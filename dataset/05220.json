{
  "Title": "[H-02] Due to missing checks on minimum gas passed through LayerZero, executions can fail on the destination chain",
  "Content": "\n<https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L148-L194> \n\n<https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L80-L111>\n\nIn LayerZero, the destination chain's function call requires a specific gas amount; otherwise, it will revert with an out-of-gas exception. It falls under the responsibility of the User Application to ensure that appropriate limits are established. These limits guide relayers in specifying the correct gas amount on the source chain, preventing users from inputting insufficient values for gas.\n\nThe contract logic in `DecentEthRouter`, assumes that a user will first get their estimated fees through `estimateSendAndCallFee()` and pass it as an argument in either `bridge()` or `bridgeWithPayload()` to be added to the calculation together with the hardcoded `GAS_FOR_RELAY` so that it can be passed as the adapter params when `CommonOFT.LzCallParams` is called, although this is not enforced and is left on the user's responsibility.\n\nA user can pass an arbitrary value as the `_dstGasForCall` argument to be added to the hardcoded `GAS_FOR_RELAY` fee, thus sending less gas than required which can lead to out-of-gas exceptions.\n\nOnce the message is received by destination, the message is considered delivered (transitioning from INFLIGHT to either SUCCESS or STORED), even though it threw an out-of-gas error.\n\nAny uncaught errors/exceptions (including out-of-gas) will cause the message to transition into STORED. A STORED message will block the delivery of any future message from source to all destination on the same destination chain and can be retried until the message becomes SUCCESS.\n\nAs per: <https://layerzero.gitbook.io/docs/faq/messaging-properties>\n\n### Proof of Concept\n\nAccording to the LayerZero integration checklist: <br><https://layerzero.gitbook.io/docs/troubleshooting/layerzero-integration-checklist>\n\nLayerZero recommends a 200,000 amount of gas to be enough for most chains and is set as default.\n\n*   \"200k for OFT for all EVMs except Arbitrum is enough. For Arbitrum, set as 2M.\"\n\nIn the DecentEthRouter, the `GAS_FOR_RELAY` is hardcoded at 100,000.\n\n            uint256 GAS_FOR_RELAY = 100000;\n            uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;\n\nThe contract logic assumes that a user would willingly first call the `estimateSendAndCallFee` to get the `nativeFee` + the `zroFee` fom `dcntEth.estimateSendAndCallFee` and then pass the addition of the nativeFee + zeroFee as the `_dstGasForCall` argument when calling `bridge()` or `bridgeWithPayload()`:\n\n        function bridgeWithPayload(\n            uint16 _dstChainId,\n            address _toAddress,\n            uint _amount,\n            bool deliverEth,\n            uint64 _dstGasForCall,\n            bytes memory additionalPayload\n        ) public payable {\n            return\n                _bridgeWithPayload(\n                    MT_ETH_TRANSFER_WITH_PAYLOAD,\n                    _dstChainId,\n                    _toAddress,\n                    _amount,\n                    _dstGasForCall,\n                    additionalPayload,\n                    deliverEth\n                );\n        }\n\nOnce the internal `_bridgeWithPayload` function is called:\n\n```\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                additionalPayload\n            );\n\n\n        ICommonOFT.LzCallParams memory callParams = ICommonOFT.LzCallParams({\n            refundAddress: payable(msg.sender),\n            zroPaymentAddress: address(0x0),\n            adapterParams: adapterParams\n        });\n\n```\n\nIt calls the `_getCallParams` function which will calculate and pack the needed arguments to be passed as the LayerZero call params, without performing any checks whether the total gas amount is sufficient or that the user passed argument `_dstGasForCall` is greater than the total of `(uint nativeFee, uint zroFee) = dcntEth.estimateSendAndCallFee`.\n\n        function _getCallParams(\n            uint8 msgType,\n            address _toAddress,\n            uint16 _dstChainId,\n            uint64 _dstGasForCall,\n            bool deliverEth,\n            bytes memory additionalPayload\n        )\n            private\n            view\n            returns (\n                bytes32 destBridge,\n                bytes memory adapterParams,\n                bytes memory payload\n            )\n        {\n            uint256 GAS_FOR_RELAY = 100000;\n            uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;\n            adapterParams = abi.encodePacked(PT_SEND_AND_CALL, gasAmount);\n\nThis can lead to failed messages on the destination. Which would yield the above-message results of a possible blockage in the communication with the source and destination.\n\n*   A malicious or an unbeknownst user can pass 1,000 as an argument for `_dstGasForCall`, making the total gas forwarded to the `LzCallParams()` 101,000 which will make a certain type of calls fail (depending on payload), and especially calls made on Arbitrum.\n\n### Recommended Mitigation Steps\n\nValidate/require that the `_dstGasForCall` parameter is greater than `nativeFee` + `zroFee` or re-engineer the architecture to make the `estimateSendAndCallFee()` function a mandatory step of the process.\n\n**[0xsomeone (Judge) increased severity to High and commented](https://github.com/code-423n4/2024-01-decent-findings/issues/525#issuecomment-1923713863):**\n > This and all duplicate exhibits highlight that the `GAS_FOR_RELAY` is a hard-coded value and that the overall gas supplied for a cross-chain call can be controlled by a user.\n> \n> A severity of high is appropriate given that the cross-chain LayerZero channel will be permanently blocked.\n> \n> None of the submissions have correctly proposed a solution as a mere adjustment of the `GAS_FOR_RELAY` is insufficient. The `DecentBridgeExecutor` permits arbitrary calls to be made that can force the transaction to run out-of-gas regardless of the gas limit imposed. This is properly defined in [#697](https://github.com/code-423n4/2024-01-decent-findings/issues/697).\n> \n> A valid solution for this problem would be a combination of a minimum enforced at the transaction level and a maximum gas consumed enforced at the executor level, ensuring that the gas remainder **after the executor performs the arbitrary call** is enough to store the failed message. This can be achieved by performing a subtraction from the `gasleft` value (hard to implement as it would need to take into account the cost of `keccak256` encoding the data payload) or by enforcing a fixed value that should be much less than the minimum imposed on the source chain.\n> \n> This submission was selected as the best given that it illustrates in-depth knowledge of the LayerZero system states and correctly highlights that a user can also maliciously block the channel.\n\n**[wkantaros (Decent) acknowledged via duplicate #212, but disagreed with severity and commented](https://github.com/code-423n4/2024-01-decent-findings/issues/212#issuecomment-1917870512):**\n> This vulnerability is not a concern in Layer Zero v2. Decent designed the contracts expecting to use LZ v2 and have since implemented this upgrade.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-decent",
  "Code": [
    {
      "filename": "src/DecentEthRouter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IDcntEth} from \"./interfaces/IDcntEth.sol\";\nimport {ICommonOFT} from \"solidity-examples/token/oft/v2/interfaces/ICommonOFT.sol\";\nimport {IOFTReceiverV2} from \"solidity-examples/token/oft/v2/interfaces/IOFTReceiverV2.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IDecentBridgeExecutor} from \"./interfaces/IDecentBridgeExecutor.sol\";\nimport {IDecentEthRouter} from \"./interfaces/IDecentEthRouter.sol\";\n\ncontract DecentEthRouter is IDecentEthRouter, IOFTReceiverV2, Owned {\n    IWETH public weth;\n    IDcntEth public dcntEth;\n    IDecentBridgeExecutor public executor;\n\n    uint8 public constant MT_ETH_TRANSFER = 0;\n    uint8 public constant MT_ETH_TRANSFER_WITH_PAYLOAD = 1;\n\n    uint16 public constant PT_SEND_AND_CALL = 1;\n\n    bool public gasCurrencyIsEth; // for chains that use ETH as gas currency\n\n    mapping(uint16 => address) public destinationBridges;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(\n        address payable _wethAddress,\n        bool gasIsEth,\n        address _executor\n    ) Owned(msg.sender) {\n        weth = IWETH(_wethAddress);\n        gasCurrencyIsEth = gasIsEth;\n        executor = IDecentBridgeExecutor(payable(_executor));\n    }\n\n    modifier onlyEthChain() {\n        require(gasCurrencyIsEth, \"Gas currency is not ETH\");\n        _;\n    }\n\n    modifier onlyLzApp() {\n        require(\n            address(dcntEth) == msg.sender,\n            \"DecentEthRouter: only lz App can call\"\n        );\n        _;\n    }\n\n    modifier onlyIfWeHaveEnoughReserves(uint256 amount) {\n        require(weth.balanceOf(address(this)) > amount, \"not enough reserves\");\n        _;\n    }\n\n    modifier userDepositing(uint256 amount) {\n        balanceOf[msg.sender] += amount;\n        _;\n    }\n\n    modifier userIsWithdrawing(uint256 amount) {\n        uint256 balance = balanceOf[msg.sender];\n        require(balance >= amount, \"not enough balance\");\n        _;\n        balanceOf[msg.sender] -= amount;\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function registerDcntEth(address _addr) public onlyOwner {\n        dcntEth = IDcntEth(_addr);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addDestinationBridge(\n        uint16 _dstChainId,\n        address _routerAddress\n    ) public onlyOwner {\n        destinationBridges[_dstChainId] = _routerAddress;\n    }\n\n    function _getCallParams(\n        uint8 msgType,\n        address _toAddress,\n        uint16 _dstChainId,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory additionalPayload\n    )\n        private\n        view\n        returns (\n            bytes32 destBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        )\n    {\n        uint256 GAS_FOR_RELAY = 100000;\n        uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;\n        adapterParams = abi.encodePacked(PT_SEND_AND_CALL, gasAmount);\n        destBridge = bytes32(abi.encode(destinationBridges[_dstChainId]));\n        if (msgType == MT_ETH_TRANSFER) {\n            payload = abi.encode(msgType, msg.sender, _toAddress, deliverEth);\n        } else {\n            payload = abi.encode(\n                msgType,\n                msg.sender,\n                _toAddress,\n                deliverEth,\n                additionalPayload\n            );\n        }\n    }\n\n    function estimateSendAndCallFee(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory payload\n    ) public view returns (uint nativeFee, uint zroFee) {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory _payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                payload\n            );\n\n        return\n            dcntEth.estimateSendAndCallFee(\n                _dstChainId,\n                destinationBridge,\n                _amount,\n                _payload,\n                _dstGasForCall,\n                false, // useZero\n                adapterParams // Relayer adapter parameters\n                // contains packet type (send and call in this case) and gasAmount\n            );\n    }\n\n    function _bridgeWithPayload(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload,\n        bool deliverEth\n    ) internal {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                additionalPayload\n            );\n\n        ICommonOFT.LzCallParams memory callParams = ICommonOFT.LzCallParams({\n            refundAddress: payable(msg.sender),\n            zroPaymentAddress: address(0x0),\n            adapterParams: adapterParams\n        });\n\n        uint gasValue;\n        if (gasCurrencyIsEth) {\n            weth.deposit{value: _amount}();\n            gasValue = msg.value - _amount;\n        } else {\n            weth.transferFrom(msg.sender, address(this), _amount);\n            gasValue = msg.value;\n        }\n\n        dcntEth.sendAndCall{value: gasValue}(\n            address(this), // from address that has dcntEth (so DecentRouter)\n            _dstChainId,\n            destinationBridge, // toAddress\n            _amount, // amount\n            payload, //payload (will have recipients address)\n            _dstGasForCall, // dstGasForCall\n            callParams // refundAddress, zroPaymentAddress, adapterParams\n        );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridgeWithPayload(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        bool deliverEth,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload\n    ) public payable {\n        return\n            _bridgeWithPayload(\n                MT_ETH_TRANSFER_WITH_PAYLOAD,\n                _dstChainId,\n                _toAddress,\n                _amount,\n                _dstGasForCall,\n                additionalPayload,\n                deliverEth\n            );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridge(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth // if false, delivers WETH\n    ) public payable {\n        _bridgeWithPayload(\n            MT_ETH_TRANSFER,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _dstGasForCall,\n            bytes(\"\"),\n            deliverEth\n        );\n    }\n\n    /// @inheritdoc IOFTReceiverV2\n    function onOFTReceived(\n        uint16 _srcChainId,\n        bytes calldata,\n        uint64,\n        bytes32,\n        uint _amount,\n        bytes memory _payload\n    ) external override onlyLzApp {\n        (uint8 msgType, address _from, address _to, bool deliverEth) = abi\n            .decode(_payload, (uint8, address, address, bool));\n\n        bytes memory callPayload = \"\";\n\n        if (msgType == MT_ETH_TRANSFER_WITH_PAYLOAD) {\n            (, , , , callPayload) = abi.decode(\n                _payload,\n                (uint8, address, address, bool, bytes)\n            );\n        }\n\n        emit ReceivedDecentEth(\n            msgType,\n            _srcChainId,\n            _from,\n            _to,\n            _amount,\n            callPayload\n        );\n\n        if (weth.balanceOf(address(this)) < _amount) {\n            dcntEth.transfer(_to, _amount);\n            return;\n        }\n\n        if (msgType == MT_ETH_TRANSFER) {\n            if (!gasCurrencyIsEth || !deliverEth) {\n                weth.transfer(_to, _amount);\n            } else {\n                weth.withdraw(_amount);\n                payable(_to).transfer(_amount);\n            }\n        } else {\n            weth.approve(address(executor), _amount);\n            executor.execute(_from, _to, deliverEth, _amount, callPayload);\n        }\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function redeemEth(\n        uint256 amount\n    ) public onlyIfWeHaveEnoughReserves(amount) {\n        dcntEth.transferFrom(msg.sender, address(this), amount);\n        weth.withdraw(amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function redeemWeth(\n        uint256 amount\n    ) public onlyIfWeHaveEnoughReserves(amount) {\n        dcntEth.transferFrom(msg.sender, address(this), amount);\n        weth.transfer(msg.sender, amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityEth()\n        public\n        payable\n        onlyEthChain\n        userDepositing(msg.value)\n    {\n        weth.deposit{value: msg.value}();\n        dcntEth.mint(address(this), msg.value);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityEth(\n        uint256 amount\n    ) public onlyEthChain userIsWithdrawing(amount) {\n        dcntEth.burn(address(this), amount);\n        weth.withdraw(amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityWeth(\n        uint256 amount\n    ) public payable userDepositing(amount) {\n        weth.transferFrom(msg.sender, address(this), amount);\n        dcntEth.mint(address(this), amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityWeth(\n        uint256 amount\n    ) public userIsWithdrawing(amount) {\n        dcntEth.burn(address(this), amount);\n        weth.transfer(msg.sender, amount);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/DecentEthRouter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IDcntEth} from \"./interfaces/IDcntEth.sol\";\nimport {ICommonOFT} from \"solidity-examples/token/oft/v2/interfaces/ICommonOFT.sol\";\nimport {IOFTReceiverV2} from \"solidity-examples/token/oft/v2/interfaces/IOFTReceiverV2.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IDecentBridgeExecutor} from \"./interfaces/IDecentBridgeExecutor.sol\";\nimport {IDecentEthRouter} from \"./interfaces/IDecentEthRouter.sol\";\n\ncontract DecentEthRouter is IDecentEthRouter, IOFTReceiverV2, Owned {\n    IWETH public weth;\n    IDcntEth public dcntEth;\n    IDecentBridgeExecutor public executor;\n\n    uint8 public constant MT_ETH_TRANSFER = 0;\n    uint8 public constant MT_ETH_TRANSFER_WITH_PAYLOAD = 1;\n\n    uint16 public constant PT_SEND_AND_CALL = 1;\n\n    bool public gasCurrencyIsEth; // for chains that use ETH as gas currency\n\n    mapping(uint16 => address) public destinationBridges;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(\n        address payable _wethAddress,\n        bool gasIsEth,\n        address _executor\n    ) Owned(msg.sender) {\n        weth = IWETH(_wethAddress);\n        gasCurrencyIsEth = gasIsEth;\n        executor = IDecentBridgeExecutor(payable(_executor));\n    }\n\n    modifier onlyEthChain() {\n        require(gasCurrencyIsEth, \"Gas currency is not ETH\");\n        _;\n    }\n\n    modifier onlyLzApp() {\n        require(\n            address(dcntEth) == msg.sender,\n            \"DecentEthRouter: only lz App can call\"\n        );\n        _;\n    }\n\n    modifier onlyIfWeHaveEnoughReserves(uint256 amount) {\n        require(weth.balanceOf(address(this)) > amount, \"not enough reserves\");\n        _;\n    }\n\n    modifier userDepositing(uint256 amount) {\n        balanceOf[msg.sender] += amount;\n        _;\n    }\n\n    modifier userIsWithdrawing(uint256 amount) {\n        uint256 balance = balanceOf[msg.sender];\n        require(balance >= amount, \"not enough balance\");\n        _;\n        balanceOf[msg.sender] -= amount;\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function registerDcntEth(address _addr) public onlyOwner {\n        dcntEth = IDcntEth(_addr);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addDestinationBridge(\n        uint16 _dstChainId,\n        address _routerAddress\n    ) public onlyOwner {\n        destinationBridges[_dstChainId] = _routerAddress;\n    }\n\n    function _getCallParams(\n        uint8 msgType,\n        address _toAddress,\n        uint16 _dstChainId,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory additionalPayload\n    )\n        private\n        view\n        returns (\n            bytes32 destBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        )\n    {\n        uint256 GAS_FOR_RELAY = 100000;\n        uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;\n        adapterParams = abi.encodePacked(PT_SEND_AND_CALL, gasAmount);\n        destBridge = bytes32(abi.encode(destinationBridges[_dstChainId]));\n        if (msgType == MT_ETH_TRANSFER) {\n            payload = abi.encode(msgType, msg.sender, _toAddress, deliverEth);\n        } else {\n            payload = abi.encode(\n                msgType,\n                msg.sender,\n                _toAddress,\n                deliverEth,\n                additionalPayload\n            );\n        }\n    }\n\n    function estimateSendAndCallFee(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory payload\n    ) public view returns (uint nativeFee, uint zroFee) {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory _payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                payload\n            );\n\n        return\n            dcntEth.estimateSendAndCallFee(\n                _dstChainId,\n                destinationBridge,\n                _amount,\n                _payload,\n                _dstGasForCall,\n                false, // useZero\n                adapterParams // Relayer adapter parameters\n                // contains packet type (send and call in this case) and gasAmount\n            );\n    }\n\n    function _bridgeWithPayload(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload,\n        bool deliverEth\n    ) internal {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                additionalPayload\n            );\n\n        ICommonOFT.LzCallParams memory callParams = ICommonOFT.LzCallParams({\n            refundAddress: payable(msg.sender),\n            zroPaymentAddress: address(0x0),\n            adapterParams: adapterParams\n        });\n\n        uint gasValue;\n        if (gasCurrencyIsEth) {\n            weth.deposit{value: _amount}();\n            gasValue = msg.value - _amount;\n        } else {\n            weth.transferFrom(msg.sender, address(this), _amount);\n            gasValue = msg.value;\n        }\n\n        dcntEth.sendAndCall{value: gasValue}(\n            address(this), // from address that has dcntEth (so DecentRouter)\n            _dstChainId,\n            destinationBridge, // toAddress\n            _amount, // amount\n            payload, //payload (will have recipients address)\n            _dstGasForCall, // dstGasForCall\n            callParams // refundAddress, zroPaymentAddress, adapterParams\n        );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridgeWithPayload(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        bool deliverEth,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload\n    ) public payable {\n        return\n            _bridgeWithPayload(\n                MT_ETH_TRANSFER_WITH_PAYLOAD,\n                _dstChainId,\n                _toAddress,\n                _amount,\n                _dstGasForCall,\n                additionalPayload,\n                deliverEth\n            );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridge(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth // if false, delivers WETH\n    ) public payable {\n        _bridgeWithPayload(\n            MT_ETH_TRANSFER,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _dstGasForCall,\n            bytes(\"\"),\n            deliverEth\n        );\n    }\n\n    /// @inheritdoc IOFTReceiverV2\n    function onOFTReceived(\n        uint16 _srcChainId,\n        bytes calldata,\n        uint64,\n        bytes32,\n        uint _amount,\n        bytes memory _payload\n    ) external override onlyLzApp {\n        (uint8 msgType, address _from, address _to, bool deliverEth) = abi\n            .decode(_payload, (uint8, address, address, bool));\n\n        bytes memory callPayload = \"\";\n\n        if (msgType == MT_ETH_TRANSFER_WITH_PAYLOAD) {\n            (, , , , callPayload) = abi.decode(\n                _payload,\n                (uint8, address, address, bool, bytes)\n            );\n        }\n\n        emit ReceivedDecentEth(\n            msgType,\n            _srcChainId,\n            _from,\n            _to,\n            _amount,\n            callPayload\n        );\n\n        if (weth.balanceOf(address(this)) < _amount) {\n            dcntEth.transfer(_to, _amount);\n            return;\n        }\n\n        if (msgType == MT_ETH_TRANSFER) {\n            if (!gasCurrencyIsEth || !deliverEth) {\n                weth.transfer(_to, _amount);\n            } else {\n                weth.withdraw(_amount);\n                payable(_to).transfer(_amount);\n            }\n        } else {\n            weth.approve(address(executor), _amount);\n            executor.execute(_from, _to, deliverEth, _amount, callPayload);\n        }\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function redeemEth(\n        uint256 amount\n    ) public onlyIfWeHaveEnoughReserves(amount) {\n        dcntEth.transferFrom(msg.sender, address(this), amount);\n        weth.withdraw(amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function redeemWeth(\n        uint256 amount\n    ) public onlyIfWeHaveEnoughReserves(amount) {\n        dcntEth.transferFrom(msg.sender, address(this), amount);\n        weth.transfer(msg.sender, amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityEth()\n        public\n        payable\n        onlyEthChain\n        userDepositing(msg.value)\n    {\n        weth.deposit{value: msg.value}();\n        dcntEth.mint(address(this), msg.value);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityEth(\n        uint256 amount\n    ) public onlyEthChain userIsWithdrawing(amount) {\n        dcntEth.burn(address(this), amount);\n        weth.withdraw(amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityWeth(\n        uint256 amount\n    ) public payable userDepositing(amount) {\n        weth.transferFrom(msg.sender, address(this), amount);\n        dcntEth.mint(address(this), amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityWeth(\n        uint256 amount\n    ) public userIsWithdrawing(amount) {\n        dcntEth.burn(address(this), amount);\n        weth.transfer(msg.sender, amount);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    }
  ]
}