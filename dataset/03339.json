{
  "Title": "Unnecessary safeMath",
  "Content": "##### Description\nsafeMath here is unnecessary:\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/core/WETHGateway.sol#L192\n##### Recommendation\nWe recommend not to use safeMath here.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/WETHGateway.sol",
      "content": "// SPDX-License-Identifier: BSL-1.1\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {AddressProvider} from \"./AddressProvider.sol\";\nimport {ContractsRegister} from \"./ContractsRegister.sol\";\n\nimport {IPoolService} from \"../interfaces/IPoolService.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\nimport {IWETH} from \"../interfaces/external/IWETH.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\n\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {Constants} from \"../libraries/helpers/Constants.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title WETHGateway\n/// @notice Used for converting ETH <> WETH\ncontract WETHGateway is IWETHGateway {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    address public wethAddress;\n    ContractsRegister internal _contractsRegister;\n\n    /// @dev Checks that pool is registered and underlying token is WETH\n    modifier wethPoolOnly(address pool) {\n        // Could be optimised by adding internal list of pools\n        require(\n            _contractsRegister.isPool(pool),\n            Errors.WG_DESTINATION_IS_NOT_POOL\n        ); // T:[WG-1]\n\n        require(\n            IPoolService(pool).underlyingToken() == wethAddress,\n            Errors.WG_DESTINATION_IS_NOT_WETH_COMPATIBLE\n        ); // T:[WG-2]\n        _;\n    }\n\n    /// @dev Checks that credit manager is registered and underlying token is WETH\n    modifier wethCreditManagerOnly(address creditManager) {\n        // Could be optimised by adding internal list of creditManagers\n\n        require(\n            _contractsRegister.isCreditManager(creditManager),\n            Errors.WG_DESTINATION_IS_NOT_CREDIT_MANAGER\n        ); // T:[WG-3]\n\n        require(\n            ICreditManager(creditManager).underlyingToken() == wethAddress,\n            Errors.WG_DESTINATION_IS_NOT_WETH_COMPATIBLE\n        ); // T:[WG-4]\n\n        _;\n    }\n\n    /// @dev Checks that credit manager is registered\n    modifier creditManagerOnly(address creditManager) {\n        // Could be optimised by adding internal list of creditManagers\n\n        require(\n            _contractsRegister.isCreditManager(creditManager),\n            Errors.WG_DESTINATION_IS_NOT_CREDIT_MANAGER\n        ); // T:[WG-3]\n\n        _;\n    }\n\n    //\n    // CONSTRUCTOR\n    //\n\n    /// @dev Constructor\n    /// @param addressProvider Address Repository for upgradable contract model\n    constructor(address addressProvider) {\n        wethAddress = AddressProvider(addressProvider).getWethToken();\n        _contractsRegister = ContractsRegister(\n            AddressProvider(addressProvider).getContractsRegister()\n        );\n    }\n\n    /// @dev convert ETH to WETH and add liqudity to pool\n    /// @param pool Address of PoolService contract which where user wants to add liquidity. This pool should has WETH as underlying asset\n    /// @param onBehalfOf The address that will receive the diesel tokens, same as msg.sender if the user  wants to receive them on his\n    ///                   own wallet, or a different address if the beneficiary of diesel tokens is a different wallet\n    /// @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n    /// 0 if the action is executed directly by the user, without any middle-man\n    function addLiquidityETH(\n        address pool,\n        address onBehalfOf,\n        uint16 referralCode\n    )\n        external\n        payable\n        override\n        wethPoolOnly(pool) // T:[WG-1, 2]\n    {\n        IWETH(wethAddress).deposit{value: msg.value}(); // T:[WG-8]\n\n        _checkAllowance(pool, msg.value); // T:[WG-8]\n        IPoolService(pool).addLiquidity(msg.value, onBehalfOf, referralCode); // T:[WG-8]\n    }\n\n    /// @dev Removes liquidity from pool and convert WETH to ETH\n    ///       - burns lp's diesel (LP) tokens\n    ///       - returns underlying tokens to lp\n    /// @param pool Address of PoolService contract which where user wants to withdraw liquidity. This pool should has WETH as underlying asset\n    /// @param amount Amount of tokens to be transfer\n    /// @param to Address to transfer liquidity\n    function removeLiquidityETH(\n        address pool,\n        uint256 amount,\n        address payable to\n    )\n        external\n        override\n        wethPoolOnly(pool) // T:[WG-1, 2]\n    {\n        IERC20(IPoolService(pool).dieselToken()).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        ); // T: [WG-9]\n\n        uint256 amountGet = IPoolService(pool).removeLiquidity(\n            amount,\n            address(this)\n        ); // T: [WG-9]\n        _unwrapWETH(to, amountGet); // T: [WG-9]\n    }\n\n    /// @dev Opens credit account in ETH\n    /// @param creditManager Address of credit Manager. Should used WETH as underlying asset\n    /// @param onBehalfOf The address that we open credit account. Same as msg.sender if the user wants to open it for  his own wallet,\n    ///                   or a different address if the beneficiary is a different wallet\n    /// @param leverageFactor Multiplier to borrowers own funds\n    /// @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n    ///                     0 if the action is executed directly by the user, without any middle-man\n    function openCreditAccountETH(\n        address creditManager,\n        address payable onBehalfOf,\n        uint256 leverageFactor,\n        uint256 referralCode\n    )\n        external\n        payable\n        override\n        wethCreditManagerOnly(creditManager) // T:[WG-3, 4]\n    {\n        _checkAllowance(creditManager, msg.value); // T:[WG-10]\n\n        IWETH(wethAddress).deposit{value: msg.value}(); // T:[WG-10]\n        ICreditManager(creditManager).openCreditAccount(\n            msg.value,\n            onBehalfOf,\n            leverageFactor,\n            referralCode\n        ); // T:[WG-10]\n    }\n\n    /// @dev Repays credit account in ETH\n    ///       - transfer borrowed money with interest + fee from borrower account to pool\n    ///       - transfer all assets to \"to\" account\n    /// @param creditManager Address of credit Manager. Should used WETH as underlying asset\n    /// @param to Address to send credit account assets\n    function repayCreditAccountETH(address creditManager, address to)\n        external\n        payable\n        override\n        wethCreditManagerOnly(creditManager) // T:[WG-3, 4]\n    {\n        uint256 amount = msg.value; // T: [WG-11]\n\n        IWETH(wethAddress).deposit{value: amount}(); // T: [WG-11]\n//        address pool = ICreditManager(creditManager).poolService(); // T: [WG-11]\n        _checkAllowance(creditManager, amount); // T: [WG-11]\n\n        // This function is protected from reentrant attack\n        uint256 repayAmount = ICreditManager(creditManager)\n        .repayCreditAccountETH(msg.sender, to); // T: [WG-11, 13]\n\n        if (amount > repayAmount) {\n            IWETH(wethAddress).withdraw(amount.sub(repayAmount));\n            msg.sender.sendValue(amount.sub(repayAmount)); // T: [WG-12]\n        }\n    }\n\n    function addCollateralETH(address creditManager, address onBehalfOf)\n        external\n        payable\n        override\n        creditManagerOnly(creditManager)\n    {\n        uint256 amount = msg.value; // T:[WG-14]\n\n        IWETH(wethAddress).deposit{value: amount}(); // T:[WG-14]\n        _checkAllowance(creditManager, amount); // T:[WG-14]\n        ICreditManager(creditManager).addCollateral(\n            onBehalfOf,\n            wethAddress,\n            amount\n        ); // T:[WG-14]\n    }\n\n    /// @dev Converts WETH to ETH, it's used when credit manager sends tokens, and one of them is WETH\n    function unwrapWETH(address to, uint256 amount)\n        external\n        override\n        creditManagerOnly(msg.sender) // T:[WG-5]\n    {\n        _unwrapWETH(to, amount); // T: [WG-7]\n    }\n\n    function _unwrapWETH(address to, uint256 amount) internal {\n        IWETH(wethAddress).withdraw(amount); // T: [WG-7]\n        payable(to).sendValue(amount); // T: [WG-7]\n    }\n\n    function _checkAllowance(address spender, uint256 amount) internal {\n        if (IERC20(wethAddress).allowance(address(this), spender) < amount) {\n            IERC20(wethAddress).approve(spender, Constants.MAX_INT);\n        }\n    }\n\n    /// @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n    receive() external payable {\n        require(\n            msg.sender == address(wethAddress),\n            Errors.WG_RECEIVE_IS_NOT_ALLOWED\n        ); // T:[WG-6]\n    }\n}"
    }
  ]
}