{
  "Title": "[13] Splitting `require()` statements that use `&&` saves gas",
  "Content": "\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: notional-wrapped-fcash/contracts/wfCashLogic.sol   #1\n\n116           require(\n117               msg.sender == address(NotionalV2) &&\n118               // Only accept the fcash id that corresponds to the listed currency and maturity\n119               _id == fCashID &&\n120               // Protect against signed value underflows\n121               int256(_value) > 0,\n122               \"Invalid\"\n123:          );\n```\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashLogic.sol#L116-L123>\n\n```solidity\nFile: notional-wrapped-fcash/contracts/wfCashLogic.sol   #2\n\n129           require(\n130               ac.hasDebt == 0x00 &&\n131               assets.length == 1 &&\n132               EncodeDecode.encodeERC1155Id(\n133                   assets[0].currencyId,\n134                   assets[0].maturity,\n135                   assets[0].assetType\n136               ) == fCashID\n137:          );\n```\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashLogic.sol#L129-L137>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-06-notional-coop",
  "Code": [
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashLogic.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\npragma experimental ABIEncoderV2;\n\nimport \"./wfCashBase.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @dev This implementation contract is deployed as an UpgradeableBeacon. Each BeaconProxy\n/// that uses this contract as an implementation will call initialize to set its own fCash id.\n/// That identifier will represent the fCash that this ERC20 wrapper can hold.\nabstract contract wfCashLogic is wfCashBase, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\n\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashBase(_notional, _weth) {}\n\n    /***** Mint Methods *****/\n\n    /// @notice Lends deposit amount in return for fCashAmount using cTokens or aTokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaAsset(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, false);\n    }\n\n    /// @notice Lends deposit amount in return for fCashAmount using underlying tokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaUnderlying(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, true);\n    }\n\n    function _mintInternal(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate,\n        bool useUnderlying\n    ) internal nonReentrant {\n        require(!hasMatured(), \"fCash matured\");\n        (IERC20 token, bool isETH) = getToken(useUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses\n        // ETH natively but due to pull payment requirements for batchLend, it does not support\n        // ETH. batchLend only supports ERC20 tokens like cETH or aETH. Since the wrapper is a compatibility\n        // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using\n        // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"\n        // is more gas efficient (does not require and additional redeem call to asset tokens). If using cETH\n        // then everything will proceed via batchLend.\n        if (isETH) {\n            IERC20((address(WETH))).safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n            WETH.withdraw(depositAmountExternal);\n\n            BalanceActionWithTrades[] memory action = EncodeDecode.encodeLendETHTrade(\n                getCurrencyId(),\n                getMarketIndex(),\n                depositAmountExternal,\n                fCashAmount,\n                minImpliedRate\n            );\n            // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those\n            // native ETH tokens will be wrapped back to WETH.\n            NotionalV2.batchBalanceAndTradeAction{value: depositAmountExternal}(address(this), action);\n        } else {\n            // Transfers tokens in for lending, Notional will transfer from this contract.\n            token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n\n            // Executes a lending action on Notional\n            BatchLend[] memory action = EncodeDecode.encodeLendTrade(\n                getCurrencyId(),\n                getMarketIndex(),\n                fCashAmount,\n                minImpliedRate,\n                useUnderlying\n            );\n            NotionalV2.batchLend(address(this), action);\n        }\n\n        // Mints ERC20 tokens for the receiver, the false flag denotes that we will not do an\n        // operatorAck\n        _mint(receiver, fCashAmount, \"\", \"\", false);\n\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n    }\n\n    /// @notice This hook will be called every time this contract receives fCash, will validate that\n    /// this is the correct fCash and then mint the corresponding amount of wrapped fCash tokens\n    /// back to the user.\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external nonReentrant returns (bytes4) {\n        uint256 fCashID = getfCashId();\n        // Only accept erc1155 transfers from NotionalV2\n        require(\n            msg.sender == address(NotionalV2) &&\n            // Only accept the fcash id that corresponds to the listed currency and maturity\n            _id == fCashID &&\n            // Protect against signed value underflows\n            int256(_value) > 0,\n            \"Invalid\"\n        );\n\n        // Double check the account's position, these are not strictly necessary and add gas costs\n        // but might be good safe guards\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));\n        require(\n            ac.hasDebt == 0x00 &&\n            assets.length == 1 &&\n            EncodeDecode.encodeERC1155Id(\n                assets[0].currencyId,\n                assets[0].maturity,\n                assets[0].assetType\n            ) == fCashID\n        );\n\n        // Update per account fCash balance, calldata from the ERC1155 call is\n        // passed via the ERC777 interface.\n        bytes memory userData;\n        bytes memory operatorData;\n        if (_operator == _from) userData = _data;\n        else operatorData = _data;\n\n        // We don't require a recipient ack here to maintain compatibility\n        // with contracts that don't support ERC777\n        _mint(_from, _value, userData, operatorData, false);\n\n        // This will allow the fCash to be accepted\n        return ERC1155_ACCEPTED;\n    }\n\n    /***** Redeem (Burn) Methods *****/\n\n    /// @notice Redeems tokens using custom options\n    /// @dev re-entrancy is protected on _burn\n    function redeem(uint256 amount, RedeemOpts memory opts) public override {\n        bytes memory data = abi.encode(opts);\n        // In this case, the owner is msg.sender based on the OZ ERC777 implementation\n        burn(amount, data);\n    }\n\n    /// @notice Redeems tokens to asset tokens\n    /// @dev re-entrancy is protected on _burn\n    function redeemToAsset(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        redeem(\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: false,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice Redeems tokens to underlying\n    /// @dev re-entrancy is protected on _burn\n    function redeemToUnderlying(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        redeem(\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice Called before tokens are burned (redemption) and so we will handle\n    /// the fCash properly before and after maturity.\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) internal override nonReentrant {\n        // Save the total supply value before burning to calculate the cash claim share\n        uint256 initialTotalSupply = totalSupply();\n        RedeemOpts memory opts = abi.decode(userData, (RedeemOpts));\n        require(opts.receiver != address(0), \"Receiver is zero address\");\n        // This will validate that the account has sufficient tokens to burn and make\n        // any relevant underlying stateful changes to balances.\n        super._burn(from, amount, userData, operatorData);\n\n        if (hasMatured()) {\n            // If the fCash has matured, then we need to ensure that the account is settled\n            // and then we will transfer back the account's share of asset tokens.\n\n            // This is a noop if the account is already settled\n            NotionalV2.settleAccount(address(this));\n            uint16 currencyId = getCurrencyId();\n\n            (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n            require(0 < cashBalance, \"Negative Cash Balance\");\n\n            // This always rounds down in favor of the wrapped fCash contract.\n            uint256 assetInternalCashClaim = (uint256(cashBalance) * amount) / initialTotalSupply;\n\n            // Transfer withdrawn tokens to the `from` address\n            _withdrawCashToAccount(\n                currencyId,\n                opts.receiver,\n                _safeUint88(assetInternalCashClaim),\n                opts.redeemToUnderlying\n            );\n        } else if (opts.transferfCash) {\n            // If the fCash has not matured, then we can transfer it via ERC1155.\n            // NOTE: this may fail if the destination is a contract and it does not implement \n            // the `onERC1155Received` hook. If that is the case it is possible to use a regular\n            // ERC20 transfer on this contract instead.\n            NotionalV2.safeTransferFrom(\n                address(this), // Sending from this contract\n                opts.receiver, // Where to send the fCash\n                getfCashId(), // fCash identifier\n                amount, // Amount of fCash to send\n                userData\n            );\n        } else {\n            _sellfCash(\n                opts.receiver,\n                amount,\n                opts.redeemToUnderlying,\n                opts.maxImpliedRate\n            );\n        }\n    }\n\n    /// @notice After maturity, withdraw cash back to account\n    function _withdrawCashToAccount(\n        uint16 currencyId,\n        address receiver,\n        uint88 assetInternalCashClaim,\n        bool toUnderlying\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(toUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        NotionalV2.withdraw(currencyId, assetInternalCashClaim, toUnderlying);\n\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    /// @dev Sells an fCash share back on the Notional AMM\n    function _sellfCash(\n        address receiver,\n        uint256 fCashToSell,\n        bool toUnderlying,\n        uint32 maxImpliedRate\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(toUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        // Sells fCash on Notional AMM (via borrowing)\n        BalanceActionWithTrades[] memory action = EncodeDecode.encodeBorrowTrade(\n            getCurrencyId(),\n            getMarketIndex(),\n            _safeUint88(fCashToSell),\n            maxImpliedRate,\n            toUnderlying\n        );\n        NotionalV2.batchBalanceAndTradeAction(address(this), action);\n\n        // Send borrowed cash back to receiver\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    function _sendTokensToReceiver(\n        IERC20 token,\n        address receiver,\n        bool isETH,\n        uint256 balanceBefore\n    ) private returns (uint256 tokensTransferred) {\n        uint256 balanceAfter = isETH ? address(this).balance : token.balanceOf(address(this));\n        tokensTransferred = balanceAfter - balanceBefore;\n\n        if (isETH) {\n            WETH.deposit{value: tokensTransferred}();\n            IERC20(address(WETH)).safeTransfer(receiver, tokensTransferred);\n        } else {\n            token.safeTransfer(receiver, tokensTransferred);\n        }\n    }\n\n    function _safeUint88(uint256 x) internal pure returns (uint88) {\n        require(x <= uint256(type(uint88).max));\n        return uint88(x);\n    }\n}"
    },
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashLogic.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\npragma experimental ABIEncoderV2;\n\nimport \"./wfCashBase.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @dev This implementation contract is deployed as an UpgradeableBeacon. Each BeaconProxy\n/// that uses this contract as an implementation will call initialize to set its own fCash id.\n/// That identifier will represent the fCash that this ERC20 wrapper can hold.\nabstract contract wfCashLogic is wfCashBase, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\n\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashBase(_notional, _weth) {}\n\n    /***** Mint Methods *****/\n\n    /// @notice Lends deposit amount in return for fCashAmount using cTokens or aTokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaAsset(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, false);\n    }\n\n    /// @notice Lends deposit amount in return for fCashAmount using underlying tokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaUnderlying(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, true);\n    }\n\n    function _mintInternal(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate,\n        bool useUnderlying\n    ) internal nonReentrant {\n        require(!hasMatured(), \"fCash matured\");\n        (IERC20 token, bool isETH) = getToken(useUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses\n        // ETH natively but due to pull payment requirements for batchLend, it does not support\n        // ETH. batchLend only supports ERC20 tokens like cETH or aETH. Since the wrapper is a compatibility\n        // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using\n        // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"\n        // is more gas efficient (does not require and additional redeem call to asset tokens). If using cETH\n        // then everything will proceed via batchLend.\n        if (isETH) {\n            IERC20((address(WETH))).safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n            WETH.withdraw(depositAmountExternal);\n\n            BalanceActionWithTrades[] memory action = EncodeDecode.encodeLendETHTrade(\n                getCurrencyId(),\n                getMarketIndex(),\n                depositAmountExternal,\n                fCashAmount,\n                minImpliedRate\n            );\n            // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those\n            // native ETH tokens will be wrapped back to WETH.\n            NotionalV2.batchBalanceAndTradeAction{value: depositAmountExternal}(address(this), action);\n        } else {\n            // Transfers tokens in for lending, Notional will transfer from this contract.\n            token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n\n            // Executes a lending action on Notional\n            BatchLend[] memory action = EncodeDecode.encodeLendTrade(\n                getCurrencyId(),\n                getMarketIndex(),\n                fCashAmount,\n                minImpliedRate,\n                useUnderlying\n            );\n            NotionalV2.batchLend(address(this), action);\n        }\n\n        // Mints ERC20 tokens for the receiver, the false flag denotes that we will not do an\n        // operatorAck\n        _mint(receiver, fCashAmount, \"\", \"\", false);\n\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n    }\n\n    /// @notice This hook will be called every time this contract receives fCash, will validate that\n    /// this is the correct fCash and then mint the corresponding amount of wrapped fCash tokens\n    /// back to the user.\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external nonReentrant returns (bytes4) {\n        uint256 fCashID = getfCashId();\n        // Only accept erc1155 transfers from NotionalV2\n        require(\n            msg.sender == address(NotionalV2) &&\n            // Only accept the fcash id that corresponds to the listed currency and maturity\n            _id == fCashID &&\n            // Protect against signed value underflows\n            int256(_value) > 0,\n            \"Invalid\"\n        );\n\n        // Double check the account's position, these are not strictly necessary and add gas costs\n        // but might be good safe guards\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));\n        require(\n            ac.hasDebt == 0x00 &&\n            assets.length == 1 &&\n            EncodeDecode.encodeERC1155Id(\n                assets[0].currencyId,\n                assets[0].maturity,\n                assets[0].assetType\n            ) == fCashID\n        );\n\n        // Update per account fCash balance, calldata from the ERC1155 call is\n        // passed via the ERC777 interface.\n        bytes memory userData;\n        bytes memory operatorData;\n        if (_operator == _from) userData = _data;\n        else operatorData = _data;\n\n        // We don't require a recipient ack here to maintain compatibility\n        // with contracts that don't support ERC777\n        _mint(_from, _value, userData, operatorData, false);\n\n        // This will allow the fCash to be accepted\n        return ERC1155_ACCEPTED;\n    }\n\n    /***** Redeem (Burn) Methods *****/\n\n    /// @notice Redeems tokens using custom options\n    /// @dev re-entrancy is protected on _burn\n    function redeem(uint256 amount, RedeemOpts memory opts) public override {\n        bytes memory data = abi.encode(opts);\n        // In this case, the owner is msg.sender based on the OZ ERC777 implementation\n        burn(amount, data);\n    }\n\n    /// @notice Redeems tokens to asset tokens\n    /// @dev re-entrancy is protected on _burn\n    function redeemToAsset(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        redeem(\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: false,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice Redeems tokens to underlying\n    /// @dev re-entrancy is protected on _burn\n    function redeemToUnderlying(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        redeem(\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice Called before tokens are burned (redemption) and so we will handle\n    /// the fCash properly before and after maturity.\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) internal override nonReentrant {\n        // Save the total supply value before burning to calculate the cash claim share\n        uint256 initialTotalSupply = totalSupply();\n        RedeemOpts memory opts = abi.decode(userData, (RedeemOpts));\n        require(opts.receiver != address(0), \"Receiver is zero address\");\n        // This will validate that the account has sufficient tokens to burn and make\n        // any relevant underlying stateful changes to balances.\n        super._burn(from, amount, userData, operatorData);\n\n        if (hasMatured()) {\n            // If the fCash has matured, then we need to ensure that the account is settled\n            // and then we will transfer back the account's share of asset tokens.\n\n            // This is a noop if the account is already settled\n            NotionalV2.settleAccount(address(this));\n            uint16 currencyId = getCurrencyId();\n\n            (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n            require(0 < cashBalance, \"Negative Cash Balance\");\n\n            // This always rounds down in favor of the wrapped fCash contract.\n            uint256 assetInternalCashClaim = (uint256(cashBalance) * amount) / initialTotalSupply;\n\n            // Transfer withdrawn tokens to the `from` address\n            _withdrawCashToAccount(\n                currencyId,\n                opts.receiver,\n                _safeUint88(assetInternalCashClaim),\n                opts.redeemToUnderlying\n            );\n        } else if (opts.transferfCash) {\n            // If the fCash has not matured, then we can transfer it via ERC1155.\n            // NOTE: this may fail if the destination is a contract and it does not implement \n            // the `onERC1155Received` hook. If that is the case it is possible to use a regular\n            // ERC20 transfer on this contract instead.\n            NotionalV2.safeTransferFrom(\n                address(this), // Sending from this contract\n                opts.receiver, // Where to send the fCash\n                getfCashId(), // fCash identifier\n                amount, // Amount of fCash to send\n                userData\n            );\n        } else {\n            _sellfCash(\n                opts.receiver,\n                amount,\n                opts.redeemToUnderlying,\n                opts.maxImpliedRate\n            );\n        }\n    }\n\n    /// @notice After maturity, withdraw cash back to account\n    function _withdrawCashToAccount(\n        uint16 currencyId,\n        address receiver,\n        uint88 assetInternalCashClaim,\n        bool toUnderlying\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(toUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        NotionalV2.withdraw(currencyId, assetInternalCashClaim, toUnderlying);\n\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    /// @dev Sells an fCash share back on the Notional AMM\n    function _sellfCash(\n        address receiver,\n        uint256 fCashToSell,\n        bool toUnderlying,\n        uint32 maxImpliedRate\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(toUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        // Sells fCash on Notional AMM (via borrowing)\n        BalanceActionWithTrades[] memory action = EncodeDecode.encodeBorrowTrade(\n            getCurrencyId(),\n            getMarketIndex(),\n            _safeUint88(fCashToSell),\n            maxImpliedRate,\n            toUnderlying\n        );\n        NotionalV2.batchBalanceAndTradeAction(address(this), action);\n\n        // Send borrowed cash back to receiver\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    function _sendTokensToReceiver(\n        IERC20 token,\n        address receiver,\n        bool isETH,\n        uint256 balanceBefore\n    ) private returns (uint256 tokensTransferred) {\n        uint256 balanceAfter = isETH ? address(this).balance : token.balanceOf(address(this));\n        tokensTransferred = balanceAfter - balanceBefore;\n\n        if (isETH) {\n            WETH.deposit{value: tokensTransferred}();\n            IERC20(address(WETH)).safeTransfer(receiver, tokensTransferred);\n        } else {\n            token.safeTransfer(receiver, tokensTransferred);\n        }\n    }\n\n    function _safeUint88(uint256 x) internal pure returns (uint88) {\n        require(x <= uint256(type(uint88).max));\n        return uint88(x);\n    }\n}"
    }
  ]
}