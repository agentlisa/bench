{
  "Title": "[G-16] `MergingPool.pickWinner()` and `MergingPool.claimRewards()` can be refactored so that users don't have to iterate through the entire array of winners for every round",
  "Content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/MergingPool.sol#L151-L153\n\n### Description\n\nNotice how `claimRewards()` detects if the caller has rewards to claim in a round:\n```solidity\n            winnersLength = winnerAddresses[currentRound].length;\n            for (uint32 j = 0; j < winnersLength; j++) {\n                if (msg.sender == winnerAddresses[currentRound][j]) {\n```\nThis method is very gas inefficient since `winnerAddresses` is in storage.\n\n### Recommended Fix\n\nInstead of iterating through all the winner addresses in every round, `MergingPool.pickWinner()` and `MergingPool.claimRewards()` could be refactored to increment a new state variable tracking number of rewards (per round, if desired).\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/MergingPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterFarm } from \"./FighterFarm.sol\";\n\n/// @title MergingPool\n/// @author ArenaX Labs Inc.\n/// @notice This contract allows users to potentially earn a new fighter NFT.\ncontract MergingPool {\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when merging pool points are added.\n    event PointsAdded(uint256 tokenId, uint256 points);\n\n    /// @notice Event emitted when claimed.\n    event Claimed(address claimer, uint32 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of winners per period.\n    uint256 public winnersPerPeriod = 2;\n\n    /// @notice Current roundId.\n    uint256 public roundId = 0;\n\n    /// @notice Total points.\n    uint256 public totalPoints = 0;    \n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// The address of the ranked battle contract.\n    address _rankedBattleAddress;\n\n    /// @dev The fighter farm contract instance.\n    FighterFarm _fighterFarmInstance;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps the user address to the number of rounds they've claimed for\n    mapping(address => uint32) public numRoundsClaimed;\n\n    /// @notice Mapping of address to fighter points.\n    mapping(uint256 => uint256) public fighterPoints;\n\n    /// @notice Mapping of roundId to winner addresses list.\n    mapping(uint256 => address[]) public winnerAddresses;    \n\n    /// @notice Mapping of round id to an indication of whether winners have been selected yet.\n    mapping(uint256 => bool) public isSelectionComplete;\n\n    /// @notice Mapping of address to admin status.\n    mapping(address => bool) public isAdmin;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the address for the owner and ranked battle smart contract.\n    /// Instantiates the fighter farm contract and sets the owner to be an admin\n    /// @param ownerAddress Address of contract deployer.\n    /// @param rankedBattleAddress Address of ranked battle contract.\n    /// @param fighterFarmAddress Address of fighter farm contract.\n    constructor(\n        address ownerAddress, \n        address rankedBattleAddress, \n        address fighterFarmAddress\n    ) {\n        _ownerAddress = ownerAddress;\n        _rankedBattleAddress = rankedBattleAddress;\n        _fighterFarmInstance = FighterFarm(fighterFarmAddress);\n        isAdmin[_ownerAddress] = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }   \n\n    /// @notice Change the number of winners per competition period.\n    /// @dev Only admins are authorized to call this function.\n    /// @param newWinnersPerPeriodAmount The new number of winners per period.\n    function updateWinnersPerPeriod(uint256 newWinnersPerPeriodAmount) external {\n        require(isAdmin[msg.sender]);\n        winnersPerPeriod = newWinnersPerPeriodAmount;\n    }    \n\n    /// @notice Allows the admin to pick the winners for the current round.\n    /// @dev Only admins are authorized to call this function.\n    /// @dev The number of winners must match the expected number of winners per period.\n    /// @dev The function will check that there are no existing winners for the current round.\n    /// @dev The function will update the winnerAddresses mapping with the addresses of the winners.\n    /// @dev The function will also reset the fighterPoints of the winners to zero.\n    /// @param winners The array of token IDs representing the winners.\n    function pickWinner(uint256[] calldata winners) external {\n        require(isAdmin[msg.sender]);\n        require(winners.length == winnersPerPeriod, \"Incorrect number of winners\");\n        require(!isSelectionComplete[roundId], \"Winners are already selected\");\n        uint256 winnersLength = winners.length;\n        address[] memory currentWinnerAddresses = new address[](winnersLength);\n        for (uint256 i = 0; i < winnersLength; i++) {\n            currentWinnerAddresses[i] = _fighterFarmInstance.ownerOf(winners[i]);\n            totalPoints -= fighterPoints[winners[i]];\n            fighterPoints[winners[i]] = 0;\n        }\n        winnerAddresses[roundId] = currentWinnerAddresses;\n        isSelectionComplete[roundId] = true;\n        roundId += 1;\n    }\n\n    /// @notice Allows the user to batch claim rewards for multiple rounds.\n    /// @dev The user can only claim rewards once for each round.\n    /// @param modelURIs The array of model URIs corresponding to each round and winner address.\n    /// @param modelTypes The array of model types corresponding to each round and winner address.\n    /// @param customAttributes Array with [element, weight] of the newly created fighter.\n    function claimRewards(\n        string[] calldata modelURIs, \n        string[] calldata modelTypes,\n        uint256[2][] calldata customAttributes\n    ) \n        external \n    {\n        uint256 winnersLength;\n        uint32 claimIndex = 0;\n        uint32 lowerBound = numRoundsClaimed[msg.sender];\n        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n            numRoundsClaimed[msg.sender] += 1;\n            winnersLength = winnerAddresses[currentRound].length;\n            for (uint32 j = 0; j < winnersLength; j++) {\n                if (msg.sender == winnerAddresses[currentRound][j]) {\n                    _fighterFarmInstance.mintFromMergingPool(\n                        msg.sender,\n                        modelURIs[claimIndex],\n                        modelTypes[claimIndex],\n                        customAttributes[claimIndex]\n                    );\n                    claimIndex += 1;\n                }\n            }\n        }\n        if (claimIndex > 0) {\n            emit Claimed(msg.sender, claimIndex);\n        }\n    }\n\n    /// @notice Gets the unclaimed rewards for a specific address.\n    /// @param claimer The address of the claimer.\n    /// @return numRewards The amount of unclaimed fighters.\n    function getUnclaimedRewards(address claimer) external view returns(uint256) {\n        uint256 winnersLength;\n        uint256 numRewards = 0;\n        uint32 lowerBound = numRoundsClaimed[claimer];\n        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n            winnersLength = winnerAddresses[currentRound].length;\n            for (uint32 j = 0; j < winnersLength; j++) {\n                if (claimer == winnerAddresses[currentRound][j]) {\n                    numRewards += 1;\n                }\n            }\n        }\n        return numRewards;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Add merging pool points to a fighter.\n    /// @dev Only the rankedBattle contract address can call this function.\n    /// @param tokenId The ID of the fighter token.\n    /// @param points The number of points to be added to the fighter.\n    function addPoints(uint256 tokenId, uint256 points) public {\n        require(msg.sender == _rankedBattleAddress, \"Not Ranked Battle contract address\");\n        fighterPoints[tokenId] += points;\n        totalPoints += points;\n        emit PointsAdded(tokenId, points);\n    }\n\n    /// @notice Retrieves the points for multiple fighters up to the specified maximum token ID.\n    /// @param maxId The maximum token ID up to which the points will be retrieved.\n    /// @return An array of points corresponding to the fighters' token IDs.\n    function getFighterPoints(uint256 maxId) public view returns(uint256[] memory) {\n        uint256[] memory points = new uint256[](1);\n        for (uint256 i = 0; i < maxId; i++) {\n            points[i] = fighterPoints[i];\n        }\n        return points;\n    }\n}"
    }
  ]
}