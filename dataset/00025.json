{
  "Title": "M-1: Accounting will be broken if `output` token is one of the `lpTokens`",
  "Content": "# Issue M-1: Accounting will be broken if `output` token is one of the `lpTokens` \n\nSource: https://github.com/sherlock-audit/2024-05-beefy-cowcentrated-liquidity-manager-judging/issues/71 \n\n## Found by \nDenTonylifer, Dliteofficial, bughuntoor, iamnmt\n## Summary\nAccounting will be broken if `output` token is one of the `lpTokens`\n\n## Vulnerability Detail\nWhen the strategy's balances is calculated, it counts both the funds in the LP positions and the funds within the strategy contract, fetched via regular `erc20.balanceOf`.\n```solidity\n    function balances() public view returns (uint256 token0Bal, uint256 token1Bal) {\n        (uint256 thisBal0, uint256 thisBal1) = balancesOfThis();\n        (uint256 poolBal0, uint256 poolBal1,,,,) = balancesOfPool();\n\n        uint256 total0 = thisBal0 + poolBal0;\n        uint256 total1 = thisBal1 + poolBal1;\n\n        // For token0 and token1 we return balance of this contract + balance of positions - feesUnharvested.\n        return (total0, total1);\n    }\n```\n```solidity\n    function balancesOfThis() public view returns (uint256 token0Bal, uint256 token1Bal) {\n        return (IERC20Metadata(lpToken0).balanceOf(address(this)), IERC20Metadata(lpToken1).balanceOf(address(this)));\n    }\n```\n\nThe problem is that the `output` token might be one of the `lpTokens` too and any accrued fees that are not yet harvested will be included in this number.\n\nThis would unfairly inflate share value when people are depositing via the Vault. Once rewards are collected though, these same depositors would suffer all the losses. Furthermore, it would lead to insolvency as the accrued fees might be deposited in the LP position, hence it will be hard to harvest them in order to temporarily fix accounting.\n\n## Impact\nBroken accounting, loss of funds, insolvency\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-05-beefy-cowcentrated-liquidity-manager/blob/main/cowcentrated-contracts/contracts/strategies/velodrome/StrategyPassiveManagerVelodrome.sol#L536C1-L538C6\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIf one of the `lpTokens` is `output` token, deduct the `fees` from the token balance\n\n\n\n## Discussion\n\n**MirthFutures**\n\nThis is a nice catch, although this can only happen if output is one of the tokens it should be accounted for. \n\n**sherlock-admin3**\n\n> Escalate\n> I believe I missed this during the judging period. This issue should not be Medium. The root cause is that the `output` token is one of the `lpTokens`, which are set in the `initialize` function, a TRUSTED admin function. This issue is input validation of a trusted function. Therefore, in my opinion, it should be downgraded to Low/Informational, because admin can check this before deployment.\n\nYou've deleted an escalation for this issue.\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/beefyfinance/cowcentrated-contracts/pull/17/files\n\n\n**0502lian**\n\nEscalate\nThis issue should invalid. The root cause is that the output token is one of the lpTokens, which are set in the initialize function, a TRUSTED admin(owner) function. This issue is input validation of a trusted function. Therefore,  it should be downgraded to Low/Informational, because admin can check this before deployment and will let the output token is not one of the lpTokens.\nBy the way, I brought up this escalation mainly because the current rules for TRUSTED admin seem unclear. There are too many issues about TRUSTED admin. Some are judged as valid, while others are deemed invalid.\n\n\n**sherlock-admin3**\n\n> Escalate\n> This issue should invalid. The root cause is that the output token is one of the lpTokens, which are set in the initialize function, a TRUSTED admin(owner) function. This issue is input validation of a trusted function. Therefore,  it should be downgraded to Low/Informational, because admin can check this before deployment and will let the output token is not one of the lpTokens.\n> By the way, I brought up this escalation mainly because the current rules for TRUSTED admin seem unclear. There are too many issues about TRUSTED admin. Some are judged as valid, while others are deemed invalid.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**z3s**\n\nI asked the sponsor about this on Discord. Their decision is to support this scenario and fix the accounting issue. Therefore, having the output token as one of the LP tokens is an expected outcome. The root cause is the wrong accounting, which makes this a valid Medium issue.\nSo, if they decided it should revert when the output token is one of the LP tokens, then it is an input validation issue and should be classified as Informational.\n\n**IWildSniperI**\n\n@z3s we judge according to sherlock judging rules\nso a sponser that could make a mistake himself and got a value from the report makes this issue in best cases `Low` severity\nquoting this from sherlock rules\n> List of Issue categories that are not considered valid:\n> Admin Input/call validation: Protocol admin is considered to be trusted in most cases, hence issues where\n>Admin incorrectly enters an input parameter. Example: Make sure interestPerMin > 1 ether as it is an important parameter. This is not a valid issue.\nAdmin could have an incorrect call order. Example: If an Admin forgets to setWithdrawAddress() before calling withdrawAll() This is not a valid issue.\nAn admin action can break certain assumptions about the functioning of the code. Example: Pausing a collateral causes some users to be unfairly liquidated or any other action causing loss of funds. This is not considered a valid issue.\nAs mentioned in the standards observed, in the case of a restricted admin, the restriction must be clearly mentioned for any issue in this category to be considered valid \n\nso its not mentioned restrictively that a check of `output` is in place, hence we are assuming the admin to do the righ thing \n\n**Dliteofficial**\n\nI believe the bone of contention is relating to whether the admin will knowingly or unknowingly pass in a CLPool with one of the LpTokens as the output/reward token. Being trusted IMO has no relevance here. Adding a check to ensure that this scenario is addressed is similar to what you would find in a staking pool where only the owner can add a reward token into the pool yet there's a check to ensure that the reward token is not the staking token. This honest mistake will cause catastrophic damage to the protocol. If the impact here doesn't entirely describe the severity of the issue, you should see #77. \n\nBecause there's no clear delineation, the accounting for both the LP Token and the output is now mushed into each other and there's at least one party who stands to lose everything.\n\n**DenTonylifer**\n\nLet me give an example that will help to solve this question. Here is a [similar report](https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/245) from a previous audit: the problem described in the report will ONLY occur because of the value entered by the TRUSTED admin. But this report was accepted for the following reason:\n>there's a specific code path that not just allows but expects the admins to set configs[i].start in the future\nSo, if the admins were to prevent the bug in issue 245, that piece of code would become dead code, which doesn't really make sense.\n\nThus, if the contract clearly expects the administrator to enter certain data, but after entering this data an unexpected problem occurs - this is a valid issue.\n\nIf we look at `_chargeFees()` and `balances()` functions, we will clearly see that they expect that `output` might be the same as one of the `lptokens`.\nIf we look at `beforeAction()` function, we will clearly see that protocol aware that unharvested fees can cause accounting problem and takes measures to prevent this.\nIf the protocol expected that  `output` will never be the same as one of the `lptokens`, then `that piece of code would become dead code, which doesn't really make sense.`\n\nAnd also:\n>So, if they decided it should revert when the output token is one of the LP tokens, then it is an input validation issue and should be classified as Informational.\n\nThis fix was made after the end of the audit and cannot affect the validity of the issue.\n\n**Dliteofficial**\n\nSo, I looked into your submission again, @DenTonylifer. Your escalation is predicated on the fact that token0 could be the same as the output tokens on which the fees are being charged, which could result in broken accounting. If that's true, then I agree that it should be a duplicate of this report then.\n\n**spacegliderrrr**\n\nAs per the readme, protocol should be able to work with any non-weird ERC20s (such one is `VELO`). Velodrome's gauges have `VELO` as their output token and hence, creating a strategy on top of a pool which has `VELO` as one of the `lpTokens` will break accounting.\n\nGiven that there are currently 37 [pools](https://velodrome.finance/liquidity?query=velo) which have `VELO` as one of their `lpTokens` it is reasonable that strategies will be built on top of them.\n\n**nevillehuang**\n\nAgree with @spacegliderrrr, planning to reject escalation and leave issue as it is.\n\n**WangSecurity**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0502lian](https://github.com/sherlock-audit/2024-05-beefy-cowcentrated-liquidity-manager-judging/issues/71/#issuecomment-2146653990): rejected\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/303",
  "Code": [
    {
      "filename": "cowcentrated-contracts/contracts/strategies/velodrome/StrategyPassiveManagerVelodrome.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20Metadata} from \"@openzeppelin-4/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC721} from \"@openzeppelin-4/contracts/token/ERC721/IERC721.sol\";\nimport {SafeERC20} from \"@openzeppelin-4/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SignedMath} from \"@openzeppelin-4/contracts/utils/math/SignedMath.sol\";\nimport {StratFeeManagerInitializable, IFeeConfig} from \"../StratFeeManagerInitializable.sol\";\nimport {IVeloPool} from \"../../interfaces/velodrome/IVeloPool.sol\";\nimport {IVeloRouter} from \"../../interfaces/velodrome/IVeloRouter.sol\";\nimport {LiquidityAmounts} from \"../../utils/LiquidityAmounts.sol\";\nimport {TickMath} from \"../../utils/TickMath.sol\";\nimport {TickUtils, FullMath} from \"../../utils/TickUtils.sol\";\nimport {VeloSwapUtils} from \"../../utils/VeloSwapUtils.sol\";\nimport {IBeefyVaultConcLiq} from \"../../interfaces/beefy/IBeefyVaultConcLiq.sol\";\nimport {IStrategyConcLiq} from \"../../interfaces/beefy/IStrategyConcLiq.sol\";\nimport {IStrategyVelodrome} from \"../../interfaces/beefy/IStrategyVelodrome.sol\";\nimport {IStrategyFactory} from \"../../interfaces/beefy/IStrategyFactory.sol\";\nimport {INftPositionManager} from \"../../interfaces/velodrome/INftPositionManager.sol\";\nimport {ICLGauge} from \"../../interfaces/velodrome/ICLGauge.sol\";\nimport {IRewardPool} from \"../../interfaces/beefy/IRewardPool.sol\";\nimport {IQuoter} from \"../../interfaces/uniswap/IQuoter.sol\";\nimport {UniV3Utils} from \"../../utils/UniV3Utils.sol\";\n\n/// @title Beefy Passive Position Manager. Version: Velodrome\n/// @author weso, Beefy\n/// @notice This is a contract for managing a passive concentrated liquidity position on Velodrome.\ncontract StrategyPassiveManagerVelodrome is StratFeeManagerInitializable, IStrategyConcLiq, IStrategyVelodrome {\n    using SafeERC20 for IERC20Metadata;\n    using TickMath for int24;\n\n    /// @notice The precision for pricing.\n    uint256 private constant PRECISION = 1e36;\n    uint256 private constant SQRT_PRECISION = 1e18;\n\n    /// @notice The max and min ticks univ3 allows.\n    int56 private constant MIN_TICK = -887272;\n    int56 private constant MAX_TICK = 887272;\n\n    /// @notice The address of the Velodrome pool.\n    address public pool;\n    /// @notice The address of the quoter.\n    address public quoter;\n    /// @notice The address of the NFT position manager.\n    address public nftManager;\n    /// @notice The address of the gauge. \n    address public gauge;\n    /// @notice The address of the output. \n    address public output;\n    /// @notice The address of the first token in the liquidity pool.\n    address public lpToken0;\n    /// @notice The address of the second token in the liquidity pool.\n    address public lpToken1;\n    /// @notice The address of the rewardPool.\n    address public rewardPool;\n\n    /// @notice The amount of unharvested output in the strategy.\n    uint256 public fees;\n\n    /// @notice The path to swap the output to the native token for fee harvesting.\n    bytes public outputToNativePath;\n    /// @notice The path to swap the first token to the native token for data pricing.\n    bytes public lpToken0ToNativePath;\n    /// @notice The path to swap the second token to the native token for data pricing.\n    bytes public lpToken1ToNativePath;\n\n    /// @notice The struct to store our tick positioning.\n    struct Position {\n        uint256 nftId;\n        int24 tickLower;\n        int24 tickUpper;\n    }\n\n    /// @notice The main position of the strategy.\n    /// @dev this will always be a 50/50 position that will be equal to position width * tickSpacing on each side.\n    Position public positionMain;\n\n    /// @notice The alternative position of the strategy.\n    /// @dev this will always be a single sided (limit order) position that will start closest to current tick and continue to width * tickSpacing.\n    /// This will always be in the token that has the most value after we fill our main position. \n    Position public positionAlt;\n\n    /// @notice The width of the position, thats a multiplier for tick spacing to find our range. \n    int24 public positionWidth;\n\n    /// @notice the max tick deviations we will allow for deposits/setTick. \n    int56 public maxTickDeviation;\n\n    /// @notice The twap interval seconds we use for the twap check. \n    uint32 public twapInterval;\n\n    /// @notice Initializes the ticks on first deposit. \n    bool private initTicks;\n\n    // Errors \n    error NotAuthorized();\n    error NotPool();\n    error InvalidEntry();\n    error NotVault();\n    error InvalidInput();\n    error InvalidOutput();\n    error NotCalm();\n    error TooMuchSlippage();\n\n    // Events\n    event TVL(uint256 bal0, uint256 bal1);\n    event Harvest(uint256 fees);\n    event SetPositionWidth(int24 oldWidth, int24 width);\n    event SetDeviation(int56 maxTickDeviation);\n    event SetTwapInterval(uint32 oldInterval, uint32 interval);\n    event SetOutputToNativePath(bytes path);\n    event SetRewardPool(address rewardPool);\n    event ChargedFees(uint256 callFeeAmount, uint256 beefyFeeAmount, uint256 strategistFeeAmount);\n    event ClaimedFees(uint256 fees);\n \n     /// @notice Modifier to only allow deposit/setTick actions when current price is within a certain deviation of twap.\n    modifier onlyCalmPeriods() {\n        _onlyCalmPeriods();\n        _;\n    }\n\n    /// @notice function to only allow deposit/setTick actions when current price is within a certain deviation of twap.\n    function _onlyCalmPeriods() private view {\n        if (!isCalm()) revert NotCalm();\n    }\n\n    modifier onlyRebalancers() {\n        if (!IStrategyFactory(factory).rebalancers(msg.sender)) revert NotAuthorized();\n        _;\n    }\n\n    /// @notice function to only allow deposit/setTick actions when current price is within a certain deviation of twap.\n    function isCalm() public view returns (bool) {\n        int24 tick = currentTick();\n        int56 twapTick = twap();\n\n        int56 minCalmTick = int56(SignedMath.max(twapTick - maxTickDeviation, MIN_TICK));\n        int56 maxCalmTick = int56(SignedMath.min(twapTick + maxTickDeviation, MAX_TICK));\n\n        // Calculate if tick move more than allowed from twap and revert if it did. \n        if(minCalmTick > tick  || maxCalmTick < tick) return false;\n        else return true;\n    }\n\n    /**\n     * @notice Initializes the strategy and the inherited strat fee manager.\n     * @dev Make sure cardinality is set appropriately for the twap.\n     * @param _pool The underlying Velodrome pool.\n     * @param _nftManager The NFT position manager.\n     * @param _output The output token for the strategy.\n     * @param _positionWidth The multiplier for tick spacing to find our range.\n     * @param _paths The bytes paths for swapping (Output To Native, Token0 to Native, Token1 to Native).\n     * @param _commonAddresses The common addresses needed for the strat fee manager.\n     */\n    function initialize (\n        address _pool,\n        address _quoter,\n        address _nftManager,\n        address _gauge,\n        address _rewardPool,\n        address _output, \n        int24 _positionWidth,\n        bytes[] calldata _paths,\n        CommonAddresses calldata _commonAddresses\n    ) external initializer {\n        __StratFeeManager_init(_commonAddresses);\n\n        pool = _pool;\n        quoter = _quoter;\n        output = _output;\n        nftManager = _nftManager;\n        gauge = _gauge;\n        rewardPool = _rewardPool;   \n        lpToken0 = IVeloPool(_pool).token0();\n        lpToken1 = IVeloPool(_pool).token1();\n\n        // Our width multiplier. The tick distance of each side will be width * tickSpacing.\n        positionWidth = _positionWidth;\n\n        outputToNativePath = _paths[0];\n        lpToken0ToNativePath = _paths[1];\n        lpToken1ToNativePath = _paths[2];\n    \n        // Set the twap interval to 120 seconds.\n        twapInterval = 120;\n\n        _giveAllowances();\n    \n    }\n\n    /// @notice Only allows the vault to call a function.\n    function _onlyVault () private view {\n        if (msg.sender != vault) revert NotVault();\n    }\n\n    /// @notice Called during deposit and withdraw to remove liquidity and harvest fees for accounting purposes.\n    function beforeAction() external {\n        _onlyVault();\n        _claimEarnings();\n        _removeLiquidity();\n    }\n\n    /// @notice Called during deposit to add all liquidity back to their positions. \n    function deposit() external onlyCalmPeriods {\n        _onlyVault();\n\n        if (!initTicks) {\n            _setTicks();\n            initTicks = true;\n        }\n\n        // Add all liquidity\n        _addLiquidity();\n        \n        (uint256 bal0, uint256 bal1) = balances();\n\n        // TVL Balances after deposit\n        emit TVL(bal0, bal1);\n    }\n\n    /**\n     * @notice Withdraws the specified amount of tokens from the strategy as calculated by the vault.\n     * @param _amount0 The amount of token0 to withdraw.\n     * @param _amount1 The amount of token1 to withdraw.\n     */\n    function withdraw(uint256 _amount0, uint256 _amount1) external {\n        _onlyVault();\n\n        // Liquidity has already been removed in beforeAction() so this is just a simple withdraw.\n        if (_amount0 > 0) IERC20Metadata(lpToken0).safeTransfer(vault, _amount0);\n        if (_amount1 > 0) IERC20Metadata(lpToken1).safeTransfer(vault, _amount1);\n\n        // After we take what is needed we add it all back to our positions. \n        if (!_isPaused()) _addLiquidity();\n\n        (uint256 bal0, uint256 bal1) = balances();\n\n        // TVL Balances after withdraw\n        emit TVL(bal0, bal1);\n    }\n\n    /// @notice Adds liquidity to the main and alternative positions called on deposit, harvest and withdraw.\n    function _addLiquidity() private {\n        _whenStrategyNotPaused();\n\n        (uint256 bal0, uint256 bal1) = balancesOfThis();\n\n        int24 mainLower = positionMain.tickLower;\n        int24 mainUpper = positionMain.tickUpper;\n        int24 altLower = positionAlt.tickLower;\n        int24 altUpper = positionAlt.tickUpper;\n\n        // Then we fetch how much liquidity we get for adding at the main position ticks with our token balances. \n        uint160 sqrtprice = sqrtPrice();\n        uint128 liquidity = LiquidityAmounts.getLiquidityForAmounts(\n            sqrtprice,\n            TickMath.getSqrtRatioAtTick(mainLower),\n            TickMath.getSqrtRatioAtTick(mainUpper),\n            bal0,\n            bal1\n        );\n\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtprice,\n            TickMath.getSqrtRatioAtTick(mainLower),\n            TickMath.getSqrtRatioAtTick(mainUpper),\n            liquidity\n        );\n\n        bool amountsOk = _checkAmounts(liquidity, mainLower, mainUpper);\n\n        // Mint or add liquidity to the position. \n        if (liquidity > 0 && amountsOk) {\n            _mintPosition(mainLower, mainUpper, amount0, amount1, true);\n        }\n\n        (bal0, bal1) = balancesOfThis();\n\n        // Fetch how much liquidity we get for adding at the alternative position ticks with our token balances.\n        liquidity = LiquidityAmounts.getLiquidityForAmounts(\n            sqrtprice,\n            TickMath.getSqrtRatioAtTick(altLower),\n            TickMath.getSqrtRatioAtTick(altUpper),\n            bal0,\n            bal1\n        );\n\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtprice,\n            TickMath.getSqrtRatioAtTick(altLower),\n            TickMath.getSqrtRatioAtTick(altUpper),\n            liquidity\n        );\n\n        // Mint or add liquidity to the position.\n        if (liquidity > 0 && (amount0 > 0 || amount1 > 0)) {\n            _mintPosition(altLower, altUpper, amount0, amount1, false);\n        }\n\n        if (positionMain.nftId != 0) ICLGauge(gauge).deposit(positionMain.nftId);\n        if (positionAlt.nftId != 0) ICLGauge(gauge).deposit(positionAlt.nftId);\n    }\n\n    /// @notice Mints a new position for the main or alternative position.\n    function _mintPosition(int24 _tickLower, int24 _tickUpper, uint256 _amount0, uint256 _amount1, bool _mainPosition) private {\n        INftPositionManager.MintParams memory mintParams = INftPositionManager.MintParams({\n            token0: lpToken0,\n            token1: lpToken1,\n            tickSpacing: _tickDistance(),\n            tickLower: _tickLower,\n            tickUpper: _tickUpper,\n            amount0Desired: _amount0,\n            amount1Desired: _amount1,\n            amount0Min: 0,\n            amount1Min: 0,\n            recipient: address(this),\n            deadline: block.timestamp,\n            sqrtPriceX96: 0\n        });\n\n        (uint256 nftId,,,) = INftPositionManager(nftManager).mint(mintParams);\n\n        if (_mainPosition) positionMain.nftId = nftId;\n        else positionAlt.nftId = nftId;\n\n        IERC721(nftManager).approve(gauge, nftId);\n    }\n\n    /// @notice Removes liquidity from the main and alternative positions, called on deposit, withdraw and harvest.\n    function _removeLiquidity() private {\n        uint128 liquidity;\n        uint128 liquidityAlt;\n        if (positionMain.nftId != 0) {\n            (,,,,,,,liquidity,,,,) = INftPositionManager(nftManager).positions(positionMain.nftId);\n            ICLGauge(gauge).withdraw(positionMain.nftId);\n        } \n\n        if (positionAlt.nftId != 0) {\n            (,,,,,,,liquidityAlt,,,,) = INftPositionManager(nftManager).positions(positionAlt.nftId);\n            ICLGauge(gauge).withdraw(positionAlt.nftId);\n        }\n\n        // init our params\n        INftPositionManager.DecreaseLiquidityParams memory decreaseLiquidityParams;\n        INftPositionManager.CollectParams memory collectParams;\n\n        // If we have liquidity in the positions we remove it and collect our tokens.\n        if (liquidity > 0) {\n            decreaseLiquidityParams = INftPositionManager.DecreaseLiquidityParams({\n                tokenId: positionMain.nftId,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            });\n\n            collectParams = INftPositionManager.CollectParams({\n                tokenId: positionMain.nftId,\n                recipient: address(this),\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            });\n\n            INftPositionManager(nftManager).decreaseLiquidity(decreaseLiquidityParams);\n            INftPositionManager(nftManager).collect(collectParams);\n            INftPositionManager(nftManager).burn(positionMain.nftId);\n            positionMain.nftId = 0;\n            \n        }\n\n        if (liquidityAlt > 0) {\n            decreaseLiquidityParams = INftPositionManager.DecreaseLiquidityParams({\n                tokenId: positionAlt.nftId,\n                liquidity: liquidityAlt,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            });\n\n            collectParams = INftPositionManager.CollectParams({\n                tokenId: positionAlt.nftId,\n                recipient: address(this),\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            });\n\n            INftPositionManager(nftManager).decreaseLiquidity(decreaseLiquidityParams);\n            INftPositionManager(nftManager).collect(collectParams);\n            INftPositionManager(nftManager).burn(positionAlt.nftId);\n            positionAlt.nftId = 0;\n            \n        }\n    }\n\n    /**\n     *  @notice Checks if the amounts are ok to add liquidity.\n     * @param _liquidity The liquidity to add.\n     * @param _tickLower The lower tick of the position.\n     * @param _tickUpper The upper tick of the position.\n     * @return bool True if the amounts are ok, false if not.\n     */\n    function _checkAmounts(uint128 _liquidity, int24 _tickLower, int24 _tickUpper) private view returns (bool) {\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPrice(),\n            TickMath.getSqrtRatioAtTick(_tickLower),\n            TickMath.getSqrtRatioAtTick(_tickUpper),\n            _liquidity\n        );\n\n        if (amount0 == 0 || amount1 == 0) return false;\n        else return true;\n    }\n\n    /// @notice Function called to rebalance the position \n    function moveTicks() external onlyCalmPeriods onlyRebalancers {\n        _claimEarnings();\n        _removeLiquidity();\n        _setTicks();\n        _addLiquidity();\n\n        (uint256 bal0, uint256 bal1) = balances();\n        emit TVL(bal0, bal1);\n    }\n\n    /// @notice Harvest call to claim rewards from gauge then charge fees for Beefy and notify rewards.\n    /// @param _callFeeRecipient The address to send the call fee to.\n    function harvest(address _callFeeRecipient) external {\n        _harvest(_callFeeRecipient);\n    }\n\n    /// @notice Harvest call to claim rewards from gauge then charge fees for Beefy and notify rewards.\n    /// @dev Call fee goes to the tx.origin. \n    function harvest() external {\n        _harvest(tx.origin);\n    }\n\n    /// @notice Internal function to claim rewards from gauge then charge fees for Beefy and notify rewards\n    function _harvest (address _callFeeRecipient) private {\n        // Claim rewards from gauge\n        _claimEarnings();\n\n        // Charge fees for Beefy and send them to the appropriate addresses, charge fees to accrued state fee amounts.\n        (uint256 feeLeft) = _chargeFees(_callFeeRecipient, fees);\n\n        // Reset state fees to 0. \n        fees = 0;\n\n        // Notify rewards with our velo. \n        IRewardPool(rewardPool).notifyRewardAmount(output, feeLeft, 1 days);\n\n        // Log the last time we claimed fees. \n        lastHarvest = block.timestamp;\n\n        // Log the fees post Beefy fees.\n        emit Harvest(feeLeft);\n    }\n\n    /// @notice Internal function to claim rewards from the gauge and collect them.\n    function _claimEarnings() private {\n        // Claim rewards\n        uint256 feeBefore = IERC20Metadata(output).balanceOf(address(this));\n\n        if (positionMain.nftId != 0) ICLGauge(gauge).getReward(positionMain.nftId);\n        if (positionAlt.nftId != 0) ICLGauge(gauge).getReward(positionAlt.nftId);\n\n        uint256 claimed = IERC20Metadata(output).balanceOf(address(this)) - feeBefore;\n        fees = fees + claimed;\n\n        emit ClaimedFees(claimed);\n    }\n\n    /**\n     * @notice Internal function to charge fees for Beefy and send them to the appropriate addresses.\n     * @param _callFeeRecipient The address to send the call fee to.\n     * @param _amount The amount of output to charge fees on.\n     * @return _amountLeft The amount of token0 left after fees.\n     */\n    function _chargeFees(address _callFeeRecipient, uint256 _amount) private returns (uint256 _amountLeft){\n        /// Fetch our fee percentage amounts from the fee config.\n        IFeeConfig.FeeCategory memory fee = getFees();\n\n        /// We calculate how much to swap and then swap both tokens to native and charge fees.\n        uint256 nativeEarned;\n        if (_amount > 0) {\n            // Calculate amount of token 0 to swap for fees.\n            uint256 amountToSwap = _amount * fee.total / DIVISOR;\n            _amountLeft = _amount - amountToSwap;\n            \n            // If token0 is not native, swap to native the fee amount.\n            uint256 out;\n            uint256 nativeBefore = IERC20Metadata(native).balanceOf(address(this));\n            if (output != native) {\n                VeloSwapUtils.swap(unirouter, outputToNativePath, amountToSwap, true);\n                out = IERC20Metadata(native).balanceOf(address(this)) - nativeBefore;\n            }\n            \n            // Add the native earned to the total of native we earned for beefy fees, handle if token0 is native.\n            if (output == native)  nativeEarned += amountToSwap;\n            else nativeEarned += out;\n        }\n\n        // Distribute the native earned to the appropriate addresses.\n        uint256 callFeeAmount = nativeEarned * fee.call / DIVISOR;\n        IERC20Metadata(native).safeTransfer(_callFeeRecipient, callFeeAmount);\n\n        uint256 strategistFeeAmount = nativeEarned * fee.strategist / DIVISOR;\n        IERC20Metadata(native).safeTransfer(strategist, strategistFeeAmount);\n\n        uint256 beefyFeeAmount = nativeEarned - callFeeAmount - strategistFeeAmount;\n        IERC20Metadata(native).safeTransfer(beefyFeeRecipient(), beefyFeeAmount);\n\n        emit ChargedFees(callFeeAmount, beefyFeeAmount, strategistFeeAmount);\n    }\n\n    /** \n     * @notice Returns total token balances in the strategy.\n     * @return token0Bal The amount of token0 in the strategy.\n     * @return token1Bal The amount of token1 in the strategy.\n    */\n    function balances() public view returns (uint256 token0Bal, uint256 token1Bal) {\n        (uint256 thisBal0, uint256 thisBal1) = balancesOfThis();\n        (uint256 poolBal0, uint256 poolBal1,,,,) = balancesOfPool();\n\n        uint256 total0 = thisBal0 + poolBal0;\n        uint256 total1 = thisBal1 + poolBal1;\n\n        // For token0 and token1 we return balance of this contract + balance of positions - feesUnharvested.\n        return (total0, total1);\n    }\n\n    /**\n     * @notice Returns total tokens sitting in the strategy.\n     * @return token0Bal The amount of token0 in the strategy.\n     * @return token1Bal The amount of token1 in the strategy.\n    */\n    function balancesOfThis() public view returns (uint256 token0Bal, uint256 token1Bal) {\n        return (IERC20Metadata(lpToken0).balanceOf(address(this)), IERC20Metadata(lpToken1).balanceOf(address(this)));\n    }\n\n    /** \n     * @notice Returns total tokens in pool positions (is a calculation which means it could be a little off by a few wei). \n     * @return token0Bal The amount of token0 in the pool.\n     * @return token1Bal The amount of token1 in the pool.\n     * @return mainAmount0 The amount of token0 in the main position.\n     * @return mainAmount1 The amount of token1 in the main position.\n     * @return altAmount0 The amount of token0 in the alt position.\n     * @return altAmount1 The amount of token1 in the alt position.\n    */\n    function balancesOfPool() public view returns (uint256 token0Bal, uint256 token1Bal, uint256 mainAmount0, uint256 mainAmount1, uint256 altAmount0, uint256 altAmount1) {\n        uint160 sqrtPriceX96 = sqrtPrice();\n\n        uint128 liquidity; \n        uint128 altLiquidity;\n        uint256 owed0;\n        uint256 owed1;\n        uint256 altOwed0;\n        uint256 altOwed1;\n        if (positionMain.nftId != 0) (,,,,,,,liquidity,,,owed0, owed1) = INftPositionManager(nftManager).positions(positionMain.nftId);\n        if (positionAlt.nftId != 0) (,,,,,,, altLiquidity,,,altOwed0, altOwed1) = INftPositionManager(nftManager).positions(positionAlt.nftId);\n\n        (mainAmount0, mainAmount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            TickMath.getSqrtRatioAtTick(positionMain.tickLower),\n            TickMath.getSqrtRatioAtTick(positionMain.tickUpper),\n            liquidity\n        );\n\n        (altAmount0, altAmount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,   \n            TickMath.getSqrtRatioAtTick(positionAlt.tickLower),\n            TickMath.getSqrtRatioAtTick(positionAlt.tickUpper),\n            altLiquidity\n        );\n\n        mainAmount0 += owed0;\n        mainAmount1 += owed1;\n\n        altAmount0 += altOwed0;\n        altAmount1 += altOwed1;\n        \n        token0Bal = mainAmount0 + altAmount0;\n        token1Bal = mainAmount1 + altAmount1;\n    }\n    \n    /**\n     * @notice Returns the range of the pool, will always be the main position.\n     * @return lowerPrice The lower price of the position.\n     * @return upperPrice The upper price of the position.\n    */\n    function range() external view returns (uint256 lowerPrice, uint256 upperPrice) {\n        // the main position is always covering the alt range\n        lowerPrice = FullMath.mulDiv(uint256(TickMath.getSqrtRatioAtTick(positionMain.tickLower)), SQRT_PRECISION, (2 ** 96)) ** 2;\n        upperPrice = FullMath.mulDiv(uint256(TickMath.getSqrtRatioAtTick(positionMain.tickUpper)), SQRT_PRECISION, (2 ** 96)) ** 2;\n    }\n\n    /**\n     * @notice The current tick of the pool.\n     * @return tick The current tick of the pool.\n    */\n    function currentTick() public view returns (int24 tick) {\n        (,tick,,,,) = IVeloPool(pool).slot0();\n    }\n\n    /**\n     * @notice The current price of the pool.\n     * @return _price The current price of the pool.\n    */\n    function price() public view returns (uint256 _price) {\n        uint160 sqrtPriceX96 = sqrtPrice();\n        _price = FullMath.mulDiv(uint256(sqrtPriceX96), SQRT_PRECISION, (2 ** 96)) ** 2;\n    }\n\n    /**\n     * @notice The sqrt price of the pool.\n     * @return sqrtPriceX96 The sqrt price of the pool.\n    */\n    function sqrtPrice() public view returns (uint160 sqrtPriceX96) {\n        (sqrtPriceX96,,,,,) = IVeloPool(pool).slot0();\n    }\n\n    /** \n     * @notice The tick distance of the pool.\n     * @return int24 The tick distance/spacing of the pool.\n    */\n    function _tickDistance() private view returns (int24) {\n        return IVeloPool(pool).tickSpacing();\n    }\n\n    /// @notice Sets the tick positions for the main and alternative positions.\n    function _setTicks() private onlyCalmPeriods {\n        int24 tick = currentTick();\n        int24 distance = _tickDistance();\n        int24 width = positionWidth * distance;\n\n        _setMainTick(tick, distance, width);\n        _setAltTick(tick, distance, width);\n    }\n\n    /// @notice Sets the main tick position.\n    function _setMainTick(int24 tick, int24 distance, int24 width) private {\n        (positionMain.tickLower, positionMain.tickUpper) = TickUtils.baseTicks(\n            tick,\n            width,\n            distance\n        );\n    }\n\n    /// @notice Sets the alternative tick position.\n    function _setAltTick(int24 tick, int24 distance, int24 width) private {\n        (uint256 bal0, uint256 bal1) = balancesOfThis();\n\n        // We calculate how much token0 we have in the price of token1. \n        uint256 amount0;\n\n        if (bal0 > 0) {\n            amount0 = bal0 * price() / PRECISION;\n        }\n\n        // We set the alternative position based on the token that has the most value available. \n        if (amount0 < bal1) {\n            (positionAlt.tickLower, ) = TickUtils.baseTicks(\n                tick,\n                width,\n                distance\n            );\n\n            (positionAlt.tickUpper, ) = TickUtils.baseTicks(\n                tick,\n                distance,\n                distance\n            ); \n        } else if (bal1 < amount0) {\n            (, positionAlt.tickLower) = TickUtils.baseTicks(\n                tick,\n                distance,\n                distance\n            );\n\n            (, positionAlt.tickUpper) = TickUtils.baseTicks(\n                tick,\n                width,\n                distance\n            ); \n        }\n    }\n\n    /**\n     * @notice Sets the path to swap the output token to the native token for fee harvesting.\n     * @param _path The path to swap the output token to the native token.\n    */\n    function setOutputToNativePath(bytes calldata _path) public onlyOwner {\n        if (_path.length > 0) {\n            (address[] memory _route) = VeloSwapUtils.pathToRoute(_path);\n            if (_route[0] != output) revert InvalidInput();\n            if (_route[_route.length - 1] != native) revert InvalidOutput();\n            outputToNativePath = _path;\n            emit SetOutputToNativePath(_path);\n        }\n    }\n\n    /**\n     * @notice Sets the deviation from the twap we will allow on adding liquidity.\n     * @param _maxDeviation The max deviation from twap we will allow.\n    */\n    function setDeviation(int56 _maxDeviation) external onlyOwner {\n        emit SetDeviation(_maxDeviation);\n\n        // Require the deviation to be less than or equal to 4 times the tick spacing.\n        if (_maxDeviation >= _tickDistance() * 4) revert InvalidInput();\n\n        maxTickDeviation = _maxDeviation;\n    }\n\n    /**\n     * @notice Returns the route to swap the output token to the native token for fee harvesting.\n     * @return address[] The route to swap the output to the native token.\n    */\n    function outputToNative() public view returns (address[] memory) {\n        if (outputToNativePath.length == 0) return new address[](0);\n        return VeloSwapUtils.pathToRoute(outputToNativePath);\n    }\n\n    /// @notice Returns the price of the first token in native token.\n    function lpToken0ToNativePrice() public returns (uint256) {\n        uint amount = 10**IERC20Metadata(lpToken0).decimals() / 10;\n        if (lpToken0 == native) return amount;\n        return IQuoter(quoter).quoteExactInput(lpToken0ToNativePath, amount);\n    }\n\n    /// @notice Returns the price of the second token in native token.\n    function lpToken1ToNativePrice() public returns (uint256) {\n        uint amount = 10**IERC20Metadata(lpToken1).decimals() / 10;\n        if (lpToken1 == native) return amount;\n        return IQuoter(quoter).quoteExactInput(lpToken1ToNativePath, amount);\n    }\n\n    /** \n     * @notice The twap of the last minute from the pool.\n     * @return twapTick The twap of the last minute from the pool.\n    */\n    function twap() public view returns (int56 twapTick) {\n        uint32[] memory secondsAgo = new uint32[](2);\n        secondsAgo[0] = uint32(twapInterval);\n        secondsAgo[1] = 0;\n\n        (int56[] memory tickCuml,) = IVeloPool(pool).observe(secondsAgo);\n        twapTick = (tickCuml[1] - tickCuml[0]) / int32(twapInterval);\n    }\n\n    function setTwapInterval(uint32 _interval) external onlyOwner {\n        emit SetTwapInterval(twapInterval, _interval);\n\n        // Require the interval to be greater than 60 seconds.\n        if (_interval < 60) revert InvalidInput();\n\n        twapInterval = _interval;\n    }\n\n    /** \n     * @notice Sets our position width and readjusts our positions.\n     * @param _width The new width multiplier of the position.\n    */\n    function setPositionWidth(int24 _width) external onlyOwner {\n        emit SetPositionWidth(positionWidth, _width);\n        _claimEarnings();\n        _removeLiquidity();\n        positionWidth = _width;\n        _setTicks();\n        _addLiquidity();\n    }\n\n    /**\n     * @notice Sets the reward pool address.\n     * @param _rewardPool The new reward pool address.\n     */\n    function setRewardPool(address _rewardPool) external onlyOwner {\n        rewardPool = _rewardPool;\n        emit SetRewardPool(_rewardPool);\n    }\n\n    /**\n     * @notice set the unirouter address\n     * @param _unirouter The new unirouter address\n     */\n    function setUnirouter(address _unirouter) external override onlyOwner {\n        _removeAllowances();\n        unirouter = _unirouter;\n        _giveAllowances();\n        emit SetUnirouter(_unirouter);\n    }\n\n    /// @notice Retire the strategy and return all the dust to the fee recipient.\n    function retireVault() external onlyOwner {\n        if (IBeefyVaultConcLiq(vault).totalSupply() != 10**3) revert NotAuthorized();\n        panic(0,0);\n        address feeRecipient = beefyFeeRecipient();\n        IERC20Metadata(lpToken0).safeTransfer(feeRecipient, IERC20Metadata(lpToken0).balanceOf(address(this)));\n        IERC20Metadata(lpToken1).safeTransfer(feeRecipient, IERC20Metadata(lpToken1).balanceOf(address(this)));\n        _transferOwnership(address(0));\n    }\n\n    /**  \n     * @notice Remove Liquidity and Allowances, then pause deposits.\n     * @param _minAmount0 The minimum amount of token0 in the strategy after panic.\n     * @param _minAmount1 The minimum amount of token1 in the strategy after panic.\n     */\n    function panic(uint256 _minAmount0, uint256 _minAmount1) public onlyManager {\n        _claimEarnings();\n        _removeLiquidity();\n        _removeAllowances();\n        _pause();\n\n        (uint256 bal0, uint256 bal1) = balances();\n        if (bal0 < _minAmount0 || bal1 < _minAmount1) revert TooMuchSlippage();\n    }\n\n    /// @notice Unpause deposits, give allowances and add liquidity.\n    function unpause() external onlyManager {\n        if (owner() == address(0)) revert NotAuthorized();\n        _giveAllowances();\n        _unpause();\n        _setTicks();\n        _addLiquidity();\n    }\n\n    /// @notice gives swap permisions for the tokens to the unirouter.\n    function _giveAllowances() private {\n        IERC20Metadata(output).forceApprove(unirouter, type(uint256).max);\n        IERC20Metadata(output).forceApprove(rewardPool, type(uint256).max);\n        IERC20Metadata(lpToken0).forceApprove(nftManager, type(uint256).m"
    }
  ]
}