{
  "Title": "M-3: HPB may be incorrectly bankrupt due to use of unscaled value in `_forgiveBadDebt`",
  "Content": "# Issue M-3: HPB may be incorrectly bankrupt due to use of unscaled value in `_forgiveBadDebt` \n\nSource: https://github.com/sherlock-audit/2023-09-ajna-judging/issues/25 \n\n## Found by \n0xkaden\n\nAn unscaled value is used in place of where a scaled value should be used in the bankruptcy check in  `_forgiveBadDebt`. This may cause the bucket to be incorrectly marked as bankrupt, losing user funds.\n\n## Vulnerability Detail\n\nAt the end of `_forgiveBadDebt`, we do a usual bankruptcy check in which we check whether the remaining deposit and collateral will be little enough that the exchange rate will round to 0, in which case we mark the bucket as bankrupt, setting the bucket lps and effectively all user lps as 0.\n\nThe problem lies in the fact that we use `depositRemaining` as part of this check, which represents an unscaled value. As a result, when computing whether the exchange rate rounds to 0 our logic is off by a factor of the bucket's scale. The bucket may be incorrectly marked as bankrupt if the unscaled `depositRemaining` would result in an exchange rate of 0 when the scaled `depositRemaining` would not.\n\n## Impact\n\nLoss of user funds.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/external/SettlerActions.sol#L485\n```solidity\n// If the remaining deposit and resulting bucket collateral is so small that the exchange rate\n// rounds to 0, then bankrupt the bucket.  Note that lhs are WADs, so the\n// quantity is naturally 1e18 times larger than the actual product\n// @audit depositRemaining should be a scaled value\nif (depositRemaining * Maths.WAD + hpbBucket.collateral * _priceAt(index) <= bucketLP) {\n    // existing LP for the bucket shall become unclaimable\n    hpbBucket.lps            = 0;\n    hpbBucket.bankruptcyTime = block.timestamp;\n\n    emit BucketBankruptcy(\n        index,\n        bucketLP\n    );\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSimply scale `depositRemaining` before doing the bankruptcy check, e.g. something like:\n\n```solidity\ndepositRemaining = Maths.wmul(depositRemaining, scale);\nif (depositRemaining * Maths.WAD + hpbBucket.collateral * _priceAt(index) <= bucketLP) {\n    // existing LP for the bucket shall become unclaimable\n    hpbBucket.lps            = 0;\n    hpbBucket.bankruptcyTime = block.timestamp;\n\n    emit BucketBankruptcy(\n        index,\n        bucketLP\n    );\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/114",
  "Code": [
    {
      "filename": "ajna-core/src/libraries/external/SettlerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    Kicker,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                       from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    SettleParams,\n    SettleResult\n}                       from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _auctionPrice,\n    _indexOf,\n    _priceAt,\n    MAX_FENWICK_INDEX,\n    MIN_PRICE,\n    DEPOSIT_BUFFER   \n}  from '../helpers/PoolHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auction settler library\n    @notice External library containing actions involving auctions within pool:\n            - `settle` auctions\n */\nlibrary SettlerActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `_settlePoolDebtWithDeposit` function local vars.\n    struct SettleLocalVars {\n        uint256 collateralUsed;     // [WAD] collateral used to settle debt\n        uint256 debt;               // [WAD] debt to settle\n        uint256 hpbCollateral;      // [WAD] amount of collateral in HPB bucket\n        uint256 hpbUnscaledDeposit; // [WAD] unscaled amount of of quote tokens in HPB bucket before settle\n        uint256 hpbLP;              // [WAD] amount of LP in HPB bucket\n        uint256 index;              // index of settling bucket\n        uint256 maxSettleableDebt;  // [WAD] max amount that can be settled with existing collateral\n        uint256 price;              // [WAD] price of settling bucket\n        uint256 scaledDeposit;      // [WAD] scaled amount of quote tokens in bucket\n        uint256 scale;              // [WAD] scale of settling bucket\n        uint256 unscaledDeposit;    // [WAD] unscaled amount of quote tokens in bucket\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AuctionSettle(address indexed borrower, uint256 collateral);\n    event AuctionNFTSettle(address indexed borrower, uint256 collateral, uint256 lp, uint256 index);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    event Settle(address indexed borrower, uint256 settledDebt);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionNotClearable();\n    error NoAuction();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IPoolSettlerActions` for descriptions.\n     *  @notice Settles the debt of the given loan / borrower by performing following steps:\n     *          1. settle debt with `HPB`s deposit, up to specified buckets depth.\n     *          2. settle debt with pool reserves (if there's still debt and no collateral left after step 1).\n     *          3. forgive bad debt from next `HPB`, up to remaining buckets depth (and if there's still debt after step 2).\n     *  @dev    === Write state ===\n     *  @dev    update borrower state\n     *  @dev    === Reverts on ===\n     *  @dev    loan is not in auction `NoAuction()`\n     *  @dev    `72` hours didn't pass and auction still has collateral `AuctionNotClearable()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Settle`\n     *  @return result_ The `SettleResult` struct result of settle action.\n     */\n    function settlePoolDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        ReserveAuctionState storage reserveAuction_,\n        PoolState calldata poolState_,\n        SettleParams memory params_\n    ) external returns (SettleResult memory result_) {\n        uint256 kickTime = auctions_.liquidations[params_.borrower].kickTime;\n        if (kickTime == 0) revert NoAuction();\n\n        Borrower memory borrower = loans_.borrowers[params_.borrower];\n        if ((block.timestamp - kickTime <= 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();\n\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n        result_.t0DebtSettled       = borrower.t0Debt;\n        result_.collateralSettled   = borrower.collateral;\n\n        // 1. settle debt with HPB deposit\n        (\n            borrower.t0Debt,\n            borrower.collateral,\n            params_.bucketDepth\n        ) = _settlePoolDebtWithDeposit(\n            buckets_,\n            deposits_,\n            params_,\n            borrower,\n            poolState_.inflator\n        );\n\n        if (borrower.t0Debt != 0 && borrower.collateral == 0) {\n            // 2. settle debt with pool reserves\n            uint256 assets = Maths.floorWmul(poolState_.t0Debt - result_.t0DebtSettled + borrower.t0Debt, poolState_.inflator) + params_.poolBalance;\n\n            uint256 liabilities =\n                // require 1.0 + 1e-9 deposit buffer (extra margin) for deposits\n                Maths.wmul(DEPOSIT_BUFFER, Deposits.treeSum(deposits_)) +\n                auctions_.totalBondEscrowed +\n                reserveAuction_.unclaimed;\n\n            // settle debt from reserves (assets - liabilities) if reserves positive, round reserves down however\n            if (assets > liabilities) {\n                borrower.t0Debt -= Maths.min(borrower.t0Debt, Maths.floorWdiv(assets - liabilities, poolState_.inflator));\n            }\n\n            // 3. forgive bad debt from next HPB\n            if (borrower.t0Debt != 0) {\n                borrower.t0Debt = _forgiveBadDebt(\n                    buckets_,\n                    deposits_,\n                    params_,\n                    borrower,\n                    poolState_.inflator\n                );\n            }\n        }\n\n        // complete result struct with debt settled\n        result_.t0DebtSettled -= borrower.t0Debt;\n\n        emit Settle(\n            params_.borrower,\n            result_.t0DebtSettled\n        );\n\n        // if entire debt was settled then settle auction\n        if (borrower.t0Debt == 0) {\n            (borrower.collateral, ) = _settleAuction(\n                auctions_,\n                buckets_,\n                deposits_,\n                params_.borrower,\n                borrower.collateral,\n                poolState_.poolType\n            );\n        }\n\n        // complete result struct with debt and collateral post action and collateral settled\n        result_.debtPostAction      = borrower.t0Debt;\n        result_.collateralRemaining = borrower.collateral;\n        result_.collateralSettled   -= result_.collateralRemaining;\n\n        // update borrower state\n        loans_.borrowers[params_.borrower] = borrower;\n    }\n\n    /***************************/\n    /***  Internal Functions ***/\n    /***************************/\n\n    /**\n     *  @notice Performs auction settle based on pool type, emits settle event and removes auction from auctions queue.\n     *  @dev    === Emit events ===\n     *  @dev    - `AuctionNFTSettle` or `AuctionSettle`\n     *  @param  auctions_              Struct for pool auctions state.\n     *  @param  buckets_               Struct for pool buckets state.\n     *  @param  deposits_              Struct for pool deposits state.\n     *  @param  borrowerAddress_       Address of the borrower that exits auction.\n     *  @param  borrowerCollateral_    Borrower collateral amount before auction exit (in `NFT` could be fragmented as result of partial takes).\n     *  @param  poolType_              Type of the pool (can be `ERC20` or `ERC721`).\n     *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for `ERC20` pool, rounded collateral for `ERC721` pool).\n     *  @return compensatedCollateral_ Amount of collateral compensated (`ERC721` settle only), to be deducted from pool pledged collateral accumulator. Always `0` for `ERC20` pools.\n     */\n    function _settleAuction(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        address borrowerAddress_,\n        uint256 borrowerCollateral_,\n        uint256 poolType_\n    ) internal returns (uint256 remainingCollateral_, uint256 compensatedCollateral_) {\n\n        if (poolType_ == uint8(PoolType.ERC721)) {\n            uint256 lp;\n            uint256 bucketIndex;\n\n            // floor collateral of borrower\n            remainingCollateral_ = (borrowerCollateral_ / Maths.WAD) * Maths.WAD;\n\n            // if there's fraction of NFTs remaining then reward difference to borrower as LP in auction price bucket\n            if (remainingCollateral_ != borrowerCollateral_) {\n\n                // calculate the amount of collateral that should be compensated with LP\n                compensatedCollateral_ = borrowerCollateral_ - remainingCollateral_;\n\n                uint256 auctionPrice = _auctionPrice(\n                    auctions_.liquidations[borrowerAddress_].referencePrice,\n                    auctions_.liquidations[borrowerAddress_].kickTime\n                );\n\n                // determine the bucket index to compensate fractional collateral\n                bucketIndex = auctionPrice > MIN_PRICE ? _indexOf(auctionPrice) : MAX_FENWICK_INDEX;\n\n                // deposit collateral in bucket and reward LP to compensate fractional collateral\n                lp = Buckets.addCollateral(\n                    buckets_[bucketIndex],\n                    borrowerAddress_,\n                    Deposits.valueAt(deposits_, bucketIndex),\n                    compensatedCollateral_,\n                    _priceAt(bucketIndex)\n                );\n            }\n\n            emit AuctionNFTSettle(\n                borrowerAddress_,\n                remainingCollateral_,\n                lp,\n                bucketIndex\n            );\n\n        } else {\n            remainingCollateral_ = borrowerCollateral_;\n\n            emit AuctionSettle(\n                borrowerAddress_,\n                remainingCollateral_\n            );\n        }\n\n        _removeAuction(auctions_, borrowerAddress_);\n    }\n\n    /**\n     *  @notice Removes auction and repairs the queue order.\n     *  @notice Updates kicker's claimable balance with bond size awarded and subtracts bond size awarded from `liquidationBondEscrowed`.\n     *  @dev    === Write state ===\n     *  @dev    decrement kicker locked accumulator, increment kicker claimable accumumlator\n     *  @dev    decrement auctions count accumulator\n     *  @dev    update auction queue state\n     *  @param  auctions_ Struct for pool auctions state.\n     *  @param  borrower_ Auctioned borrower address.\n     */\n    function _removeAuction(\n        AuctionsState storage auctions_,\n        address borrower_\n    ) internal {\n        Liquidation memory liquidation = auctions_.liquidations[borrower_];\n        // update kicker balances\n        Kicker storage kicker = auctions_.kickers[liquidation.kicker];\n\n        kicker.locked    -= liquidation.bondSize;\n        kicker.claimable += liquidation.bondSize;\n\n        // decrement number of active auctions\n        -- auctions_.noOfAuctions;\n\n        // update auctions queue\n        if (auctions_.head == borrower_ && auctions_.tail == borrower_) {\n            // liquidation is the head and tail\n            auctions_.head = address(0);\n            auctions_.tail = address(0);\n        }\n        else if(auctions_.head == borrower_) {\n            // liquidation is the head\n            auctions_.liquidations[liquidation.next].prev = address(0);\n            auctions_.head = liquidation.next;\n        }\n        else if(auctions_.tail == borrower_) {\n            // liquidation is the tail\n            auctions_.liquidations[liquidation.prev].next = address(0);\n            auctions_.tail = liquidation.prev;\n        }\n        else {\n            // liquidation is in the middle\n            auctions_.liquidations[liquidation.prev].next = liquidation.next;\n            auctions_.liquidations[liquidation.next].prev = liquidation.prev;\n        }\n        // delete liquidation\n        delete auctions_.liquidations[borrower_];\n    }\n\n    /**\n     *  @notice Called to settle debt using `HPB` deposits, up to the number of specified buckets depth.\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.unscaledRemove()` (remove amount in `Fenwick` tree, from index):\n     *  @dev      update `values` array state\n     *  @dev    - `Buckets.addCollateral`:\n     *  @dev      increment `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev      increment `lender.lps` accumulator and `lender.depositTime` state\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     *  @param  buckets_             Struct for pool buckets state.\n     *  @param  deposits_            Struct for pool deposits state.\n     *  @param  params_              Struct containing params for settle action.\n     *  @param  borrower_            Struct containing borrower details.\n     *  @param  inflator_            Current pool inflator.\n     *  @return remainingt0Debt_     Remaining borrower `t0` debt after settle with `HPB`.\n     *  @return remainingCollateral_ Remaining borrower collateral after settle with `HPB`.\n     *  @return bucketDepth_         Number of buckets to use for forgiving debt in case there's more remaining.\n     */\n    function _settlePoolDebtWithDeposit(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        SettleParams memory params_,\n        Borrower memory borrower_,\n        uint256 inflator_\n    ) internal returns (uint256 remainingt0Debt_, uint256 remainingCollateral_, uint256 bucketDepth_) {\n        remainingt0Debt_     = borrower_.t0Debt;\n        remainingCollateral_ = borrower_.collateral;\n        bucketDepth_         = params_.bucketDepth;\n\n        while (bucketDepth_ != 0 && remainingt0Debt_ != 0 && remainingCollateral_ != 0) {\n            SettleLocalVars memory vars;\n\n            (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);\n            vars.hpbUnscaledDeposit    = Deposits.unscaledValueAt(deposits_, vars.index);\n            vars.unscaledDeposit       = vars.hpbUnscaledDeposit;\n            vars.price                 = _priceAt(vars.index);\n\n            if (vars.unscaledDeposit != 0) {\n                vars.debt              = Maths.wmul(remainingt0Debt_, inflator_);           // current debt to be settled\n                vars.maxSettleableDebt = Maths.floorWmul(remainingCollateral_, vars.price); // max debt that can be settled with existing collateral\n                vars.scaledDeposit     = Maths.wmul(vars.scale, vars.unscaledDeposit);\n\n                // 1) bucket deposit covers remaining loan debt to settle, loan's collateral can cover remaining loan debt to settle\n                if (vars.scaledDeposit >= vars.debt && vars.maxSettleableDebt >= vars.debt) {\n                    // remove only what's needed to settle the debt\n                    vars.unscaledDeposit = Maths.wdiv(vars.debt, vars.scale);\n                    vars.collateralUsed  = Maths.ceilWdiv(vars.debt, vars.price);\n\n                    // settle the entire debt\n                    remainingt0Debt_ = 0;\n                }\n                // 2) bucket deposit can not cover all of loan's remaining debt, bucket deposit is the constraint\n                else if (vars.maxSettleableDebt >= vars.scaledDeposit) {\n                    vars.collateralUsed = Maths.ceilWdiv(vars.scaledDeposit, vars.price);\n\n                    // subtract from debt the corresponding t0 amount of deposit\n                    remainingt0Debt_ -= Maths.floorWdiv(vars.scaledDeposit, inflator_);\n                }\n                // 3) loan's collateral can not cover remaining loan debt to settle, loan collateral is the constraint\n                else {\n                    vars.unscaledDeposit = Maths.wdiv(vars.maxSettleableDebt, vars.scale);\n                    vars.collateralUsed  = remainingCollateral_;\n\n                    remainingt0Debt_ -= Maths.floorWdiv(vars.maxSettleableDebt, inflator_);\n                }\n\n                // remove settled collateral from loan\n                remainingCollateral_ -= vars.collateralUsed;\n\n                // use HPB bucket to swap loan collateral for loan debt\n                Bucket storage hpb = buckets_[vars.index];\n                vars.hpbLP         = hpb.lps;\n                vars.hpbCollateral = hpb.collateral + vars.collateralUsed;\n\n                // set amount to remove as min of calculated amount and available deposit (to prevent rounding issues)\n                vars.unscaledDeposit    = Maths.min(vars.hpbUnscaledDeposit, vars.unscaledDeposit);\n                vars.hpbUnscaledDeposit -= vars.unscaledDeposit;\n\n                // remove amount to settle debt from bucket (could be entire deposit or only the settled debt)\n                Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit);\n\n                // check if bucket healthy - set bankruptcy if collateral is 0 and entire deposit was used to settle and there's still LP\n                if (vars.hpbCollateral == 0 && vars.hpbUnscaledDeposit == 0 && vars.hpbLP != 0) {\n                    hpb.lps            = 0;\n                    hpb.bankruptcyTime = block.timestamp;\n\n                    emit BucketBankruptcy(\n                        vars.index,\n                        vars.hpbLP\n                    );\n                } else {\n                    // add settled collateral into bucket\n                    hpb.collateral = vars.hpbCollateral;\n                }\n\n            } else {\n                // Deposits in the tree is zero, insert entire collateral into lowest bucket 7388\n                Buckets.addCollateral(\n                    buckets_[vars.index],\n                    params_.borrower,\n                    0,  // zero deposit in bucket\n                    remainingCollateral_,\n                    vars.price\n                );\n                // entire collateral added into bucket, no borrower pledged collateral remaining\n                remainingCollateral_ = 0;\n            }\n\n            --bucketDepth_;\n        }\n    }\n\n    /**\n     *  @notice Called to forgive bad debt starting from next `HPB`, up to the number of remaining buckets depth.\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.unscaledRemove()` (remove amount in `Fenwick` tree, from index):\n     *  @dev      update `values` array state\n     *  @dev      reset `bucket.lps` accumulator and update `bucket.bankruptcyTime`\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     *  @param  buckets_         Struct for pool buckets state.\n     *  @param  deposits_        Struct for pool deposits state.\n     *  @param  params_          Struct containing params for settle action.\n     *  @param  borrower_        Struct containing borrower details.\n     *  @param  inflator_        Current pool inflator.\n     *  @return remainingt0Debt_ Remaining borrower `t0` debt after forgiving bad debt in case not enough buckets used.\n     */\n    function _forgiveBadDebt(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        SettleParams memory params_,\n        Borrower memory borrower_,\n        uint256 inflator_\n    ) internal returns (uint256 remainingt0Debt_) {\n        remainingt0Debt_ = borrower_.t0Debt;\n\n        // loop through remaining buckets if there's still debt to forgive\n        while (params_.bucketDepth != 0 && remainingt0Debt_ != 0) {\n\n            (uint256 index, , uint256 scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);\n            uint256 unscaledDeposit          = Deposits.unscaledValueAt(deposits_, index);\n            uint256 depositToRemove          = Maths.wmul(scale, unscaledDeposit);\n            uint256 debt                     = Maths.wmul(remainingt0Debt_, inflator_);\n            uint256 depositRemaining;\n\n            // 1) bucket deposit covers entire loan debt to settle, no constraints needed\n            if (depositToRemove >= debt) {\n                // no remaining debt to forgive\n                remainingt0Debt_ = 0;\n\n                uint256 depositUsed = Maths.wdiv(debt, scale);\n                depositRemaining = unscaledDeposit - depositUsed;\n\n                // Remove deposit used to forgive bad debt from bucket\n                Deposits.unscaledRemove(deposits_, index, depositUsed);\n\n            // 2) loan debt to settle exceeds bucket deposit, bucket deposit is the constraint\n            } else {\n                // subtract from remaining debt the corresponding t0 amount of deposit\n                remainingt0Debt_ -= Maths.floorWdiv(depositToRemove, inflator_);\n\n                // Remove all deposit from bucket\n                Deposits.unscaledRemove(deposits_, index, unscaledDeposit);\n            }\n\n            Bucket storage hpbBucket = buckets_[index];\n            uint256 bucketLP = hpbBucket.lps;\n            // If the remaining deposit and resulting bucket collateral is so small that the exchange rate\n            // rounds to 0, then bankrupt the bucket.  Note that lhs are WADs, so the\n            // quantity is naturally 1e18 times larger than the actual product\n            if (depositRemaining * Maths.WAD + hpbBucket.collateral * _priceAt(index) <= bucketLP) {\n                // existing LP for the bucket shall become unclaimable\n                hpbBucket.lps            = 0;\n                hpbBucket.bankruptcyTime = block.timestamp;\n\n                emit BucketBankruptcy(\n                    index,\n                    bucketLP\n                );\n            }\n\n            --params_.bucketDepth;\n        }\n    }\n\n}"
    }
  ]
}