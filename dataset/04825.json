{
  "Title": "[46] Protocol should consider supporting deposits of pure erc20s",
  "Content": "\n### Proof of Concept\n\nHere is how a token's deposit gets finalized: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/zksync/contracts/bridge/L2SharedBridge.sol#L97\n\nThat is the contract creates the token address if the deposit for this token has never been made, but before that the user needs to deposit their tokens via the L1 shared bridge.\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L243-L267\n\n```solidity\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal view returns (bytes memory) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        return abi.encodeCall(IL2Bridge.finalizeDeposit, (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData));\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory) {\n        if (_token == ETH_TOKEN_ADDRESS) {\n            bytes memory name = bytes(\"Ether\");\n            bytes memory symbol = bytes(\"ETH\");\n            bytes memory decimals = abi.encode(uint8(18));\n            return abi.encode(name, symbol, decimals); // when depositing eth to a non-eth based chain it is an ERC20\n        }\n        //@audit using staticcall for a call that is going to revert? Not all tokens support the name, symbol and decimal getters\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        return abi.encode(data1, data2, data3);\n    }\n```\nThis function is inevitably called whenever executing `depositLegacyErc20Bridge()` & `bridgehubDeposit()`, used to generate a calldata for calling the deposit finalization, issue is that while the call is being routed to `_getERC20Getters()` and in the case where the token is not eth, protocol assumes the token implements the `name(), symbol(), & decimals()` function, but contrary to this assumption, these getter functions are not part of the original `EIP20` specification and as such not all tokens support this, causing an attempt get this deposit calldata revert for pure EIP20 tokens.\n\n### Impact\n\nPure eip-20 tokens are not supported, since there is an inability to execute both `depositLegacyErc20Bridge()` & `bridgehubDeposit()` functions for these tokens\n\n### Recommended Mitigation Steps\n\nReimplement a logic to allow for the support of pure eip20 tokens.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/zksync/contracts/bridge/L2SharedBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {BeaconProxy} from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport {IL1ERC20Bridge} from \"./interfaces/IL1ERC20Bridge.sol\";\nimport {IL2SharedBridge} from \"./interfaces/IL2SharedBridge.sol\";\nimport {IL2StandardToken} from \"./interfaces/IL2StandardToken.sol\";\n\nimport {L2StandardERC20} from \"./L2StandardERC20.sol\";\nimport {AddressAliasHelper} from \"../vendor/AddressAliasHelper.sol\";\nimport {L2ContractHelper, DEPLOYER_SYSTEM_CONTRACT, L2_BASE_TOKEN_ADDRESS, IContractDeployer} from \"../L2ContractHelper.sol\";\nimport {SystemContractsCaller} from \"../SystemContractsCaller.sol\";\nimport {ERA_CHAIN_ID, ERA_WETH_ADDRESS} from \"../Config.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The \"default\" bridge implementation for the ERC20 tokens. Note, that it does not\n/// support any custom token logic, i.e. rebase tokens' functionality is not supported.\ncontract L2SharedBridge is IL2SharedBridge, Initializable {\n    /// @dev The address of the L1 bridge counterpart.\n    address public override l1Bridge;\n\n    /// @dev Contract that stores the implementation address for token.\n    /// @dev For more details see https://docs.openzeppelin.com/contracts/3.x/api/proxy#UpgradeableBeacon.\n    UpgradeableBeacon public l2TokenBeacon;\n\n    /// @dev Bytecode hash of the proxy for tokens deployed by the bridge.\n    bytes32 internal l2TokenProxyBytecodeHash;\n\n    /// @dev A mapping l2 token address => l1 token address\n    mapping(address l2TokenAddress => address l1TokenAddress) public override l1TokenAddress;\n\n    address private l1LegacyBridge;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Disable the initialization to prevent Parity hack.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the bridge contract for later use. Expected to be used in the proxy.\n    /// @param _l1Bridge The address of the L1 Bridge contract.\n    /// @param _l2TokenProxyBytecodeHash The bytecode hash of the proxy for tokens deployed by the bridge.\n    /// @param _aliasedOwner The address of the governor contract.\n    function initialize(\n        address _l1Bridge,\n        address _l1LegecyBridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _aliasedOwner\n    ) external reinitializer(2) {\n        require(_l1Bridge != address(0), \"bf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n        require(_aliasedOwner != address(0), \"sf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n\n        l1Bridge = _l1Bridge;\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n\n        if (block.chainid != ERA_CHAIN_ID) {\n            address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n            l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n            l2TokenBeacon.transferOwnership(_aliasedOwner);\n        } else {\n            require(_l1LegecyBridge != address(0), \"bf2\");\n            // l2StandardToken and l2TokenBeacon are already deployed on ERA, and stored in the proxy\n        }\n    }\n\n    /// @notice Finalize the deposit and mint funds\n    /// @param _l1Sender The account address that initiated the deposit on L1\n    /// @param _l2Receiver The account address that would receive minted ether\n    /// @param _l1Token The address of the token that was locked on the L1\n    /// @param _amount Total amount of tokens deposited from L1\n    /// @param _data The additional data that user can pass with the deposit\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override {\n        // Only the L1 bridge counterpart can initiate and finalize the deposit.\n        require(\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1Bridge ||\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1LegacyBridge,\n            \"mq\"\n        );\n        require(msg.value == 0, \"Value should be 0 for ERC20 bridge\");\n\n        address expectedL2Token = l2TokenAddress(_l1Token);\n        address currentL1Token = l1TokenAddress[expectedL2Token];\n        if (currentL1Token == address(0)) {\n            address deployedToken = _deployL2Token(_l1Token, _data);\n            require(deployedToken == expectedL2Token, \"mt\");\n            l1TokenAddress[expectedL2Token] = _l1Token;\n        } else {\n            require(currentL1Token == _l1Token, \"gg\"); // Double check that the expected value equal to real one\n        }\n\n        IL2StandardToken(expectedL2Token).bridgeMint(_l2Receiver, _amount);\n        emit FinalizeDeposit(_l1Sender, _l2Receiver, expectedL2Token, _amount);\n    }\n\n    /// @dev Deploy and initialize the L2 token for the L1 counterpart\n    function _deployL2Token(address _l1Token, bytes calldata _data) internal returns (address) {\n        bytes32 salt = _getCreate2Salt(_l1Token);\n\n        BeaconProxy l2Token = _deployBeaconProxy(salt);\n        L2StandardERC20(address(l2Token)).bridgeInitialize(_l1Token, _data);\n\n        return address(l2Token);\n    }\n\n    /// @notice Initiates a withdrawal by burning funds on the contract and sending the message to L1\n    /// where tokens would be unlocked\n    /// @param _l1Receiver The account address that should receive funds on L1\n    /// @param _l2Token The L2 token address which is withdrawn\n    /// @param _amount The total amount of tokens to be withdrawn\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external override {\n        require(_amount > 0, \"Amount cannot be zero\");\n\n        IL2StandardToken(_l2Token).bridgeBurn(msg.sender, _amount);\n\n        address l1Token = l1TokenAddress[_l2Token];\n        require(l1Token != address(0), \"yh\");\n\n        bytes memory message = _getL1WithdrawMessage(_l1Receiver, l1Token, _amount);\n        L2ContractHelper.sendMessageToL1(message);\n\n        emit WithdrawalInitiated(msg.sender, _l1Receiver, _l2Token, _amount);\n    }\n\n    /// @dev Encode the message for l2ToL1log sent with withdraw initialization\n    function _getL1WithdrawMessage(\n        address _to,\n        address _l1Token,\n        uint256 _amount\n    ) internal pure returns (bytes memory) {\n        // note we use the IL1ERC20Bridge.finalizeWithdrawal function selector to specify the selector for L1<>L2 messages,\n        // and we use this interface so that when the switch happened the old messages could be processed\n        return abi.encodePacked(IL1ERC20Bridge.finalizeWithdrawal.selector, _to, _l1Token, _amount);\n    }\n\n    /// @return Address of an L2 token counterpart\n    function l2TokenAddress(address _l1Token) public view override returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n        bytes32 salt = _getCreate2Salt(_l1Token);\n        return\n            L2ContractHelper.computeCreate2Address(address(this), salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n\n    /// @dev Convert the L1 token address to the create2 salt of deployed L2 token\n    function _getCreate2Salt(address _l1Token) internal pure returns (bytes32 salt) {\n        salt = bytes32(uint256(uint160(_l1Token)));\n    }\n\n    /// @dev Deploy the beacon proxy for the L2 token, while using ContractDeployer system contract.\n    /// @dev This function uses raw call to ContractDeployer to make sure that exactly `l2TokenProxyBytecodeHash` is used\n    /// for the code of the proxy.\n    function _deployBeaconProxy(bytes32 salt) internal returns (BeaconProxy proxy) {\n        (bool success, bytes memory returndata) = SystemContractsCaller.systemCallWithReturndata(\n            uint32(gasleft()),\n            DEPLOYER_SYSTEM_CONTRACT,\n            0,\n            abi.encodeCall(\n                IContractDeployer.create2,\n                (salt, l2TokenProxyBytecodeHash, abi.encode(address(l2TokenBeacon), \"\"))\n            )\n        );\n\n        // The deployment should be successful and return the address of the proxy\n        require(success, \"mk\");\n        proxy = BeaconProxy(abi.decode(returndata, (address)));\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IL1ERC20Bridge} from \"./interfaces/IL1ERC20Bridge.sol\";\nimport {IL1SharedBridge} from \"./interfaces/IL1SharedBridge.sol\";\nimport {IL2Bridge} from \"./interfaces/IL2Bridge.sol\";\n\nimport {IMailbox} from \"../state-transition/chain-interfaces/IMailbox.sol\";\nimport {L2Message, TxStatus} from \"../common/Messaging.sol\";\nimport {UnsafeBytes} from \"../common/libraries/UnsafeBytes.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {AddressAliasHelper} from \"../vendor/AddressAliasHelper.sol\";\nimport {ERA_CHAIN_ID, ERA_ERC20_BRIDGE_ADDRESS, ETH_TOKEN_ADDRESS, ERA_DIAMOND_PROXY, TWO_BRIDGES_MAGIC_VALUE} from \"../common/Config.sol\";\nimport {IBridgehub, L2TransactionRequestTwoBridgesInner, L2TransactionRequestDirect} from \"../bridgehub/IBridgehub.sol\";\nimport {IGetters} from \"../state-transition/chain-interfaces/IGetters.sol\";\nimport {L2_BASE_TOKEN_SYSTEM_CONTRACT_ADDR} from \"../common/L2ContractAddresses.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Bridges assets between L1 and hyperchains, supporting both ETH and ERC20 tokens.\n/// @dev Designed for use with a proxy for upgradability.\ncontract L1SharedBridge is IL1SharedBridge, ReentrancyGuard, Initializable, Ownable2Step {\n    using SafeERC20 for IERC20;\n\n    /// @dev The address of the WETH token on L1.\n    address public immutable override l1WethAddress;\n\n    /// @dev Bridgehub smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication.\n    IBridgehub public immutable override bridgehub;\n\n    /// @dev Legacy bridge smart contract that used to hold ERC20 tokens.\n    IL1ERC20Bridge public immutable override legacyBridge;\n\n    /// @dev Stores the first batch number on the zkSync Era Diamond Proxy that was settled after Shared Bridge upgrade.\n    /// This variable is used to differentiate between pre-upgrade and post-upgrade withdrawals. Withdrawals from batches older\n    /// than this value are considered to have been finalized prior to the upgrade and handled separately.\n    uint256 internal eraFirstPostUpgradeBatch;\n\n    /// @dev A mapping chainId => bridgeProxy. Used to store the bridge proxy's address, and to see if it has been deployed yet.\n    mapping(uint256 chainId => address l2Bridge) public override l2BridgeAddress;\n\n    /// @dev A mapping chainId => L2 deposit transaction hash => keccak256(abi.encode(account, tokenAddress, amount))\n    /// @dev Tracks deposit transactions from L2 to enable users to claim their funds if a deposit fails.\n    mapping(uint256 chainId => mapping(bytes32 l2DepositTxHash => bytes32 depositDataHash))\n        public\n        override depositHappened;\n\n    /// @dev Tracks the processing status of L2 to L1 messages, indicating whether a message has already been finalized.\n    mapping(uint256 chainId => mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized)))\n        public isWithdrawalFinalized;\n\n    /// @dev Indicates whether the hyperbridging is enabled for a given chain.\n    mapping(uint256 chainId => bool enabled) internal hyperbridgingEnabled;\n\n    /// @dev Maps token balances for each chain to prevent unauthorized spending across hyperchains.\n    /// This serves as a security measure until hyperbridging is implemented.\n    mapping(uint256 chainId => mapping(address l1Token => uint256 balance)) internal chainBalance;\n\n    /// @notice Checks that the message sender is the bridgehub.\n    modifier onlyBridgehub() {\n        require(msg.sender == address(bridgehub), \"ShB not BH\");\n        _;\n    }\n\n    /// @notice Checks that the message sender is the bridgehub or zkSync Era Diamond Proxy.\n    modifier onlyBridgehubOrEra(uint256 _chainId) {\n        require(\n            msg.sender == address(bridgehub) || (_chainId == ERA_CHAIN_ID && msg.sender == ERA_DIAMOND_PROXY),\n            \"L1SharedBridge: not bridgehub or era chain\"\n        );\n        _;\n    }\n\n    /// @notice Checks that the message sender is the legacy bridge.\n    modifier onlyLegacyBridge() {\n        require(msg.sender == address(legacyBridge), \"ShB not legacy bridge\");\n        _;\n    }\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(\n        address _l1WethAddress,\n        IBridgehub _bridgehub,\n        IL1ERC20Bridge _legacyBridge\n    ) reentrancyGuardInitializer {\n        _disableInitializers();\n        l1WethAddress = _l1WethAddress;\n        bridgehub = _bridgehub;\n        legacyBridge = _legacyBridge;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @param _owner Address which can change L2 token implementation and upgrade the bridge\n    /// implementation. The owner is the Governor and separate from the ProxyAdmin from now on, so that the Governor can call the bridge.\n    function initialize(\n        address _owner,\n        uint256 _eraFirstPostUpgradeBatch\n    ) external reentrancyGuardInitializer initializer {\n        require(_owner != address(0), \"ShB owner 0\");\n        _transferOwnership(_owner);\n\n        eraFirstPostUpgradeBatch = _eraFirstPostUpgradeBatch;\n        l2BridgeAddress[ERA_CHAIN_ID] = ERA_ERC20_BRIDGE_ADDRESS;\n    }\n\n    /// @dev tranfer tokens from legacy erc20 bridge or mailbox and set chainBalance as part of migration process\n    function transferFundsFromLegacy(address _token, address _target, uint256 _targetChainId) external onlyOwner {\n        if (_token == ETH_TOKEN_ADDRESS) {\n            uint256 balanceBefore = address(this).balance;\n            IMailbox(_target).transferEthToSharedBridge();\n            uint256 balanceAfter = address(this).balance;\n            require(balanceAfter > balanceBefore, \"ShB: 0 eth transferred\");\n            chainBalance[_targetChainId][ETH_TOKEN_ADDRESS] =\n                chainBalance[_targetChainId][ETH_TOKEN_ADDRESS] +\n                balanceAfter -\n                balanceBefore;\n        } else {\n            uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n            uint256 amount = IERC20(_token).balanceOf(address(legacyBridge));\n            require(amount > 0, \"ShB: 0 amount to transfer\");\n            IL1ERC20Bridge(_target).tranferTokenToSharedBridge(_token, amount);\n            uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n            require(balanceAfter - balanceBefore == amount, \"ShB: wrong amount transferred\");\n            chainBalance[_targetChainId][_token] = chainBalance[_targetChainId][_token] + amount;\n        }\n    }\n\n    function receiveEth(uint256 _chainId) external payable {\n        require(bridgehub.getStateTransition(_chainId) == msg.sender, \"receiveEth not state transition\");\n    }\n\n    /// @dev Initializes the l2Bridge address by governance for a specific chain.\n    function initializeChainGovernance(uint256 _chainId, address _l2BridgeAddress) external onlyOwner {\n        l2BridgeAddress[_chainId] = _l2BridgeAddress;\n    }\n\n    /// @notice Allows bridgehub to acquire mintValue for L1->L2 transactions.\n    /// @dev If the corresponding L2 transaction fails, refunds are issued to a refund recipient on L2.\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable virtual onlyBridgehubOrEra(_chainId) {\n        if (_l1Token == ETH_TOKEN_ADDRESS) {\n            require(msg.value == _amount, \"L1SharedBridge: msg.value not equal to amount\");\n        } else {\n            // The Bridgehub also checks this, but we want to be sure\n            require(msg.value == 0, \"ShB m.v > 0 b d.it\");\n\n            uint256 amount = _depositFunds(_prevMsgSender, IERC20(_l1Token), _amount); // note if _prevMsgSender is this contract, this will return 0. This does not happen.\n            require(amount == _amount, \"3T\"); // The token has non-standard transfer logic\n        }\n\n        if (!hyperbridgingEnabled[_chainId]) {\n            chainBalance[_chainId][_l1Token] += _amount;\n        }\n        // Note that we don't save the deposited amount, as this is for the base token, which gets sent to the refundRecipient if the tx fails\n        emit BridgehubDepositBaseTokenInitiated(_chainId, _prevMsgSender, _l1Token, _amount);\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address.\n    /// @return The difference between the contract balance before and after the transferring of funds.\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @notice Initiates a deposit transaction within Bridgehub, used by `requestL2TransactionTwoBridges`.\n    function bridgehubDeposit(\n        uint256 _chainId,\n        address _prevMsgSender,\n        uint256, // l2Value, needed for Weth deposits in the future\n        bytes calldata _data\n    ) external payable override onlyBridgehub returns (L2TransactionRequestTwoBridgesInner memory request) {\n        require(l2BridgeAddress[_chainId] != address(0), \"ShB l2 bridge not deployed\");\n\n        (address _l1Token, uint256 _depositAmount, address _l2Receiver) = abi.decode(\n            _data,\n            (address, uint256, address)\n        );\n        require(_l1Token != l1WethAddress, \"ShB: WETH deposit not supported\");\n        require(bridgehub.baseToken(_chainId) != _l1Token, \"ShB: baseToken deposit not supported\");\n\n        uint256 amount;\n        if (_l1Token == ETH_TOKEN_ADDRESS) {\n            amount = msg.value;\n            require(_depositAmount == 0, \"ShB wrong withdraw amount\");\n        } else {\n            require(msg.value == 0, \"ShB m.v > 0 for BH d.it 2\");\n            amount = _depositAmount;\n\n            uint256 withdrawAmount = _depositFunds(_prevMsgSender, IERC20(_l1Token), _depositAmount);\n            require(withdrawAmount == _depositAmount, \"5T\"); // The token has non-standard transfer logic\n        }\n        require(amount != 0, \"6T\"); // empty deposit amount\n\n        bytes32 txDataHash = keccak256(abi.encode(_prevMsgSender, _l1Token, amount));\n        if (!hyperbridgingEnabled[_chainId]) {\n            chainBalance[_chainId][_l1Token] += amount;\n        }\n\n        {\n            // Request the finalization of the deposit on the L2 side\n            bytes memory l2TxCalldata = _getDepositL2Calldata(_prevMsgSender, _l2Receiver, _l1Token, amount);\n\n            request = L2TransactionRequestTwoBridgesInner({\n                magicValue: TWO_BRIDGES_MAGIC_VALUE,\n                l2Contract: l2BridgeAddress[_chainId],\n                l2Calldata: l2TxCalldata,\n                factoryDeps: new bytes[](0),\n                txDataHash: txDataHash\n            });\n        }\n        emit BridgehubDepositInitiated(_chainId, txDataHash, _prevMsgSender, _l2Receiver, _l1Token, amount);\n    }\n\n    /// @notice Confirms the acceptance of a transaction by the Mailbox, as part of the L2 transaction process within Bridgehub.\n    /// This function is utilized by `requestL2TransactionTwoBridges` to validate the execution of a transaction.\n    function bridgehubConfirmL2Transaction(\n        uint256 _chainId,\n        bytes32 _txDataHash,\n        bytes32 _txHash\n    ) external override onlyBridgehub {\n        require(depositHappened[_chainId][_txHash] == 0x00, \"ShB tx hap\");\n        depositHappened[_chainId][_txHash] = _txDataHash;\n        emit BridgehubDepositFinalized(_chainId, _txDataHash, _txHash);\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal view returns (bytes memory) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        return abi.encodeCall(IL2Bridge.finalizeDeposit, (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData));\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory) {\n        if (_token == ETH_TOKEN_ADDRESS) {\n            bytes memory name = bytes(\"Ether\");\n            bytes memory symbol = bytes(\"ETH\");\n            bytes memory decimals = abi.encode(uint8(18));\n            return abi.encode(name, symbol, decimals); // when depositing eth to a non-eth based chain it is an ERC20\n        }\n\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        return abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _amount The amount of the deposit that failed.\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external override {\n        _claimFailedDeposit(\n            false,\n            _chainId,\n            _depositSender,\n            _l1Token,\n            _amount,\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof\n        );\n    }\n\n    /// @dev Processes claims of failed deposit, whether they originated from the legacy bridge or the current system.\n    function _claimFailedDeposit(\n        bool _checkedInLegacyBridge,\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) internal nonReentrant {\n        {\n            bool proofValid = bridgehub.proveL1ToL2TransactionStatus(\n                _chainId,\n                _l2TxHash,\n                _l2BatchNumber,\n                _l2MessageIndex,\n                _l2TxNumberInBatch,\n                _merkleProof,\n                TxStatus.Failure\n            );\n            require(proofValid, \"yn\");\n        }\n        require(_amount > 0, \"y1\");\n\n        {\n            bool notCheckedInLegacyBridgeOrWeCanCheckDeposit;\n            {\n                // Deposits that happened before the upgrade cannot be checked here, they have to be claimed and checked in the legacyBridge\n                bool weCanCheckDepositHere = !_isEraLegacyWithdrawal(_chainId, _l2BatchNumber);\n                // Double claims are not possible, as we this check except for legacy bridge withdrawals\n                // Funds claimed before the update will still be recorded in the legacy bridge\n                // Note we double check NEW deposits if they are called from the legacy bridge\n                notCheckedInLegacyBridgeOrWeCanCheckDeposit = (!_checkedInLegacyBridge) || weCanCheckDepositHere;\n            }\n            if (notCheckedInLegacyBridgeOrWeCanCheckDeposit) {\n                bytes32 dataHash = depositHappened[_chainId][_l2TxHash];\n                bytes32 txDataHash = keccak256(abi.encode(_depositSender, _l1Token, _amount));\n                require(dataHash == txDataHash, \"ShB: d.it not hap\");\n                delete depositHappened[_chainId][_l2TxHash];\n            }\n        }\n\n        if (!hyperbridgingEnabled[_chainId]) {\n            // check that the chain has sufficient balance\n            require(chainBalance[_chainId][_l1Token] >= _amount, \"ShB n funds\");\n            chainBalance[_chainId][_l1Token] -= _amount;\n        }\n\n        // Withdraw funds\n        if (_l1Token == ETH_TOKEN_ADDRESS) {\n            bool callSuccess;\n            // Low-level assembly call, to avoid any memory copying (save gas)\n            assembly {\n                callSuccess := call(gas(), _depositSender, _amount, 0, 0, 0, 0)\n            }\n            require(callSuccess, \"ShB: claimFailedDeposit failed\");\n        } else {\n            IERC20(_l1Token).safeTransfer(_depositSender, _amount);\n            // Note we don't allow weth deposits anymore, but there might be legacy weth deposits.\n            // until we add Weth bridging capabilities, we don't wrap/unwrap weth to ether.\n        }\n\n        emit ClaimedFailedDepositSharedBridge(_chainId, _depositSender, _l1Token, _amount);\n    }\n\n    /// @dev Determines if a withdrawal was initiated on zkSync Era before the upgrade to the Shared Bridge.\n    /// @param _chainId The chain ID of the transaction to check.\n    /// @param _l2BatchNumber The L2 batch number for the withdrawal.\n    /// @return Whether withdrawal was initiated on zkSync Era before Shared Bridge upgrade.\n    function _isEraLegacyWithdrawal(uint256 _chainId, uint256 _l2BatchNumber) internal view returns (bool) {\n        return (_chainId == ERA_CHAIN_ID) && (_l2BatchNumber < eraFirstPostUpgradeBatch);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _chainId The chain ID of the transaction to check\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override {\n        // To avoid rewithdrawing txs that have already happened on the legacy bridge.\n        // Note: new withdraws are all recorded here, so double withdrawing them is not possible.\n        if (_isEraLegacyWithdrawal(_chainId, _l2BatchNumber)) {\n            require(!legacyBridge.isWithdrawalFinalized(_l2BatchNumber, _l2MessageIndex), \"ShB: legacy withdrawal\");\n        }\n        _finalizeWithdrawal(_chainId, _l2BatchNumber, _l2MessageIndex, _l2TxNumberInBatch, _message, _merkleProof);\n    }\n\n    struct MessageParams {\n        uint256 l2BatchNumber;\n        uint256 l2MessageIndex;\n        uint16 l2TxNumberInBatch;\n    }\n\n    /// @dev Internal function that handles the logic for finalizing withdrawals,\n    /// serving both the current bridge system and the legacy ERC20 bridge.\n    function _finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) internal nonReentrant returns (address l1Receiver, address l1Token, uint256 amount) {\n        require(!isWithdrawalFinalized[_chainId][_l2BatchNumber][_l2MessageIndex], \"Withdrawal is already finalized\");\n        isWithdrawalFinalized[_chainId][_l2BatchNumber][_l2MessageIndex] = true;\n\n        // Handling special case for withdrawal from zkSync Era initiated before Shared Bridge.\n        if (_isEraLegacyWithdrawal(_chainId, _l2BatchNumber)) {\n            // Checks that the withdrawal wasn't finalized already.\n            bool alreadyFinalized = IGetters(ERA_DIAMOND_PROXY).isEthWithdrawalFinalized(\n                _l2BatchNumber,\n                _l2MessageIndex\n            );\n            require(!alreadyFinalized, \"Withdrawal is already finalized 2\");\n        }\n\n        MessageParams memory messageParams = MessageParams({\n            l2BatchNumber: _l2BatchNumber,\n            l2MessageIndex: _l2MessageIndex,\n            l2TxNumberInBatch: _l2TxNumberInBatch\n        });\n        (l1Receiver, l1Token, amount) = _checkWithdrawal(_chainId, messageParams, _message, _merkleProof);\n\n        if (!hyperbridgingEnabled[_chainId]) {\n            // Check that the chain has sufficient balance\n            require(chainBalance[_chainId][l1Token] >= amount, \"ShB not enough funds 2\"); // not enought funds\n            chainBalance[_chainId][l1Token] -= amount;\n        }\n\n        if (l1Token == ETH_TOKEN_ADDRESS) {\n            bool callSuccess;\n            // Low-level assembly call, to avoid any memory copying (save gas)\n            assembly {\n                callSuccess := call(gas(), l1Receiver, amount, 0, 0, 0, 0)\n            }\n            require(callSuccess, \"ShB: withdraw failed\");\n        } else {\n            // Withdraw funds\n            IERC20(l1Token).safeTransfer(l1Receiver, amount);\n        }\n        emit WithdrawalFinalizedSharedBridge(_chainId, l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Verifies the validity of a withdrawal message from L2 and returns details of the withdrawal.\n    function _checkWithdrawal(\n        uint256 _chainId,\n        MessageParams memory _messageParams,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) internal view returns (address l1Receiver, address l1Token, uint256 amount) {\n        (l1Receiver, l1Token, amount) = _parseL2WithdrawalMessage(_chainId, _message);\n        L2Message memory l2ToL1Message;\n        {\n            bool baseTokenWithdrawal = (l1Token == bridgehub.baseToken(_chainId));\n            address l2Sender = baseTokenWithdrawal ? L2_BASE_TOKEN_SYSTEM_CONTRACT_ADDR : l2BridgeAddress[_chainId];\n\n            l2ToL1Message = L2Message({\n                txNumberInBatch: _messageParams.l2TxNumberInBatch,\n                sender: l2Sender,\n                data: _message\n            });\n        }\n\n        bool success = bridgehub.proveL2MessageInclusion(\n            _chainId,\n            _messageParams.l2BatchNumber,\n            _messageParams.l2MessageIndex,\n            l2ToL1Message,\n            _merkleProof\n        );\n        require(success, \"ShB withd w proof\"); // withdrawal wrong proof\n    }\n\n    function _parseL2WithdrawalMessage(\n        uint256 _chainId,\n        bytes memory _l2ToL1message\n    ) internal view returns (address l1Receiver, address l1Token, uint256 amount) {\n        // We check that the message is long enough to read the data.\n        // Please note that there are two versions of the message:\n        // 1. The message that is sent by `withdraw(address _l1Receiver)`\n        // It should be equal to the length of the bytes4 function signature + address l1Receiver + uint256 amount = 4 + 20 + 32 = 56 (bytes).\n        // 2. The message that is sent by `withdrawWithMessage(address _l1Receiver, bytes calldata _additionalData)`\n        // It should be equal to the length of the following:\n        // bytes4"
    }
  ]
}