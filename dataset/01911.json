{
  "Title": "M-5: Cannot permissionless settle the vault account if the user use a blacklisted account",
  "Content": "# Issue M-5: Cannot permissionless settle the vault account if the user use a blacklisted account \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/155 \n\n## Found by \nShadowForce\n## Summary\n\nCannot permissionless settle the vault account if the user use a blacklisted account\n\n## Vulnerability Detail\n\nIn VaultAccoutnAction.sol, one of the critical function is \n\n```solidity\n    /// @notice Settles a matured vault account by transforming it from an fCash maturity into\n    /// a prime cash account. This method is not authenticated, anyone can settle a vault account\n    /// without permission. Generally speaking, this action is economically equivalent no matter\n    /// when it is called. In some edge conditions when the vault is holding prime cash, it is\n    /// advantageous for the vault account to have this called sooner. All vault account actions\n    /// will first settle the vault account before taking any further actions.\n    /// @param account the address to settle\n    /// @param vault the vault the account is in\n    function settleVaultAccount(address account, address vault) external override nonReentrant {\n        requireValidAccount(account);\n        require(account != vault);\n\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n        \n        // Require that the account settled, otherwise we may leave the account in an unintended\n        // state in this method because we allow it to skip the min borrow check in the next line.\n        (bool didSettle, bool didTransfer) = vaultAccount.settleVaultAccount(vaultConfig);\n        require(didSettle, \"No Settle\");\n\n        vaultAccount.accruePrimeCashFeesToDebt(vaultConfig);\n\n        // Skip Min Borrow Check so that accounts can always be settled\n        vaultAccount.setVaultAccount({vaultConfig: vaultConfig, checkMinBorrow: false});\n\n        if (didTransfer) {\n            // If the vault did a transfer (i.e. withdrew cash) we have to check their collateral ratio. There\n            // is an edge condition where a vault with secondary borrows has an emergency exit. During that process\n            // an account will be left some cash balance in both currencies. It may have excess cash in one and\n            // insufficient cash in the other. A withdraw of the excess in one side will cause the vault account to\n            // be insolvent if we do not run this check. If this scenario indeed does occur, the vault itself must\n            // be upgraded in order to facilitate orderly exits for all of the accounts since they will be prevented\n            // from settling.\n            IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n        }\n    }\n\n```\n\nas the comment suggests, this function should be called permissionless\n\nand the comment is, which means there should not be able to permissionless reject account settlement\n\n```solidity\n/// will first settle the vault account before taking any further actions.\n```\n\nthis is calling\n\n```solidity\n  (bool didSettle, bool didTransfer) = vaultAccount.settleVaultAccount(vaultConfig);\n```\n\nwhich calls\n\n```solidity\n    /// @notice Settles a matured vault account by transforming it from an fCash maturity into\n    /// a prime cash account. This method is not authenticated, anyone can settle a vault account\n    /// without permission. Generally speaking, this action is economically equivalent no matter\n    /// when it is called. In some edge conditions when the vault is holding prime cash, it is\n    /// advantageous for the vault account to have this called sooner. All vault account actions\n    /// will first settle the vault account before taking any further actions.\n    /// @param account the address to settle\n    /// @param vault the vault the account is in\n    function settleVaultAccount(address account, address vault) external override nonReentrant {\n        requireValidAccount(account);\n        require(account != vault);\n\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n        \n        // Require that the account settled, otherwise we may leave the account in an unintended\n        // state in this method because we allow it to skip the min borrow check in the next line.\n        (bool didSettle, bool didTransfer) = vaultAccount.settleVaultAccount(vaultConfig);\n        require(didSettle, \"No Settle\");\n```\n\nbasically this calls\n\n```solidity\n        // Calculates the net settled cash if there is any temp cash balance that is net off\n        // against the settled prime debt.\n        bool didTransferPrimary;\n        (accountPrimeStorageValue, didTransferPrimary) = repayAccountPrimeDebtAtSettlement(\n            vaultConfig.primeRate,\n            primeVaultState,\n            vaultConfig.borrowCurrencyId,\n            vaultConfig.vault,\n            vaultAccount.account,\n            vaultAccount.tempCashBalance,\n            accountPrimeStorageValue\n        );\n```\n\ncalling\n\n```solidity\n    function repayAccountPrimeDebtAtSettlement(\n        PrimeRate memory pr,\n        VaultStateStorage storage primeVaultState,\n        uint16 currencyId,\n        address vault,\n        address account,\n        int256 accountPrimeCash,\n        int256 accountPrimeStorageValue\n    ) internal returns (int256 finalPrimeDebtStorageValue, bool didTransfer) {\n        didTransfer = false;\n        finalPrimeDebtStorageValue = accountPrimeStorageValue;\n        \n        if (accountPrimeCash > 0) {\n            // netPrimeDebtRepaid is a negative number\n            int256 netPrimeDebtRepaid = pr.convertUnderlyingToDebtStorage(\n                pr.convertToUnderlying(accountPrimeCash).neg()\n            );\n\n            int256 netPrimeDebtChange;\n            if (netPrimeDebtRepaid < accountPrimeStorageValue) {\n                // If the net debt change is greater than the debt held by the account, then only\n                // decrease the total prime debt by what is held by the account. The residual amount\n                // will be refunded to the account via a direct transfer.\n                netPrimeDebtChange = accountPrimeStorageValue;\n                finalPrimeDebtStorageValue = 0;\n\n                int256 primeCashRefund = pr.convertFromUnderlying(\n                    pr.convertDebtStorageToUnderlying(netPrimeDebtChange.sub(accountPrimeStorageValue))\n                );\n                TokenHandler.withdrawPrimeCash(\n                    account, currencyId, primeCashRefund, pr, false // ETH will be transferred natively\n                );\n                didTransfer = true;\n            } else {\n                // In this case, part of the account's debt is repaid.\n                netPrimeDebtChange = netPrimeDebtRepaid;\n                finalPrimeDebtStorageValue = accountPrimeStorageValue.sub(netPrimeDebtRepaid);\n            }\n\n```\n\nthe token withdrawal logic above try to push ETH to accout\n\n```solidity\nTokenHandler.withdrawPrimeCash(\n\taccount, currencyId, primeCashRefund, pr, false // ETH will be transferred natively\n);\n```\n\nthis is calling\n\n```solidity\n  function withdrawPrimeCash(\n        address account,\n        uint16 currencyId,\n        int256 primeCashToWithdraw,\n        PrimeRate memory primeRate,\n        bool withdrawWrappedNativeToken\n    ) internal returns (int256 netTransferExternal) {\n        if (primeCashToWithdraw == 0) return 0;\n        require(primeCashToWithdraw < 0);\n\n        Token memory underlying = getUnderlyingToken(currencyId);\n        netTransferExternal = convertToExternal(\n            underlying, \n            primeRate.convertToUnderlying(primeCashToWithdraw) \n        );\n\n        // Overflow not possible due to int256\n        uint256 withdrawAmount = uint256(netTransferExternal.neg());\n        _redeemMoneyMarketIfRequired(currencyId, underlying, withdrawAmount);\n\n        if (underlying.tokenType == TokenType.Ether) {\n            GenericToken.transferNativeTokenOut(account, withdrawAmount, withdrawWrappedNativeToken);\n        } else {\n            GenericToken.safeTransferOut(underlying.tokenAddress, account, withdrawAmount);\n        }\n\n        _postTransferPrimeCashUpdate(account, currencyId, netTransferExternal, underlying, primeRate);\n    }\n```\n\nnote the function call\n\n```solidity\nif (underlying.tokenType == TokenType.Ether) {\n\tGenericToken.transferNativeTokenOut(account, withdrawAmount, withdrawWrappedNativeToken);\n} else {\n\tGenericToken.safeTransferOut(underlying.tokenAddress, account, withdrawAmount);\n}\n```\n\nif the token type is not ETHER,\n\nwe are transfer the underlying ERC20 token to the account\n\n```solidity\nGenericToken.safeTransferOut(underlying.tokenAddress, account, withdrawAmount);\n```\n\nthe token in-scoped is\n\n```solidity\nERC20:  Any Non-Rebasing token. ex. USDC, DAI, USDT (future), wstETH, WETH, WBTC, FRAX, CRV, etc.\n```\n\nUSDC is common token that has blacklisted\n\nif the account is blacklisted, the transfer would revert and the account cannot be settled!\n\n## Impact\n\nwhat are the impact, \n\nper comment\n\n```solidity\n/// will first settle the vault account before taking any further actions.\n```\n\nif that is too vague, I can list three, there are more!\n\n1. there are certain action that need to be done after the vault settlement, for example, liqudation require the vault settlement first\n\nhttps://github.com/notional-finance/contracts-v2/blob/b20a45c912785fab5f2b62992e5260f44dbae197/contracts/external/actions/VaultLiquidationAction.sol#L229\n\n2. there are case that require force vault settlement, actually one example is notional need to force the settle the vault during migration! (this is just the case to show user should be able to permissionless reject settlement)\n\n\n## Code Snippet\n\nhttps://github.com/notional-finance/contracts-v2/blob/b20a45c912785fab5f2b62992e5260f44dbae197/contracts/internal/balances/TokenHandler.sol#L241\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nmaybe let admin bypass the withdrawPrimeCash and force settle the account to not let settlement block further action!\n\n\n\n## Discussion\n\n**jeffywu**\n\nValid issue, transfers during supposedly permissionless settlement can indeed cause issues.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts/external/actions/VaultLiquidationAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    VaultState,\n    VaultAccountHealthFactors,\n    VaultConfig,\n    VaultAccount,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {Emitter} from \"../../internal/Emitter.sol\";\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {VaultConfiguration} from \"../../internal/vaults/VaultConfiguration.sol\";\nimport {VaultAccountLib} from \"../../internal/vaults/VaultAccount.sol\";\nimport {VaultValuation} from \"../../internal/vaults/VaultValuation.sol\";\nimport {VaultSecondaryBorrow} from \"../../internal/vaults/VaultSecondaryBorrow.sol\";\nimport {VaultStateLib} from \"../../internal/vaults/VaultState.sol\";\nimport {TokenHandler} from \"../../internal/balances/TokenHandler.sol\";\n\nimport {SettleAssetsExternal} from \"../SettleAssetsExternal.sol\";\nimport {FreeCollateralExternal} from \"../FreeCollateralExternal.sol\";\n\nimport {\n    IVaultLiquidationAction,\n    IVaultAccountHealth\n} from \"../../../interfaces/notional/IVaultController.sol\";\n\ncontract VaultLiquidationAction is ActionGuards, IVaultLiquidationAction {\n    using VaultConfiguration for VaultConfig;\n    using VaultAccountLib for VaultAccount;\n    using VaultStateLib for VaultState;\n    using PrimeRateLib for PrimeRate;\n    using TokenHandler for Token;\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n\n\n    /// @notice If an account is below the minimum collateral ratio, this method wil deleverage (liquidate)\n    /// that account. `depositAmountPrimeCash` in the borrow currency will be transferred from the liquidator\n    /// and used to offset the account's debt position. The liquidator will receive either vaultShares or\n    /// cash depending.\n    /// @param account the address that will exit the vault\n    /// @param vault the vault to enter\n    /// @param liquidator the address that will receive profits from liquidation\n    /// @param currencyIndex 0 refers to primary borrow, 1 or 2 will refer to one of the secondary\n    /// currencies (if any)\n    /// @param depositUnderlyingInternal amount of underlying to deposit, in 8 decimal underlying precision\n    /// @return vaultSharesToLiquidator amount of vaultShares received from liquidation\n    /// @return depositAmountPrimeCash amount of prime cash deposited from liquidation\n    function deleverageAccount(\n        address account,\n        address vault,\n        address liquidator,\n        uint16 currencyIndex,\n        int256 depositUnderlyingInternal\n    ) external payable nonReentrant override returns (\n        uint256 vaultSharesToLiquidator,\n        int256 depositAmountPrimeCash\n    ) {\n        require(currencyIndex < 3);\n        (\n            VaultConfig memory vaultConfig,\n            VaultAccount memory vaultAccount,\n            VaultState memory vaultState\n        ) = _authenticateDeleverage(account, vault, liquidator);\n\n        PrimeRate memory pr;\n        // Currency Index is validated in this method\n        (\n            depositUnderlyingInternal,\n            vaultSharesToLiquidator,\n            pr\n        ) = IVaultAccountHealth(address(this)).calculateDepositAmountInDeleverage(\n            currencyIndex, vaultAccount, vaultConfig, vaultState, depositUnderlyingInternal\n        );\n\n        uint16 currencyId = vaultConfig.borrowCurrencyId;\n        if (currencyIndex == 1) currencyId = vaultConfig.secondaryBorrowCurrencies[0];\n        else if (currencyIndex == 2) currencyId = vaultConfig.secondaryBorrowCurrencies[1];\n\n        Token memory token = TokenHandler.getUnderlyingToken(currencyId);\n        // Excess ETH is returned to the liquidator natively\n        (/* */, depositAmountPrimeCash) = TokenHandler.depositUnderlyingExternal(\n            liquidator, currencyId, token.convertToExternal(depositUnderlyingInternal), pr, false \n        );\n\n        // Do not skip the min borrow check here\n        vaultAccount.vaultShares = vaultAccount.vaultShares.sub(vaultSharesToLiquidator);\n        if (vaultAccount.maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // Vault account will not incur a cash balance if they are in the prime cash maturity, their debts\n            // will be paid down directly.\n            _reduceAccountDebt(\n                vaultConfig, vaultState, vaultAccount, pr, currencyIndex, depositUnderlyingInternal, true\n            );\n            depositAmountPrimeCash = 0;\n        }\n\n        // Check min borrow in this liquidation method, the deleverage calculation should adhere to the min borrow\n        vaultAccount.setVaultAccountForLiquidation(vaultConfig, currencyIndex, depositAmountPrimeCash, true);\n\n        emit VaultDeleverageAccount(vault, account, currencyId, vaultSharesToLiquidator, depositAmountPrimeCash);\n        emit VaultLiquidatorProfit(vault, account, liquidator, vaultSharesToLiquidator, true);\n\n        _transferVaultSharesToLiquidator(\n            liquidator, vaultConfig, vaultSharesToLiquidator, vaultAccount.maturity\n        );\n\n        Emitter.emitVaultDeleverage(\n            liquidator, account, vault, currencyId, vaultState.maturity,\n            depositAmountPrimeCash, vaultSharesToLiquidator\n        );\n    }\n\n    /// @notice If an account has a cash balance, a liquidator can purchase the cash and provide\n    /// fCash to the account to reduce it's debt balance.\n    function liquidateVaultCashBalance(\n        address account,\n        address vault,\n        address liquidator,\n        uint256 currencyIndex,\n        int256 fCashDeposit\n    ) external nonReentrant override returns (int256 cashToLiquidator) {\n        (\n            VaultConfig memory vaultConfig,\n            VaultAccount memory vaultAccount,\n            VaultState memory vaultState\n        ) = _authenticateDeleverage(account, vault, liquidator);\n\n        uint16 currencyId;\n        PrimeRate memory pr;\n        int256 fCashBalance;\n        int256 cashBalance;\n\n        if (currencyIndex == 0) {\n            currencyId = vaultConfig.borrowCurrencyId;\n            pr = vaultConfig.primeRate;\n            fCashBalance = vaultAccount.accountDebtUnderlying;\n            cashBalance = vaultAccount.tempCashBalance;\n        } else if (currencyIndex < 3) {\n            (currencyId, pr, fCashBalance, cashBalance) = _getSecondaryCashFactors(\n                vaultConfig, currencyIndex, account\n            );\n        } else {\n            revert(); // dev: invalid currency index\n        }\n\n        int256 discountFactor = VaultValuation.getLiquidateCashDiscountFactor(\n            pr, currencyId, vaultAccount.maturity\n        );\n\n        cashToLiquidator = pr.convertFromUnderlying(fCashDeposit.mulInRatePrecision(discountFactor));\n        if (cashToLiquidator > cashBalance) {\n            // Cap the fCash deposit to the cash balance available at the discount factor\n            fCashDeposit = pr.convertToUnderlying(cashBalance).divInRatePrecision(discountFactor);\n            cashToLiquidator = cashBalance;\n        }\n\n        // Cap the fCash deposit to the fcash balance held by the account\n        require(0 < fCashDeposit && fCashDeposit <= fCashBalance.neg());\n\n        _transferCashToVault(\n            vaultAccount, liquidator, vault, currencyId, fCashDeposit, cashToLiquidator\n        );\n\n        _reduceAccountDebt(vaultConfig, vaultState, vaultAccount, pr, currencyIndex, fCashDeposit, false);\n        vaultAccount.setVaultAccountForLiquidation(vaultConfig, currencyIndex, cashToLiquidator.neg(), false);\n    }\n\n    function _transferCashToVault(\n        VaultAccount memory vaultAccount,\n        address liquidator,\n        address vault,\n        uint16 currencyId,\n        int256 fCashDeposit,\n        int256 cashToLiquidator\n    ) internal {\n        bool mustCheckFC = SettleAssetsExternal.transferCashToVaultLiquidator(\n            liquidator, vault, vaultAccount.account, currencyId, vaultAccount.maturity, fCashDeposit, cashToLiquidator\n        );\n\n        if (mustCheckFC) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(liquidator);\n        }\n        emit VaultAccountCashLiquidation(\n            vault, vaultAccount.account, liquidator, currencyId, fCashDeposit, cashToLiquidator\n        );\n    }\n\n    /// @notice Authenticates a call to the deleverage method\n    function _authenticateDeleverage(\n        address account,\n        address vault,\n        address liquidator\n    ) private returns (\n        VaultConfig memory vaultConfig,\n        VaultAccount memory vaultAccount,\n        VaultState memory vaultState\n    ) {\n        // Do not allow invalid accounts to liquidate\n        requireValidAccount(liquidator);\n        require(liquidator != vault);\n\n        // Cannot liquidate self, if a vault needs to deleverage itself as a whole it has other methods \n        // in VaultAction to do so.\n        require(account != msg.sender);\n        require(account != liquidator);\n\n        vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        require(vaultConfig.getFlag(VaultConfiguration.DISABLE_DELEVERAGE) == false);\n\n        // Authorization rules for deleveraging\n        if (vaultConfig.getFlag(VaultConfiguration.ONLY_VAULT_DELEVERAGE)) {\n            require(msg.sender == vault);\n        } else {\n            require(msg.sender == liquidator);\n        }\n\n        vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n\n        // Vault accounts that are not settled must be settled first by calling settleVaultAccount\n        // before liquidation. settleVaultAccount is not permissioned so anyone may settle the account.\n        require(block.timestamp < vaultAccount.maturity, \"Must Settle\");\n\n        if (vaultAccount.maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // Returns the updated prime vault state\n            vaultState = vaultAccount.accruePrimeCashFeesToDebtInLiquidation(vaultConfig);\n        } else {\n            vaultState = VaultStateLib.getVaultState(vaultConfig, vaultAccount.maturity);\n        }\n    }\n\n    function _reduceAccountDebt(\n        VaultConfig memory vaultConfig,\n        VaultState memory vaultState,\n        VaultAccount memory vaultAccount,\n        PrimeRate memory primeRate,\n        uint256 currencyIndex,\n        int256 depositUnderlyingInternal,\n        bool checkMinBorrow\n    ) private {\n        if (currencyIndex == 0) {\n            vaultAccount.updateAccountDebt(vaultState, depositUnderlyingInternal, 0);\n            vaultState.setVaultState(vaultConfig);\n        } else {\n            // Only set one of the prime rates, the other prime rate is not used since\n            // the net debt amount is set to zero\n            PrimeRate[2] memory pr;\n            pr[currencyIndex - 1] = primeRate;\n\n            VaultSecondaryBorrow.updateAccountSecondaryDebt(\n                vaultConfig,\n                vaultAccount.account,\n                vaultAccount.maturity,\n                currencyIndex == 1 ? depositUnderlyingInternal : 0,\n                currencyIndex == 2 ? depositUnderlyingInternal : 0,\n                pr,\n                checkMinBorrow\n            );\n        }\n    }\n\n    /// @notice Transfers liquidator profits in the form of vault shares to be returned to the liquidator\n    function _transferVaultSharesToLiquidator(\n        address receiver,\n        VaultConfig memory vaultConfig,\n        uint256 vaultSharesToLiquidator,\n        uint256 maturity\n    ) private {\n        // Liquidator will receive vault shares that they can redeem by calling exitVault. If the liquidator has a\n        // leveraged position on then their collateral ratio will increase\n        VaultAccount memory liquidator = VaultAccountLib.getVaultAccount(receiver, vaultConfig);\n        // The liquidator must be able to receive the vault shares (i.e. not be in the vault at all or be in the\n        // vault at the same maturity). If the liquidator has fCash in the current maturity then their collateral\n        // ratio will increase as a result of the liquidation, no need to check their collateral position.\n        require(liquidator.maturity == 0 || liquidator.maturity == maturity, \"Maturity Mismatch\"); // dev: has vault shares\n        liquidator.maturity = maturity;\n        liquidator.vaultShares = liquidator.vaultShares.add(vaultSharesToLiquidator);\n        liquidator.setVaultAccount({vaultConfig: vaultConfig, checkMinBorrow: true});\n    }\n\n    function _getSecondaryCashFactors(\n        VaultConfig memory vaultConfig,\n        uint256 currencyIndex,\n        address account\n    ) private returns (uint16 currencyId, PrimeRate memory pr, int256 fCashBalance, int256 cashBalance) {\n        PrimeRate[2] memory primeRates = VaultSecondaryBorrow.getSecondaryPrimeRateStateful(vaultConfig);\n        (/* */, int256 debtOne, int256 debtTwo) = VaultSecondaryBorrow.getAccountSecondaryDebt(vaultConfig, account, primeRates);\n\n        // Cash balances refer to cash held on the account against debt, not prime cash balances held by the vault.\n        // Those are included in the vault share value.\n        (int256 cashOne, int256 cashTwo) = VaultSecondaryBorrow.getSecondaryCashHeld(account, vaultConfig.vault);\n\n        currencyId = vaultConfig.secondaryBorrowCurrencies[currencyIndex - 1];\n        pr = primeRates[currencyIndex - 1];\n        // Return the correct pair of debt and cash balances\n        (fCashBalance, cashBalance) = currencyIndex == 1 ? (debtOne, cashOne) : (debtTwo, cashTwo);\n    }\n\n    function getLibInfo() external pure returns (address, address) {\n        return (address(FreeCollateralExternal), address(SettleAssetsExternal));\n    }\n}"
    },
    {
      "filename": "contracts/internal/balances/TokenHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    TokenType,\n    TokenStorage,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\n\nimport {Emitter} from \"../Emitter.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\n\nimport {CompoundHandler} from \"./protocols/CompoundHandler.sol\";\nimport {GenericToken} from \"./protocols/GenericToken.sol\";\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {IPrimeCashHoldingsOracle, RedeemData} from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\n\n/// @notice Handles all external token transfers and events\nlibrary TokenHandler {\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n    using PrimeRateLib for PrimeRate;\n\n    function getDeprecatedAssetToken(uint256 currencyId) internal view returns (Token memory) {\n        return _getToken(currencyId, false);\n    }\n\n    function getUnderlyingToken(uint256 currencyId) internal view returns (Token memory) {\n        return _getToken(currencyId, true);\n    }\n\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\n    /// the underlying token. (These may not always exist)\n    function _getToken(uint256 currencyId, bool underlying) private view returns (Token memory) {\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\n        TokenStorage storage tokenStorage = store[currencyId][underlying];\n\n        return\n            Token({\n                tokenAddress: tokenStorage.tokenAddress,\n                hasTransferFee: tokenStorage.hasTransferFee,\n                // No overflow, restricted on storage\n                decimals: int256(10**tokenStorage.decimalPlaces),\n                tokenType: tokenStorage.tokenType,\n                deprecated_maxCollateralBalance: 0\n            });\n    }\n\n    /// @notice Sets a token for a currency id. After the prime cash migration, only\n    /// underlying tokens may be set by this method.\n    function setToken(uint256 currencyId, TokenStorage memory tokenStorage) internal {\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Hardcoded parameters for ETH just to make sure we don't get it wrong.\n            TokenStorage storage ts = store[currencyId][true];\n            ts.tokenAddress = address(0);\n            ts.hasTransferFee = false;\n            ts.tokenType = TokenType.Ether;\n            ts.decimalPlaces = Constants.ETH_DECIMAL_PLACES;\n\n            return;\n        }\n\n        // Check token address\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = _getToken(currencyId, true);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        require(0 < tokenStorage.decimalPlaces \n            && tokenStorage.decimalPlaces <= Constants.MAX_DECIMAL_PLACES, \"TH: invalid decimals\");\n\n        // Validate token type\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        // Only underlying tokens allowed after migration\n        require(tokenStorage.tokenType == TokenType.UnderlyingToken); // dev: only underlying token\n\n        // Underlying is always true.\n        store[currencyId][true] = tokenStorage;\n    }\n\n    /**\n     * @notice Transfers a deprecated asset token into Notional and redeems it for underlying,\n     * updates prime cash supply and returns the total prime cash to add to the account.\n     * @param assetToken asset token to redeem\n     * @param currencyId the currency id of the token\n     * @param assetAmountExternal the amount to transfer in asset token denomination and external precision\n     * @param primeRate the prime rate for the given currency\n     * @param account the address of the account to transfer from\n     * @return primeCashDeposited the amount of prime cash to mint back to the account\n     */\n    function depositDeprecatedAssetToken(\n        Token memory assetToken,\n        uint16 currencyId,\n        uint256 assetAmountExternal,\n        address account,\n        PrimeRate memory primeRate\n    ) internal returns (int256 primeCashDeposited) {\n        // Transfer the asset token into the contract\n        assetAmountExternal = GenericToken.safeTransferIn(\n            assetToken.tokenAddress, account, assetAmountExternal\n        );\n\n        Token memory underlyingToken = getUnderlyingToken(currencyId);\n        int256 underlyingExternalAmount;\n        // Only cTokens will be listed at the time of the migration. Redeem\n        // those cTokens to underlying (to be held by the Notional contract)\n        // and then run the post transfer update\n        if (assetToken.tokenType == TokenType.cETH) {\n            underlyingExternalAmount = CompoundHandler.redeemCETH(\n                assetToken, assetAmountExternal\n            ).toInt();\n        } else if (assetToken.tokenType == TokenType.cToken) {\n            underlyingExternalAmount = CompoundHandler.redeem(\n                assetToken, underlyingToken, assetAmountExternal\n            ).toInt();\n        } else {\n            // No other asset token variants can be called here.\n            revert();\n        }\n        \n        primeCashDeposited = _postTransferPrimeCashUpdate(\n            account, currencyId, underlyingExternalAmount, underlyingToken, primeRate\n        );\n    }\n\n    /// @notice Deposits an exact amount of underlying tokens to mint the specified amount of prime cash.\n    /// @param account account to transfer tokens from\n    /// @param currencyId the associated currency id\n    /// @param primeCashToMint the amount of prime cash to mint\n    /// @param primeRate the current accrued prime rate\n    /// @param returnNativeTokenWrapped if true, return excess msg.value ETH payments as WETH\n    /// @return actualTransferExternal the actual amount of tokens transferred in external precision\n    function depositExactToMintPrimeCash(\n        address account,\n        uint16 currencyId,\n        int256 primeCashToMint,\n        PrimeRate memory primeRate,\n        bool returnNativeTokenWrapped\n    ) internal returns (int256 actualTransferExternal) {\n        if (primeCashToMint == 0) return 0;\n        require(primeCashToMint > 0);\n        Token memory underlying = getUnderlyingToken(currencyId);\n        int256 netTransferExternal = convertToUnderlyingExternalWithAdjustment(\n            underlying, \n            primeRate.convertToUnderlying(primeCashToMint) \n        );\n\n        (actualTransferExternal, /* */) = depositUnderlyingExternal(\n            account, currencyId, netTransferExternal, primeRate, returnNativeTokenWrapped\n        );\n    }\n\n    /// @notice Deposits an amount of underlying tokens to mint prime cash\n    /// @param account account to transfer tokens from\n    /// @param currencyId the associated currency id\n    /// @param _underlyingExternalDeposit the amount of underlying tokens to deposit\n    /// @param primeRate the current accrued prime rate\n    /// @param returnNativeTokenWrapped if true, return excess msg.value ETH payments as WETH\n    /// @return actualTransferExternal the actual amount of tokens transferred in external precision\n    /// @return netPrimeSupplyChange the amount of prime supply created\n    function depositUnderlyingExternal(\n        address account,\n        uint16 currencyId,\n        int256 _underlyingExternalDeposit,\n        PrimeRate memory primeRate,\n        bool returnNativeTokenWrapped\n    ) internal returns (int256 actualTransferExternal, int256 netPrimeSupplyChange) {\n        uint256 underlyingExternalDeposit = _underlyingExternalDeposit.toUint();\n        if (underlyingExternalDeposit == 0) return (0, 0);\n\n        Token memory underlying = getUnderlyingToken(currencyId);\n        if (underlying.tokenType == TokenType.Ether) {\n            // Underflow checked above\n            if (underlyingExternalDeposit < msg.value) {\n                // Transfer any excess ETH back to the account\n                GenericToken.transferNativeTokenOut(\n                    account, msg.value - underlyingExternalDeposit, returnNativeTokenWrapped\n                );\n            } else {\n                require(underlyingExternalDeposit == msg.value, \"ETH Balance\");\n            }\n\n            actualTransferExternal = _underlyingExternalDeposit;\n        } else {\n            // In the case of deposits, we use a balance before and after check\n            // to ensure that we record the proper balance change.\n            actualTransferExternal = GenericToken.safeTransferIn(\n                underlying.tokenAddress, account, underlyingExternalDeposit\n            ).toInt();\n        }\n\n        netPrimeSupplyChange = _postTransferPrimeCashUpdate(\n            account, currencyId, actualTransferExternal, underlying, primeRate\n        );\n    }\n\n    /// @notice Withdraws an amount of prime cash and returns it to the account as underlying tokens\n    /// @param account account to transfer tokens to\n    /// @param currencyId the associated currency id\n    /// @param primeCashToWithdraw the amount of prime cash to burn\n    /// @param primeRate the current accrued prime rate\n    /// @param withdrawWrappedNativeToken if true, return ETH as WETH\n    /// @return netTransferExternal the amount of underlying tokens withdrawn in native precision, this is\n    /// negative to signify that tokens have left the protocol\n    function withdrawPrimeCash(\n        address account,\n        uint16 currencyId,\n        int256 primeCashToWithdraw,\n        PrimeRate memory primeRate,\n        bool withdrawWrappedNativeToken\n    ) internal returns (int256 netTransferExternal) {\n        if (primeCashToWithdraw == 0) return 0;\n        require(primeCashToWithdraw < 0);\n\n        Token memory underlying = getUnderlyingToken(currencyId);\n        netTransferExternal = convertToExternal(\n            underlying, \n            primeRate.convertToUnderlying(primeCashToWithdraw) \n        );\n\n        // Overflow not possible due to int256\n        uint256 withdrawAmount = uint256(netTransferExternal.neg());\n        _redeemMoneyMarketIfRequired(currencyId, underlying, withdrawAmount);\n\n        if (underlying.tokenType == TokenType.Ether) {\n            GenericToken.transferNativeTokenOut(account, withdrawAmount, withdrawWrappedNativeToken);\n        } else {\n            GenericToken.safeTransferOut(underlying.tokenAddress, account, withdrawAmount);\n        }\n\n        _postTransferPrimeCashUpdate(account, currencyId, netTransferExternal, underlying, primeRate);\n    }\n\n    /// @notice Prime cash holdings may be in underlying tokens or they may be held in other money market\n    /// protocols like Compound, Aave or Euler. If there is insufficient underlying tokens to withdraw on\n    /// the contract, this method will redeem money market tokens in order to gain sufficient underlying\n    /// to withdraw from the contract.\n    /// @param currencyId associated currency id\n    /// @param underlying underlying token information\n    /// @param withdrawAmountExternal amount of underlying to withdraw in external token precision\n    function _redeemMoneyMarketIfRequired(\n        uint16 currencyId,\n        Token memory underlying,\n        uint256 withdrawAmountExternal\n    ) private {\n        // If there is sufficient balance of the underlying to withdraw from the contract\n        // immediately, just return.\n        mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\n        uint256 currentBalance = store[underlying.tokenAddress];\n        if (withdrawAmountExternal <= currentBalance) return;\n\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        // Redemption data returns an array of contract calls to make from the Notional proxy (which\n        // is holding all of the money market tokens).\n        (RedeemData[] memory data) = oracle.getRedemptionCalldata(withdrawAmountExternal);\n\n        // This is the total expected underlying that we should redeem after all redemption calls\n        // are executed.\n        uint256 totalUnderlyingRedeemed = executeMoneyMarketRedemptions(underlying, data);\n\n        // Ensure that we have sufficient funds before we exit\n        require(withdrawAmountExternal <= currentBalance.add(totalUnderlyingRedeemed)); // dev: insufficient redeem\n    }\n\n    /// @notice Every time tokens are transferred into or out of the protocol, the prime supply\n    /// and total underlying held must be updated.\n    function _postTransferPrimeCashUpdate(\n        address account,\n        uint16 currencyId,\n        int256 netTransferUnderlyingExternal,\n        Token memory underlyingToken,\n        PrimeRate memory primeRate\n    ) private returns (int256 netPrimeSupplyChange) {\n        int256 netUnderlyingChange = convertToInternal(underlyingToken, netTransferUnderlyingExternal);\n\n        netPrimeSupplyChange = primeRate.convertFromUnderlying(netUnderlyingChange);\n\n        Emitter.emitMintOrBurnPrimeCash(account, currencyId, netPrimeSupplyChange);\n        PrimeCashExchangeRate.updateTotalPrimeSupply(currencyId, netPrimeSupplyChange, netUnderlyingChange);\n\n        _updateNetStoredTokenBalance(underlyingToken.tokenAddress, netTransferUnderlyingExternal);\n    }\n\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\n        // If token decimals > INTERNAL_TOKEN_PRECISION:\n        //  on deposit: resulting dust will accumulate to protocol\n        //  on withdraw: protocol may lose dust amount. However, withdraws are only calculated based\n        //    on a conversion from internal token precision to external token precision so therefore dust\n        //    amounts cannot be specified for withdraws.\n        // If token decimals < INTERNAL_TOKEN_PRECISION then this will add zeros to the\n        // end of amount and will not result in dust.\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\n    }\n\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        // If token decimals > INTERNAL_TOKEN_PRECISION then this will increase amount\n        // by adding a number of zeros to the end and will not result in dust.\n        // If token decimals < INTERNAL_TOKEN_PRECISION:\n        //  on deposit: Deposits are specified in external token precision and there is no loss of precision when\n        //      tokens are converted from external to internal precision\n        //  on withdraw: this calculation will round down such that the protocol retains the residual cash balance\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    /// @notice Converts a token to an underlying external amount with adjustments for rounding errors when depositing\n    function convertToUnderlyingExternalWithAdjustment(\n        Token memory token,\n        int256 underlyingInternalAmount\n    ) internal pure returns (int256 underlyingExternalAmount) {\n        if (token.decimals < Constants.INTERNAL_TOKEN_PRECISION) {\n            // If external < 8, we could truncate down and cause an off by one error, for example we need\n            // 1.00000011 cash and we deposit only 1.000000, missing 11 units. Therefore, we add a unit at the\n            // lower precision (external) to get around off by one errors\n            underlyingExternalAmount = convertToExternal(token, underlyingInternalAmount).add(1);\n        } else {\n            // If external > 8, we may not mint enough asset tokens because in the case of 1e18 precision \n            // an off by 1 error at 1e8 precision is 1e10 units of the underlying token. In this case we\n            // add 1 at the internal precision which has the effect of rounding up by 1e10\n            underlyingExternalAmount = convertToExternal(token, underlyingInternalAmount.add(1));\n        }\n    }\n\n    /// @notice Convenience method for getting the balance using a token object\n    function balanceOf(Token memory token, address account) internal view returns (uint256) {\n        if (token.tokenType == TokenType.Ether) {\n            return account.balance;\n        } else {\n            return IERC20(token.tokenAddress).balanceOf(account);\n        }\n    }\n\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\n        GenericToken.safeTransferOut(Deployments.NOTE_TOKEN_ADDRESS, account, tokensToTransfer);\n    }\n\n    /// @notice It is critical that this method measures and records the balanceOf changes before and after\n    /// every token change. If not, then external donations can affect the valuation of pCash and pDebt\n    /// tokens which may be exploitable.\n    /// @param redeemData parameters from the prime cash holding oracle\n    function executeMoneyMarketRedemptions(\n        Token memory underlyingToken,\n        RedeemData[] memory redeemData\n    ) internal returns (uint256 totalUnderlyingRedeemed) {\n        for (uint256 i; i < redeemData.length; i++) {\n            RedeemData memory data = redeemData[i];\n            // Measure the token balance change if the `assetToken` value is set in the\n            // current redemption data struct. \n            uint256 oldAssetBalance = IERC20(data.assetToken).balanceOf(address(this));\n\n            // Measure the underlying balance change before and after the call.\n            uint256 oldUnderlyingBalance = balanceOf(underlyingToken, address(this));\n            \n            // Some asset tokens may require multiple calls to redeem if there is an unstake\n            // or redemption from WETH involved. We only measure the asset token balance change\n            // on the final redemption call, as dictated by the prime cash holdings oracle.\n            for (uint256 j; j < data.targets.length; j++) {\n                // This will revert if the individual call reverts.\n                GenericToken.executeLowLevelCall(data.targets[j], 0, data.cal"
    }
  ]
}