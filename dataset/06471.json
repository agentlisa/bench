{
  "Title": "[M-19] The `RestakeToken` function is not permissionless",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/uni-v3-staker/UniswapV3Staker.sol#L340-L348> <br><https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/uni-v3-staker/UniswapV3Staker.sol#L373-L374>\n\n### Vulnerability details\n\nOne of the project assumptions is that anyone can call the `restakeToken` function on someone else's token after the incentive ends (at the start of the new gauge cycle).\n\n```solidity\nFile: src/uni-v3-staker/UniswapV3Staker.sol\n365:     function _unstakeToken(IncentiveKey memory key, uint256 tokenId, bool isNotRestake) private {\n366:         Deposit storage deposit = deposits[tokenId];\n367: \n368:         (uint96 endTime, uint256 stakedDuration) =\n369:             IncentiveTime.getEndAndDuration(key.startTime, deposit.stakedTimestamp, block.timestamp);\n370: \n371:         address owner = deposit.owner;\n372: \n373: @>      // anyone can call restakeToken if the block time is after the end time of the incentive\n374: @>      if ((isNotRestake || block.timestamp < endTime) && owner != msg.sender) revert NotCalledByOwner();\n\t\t\n\t\t...\n```\n\nThis assumption is broken because everywhere the `_unstakeToken` is called, the `isNotRestake` flag is set to `true`, including the [`restakeToken`](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/uni-v3-staker/UniswapV3Staker.sol#L342) function. Because of that, when the caller is not the `deposit.owner`, the `if` block will evaluate to `true`, and the call will revert with `NotCalledByOwner()` error.\n\n```solidity\nFile: src/uni-v3-staker/UniswapV3Staker.sol\n340:     function restakeToken(uint256 tokenId) external {\n341:         IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId];\n342: @>      if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true);\n343: \n344:         (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) =\n345:             NFTPositionInfo.getPositionInfo(factory, nonfungiblePositionManager, tokenId);\n346: \n347:         _stakeToken(tokenId, pool, tickLower, tickUpper, liquidity);\n348:     }\n```\n\n### Impact\n\nLower yield for users, broken 3rd party integration and higher gas usage.\n\nThe purpose of the `restakeToken` function is to:\n\n- Enable easier automation - re-staking without the need for manual intervention.\n- Aggregation - combining multiple actions into a single operation to increase efficiency and reduce transaction costs.\n\nThis is also the reason why the `UniswapV3Staker` contract inherits from `Multicallable`. Without the ability to re-stake for someone else, 3rd parties or groups of users won't be able to perform cost and yield efficient batch re-stakes.\n\nAs stated in the [Liquidity Mining section](https://v2-docs.maiadao.io/protocols/Hermes/overview/gauges/uni-v3#liquidity-mining) in the docs, LPs will lose new rewards until they re-stake again. Any delay means: fewer rewards -> fewer `bHermes` utility tokens -> lower impact in the ecosystem. It is very unlikely that users will be able to re-stake exactly at 12:00 UTC every Thursday (to maximize the yield) without some automation/aggregation.\n\n### Proof of Concept\n\nSince I decided to create a fork test on Arbitrum mainnet, the setup is quite lengthy and is explained in great detail in the following [GitHub Gist](https://gist.github.com/ChmielewskiKamil/8261acbbed37b84d176938aa398f19bd).\n\nPre-conditions:\n\n- Alice and Bob are users of the protocol. They both have the 1000 DAI/1000 USDC UniswapV3 Liquidity position minted.\n- The `UniswapV3Gauge` has weight allocated to it.\n- The `BaseV2Minter` has queued `HERMES` rewards for the cycle.\n- Charlie is a 3rd party that agreed to re-stake Alice's token at the start of the next cycle (current incentive end time).\n\n```solidity\nfunction testRestake_RestakeIsNotPermissionless() public {\n        vm.startPrank(ALICE);\n        // 1.a Alice stakes her NFT (at incentive StartTime)\n        nonfungiblePositionManager.safeTransferFrom(ALICE, address(uniswapV3Staker), tokenIdAlice);\n        vm.stopPrank();\n\n        vm.startPrank(BOB);\n        // 1.b Bob stakes his NFT (at incentive StartTime)\n        nonfungiblePositionManager.safeTransferFrom(BOB, address(uniswapV3Staker), tokenIdBob);\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + 1 weeks); // 2.a Warp to incentive end time\n        gauge.newEpoch();                   // 2.b Queue minter rewards for the next cycle\n\n        vm.startPrank(BOB);\n        uniswapV3Staker.restakeToken(tokenIdBob); // 3.a Bob can restake his own token\n        vm.stopPrank();\n\n        vm.startPrank(CHARLIE);\n        vm.expectRevert(bytes4(keccak256(\"NotCalledByOwner()\")));\n@>issue uniswapV3Staker.restakeToken(tokenIdAlice); // 3.b Charlie cannot restake Alice's token\n        vm.stopPrank();\n\n        uint256 rewardsBob = uniswapV3Staker.rewards(BOB);\n        uint256 rewardsAlice = uniswapV3Staker.rewards(ALICE);\n\n        assertNotEq(rewardsBob, 0, \"Bob should have rewards\");\n        assertEq(rewardsAlice, 0, \"Alice should not have rewards\");\n\n        console.log(\"=================\");\n        console.log(\"Bob's rewards   : %s\", rewardsBob);\n        console.log(\"Alice's rewards : %s\", rewardsAlice);\n        console.log(\"=================\");\n    }\n```\n\nWhen used with `multicall`, as it probably would in a real-life scenario, it won't work either.\n\nChange Charlie's part to:\n\n```solidity\nbytes memory functionCall1 = abi.encodeWithSignature(\n\t\"restakeToken(uint256)\",\n\ttokenIdAlice\n);\nbytes memory functionCall2 = abi.encodeWithSignature(\n\t\"restakeToken(uint256)\",\n\ttokenIdBob\n);\n\nbytes[] memory data = new bytes[](2);\ndata[0] = functionCall1;\ndata[1] = functionCall2;\n\nvm.startPrank(CHARLIE);\naddress(uniswapV3Staker).call(abi.encodeWithSignature(\"multicall(bytes[])\", data));\nvm.stopPrank();\n```\n\n### Recommended Mitigation Steps\n\nA simple fix is to change the `isNotRestake` flag inside the `restakeToken` function to `false`:\n\n```diff\ndiff --git a/src/uni-v3-staker/UniswapV3Staker.sol b/src/uni-v3-staker/UniswapV3Staker.sol\nindex 5970379..d7add32 100644\n--- a/src/uni-v3-staker/UniswapV3Staker.sol\n+++ b/src/uni-v3-staker/UniswapV3Staker.sol\n@@ -339,7 +339,7 @@ contract UniswapV3Staker is IUniswapV3Staker, Multicallable {\n \n     function restakeToken(uint256 tokenId) external {\n         IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId];\n-        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true);\n+        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, false);\n \n         (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) =\n             NFTPositionInfo.getPositionInfo(factory, nonfungiblePositionManager, tokenId);\n```\n\nA more complicated fix, which would reduce code complexity in the future, would be to rename the `isNotRestake` flag to `isRestake`.\n\nThis way, one level of indirection would be reduced.\n\n```diff\ndiff --git a/src/uni-v3-staker/UniswapV3Staker.sol b/src/uni-v3-staker/UniswapV3Staker.sol\nindex 5970379..43ff24c 100644\n--- a/src/uni-v3-staker/UniswapV3Staker.sol\n+++ b/src/uni-v3-staker/UniswapV3Staker.sol\n@@ -354,15 +354,15 @@ contract UniswapV3Staker is IUniswapV3Staker, Multicallable {\n     /// @inheritdoc IUniswapV3Staker\n     function unstakeToken(uint256 tokenId) external {\n         IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId];\n-        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true);\n+        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, false);\n     }\n \n     /// @inheritdoc IUniswapV3Staker\n     function unstakeToken(IncentiveKey memory key, uint256 tokenId) external {\n-        _unstakeToken(key, tokenId, true);\n+        _unstakeToken(key, tokenId, false);\n     }\n \n-    function _unstakeToken(IncentiveKey memory key, uint256 tokenId, bool isNotRestake) private {\n+    function _unstakeToken(IncentiveKey memory key, uint256 tokenId, bool isRestake) private {\n         Deposit storage deposit = deposits[tokenId];\n \n         (uint96 endTime, uint256 stakedDuration) =\n@@ -371,7 +371,7 @@ contract UniswapV3Staker is IUniswapV3Staker, Multicallable {\n         address owner = deposit.owner;\n \n         // anyone can call restakeToken if the block time is after the end time of the incentive\n-        if ((isNotRestake || block.timestamp < endTime) && owner != msg.sender) revert NotCalledByOwner();\n+        if ((isRestake || block.timestamp < endTime) && owner != msg.sender) revert NotCalledByOwner();\n```\n\n### Assessed type\n\nAccess Control\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/534#issuecomment-1655670255)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/534#issuecomment-1709163938):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/534).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/uni-v3-staker/UniswapV3Staker.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by Uniswap V3 Contracts (Uniswap/v3-staker/contracts/UniswapV3Staker.sol)\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {Multicallable} from \"solady/utils/Multicallable.sol\";\n\nimport {IUniswapV3Factory} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IUniswapV3GaugeFactory} from \"@gauges/interfaces/IUniswapV3GaugeFactory.sol\";\nimport {UniswapV3Gauge} from \"@gauges/UniswapV3Gauge.sol\";\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\n\nimport {IncentiveId} from \"./libraries/IncentiveId.sol\";\nimport {IncentiveTime} from \"./libraries/IncentiveTime.sol\";\nimport {NFTPositionInfo} from \"./libraries/NFTPositionInfo.sol\";\nimport {RewardMath} from \"./libraries/RewardMath.sol\";\n\nimport {IUniswapV3Staker} from \"./interfaces/IUniswapV3Staker.sol\";\n\n/// @title Uniswap V3 Staker Interface with bHermes Boost.\ncontract UniswapV3Staker is IUniswapV3Staker, Multicallable {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                        UNISWAP V3 STAKER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(address => IUniswapV3Pool) public gaugePool;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(IUniswapV3Pool => UniswapV3Gauge) public gauges;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(IUniswapV3Pool => address) public bribeDepots;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(IUniswapV3Pool => uint24) public poolsMinimumWidth;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(bytes32 => Incentive) public override incentives;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(uint256 => Deposit) public override deposits;\n\n    /// @notice stakes[user][pool] => tokenId of attached position of user per pool\n    mapping(address => mapping(IUniswapV3Pool => uint256)) private _userAttachements;\n\n    /// @dev stakes[tokenId][incentiveHash] => Stake\n    mapping(uint256 => mapping(bytes32 => Stake)) private _stakes;\n\n    /// @dev stakedIncentives[tokenId] => incentiveIds\n    mapping(uint256 => IncentiveKey) private stakedIncentiveKey;\n\n    /// @inheritdoc IUniswapV3Staker\n    function stakes(uint256 tokenId, bytes32 incentiveId)\n        public\n        view\n        override\n        returns (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity)\n    {\n        Stake storage stake = _stakes[tokenId][incentiveId];\n        secondsPerLiquidityInsideInitialX128 = stake.secondsPerLiquidityInsideInitialX128;\n        liquidity = stake.liquidityNoOverflow;\n        if (liquidity == type(uint96).max) {\n            liquidity = stake.liquidityIfOverflow;\n        }\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function userAttachements(address user, IUniswapV3Pool pool) external view override returns (uint256) {\n        return hermesGaugeBoost.isUserGauge(user, address(gauges[pool])) ? _userAttachements[user][pool] : 0;\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(address => uint256) public override rewards;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(uint256 => uint256) public tokenIdRewards;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Uniswap V3 Gauge Factory\n    IUniswapV3GaugeFactory public immutable uniswapV3GaugeFactory;\n\n    /// @inheritdoc IUniswapV3Staker\n    IUniswapV3Factory public immutable override factory;\n\n    /// @inheritdoc IUniswapV3Staker\n    INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n    /// @inheritdoc IUniswapV3Staker\n    uint256 public immutable override maxIncentiveStartLeadTime;\n\n    /// @inheritdoc IUniswapV3Staker\n    address public immutable minter;\n\n    /// @inheritdoc IUniswapV3Staker\n    address public immutable hermes;\n\n    /// @inheritdoc IUniswapV3Staker\n    bHermesBoost public immutable hermesGaugeBoost;\n\n    /// @param _factory the Uniswap V3 factory\n    /// @param _nonfungiblePositionManager the NFT position manager contract address\n    /// @param _maxIncentiveStartLeadTime the max duration of an incentive in seconds\n    constructor(\n        IUniswapV3Factory _factory,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        IUniswapV3GaugeFactory _uniswapV3GaugeFactory,\n        bHermesBoost _hermesGaugeBoost,\n        uint256 _maxIncentiveStartLeadTime,\n        address _minter,\n        address _hermes\n    ) {\n        factory = _factory;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        maxIncentiveStartLeadTime = _maxIncentiveStartLeadTime;\n        uniswapV3GaugeFactory = _uniswapV3GaugeFactory;\n        hermesGaugeBoost = _hermesGaugeBoost;\n        minter = _minter;\n        hermes = _hermes;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        CREATE INCENTIVE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function createIncentiveFromGauge(uint256 reward) external {\n        if (reward <= 0) revert IncentiveRewardMustBePositive();\n\n        uint96 startTime = IncentiveTime.computeEnd(block.timestamp);\n\n        IUniswapV3Pool pool = gaugePool[msg.sender];\n\n        if (address(pool) == address(0)) revert IncentiveCallerMustBeRegisteredGauge();\n\n        IncentiveKey memory key = IncentiveKey({startTime: startTime, pool: pool});\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        incentives[incentiveId].totalRewardUnclaimed += reward;\n\n        hermes.safeTransferFrom(msg.sender, address(this), reward);\n\n        emit IncentiveCreated(pool, startTime, reward);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function createIncentive(IncentiveKey memory key, uint256 reward) external {\n        if (reward <= 0) revert IncentiveRewardMustBePositive();\n\n        uint96 startTime = IncentiveTime.computeStart(key.startTime);\n\n        if (startTime != key.startTime) revert IncentiveStartTimeNotAtEndOfAnEpoch();\n\n        if (startTime <= block.timestamp) revert IncentiveStartTimeMustBeNowOrInTheFuture();\n        if (startTime - block.timestamp > maxIncentiveStartLeadTime) {\n            revert IncentiveStartTimeTooFarIntoFuture();\n        }\n\n        if (address(gauges[key.pool]) == address(0)) {\n            revert IncentiveCannotBeCreatedForPoolWithNoGauge();\n        }\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        incentives[incentiveId].totalRewardUnclaimed += reward;\n\n        hermes.safeTransferFrom(msg.sender, address(this), reward);\n\n        emit IncentiveCreated(key.pool, startTime, reward);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            END INCENTIVE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function endIncentive(IncentiveKey memory key) external returns (uint256 refund) {\n        if (block.timestamp < IncentiveTime.getEnd(key.startTime)) {\n            revert EndIncentiveBeforeEndTime();\n        }\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        Incentive storage incentive = incentives[incentiveId];\n\n        refund = incentive.totalRewardUnclaimed;\n\n        if (refund == 0) revert EndIncentiveNoRefundAvailable();\n        if (incentive.numberOfStakes > 0) revert EndIncentiveWhileStakesArePresent();\n\n        // issue the refund\n        incentive.totalRewardUnclaimed = 0;\n\n        hermes.safeTransfer(minter, refund);\n\n        // note we never clear totalSecondsClaimedX128\n\n        emit IncentiveEnded(incentiveId, refund);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            DEPOSIT TOKEN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Upon receiving a Uniswap V3 ERC721, create the token deposit and\n    ///      _stakes in current incentive setting owner to `from`.\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata)\n        external\n        override\n        returns (bytes4)\n    {\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager;\n        if (msg.sender != address(_nonfungiblePositionManager)) revert TokenNotUniswapV3NFT();\n\n        (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) =\n            NFTPositionInfo.getPositionInfo(factory, nonfungiblePositionManager, tokenId);\n\n        deposits[tokenId] = Deposit({owner: from, tickLower: tickLower, tickUpper: tickUpper, stakedTimestamp: 0});\n        emit DepositTransferred(tokenId, address(0), from);\n\n        // stake the token in the current incentive\n        _stakeToken(tokenId, pool, tickLower, tickUpper, liquidity);\n\n        return this.onERC721Received.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            WITHDRAW TOKEN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function withdrawToken(uint256 tokenId, address to, bytes memory data) external {\n        if (to == address(0)) revert InvalidRecipient();\n\n        Deposit storage deposit = deposits[tokenId];\n\n        if (deposit.owner != msg.sender) revert NotCalledByOwner();\n        if (deposit.stakedTimestamp != 0) revert TokenStakedError();\n\n        delete deposits[tokenId];\n        emit DepositTransferred(tokenId, msg.sender, address(0));\n\n        nonfungiblePositionManager.safeTransferFrom(address(this), to, tokenId, data);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            REWARD LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function claimReward(address to, uint256 amountRequested) external returns (uint256 reward) {\n        reward = rewards[msg.sender];\n        if (amountRequested != 0 && amountRequested < reward) {\n            reward = amountRequested;\n            rewards[msg.sender] -= reward;\n        } else {\n            rewards[msg.sender] = 0;\n        }\n\n        if (reward > 0) hermes.safeTransfer(to, reward);\n\n        emit RewardClaimed(to, reward);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function claimAllRewards(address to) external returns (uint256 reward) {\n        reward = rewards[msg.sender];\n        rewards[msg.sender] = 0;\n\n        if (reward > 0) hermes.safeTransfer(to, reward);\n\n        emit RewardClaimed(to, reward);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function getRewardInfo(IncentiveKey memory key, uint256 tokenId)\n        external\n        view\n        override\n        returns (uint256 reward, uint160 secondsInsideX128)\n    {\n        Deposit storage deposit = deposits[tokenId];\n\n        (uint96 endTime, uint256 stakedDuration) =\n            IncentiveTime.getEndAndDuration(key.startTime, deposit.stakedTimestamp, block.timestamp);\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n        {\n            uint128 boostAmount;\n            uint128 boostTotalSupply;\n            address owner = deposit.owner;\n            // If tokenId is attached to gauge\n            if (_userAttachements[owner][key.pool] == tokenId) {\n                // get boost amount and total supply\n                (boostAmount, boostTotalSupply) = hermesGaugeBoost.getUserGaugeBoost(owner, address(gauges[key.pool]));\n            }\n\n            (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity) = stakes(tokenId, incentiveId);\n            if (liquidity == 0) revert TokenNotStaked();\n\n            (, uint160 secondsPerLiquidityInsideX128,) =\n                key.pool.snapshotCumulativesInside(deposit.tickLower, deposit.tickUpper);\n\n            secondsInsideX128 = RewardMath.computeBoostedSecondsInsideX128(\n                stakedDuration,\n                liquidity,\n                uint128(boostAmount),\n                uint128(boostTotalSupply),\n                secondsPerLiquidityInsideInitialX128,\n                secondsPerLiquidityInsideX128\n            );\n        }\n\n        Incentive storage incentive = incentives[incentiveId];\n        reward = RewardMath.computeBoostedRewardAmount(\n            incentive.totalRewardUnclaimed,\n            incentive.totalSecondsClaimedX128,\n            key.startTime,\n            endTime,\n            secondsInsideX128,\n            block.timestamp\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            RE-STAKE TOKEN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function restakeToken(uint256 tokenId) external {\n        IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId];\n        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true);\n\n        (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) =\n            NFTPositionInfo.getPositionInfo(factory, nonfungiblePositionManager, tokenId);\n\n        _stakeToken(tokenId, pool, tickLower, tickUpper, liquidity);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UNSTAKE TOKEN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function unstakeToken(uint256 tokenId) external {\n        IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId];\n        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function unstakeToken(IncentiveKey memory key, uint256 tokenId) external {\n        _unstakeToken(key, tokenId, true);\n    }\n\n    function _unstakeToken(IncentiveKey memory key, uint256 tokenId, bool isNotRestake) private {\n        Deposit storage deposit = deposits[tokenId];\n\n        (uint96 endTime, uint256 stakedDuration) =\n            IncentiveTime.getEndAndDuration(key.startTime, deposit.stakedTimestamp, block.timestamp);\n\n        address owner = deposit.owner;\n\n        // anyone can call restakeToken if the block time is after the end time of the incentive\n        if ((isNotRestake || block.timestamp < endTime) && owner != msg.sender) revert NotCalledByOwner();\n\n        {\n            // scope for bribeAddress, avoids stack too deep errors\n            address bribeAddress = bribeDepots[key.pool];\n\n            if (bribeAddress != address(0)) {\n                nonfungiblePositionManager.collect(\n                    INonfungiblePositionManager.CollectParams({\n                        tokenId: tokenId,\n                        recipient: bribeAddress,\n                        amount0Max: type(uint128).max,\n                        amount1Max: type(uint128).max\n                    })\n                );\n            }\n        }\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n        uint160 secondsInsideX128;\n        uint128 liquidity;\n        {\n            uint128 boostAmount;\n            uint128 boostTotalSupply;\n\n            UniswapV3Gauge gauge = gauges[key.pool]; // saves another SLOAD if no tokenId is attached\n\n            // If tokenId is attached to gauge\n            if (hermesGaugeBoost.isUserGauge(owner, address(gauge)) && _userAttachements[owner][key.pool] == tokenId) {\n                // get boost amount and total supply\n                (boostAmount, boostTotalSupply) = hermesGaugeBoost.getUserGaugeBoost(owner, address(gauge));\n                gauge.detachUser(owner);\n                _userAttachements[owner][key.pool] = 0;\n            }\n\n            uint160 secondsPerLiquidityInsideInitialX128;\n            (secondsPerLiquidityInsideInitialX128, liquidity) = stakes(tokenId, incentiveId);\n            if (liquidity == 0) revert TokenNotStaked();\n\n            (, uint160 secondsPerLiquidityInsideX128,) =\n                key.pool.snapshotCumulativesInside(deposit.tickLower, deposit.tickUpper);\n\n            secondsInsideX128 = RewardMath.computeBoostedSecondsInsideX128(\n                stakedDuration,\n                liquidity,\n                uint128(boostAmount),\n                uint128(boostTotalSupply),\n                secondsPerLiquidityInsideInitialX128,\n                secondsPerLiquidityInsideX128\n            );\n        }\n\n        deposit.stakedTimestamp = 0;\n        Incentive storage incentive = incentives[incentiveId];\n        incentive.numberOfStakes--;\n        uint256 reward = RewardMath.computeBoostedRewardAmount(\n            incentive.totalRewardUnclaimed,\n            incentive.totalSecondsClaimedX128,\n            key.startTime,\n            endTime,\n            secondsInsideX128,\n            block.timestamp\n        );\n\n        unchecked {\n            // if this overflows, e.g. after 2^32-1 full liquidity seconds have been claimed,\n            // reward rate will fall drastically so it's safe\n            // can't overflow if incentiveDuration < 2^32-1 seconds\n            incentive.totalSecondsClaimedX128 += secondsInsideX128;\n            // reward is never greater than total reward unclaimed\n            incentive.totalRewardUnclaimed -= reward;\n            // this only overflows if a token has a total supply greater than type(uint256).max\n            rewards[owner] += reward;\n\n            // this only overflows if a token has a total supply greater than type(uint256).max\n            // Accounting purposes for external contracts only\n            tokenIdRewards[tokenId] += reward;\n        }\n\n        Stake storage stake = _stakes[tokenId][incentiveId];\n        stake.secondsPerLiquidityInsideInitialX128 = 0;\n        stake.liquidityNoOverflow = 0;\n        if (liquidity >= type(uint96).max) stake.liquidityIfOverflow = 0;\n        delete stakedIncentiveKey[tokenId];\n        emit TokenUnstaked(tokenId, incentiveId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            STAKE TOKEN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function stakeToken(uint256 tokenId) external override {\n        if (deposits[tokenId].stakedTimestamp != 0) revert TokenStakedError();\n\n        (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) =\n            NFTPositionInfo.getPositionInfo(factory, nonfungiblePositionManager, tokenId);\n\n        _stakeToken(tokenId, pool, tickLower, tickUpper, liquidity);\n    }\n\n    /// @dev Stakes a deposited token without doing an already staked in another position check\n    function _stakeToken(uint256 tokenId, IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity)\n        private\n    {\n        IncentiveKey memory key = IncentiveKey({pool: pool, startTime: IncentiveTime.computeStart(block.timestamp)});\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        if (incentives[incentiveId].totalRewardUnclaimed == 0) revert NonExistentIncentiveError();\n\n        if (uint24(tickUpper - tickLower) < poolsMinimumWidth[pool]) revert RangeTooSmallError();\n        if (liquidity == 0) revert NoLiquidityError();\n\n        stakedIncentiveKey[tokenId] = key;\n\n        // If user not attached to gauge, attach\n        address tokenOwner = deposits[tokenId].owner;\n        if (tokenOwner == address(0)) revert TokenNotDeposited();\n\n        UniswapV3Gauge gauge = gauges[pool]; // saves another SLOAD if no tokenId is attached\n\n        if (!hermesGaugeBoost.isUserGauge(tokenOwner, address(gauge))) {\n            _userAttachements[tokenOwner][pool] = tokenId;\n            gauge.attachUser(tokenOwner);\n        }\n\n        deposits[tokenId].stakedTimestamp = uint40(block.timestamp);\n        incentives[incentiveId].numberOfStakes++;\n\n        (, uint160 secondsPerLiquidityInsideX128,) = pool.snapshotCumulativesInside(tickLower, tickUpper);\n\n        if (liquidity >= type(uint96).max) {\n            _stakes[tokenId][incentiveId] = Stake({\n                secondsPerLiquidityInsideInitialX128: secondsPerLiquidityInsideX128,\n                liquidityNoOverflow: type(uint96).max,\n                liquidityIfOverflow: liquidity\n            });\n        } else {\n            Stake storage stake = _stakes[tokenId][incentiveId];\n            stake.secondsPerLiquidityInsideInitialX128 = secondsPerLiquidityInsideX128;\n            stake.liquidityNoOverflow = uint96(liquidity);\n        }\n\n        emit TokenStaked(tokenId, incentiveId, liquidity);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GAUGE UPDATE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function updateGauges(IUniswapV3Pool uniswapV3Pool) external {\n        address uniswapV3Gauge = address(uniswapV3GaugeFactory.strategyGauges(address(uniswapV3Pool)));\n\n        if (uniswapV3Gauge == address(0)) revert InvalidGauge();\n\n        if (address(gauges[uniswapV3Pool]) != uniswapV3Gauge) {\n            emit GaugeUpdated(uniswapV3Pool, uniswapV3Gauge);\n\n            gauges[uniswapV3Pool] = UniswapV3Gauge(uniswapV3Gauge);\n            gaugePool[uniswapV3Gauge] = uniswapV3Pool;\n        }\n\n        updateBribeDepot(uniswapV3Pool);\n        updatePoolMinimumWidth(uniswapV3Pool);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function updateBribeDepot(IUniswapV3Pool uniswapV3Pool) public {\n        address newDepot = address(gauges[uniswapV3Pool].multiRewardsDepot());\n        if (newDepot != bribeDepots[uniswapV3Pool]) {\n            bribeDepots[uniswapV3Pool] = newDepot;\n\n            emit BribeDepotUpdated(uniswapV3Pool, newDepot);\n        }\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function updatePoolMinimumWidth(IUniswapV3Pool uniswapV3Pool) public {\n        uint24 minimumWidth = gauges[uniswapV3Pool].minimumWidth();\n        if (minimumWidth != poolsMinimumWidth[uniswapV3Pool]) {\n            poolsMinimumWidth[uniswapV3Pool] = minimumWidth;\n\n            emit PoolMinimumWidthUpdated(uniswapV3Pool, minimumWidth);\n        }\n    }\n}"
    }
  ]
}