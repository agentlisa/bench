{
  "Title": "[H-05] Access restrictions on `NotionalV1ToNotionalV2.notionalCallback` can be bypassed",
  "Content": "_Submitted by cmichel, also found by pauliax_\n\nThe `NotionalV1ToNotionalV2.notionalCallback` is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing `sender = this` as `sender` is a parameter of the function that can be chosen by the attacker.\n\n```solidity\nfunction notionalCallback(\n    address sender,\n    address account,\n    bytes calldata callbackData\n) external returns (uint256) {\n    require(sender == address(this), \"Unauthorized callback\");\n```\n\nAn attacker can call the function passing in an arbitrary `account` whose tokens can then be stolen.\nThe `account` first has to approve this contract but this can happen with accounts that legitimately want to migrate their tokens and therefore have to send a first transaction to approve the contract, but then an attacker frontruns the actual migration transaction.\n\nThe attacker can steal the tokens by performing an attack similar to the following:\n- first transaction is used to withdraw the victim's funds to the contract. This can be done by choosing `account=victim`, `v1RepayAmount=0`, `v1CollateralId=WBTC`, `v2CollateralId=DAI`. The [`NotionalV1Erc1155.batchOperationWithdraw`](https://github.com/notional-finance/contracts/blob/4bf7a85e6cf81cde4283e0efab0b03f21249ba00/contracts/ERC1155Trade.sol#L108) (not part of this contest) will withdraw the victim's funds to this contract. Note that the attacker has to deposit the same `v2CollateralBalance = uint256(collateralBalance)` for the victim into the V2 version, but they can choose different cheaper collateral (for example, withdraw WBTC, deposit same amount of DAI).\n- second transaction is now used to deposit the victim funds in the contract into the user's account. They use `account=attacker`, `v1DebtCurrencyId=WBTC`, `v1RepayAmount=amount` to deposit it into Notional V1. (They need to have a small `collateralBalance`, etc. to pass all checks).\n\nRecommend fixing the authorization check.\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-08-notional",
  "Code": [
    {
      "filename": "contracts/ERC1155Trade.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./utils/Common.sol\";\nimport \"./utils/ERC1155Base.sol\";\nimport \"./lib/SafeUInt128.sol\";\n\nimport \"./interface/IERC1155TokenReceiver.sol\";\n\nimport \"./CashMarket.sol\";\n\n/**\n * @notice Implements the ERC1155 token standard for trading OTC and batch operations over Notional markets.\n */\ncontract ERC1155Trade is ERC1155Base {\n    using SafeUInt128 for uint128;\n    address public BRIDGE_PROXY;\n\n    struct TradeRecord {\n        uint16 currencyId;\n        Common.TradeType tradeType;\n        uint128 cash;\n    }\n\n    /**\n     * @notice Notice that a batch operation occured\n     * @param account the account that was affected by the operation\n     * @param operator the operator that sent the transaction\n     */\n    event BatchOperation(address indexed account, address indexed operator);\n\n    /**\n     * @notice Sets the address of the 0x bridgeProxy that is allowed to mint fCash pairs.\n     * @dev governance\n     * @param bridgeProxy address of the 0x ERC1155AssetProxy\n     */\n    function setBridgeProxy(address bridgeProxy) external onlyOwner {\n        BRIDGE_PROXY = bridgeProxy;\n    }\n\n    /**\n     * @notice Allows batch operations of deposits and trades. Approved operators are allowed to call this function\n     * on behalf of accounts.\n     * @dev - TRADE_FAILED_MAX_TIME: the operation will fail due to the set timeout\n     * - UNAUTHORIZED_CALLER: operator is not authorized for the account\n     * - INVALID_CURRENCY: currency specified in deposits is invalid\n     * - MARKET_INACTIVE: maturity is not a valid one\n     * - INSUFFICIENT_BALANCE: insufficient cash balance (or token balance when removing liquidity)\n     * - INSUFFICIENT_FREE_COLLATERAL: account does not have enough free collateral to place the trade\n     * - OVER_MAX_FCASH: [addLiquidity] fCash amount required exceeds supplied maxfCash\n     * - OUT_OF_IMPLIED_RATE_BOUNDS: [addLiquidity] depositing collateral would require more fCash than specified\n     * - TRADE_FAILED_TOO_LARGE: [takeCurrentCash, takefCash] trade is larger than allowed by the governance settings\n     * - TRADE_FAILED_LACK_OF_LIQUIDITY: [takeCurrentCash, takefCash] there is insufficient liquidity in this maturity to handle the trade\n     * - TRADE_FAILED_SLIPPAGE: [takeCurrentCash, takefCash] trade is greater than the max implied rate set\n     * @param account account for which the operation will take place\n     * @param maxTime after this time the operation will fail\n     * @param deposits a list of deposits into the Escrow contract, ERC20 allowance must be in place for the Escrow contract\n     * or these deposits will fail.\n     * @param trades a list of trades to place on fCash markets\n     */\n    function batchOperation(\n        address account,\n        uint32 maxTime,\n        Common.Deposit[] memory deposits,\n        Common.Trade[] memory trades\n    ) public payable {\n        uint32 blockTime = uint32(block.timestamp);\n        require(blockTime <= maxTime, $$(ErrorCode(TRADE_FAILED_MAX_TIME)));\n        require(msg.sender == account || isApprovedForAll(account, msg.sender), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        Portfolios().settleMaturedAssets(account);\n\n        if (deposits.length > 0 || msg.value != 0) Escrow().depositsOnBehalf{value: msg.value}(account, deposits);\n        if (trades.length > 0) _batchTrade(account, trades);\n\n        // If there are only deposits then free collateral will only increase and we do not want to run a check against\n        // it in case an account deposits collateral but is still undercollateralized\n        if (trades.length > 0) {\n            int256 fc = Portfolios().freeCollateralViewAggregateOnly(account);\n            require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n        }\n\n        emit BatchOperation(account, msg.sender);\n    }\n\n    /**\n     * @notice Allows batch operations of deposits, trades and withdraws. Approved operators are allowed to call this function\n     * on behalf of accounts.\n     * @dev - TRADE_FAILED_MAX_TIME: the operation will fail due to the set timeout\n     * - UNAUTHORIZED_CALLER: operator is not authorized for the account\n     * - INVALID_CURRENCY: currency specified in deposits is invalid\n     * - MARKET_INACTIVE: maturity is not a valid one\n     * - INSUFFICIENT_BALANCE: insufficient cash balance (or token balance when removing liquidity)\n     * - INSUFFICIENT_FREE_COLLATERAL: account does not have enough free collateral to place the trade\n     * - OVER_MAX_FCASH: [addLiquidity] fCash amount required exceeds supplied maxfCash\n     * - OUT_OF_IMPLIED_RATE_BOUNDS: [addLiquidity] depositing collateral would require more fCash than specified\n     * - TRADE_FAILED_TOO_LARGE: [takeCurrentCash, takefCash] trade is larger than allowed by the governance settings\n     * - TRADE_FAILED_LACK_OF_LIQUIDITY: [takeCurrentCash, takefCash] there is insufficient liquidity in this maturity to handle the trade\n     * - TRADE_FAILED_SLIPPAGE: [takeCurrentCash, takefCash] trade is greater than the max implied rate set\n     * @param account account for which the operation will take place\n     * @param maxTime after this time the operation will fail\n     * @param deposits a list of deposits into the Escrow contract, ERC20 allowance must be in place for the Escrow contract\n     * or these deposits will fail.\n     * @param trades a list of trades to place on fCash markets\n     * @param withdraws a list of withdraws, if amount is set to zero will attempt to withdraw the account's entire balance\n     * of the specified currency. This is useful for borrowing when the exact exchange rate is not known ahead of time.\n     */\n    function batchOperationWithdraw(\n        address account,\n        uint32 maxTime,\n        Common.Deposit[] memory deposits,\n        Common.Trade[] memory trades,\n        Common.Withdraw[] memory withdraws\n    ) public payable {\n        uint32 blockTime = uint32(block.timestamp);\n        require(blockTime <= maxTime, $$(ErrorCode(TRADE_FAILED_MAX_TIME)));\n        require(msg.sender == account || isApprovedForAll(account, msg.sender), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        Portfolios().settleMaturedAssets(account);\n\n        TradeRecord[] memory tradeRecord;\n        if (deposits.length > 0 || msg.value != 0) Escrow().depositsOnBehalf{value: msg.value}(account, deposits);\n        if (trades.length > 0) tradeRecord = _batchTrade(account, trades);\n        if (withdraws.length > 0) {\n            if (tradeRecord.length > 0) {\n                _updateWithdrawsWithTradeRecord(tradeRecord, deposits, withdraws);\n            }\n\n            Escrow().withdrawsOnBehalf(account, withdraws);\n        }\n\n        int256 fc = Portfolios().freeCollateralViewAggregateOnly(account);\n        require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n\n        emit BatchOperation(account, msg.sender);\n    }\n\n    /**\n     * @notice Transfers tokens between from and to addresses.\n     * @dev - UNAUTHORIZED_CALLER: calling contract must be approved by both from / to addresses or be the 0x proxy\n     * - OVER_MAX_UINT128_AMOUNT: amount specified cannot be greater than MAX_UINT128\n     * - INVALID_SWAP: the asset id specified can only be of CASH_PAYER or CASH_RECEIVER types\n     * - INVALID_CURRENCY: the currency id specified is invalid\n     * - INVALID_CURRENCY: the currency id specified is invalid\n     * @param from Source address\n     * @param to Target address\n     * @param id ID of the token type\n     * @param value Transfer amount\n     * @param data Additional data with no specified format, unused by this contract but forwarded unaltered\n     * to the ERC1155TokenReceiver.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external override {\n        require(\n            msg.sender == BRIDGE_PROXY ||\n            (from == msg.sender && isApprovedForAll(to, from)) ||\n            (isApprovedForAll(from, msg.sender) && isApprovedForAll(to, msg.sender)),\n            $$(ErrorCode(UNAUTHORIZED_CALLER))\n        );\n        require(value <= Common.MAX_UINT_128, $$(ErrorCode(OVER_MAX_UINT128_AMOUNT)));\n\n\n        Common.Deposit[] memory deposits;\n        if (data.length > 0) deposits = abi.decode(data, (Common.Deposit[]));\n\n        bytes1 assetType = Common.getAssetType(id);\n        (uint8 cashGroupId, /* uint16 */ , uint32 maturity) = Common.decodeAssetId(id);\n\n        if (Common.isCashPayer(assetType)) {\n            // (payer, receiver) = (to, from);\n            if (data.length > 0) Escrow().depositsOnBehalf(to, deposits);\n\n            // This does a free collateral check inside.\n            Portfolios().mintfCashPair(to, from, cashGroupId, maturity, uint128(value));\n        } else if (Common.isCashReceiver(assetType)) {\n            // (payer, receiver) = (from, to);\n            if (data.length > 0) Escrow().depositsOnBehalf(from, deposits);\n\n            // This does a free collateral check inside.\n            Portfolios().mintfCashPair(from, to, cashGroupId, maturity, uint128(value));\n        } else {\n            revert($$(ErrorCode(INVALID_SWAP)));\n        }\n\n        emit TransferSingle(msg.sender, from, to, id, value);\n    }\n\n    function safeBatchTransferFrom(\n        address /* _from */,\n        address /* _to */,\n        uint256[] calldata /* _ids */,\n        uint256[] calldata /* _values */,\n        bytes calldata /* _data */\n    ) external override {\n        revert($$(ErrorCode(UNIMPLEMENTED)));\n    }\n\n    /**\n     * @notice Decodes the slippage data parameter and places trades on the cash groups\n     */\n    function _batchTrade(address account, Common.Trade[] memory trades) internal returns (TradeRecord[] memory) {\n        TradeRecord[] memory tradeRecord = new TradeRecord[](trades.length);\n\n        for (uint256 i; i < trades.length; i++) {\n            Common.CashGroup memory fcg = Portfolios().getCashGroup(trades[i].cashGroup);\n            CashMarket fc = CashMarket(fcg.cashMarket);\n\n            if (trades[i].tradeType == Common.TradeType.TakeCurrentCash) {\n                uint32 maxRate;\n                if (trades[i].slippageData.length == 32) {\n                    maxRate = abi.decode(trades[i].slippageData, (uint32));\n                } else {\n                    maxRate = Common.MAX_UINT_32;\n                }\n\n                tradeRecord[i].currencyId = fcg.currency;\n                tradeRecord[i].tradeType = Common.TradeType.TakeCurrentCash;\n                tradeRecord[i].cash = fc.takeCurrentCashOnBehalf(account, trades[i].maturity, trades[i].amount, maxRate);\n            } else if (trades[i].tradeType == Common.TradeType.TakefCash) {\n                uint32 minRate;\n                if (trades[i].slippageData.length == 32) {\n                    minRate = abi.decode(trades[i].slippageData, (uint32));\n                }\n\n                tradeRecord[i].currencyId = fcg.currency;\n                tradeRecord[i].tradeType = Common.TradeType.TakefCash;\n                tradeRecord[i].cash = fc.takefCashOnBehalf(account, trades[i].maturity, trades[i].amount, minRate);\n            } else if (trades[i].tradeType == Common.TradeType.AddLiquidity) {\n                uint32 minRate;\n                uint32 maxRate;\n                uint128 maxfCash;\n                if (trades[i].slippageData.length == 64) {\n                    (minRate, maxRate) = abi.decode(trades[i].slippageData, (uint32, uint32));\n                    maxfCash = Common.MAX_UINT_128;\n                } else if (trades[i].slippageData.length == 96) {\n                    (minRate, maxRate, maxfCash) = abi.decode(trades[i].slippageData, (uint32, uint32, uint128));\n                } else {\n                    maxRate = Common.MAX_UINT_32;\n                    maxfCash = Common.MAX_UINT_128;\n                }\n\n                // Add Liquidity always adds the specified amount of cash or it fails out.\n                tradeRecord[i].currencyId = fcg.currency;\n                tradeRecord[i].tradeType = Common.TradeType.AddLiquidity;\n                tradeRecord[i].cash = trades[i].amount;\n                fc.addLiquidityOnBehalf(account, trades[i].maturity, trades[i].amount, maxfCash, minRate, maxRate);\n            } else if (trades[i].tradeType == Common.TradeType.RemoveLiquidity) {\n                tradeRecord[i].currencyId = fcg.currency;\n                tradeRecord[i].tradeType = Common.TradeType.RemoveLiquidity;\n                tradeRecord[i].cash = fc.removeLiquidityOnBehalf(account, trades[i].maturity, trades[i].amount);\n            }\n        }\n\n        return tradeRecord;\n    }\n\n    function _updateWithdrawsWithTradeRecord(\n        TradeRecord[] memory tradeRecord,\n        Common.Deposit[] memory deposits,\n        Common.Withdraw[] memory withdraws\n    ) internal pure {\n        // We look for records of withdraw.amount == 0 in order to update the amount for the\n        // residuals from the trade record.\n        for (uint256 i; i < withdraws.length; i++) {\n            if (withdraws[i].amount == 0) {\n                withdraws[i].amount = _calculateWithdrawAmount(\n                    withdraws[i].currencyId,\n                    tradeRecord,\n                    deposits\n                );\n            }\n        }\n    }\n\n    function _calculateWithdrawAmount(\n        uint16 currencyId,\n        TradeRecord[] memory tradeRecord,\n        Common.Deposit[] memory deposits\n    ) internal pure returns (uint128) {\n        uint128 depositResidual;\n\n        for (uint256 i; i < deposits.length; i++) {\n            if (deposits[i].currencyId == currencyId) {\n                // First seek the deposit array to find the deposit residual\n                depositResidual = deposits[i].amount;\n                break;\n            }\n        }\n\n        for (uint256 i; i < tradeRecord.length; i++) {\n            if (tradeRecord[i].currencyId != currencyId) continue;\n\n            if (tradeRecord[i].tradeType == Common.TradeType.TakeCurrentCash\n                || tradeRecord[i].tradeType == Common.TradeType.RemoveLiquidity) {\n                // This is the amount of cash that was taken from the market\n                depositResidual = depositResidual.add(tradeRecord[i].cash);\n            } else if (tradeRecord[i].tradeType == Common.TradeType.TakefCash\n                || tradeRecord[i].tradeType == Common.TradeType.AddLiquidity) {\n                // This is the residual from the deposit that was not put into the market. We floor this value at\n                // zero to avoid an overflow.\n                depositResidual = depositResidual < tradeRecord[i].cash ? 0 : depositResidual - tradeRecord[i].cash;\n            }\n        }\n\n        return depositResidual;\n    }\n}"
    }
  ]
}