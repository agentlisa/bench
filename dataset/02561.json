{
  "Title": "H-4: PerpDepository has no way to withdraw profits depriving stakers of profits owed",
  "Content": "# Issue H-4: PerpDepository has no way to withdraw profits depriving stakers of profits owed \n\nSource: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/251 \n\n## Found by \n0x52\n\n## Summary\n\nPerpDepository has no way to calculate or withdraw any profits made by the vault. By [design](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/rage-trade/RageDnDepository.sol#L99-L115) stakes are entitled to a portion of the profits generated by the delta-neutral strategy. The issue is that the vault never implements a way to withdraw profits to stakers, resulting in loss of revenue for them.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nProfits owed stakers will be trapped in the contract and they will lose that portion of their revenue\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L25\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCreate a function to calculate and withdraw protocol profit to be awarded to stakers\n\n## Discussion\n\n**WarTech9**\n\nProfits on `PerpDepository` are currently locked in the depository and can be unlocked in future updates through positive PnL rebalancing.\n`RageDepository` profits are locked in that contract and can be withdrawn by the contract owner (governance) through the `withdrawProfits()` function\n\n**rvierdiyev**\n\nEscalate for 11 USDC.\n\nThis is not a vulnerability.\nAs @WarTech9 said, \n>`RageDepository` profits are locked in that contract and can be withdrawn by the contract owner (governance) through the `withdrawProfits()` function\n\nThis is design choice of protocol. I have discussed that during the contest with @WarTech9, so he explained me that and i didn't submit that as issue. As he said, that rewards are not lost and governance can withdraw it later to reuse.\n\nAlso author of report states in impact section that:\n> Profits owed stakers will be trapped in the contract and they will lose that portion of their revenue\n\nBut this is not true, as i described above, that value is not stucked as protocol can withdraw it.\n\n**sherlock-admin**\n\n > Escalate for 11 USDC.\n> \n> This is not a vulnerability.\n> As @WarTech9 said, \n> >`RageDepository` profits are locked in that contract and can be withdrawn by the contract owner (governance) through the `withdrawProfits()` function\n> \n> This is design choice of protocol. I have discussed that during the contest with @WarTech9, so he explained me that and i didn't submit that as issue. As he said, that rewards are not lost and governance can withdraw it later to reuse.\n> \n> Also author of report states in impact section that:\n> > Profits owed stakers will be trapped in the contract and they will lose that portion of their revenue\n> \n> But this is not true, as i described above, that value is not stucked as protocol can withdraw it.\n\nYou've created a valid escalation for 11 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nThis is in PerpDepository and not RageDepository. Profits in PerpDepository are stuck with no method to unlock them except while upgrading the contract. \nAlthough contract upgrades are to be used for feature updates and add changes to handle extreme situations, this issue is clearly a smart contract bug where funds are locked.  \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> This is in PerpDepository and not RageDepository. Profits in PerpDepository are stuck with no method to unlock them except while upgrading the contract. \n> Although contract upgrades are to be used for feature updates and add changes to handle extreme situations, this issue is clearly a smart contract bug where funds are locked.  \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/33",
  "Code": [
    {
      "filename": "contracts/integrations/rage-trade/RageDnDepository.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20, IERC20Metadata, ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IDnGmxSeniorVault} from \"../../external/rage-trade/IDnGmxSeniorVault.sol\";\nimport {IDepository} from \"../IDepository.sol\";\nimport {IUXDController} from \"../../core/IUXDController.sol\";\nimport {MathLib} from \"../../libraries/MathLib.sol\";\nimport {RageDnDepositoryStorage} from \"./RageDnDepositoryStorage.sol\";\n\n/// @title RageDnDepository\n/// @notice Manages interactions with Rage Trade.\ncontract RageDnDepository is\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    RageDnDepositoryStorage\n{\n    using MathLib for uint256;\n    using AddressUpgradeable for address;\n    using SafeERC20Upgradeable for IERC20;\n    using SafeERC20Upgradeable for ERC20;\n\n    error NoProfits(int256 pnl);\n    error NotApproved(uint256 allowance, uint256 amount);\n    error NotController(address caller);\n    error NotContractAddress(address addr);\n    error UnsupportedAsset(address asset);\n    error RedeemableSoftCapHit(uint256 softcap, uint256 totalRedeemable);\n    error TokenTransferFail(address token, address from, address to);\n\n    ///////////////////////////////////////////////////////////////////\n    ///                         Events\n    ///////////////////////////////////////////////////////////////////\n    event Deposited(\n        address indexed caller,\n        uint256 assets,\n        uint256 redeemable,\n        uint256 shares\n    );\n    event Withdrawn(\n        address indexed caller,\n        uint256 assets,\n        uint256 redeemable,\n        uint256 shares\n    );\n    event Redeemed(\n        address indexed caller,\n        uint256 assets,\n        uint256 redeemable,\n        uint256 shares\n    );\n    event RedeemableSoftCapUpdated(address indexed caller, uint256 newSoftCap);\n\n    /// @notice Constructor\n    /// @param _vault the address of the Rage Senior vault\n    /// @param _controller the address of the UXDController\n    function initialize(address _vault, address _controller) external virtual initializer {\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n\n        if (!_vault.isContract()) {\n            revert NotContractAddress(_vault);\n        }\n        if (!_controller.isContract()) {\n            revert NotContractAddress(_controller);\n        }\n        vault = IDnGmxSeniorVault(_vault);\n        controller = IUXDController(_controller);\n        assetToken = vault.asset();\n        redeemable = address(controller.redeemable());\n    }\n\n    /// @dev restirct access to controller\n    modifier onlyController() {\n        if (msg.sender != address(controller)) {\n            revert NotController(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Sets the redeemable soft cap\n    /// @dev Can only be called by owner\n    /// @param softCap The new redeemable soft cap\n    function setRedeemableSoftCap(uint256 softCap) external onlyOwner {\n        redeemableSoftCap = softCap;\n        emit RedeemableSoftCapUpdated(msg.sender, softCap);\n    }\n\n    /// @notice Deposits assets\n    /// @param assetAmount The amount of assets to deposit in assetToken.decimals()\n    /// @return redeemableAmount the corresponding amount of redeemable for asset deposited\n    function deposit(address asset, uint256 assetAmount)\n        external\n        onlyController\n        returns (uint256)\n    {\n        if (asset != assetToken) {\n            revert UnsupportedAsset(asset);\n        }\n        netAssetDeposits += assetAmount;\n        IERC20(assetToken).approve(address(vault), assetAmount);\n        uint256 shares = vault.deposit(assetAmount, address(this));\n        uint256 redeemableAmount = _assetsToRedeemable(assetAmount);\n        redeemableUnderManagement += redeemableAmount;\n        _checkSoftCap();\n        emit Deposited(msg.sender, assetAmount, redeemableAmount, shares);\n        return redeemableAmount;\n    }\n\n    /// @notice Redeem a given amount.\n    /// @param redeemableAmount The amount to redeem in redeemable.decimals()\n    /// @return assetAmount The asset amount withdrawn by this redemption\n    function redeem(address asset, uint256 redeemableAmount)\n        external\n        onlyController\n        returns (uint256)\n    {\n        if (asset != assetToken) {\n            revert UnsupportedAsset(asset);\n        }\n        uint256 assetAmount = _redeemableToAssets(redeemableAmount);\n        redeemableUnderManagement -= redeemableAmount;\n        netAssetDeposits -= assetAmount;\n        uint256 shares = vault.withdraw(\n            assetAmount,\n            address(controller),\n            address(this)\n        );\n        emit Withdrawn(msg.sender, assetAmount, redeemableAmount, shares);\n        return assetAmount;\n    }\n\n    /// @dev returns assets deposited. IDepository required.\n    function assetsDeposited() external view returns (uint256) {\n        return netAssetDeposits;\n    }\n\n    /// @dev returns the shares currently owned by this depository\n    function getDepositoryShares() external view returns (uint256) {\n        return vault.balanceOf(address(this));\n    }\n\n    /// @dev returns the assets currently owned by this depository.\n    function getDepositoryAssets() public view returns (uint256) {\n        return vault.convertToAssets(vault.balanceOf(address(this)));\n    }\n\n    /// @dev the difference between curent vault assets and amount deposited\n    function getUnrealizedPnl() public view returns (int256) {\n        return int256(getDepositoryAssets()) - int256(netAssetDeposits);\n    }\n\n    /// @dev Withdraw profits. Ensure redeemable is still fully backed by asset balance after this is run.\n    /// TODO: Remove this function. Code profit access and use in contracts\n    function withdrawProfits(address receiver) external onlyOwner nonReentrant {\n        int256 pnl = getUnrealizedPnl();\n        if (pnl <= 0) {\n            revert NoProfits(pnl);\n        }\n        uint256 profits = uint256(pnl);\n        vault.withdraw(profits, receiver, address(this));\n        realizedPnl += profits;\n    }\n\n    function _assetsToRedeemable(uint256 assetAmount)\n        private\n        view\n        returns (uint256)\n    {\n        return\n            assetAmount.fromDecimalToDecimal(\n                IERC20Metadata(assetToken).decimals(),\n                IERC20Metadata(redeemable).decimals()\n            );\n    }\n\n    function _redeemableToAssets(uint256 redeemableAmount)\n        private\n        view\n        returns (uint256)\n    {\n        return\n            redeemableAmount.fromDecimalToDecimal(\n                IERC20Metadata(redeemable).decimals(),\n                IERC20Metadata(assetToken).decimals()\n            );\n    }\n\n    function _checkSoftCap() private view {\n        if (redeemableUnderManagement > redeemableSoftCap) {\n            revert RedeemableSoftCapHit(\n                redeemableSoftCap,\n                redeemableUnderManagement\n            );\n        }\n    }\n\n    /// @notice Transfers contract ownership to a new address\n    /// @dev This can only be called by the current owner.\n    /// @param newOwner The address of the new owner.\n    function transferOwnership(address newOwner)\n        public\n        override(IDepository, OwnableUpgradeable)\n        onlyOwner\n    {\n        super.transferOwnership(newOwner);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    ///                         Upgrades\n    ///////////////////////////////////////////////////////////////////////\n\n    /// @dev Returns the current version of this contract\n    // solhint-disable-next-line func-name-mixedcase\n    function VERSION() external pure virtual returns (uint8) {\n        return 1;\n    }\n\n    /// @dev called on upgrade. only owner can call upgrade function\n    function _authorizeUpgrade(address)\n        internal\n        virtual\n        override\n        onlyOwner\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n}"
    },
    {
      "filename": "contracts/integrations/perp/PerpDepository.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IDepository, DepositoryState} from \"../IDepository.sol\";\nimport {IVault} from \"../../external/perp/IVault.sol\";\nimport {IClearingHouse} from \"../../external/perp/IClearingHouse.sol\";\nimport {IMarketRegistry} from \"../../external/perp/IMarketRegistry.sol\";\nimport {IAccountBalance} from \"../../external/perp/IAccountBalance.sol\";\nimport {IExchange} from \"../../external/perp/IExchange.sol\";\nimport {IUXDRouter} from \"../../core/IUXDRouter.sol\";\nimport {ERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ErrZeroAddress} from \"../../common/Constants.sol\";\nimport {FixedPointMathLib} from \"../../libraries/FixedPointMath.sol\";\nimport {MathLib} from \"../../libraries/MathLib.sol\";\nimport {ISwapper, SwapParams} from \"../ISwapper.sol\";\nimport {PerpDepositoryStorage} from \"./PerpDepositoryStorage.sol\";\n\n/// @title PerpDepository\n/// @notice Handles interactions with Perpetual Protocol Curie smart congtracts.\n/// @dev Collateral deposits, withdrawals and open positions are managed by this contract.\ncontract PerpDepository is\n    UUPSUpgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PerpDepositoryStorage\n{\n    using FixedPointMathLib for uint256;\n    using MathLib for uint256;\n    using MathLib for uint160;\n    using AddressUpgradeable for address;\n\n    ///////////////////////////////////////////////////////////////////\n    ///                         Errors\n    ///////////////////////////////////////////////////////////////////\n    error NotController(address caller);\n    error NotApproved(uint256 allowance, uint256 amount);\n    error ZeroAmount();\n    error RedeemableSoftCapHit(uint256 softcap, uint256 newBasePosition);\n    error InsufficientPnl(int256 allowance, uint256 amount);\n    error InvalidRebalance(int8 polarity);\n    error InvalidQuoteTokenBalance(int256 balance);\n    error AddressNotContract(address addr);\n    error PositivePnlRebalanceDisabled(address caller);\n    error QuoteRedeemDisabled(address account);\n    error UnsupportedAsset(address asset);\n    error InsufficientAssetDeposits(uint256 assetDeposits, uint256 amount);\n\n    ///////////////////////////////////////////////////////////////////\n    ///                         Events\n    ///////////////////////////////////////////////////////////////////\n    event InsuranceDeposited(\n        address indexed caller,\n        address indexed from,\n        uint256 amount\n    );\n    event InsuranceWithdrawn(\n        address indexed caller,\n        address indexed to,\n        uint256 amount\n    );\n    event RedeemableSoftCapUpdated(address indexed caller, uint256 newSoftCap);\n    event PositionOpened(\n        bool isShort,\n        uint256 amount,\n        bool amountIsInput,\n        uint160 sqrtPriceLimitX96\n    );\n\n    event Rebalanced(uint256 baseAmount, uint256 quoteAmount, int256 shortfall);\n\n    ///////////////////////////////////////////////////////////////////\n    ///                     Constants\n    ///////////////////////////////////////////////////////////////////\n\n    /// @dev For Perpetual protocol fee calculations\n    uint256 public constant HUNDRED_PERCENT = 1e6;\n\n    uint256 private constant WAD = 1e18;\n\n    modifier onlyController() {\n        if (msg.sender != address(controller)) {\n            revert NotController(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Initializer\n    /// @param _clearingHouse Perp curie clearing house\n    /// @param _marketRegistry Perp curie market registry\n    /// @param _futuresMarket The market this depository opens positions in\n    /// @param _assetToken The asset/collateral token address\n    /// @param _quoteToken The insurance token address\n    /// @param _controller UXD Controller. Used for access control\n    function initialize(\n        address _vault,\n        address _clearingHouse,\n        address _marketRegistry,\n        address _futuresMarket,\n        address _assetToken,\n        address _quoteToken,\n        address _controller\n    ) external virtual initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        address[] memory contractAddresses = new address[](7);\n        contractAddresses[0] = _vault;\n        contractAddresses[1] = _clearingHouse;\n        contractAddresses[2] = _marketRegistry;\n        contractAddresses[3] = _futuresMarket;\n        contractAddresses[4] = _assetToken;\n        contractAddresses[5] = _quoteToken;\n        contractAddresses[6] = _controller;\n        _checkContractAddresses(contractAddresses);\n\n        vault = IVault(_vault);\n        clearingHouse = IClearingHouse(_clearingHouse);\n        marketRegistry = IMarketRegistry(_marketRegistry);\n        market = _futuresMarket;\n        assetToken = _assetToken;\n        quoteToken = _quoteToken;\n        controller = _controller;\n    }\n\n    function _checkContractAddresses(address[] memory addresses) private view {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (!addresses[i].isContract()) {\n                revert AddressNotContract(addresses[i]);\n            }\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////\n    ///                 Admin functions\n    //////////////////////////////////////////////////////////////////\n\n    /// @notice Sets the controller address\n    /// @param _controller The new controller address\n    function setController(address _controller) external onlyOwner {\n        if (!_controller.isContract()) {\n            revert AddressNotContract(_controller);\n        }\n        controller = _controller;\n    }\n\n    /// @notice Sets the spot market swapping contract address.\n    /// @dev This updates the contract that performs the spot market swap as part of rebalancing.\n    /// @param _swapper The new contract address\n    function setSpotSwapper(address _swapper) external onlyOwner {\n        if (!_swapper.isContract()) {\n            revert AddressNotContract(_swapper);\n        }\n        spotSwapper = ISwapper(_swapper);\n    }\n\n    /// @notice Sets the redeemable soft cap\n    /// @dev Can only be called by owner\n    /// @param softCap The new redeemable soft cap\n    function setRedeemableSoftCap(uint256 softCap) external onlyOwner {\n        if (softCap == 0) {\n            revert ZeroAmount();\n        }\n        redeemableSoftCap = softCap;\n\n        emit RedeemableSoftCapUpdated(msg.sender, softCap);\n    }\n\n    /// @notice Deposits insurance to this depository\n    /// @dev Insurance token is set at contract initialization.\n    /// Only called by the owner\n    /// @param amount the amount to deposit\n    /// @param from the account to deposit from. This account must have approved this contract to\n    // spend >= amount.\n    function depositInsurance(uint256 amount, address from)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n        uint256 allowance = IERC20(insuranceToken()).allowance(\n            from,\n            address(this)\n        );\n        if (allowance < amount) {\n            revert NotApproved(allowance, amount);\n        }\n\n        insuranceDeposited += amount;\n\n        IERC20(insuranceToken()).transferFrom(from, address(this), amount);\n        IERC20(insuranceToken()).approve(address(vault), amount);\n        vault.deposit(insuranceToken(), amount);\n\n        emit InsuranceDeposited(msg.sender, from, amount);\n    }\n\n    /// @notice Withdraws insurance from this depository\n    /// @dev Can only be called by Owner (governance).\n    /// @param amount The amount to withdraw.\n    /// @param to The account to withdraw to.\n    function withdrawInsurance(uint256 amount, address to)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n\n        insuranceDeposited -= amount;\n\n        vault.withdraw(insuranceToken(), amount);\n        IERC20(insuranceToken()).transfer(to, amount);\n\n        emit InsuranceWithdrawn(msg.sender, to, amount);\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    ///                 Mint and redeem\n    ///////////////////////////////////////////////////////////////////\n\n    /// @notice Deposit asset and return the amount of redeemable that can be minted.\n    /// @dev This is set up to handle either `assetToken` or `quoteToken` deposits.\n    /// If `assetToken` is deposted, we use the delta-neutral strategy and open additional\n    /// short position. The amount returned is the `quote` amount from opening the short.\n    /// If `quoteToken` is deposited, we use the \"quote mint\" strategy whereby we deposit\n    /// quote token and return an equivalant amount redeemable.\n    /// Quote minting is only possible if we have a negative PnL > `amount`. The amount deposited\n    /// is used to pay off part of this negative PnL.\n    /// @param asset The token to deposit\n    /// @param amount The amount to deposit\n    /// @return amountOut The amount of redeemable that can be added to the total supply.\n    function deposit(\n        address asset,\n        uint256 amount\n    ) external onlyController returns (uint256) {\n        if (asset == assetToken) {\n            _depositAsset(amount);\n            (, uint256 quoteAmount) = _openShort(amount);\n            return quoteAmount;\n        } else if (asset == quoteToken) {\n            return _processQuoteMint(amount);\n        } else {\n            revert UnsupportedAsset(asset);\n        }\n    }\n\n    /// @notice Redeem an amount of redeemable token.\n    /// @dev This handles redeeming for either `assetToken` or `quoteToken`.\n    /// If `assetToken` is specified, we use the delta-neutral strategy and close part of the\n    /// short position. This frees up asset collateral which can then be returned to the user.\n    /// If `quoteToken` is specified, we use the quote redeem strategy where we withdraw quote token\n    /// which can be returned to the caller. This is only possible if we have a positive PnL > amount being redeemed.\n    /// @param asset The asset to receive from this redemption\n    /// @param amount The amount of redeemable to redeem\n    /// @return amountOut The amount of `asset` released from this redemption\n    function redeem(\n        address asset,\n        uint256 amount\n    ) external onlyController returns (uint256) {\n        if (asset == assetToken) {\n            (uint256 base, ) = _openLong(amount);\n            _withdrawAsset(base, address(controller));\n            return base;\n        } else if (asset == quoteToken) {\n            revert QuoteRedeemDisabled(msg.sender);\n            // return _processQuoteRedeem(amount);\n        } else {\n            revert UnsupportedAsset(asset);\n        }\n    }\n\n    /// @notice Deposits collateral to back the delta-neutral position\n    /// @dev Only called by the controller\n    /// @param amount The amount to deposit\n    function _depositAsset(uint256 amount) private {\n        netAssetDeposits += amount;\n\n        IERC20(assetToken).approve(address(vault), amount);\n        vault.deposit(assetToken, amount);\n    }\n\n    /// @notice Withdraws collateral to used in the delta-neutral position.\n    /// @dev This should only happen when redeeming UXD for collateral.\n    /// Only called by the controller.\n    /// @param amount The amount to deposit\n    function _withdrawAsset(uint256 amount, address to) private {\n        if (amount > netAssetDeposits) {\n            revert InsufficientAssetDeposits(netAssetDeposits, amount);\n        }\n        netAssetDeposits -= amount;\n\n        vault.withdraw(address(assetToken), amount);\n        IERC20(assetToken).transfer(to, amount);\n    }\n\n    /// @notice Opens a long position on the perpetual DEX.\n    /// @dev This closes a portion of the previously open short backing the delta-neutral position.\n    /// Only called by the controller\n    /// @param amount The amount to open long position for.\n    /// `isBaseToQuote == false`, `exactInput == true`, so this is the quote amount.\n    function _openLong(uint256 amount)\n        private\n        returns (uint256, uint256)\n    {\n        (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n            amount,\n            false, // isShort\n            true, // isExactInput\n            0 // sqrtPriceLimitX96\n        );\n        redeemableUnderManagement -= quoteAmount;\n\n        return (baseAmount, quoteAmount);\n    }\n\n    /// @notice Opens a short position on the perpetual DEX.\n    /// @dev This increases the size of the delta-neutral position.\n    /// Can only be called by the controller\n    /// @param amount The amount of short position to open. THis is opened with `exactInput = true`,\n    /// thus, this is the input/base token amount.\n    /// @return base, quote\n    function _openShort(uint256 amount)\n        private\n        returns (uint256, uint256)\n    {\n        (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n            amount,\n            true, // short\n            true, // exactInput\n            0\n        );\n        redeemableUnderManagement += quoteAmount;\n        _checkSoftCap();\n        // emit event here\n        return (baseAmount, quoteAmount);\n    }\n\n    function _placePerpOrder(\n        uint256 amount,\n        bool isShort,\n        bool amountIsInput,\n        uint160 sqrtPriceLimit\n    ) private returns (uint256, uint256) {\n        uint256 upperBound = 0; // 0 = no limit, limit set by sqrtPriceLimit\n\n        IClearingHouse.OpenPositionParams memory params = IClearingHouse\n            .OpenPositionParams({\n                baseToken: market,\n                isBaseToQuote: isShort, // true for short\n                isExactInput: amountIsInput, // we specify exact input amount\n                amount: amount, // collateral amount - fees\n                oppositeAmountBound: upperBound, // output upper bound\n                // solhint-disable-next-line not-rely-on-time\n                deadline: block.timestamp,\n                sqrtPriceLimitX96: sqrtPriceLimit, // max slippage\n                referralCode: 0x0\n            });\n\n        (uint256 baseAmount, uint256 quoteAmount) = clearingHouse.openPosition(\n            params\n        );\n        uint256 feeAmount = _calculatePerpOrderFeeAmount(quoteAmount);\n        totalFeesPaid += feeAmount;\n\n        emit PositionOpened(isShort, amount, amountIsInput, sqrtPriceLimit);\n        return (baseAmount, quoteAmount);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    ///                     Quote mint and redeem\n    ///////////////////////////////////////////////////////////////////////////\n    /// @notice Process minting with quote token\n    /// @dev Deposits quote token to offset open noitional. Only possible if unrealizedPnl() > quoteAmount (normalized to 10^18).\n    /// Only called by controller.\n    /// @param quoteAmount The amount of quote amount being deposited.\n    /// @return normalizedAmount The amount of redeemable that can be minted.\n    function _processQuoteMint(uint256 quoteAmount) private returns (uint256) {\n        uint256 normalizedAmount = quoteAmount.fromDecimalToDecimal(\n            ERC20(quoteToken).decimals(),\n            18\n        );\n        _checkNegativePnl(normalizedAmount);\n        quoteMinted += int256(normalizedAmount);\n        redeemableUnderManagement += normalizedAmount;\n        _checkSoftCap();\n        IERC20(quoteToken).approve(address(vault), quoteAmount);\n        vault.deposit(quoteToken, quoteAmount);\n        return normalizedAmount;\n    }\n\n\n    /// NOTE: Quote redeem disabled (rebalances positive PnL)\n    /// @notice Process redeeming quote token on this depository.\n    /// @dev Withdraws quote token from the vault and returns it to the user.\n    /// Only called by controller.\n    //// @param redeemableAmount The amount being redeemed.\n    /// @return quoteAmout The amount of quote token withdrawn.\n    // function _processQuoteRedeem(uint256 redeemableAmount)\n    //     private\n    //     onlyController\n    //     returns (uint256)\n    // {\n    //     _checkPositivePnl(redeemableAmount);\n    //     quoteMinted -= int256(redeemableAmount);\n    //     redeemableUnderManagement -= redeemableAmount;\n    //     uint256 quoteAmount = redeemableAmount.fromDecimalToDecimal(\n    //         18,\n    //         ERC20(quoteToken).decimals()\n    //     );\n    //     vault.withdraw(quoteToken, quoteAmount);\n    //     IERC20(quoteToken).transfer(address(controller), quoteAmount);\n    //     return quoteAmount;\n    // }\n\n    /// @notice The unrealized Pnl from the delta neutral position.\n    /// @dev A positive value means the `redeemableUnderManagement` is larger than the delta neutral position\n    /// thus, we quote redeem or rebalance positive PnL.\n    /// A negative value means the `redeemableUnderManagement` is smaller than the delta neutral position value\n    /// thus, we can quote mint and/or rebalance negative PnL.\n    /// @return pnl The differnce between the `redeemableUnderManagement` and current perp position size.\n    function getUnrealizedPnl() public view returns (int256) {\n        return int256(redeemableUnderManagement) - int256(getPositionValue());\n    }\n\n    ////////////////////////////////////////////////////////////////////////\n    ///                        Rebalancing\n    ////////////////////////////////////////////////////////////////////////\n\n    /// @notice Rebalance PnL\n    /// @param amount The amount in quote token to rebalance.\n    /// @param amountOutMinimum The minimum amount of base token to receive in the swap to proceed with rebalancing.\n    /// @param polarity the direction of the rebalance. -1 to rebalance negative PnL, +1 for positive PnL\n    /// @param sqrtPriceLimitX96 The target price when performing the swap on the spot DEX, and also when placing the perp order.\n    /// @param account If there is any shortfall in the swap `account` covers the difference.\n    /// For negative PnL, account must have pre-approved this contract to spend quoteToken.\n    /// For positive PnL, account must have pre-approved this contract to spend assetToken.\n    /// The maximum amount that must be transferred from account = swap fees + slippage.\n    function rebalance(\n        uint256 amount,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint24 swapPoolFee,\n        int8 polarity,\n        address account\n    ) external nonReentrant returns (uint256, uint256) {\n        if (polarity == -1) {\n            return\n                _rebalanceNegativePnlWithSwap(\n                    amount,\n                    amountOutMinimum,\n                    sqrtPriceLimitX96,\n                    swapPoolFee,\n                    account\n                );\n        } else if (polarity == 1) {\n            // disable rebalancing positive PnL\n            revert PositivePnlRebalanceDisabled(msg.sender);\n            // return _rebalancePositivePnlWithSwap(amount, amountOutMinimum, sqrtPriceLimitX96, swapPoolFee, account);\n        } else {\n            revert InvalidRebalance(polarity);\n        }\n    }\n\n    // Collateral price has increased, thus, positionValue > supply. close part of open position\n    // close (amount quote) part of position => (baseAmount, quoteAmount)\n    // withdraw baseAmount base token.\n    // swap base => quote\n    // Transfer shortfall from swap from `account`\n    // deposit USDC to cover negative PnL\n    function _rebalanceNegativePnlWithSwap(\n        uint256 amount,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint24 swapPoolFee,\n        address account\n    ) private returns (uint256, uint256) {\n        uint256 normalizedAmount = amount.fromDecimalToDecimal(\n            ERC20(quoteToken).decimals(),\n            18\n        );\n        _checkNegativePnl(normalizedAmount);\n        bool isShort = false;\n        bool amountIsInput = true;\n        (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n            normalizedAmount,\n            isShort,\n            amountIsInput,\n            sqrtPriceLimitX96\n        );\n        vault.withdraw(assetToken, baseAmount);\n        SwapParams memory params = SwapParams({\n            tokenIn: assetToken,\n            tokenOut: quoteToken,\n            amountIn: baseAmount,\n            amountOutMinimum: amountOutMinimum,\n            sqrtPriceLimitX96: sqrtPriceLimitX96,\n            poolFee: swapPoolFee\n        });\n        uint256 quoteAmountOut = spotSwapper.swapExactInput(params);\n        int256 shortFall = int256(\n            quoteAmount.fromDecimalToDecimal(18, ERC20(quoteToken).decimals())\n        ) - int256(quoteAmountOut);\n        if (shortFall > 0) {\n            IERC20(quoteToken).transferFrom(\n                account,\n                address(this),\n                uint256(shortFall)\n            );\n        } else if (shortFall < 0) {\n            // we got excess tokens in the spot swap. Send them to the account paying for rebalance\n            IERC20(quoteToken).transfer(\n                account,\n                _abs(shortFall)\n            );\n        }\n        vault.deposit(quoteToken, quoteAmount);\n\n        emit Rebalanced(baseAmount, quoteAmount, shortFall);\n        return (baseAmount, quoteAmount);\n    }\n\n    /// NOTE: Rebalancing positive PnL disabled.\n    // Collateral price has fallen, thus, openNotional < supply. Open more DNP.\n    // withdraw quote profit\n    // swap quote => base\n    // deposit base\n    // open more DNP amount\n    // function _rebalancePositivePnlWithSwap(\n    //     uint256 amount,\n    //     uint256 amountOutMinimum,\n    //     uint160 sqrtPriceLimitX96,\n    //     uint24 swapPoolFee,\n    //     address account\n    // ) private returns (uint256, uint256) {\n    //     uint256 normalizedAmount = amount.fromDecimalToDecimal(\n    //         ERC20(quoteToken).decimals(),\n    //         18\n    //     );\n    //     _checkPositivePnl(normalizedAmount);\n    //     vault.withdraw(quoteToken, amount);\n    //     SwapParams memory params = SwapParams({\n    //         tokenIn: quoteToken,\n    //         tokenOut: assetToken,\n    //         amountIn: normalizedAmount,\n    //         amountOutMinimum: amountOutMinimum,\n    //         sqrtPriceLimitX96: sqrtPriceLimitX96,\n    //         poolFee: swapPoolFee\n    //     });\n    //     uint256 baseAmountFromSwap = spotSwapper.swapExactInput(params);\n    //     // can we wait to deposit this after we know the shortfall?\n    //     vault.deposit(assetToken, baseAmountFromSwap);\n    //     (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n    //         normalizedAmount,\n    //         true, // expand position\n    //         false, // amount is input\n    //         sqrtPriceLimitX96\n    //     );\n    //     int256 shortFall = int256(baseAmount) - int256(baseAmountFromSwap);\n    //     if (shortFall > 0) {\n    //         IERC20(assetToken).transferFrom(\n    //             account,\n    //             address(this),\n    //             uint256(shortFall)\n    //         );\n    //         vault.deposit(assetToken, uint256(shortFall));\n    //     } else if (shortFall < 0) {\n    //         // we got excess tokens from swap. Send them to account paying for rebalance\n    //         IERC20(assetToken).transfer(\n    //             account,\n    //             _abs(shortFall)\n    //         );\n    //     }\n\n    //     emit Rebalanced(baseAmount, quoteAmount, shortFall);\n    //     return (baseAmount, quoteAmount);\n    // }\n\n    /// @notice Rebalance unrealized PnL lite.\n    /// @dev Lite rebalancing requires the caller to provide the amount to rebalance.\n    /// For negative PnL, `account` provides amount in quote token.\n    /// For this call to succeed the account must"
    }
  ]
}