{
  "Title": "M-16: Incorrect amount given as input to `_handleRebalanceIn` when `flashRebalance` is called",
  "Content": "# Issue M-16: Incorrect amount given as input to `_handleRebalanceIn` when `flashRebalance` is called \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/701 \n\n## Found by \nAymen0909, ck\n\nWhen `flashRebalance` is called, the wrong deposit amount is given to the `_handleRebalanceIn` function as the whole `tokenInBalanceAfter` amount is given as input instead of the delta value `tokenInBalanceAfter - tokenInBalanceBefore`, this will result in an incorrect rebalance operation and can potentialy lead to a DOS due to the insufficient amount error.\n\n## Vulnerability Detail\n\nThe issue occurs in the `flashRebalance` function below :\n\n```solidity\nfunction flashRebalance(\n    DestinationInfo storage destInfoOut,\n    DestinationInfo storage destInfoIn,\n    IERC3156FlashBorrower receiver,\n    IStrategy.RebalanceParams memory params,\n    FlashRebalanceParams memory flashParams,\n    bytes calldata data\n) external returns (uint256 idle, uint256 debt) {\n    ...\n\n    // Handle increase (shares coming \"In\", getting underlying from the swapper and trading for new shares)\n    if (params.amountIn > 0) {\n        IDestinationVault dvIn = IDestinationVault(params.destinationIn);\n\n        // get \"before\" counts\n        uint256 tokenInBalanceBefore = IERC20(params.tokenIn).balanceOf(address(this));\n\n        // Give control back to the solver so they can make use of the \"out\" assets\n        // and get our \"in\" asset\n        bytes32 flashResult = receiver.onFlashLoan(msg.sender, params.tokenIn, params.amountIn, 0, data);\n\n        // We assume the solver will send us the assets\n        uint256 tokenInBalanceAfter = IERC20(params.tokenIn).balanceOf(address(this));\n\n        // Make sure the call was successful and verify we have at least the assets we think\n        // we were getting\n        if (\n            flashResult != keccak256(\"ERC3156FlashBorrower.onFlashLoan\")\n                || tokenInBalanceAfter < tokenInBalanceBefore + params.amountIn\n        ) {\n            revert Errors.FlashLoanFailed(params.tokenIn, params.amountIn);\n        }\n\n        if (params.tokenIn != address(flashParams.baseAsset)) {\n            // @audit should be `tokenInBalanceAfter - tokenInBalanceBefore` given to `_handleRebalanceIn`\n            (uint256 debtDecreaseIn, uint256 debtIncreaseIn) =\n                _handleRebalanceIn(destInfoIn, dvIn, params.tokenIn, tokenInBalanceAfter);\n            idleDebtChange.debtDecrease += debtDecreaseIn;\n            idleDebtChange.debtIncrease += debtIncreaseIn;\n        } else {\n            idleDebtChange.idleIncrease += tokenInBalanceAfter - tokenInBalanceBefore;\n        }\n    }\n    ...\n}\n```\n\nAs we can see from the code above, the function executes a flashloan in order to receive th tokenIn amount which should be the difference between `tokenInBalanceAfter` (balance of the contract after the flashloan) and `tokenInBalanceBefore` (balance of the contract before the flashloan) : `tokenInBalanceAfter - tokenInBalanceBefore`.\n\nBut when calling the `_handleRebalanceIn` function the wrong deposit amount is given as input, as the total balance `tokenInBalanceAfter` is used instead of the received amount `tokenInBalanceAfter - tokenInBalanceBefore`.\n\nBecause the `_handleRebalanceIn` function is supposed to deposit the input amount to the destination vault, this error can result in sending a larger amount of funds to DV then what was intended or this error can cause a DOS of the `flashRebalance` function (due to the insufficient amount error when performing the transfer to DV), all of this will make the rebalance operation fail (or not done correctely) which can have a negative impact on the LMPVault.\n\n## Impact\n\nSee summary\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol#L185-L215\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the correct received tokenIn amount `tokenInBalanceAfter - tokenInBalanceBefore` as input to the `_handleRebalanceIn` function :\n\n```solidity\nfunction flashRebalance(\n    DestinationInfo storage destInfoOut,\n    DestinationInfo storage destInfoIn,\n    IERC3156FlashBorrower receiver,\n    IStrategy.RebalanceParams memory params,\n    FlashRebalanceParams memory flashParams,\n    bytes calldata data\n) external returns (uint256 idle, uint256 debt) {\n    ...\n\n    // Handle increase (shares coming \"In\", getting underlying from the swapper and trading for new shares)\n    if (params.amountIn > 0) {\n        IDestinationVault dvIn = IDestinationVault(params.destinationIn);\n\n        // get \"before\" counts\n        uint256 tokenInBalanceBefore = IERC20(params.tokenIn).balanceOf(address(this));\n\n        // Give control back to the solver so they can make use of the \"out\" assets\n        // and get our \"in\" asset\n        bytes32 flashResult = receiver.onFlashLoan(msg.sender, params.tokenIn, params.amountIn, 0, data);\n\n        // We assume the solver will send us the assets\n        uint256 tokenInBalanceAfter = IERC20(params.tokenIn).balanceOf(address(this));\n\n        // Make sure the call was successful and verify we have at least the assets we think\n        // we were getting\n        if (\n            flashResult != keccak256(\"ERC3156FlashBorrower.onFlashLoan\")\n                || tokenInBalanceAfter < tokenInBalanceBefore + params.amountIn\n        ) {\n            revert Errors.FlashLoanFailed(params.tokenIn, params.amountIn);\n        }\n\n        if (params.tokenIn != address(flashParams.baseAsset)) {\n            // @audit Use `tokenInBalanceAfter - tokenInBalanceBefore` as input\n            (uint256 debtDecreaseIn, uint256 debtIncreaseIn) =\n                _handleRebalanceIn(destInfoIn, dvIn, params.tokenIn, tokenInBalanceAfter - tokenInBalanceBefore);\n            idleDebtChange.debtDecrease += debtDecreaseIn;\n            idleDebtChange.debtIncrease += debtIncreaseIn;\n        } else {\n            idleDebtChange.idleIncrease += tokenInBalanceAfter - tokenInBalanceBefore;\n        }\n    }\n    ...\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Trumpero** commented:\n> \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { IDestinationVault } from \"src/interfaces/vault/IDestinationVault.sol\";\nimport { Math } from \"openzeppelin-contracts/utils/math/Math.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { IStrategy } from \"src/interfaces/strategy/IStrategy.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata as IERC20 } from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISystemRegistry, IDestinationVaultRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { IERC3156FlashBorrower } from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport { LMPStrategy } from \"src/strategy/LMPStrategy.sol\";\n\nlibrary LMPDebt {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    error VaultShutdown();\n    error WithdrawShareCalcInvalid(uint256 currentShares, uint256 cachedShares);\n    error RebalanceDestinationsMatch(address destinationVault);\n    error RebalanceFailed(string message);\n\n    struct DestinationInfo {\n        /// @notice Current underlying and reward value at the destination vault\n        /// @dev Used for calculating totalDebt of the LMPVault\n        uint256 currentDebt;\n        /// @notice Last block timestamp this info was updated\n        uint256 lastReport;\n        /// @notice How many shares of the destination vault we owned at last report\n        uint256 ownedShares;\n        /// @notice Amount of baseAsset transferred out in service of deployments\n        /// @dev Used for calculating 'in profit' or not during user withdrawals\n        uint256 debtBasis;\n    }\n\n    struct RebalanceOutParams {\n        /// Address that will received the withdrawn underlyer\n        address receiver;\n        /// The \"out\" destination vault\n        address destinationOut;\n        /// The amount of tokenOut that will be withdrawn\n        uint256 amountOut;\n        /// The underlyer for destinationOut\n        address tokenOut;\n        IERC20 _baseAsset;\n        bool _shutdown;\n    }\n\n    /// @dev In memory struct only for managing vars in rebalances\n    struct IdleDebtChange {\n        uint256 debtDecrease;\n        uint256 debtIncrease;\n        uint256 idleDecrease;\n        uint256 idleIncrease;\n    }\n\n    struct FlashRebalanceParams {\n        uint256 totalIdle;\n        uint256 totalDebt;\n        IERC20 baseAsset;\n        bool shutdown;\n    }\n\n    function rebalance(\n        DestinationInfo storage destInfoOut,\n        DestinationInfo storage destInfoIn,\n        IStrategy.RebalanceParams memory params,\n        IERC20 baseAsset,\n        bool shutdown,\n        uint256 totalIdle,\n        uint256 totalDebt\n    ) external returns (uint256 idle, uint256 debt) {\n        LMPDebt.IdleDebtChange memory idleDebtChange;\n\n        // make sure there's something to do\n        if (params.amountIn == 0 && params.amountOut == 0) {\n            revert Errors.InvalidParams();\n        }\n\n        if (params.destinationIn == params.destinationOut) {\n            revert RebalanceDestinationsMatch(params.destinationOut);\n        }\n\n        // make sure we have a valid path\n        {\n            (bool success, string memory message) = LMPStrategy.verifyRebalance(params);\n            if (!success) {\n                revert RebalanceFailed(message);\n            }\n        }\n\n        // Handle decrease (shares going \"Out\", cashing in shares and sending underlying back to swapper)\n        // If the tokenOut is _asset we assume they are taking idle\n        // which is already in the contract\n        idleDebtChange = _handleRebalanceOut(\n            LMPDebt.RebalanceOutParams({\n                receiver: msg.sender,\n                destinationOut: params.destinationOut,\n                amountOut: params.amountOut,\n                tokenOut: params.tokenOut,\n                _baseAsset: baseAsset,\n                _shutdown: shutdown\n            }),\n            destInfoOut\n        );\n\n        // Handle increase (shares coming \"In\", getting underlying from the swapper and trading for new shares)\n        if (params.amountIn > 0) {\n            // transfer dv underlying lp from swapper to here\n            IERC20(params.tokenIn).safeTransferFrom(msg.sender, address(this), params.amountIn);\n\n            // deposit to dv (already checked in `verifyRebalance` so no need to check return of deposit)\n\n            if (params.tokenIn != address(baseAsset)) {\n                IDestinationVault dvIn = IDestinationVault(params.destinationIn);\n                (uint256 debtDecreaseIn, uint256 debtIncreaseIn) =\n                    _handleRebalanceIn(destInfoIn, dvIn, params.tokenIn, params.amountIn);\n                idleDebtChange.debtDecrease += debtDecreaseIn;\n                idleDebtChange.debtIncrease += debtIncreaseIn;\n            } else {\n                idleDebtChange.idleIncrease += params.amountIn;\n            }\n        }\n\n        {\n            idle = totalIdle;\n            debt = totalDebt;\n\n            if (idleDebtChange.idleDecrease > 0 || idleDebtChange.idleIncrease > 0) {\n                idle = idle + idleDebtChange.idleIncrease - idleDebtChange.idleDecrease;\n            }\n\n            if (idleDebtChange.debtDecrease > 0 || idleDebtChange.debtIncrease > 0) {\n                debt = debt + idleDebtChange.debtIncrease - idleDebtChange.debtDecrease;\n            }\n        }\n    }\n\n    function flashRebalance(\n        DestinationInfo storage destInfoOut,\n        DestinationInfo storage destInfoIn,\n        IERC3156FlashBorrower receiver,\n        IStrategy.RebalanceParams memory params,\n        FlashRebalanceParams memory flashParams,\n        bytes calldata data\n    ) external returns (uint256 idle, uint256 debt) {\n        LMPDebt.IdleDebtChange memory idleDebtChange;\n\n        // make sure there's something to do\n        if (params.amountIn == 0 && params.amountOut == 0) {\n            revert Errors.InvalidParams();\n        }\n\n        if (params.destinationIn == params.destinationOut) {\n            revert RebalanceDestinationsMatch(params.destinationOut);\n        }\n\n        // make sure we have a valid path\n        {\n            (bool success, string memory message) = LMPStrategy.verifyRebalance(params);\n            if (!success) {\n                revert RebalanceFailed(message);\n            }\n        }\n\n        // Handle decrease (shares going \"Out\", cashing in shares and sending underlying back to swapper)\n        // If the tokenOut is _asset we assume they are taking idle\n        // which is already in the contract\n        idleDebtChange = _handleRebalanceOut(\n            LMPDebt.RebalanceOutParams({\n                receiver: address(receiver),\n                destinationOut: params.destinationOut,\n                amountOut: params.amountOut,\n                tokenOut: params.tokenOut,\n                _baseAsset: flashParams.baseAsset,\n                _shutdown: flashParams.shutdown\n            }),\n            destInfoOut\n        );\n\n        // Handle increase (shares coming \"In\", getting underlying from the swapper and trading for new shares)\n        if (params.amountIn > 0) {\n            IDestinationVault dvIn = IDestinationVault(params.destinationIn);\n\n            // get \"before\" counts\n            uint256 tokenInBalanceBefore = IERC20(params.tokenIn).balanceOf(address(this));\n\n            // Give control back to the solver so they can make use of the \"out\" assets\n            // and get our \"in\" asset\n            bytes32 flashResult = receiver.onFlashLoan(msg.sender, params.tokenIn, params.amountIn, 0, data);\n\n            // We assume the solver will send us the assets\n            uint256 tokenInBalanceAfter = IERC20(params.tokenIn).balanceOf(address(this));\n\n            // Make sure the call was successful and verify we have at least the assets we think\n            // we were getting\n            if (\n                flashResult != keccak256(\"ERC3156FlashBorrower.onFlashLoan\")\n                    || tokenInBalanceAfter < tokenInBalanceBefore + params.amountIn\n            ) {\n                revert Errors.FlashLoanFailed(params.tokenIn, params.amountIn);\n            }\n\n            if (params.tokenIn != address(flashParams.baseAsset)) {\n                (uint256 debtDecreaseIn, uint256 debtIncreaseIn) =\n                    _handleRebalanceIn(destInfoIn, dvIn, params.tokenIn, tokenInBalanceAfter);\n                idleDebtChange.debtDecrease += debtDecreaseIn;\n                idleDebtChange.debtIncrease += debtIncreaseIn;\n            } else {\n                idleDebtChange.idleIncrease += tokenInBalanceAfter - tokenInBalanceBefore;\n            }\n        }\n\n        {\n            idle = flashParams.totalIdle;\n            debt = flashParams.totalDebt;\n\n            if (idleDebtChange.idleDecrease > 0 || idleDebtChange.idleIncrease > 0) {\n                idle = idle + idleDebtChange.idleIncrease - idleDebtChange.idleDecrease;\n            }\n\n            if (idleDebtChange.debtDecrease > 0 || idleDebtChange.debtIncrease > 0) {\n                debt = debt + idleDebtChange.debtIncrease - idleDebtChange.debtDecrease;\n            }\n        }\n    }\n\n    function _calcUserWithdrawSharesToBurn(\n        DestinationInfo storage destInfo,\n        IDestinationVault destVault,\n        uint256 userShares,\n        uint256 maxAssetsToPull,\n        uint256 totalVaultShares\n    ) external returns (uint256 sharesToBurn, uint256 totalDebtBurn) {\n        // Figure out how many shares we can burn from the destination as well\n        // as what our totalDebt deduction should be (totalDebt being a cached value).\n        // If the destination vault is currently sitting at a profit, then the user can burn\n        // all the shares this vault owns. If its at a loss, they can only burn an amount\n        // proportional to their ownership of this vault. This is so a user doesn't lock in\n        // a loss for the entire vault during their withdrawal\n\n        uint256 currentDvShares = destVault.balanceOf(address(this));\n\n        // slither-disable-next-line incorrect-equality\n        if (currentDvShares == 0) {\n            return (0, 0);\n        }\n\n        // Calculate the current value of our shares\n        uint256 currentDvDebtValue = destVault.debtValue(currentDvShares);\n\n        // Get the basis for the current deployment\n        uint256 cachedDebtBasis = destInfo.debtBasis;\n\n        // The amount of shares we had at the last debt reporting\n        uint256 cachedDvShares = destInfo.ownedShares;\n\n        // The value of our debt + earned rewards at last debt reporting\n        uint256 cachedCurrentDebt = destInfo.currentDebt;\n\n        // Our current share balance should only ever be lte the last snapshot\n        // Any update to the deployment should update the snapshot and withdrawals\n        // can only lower it\n        if (currentDvShares > cachedDvShares) {\n            revert WithdrawShareCalcInvalid(currentDvShares, cachedDvShares);\n        }\n\n        // Recalculated what the debtBasis is with the current number of shares\n        uint256 updatedDebtBasis = cachedDebtBasis.mulDiv(currentDvShares, cachedDvShares, Math.Rounding.Up);\n\n        // Neither of these numbers include rewards from the DV\n        if (currentDvDebtValue < updatedDebtBasis) {\n            // We are currently sitting at a loss. Limit the value we can pull from\n            // the destination vault\n            currentDvDebtValue = currentDvDebtValue.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n            currentDvShares = currentDvShares.mulDiv(userShares, totalVaultShares, Math.Rounding.Down);\n        }\n\n        // Shouldn't pull more than we want\n        // Or, we're not in profit so we limit the pull\n        if (currentDvDebtValue < maxAssetsToPull) {\n            maxAssetsToPull = currentDvDebtValue;\n        }\n\n        // Calculate the portion of shares to burn based on the assets we need to pull\n        // and the current total debt value. These are destination vault shares.\n        sharesToBurn = currentDvShares.mulDiv(maxAssetsToPull, currentDvDebtValue, Math.Rounding.Up);\n\n        // This is what will be deducted from totalDebt with the withdrawal. The totalDebt number\n        // is calculated based on the cached values so we need to be sure to reduce it\n        // proportional to the original cached debt value\n        totalDebtBurn = cachedCurrentDebt.mulDiv(sharesToBurn, cachedDvShares, Math.Rounding.Up);\n    }\n\n    /// @notice Perform deposit and debt info update for the \"in\" destination during a rebalance\n    /// @dev This \"in\" function performs less validations than its \"out\" version\n    /// @param dvIn The \"in\" destination vault\n    /// @param tokenIn The underlyer for dvIn\n    /// @param depositAmount The amount of tokenIn that will be deposited\n    /// @return debtDecrease The previous amount of debt dvIn accounted for in totalDebt\n    /// @return debtIncrease The current amount of debt dvIn should account for in totalDebt\n    function handleRebalanceIn(\n        DestinationInfo storage destInfo,\n        IDestinationVault dvIn,\n        address tokenIn,\n        uint256 depositAmount\n    ) external returns (uint256 debtDecrease, uint256 debtIncrease) {\n        (debtDecrease, debtIncrease) = _handleRebalanceIn(destInfo, dvIn, tokenIn, depositAmount);\n    }\n\n    /// @notice Perform deposit and debt info update for the \"in\" destination during a rebalance\n    /// @dev This \"in\" function performs less validations than its \"out\" version\n    /// @param dvIn The \"in\" destination vault\n    /// @param tokenIn The underlyer for dvIn\n    /// @param depositAmount The amount of tokenIn that will be deposited\n    /// @return debtDecrease The previous amount of debt dvIn accounted for in totalDebt\n    /// @return debtIncrease The current amount of debt dvIn should account for in totalDebt\n    function _handleRebalanceIn(\n        DestinationInfo storage destInfo,\n        IDestinationVault dvIn,\n        address tokenIn,\n        uint256 depositAmount\n    ) private returns (uint256 debtDecrease, uint256 debtIncrease) {\n        IERC20(tokenIn).safeApprove(address(dvIn), depositAmount);\n\n        // Snapshot our current shares so we know how much to back out\n        uint256 originalShareBal = dvIn.balanceOf(address(this));\n\n        // deposit to dv\n        uint256 newShares = dvIn.depositUnderlying(depositAmount);\n\n        // Update the debt info snapshot\n        (debtDecrease, debtIncrease) =\n            _recalculateDestInfo(destInfo, dvIn, originalShareBal, originalShareBal + newShares, true);\n    }\n\n    /**\n     * @notice Perform withdraw and debt info update for the \"out\" destination during a rebalance\n     * @dev This \"out\" function performs more validations and handles idle as opposed to \"in\" which does not\n     *  debtDecrease The previous amount of debt destinationOut accounted for in totalDebt\n     *  debtIncrease The current amount of debt destinationOut should account for in totalDebt\n     *  idleDecrease Amount of baseAsset that was sent from the vault. > 0 only when tokenOut == baseAsset\n     *  idleIncrease Amount of baseAsset that was claimed from Destination Vault\n     * @param params Rebalance out params\n     * @param destOutInfo The \"out\" destination vault info\n     * @return assetChange debt and idle change data\n     */\n    function handleRebalanceOut(\n        RebalanceOutParams memory params,\n        DestinationInfo storage destOutInfo\n    ) external returns (IdleDebtChange memory assetChange) {\n        (assetChange) = _handleRebalanceOut(params, destOutInfo);\n    }\n\n    /**\n     * @notice Perform withdraw and debt info update for the \"out\" destination during a rebalance\n     * @dev This \"out\" function performs more validations and handles idle as opposed to \"in\" which does not\n     *  debtDecrease The previous amount of debt destinationOut accounted for in totalDebt\n     *  debtIncrease The current amount of debt destinationOut should account for in totalDebt\n     *  idleDecrease Amount of baseAsset that was sent from the vault. > 0 only when tokenOut == baseAsset\n     *  idleIncrease Amount of baseAsset that was claimed from Destination Vault\n     * @param params Rebalance out params\n     * @param destOutInfo The \"out\" destination vault info\n     * @return assetChange debt and idle change data\n     */\n    function _handleRebalanceOut(\n        RebalanceOutParams memory params,\n        DestinationInfo storage destOutInfo\n    ) private returns (IdleDebtChange memory assetChange) {\n        // Handle decrease (shares going \"Out\", cashing in shares and sending underlying back to swapper)\n        // If the tokenOut is _asset we assume they are taking idle\n        // which is already in the contract\n        if (params.amountOut > 0) {\n            if (params.tokenOut != address(params._baseAsset)) {\n                IDestinationVault dvOut = IDestinationVault(params.destinationOut);\n\n                // Snapshot our current shares so we know how much to back out\n                uint256 originalShareBal = dvOut.balanceOf(address(this));\n\n                // Burning our shares will claim any pending baseAsset\n                // rewards and send them to us. Make sure we capture them\n                // so they can end up in idle\n                uint256 beforeBaseAssetBal = params._baseAsset.balanceOf(address(this));\n\n                // withdraw underlying from dv\n                // slither-disable-next-line unused-return\n                dvOut.withdrawUnderlying(params.amountOut, params.receiver);\n\n                assetChange.idleIncrease = params._baseAsset.balanceOf(address(this)) - beforeBaseAssetBal;\n\n                // Update the debt info snapshot\n                (assetChange.debtDecrease, assetChange.debtIncrease) = _recalculateDestInfo(\n                    destOutInfo, dvOut, originalShareBal, originalShareBal - params.amountOut, true\n                );\n            } else {\n                // If we are shutdown then the only operations we should be performing are those that get\n                // the base asset back to the vault. We shouldn't be sending out more\n                if (params._shutdown) {\n                    revert VaultShutdown();\n                }\n                // Working with idle baseAsset which should be in the vault already\n                // Just send it out\n                IERC20(params.tokenOut).safeTransfer(params.receiver, params.amountOut);\n                assetChange.idleDecrease = params.amountOut;\n            }\n        }\n    }\n\n    function recalculateDestInfo(\n        DestinationInfo storage destInfo,\n        IDestinationVault destVault,\n        uint256 originalShares,\n        uint256 currentShares,\n        bool resetDebtBasis\n    ) external returns (uint256 totalDebtDecrease, uint256 totalDebtIncrease) {\n        (totalDebtDecrease, totalDebtIncrease) =\n            _recalculateDestInfo(destInfo, destVault, originalShares, currentShares, resetDebtBasis);\n    }\n\n    function _recalculateDestInfo(\n        DestinationInfo storage destInfo,\n        IDestinationVault destVault,\n        uint256 originalShares,\n        uint256 currentShares,\n        bool resetDebtBasis\n    ) private returns (uint256 totalDebtDecrease, uint256 totalDebtIncrease) {\n        // Figure out what to back out of our totalDebt number.\n        // We could have had withdraws since the last snapshot which means our\n        // cached currentDebt number should be decreased based on the remaining shares\n        // totalDebt is decreased using the same proportion of shares method during withdrawals\n        // so this should represent whatever is remaining.\n\n        // Figure out how much our debt is currently worth\n        uint256 dvDebtValue = destVault.debtValue(currentShares);\n\n        // Calculate what we're backing out based on the original shares\n        uint256 currentDebt = (destInfo.currentDebt * originalShares) / Math.max(destInfo.ownedShares, 1);\n        destInfo.currentDebt = dvDebtValue;\n        destInfo.lastReport = block.timestamp;\n        destInfo.ownedShares = currentShares;\n        if (resetDebtBasis) {\n            destInfo.debtBasis = dvDebtValue;\n        }\n\n        totalDebtDecrease = currentDebt;\n        totalDebtIncrease = dvDebtValue;\n    }\n}"
    }
  ]
}