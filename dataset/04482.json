{
  "Title": "Malicious AutoTrader contracts may steal funds",
  "Content": "The Solo contract allows a user to [set any contract as their](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/impl/OperationImpl.sol#L541) [`AutoTrader`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/impl/OperationImpl.sol#L541). If a user makes a trade with an attacker using a malicious [`AutoTrader`](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/interfaces/IAutoTrader.sol), the attacker may front-run the trade with a transaction that changes the rate returned by the `AutoTrader`‘s `getTradeCost()` effectively allowing the attacker to steal the full amount of the trade.\n\n\nThis can be prevented by only allowing users to interact with approved `AutoTrader` contracts on the front-end. However, it would be best to prevent this attack on-chain rather than relying on off-chain protections.\n\n\nConsider adding a whitelist of `AutoTrader` contracts or `AutoTrader` factories to restrict the possible implementations on-chain.\n\n\n*Note: This issue was downgraded from critical severity because the dYdX team is aware of the issue and has plans for off-chain mitigation.*\n\n\n***Update:*** *Statement from the dYdX team about this issue: “By using the* *`TradeData`* *field,**`AutoTrader`* *contracts can be written so that they do not suffer from any of the security issues mentioned (front running or otherwise). The* *`ExchangeWrapper`* *contracts that we have been using in production for months are secured in this manner.  \n\nAs with all smart contracts, users should only use contracts that they trust; it is clearly unsafe to use any arbitrary address for an* *AutoTrader**. Passing in the address of an**`AutoTrader`* *is not less secure than specifying any other data in an Ethereum transaction. An on-chain whitelist of* *`AutoTraders`* *would not prevent malformed or malicious transaction data from producing unintended results.”*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/impl/OperationImpl.sol",
      "content": "/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.4;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport { IAutoTrader } from \"../interfaces/IAutoTrader.sol\";\nimport { ICallee } from \"../interfaces/ICallee.sol\";\nimport { Account } from \"../lib/Account.sol\";\nimport { Actions } from \"../lib/Actions.sol\";\nimport { Cache } from \"../lib/Cache.sol\";\nimport { Decimal } from \"../lib/Decimal.sol\";\nimport { Events } from \"../lib/Events.sol\";\nimport { Exchange } from \"../lib/Exchange.sol\";\nimport { Math } from \"../lib/Math.sol\";\nimport { Monetary } from \"../lib/Monetary.sol\";\nimport { Require } from \"../lib/Require.sol\";\nimport { Storage } from \"../lib/Storage.sol\";\nimport { Types } from \"../lib/Types.sol\";\n\n\n/**\n * @title OperationImpl\n * @author dYdX\n *\n * Logic for processing actions\n */\nlibrary OperationImpl {\n    using Cache for Cache.MarketCache;\n    using Decimal for uint256;\n    using SafeMath for uint256;\n    using Storage for Storage.State;\n    using Types for Types.Par;\n    using Types for Types.Wei;\n\n    // ============ Constants ============\n\n    bytes32 constant FILE = \"OperationImpl\";\n\n    // ============ Public Functions ============\n\n    function operate(\n        Storage.State storage state,\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions\n    )\n        public\n    {\n        Events.logOperation();\n\n        _verifyInputs(accounts, actions);\n\n        (\n            bool[] memory primaryAccounts,\n            Cache.MarketCache memory cache\n        ) = _runPreprocessing(\n            state,\n            accounts,\n            actions\n        );\n\n        _runActions(\n            state,\n            accounts,\n            actions,\n            cache\n        );\n\n        _verifyFinalState(\n            state,\n            accounts,\n            primaryAccounts,\n            cache\n        );\n    }\n\n    // ============ Helper Functions ============\n\n    function _verifyInputs(\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions\n    )\n        private\n        pure\n    {\n        Require.that(\n            actions.length != 0,\n            FILE,\n            \"Cannot have zero actions\"\n        );\n\n        Require.that(\n            accounts.length != 0,\n            FILE,\n            \"Cannot have zero accounts\"\n        );\n\n        for (uint256 a = 0; a < accounts.length; a++) {\n            for (uint256 b = a + 1; b < accounts.length; b++) {\n                Require.that(\n                    !Account.equals(accounts[a], accounts[b]),\n                    FILE,\n                    \"Cannot duplicate accounts\",\n                    a,\n                    b\n                );\n            }\n        }\n    }\n\n    function _runPreprocessing(\n        Storage.State storage state,\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions\n    )\n        private\n        returns (\n            bool[] memory,\n            Cache.MarketCache memory\n        )\n    {\n        uint256 numMarkets = state.numMarkets;\n        bool[] memory primaryAccounts = new bool[](accounts.length);\n        Cache.MarketCache memory cache = Cache.create(numMarkets);\n\n        // keep track of primary accounts and indexes that need updating\n        for (uint256 i = 0; i < actions.length; i++) {\n            Actions.ActionArgs memory arg = actions[i];\n            Actions.ActionType ttype = arg.actionType;\n            Actions.MarketLayout marketLayout = Actions.getMarketLayout(ttype);\n            Actions.AccountLayout accountLayout = Actions.getAccountLayout(ttype);\n\n            // parse out primary accounts\n            if (accountLayout != Actions.AccountLayout.OnePrimary) {\n                Require.that(\n                    arg.accountId != arg.otherAccountId,\n                    FILE,\n                    \"Accounts must be distinct\"\n                );\n                if (accountLayout == Actions.AccountLayout.TwoPrimary) {\n                    primaryAccounts[arg.otherAccountId] = true;\n                } else {\n                    assert(accountLayout == Actions.AccountLayout.PrimaryAndSecondary);\n                    Require.that(\n                        !primaryAccounts[arg.otherAccountId],\n                        FILE,\n                        \"Requires non-primary account\",\n                        arg.otherAccountId\n                    );\n                }\n            }\n            primaryAccounts[arg.accountId] = true;\n\n            // keep track of indexes to update\n            if (marketLayout == Actions.MarketLayout.OneMarket) {\n                _updateMarket(state, cache, arg.primaryMarketId);\n            } else if (marketLayout == Actions.MarketLayout.TwoMarkets) {\n                Require.that(\n                    arg.primaryMarketId != arg.secondaryMarketId,\n                    FILE,\n                    \"Markets must be distinct\"\n                );\n                _updateMarket(state, cache, arg.primaryMarketId);\n                _updateMarket(state, cache, arg.secondaryMarketId);\n            } else {\n                assert(marketLayout == Actions.MarketLayout.ZeroMarkets);\n            }\n        }\n\n        // get any other markets for which an account has a balance\n        for (uint256 m = 0; m < numMarkets; m++) {\n            if (cache.hasMarket(m)) {\n                continue;\n            }\n            for (uint256 a = 0; a < accounts.length; a++) {\n                if (!state.getPar(accounts[a], m).isZero()) {\n                    _updateMarket(state, cache, m);\n                    break;\n                }\n            }\n        }\n\n        return (primaryAccounts, cache);\n    }\n\n    function _updateMarket(\n        Storage.State storage state,\n        Cache.MarketCache memory cache,\n        uint256 marketId\n    )\n        private\n    {\n        bool updated = cache.addMarket(state, marketId);\n        if (updated) {\n            Events.logIndexUpdate(marketId, state.updateIndex(marketId));\n        }\n    }\n\n    function _runActions(\n        Storage.State storage state,\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions,\n        Cache.MarketCache memory cache\n    )\n        private\n    {\n        for (uint256 i = 0; i < actions.length; i++) {\n            Actions.ActionArgs memory arg = actions[i];\n            Actions.ActionType ttype = arg.actionType;\n\n            if (ttype == Actions.ActionType.Deposit) {\n                _deposit(state, Actions.parseDepositArgs(accounts, arg));\n            }\n            else if (ttype == Actions.ActionType.Withdraw) {\n                _withdraw(state, Actions.parseWithdrawArgs(accounts, arg));\n            }\n            else if (ttype == Actions.ActionType.Transfer) {\n                _transfer(state, Actions.parseTransferArgs(accounts, arg));\n            }\n            else if (ttype == Actions.ActionType.Buy) {\n                _buy(state, Actions.parseBuyArgs(accounts, arg));\n            }\n            else if (ttype == Actions.ActionType.Sell) {\n                _sell(state, Actions.parseSellArgs(accounts, arg));\n            }\n            else if (ttype == Actions.ActionType.Trade) {\n                _trade(state, Actions.parseTradeArgs(accounts, arg));\n            }\n            else if (ttype == Actions.ActionType.Liquidate) {\n                _liquidate(state, Actions.parseLiquidateArgs(accounts, arg), cache);\n            }\n            else if (ttype == Actions.ActionType.Vaporize) {\n                _vaporize(state, Actions.parseVaporizeArgs(accounts, arg), cache);\n            }\n            else  {\n                assert(ttype == Actions.ActionType.Call);\n                _call(state, Actions.parseCallArgs(accounts, arg));\n            }\n        }\n    }\n\n    function _verifyFinalState(\n        Storage.State storage state,\n        Account.Info[] memory accounts,\n        bool[] memory primaryAccounts,\n        Cache.MarketCache memory cache\n    )\n        private\n    {\n        // verify no increase in borrowPar for closing markets\n        uint256 numMarkets = cache.getNumMarkets();\n        for (uint256 m = 0; m < numMarkets; m++) {\n            if (cache.getIsClosing(m)) {\n                Require.that(\n                    state.getTotalPar(m).borrow <= cache.getBorrowPar(m),\n                    FILE,\n                    \"Market is closing\",\n                    m\n                );\n            }\n        }\n\n        // verify account collateralization\n        for (uint256 a = 0; a < accounts.length; a++) {\n            Account.Info memory account = accounts[a];\n\n            // validate minBorrowedValue\n            bool collateralized = state.isCollateralized(account, cache, true);\n\n            // don't check collateralization for non-primary accounts\n            if (!primaryAccounts[a]) {\n                continue;\n            }\n\n            // check collateralization for primary accounts\n            Require.that(\n                collateralized,\n                FILE,\n                \"Undercollateralized account\",\n                a\n            );\n\n            // ensure status is normal for primary accounts\n            if (state.getStatus(account) != Account.Status.Normal) {\n                state.setStatus(account, Account.Status.Normal);\n            }\n        }\n    }\n\n    // ============ Action Functions ============\n\n    function _deposit(\n        Storage.State storage state,\n        Actions.DepositArgs memory args\n    )\n        private\n    {\n        state.requireIsOperator(args.account, msg.sender);\n\n        Require.that(\n            args.from == msg.sender || args.from == args.account.owner,\n            FILE,\n            \"Invalid deposit source\"\n        );\n\n        (\n            Types.Par memory newPar,\n            Types.Wei memory deltaWei\n        ) = state.getNewParAndDeltaWei(\n            args.account,\n            args.market,\n            args.amount\n        );\n\n        state.setPar(\n            args.account,\n            args.market,\n            newPar\n        );\n\n        // requires a positive deltaWei\n        Exchange.transferIn(\n            state.getToken(args.market),\n            args.from,\n            deltaWei\n        );\n\n        Events.logDeposit(\n            state,\n            args,\n            deltaWei\n        );\n    }\n\n    function _withdraw(\n        Storage.State storage state,\n        Actions.WithdrawArgs memory args\n    )\n        private\n    {\n        state.requireIsOperator(args.account, msg.sender);\n\n        (\n            Types.Par memory newPar,\n            Types.Wei memory deltaWei\n        ) = state.getNewParAndDeltaWei(\n            args.account,\n            args.market,\n            args.amount\n        );\n\n        state.setPar(\n            args.account,\n            args.market,\n            newPar\n        );\n\n        // requires a negative deltaWei\n        Exchange.transferOut(\n            state.getToken(args.market),\n            args.to,\n            deltaWei\n        );\n\n        Events.logWithdraw(\n            state,\n            args,\n            deltaWei\n        );\n    }\n\n    function _transfer(\n        Storage.State storage state,\n        Actions.TransferArgs memory args\n    )\n        private\n    {\n        state.requireIsOperator(args.accountOne, msg.sender);\n        state.requireIsOperator(args.accountTwo, msg.sender);\n\n        (\n            Types.Par memory newPar,\n            Types.Wei memory deltaWei\n        ) = state.getNewParAndDeltaWei(\n            args.accountOne,\n            args.market,\n            args.amount\n        );\n\n        state.setPar(\n            args.accountOne,\n            args.market,\n            newPar\n        );\n\n        state.setParFromDeltaWei(\n            args.accountTwo,\n            args.market,\n            deltaWei.negative()\n        );\n\n        Events.logTransfer(\n            state,\n            args,\n            deltaWei\n        );\n    }\n\n    function _buy(\n        Storage.State storage state,\n        Actions.BuyArgs memory args\n    )\n        private\n    {\n        state.requireIsOperator(args.account, msg.sender);\n\n        address takerToken = state.getToken(args.takerMarket);\n        address makerToken = state.getToken(args.makerMarket);\n\n        (\n            Types.Par memory makerPar,\n            Types.Wei memory makerWei\n        ) = state.getNewParAndDeltaWei(\n            args.account,\n            args.makerMarket,\n            args.amount\n        );\n\n        Types.Wei memory takerWei = Exchange.getCost(\n            args.exchangeWrapper,\n            makerToken,\n            takerToken,\n            makerWei,\n            args.orderData\n        );\n\n        Types.Wei memory tokensReceived = Exchange.exchange(\n            args.exchangeWrapper,\n            args.account.owner,\n            makerToken,\n            takerToken,\n            takerWei,\n            args.orderData\n        );\n\n        Require.that(\n            tokensReceived.value >= makerWei.value,\n            FILE,\n            \"Buy amount less than promised\",\n            tokensReceived.value,\n            makerWei.value\n        );\n\n        state.setPar(\n            args.account,\n            args.makerMarket,\n            makerPar\n        );\n\n        state.setParFromDeltaWei(\n            args.account,\n            args.takerMarket,\n            takerWei\n        );\n\n        Events.logBuy(\n            state,\n            args,\n            takerWei,\n            makerWei\n        );\n    }\n\n    function _sell(\n        Storage.State storage state,\n        Actions.SellArgs memory args\n    )\n        private\n    {\n        state.requireIsOperator(args.account, msg.sender);\n\n        address takerToken = state.getToken(args.takerMarket);\n        address makerToken = state.getToken(args.makerMarket);\n\n        (\n            Types.Par memory takerPar,\n            Types.Wei memory takerWei\n        ) = state.getNewParAndDeltaWei(\n            args.account,\n            args.takerMarket,\n            args.amount\n        );\n\n        Types.Wei memory makerWei = Exchange.exchange(\n            args.exchangeWrapper,\n            args.account.owner,\n            makerToken,\n            takerToken,\n            takerWei,\n            args.orderData\n        );\n\n        state.setPar(\n            args.account,\n            args.takerMarket,\n            takerPar\n        );\n\n        state.setParFromDeltaWei(\n            args.account,\n            args.makerMarket,\n            makerWei\n        );\n\n        Events.logSell(\n            state,\n            args,\n            takerWei,\n            makerWei\n        );\n    }\n\n    function _trade(\n        Storage.State storage state,\n        Actions.TradeArgs memory args\n    )\n        private\n    {\n        state.requireIsOperator(args.takerAccount, msg.sender);\n        state.requireIsOperator(args.makerAccount, args.autoTrader);\n\n        Types.Par memory oldInputPar = state.getPar(\n            args.makerAccount,\n            args.inputMarket\n        );\n        (\n            Types.Par memory newInputPar,\n            Types.Wei memory inputWei\n        ) = state.getNewParAndDeltaWei(\n            args.makerAccount,\n            args.inputMarket,\n            args.amount\n        );\n\n        Types.AssetAmount memory outputAmount = IAutoTrader(args.autoTrader).getTradeCost(\n            args.inputMarket,\n            args.outputMarket,\n            args.makerAccount,\n            args.takerAccount,\n            oldInputPar,\n            newInputPar,\n            inputWei,\n            args.tradeData\n        );\n\n        (\n            Types.Par memory newOutputPar,\n            Types.Wei memory outputWei\n        ) = state.getNewParAndDeltaWei(\n            args.makerAccount,\n            args.outputMarket,\n            outputAmount\n        );\n\n        Require.that(\n            outputWei.isZero() || inputWei.isZero() || outputWei.sign != inputWei.sign,\n            FILE,\n            \"Trades cannot be one-sided\"\n        );\n\n        // set the balance for the maker\n        state.setPar(\n            args.makerAccount,\n            args.inputMarket,\n            newInputPar\n        );\n        state.setPar(\n            args.makerAccount,\n            args.outputMarket,\n            newOutputPar\n        );\n\n        // set the balance for the taker\n        state.setParFromDeltaWei(\n            args.takerAccount,\n            args.inputMarket,\n            inputWei.negative()\n        );\n        state.setParFromDeltaWei(\n            args.takerAccount,\n            args.outputMarket,\n            outputWei.negative()\n        );\n\n        Events.logTrade(\n            state,\n            args,\n            inputWei,\n            outputWei\n        );\n    }\n\n    function _liquidate(\n        Storage.State storage state,\n        Actions.LiquidateArgs memory args,\n        Cache.MarketCache memory cache\n    )\n        private\n    {\n        state.requireIsOperator(args.solidAccount, msg.sender);\n\n        // verify liquidatable\n        if (Account.Status.Liquid != state.getStatus(args.liquidAccount)) {\n            Require.that(\n                !state.isCollateralized(args.liquidAccount, cache, false),\n                FILE,\n                \"Unliquidatable account\"\n            );\n            state.setStatus(args.liquidAccount, Account.Status.Liquid);\n        }\n\n        Types.Wei memory maxHeldWei = state.getWei(\n            args.liquidAccount,\n            args.heldMarket\n        );\n\n        Require.that(\n            !maxHeldWei.isNegative(),\n            FILE,\n            \"Collateral cannot be negative\",\n            maxHeldWei.value\n        );\n\n        (\n            Types.Par memory owedPar,\n            Types.Wei memory owedWei\n        ) = state.getNewParAndDeltaWeiForLiquidation(\n            args.liquidAccount,\n            args.owedMarket,\n            args.amount\n        );\n\n        (\n            Monetary.Price memory heldPrice,\n            Monetary.Price memory owedPrice\n        ) = _getLiquidationPrices(\n            state,\n            cache,\n            args.heldMarket,\n            args.owedMarket\n        );\n\n        Types.Wei memory heldWei = _owedWeiToHeldWei(owedWei, heldPrice, owedPrice);\n\n        // if attempting to over-borrow the held asset, bound it by the maximum\n        if (heldWei.value > maxHeldWei.value) {\n            heldWei = maxHeldWei.negative();\n            owedWei = _heldWeiToOwedWei(heldWei, heldPrice, owedPrice);\n\n            state.setPar(\n                args.liquidAccount,\n                args.heldMarket,\n                Types.zeroPar()\n            );\n            state.setParFromDeltaWei(\n                args.liquidAccount,\n                args.owedMarket,\n                owedWei\n            );\n        } else {\n            state.setPar(\n                args.liquidAccount,\n                args.owedMarket,\n                owedPar\n            );\n            state.setParFromDeltaWei(\n                args.liquidAccount,\n                args.heldMarket,\n                heldWei\n            );\n        }\n\n        // set the balances for the solid account\n        state.setParFromDeltaWei(\n            args.solidAccount,\n            args.owedMarket,\n            owedWei.negative()\n        );\n        state.setParFromDeltaWei(\n            args.solidAccount,\n            args.heldMarket,\n            heldWei.negative()\n        );\n\n        Events.logLiquidate(\n            state,\n            args,\n            heldWei,\n            owedWei\n        );\n    }\n\n    function _vaporize(\n        Storage.State storage state,\n        Actions.VaporizeArgs memory args,\n        Cache.MarketCache memory cache\n    )\n        private\n    {\n        state.requireIsOperator(args.solidAccount, msg.sender);\n\n        // verify vaporizable\n        if (Account.Status.Vapor != state.getStatus(args.vaporAccount)) {\n            Require.that(\n                state.isVaporizable(args.vaporAccount, cache),\n                FILE,\n                \"Unvaporizable account\"\n            );\n            state.setStatus(args.vaporAccount, Account.Status.Vapor);\n        }\n\n        // First, attempt to refund using the same token\n        (\n            bool fullyRepaid,\n            Types.Wei memory excessWei\n        ) = _vaporizeUsingExcess(state, args);\n        if (fullyRepaid) {\n            Events.logVaporize(\n                state,\n                args,\n                Types.zeroWei(),\n                Types.zeroWei(),\n                excessWei\n            );\n            return;\n        }\n\n        Types.Wei memory maxHeldWei = state.getNumExcessTokens(args.heldMarket);\n\n        Require.that(\n            !maxHeldWei.isNegative(),\n            FILE,\n            \"Excess cannot be negative\",\n            maxHeldWei.value\n        );\n\n        (\n            Types.Par memory owedPar,\n            Types.Wei memory owedWei\n        ) = state.getNewParAndDeltaWeiForLiquidation(\n            args.vaporAccount,\n            args.owedMarket,\n            args.amount\n        );\n\n        (\n            Monetary.Price memory heldPrice,\n            Monetary.Price memory owedPrice\n        ) = _getLiquidationPrices(\n            state,\n            cache,\n            args.heldMarket,\n            args.owedMarket\n        );\n\n        Types.Wei memory heldWei = _owedWeiToHeldWei(owedWei, heldPrice, owedPrice);\n\n        // if attempting to over-borrow the held asset, bound it by the maximum\n        if (heldWei.value > maxHeldWei.value) {\n            heldWei = maxHeldWei.negative();\n            owedWei = _heldWeiToOwedWei(heldWei, heldPrice, owedPrice);\n\n            state.setParFromDeltaWei(\n                args.vaporAccount,\n                args.owedMarket,\n                owedWei\n            );\n        } else {\n            state.setPar(\n                args.vaporAccount,\n                args.owedMarket,\n                owedPar\n            );\n        }\n\n        // set the balances for the solid account\n        state.setParFromDeltaWei(\n            args.solidAccount,\n            args.owedMarket,\n            owedWei.negative()\n        );\n        state.setParFromDeltaWei(\n            args.solidAccount,\n            args.heldMarket,\n            heldWei.negative()\n        );\n\n        Events.logVaporize(\n            state,\n            args,\n            heldWei,\n            owedWei,\n            excessWei\n        );\n    }\n\n    function _call(\n        Storage.State storage state,\n        Actions.CallArgs memory args\n    )\n        private\n    {\n        state.requireIsOperator(args.account, msg.sender);\n\n        ICallee(args.callee).callFunction(\n            msg.sender,\n            args.account,\n            args.data\n        );\n\n        Events.logCall(args);\n    }\n\n    // ============ Private Functions ============\n\n    function _owedWeiToHeldWei(\n        Types.Wei memory owedWei,\n        Monetary.Price memory heldPrice,\n        Monetary.Price memory owedPrice\n    )\n        private\n        pure\n        returns (Types.Wei memory)\n    {\n        return Types.Wei({\n            sign: false,\n            value: Math.getPartial(owedWei.value, owedPrice.value, heldPrice.value)\n        });\n    }\n\n    function _heldWeiToOwedWei(\n        Types.Wei memory heldWei,\n        Monetary.Price memory heldPrice,\n        Monetary.Price memory owedPrice\n    )\n        private\n        pure\n        returns (Types.Wei memory)\n    {\n        return Types.Wei({\n            sign: true,\n            value: Math.getPartialRoundUp(heldWei.value, heldPrice.value, owedPrice.value)\n        });\n    }\n\n    function _vaporizeUsingExcess(\n        Storage.State storage state,\n        Actions.VaporizeArgs memory args\n    )\n        internal\n        returns (bool, Types.Wei memory)\n    {\n        Types.Wei memory excessWei = state.getNumExcessTokens(args.owedMarket);\n\n        if (!excessWei.isPositive()) {\n            return (false, Types.zeroWei());\n        }\n\n        Types.Wei memory maxRefundWei = state.getWei(args.vaporAccount, args.owedMarket);\n        maxRefundWei.sign = true;\n\n        if (excessWei.value >= maxRefundWei.value) {\n            state.setPar(\n                args.vaporAccount,\n                args.owedMarket,\n                Types.zeroPar()\n            );\n            return (true, maxRefundWei);\n        } else {\n            state.setParFromDeltaWei(\n                args.vaporAccount,\n                args.owedMarket,\n                excessWei\n            );\n            return (false, excessWei);\n        }\n    }\n\n    function _getLiquidationPrices(\n        Storage.State storage state,\n        Cache.MarketCache memory cache,\n        uint256 heldMarketId,\n        uint256 owedMarketId\n    )\n        internal\n        view\n        returns (\n            Monetary.Price memory,\n            Monetary.Price memory\n        )\n    {\n        uint256 originalPrice = cache.getPrice(owedMarketId).value;\n        Decimal.D256 memory heldPremium =\n            Decimal.add(Decimal.one(), state.markets[heldMarketId].spreadPremium);\n        Decimal.D256 memory owedPremium =\n            Decimal.add(Decimal.one(), state.markets[owedMarketId].spreadPremium);\n        uint256 adjustedSpread =\n            originalPrice.mul(state.riskParams.liquidationSpread).mul(heldPremium).mul(owedPremium);\n\n        Monetary.Price memory owedPrice = Monetary.Price({\n            value: originalPrice.add(adjustedSpread)\n        });\n\n        return (cache.getPrice(heldMarketId), owedPrice);\n    }\n}"
    }
  ]
}