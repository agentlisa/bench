{
  "Title": "BridgeRouterFacet::withdraw() and unstake() can revert when amount * TVL > uint88 because of PRBMathHelper::mulU88",
  "Content": "# BridgeRouterFacet::withdraw() and unstake() can revert when amount * TVL > uint88 because of PRBMathHelper::mulU88\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BridgeRouterFacet.sol#L110\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BridgeRouterFacet.sol#L110</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BridgeRouterFacet.sol#L136\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BridgeRouterFacet.sol#L136</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BridgeRouterFacet.sol#L184\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BridgeRouterFacet.sol#L184</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/PRBMathHelper.sol#L102\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/PRBMathHelper.sol#L102</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"\"></a>\n\n\n## Summary\n\nWhen the protocol will be well established, there might be user wanting to withdraw substantial amount of ETH, but the call will revert because of an overflow that shouldn't happen.\n\n## Vulnerability Details\n\nIn [`withdraw()`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BridgeRouterFacet.sol#L110) or [`unstakeEth()`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BridgeRouterFacet.sol#L136), the amount that the user want to get is converted from the LSD to ETH by calling the function [`_ethConversion(...)`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BridgeRouterFacet.sol#L184) :\n\n```solidity\n    function _ethConversion(uint256 vault, uint88 amount) private view returns (uint88) {\n        uint256 zethTotalNew = vault.getZethTotal();\n        uint88 zethTotal = s.vault[vault].zethTotal;\n\n\n        if (zethTotalNew >= zethTotal) {\n            // when yield is positive 1 zeth = 1 eth\n            return amount;\n        } else {\n            // negative yield means 1 zeth < 1 eth\n            return amount.mulU88(zethTotalNew).divU88(zethTotal); //@audit revert if amount*zethTotalNew > u88, replace mulU88 by mul\n        }\n    }\n```\n\nBut as we can see in the else case, `amount` is multiplied by `zethTotalNew` using the `PRBMathHelper::mulU88` function.\nThis function reverts when the result of the calculation is greater than U88.\nBut there is realistic situations (*amount: 333 ETH*, *zethTotalNew: 1M ETH*, [see total LSD staked here](https://defillama.com/lsd): 11.3M ETH staked) where this can happen.\nThe thing is that what matters in this calculation, is that the final result fits in a U88.\nThat means, only the division should check the overflow, but its not the case.\n\n## Impact\n\nUser request to withdraw or unstake will revert.\n\n## Proof of Concept\n\nAdd this test to `Yield.t.sol`:\n```solidity\nfunction test_audit_withdrawInvalidAmount() public {\n\t\tuint88 revertWithdrawal = 333 ether;\n\t\tuint88 zethTotal = 1_000_000 ether;\n\t\tuint88 zethTotalNew = 1_000_001 ether;\n\t\n        deal(_reth, sender, revertWithdrawal+100);\n        deal(_reth, extra, zethTotal);\n\n\t\tvm.prank(extra);\n\t\tdiamond.deposit(_bridgeReth, zethTotal);\n\n\t\tvm.prank(sender);\n\t\tdiamond.deposit(_bridgeReth, revertWithdrawal+100);\n\n\t\tdeal(_reth, _bridgeReth, zethTotalNew); // Mimics loss of value of 0.1 ETH\n\n\t\tvm.prank(sender);\n\t\tdiamond.withdraw(_bridgeReth, revertWithdrawal);\t\t\n\t}\n```\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nreplace the first mulU88 by a mul:\n\n```shell\ndiff --git a/contracts/facets/BridgeRouterFacet.sol b/contracts/facets/BridgeRouterFacet.sol\nindex c9ff4e5..3680ae6 100644\n--- a/contracts/facets/BridgeRouterFacet.sol\n+++ b/contracts/facets/BridgeRouterFacet.sol\n \n@@ -176,12 +176,12 @@ contract BridgeRouterFacet is Modifiers {\n\t    function _ethConversion(uint256 vault, uint88 amount) private view returns (uint88) {\n         uint256 zethTotalNew = vault.getZethTotal();\n         uint88 zethTotal = s.vault[vault].zethTotal;\n \n        if (zethTotalNew >= zethTotal) { \n             // when yield is positive 1 zeth = 1 eth\n             return amount;\n         } else {\n             // negative yield means 1 zeth < 1 eth\n-            return amount.mulU88(zethTotalNew).divU88(zethTotal);\n+            return amount.mul(zethTotalNew).divU88(zethTotal); //@audit-issue revert if amount*zethTotalNew > u88, replace mulU88 by mul\n         }\n     }\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/BridgeRouterFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibBridge} from \"contracts/libraries/LibBridge.sol\";\nimport {LibVault} from \"contracts/libraries/LibVault.sol\";\nimport {Constants, Vault} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract BridgeRouterFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using LibBridge for uint256;\n    using LibBridge for address;\n    using LibVault for uint256;\n\n    address private immutable rethBridge;\n    address private immutable stethBridge;\n\n    constructor(address _rethBridge, address _stethBridge) {\n        rethBridge = _rethBridge;\n        stethBridge = _stethBridge;\n    }\n\n    function getZethTotal(uint256 vault)\n        external\n        view\n        nonReentrantView\n        returns (uint256)\n    {\n        return vault.getZethTotal();\n    }\n\n    //@dev does not need read only re-entrancy\n    function getBridges(uint256 vault) external view returns (address[] memory) {\n        return s.vaultBridges[vault];\n    }\n\n    function deposit(address bridge, uint88 amount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (amount < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n        // @dev amount after deposit might be less, if bridge takes a fee\n        uint88 zethAmount = uint88(IBridge(bridge).deposit(msg.sender, amount)); // @dev(safe-cast)\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.Deposit(bridge, msg.sender, zethAmount);\n    }\n\n    function depositEth(address bridge)\n        external\n        payable\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (msg.value < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        uint88 zethAmount = uint88(IBridge(bridge).depositEth{value: msg.value}()); // Assumes 1 ETH = 1 ZETH\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.DepositEth(bridge, msg.sender, zethAmount);\n    }\n\n    function withdraw(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee;\n        uint256 withdrawalFee = bridge.withdrawalFee();\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (withdrawalFee > 0) {\n            fee = zethAmount.mulU88(withdrawalFee);\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.Withdraw(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function unstakeEth(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee = zethAmount.mulU88(bridge.unstakeFee());\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (fee > 0) {\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).unstake(msg.sender, ethAmount);\n        emit Events.UnstakeEth(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function withdrawTapp(address bridge, uint88 zethAmount)\n        external\n        onlyDAO\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n\n        s.vaultUser[vault][address(this)].ethEscrowed -= zethAmount;\n        s.vault[vault].zethTotal -= zethAmount;\n\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.WithdrawTapp(bridge, msg.sender, zethAmount);\n    }\n\n    function maybeUpdateYield(uint256 vault, uint88 amount) private {\n        uint88 zethTotal = s.vault[vault].zethTotal;\n        if (\n            zethTotal > Constants.BRIDGE_YIELD_UPDATE_THRESHOLD\n                && amount.div(zethTotal) > Constants.BRIDGE_YIELD_PERCENT_THRESHOLD\n        ) {\n            // Update yield for \"large\" bridge deposits\n            vault.updateYield();\n        }\n    }\n\n    function _ethConversion(uint256 vault, uint88 amount) private view returns (uint88) {\n        uint256 zethTotalNew = vault.getZethTotal();\n        uint88 zethTotal = s.vault[vault].zethTotal;\n\n        if (zethTotalNew >= zethTotal) {\n            // when yield is positive 1 zeth = 1 eth\n            return amount;\n        } else {\n            // negative yield means 1 zeth < 1 eth\n            return amount.mulU88(zethTotalNew).divU88(zethTotal);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/facets/BridgeRouterFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibBridge} from \"contracts/libraries/LibBridge.sol\";\nimport {LibVault} from \"contracts/libraries/LibVault.sol\";\nimport {Constants, Vault} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract BridgeRouterFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using LibBridge for uint256;\n    using LibBridge for address;\n    using LibVault for uint256;\n\n    address private immutable rethBridge;\n    address private immutable stethBridge;\n\n    constructor(address _rethBridge, address _stethBridge) {\n        rethBridge = _rethBridge;\n        stethBridge = _stethBridge;\n    }\n\n    function getZethTotal(uint256 vault)\n        external\n        view\n        nonReentrantView\n        returns (uint256)\n    {\n        return vault.getZethTotal();\n    }\n\n    //@dev does not need read only re-entrancy\n    function getBridges(uint256 vault) external view returns (address[] memory) {\n        return s.vaultBridges[vault];\n    }\n\n    function deposit(address bridge, uint88 amount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (amount < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n        // @dev amount after deposit might be less, if bridge takes a fee\n        uint88 zethAmount = uint88(IBridge(bridge).deposit(msg.sender, amount)); // @dev(safe-cast)\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.Deposit(bridge, msg.sender, zethAmount);\n    }\n\n    function depositEth(address bridge)\n        external\n        payable\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (msg.value < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        uint88 zethAmount = uint88(IBridge(bridge).depositEth{value: msg.value}()); // Assumes 1 ETH = 1 ZETH\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.DepositEth(bridge, msg.sender, zethAmount);\n    }\n\n    function withdraw(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee;\n        uint256 withdrawalFee = bridge.withdrawalFee();\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (withdrawalFee > 0) {\n            fee = zethAmount.mulU88(withdrawalFee);\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.Withdraw(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function unstakeEth(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee = zethAmount.mulU88(bridge.unstakeFee());\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (fee > 0) {\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).unstake(msg.sender, ethAmount);\n        emit Events.UnstakeEth(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function withdrawTapp(address bridge, uint88 zethAmount)\n        external\n        onlyDAO\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n\n        s.vaultUser[vault][address(this)].ethEscrowed -= zethAmount;\n        s.vault[vault].zethTotal -= zethAmount;\n\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.WithdrawTapp(bridge, msg.sender, zethAmount);\n    }\n\n    function maybeUpdateYield(uint256 vault, uint88 amount) private {\n        uint88 zethTotal = s.vault[vault].zethTotal;\n        if (\n            zethTotal > Constants.BRIDGE_YIELD_UPDATE_THRESHOLD\n                && amount.div(zethTotal) > Constants.BRIDGE_YIELD_PERCENT_THRESHOLD\n        ) {\n            // Update yield for \"large\" bridge deposits\n            vault.updateYield();\n        }\n    }\n\n    function _ethConversion(uint256 vault, uint88 amount) private view returns (uint88) {\n        uint256 zethTotalNew = vault.getZethTotal();\n        uint88 zethTotal = s.vault[vault].zethTotal;\n\n        if (zethTotalNew >= zethTotal) {\n            // when yield is positive 1 zeth = 1 eth\n            return amount;\n        } else {\n            // negative yield means 1 zeth < 1 eth\n            return amount.mulU88(zethTotalNew).divU88(zethTotal);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/facets/BridgeRouterFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibBridge} from \"contracts/libraries/LibBridge.sol\";\nimport {LibVault} from \"contracts/libraries/LibVault.sol\";\nimport {Constants, Vault} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract BridgeRouterFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using LibBridge for uint256;\n    using LibBridge for address;\n    using LibVault for uint256;\n\n    address private immutable rethBridge;\n    address private immutable stethBridge;\n\n    constructor(address _rethBridge, address _stethBridge) {\n        rethBridge = _rethBridge;\n        stethBridge = _stethBridge;\n    }\n\n    function getZethTotal(uint256 vault)\n        external\n        view\n        nonReentrantView\n        returns (uint256)\n    {\n        return vault.getZethTotal();\n    }\n\n    //@dev does not need read only re-entrancy\n    function getBridges(uint256 vault) external view returns (address[] memory) {\n        return s.vaultBridges[vault];\n    }\n\n    function deposit(address bridge, uint88 amount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (amount < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n        // @dev amount after deposit might be less, if bridge takes a fee\n        uint88 zethAmount = uint88(IBridge(bridge).deposit(msg.sender, amount)); // @dev(safe-cast)\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.Deposit(bridge, msg.sender, zethAmount);\n    }\n\n    function depositEth(address bridge)\n        external\n        payable\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (msg.value < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        uint88 zethAmount = uint88(IBridge(bridge).depositEth{value: msg.value}()); // Assumes 1 ETH = 1 ZETH\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.DepositEth(bridge, msg.sender, zethAmount);\n    }\n\n    function withdraw(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee;\n        uint256 withdrawalFee = bridge.withdrawalFee();\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (withdrawalFee > 0) {\n            fee = zethAmount.mulU88(withdrawalFee);\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.Withdraw(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function unstakeEth(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee = zethAmount.mulU88(bridge.unstakeFee());\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (fee > 0) {\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).unstake(msg.sender, ethAmount);\n        emit Events.UnstakeEth(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function withdrawTapp(address bridge, uint88 zethAmount)\n        external\n        onlyDAO\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n\n        s.vaultUser[vault][address(this)].ethEscrowed -= zethAmount;\n        s.vault[vault].zethTotal -= zethAmount;\n\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.WithdrawTapp(bridge, msg.sender, zethAmount);\n    }\n\n    function maybeUpdateYield(uint256 vault, uint88 amount) private {\n        uint88 zethTotal = s.vault[vault].zethTotal;\n        if (\n            zethTotal > Constants.BRIDGE_YIELD_UPDATE_THRESHOLD\n                && amount.div(zethTotal) > Constants.BRIDGE_YIELD_PERCENT_THRESHOLD\n        ) {\n            // Update yield for \"large\" bridge deposits\n            vault.updateYield();\n        }\n    }\n\n    function _ethConversion(uint256 vault, uint88 amount) private view returns (uint88) {\n        uint256 zethTotalNew = vault.getZethTotal();\n        uint88 zethTotal = s.vault[vault].zethTotal;\n\n        if (zethTotalNew >= zethTotal) {\n            // when yield is positive 1 zeth = 1 eth\n            return amount;\n        } else {\n            // negative yield means 1 zeth < 1 eth\n            return amount.mulU88(zethTotalNew).divU88(zethTotal);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/PRBMathHelper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {mulDiv as _mulDiv, mulDiv18, UNIT} from \"@prb/math/src/Common.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\nlibrary U256 {\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        return _mulDiv(x, y, denominator);\n    }\n\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is UNIT * UNIT.\n            result = 1e36 / x;\n        }\n    }\n\n    function divU80(uint256 x, uint256 y) internal pure returns (uint80 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint80).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint80(_result);\n    }\n\n    function divU64(uint256 x, uint256 y) internal pure returns (uint64 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint64).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint64(_result);\n    }\n\n    // test\n    function divU88(uint256 x, uint256 y) internal pure returns (uint88 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint88).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint88(_result);\n    }\n}\n\n// uint128\nlibrary Math128 {\n    // just passing the result of casting the first param to 256\n    function mul(uint128 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function div(uint128 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n}\n\n// uint104\nlibrary Math104 {\n    // just passing the result of casting the first param to 256\n    function mul(uint104 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function div(uint104 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n}\n\n// uint96\nlibrary U96 {\n    // just passing the result of casting the first param to 256\n    function mul(uint96 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function div(uint96 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n\n    function divU64(uint96 x, uint256 y) internal pure returns (uint64 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint64).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint64(_result);\n    }\n}\n\n// uint88\nlibrary U88 {\n    // just passing the result of casting the first param to 256\n    function mul(uint88 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function mulU88(uint88 x, uint256 y) internal pure returns (uint88 result) {\n        uint256 _result = mulDiv18(x, y);\n        if (_result > type(uint88).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint88(_result);\n    }\n\n    function div(uint88 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n\n    function divU88(uint88 x, uint256 y) internal pure returns (uint88 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint88).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint88(_result);\n    }\n\n    function divU80(uint88 x, uint256 y) internal pure returns (uint80 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint80).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint80(_result);\n    }\n}\n\n// uint80\nlibrary U80 {\n    // just passing the result of casting the first param to 256\n    function mul(uint80 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function mulU80(uint80 x, uint256 y) internal pure returns (uint80 result) {\n        uint256 _result = mulDiv18(x, y);\n        if (_result > type(uint80).max) revert Errors.InvalidPrice(); // assume price?\n        result = uint80(_result);\n    }\n\n    function mulU88(uint80 x, uint256 y) internal pure returns (uint88 result) {\n        uint256 _result = mulDiv18(x, y);\n        if (_result > type(uint80).max) revert Errors.InvalidPrice(); // assume price?\n        result = uint88(_result);\n    }\n\n    function div(uint80 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n\n    // test\n    function inv(uint80 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is UNIT * UNIT.\n            result = 1e36 / x;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/facets/BridgeRouterFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibBridge} from \"contracts/libraries/LibBridge.sol\";\nimport {LibVault} from \"contracts/libraries/LibVault.sol\";\nimport {Constants, Vault} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract BridgeRouterFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using LibBridge for uint256;\n    using LibBridge for address;\n    using LibVault for uint256;\n\n    address private immutable rethBridge;\n    address private immutable stethBridge;\n\n    constructor(address _rethBridge, address _stethBridge) {\n        rethBridge = _rethBridge;\n        stethBridge = _stethBridge;\n    }\n\n    function getZethTotal(uint256 vault)\n        external\n        view\n        nonReentrantView\n        returns (uint256)\n    {\n        return vault.getZethTotal();\n    }\n\n    //@dev does not need read only re-entrancy\n    function getBridges(uint256 vault) external view returns (address[] memory) {\n        return s.vaultBridges[vault];\n    }\n\n    function deposit(address bridge, uint88 amount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (amount < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n        // @dev amount after deposit might be less, if bridge takes a fee\n        uint88 zethAmount = uint88(IBridge(bridge).deposit(msg.sender, amount)); // @dev(safe-cast)\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.Deposit(bridge, msg.sender, zethAmount);\n    }\n\n    function depositEth(address bridge)\n        external\n        payable\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (msg.value < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        uint88 zethAmount = uint88(IBridge(bridge).depositEth{value: msg.value}()); // Assumes 1 ETH = 1 ZETH\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.DepositEth(bridge, msg.sender, zethAmount);\n    }\n\n    function withdraw(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee;\n        uint256 withdrawalFee = bridge.withdrawalFee();\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (withdrawalFee > 0) {\n            fee = zethAmount.mulU88(withdrawalFee);\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.Withdraw(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function unstakeEth(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee = zethAmount.mulU88(bridge.unstakeFee());\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (fee > 0) {\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).unstake(msg.sender, ethAmount);\n        emit Events.UnstakeEth(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function withdrawTapp(address bridge, uint88 zethAmount)\n        external\n        onlyDAO\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n\n        s.vaultUser[vault][address(this)].ethEscrowed -= zethAmount;\n        s.vault[vault].zethTotal -= zethAmount;\n\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.WithdrawTapp(bridge, msg.sender, zethAmount);\n    }\n\n    function maybeUpdateYield(uint256 vault, uint88 amount) private {\n        uint88 zethTotal = s.vault[vault].zethTotal;\n        if (\n            zethTotal > Constants.BRIDGE_YIELD_UPDATE_THRESHOLD\n                && amount.div(zethTotal) > Constants.BRIDGE_YIELD_PERCENT_THRESHOLD\n        ) {\n            // Update yield for \"large\" bridge deposits\n            vault.updateYield();\n        }\n    }\n\n    function _ethConversion(uint256 vault, uint88 amount) private view returns (uint88) {\n        uint256 zethTotalNew = vault.getZethTotal();\n        uint88 zethTotal = s.vault[vault].zethTotal;\n\n        if (zethTotalNew >= zethTotal) {\n            // when yield is positive 1 zeth = 1 eth\n            return amount;\n        } else {\n            // negative yield means 1 zeth < 1 eth\n            return amount.mulU88(zethTotalNew).divU88(zethTotal);\n        }\n    }\n}"
    }
  ]
}