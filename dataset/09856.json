{
  "Title": "[N-02] Extra whitespace in slot description of `WithdrewDelegationToStake()` event",
  "Content": "_Submitted by hickuphh3_\n\n### Line References\n[TWABDelegator.sol#L114](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L114)\n\n### Description\nThere is an additional spacing between `slot` and `Slot`.\n\n### Recommended Mitigation Steps\nRemove the spacing to become: `* @param slot Slot of the delegation`\n\n**[PierrickGT (PoolTogether) confirmed and commented](https://github.com/code-423n4/2022-02-pooltogether-findings/issues/16#issuecomment-1054830545):**\n> PR: [pooltogether/v4-twab-delegator#21](https://github.com/pooltogether/v4-twab-delegator/pull/21)\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-02-pooltogether",
  "Code": [
    {
      "filename": "contracts/TWABDelegator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@pooltogether/v4-core/contracts/interfaces/ITicket.sol\";\n\nimport \"./Delegation.sol\";\nimport \"./LowLevelDelegator.sol\";\nimport \"./PermitAndMulticall.sol\";\n\n/**\n * @title Delegate chances to win to multiple accounts.\n * @notice This contract allows accounts to easily delegate a portion of their tickets to multiple delegatees.\n  The delegatees chance of winning prizes is increased by the delegated amount.\n  If a delegator doesn't want to actively manage the delegations, then they can stake on the contract and appoint representatives.\n */\ncontract TWABDelegator is ERC20, LowLevelDelegator, PermitAndMulticall {\n  using Address for address;\n  using Clones for address;\n  using SafeERC20 for IERC20;\n\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted when ticket associated with this contract has been set.\n   * @param ticket Address of the ticket\n   */\n  event TicketSet(ITicket indexed ticket);\n\n  /**\n   * @notice Emitted when tickets have been staked.\n   * @param delegator Address of the delegator\n   * @param amount Amount of tickets staked\n   */\n  event TicketsStaked(address indexed delegator, uint256 amount);\n\n  /**\n   * @notice Emitted when tickets have been unstaked.\n   * @param delegator Address of the delegator\n   * @param recipient Address of the recipient that will receive the tickets\n   * @param amount Amount of tickets unstaked\n   */\n  event TicketsUnstaked(address indexed delegator, address indexed recipient, uint256 amount);\n\n  /**\n   * @notice Emitted when a new delegation is created.\n   * @param delegator Delegator of the delegation\n   * @param slot Slot of the delegation\n   * @param lockUntil Timestamp until which the delegation is locked\n   * @param delegatee Address of the delegatee\n   * @param delegation Address of the delegation that was created\n   * @param user Address of the user who created the delegation\n   */\n  event DelegationCreated(\n    address indexed delegator,\n    uint256 indexed slot,\n    uint96 lockUntil,\n    address indexed delegatee,\n    Delegation delegation,\n    address user\n  );\n\n  /**\n   * @notice Emitted when a delegatee is updated.\n   * @param delegator Address of the delegator\n   * @param slot Slot of the delegation\n   * @param delegatee Address of the delegatee\n   * @param lockUntil Timestamp until which the delegation is locked\n   * @param user Address of the user who updated the delegatee\n   */\n  event DelegateeUpdated(\n    address indexed delegator,\n    uint256 indexed slot,\n    address indexed delegatee,\n    uint96 lockUntil,\n    address user\n  );\n\n  /**\n   * @notice Emitted when a delegation is funded.\n   * @param delegator Address of the delegator\n   * @param slot Slot of the delegation\n   * @param amount Amount of tickets that were sent to the delegation\n   * @param user Address of the user who funded the delegation\n   */\n  event DelegationFunded(\n    address indexed delegator,\n    uint256 indexed slot,\n    uint256 amount,\n    address indexed user\n  );\n\n  /**\n   * @notice Emitted when a delegation is funded from the staked amount.\n   * @param delegator Address of the delegator\n   * @param slot Slot of the delegation\n   * @param amount Amount of tickets that were sent to the delegation\n   * @param user Address of the user who pulled funds from the delegator stake to the delegation\n   */\n  event DelegationFundedFromStake(\n    address indexed delegator,\n    uint256 indexed slot,\n    uint256 amount,\n    address indexed user\n  );\n\n  /**\n   * @notice Emitted when an amount of tickets has been withdrawn from a delegation. The tickets are held by this contract and the delegator stake is increased.\n   * @param delegator Address of the delegator\n   * @param slot Slot of the delegation\n   * @param amount Amount of tickets withdrawn\n   * @param user Address of the user who withdrew the tickets\n   */\n  event WithdrewDelegationToStake(\n    address indexed delegator,\n    uint256 indexed slot,\n    uint256 amount,\n    address indexed user\n  );\n\n  /**\n   * @notice Emitted when a delegator withdraws an amount of tickets from a delegation to a specified wallet.\n   * @param delegator Address of the delegator\n   * @param slot  Slot of the delegation\n   * @param amount Amount of tickets withdrawn\n   * @param to Recipient address of withdrawn tickets\n   */\n  event TransferredDelegation(\n    address indexed delegator,\n    uint256 indexed slot,\n    uint256 amount,\n    address indexed to\n  );\n\n  /**\n   * @notice Emitted when a representative is set.\n   * @param delegator Address of the delegator\n   * @param representative Address of the representative\n   * @param set Boolean indicating if the representative was set or unset\n   */\n  event RepresentativeSet(address indexed delegator, address indexed representative, bool set);\n\n  /* ============ Variables ============ */\n\n  /// @notice Prize pool ticket to which this contract is tied to.\n  ITicket public immutable ticket;\n\n  /// @notice Max lock time during which a delegation cannot be updated.\n  uint256 public constant MAX_LOCK = 180 days;\n\n  /**\n   * @notice Representative elected by the delegator to handle delegation.\n   * @dev Representative can only handle delegation and cannot withdraw tickets to their wallet.\n   * @dev delegator => representative => bool allowing representative to represent the delegator\n   */\n  mapping(address => mapping(address => bool)) internal representatives;\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice Creates a new TWAB Delegator that is bound to the given ticket contract.\n   * @param name_ The name for the staked ticket token\n   * @param symbol_ The symbol for the staked ticket token\n   * @param _ticket Address of the ticket contract\n   */\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    ITicket _ticket\n  ) LowLevelDelegator() ERC20(name_, symbol_) {\n    require(address(_ticket) != address(0), \"TWABDelegator/tick-not-zero-addr\");\n    ticket = _ticket;\n\n    emit TicketSet(_ticket);\n  }\n\n  /* ============ External Functions ============ */\n\n  /**\n   * @notice Stake `_amount` of tickets in this contract.\n   * @dev Tickets can be staked on behalf of a `_to` user.\n   * @param _to Address to which the stake will be attributed\n   * @param _amount Amount of tickets to stake\n   */\n  function stake(address _to, uint256 _amount) external {\n    _requireAmountGtZero(_amount);\n\n    IERC20(ticket).safeTransferFrom(msg.sender, address(this), _amount);\n    _mint(_to, _amount);\n\n    emit TicketsStaked(_to, _amount);\n  }\n\n  /**\n   * @notice Unstake `_amount` of tickets from this contract. Transfers ticket to the passed `_to` address.\n   * @dev If delegator has delegated his whole stake, he will first have to withdraw from a delegation to be able to unstake.\n   * @param _to Address of the recipient that will receive the tickets\n   * @param _amount Amount of tickets to unstake\n   */\n  function unstake(address _to, uint256 _amount) external {\n    _requireRecipientNotZeroAddress(_to);\n    _requireAmountGtZero(_amount);\n\n    _burn(msg.sender, _amount);\n\n    IERC20(ticket).safeTransfer(_to, _amount);\n\n    emit TicketsUnstaked(msg.sender, _to, _amount);\n  }\n\n  /**\n   * @notice Creates a new delegation.\n   This will create a new Delegation contract for the given slot and have it delegate its tickets to the given delegatee.\n   If a non-zero lock duration is passed, then the delegatee cannot be changed, nor funding withdrawn, until the lock has expired.\n   * @dev The `_delegator` and `_slot` params are used to compute the salt of the delegation\n   * @param _delegator Address of the delegator that will be able to handle the delegation\n   * @param _slot Slot of the delegation\n   * @param _delegatee Address of the delegatee\n   * @param _lockDuration Duration of time for which the delegation is locked. Must be less than the max duration.\n   * @return Returns the address of the Delegation contract that will hold the tickets\n   */\n  function createDelegation(\n    address _delegator,\n    uint256 _slot,\n    address _delegatee,\n    uint96 _lockDuration\n  ) external returns (Delegation) {\n    _requireDelegatorOrRepresentative(_delegator);\n    _requireDelegateeNotZeroAddress(_delegatee);\n    _requireLockDuration(_lockDuration);\n\n    uint96 _lockUntil = _computeLockUntil(_lockDuration);\n\n    Delegation _delegation = _createDelegation(\n      _computeSalt(_delegator, bytes32(_slot)),\n      _lockUntil\n    );\n\n    _setDelegateeCall(_delegation, _delegatee);\n\n    emit DelegationCreated(_delegator, _slot, _lockUntil, _delegatee, _delegation, msg.sender);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Updates the delegatee and lock duration for a delegation slot.\n   * @dev Only callable by the `_delegator` or their representative.\n   * @dev Will revert if delegation is still locked.\n   * @param _delegator Address of the delegator\n   * @param _slot Slot of the delegation\n   * @param _delegatee Address of the delegatee\n   * @param _lockDuration Duration of time during which the delegatee cannot be changed nor withdrawn\n   * @return The address of the Delegation\n   */\n  function updateDelegatee(\n    address _delegator,\n    uint256 _slot,\n    address _delegatee,\n    uint96 _lockDuration\n  ) external returns (Delegation) {\n    _requireDelegatorOrRepresentative(_delegator);\n    _requireDelegateeNotZeroAddress(_delegatee);\n    _requireLockDuration(_lockDuration);\n\n    Delegation _delegation = Delegation(_computeAddress(_delegator, _slot));\n    _requireDelegationUnlocked(_delegation);\n\n    uint96 _lockUntil = _computeLockUntil(_lockDuration);\n\n    if (_lockDuration > 0) {\n      _delegation.setLockUntil(_lockUntil);\n    }\n\n    _setDelegateeCall(_delegation, _delegatee);\n\n    emit DelegateeUpdated(_delegator, _slot, _delegatee, _lockUntil, msg.sender);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Fund a delegation by transferring tickets from the caller to the delegation.\n   * @dev Callable by anyone.\n   * @dev Will revert if delegation does not exist.\n   * @param _delegator Address of the delegator\n   * @param _slot Slot of the delegation\n   * @param _amount Amount of tickets to transfer\n   * @return The address of the Delegation\n   */\n  function fundDelegation(\n    address _delegator,\n    uint256 _slot,\n    uint256 _amount\n  ) external returns (Delegation) {\n    require(_delegator != address(0), \"TWABDelegator/dlgtr-not-zero-adr\");\n    _requireAmountGtZero(_amount);\n\n    Delegation _delegation = Delegation(_computeAddress(_delegator, _slot));\n    IERC20(ticket).safeTransferFrom(msg.sender, address(_delegation), _amount);\n\n    emit DelegationFunded(_delegator, _slot, _amount, msg.sender);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Fund a delegation using the `_delegator` stake.\n   * @dev Callable only by the `_delegator` or a representative.\n   * @dev Will revert if delegation does not exist.\n   * @dev Will revert if `_amount` is greater than the staked amount.\n   * @param _delegator Address of the delegator\n   * @param _slot Slot of the delegation\n   * @param _amount Amount of tickets to send to the delegation from the staked amount\n   * @return The address of the Delegation\n   */\n  function fundDelegationFromStake(\n    address _delegator,\n    uint256 _slot,\n    uint256 _amount\n  ) external returns (Delegation) {\n    _requireDelegatorOrRepresentative(_delegator);\n    _requireAmountGtZero(_amount);\n\n    Delegation _delegation = Delegation(_computeAddress(_delegator, _slot));\n\n    _burn(_delegator, _amount);\n\n    IERC20(ticket).safeTransfer(address(_delegation), _amount);\n\n    emit DelegationFundedFromStake(_delegator, _slot, _amount, msg.sender);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Withdraw tickets from a delegation. The tickets will be held by this contract and the delegator's stake will increase.\n   * @dev Only callable by the `_delegator` or a representative.\n   * @dev Will send the tickets to this contract and increase the `_delegator` staked amount.\n   * @dev Will revert if delegation is still locked.\n   * @param _delegator Address of the delegator\n   * @param _slot Slot of the delegation\n   * @param _amount Amount of tickets to withdraw\n   * @return The address of the Delegation\n   */\n  function withdrawDelegationToStake(\n    address _delegator,\n    uint256 _slot,\n    uint256 _amount\n  ) external returns (Delegation) {\n    _requireDelegatorOrRepresentative(_delegator);\n\n    Delegation _delegation = Delegation(_computeAddress(_delegator, _slot));\n\n    _transfer(_delegation, address(this), _amount);\n\n    _mint(_delegator, _amount);\n\n    emit WithdrewDelegationToStake(_delegator, _slot, _amount, msg.sender);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Withdraw an `_amount` of tickets from a delegation. The delegator is assumed to be the caller.\n   * @dev Tickets are sent directly to the passed `_to` address.\n   * @dev Will revert if delegation is still locked.\n   * @param _slot Slot of the delegation\n   * @param _amount Amount to withdraw\n   * @param _to Account to transfer the withdrawn tickets to\n   * @return The address of the Delegation\n   */\n  function transferDelegationTo(\n    uint256 _slot,\n    uint256 _amount,\n    address _to\n  ) external returns (Delegation) {\n    _requireRecipientNotZeroAddress(_to);\n\n    Delegation _delegation = Delegation(_computeAddress(msg.sender, _slot));\n    _transfer(_delegation, _to, _amount);\n\n    emit TransferredDelegation(msg.sender, _slot, _amount, _to);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Allow an account to set or unset a `_representative` to handle delegation.\n   * @dev If `_set` is `true`, `_representative` will be set as representative of `msg.sender`.\n   * @dev If `_set` is `false`, `_representative` will be unset as representative of `msg.sender`.\n   * @param _representative Address of the representative\n   * @param _set Set or unset the representative\n   */\n  function setRepresentative(address _representative, bool _set) external {\n    require(_representative != address(0), \"TWABDelegator/rep-not-zero-addr\");\n\n    representatives[msg.sender][_representative] = _set;\n\n    emit RepresentativeSet(msg.sender, _representative, _set);\n  }\n\n  /**\n   * @notice Returns whether or not the given rep is a representative of the delegator.\n   * @param _delegator The delegator\n   * @param _representative The representative to check for\n   * @return True if the rep is a rep, false otherwise\n   */\n  function isRepresentativeOf(address _delegator, address _representative)\n    external\n    view\n    returns (bool)\n  {\n    return representatives[_delegator][_representative];\n  }\n\n  /**\n   * @notice Allows a user to call multiple functions on the same contract.  Useful for EOA who wants to batch transactions.\n   * @param _data An array of encoded function calls.  The calls must be abi-encoded calls to this contract.\n   * @return The results from each function call\n   */\n  function multicall(bytes[] calldata _data) external returns (bytes[] memory) {\n    return _multicall(_data);\n  }\n\n  /**\n   * @notice Alow a user to approve ticket and run various calls in one transaction.\n   * @param _amount Amount of tickets to approve\n   * @param _permitSignature Permit signature\n   * @param _data Datas to call with `functionDelegateCall`\n   */\n  function permitAndMulticall(\n    uint256 _amount,\n    Signature calldata _permitSignature,\n    bytes[] calldata _data\n  ) external {\n    _permitAndMulticall(IERC20Permit(address(ticket)), _amount, _permitSignature, _data);\n  }\n\n  /**\n   * @notice Allows the caller to easily get the details for a delegation.\n   * @param _delegator The delegator address\n   * @param _slot The delegation slot they are using\n   * @return delegation The address that holds tickets for the delegation\n   * @return delegatee The address that tickets are being delegated to\n   * @return balance The balance of tickets in the delegation\n   * @return lockUntil The timestamp at which the delegation unlocks\n   * @return wasCreated Whether or not the delegation has been created\n   */\n  function getDelegation(address _delegator, uint256 _slot)\n    external\n    view\n    returns (\n      Delegation delegation,\n      address delegatee,\n      uint256 balance,\n      uint256 lockUntil,\n      bool wasCreated\n    )\n  {\n    delegation = Delegation(_computeAddress(_delegator, _slot));\n    wasCreated = address(delegation).isContract();\n    delegatee = ticket.delegateOf(address(delegation));\n    balance = ticket.balanceOf(address(delegation));\n\n    if (wasCreated) {\n      lockUntil = delegation.lockUntil();\n    }\n  }\n\n  /**\n   * @notice Computes the address of the delegation for the delegator + slot combination.\n   * @param _delegator The user who is delegating tickets\n   * @param _slot The delegation slot\n   * @return The address of the delegation.  This is the address that holds the balance of tickets.\n   */\n  function computeDelegationAddress(address _delegator, uint256 _slot)\n    external\n    view\n    returns (address)\n  {\n    return _computeAddress(_delegator, _slot);\n  }\n\n  /**\n   * @notice Returns the ERC20 token decimals.\n   * @dev This value is equal to the decimals of the ticket being delegated.\n   * @return ERC20 token decimals\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return ERC20(address(ticket)).decimals();\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /**\n   * @notice Computes the address of a delegation contract using the delegator and slot as a salt.\n   The contract is a clone, also known as minimal proxy contract.\n   * @param _delegator Address of the delegator\n   * @param _slot Slot of the delegation\n   * @return Address at which the delegation contract will be deployed\n   */\n  function _computeAddress(address _delegator, uint256 _slot) internal view returns (address) {\n    return _computeAddress(_computeSalt(_delegator, bytes32(_slot)));\n  }\n\n  /**\n   * @notice Computes the timestamp at which the delegation unlocks, after which the delegatee can be changed and tickets withdrawn.\n   * @param _lockDuration The duration of the lock\n   * @return The lock expiration timestamp\n   */\n  function _computeLockUntil(uint96 _lockDuration) internal view returns (uint96) {\n    unchecked {\n      return uint96(block.timestamp) + _lockDuration;\n    }\n  }\n\n  /**\n   * @notice Delegates tickets from the `_delegation` contract to the `_delegatee` address.\n   * @param _delegation Address of the delegation contract\n   * @param _delegatee Address of the delegatee\n   */\n  function _setDelegateeCall(Delegation _delegation, address _delegatee) internal {\n    bytes4 _selector = ticket.delegate.selector;\n    bytes memory _data = abi.encodeWithSelector(_selector, _delegatee);\n\n    _executeCall(_delegation, _data);\n  }\n\n  /**\n   * @notice Tranfers tickets from the Delegation contract to the `_to` address.\n   * @param _delegation Address of the delegation contract\n   * @param _to Address of the recipient\n   * @param _amount Amount of tickets to transfer\n   */\n  function _transferCall(\n    Delegation _delegation,\n    address _to,\n    uint256 _amount\n  ) internal {\n    bytes4 _selector = ticket.transfer.selector;\n    bytes memory _data = abi.encodeWithSelector(_selector, _to, _amount);\n\n    _executeCall(_delegation, _data);\n  }\n\n  /**\n   * @notice Execute a function call on the delegation contract.\n   * @param _delegation Address of the delegation contract\n   * @param _data The call data that will be executed\n   * @return The return datas from the calls\n   */\n  function _executeCall(Delegation _delegation, bytes memory _data)\n    internal\n    returns (bytes[] memory)\n  {\n    Delegation.Call[] memory _calls = new Delegation.Call[](1);\n    _calls[0] = Delegation.Call({ to: address(ticket), data: _data });\n\n    return _delegation.executeCalls(_calls);\n  }\n\n  /**\n   * @notice Transfers tickets from a delegation contract to `_to`.\n   * @param _delegation Address of the delegation contract\n   * @param _to Address of the recipient\n   * @param _amount Amount of tickets to transfer\n   */\n  function _transfer(\n    Delegation _delegation,\n    address _to,\n    uint256 _amount\n  ) internal {\n    _requireAmountGtZero(_amount);\n    _requireDelegationUnlocked(_delegation);\n\n    _transferCall(_delegation, _to, _amount);\n  }\n\n  /* ============ Modifier/Require Functions ============ */\n\n  /**\n   * @notice Require to only allow the delegator or representative to call a function.\n   * @param _delegator Address of the delegator\n   */\n  function _requireDelegatorOrRepresentative(address _delegator) internal view {\n    require(\n      _delegator == msg.sender || representatives[_delegator][msg.sender],\n      \"TWABDelegator/not-dlgtr-or-rep\"\n    );\n  }\n\n  /**\n   * @notice Require to verify that `_delegatee` is not address zero.\n   * @param _delegatee Address of the delegatee\n   */\n  function _requireDelegateeNotZeroAddress(address _delegatee) internal pure {\n    require(_delegatee != address(0), \"TWABDelegator/dlgt-not-zero-addr\");\n  }\n\n  /**\n   * @notice Require to verify that `_amount` is greater than 0.\n   * @param _amount Amount to check\n   */\n  function _requireAmountGtZero(uint256 _amount) internal pure {\n    require(_amount > 0, \"TWABDelegator/amount-gt-zero\");\n  }\n\n  /**\n   * @notice Require to verify that `_to` is not address zero.\n   * @param _to Address to check\n   */\n  function _requireRecipientNotZeroAddress(address _to) internal pure {\n    require(_to != address(0), \"TWABDelegator/to-not-zero-addr\");\n  }\n\n  /**\n   * @notice Require to verify if a `_delegation` is locked.\n   * @param _delegation Delegation to check\n   */\n  function _requireDelegationUnlocked(Delegation _delegation) internal view {\n    require(block.timestamp >= _delegation.lockUntil(), \"TWABDelegator/delegation-locked\");\n  }\n\n  /**\n   * @notice Require to verify that a `_lockDuration` does not exceed the maximum lock duration.\n   * @param _lockDuration Lock duration to check\n   */\n  function _requireLockDuration(uint256 _lockDuration) internal pure {\n    require(_lockDuration <= MAX_LOCK, \"TWABDelegator/lock-too-long\");\n  }\n}"
    }
  ]
}