{
  "Title": "[H01] Deposit uses operator collateral",
  "Content": "The `_deposit` function of the Pod contract [attempts to take collateral from the `operator`](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L180) but [credits it to the `from` address](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L185).\n\n\nIf successful, this effectively transfers funds from the operator to the `from` address. On the other hand, if the operator has insufficient funds or the Pod contract does not have approval, the [`operatorDeposit` function](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L151) will revert. Either scenario is undesirable.\n\n\nConsider updating the `transferFrom` arguments to retrieve collateral from the `from` address.\n\n\n**Update:** *Fixed in [PR#3](https://github.com/pooltogether/pods/pull/3/). Collateral is correctly taken from the `from` address.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Pod.sol",
      "content": "/**\nCopyright 2020 PoolTogether Inc.\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.5.12;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/introspection/IERC1820Registry.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC777/ERC777.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport \"@kleros/kleros/contracts/data-structures/SortitionSumTreeFactory.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/UniformRandomNumber.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/MCDAwarePool.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/IRewardListener.sol\";\n\nimport \"./ScheduledBalance.sol\";\nimport \"./ExchangeRateTracker.sol\";\n\n/**\n * @title PoolTogether Pod\n * @author Brendan Asselstine\n * @notice Allows users to own shares in pooled tickets for a PoolTogether Pool\n *\n * Designed to be bound to the PoolTogether Pool that support RewardListeners.\n *\n * A RewardListener is a contract that is registered to be the reward listener for an address using the ERC 1820 registry.\n *\n * When the Pool picks a winner, the Pool will look for a registered RewardListener.  If one exists, it calls `rewarded`\n * on the listener with a stipend of 200000 gas.\n *\n * In this way the Pod is able to track historic exchange rates.\n */\ncontract Pod is ERC777, ReentrancyGuard, IERC777Recipient, IRewardListener {\n  using ScheduledBalance for ScheduledBalance.State;\n  using ExchangeRateTracker for ExchangeRateTracker.State;\n\n  /// @notice The initial exchange rate for shares.  Starts high as the shares perpetually deflate.\n  uint256 internal constant BASE_EXCHANGE_RATE_MANTISSA = 1e24;\n\n  /// @notice keccak256(\"PoolTogetherRewardListener\")\n  bytes32 constant internal REWARD_LISTENER_INTERFACE_HASH =\n      0x68f03b0b1a978ee238a70b362091d993343460bc1a2830ab3f708936d9f564a4;\n\n  /// @notice keccak256(\"ERC777TokensRecipient\")\n  bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =\n      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n  /// @notice A reference to interact with the ERC1820 registry\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n  /**\n   * @notice Event emitted when a user withdraws their pending deposit\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that is being debited\n   * @param collateral The amount of collateral being withdrawn\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event PendingDepositWithdrawn(address indexed operator, address indexed from, uint256 collateral, bytes data, bytes operatorData);\n\n  /**\n   * @notice Event emitted when a user or operator redeems tokens into the backing collateral\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that is being debited\n   * @param amount The amount of Pod shares burned\n   * @param collateral The amount of collateral that was returned\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event Redeemed(address indexed operator, address indexed from, uint256 amount, uint256 collateral, bytes data, bytes operatorData);\n\n  /**\n   * @notice Event emitted when a user or operator redeems tokens into Pool tickets\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that is being debited\n   * @param amount The amount of Pod shares burned\n   * @param collateral The amount of Pool tickets redeemed.\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event RedeemedToPool(address indexed operator, address indexed from, uint256 amount, uint256 collateral, bytes data, bytes operatorData);\n\n  /**\n   * @notice Event emitted when the collateralization of the Pod shares changes.\n   * @param timestamp The timestamp at which the collateralization changed\n   * @param tokens The new token supply\n   * @param collateral The new collateral amount\n   * @param mantissa The new exchange rate mantissa\n   */\n  event CollateralizationChanged(uint256 indexed timestamp, uint256 tokens, uint256 collateral, uint256 mantissa);\n\n  /**\n   * @notice Event emitted when a user or operator deposits collateral for Pod shares\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that will be credited with Pod shares\n   * @param collateral The amount of collateral deposited\n   * @param drawId The open draw id in which the account deposited\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event Deposited(address indexed operator, address indexed from, uint256 collateral, uint256 drawId, bytes data, bytes operatorData);\n\n  /// @notice Tracks the consolidated and unconsolidated supply of tokens\n  ScheduledBalance.State internal scheduledSupply;\n\n  /// @notice Tracks the consolidated and unconsolidated balances of tokens per user\n  mapping(address => ScheduledBalance.State) internal scheduledBalances;\n\n  /// @notice Tracks the historic exchange rate\n  ExchangeRateTracker.State internal exchangeRateTracker;\n\n  /// @notice The PoolTogether Pool that this Pod is bound to\n  MCDAwarePool public pool;\n\n  /**\n   * @notice Initializes the Pod.\n   * @param _pool The Pool to bind this Pod to.\n   */\n  function initialize(\n    MCDAwarePool _pool\n  ) public initializer {\n    require(address(_pool) != address(0), \"Pod/pool-def\");\n    exchangeRateTracker.initialize(BASE_EXCHANGE_RATE_MANTISSA);\n    pool = _pool;\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), REWARD_LISTENER_INTERFACE_HASH, address(this));\n  }\n\n  /**\n   * @notice Deposits on behalf of a user by an operator.  The deposit will become Pod shares upon the next Pool reward.\n   * @param user The user on whose behalf to deposit\n   * @param amount The amount of collateral to deposit\n   * @param data Included user data\n   * @param operatorData Included operator data\n   */\n  function operatorDeposit(address user, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n    _deposit(msg.sender, user, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Deposits into the Pod. The deposit will become Pod shares upon the next Pool reward.\n   * @param amount The amount of collateral to deposit\n   * @param data Included user data\n   */\n  function deposit(uint256 amount, bytes calldata data) external {\n    _deposit(msg.sender, msg.sender, amount, data, \"\");\n  }\n\n  /**\n   * @notice Deposits on behalf of a user by an operator.  The operator may also be the user. The deposit will become Pod shares upon the next Pool reward.\n   * @param operator The operator who kicked of the deposit\n   * @param from The user on whose half to deposit\n   * @param amount The amount of collateral to deposit\n   * @param data Included user data\n   * @param operatorData Included operator data\n   */\n  function _deposit(\n    address operator,\n    address from,\n    uint256 amount,\n    bytes memory data,\n    bytes memory operatorData\n  ) internal nonReentrant {\n    consolidateBalanceOf(from);\n    pool.token().transferFrom(operator, address(this), amount);\n    pool.token().approve(address(pool), amount);\n    pool.depositPool(amount);\n    uint256 openDrawId = pool.currentOpenDrawId();\n    scheduledSupply.deposit(amount, openDrawId);\n    scheduledBalances[from].deposit(amount, openDrawId);\n    emit Deposited(operator, from, amount, openDrawId, data, operatorData);\n  }\n\n  /**\n   * @notice IERC777Recipient callback to handle direct Pool token transfers. When users transfer their Pool tickets to this contract they will be instantly converted into Pod shares.\n   * @param from The user whose tickets are being transferred\n   * @param amount The number of tickets being transferred\n   */\n  function tokensReceived(\n    address,\n    address from,\n    address, // to address can't be anything but us because we don't implement ERC1820ImplementerInterface\n    uint256 amount,\n    bytes calldata,\n    bytes calldata\n  ) external {\n    // if this is a transfer of pool tickets\n    if (msg.sender == address(pool.poolToken())) {\n      // convert to shares\n      consolidateBalanceOf(from);\n      uint256 tokens = exchangeRateTracker.collateralToTokenValue(amount);\n      _mint(address(this), from, tokens, \"\", \"\");\n    } else {\n      // The only other allowed token is itself and the asset\n      require(msg.sender == address(this) || msg.sender == address(pool.token()), \"Pod/unknown-token\");\n    }\n  }\n\n  /**\n   * @notice Returns the collateral value of the given users tokens. If the user does not have any tokens, this will be zero.  Pending deposits are not included.\n   * @param user The user whose balance should be checked\n   * @return The collateral value of the tokens held by the user.\n   */\n  function balanceOfUnderlying(address user) public view returns (uint256) {\n    return exchangeRateTracker.tokenToCollateralValue(balanceOf(user));\n  }\n\n  /**\n   * @notice Returns the number of tokens held by the given user.  Does not include pending deposits.\n   * @param tokenHolder The user whose balance should be checked\n   * @return The users total balance of tokens.\n   */\n  function balanceOf(address tokenHolder) public view returns (uint256) {\n    (uint256 balance, uint256 drawId) = scheduledBalances[tokenHolder].consolidatedBalanceInfo(pool.currentOpenDrawId());\n    return super.balanceOf(tokenHolder).add(\n      exchangeRateTracker.collateralToTokenValueAt(\n        balance,\n        drawId\n      )\n    );\n  }\n\n  /**\n   * @notice Returns the amount of collateral a user has deposited that is pending conversion to tokens.\n   * @param user The user whose pending collateral balance should be returned.\n   * @return The amount of collateral the user has deposited that has not converted to tokens.\n   */\n  function pendingDeposit(address user) public view returns (uint256) {\n    return scheduledBalances[user].unconsolidatedBalance(pool.currentOpenDrawId());\n  }\n\n  /**\n   * @notice Allows an operator to withdraw a user's pending deposit on their behalf\n   * @param from The user on whose behalf to withdraw\n   * @param amount The amount to withdraw\n   * @param data Data included by the user\n   * @param operatorData Data included by the operator\n   */\n  function operatorWithdrawPendingDeposit(\n    address from,\n    uint256 amount,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external {\n    require(isOperatorFor(msg.sender, from), \"Pod/not-op\");\n    _withdrawPendingDeposit(msg.sender, from, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Allows a user to withdraw their pending deposit\n   * @param amount The amount the user wishes to withdraw\n   * @param data Data included by the user\n   */\n  function withdrawPendingDeposit(\n    uint256 amount,\n    bytes calldata data\n  ) external {\n    _withdrawPendingDeposit(msg.sender, msg.sender, amount, data, \"\");\n  }\n\n  /**\n   * @notice Withdraw from a user's pending deposit\n   * @param operator The operator conducting the withdrawal\n   * @param from The user whose deposit will be withdrawn\n   * @param amount The amount to withdraw\n   * @param data Data included by the user\n   * @param operatorData Data included by the operator\n   */\n  function _withdrawPendingDeposit(\n    address operator,\n    address from,\n    uint256 amount,\n    bytes memory data,\n    bytes memory operatorData\n  ) internal {\n    uint256 openDrawId = pool.currentOpenDrawId();\n    scheduledBalances[from].withdrawUnconsolidated(amount, openDrawId);\n    pool.withdrawOpenDeposit(amount);\n    pool.token().transfer(from, amount);\n\n    emit PendingDepositWithdrawn(operator, from, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Returns the total supply of tokens.  Does not included any pending deposits.\n   * @return The total supply of tokens.\n   */\n  function totalSupply() public view returns (uint256) {\n    (uint256 balance, uint256 drawId) = scheduledSupply.consolidatedBalanceInfo(pool.currentOpenDrawId());\n    return super.totalSupply().add(\n      exchangeRateTracker.collateralToTokenValueAt(\n        balance,\n        drawId\n      )\n    );\n  }\n\n  /**\n    * @dev See {IERC777-operatorBurn}.\n    *\n    * This contract does not support burning.  Redeem must be called.\n    */\n  function operatorBurn(address, uint256, bytes memory, bytes memory) public {\n    revert(\"Pod/no-op\");\n  }\n\n  /**\n    * @dev See {IERC777-burn}.\n    *\n    * This contract does not support burning.  Redeem must be called.\n    */\n  function burn(uint256, bytes memory) public {\n    revert(\"Pod/no-op\");\n  }\n\n  /**\n   * @dev PoolTogetherRewardListener callback that is triggered by the Pool when this Pod wins.\n   * @param winnings The amount of collateral won in the prize\n   * @param drawId The prize id that was won\n   */\n  function rewarded(address, uint256 winnings, uint256 drawId) external nonReentrant {\n    require(msg.sender == address(pool), \"Pod/only-pool\");\n    uint256 tokens = totalSupply();\n    uint256 collateral = exchangeRateTracker.tokenToCollateralValue(tokens).add(winnings);\n    uint256 mantissa = exchangeRateTracker.collateralizationChanged(tokens, collateral, drawId.add(1));\n    emit CollateralizationChanged(drawId, tokens, collateral, mantissa);\n  }\n\n  /**\n   * @notice Returns the mantissa of the current exchange rate.\n   * @return The current exchange rate mantissa.\n   */\n  function currentExchangeRateMantissa() external view returns (uint256) {\n    return exchangeRateTracker.currentExchangeRateMantissa();\n  }\n\n  /**\n   * @notice Allows an operator to redeem tokens for collateral on behalf of a user.\n   * @param account The user who is redeeming tokens\n   * @param amount The amount of tokens to convert to collateral\n   * @param data User data included with the tx\n   * @param operatorData Operator data included with the tx\n   */\n  function operatorRedeem(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n    require(isOperatorFor(msg.sender, account), \"Pod/not-op\");\n    _redeem(msg.sender, account, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Allows a user to redeem tokens for collateral.\n   * @param amount The amount of tokens to convert to collateral\n   * @param data User data included with the tx\n   */\n  function redeem(uint256 amount, bytes calldata data) external {\n    _redeem(msg.sender, msg.sender, amount, data, \"\");\n  }\n\n  /**\n    * @notice Redeems tokens for the underlying asset.\n    * @param operator address operator requesting the operation\n    * @param from address token holder address\n    * @param amount uint256 amount of tokens to redeem\n    * @param data bytes extra information provided by the token holder\n    * @param operatorData bytes extra information provided by the operator (if any)\n    */\n  function _redeem(\n      address operator,\n      address from,\n      uint256 amount,\n      bytes memory data,\n      bytes memory operatorData\n  )\n      internal nonReentrant\n  {\n      consolidateBalanceOf(from);\n      uint256 collateral = exchangeRateTracker.tokenToCollateralValue(amount);\n      pool.withdrawCommittedDeposit(collateral);\n      pool.token().transfer(from, collateral);\n      emit Redeemed(operator, from, amount, collateral, data, operatorData);\n      _burn(operator, from, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Allows an operator to redeem tokens for Pool tickets on behalf of a user.\n   * @param account The user who is redeeming tokens\n   * @param amount The amount of tokens to convert to Pool tickets\n   * @param data User data included with the tx\n   * @param operatorData Operator data included with the tx\n   */\n  function operatorRedeemToPool(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n    require(isOperatorFor(msg.sender, account), \"Pod/not-op\");\n    _redeemToPool(msg.sender, account, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Allows a user to redeem tokens for Pool tickets\n   * @param amount The amount of tokens to convert to Pool tickets\n   * @param data User data included with the tx\n   */\n  function redeemToPool(uint256 amount, bytes calldata data) external {\n    _redeemToPool(msg.sender, msg.sender, amount, data, \"\");\n  }\n\n  /**\n   * @notice Allows an operator to redeem tokens for Pool tickets on behalf of a user.\n   * @param operator The operator who is running the tx\n   * @param from The user who is redeeming tokens\n   * @param amount The amount of tokens to convert to Pool tickets\n   * @param data User data included with the tx\n   * @param operatorData Operator data included with the tx\n   */\n  function _redeemToPool(\n    address operator,\n    address from,\n    uint256 amount,\n    bytes memory data,\n    bytes memory operatorData\n  ) internal nonReentrant {\n    consolidateBalanceOf(from);\n    uint256 collateral = exchangeRateTracker.tokenToCollateralValue(amount);\n    pool.poolToken().transfer(from, collateral);\n    emit RedeemedToPool(operator, from, amount, collateral, data, operatorData);\n    _burn(operator, from, amount, data, operatorData);\n  }\n\n  /**\n   * @dev Mints tokens to the Pod using any consolidated supply, then zeroes out the supply.\n   */\n  function consolidateSupply() internal {\n    uint256 openDrawId = pool.currentOpenDrawId();\n    (uint256 balance, uint256 drawId) = scheduledSupply.consolidatedBalanceInfo(openDrawId);\n    uint256 tokens = exchangeRateTracker.collateralToTokenValueAt(balance, drawId);\n    if (tokens > 0) {\n      scheduledSupply.clearConsolidated(openDrawId);\n      _mint(address(this), address(this), tokens, \"\", \"\");\n    }\n  }\n\n  /**\n   * @dev First calls `consolidateSupply()`, then transfers tokens from the Pod to the user based\n   * on the users consolidated supply.  Finally, it zeroes out the users consolidated supply.\n   * @param user The user whose balance should be consolidated.\n   */\n  function consolidateBalanceOf(address user) internal {\n    consolidateSupply();\n    uint256 openDrawId = pool.currentOpenDrawId();\n    (uint256 balance, uint256 drawId) = scheduledBalances[user].consolidatedBalanceInfo(openDrawId);\n    uint256 tokens = exchangeRateTracker.collateralToTokenValueAt(balance, drawId);\n    if (tokens > 0) {\n      scheduledBalances[user].clearConsolidated(openDrawId);\n      _send(address(this), address(this), user, tokens, \"\", \"\", true);\n    }\n  }\n}"
    },
    {
      "filename": "contracts/Pod.sol",
      "content": "/**\nCopyright 2020 PoolTogether Inc.\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.5.12;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/introspection/IERC1820Registry.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC777/ERC777.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport \"@kleros/kleros/contracts/data-structures/SortitionSumTreeFactory.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/UniformRandomNumber.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/MCDAwarePool.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/IRewardListener.sol\";\n\nimport \"./ScheduledBalance.sol\";\nimport \"./ExchangeRateTracker.sol\";\n\n/**\n * @title PoolTogether Pod\n * @author Brendan Asselstine\n * @notice Allows users to own shares in pooled tickets for a PoolTogether Pool\n *\n * Designed to be bound to the PoolTogether Pool that support RewardListeners.\n *\n * A RewardListener is a contract that is registered to be the reward listener for an address using the ERC 1820 registry.\n *\n * When the Pool picks a winner, the Pool will look for a registered RewardListener.  If one exists, it calls `rewarded`\n * on the listener with a stipend of 200000 gas.\n *\n * In this way the Pod is able to track historic exchange rates.\n */\ncontract Pod is ERC777, ReentrancyGuard, IERC777Recipient, IRewardListener {\n  using ScheduledBalance for ScheduledBalance.State;\n  using ExchangeRateTracker for ExchangeRateTracker.State;\n\n  /// @notice The initial exchange rate for shares.  Starts high as the shares perpetually deflate.\n  uint256 internal constant BASE_EXCHANGE_RATE_MANTISSA = 1e24;\n\n  /// @notice keccak256(\"PoolTogetherRewardListener\")\n  bytes32 constant internal REWARD_LISTENER_INTERFACE_HASH =\n      0x68f03b0b1a978ee238a70b362091d993343460bc1a2830ab3f708936d9f564a4;\n\n  /// @notice keccak256(\"ERC777TokensRecipient\")\n  bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =\n      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n  /// @notice A reference to interact with the ERC1820 registry\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n  /**\n   * @notice Event emitted when a user withdraws their pending deposit\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that is being debited\n   * @param collateral The amount of collateral being withdrawn\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event PendingDepositWithdrawn(address indexed operator, address indexed from, uint256 collateral, bytes data, bytes operatorData);\n\n  /**\n   * @notice Event emitted when a user or operator redeems tokens into the backing collateral\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that is being debited\n   * @param amount The amount of Pod shares burned\n   * @param collateral The amount of collateral that was returned\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event Redeemed(address indexed operator, address indexed from, uint256 amount, uint256 collateral, bytes data, bytes operatorData);\n\n  /**\n   * @notice Event emitted when a user or operator redeems tokens into Pool tickets\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that is being debited\n   * @param amount The amount of Pod shares burned\n   * @param collateral The amount of Pool tickets redeemed.\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event RedeemedToPool(address indexed operator, address indexed from, uint256 amount, uint256 collateral, bytes data, bytes operatorData);\n\n  /**\n   * @notice Event emitted when the collateralization of the Pod shares changes.\n   * @param timestamp The timestamp at which the collateralization changed\n   * @param tokens The new token supply\n   * @param collateral The new collateral amount\n   * @param mantissa The new exchange rate mantissa\n   */\n  event CollateralizationChanged(uint256 indexed timestamp, uint256 tokens, uint256 collateral, uint256 mantissa);\n\n  /**\n   * @notice Event emitted when a user or operator deposits collateral for Pod shares\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that will be credited with Pod shares\n   * @param collateral The amount of collateral deposited\n   * @param drawId The open draw id in which the account deposited\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event Deposited(address indexed operator, address indexed from, uint256 collateral, uint256 drawId, bytes data, bytes operatorData);\n\n  /// @notice Tracks the consolidated and unconsolidated supply of tokens\n  ScheduledBalance.State internal scheduledSupply;\n\n  /// @notice Tracks the consolidated and unconsolidated balances of tokens per user\n  mapping(address => ScheduledBalance.State) internal scheduledBalances;\n\n  /// @notice Tracks the historic exchange rate\n  ExchangeRateTracker.State internal exchangeRateTracker;\n\n  /// @notice The PoolTogether Pool that this Pod is bound to\n  MCDAwarePool public pool;\n\n  /**\n   * @notice Initializes the Pod.\n   * @param _pool The Pool to bind this Pod to.\n   */\n  function initialize(\n    MCDAwarePool _pool\n  ) public initializer {\n    require(address(_pool) != address(0), \"Pod/pool-def\");\n    exchangeRateTracker.initialize(BASE_EXCHANGE_RATE_MANTISSA);\n    pool = _pool;\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), REWARD_LISTENER_INTERFACE_HASH, address(this));\n  }\n\n  /**\n   * @notice Deposits on behalf of a user by an operator.  The deposit will become Pod shares upon the next Pool reward.\n   * @param user The user on whose behalf to deposit\n   * @param amount The amount of collateral to deposit\n   * @param data Included user data\n   * @param operatorData Included operator data\n   */\n  function operatorDeposit(address user, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n    _deposit(msg.sender, user, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Deposits into the Pod. The deposit will become Pod shares upon the next Pool reward.\n   * @param amount The amount of collateral to deposit\n   * @param data Included user data\n   */\n  function deposit(uint256 amount, bytes calldata data) external {\n    _deposit(msg.sender, msg.sender, amount, data, \"\");\n  }\n\n  /**\n   * @notice Deposits on behalf of a user by an operator.  The operator may also be the user. The deposit will become Pod shares upon the next Pool reward.\n   * @param operator The operator who kicked of the deposit\n   * @param from The user on whose half to deposit\n   * @param amount The amount of collateral to deposit\n   * @param data Included user data\n   * @param operatorData Included operator data\n   */\n  function _deposit(\n    address operator,\n    address from,\n    uint256 amount,\n    bytes memory data,\n    bytes memory operatorData\n  ) internal nonReentrant {\n    consolidateBalanceOf(from);\n    pool.token().transferFrom(operator, address(this), amount);\n    pool.token().approve(address(pool), amount);\n    pool.depositPool(amount);\n    uint256 openDrawId = pool.currentOpenDrawId();\n    scheduledSupply.deposit(amount, openDrawId);\n    scheduledBalances[from].deposit(amount, openDrawId);\n    emit Deposited(operator, from, amount, openDrawId, data, operatorData);\n  }\n\n  /**\n   * @notice IERC777Recipient callback to handle direct Pool token transfers. When users transfer their Pool tickets to this contract they will be instantly converted into Pod shares.\n   * @param from The user whose tickets are being transferred\n   * @param amount The number of tickets being transferred\n   */\n  function tokensReceived(\n    address,\n    address from,\n    address, // to address can't be anything but us because we don't implement ERC1820ImplementerInterface\n    uint256 amount,\n    bytes calldata,\n    bytes calldata\n  ) external {\n    // if this is a transfer of pool tickets\n    if (msg.sender == address(pool.poolToken())) {\n      // convert to shares\n      consolidateBalanceOf(from);\n      uint256 tokens = exchangeRateTracker.collateralToTokenValue(amount);\n      _mint(address(this), from, tokens, \"\", \"\");\n    } else {\n      // The only other allowed token is itself and the asset\n      require(msg.sender == address(this) || msg.sender == address(pool.token()), \"Pod/unknown-token\");\n    }\n  }\n\n  /**\n   * @notice Returns the collateral value of the given users tokens. If the user does not have any tokens, this will be zero.  Pending deposits are not included.\n   * @param user The user whose balance should be checked\n   * @return The collateral value of the tokens held by the user.\n   */\n  function balanceOfUnderlying(address user) public view returns (uint256) {\n    return exchangeRateTracker.tokenToCollateralValue(balanceOf(user));\n  }\n\n  /**\n   * @notice Returns the number of tokens held by the given user.  Does not include pending deposits.\n   * @param tokenHolder The user whose balance should be checked\n   * @return The users total balance of tokens.\n   */\n  function balanceOf(address tokenHolder) public view returns (uint256) {\n    (uint256 balance, uint256 drawId) = scheduledBalances[tokenHolder].consolidatedBalanceInfo(pool.currentOpenDrawId());\n    return super.balanceOf(tokenHolder).add(\n      exchangeRateTracker.collateralToTokenValueAt(\n        balance,\n        drawId\n      )\n    );\n  }\n\n  /**\n   * @notice Returns the amount of collateral a user has deposited that is pending conversion to tokens.\n   * @param user The user whose pending collateral balance should be returned.\n   * @return The amount of collateral the user has deposited that has not converted to tokens.\n   */\n  function pendingDeposit(address user) public view returns (uint256) {\n    return scheduledBalances[user].unconsolidatedBalance(pool.currentOpenDrawId());\n  }\n\n  /**\n   * @notice Allows an operator to withdraw a user's pending deposit on their behalf\n   * @param from The user on whose behalf to withdraw\n   * @param amount The amount to withdraw\n   * @param data Data included by the user\n   * @param operatorData Data included by the operator\n   */\n  function operatorWithdrawPendingDeposit(\n    address from,\n    uint256 amount,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external {\n    require(isOperatorFor(msg.sender, from), \"Pod/not-op\");\n    _withdrawPendingDeposit(msg.sender, from, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Allows a user to withdraw their pending deposit\n   * @param amount The amount the user wishes to withdraw\n   * @param data Data included by the user\n   */\n  function withdrawPendingDeposit(\n    uint256 amount,\n    bytes calldata data\n  ) external {\n    _withdrawPendingDeposit(msg.sender, msg.sender, amount, data, \"\");\n  }\n\n  /**\n   * @notice Withdraw from a user's pending deposit\n   * @param operator The operator conducting the withdrawal\n   * @param from The user whose deposit will be withdrawn\n   * @param amount The amount to withdraw\n   * @param data Data included by the user\n   * @param operatorData Data included by the operator\n   */\n  function _withdrawPendingDeposit(\n    address operator,\n    address from,\n    uint256 amount,\n    bytes memory data,\n    bytes memory operatorData\n  ) internal {\n    uint256 openDrawId = pool.currentOpenDrawId();\n    scheduledBalances[from].withdrawUnconsolidated(amount, openDrawId);\n    pool.withdrawOpenDeposit(amount);\n    pool.token().transfer(from, amount);\n\n    emit PendingDepositWithdrawn(operator, from, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Returns the total supply of tokens.  Does not included any pending deposits.\n   * @return The total supply of tokens.\n   */\n  function totalSupply() public view returns (uint256) {\n    (uint256 balance, uint256 drawId) = scheduledSupply.consolidatedBalanceInfo(pool.currentOpenDrawId());\n    return super.totalSupply().add(\n      exchangeRateTracker.collateralToTokenValueAt(\n        balance,\n        drawId\n      )\n    );\n  }\n\n  /**\n    * @dev See {IERC777-operatorBurn}.\n    *\n    * Th"
    }
  ]
}