{
  "Title": "[M-03] Cross-Chain Signature Replay Attack",
  "Content": "\nUser operations can be replayed on smart accounts accross different chains. This can lead to user's losing funds or any unexpected behaviour that transaction replay attacks usually lead to.\n\n### Proof of Concept\n\nAs specified by the [EIP4337](https://eips.ethereum.org/EIPS/eip-4337) standard `to prevent replay attacks ... the signature should depend on chainid`. In [VerifyingSingletonPaymaster.sol#getHash](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90) the chainId is missing which means that the same UserOperation can be replayed on a different chain for the same smart contract account if the `verifyingSigner` is the same (and most likely this will be the case).\n\n### Recommended Mitigation Steps\n\nAdd the chainId in the calculation of the UserOperation hash in [VerifyingSingletonPaymaster.sol#getHash](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90)\n\n        function getHash(UserOperation calldata userOp)\n        public view returns (bytes32) { // @audit change to view\n            //can't use userOp.hash(), since it contains also the paymasterAndData itself.\n            return keccak256(abi.encode(\n                    userOp.getSender(),\n                    userOp.nonce,\n                    keccak256(userOp.initCode),\n                    keccak256(userOp.callData),\n                    userOp.callGasLimit,\n                    userOp.verificationGasLimit,\n                    userOp.preVerificationGas,\n                    userOp.maxFeePerGas,\n                    userOp.maxPriorityFeePerGas\n    \t\tblock.chainid // @audit add chain id\n                ));\n        }\n\n**[livingrockrises (Biconomy) confirmed](https://github.com/code-423n4/2023-01-biconomy-findings/issues/466#issuecomment-1421110204)**\n\n**[gzeon (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-biconomy-findings/issues/466#issuecomment-1425735635)**\n\n**[vlad\\_bochok (warden) commented](https://github.com/code-423n4/2023-01-biconomy-findings/issues/466#issuecomment-1426673710):**\n > @gzeon @livingrockrises \n> \n> > User operations can be replayed on smart accounts accross different chains\n> \n> The author refers that the operation may be replayed on a different chain. That is not true. The \"getHash\" function derives the hash of UserOp specifically for the paymaster's internal usage. While the paymaster doesn't sign the chainId, the UserOp may not be relayed on a different chain. So, the only paymaster may get hurt. In all other respects, the bug is valid.\n> \n> The real use case of this cross-chan replayability is described in issue [`#504`](https://github.com/code-423n4/2023-01-biconomy-findings/issues/504) (which, I believe, was mistakenly downgraded).\n\n**[livingrockrises (Biconomy) commented](https://github.com/code-423n4/2023-01-biconomy-findings/issues/466#issuecomment-1426685496):**\n > True. Besides chainId , address(this) should be hashed and contract must maintain it's own nonces per wallet otherwise wallet can replay the signature and use paymaster to sponsor! We're also planning to hash paymasterId as add-on on top of our off-chain validation for it.  \n> \n> I have't seen an issue which covers all above. Either cross chain replay or suggested paymaster nonce.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-biconomy-smart-contract-wallet-contest",
  "Code": [
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.12;\n\n/* solhint-disable reason-string */\nimport \"../../BasePaymaster.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../PaymasterHelpers.sol\";\n// import \"../samples/Signatures.sol\";\n\n\n/**\n * A sample paymaster that uses external service to decide whether to pay for the UserOp.\n * The paymaster trusts an external signer to sign the transaction.\n * The calling user must pass the UserOp to that external signer first, which performs\n * whatever off-chain verification before signing the UserOp.\n * Note that this signature is NOT a replacement for wallet signature:\n * - the paymaster signs to agree to PAY for GAS.\n * - the wallet signs to prove identity and wallet ownership.\n */\ncontract VerifyingSingletonPaymaster is BasePaymaster {\n\n    using ECDSA for bytes32;\n    // possibly //  using Signatures for UserOperation;\n    using UserOperationLib for UserOperation;\n    using PaymasterHelpers for UserOperation;\n    using PaymasterHelpers for bytes;\n    using PaymasterHelpers for PaymasterData;\n\n    mapping(address => uint256) public paymasterIdBalances;\n\n    address public verifyingSigner;\n\n    constructor(IEntryPoint _entryPoint, address _verifyingSigner) BasePaymaster(_entryPoint) {\n        require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\n        require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\n        verifyingSigner = _verifyingSigner;\n    }\n\n    function deposit() public virtual override payable {\n        revert(\"Deposit must be for a paymasterId. Use depositFor\");\n    }\n\n    /**\n     * add a deposit for this paymaster and given paymasterId (Dapp Depositor address), used for paying for transaction fees\n     */\n    function depositFor(address paymasterId) public payable {\n        require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\n        require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n        paymasterIdBalances[paymasterId] += msg.value;\n        entryPoint.depositTo{value : msg.value}(address(this));\n    }\n\n    function withdrawTo(address payable withdrawAddress, uint256 amount) public override {\n        uint256 currentBalance = paymasterIdBalances[msg.sender];\n        require(amount <= currentBalance, \"Insufficient amount to withdraw\");\n        paymasterIdBalances[msg.sender] -= amount;\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n    \n    /**\n    this function will let owner change signer\n    */\n    function setSigner( address _newVerifyingSigner) external onlyOwner{\n        require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n        verifyingSigner = _newVerifyingSigner;\n    }\n\n    /**\n     * return the hash we're going to sign off-chain (and validate on-chain)\n     * this method is called by the off-chain service, to sign the request.\n     * it is called on-chain from the validatePaymasterUserOp, to validate the signature.\n     * note that this signature covers all fields of the UserOperation, except the \"paymasterAndData\",\n     * which will carry the signature itself.\n     */\n    function getHash(UserOperation calldata userOp)\n    public pure returns (bytes32) {\n        //can't use userOp.hash(), since it contains also the paymasterAndData itself.\n        return keccak256(abi.encode(\n                userOp.getSender(),\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas\n            ));\n    }\n\n    /**\n     * verify our external signer signed this request.\n     * the \"paymasterAndData\" is expected to be the paymaster and a signature over the entire request params\n     */\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n    external view override returns (bytes memory context, uint256 deadline) {\n        (requiredPreFund);\n        bytes32 hash = getHash(userOp);\n\n        PaymasterData memory paymasterData = userOp.decodePaymasterData();\n        uint256 sigLength = paymasterData.signatureLength;\n\n        //ECDSA library supports both 64 and 65-byte long signatures.\n        // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\n        require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n        require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n        require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n        return (userOp.paymasterContext(paymasterData), 0);\n    }\n\n    /**\n   * @dev Executes the paymaster's payment conditions\n   * @param mode tells whether the op succeeded, reverted, or if the op succeeded but cause the postOp to revert\n   * @param context payment conditions signed by the paymaster in `validatePaymasterUserOp`\n   * @param actualGasCost amount to be paid to the entry point in wei\n   */\n  function _postOp(\n    PostOpMode mode,\n    bytes calldata context,\n    uint256 actualGasCost\n  ) internal virtual override {\n    (mode);\n    // (mode,context,actualGasCost); // unused params\n    PaymasterContext memory data = context.decodePaymasterContext();\n    address extractedPaymasterId = data.paymasterId;\n    paymasterIdBalances[extractedPaymasterId] -= actualGasCost;\n  }\n\n}"
    },
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.12;\n\n/* solhint-disable reason-string */\nimport \"../../BasePaymaster.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../PaymasterHelpers.sol\";\n// import \"../samples/Signatures.sol\";\n\n\n/**\n * A sample paymaster that uses external service to decide whether to pay for the UserOp.\n * The paymaster trusts an external signer to sign the transaction.\n * The calling user must pass the UserOp to that external signer first, which performs\n * whatever off-chain verification before signing the UserOp.\n * Note that this signature is NOT a replacement for wallet signature:\n * - the paymaster signs to agree to PAY for GAS.\n * - the wallet signs to prove identity and wallet ownership.\n */\ncontract VerifyingSingletonPaymaster is BasePaymaster {\n\n    using ECDSA for bytes32;\n    // possibly //  using Signatures for UserOperation;\n    using UserOperationLib for UserOperation;\n    using PaymasterHelpers for UserOperation;\n    using PaymasterHelpers for bytes;\n    using PaymasterHelpers for PaymasterData;\n\n    mapping(address => uint256) public paymasterIdBalances;\n\n    address public verifyingSigner;\n\n    constructor(IEntryPoint _entryPoint, address _verifyingSigner) BasePaymaster(_entryPoint) {\n        require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\n        require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\n        verifyingSigner = _verifyingSigner;\n    }\n\n    function deposit() public virtual override payable {\n        revert(\"Deposit must be for a paymasterId. Use depositFor\");\n    }\n\n    /**\n     * add a deposit for this paymaster and given paymasterId (Dapp Depositor address), used for paying for transaction fees\n     */\n    function depositFor(address paymasterId) public payable {\n        require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\n        require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n        paymasterIdBalances[paymasterId] += msg.value;\n        entryPoint.depositTo{value : msg.value}(address(this));\n    }\n\n    function withdrawTo(address payable withdrawAddress, uint256 amount) public override {\n        uint256 currentBalance = paymasterIdBalances[msg.sender];\n        require(amount <= currentBalance, \"Insufficient amount to withdraw\");\n        paymasterIdBalances[msg.sender] -= amount;\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n    \n    /**\n    this function will let owner change signer\n    */\n    function setSigner( address _newVerifyingSigner) external onlyOwner{\n        require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n        verifyingSigner = _newVerifyingSigner;\n    }\n\n    /**\n     * return the hash we're going to sign off-chain (and validate on-chain)\n     * this method is called by the off-chain service, to sign the request.\n     * it is called on-chain from the validatePaymasterUserOp, to validate the signature.\n     * note that this signature covers all fields of the UserOperation, except the \"paymasterAndData\",\n     * which will carry the signature itself.\n     */\n    function getHash(UserOperation calldata userOp)\n    public pure returns (bytes32) {\n        //can't use userOp.hash(), since it contains also the paymasterAndData itself.\n        return keccak256(abi.encode(\n                userOp.getSender(),\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas\n            ));\n    }\n\n    /**\n     * verify our external signer signed this request.\n     * the \"paymasterAndData\" is expected to be the paymaster and a signature over the entire request params\n     */\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n    external view override returns (bytes memory context, uint256 deadline) {\n        (requiredPreFund);\n        bytes32 hash = getHash(userOp);\n\n        PaymasterData memory paymasterData = userOp.decodePaymasterData();\n        uint256 sigLength = paymasterData.signatureLength;\n\n        //ECDSA library supports both 64 and 65-byte long signatures.\n        // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\n        require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n        require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n        require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n        return (userOp.paymasterContext(paymasterData), 0);\n    }\n\n    /**\n   * @dev Executes the paymaster's payment conditions\n   * @param mode tells whether the op succeeded, reverted, or if the op succeeded but cause the postOp to revert\n   * @param context payment conditions signed by the paymaster in `validatePaymasterUserOp`\n   * @param actualGasCost amount to be paid to the entry point in wei\n   */\n  function _postOp(\n    PostOpMode mode,\n    bytes calldata context,\n    uint256 actualGasCost\n  ) internal virtual override {\n    (mode);\n    // (mode,context,actualGasCost); // unused params\n    PaymasterContext memory data = context.decodePaymasterContext();\n    address extractedPaymasterId = data.paymasterId;\n    paymasterIdBalances[extractedPaymasterId] -= actualGasCost;\n  }\n\n}"
    }
  ]
}