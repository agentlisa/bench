{
  "Title": "[M-24] ProfitManager's `creditMultiplier` calculation does not count undistributed rewards; this can cause value losses to users",
  "Content": "\nThe function `notifyPnL` in ProfitManager is called by `LendingTerms` when a loan is closed to report a profit or loss.\n\nIn case there is a loss, the amount in excess of the protocol's buffer is attributed to the credit token holders. This is done by slashing the `creditMultiplier` with the effect of depreciating the credit token relatively to the collateral.\n\nThe math for slashing the `creditMultiplier` is the following:\n\n```Solidity\nFile: ProfitManager.sol\n292:     function notifyPnL(\n293:         address gauge,\n294:         int256 amount\n295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {\n---\n330:                 // update the CREDIT multiplier\n331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();\n332:                 uint256 newCreditMultiplier = (creditMultiplier *\n333:                     (creditTotalSupply - loss)) / creditTotalSupply;\n334:                 creditMultiplier = newCreditMultiplier;\n```\n\nIt is particularly interesting that `totalSupply()` is used, since in a similar high-level accounting calculation, `totalBorrowedCredit()`, `targetTotalSupply()` is used instead:\n\n```Solidity\nFile: ProfitManager.sol\n172:     function totalBorrowedCredit() external view returns (uint256) {\n173:         return\n174:             CreditToken(credit).targetTotalSupply() -\n175:             SimplePSM(psm).redeemableCredit();\n176:     }\n```\n\nThe usage of `totalSupply()` here can be problematic when a significant portion of the supply is in undistributed rewards. In this case, the `creditMultiplier` slashing will be higher than it should because `totalSupply()` will return a much lower value than `targetTotalSupply()`.\n\n### Impact\n\n`creditMultiplier` slashing will always be higher than it should for correct accounting, penalizing credit token holders, and finally locking value in the protocol. The negative effects will be proportional to the relative supply of credit tokens in undistributed rewards versus the interpolated supply of the credit token.\n\n### Proof of Concept\n\nThe following PoC in Foundry (full setup [here](https://gist.github.com/3docSec/4e04f4dbd14ecfa4d5fecd1a4cfca81c)) shows how an overshot `creditMultiplier` slashing locks collateral value in `SimplePSM`, with a net loss for protocol users, in a real-wold scenario:\n\n```Solidity\n    function testH2() external {\n        uint ts = block.timestamp;\n\n        // Set ProfitManager to 100% rewards for rebasing users\n        pm.setProfitSharingConfig(\n            0,          // surplusBufferSplit,\n            1e18,       // creditSplit,\n            0,          // guildSplit,\n            0,          // otherSplit,\n            address(0)  // otherRecipient\n        );\n        \n        // User 1 deposit 3000 USDC in PSM, gets 3000 gUSDC, enters rebase\n        address user1 = address(1);\n        vm.startPrank(user1);\n\n        coll.mint(user1, 3_000e18);\n        coll.approve(address(sPsm), 3_000e18);\n        sPsm.mintAndEnterRebase(3_000e18);\n\n        // User 2 open Loan A, 1000 gUSDC, redeems for 1000 USDC\n        address user2 = address(2);\n        vm.startPrank(user2);\n\n        coll.mint(user2, 1_000e18);\n        coll.approve(address(lt), 1_000e18);\n        bytes32 loanA = lt.borrow(1_000e18, 1_000e18);\n\n        ct.approve(address(sPsm), 1_000e18);\n        sPsm.redeem(user2, 1_000e18);\n\n        // User 3 open Loan B, 1000 gUSDC, redeems for 1000 USDC\n        address user3 = address(3);\n        vm.startPrank(user3);\n\n        coll.mint(user3, 1_000e18);\n        coll.approve(address(lt), 1_000e18);\n        bytes32 loanB = lt.borrow(1_000e18, 1_000e18);\n\n        ct.approve(address(sPsm), 1_000e18);\n        sPsm.redeem(user3, 1_000e18);\n\n        // User 4 open Loan C, 1000 gUSDC, redeems for 1000 USDC\n        address user4 = address(4);\n        vm.startPrank(user4);\n\n        coll.mint(user4, 1_000e18);\n        coll.approve(address(lt), 1_000e18);\n        bytes32 loanC = lt.borrow(1_000e18, 1_000e18);\n\n        ct.approve(address(sPsm), 1_000e18);\n        sPsm.redeem(user4, 1_000e18);\n\n        // Time passes, all loans accrue 50% interest, loan B gets called\n        ts += lt.YEAR() - 3 weeks;\n        vm.warp(ts);\n        lt.call(loanB);\n        ts += 3 weeks;\n        vm.warp(ts);\n\n        // User 2 deposit 1500 USDC in PSM, gets 1500 gUSDC, and repay Loan A (500 profit) -> 1500 USDC in PSM\n        vm.startPrank(user2);\n        coll.mint(user2, 500e18);\n        coll.approve(address(sPsm), 1500e18);\n        sPsm.mint(user2, 1500e18);\n\n        ct.approve(address(lt), 1500e18);\n        lt.repay(loanA);\n\n        // Now User 1's 3000 gUSDC balance is interpolating towards 3500 gUSDC\n        assertEq(3_000e18, ct.totalSupply());\n        assertEq(ct.totalSupply(), ct.balanceOf(user1));\n        assertEq(3_500e18, ct.targetTotalSupply());\n\n        // ---  Everything good till here; now we get to the bug:\n        // User 3 completely defaults on Loan B, 1000 gUSDC loss is reported, \n        // creditMultiplier becomes 1e18 * (3000 - 1000) / 3000 = 0.6667e18\n        // ðŸš¨ if targetTotalSupply was used, this would be 1e18 * (3500 - 1000) / 3500 = 0.714285e18\n        ah.forgive(loanB);\n        assertApproxEqRel(pm.creditMultiplier(), 0.6667e18, 0.0001e18 /* 0.01% */);\n\n        // User 4's Loan C now owes 1500 / 0.66667 = 2250 gUSDC\n        uint loanCdebt = lt.getLoanDebt(loanC);\n        assertApproxEqRel(loanCdebt, 2250e18, 0.0001e18 /* 0.01% */);\n\n        // User 4 deposit 1500 USDC in PSM, gets 2250 gUSDC, and repay Loan C (750 profit) -> 3000 USDC in PSM\n        vm.startPrank(user4);\n        coll.mint(user4, 500e18);\n        coll.approve(address(sPsm), 1500e18);\n        sPsm.mint(user4, 1500e18);\n\n        ct.approve(address(lt), loanCdebt);\n        lt.repay(loanC);\n        \n        // Now User 1's 3000 gUSDC balance is interpolating towards 4250\n        assertEq(3_000e18, ct.totalSupply());\n        assertEq(ct.totalSupply(), ct.balanceOf(user1));\n        assertApproxEqRel(4_250e18, ct.targetTotalSupply(), 0.0001e18 /* 0.01% */);\n\n        // User 1 waits for the interpolation to end\n        ts += ct.DISTRIBUTION_PERIOD();\n        vm.warp(ts);\n\n        // User 1 redeems 4250 gUSDC for 4250 * 0.66667 = 2833 USDC -> 167 USDC in PSM (ðŸš¨ there should be no leftover)\n        vm.startPrank(user1);\n        ct.approve(address(sPsm), ct.balanceOf(user1));\n        sPsm.redeem(user1, ct.balanceOf(user1));\n\n        assertApproxEqRel(2833.3e18, coll.balanceOf(user1), 0.0001e18 /* 0.01% */);\n\n        // ðŸš¨ this value remains locked in the SimplePSM contract as a result of the incorrect accounting\n        assertApproxEqRel(166.66e18, coll.balanceOf(address(sPsm)), 0.0001e18 /* 0.01% */);\n\n        // â„¹ï¸ if ProfitManager used targetTotalSupply, the value locked would be ~2e4 lost to rounding\n    }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nConsider using `targetTotalSupply()` instead of `totalSupply()` in the `creditMultiplier` slashing calculation:\n\n```diff\n    // ProfitManager:330\n    // update the CREDIT multiplier\n-   uint256 creditTotalSupply = CreditToken(_credit).totalSupply();\n+   uint256 creditTotalSupply = CreditToken(_credit).targetTotalSupply();\n    uint256 newCreditMultiplier = (creditMultiplier *\n        (creditTotalSupply - loss)) / creditTotalSupply;\n    creditMultiplier = newCreditMultiplier;\n    emit CreditMultiplierUpdate(\n        block.timestamp,\n        newCreditMultiplier\n    );\n```\n\n### Assessed type\n\nMath\n\n**[eswak (Ethereum Credit Guild) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/292#issuecomment-1881213706):**\n > Confirming this issue, and thanks a lot for the quality of the report!\n> \n> I wonder if this should be qualified as \"Medium\", as duplicates of this issue are qualified as Medium. Even though the protocol could end up with funds left in the PSM, all users are treated the same way, and there is always the possibility to recover the funds and organize and airdrop / multisend.\n\n**[TrungOre (judge) decreased severity to Medium](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/292#issuecomment-1915328442)**\n\n**[btk (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/292#issuecomment-1923615247):**\n > @TrungOre - I believe that this issue should be a high because the `creditMultiplier` directly influences the value of CREDIT in the system. Using the incorrect method will lead to an inaccurate representation of the CREDIT value. Note that `creditMultiplier` can only decrease, and due to the current logical error, it's diminishing too quickly, resulting in direct losses for borrowers and holders.\n\n**[Soul22 (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/292#issuecomment-1923681426):**\n > I agree with @btk - this issue should be a high.\n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/292#issuecomment-1924740684):**\n > @eswak - Could you take a second look at this? Doesn't the `CreditToken.totalSupply()` return the **total number of the tokens in existence**? If a slashing event occurs, why would the  `creditMultiplier` need to consider the future rewards (`__unmintedRebaseRewards.targetValue`)? Aren't those tokens locked until a date in the future? Why would the slashing consider those future rewards in the present?\n >\n> Suppose a slashing occurs on day 2 of the reward's distribution, why would the rewards from day 3 to day 30 need to be considered as part of the existing supply? Is it not the purpose of the distribution of rewards to lock rewards and as time passes, slowly unlock them to be part of the existing supply?\n> \n> I think the value of the `creditMultiplier` is correctly calculated by using the amount of existing supply at the moment when the slashing event occurs. I reiterate again, why is a supply that is meant to be unlocked in the future would need to be considered in the present?\n> \n> I just want to emphasize, the `unmintedRewards` are indeed considered when reading from `CreditToken.totalSupply()`. Understanding that `unmintedRewards` are those rewards that have been unlocked based on the total time that has passed since they have been added to the distribution period. On the other hand, the future unminted rewards (`__unmintedRebaseRewards.targetValue`) are the ones that I believe should not be considered part of the supply in the present, because those rewards are yet to be slowly added to the supply in the future, not in the present.\n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/292#issuecomment-1924873976):**\n > I've taken a second look at the report and the problem seems to be a legit issue, if the undistributed rewards are not included as part of the existing supply at the moment of the slashing, that would bring down the `creditMultiplier` more than what it should. If all the undistributed rewards are included, this would cause that the PSM module has more PeggedTokens than what they could be claimed for using the total `CreditTokens` in existence.\n> \n> As for the severity, I think @eswak has a point in his comment (severity should be medium). All the funds that would've been left in the PSM could've been recovered and distributed to the users so they ended up equal as if the `creditMultiplier` would've been updated considering all the supply. The users would not lose their assets permanently, right? It would be a temporary loss while the extra funds are correctly distributed. It may take some extra work, but in the end, all users could get the exact amount of PeggedTokens they could've claimed if the `creditMultiplier` had been updated correctly. No PeggedTokens would be lost in reality and there would only be more PeggedTokens in the PSM module than the total PeggedTokens that could be claimed for. Thus, the extra tokens can be claimed by governance and distributed accordingly, making whole to all the users. \n>\n>TL:DR; no funds are lost, the extra tokens are left in the PSM module, and they can be claimed by governance and distributed accordingly.\n> \n> Plus, all new minting and borrowing, and basically everything, from that point onwards will use the new value of the `creditMultiplier`, even though it was brought down more than what it should. All the accounting from that point and beyond it will use the new value of the `creditMultiplier`.\n\n**[3docSec (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/292#issuecomment-1925138616):**\n > @0xStalin - the point of the credit multiplier update, and the goal of the math behind it, is to depreciate the synthetic versus the underlying so that:\n> - All synthetics are redeemable (solvency).\n> - When all synthetics are redeemed, the protocol does not hold value locked (correctness to users).\n> \n> This report proves how the second point is not respected, so value can remain locked in the protocol at the userâ€™s expense. This should be clear in the PoC but you are very right that I should have point it out in the report.\n> \n> @TrungOre - A few wardens suggested this finding could be high and I tend to agree with that because the remediation of a governance action suggested by the sponsor may in practice not always be feasible in terms of:\n> - Time to figure out a potentially large number of affected users and the exact extent of the loss for each of them.\n> - Preparing and having governance token holders review and vote a large proposal that includes an emergency action for each and every one of the affected users.\n> - The cost in terms of gas of executing such proposal and the \"always lost\" choice of whether refunding users whose loss is lower than the cost of gas to refund them.\n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/292#issuecomment-1925422169):**\n > @3docSec - For the points that you've just mentioned is exactly why this fits as a medium severity. Yes, it may take some extra work to governance for preparing the distribution of the extra PeggedTokens left in the PSM module. As for the second point, how much gas does it take to make an ERC20 transfer? Include it inside a batch of transfers, and how much would it cost to make full the user? Unless the user's difference was less than 1-2 usd then it might be more expensive to credit the difference, but even though, that is doable, that's the reason why this is fine as a medium severity. For a report to be classified as a high severity, there should be a permanent loss of funds, a way that it is impossible to recover them.\n\n**[btk (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/292#issuecomment-1925444794):**\n > @0xStalin, not all borrowers will redeem their credit in the PSM. Those holding credit during a loss will incur more losses than they should. Any thoughts on how governance can refund them? \n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/292#issuecomment-1925448437):**\n > @btk - Those incurred losses for the holders are exactly what it should be distributed by governance. As for the question of how could governance refund them, [The SimplePSM contract inherits from the CoreRef contract](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L25), [the CoreRef has the `emergencyAction()`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L107), governance can simply craft a calldata to transfer the extra PeggedTokens that needs to be distributed to the holders who were impacted by the `creditMultiplier` going down more than what it should. So, governance transfers those PeggedTokens to an account of their own, they collect the information of how many PeggedTokens need to be sent to who to cover the difference and then they do those transfers in batch. That's it, governance recovered the extra tokens and distributed them.\n> \n> That is because I consider this issue not to be a high severity. The tokens are not lost and they are not stuck forever in the PSM.\n\n**[TrungOre (judge) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/292#issuecomment-1934209560):**\n > I consider this issue as medium because it doesn't cause a direct loss to the protocol or users. As the sponsor stated, the protocol could end up with funds left in the PSM, but all users are treated the same way, and Governor can still recover the funds by `emergencyActions`.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/loan/SimplePSM.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice Simple PSM contract of the Ethereum Credit Guild, that allows mint/redeem\n/// of CREDIT token outside of lending terms & guarantee a stable peg of the CREDIT token\n/// around the value targeted by the protocol.\n/// The SimplePSM targets a value equal to ProfitManager.creditMultiplier(), so when bad\n/// debt is created and all loans are marked up, they stay the same in terms of peg token,\n/// because new CREDIT can be minted with fewer peg tokens from the PSM. Conversely, when\n/// new loans are issued, if there are funds available in the SimplePSM, borrowers know\n/// the amount of peg tokens they'll be able to redeem their borrowed CREDIT for.\n/// @dev inspired by the SimpleFeiDaiPSM used in the TribeDAO shutdown, see:\n/// - https://github.com/code-423n4/2022-09-tribe/blob/main/contracts/peg/SimpleFeiDaiPSM.sol\n/// - https://code4rena.com/reports/2022-09-tribe\ncontract SimplePSM is CoreRef {\n    using SafeERC20 for ERC20;\n\n    /// @notice reference to the ProfitManager contract\n    address public immutable profitManager;\n\n    /// @notice reference to the CreditToken contract\n    address public immutable credit;\n\n    /// @notice reference to the peg token contract\n    address public immutable pegToken;\n\n    /// @notice peg token balance, used to track sum of i/o and exclude donations.\n    /// invariant: pegToken.balanceOf(this) >= pegTokenBalance\n    uint256 public pegTokenBalance;\n\n    /// @notice multiplier for decimals correction, e.g. 1e12 for a pegToken\n    /// with 6 decimals (because CREDIT has 18 decimals)\n    uint256 public immutable decimalCorrection;\n\n    /// @notice true if the redemptions are currently paused\n    bool public redemptionsPaused;\n\n    /// @notice event emitted upon a redemption\n    event Redeem(\n        uint256 indexed when,\n        address indexed to,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    /// @notice event emitted when credit gets minted\n    event Mint(\n        uint256 indexed when,\n        address indexed to,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    /// @notice event emitted when redemption pausability status changes\n    event RedemptionsPaused(uint256 indexed when, bool status);\n\n    constructor(\n        address _core,\n        address _profitManager,\n        address _credit,\n        address _pegToken\n    ) CoreRef(_core) {\n        profitManager = _profitManager;\n        credit = _credit;\n        pegToken = _pegToken;\n\n        uint256 decimals = uint256(ERC20(_pegToken).decimals());\n        decimalCorrection = 10 ** (18 - decimals);\n    }\n\n    /// @notice calculate the amount of CREDIT out for a given `amountIn` of underlying\n    function getMintAmountOut(uint256 amountIn) public view returns (uint256) {\n        uint256 creditMultiplier = ProfitManager(profitManager)\n            .creditMultiplier();\n        return (amountIn * decimalCorrection * 1e18) / creditMultiplier;\n    }\n\n    /// @notice calculate the amount of underlying out for a given `amountIn` of CREDIT\n    function getRedeemAmountOut(\n        uint256 amountIn\n    ) public view returns (uint256) {\n        uint256 creditMultiplier = ProfitManager(profitManager)\n            .creditMultiplier();\n        return (amountIn * creditMultiplier) / 1e18 / decimalCorrection;\n    }\n\n    /// @notice calculate the total number of CREDIT that can be redeemed\n    /// at the moment, based on the pegTokenBalance.\n    function redeemableCredit() public view returns (uint256) {\n        return getMintAmountOut(pegTokenBalance);\n    }\n\n    /// @notice mint `amountOut` CREDIT to address `to` for `amountIn` underlying tokens\n    /// @dev see getMintAmountOut() to pre-calculate amount out\n    function mint(\n        address to,\n        uint256 amountIn\n    ) external whenNotPaused returns (uint256 amountOut) {\n        amountOut = getMintAmountOut(amountIn);\n        pegTokenBalance += amountIn;\n        ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);\n        CreditToken(credit).mint(to, amountOut);\n        emit Mint(block.timestamp, to, amountIn, amountOut);\n    }\n\n    /// @notice mint `amountOut` CREDIT to `msg.sender` for `amountIn` underlying tokens\n    /// and enter rebase to earn the savings rate.\n    /// @dev see getMintAmountOut() to pre-calculate amount out\n    function mintAndEnterRebase(\n        uint256 amountIn\n    ) external whenNotPaused returns (uint256 amountOut) {\n        require(\n            !CreditToken(credit).isRebasing(msg.sender),\n            \"SimplePSM: already rebasing\"\n        );\n        amountOut = getMintAmountOut(amountIn);\n        pegTokenBalance += amountIn;\n        ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);\n        CreditToken(credit).mint(msg.sender, amountOut);\n        CreditToken(credit).forceEnterRebase(msg.sender);\n        emit Mint(block.timestamp, msg.sender, amountIn, amountOut);\n    }\n\n    /// @notice redeem `amountIn` CREDIT for `amountOut` underlying tokens and send to address `to`\n    /// @dev see getRedeemAmountOut() to pre-calculate amount out\n    function redeem(\n        address to,\n        uint256 amountIn\n    ) external returns (uint256 amountOut) {\n        require(!redemptionsPaused, \"SimplePSM: redemptions paused\");\n        amountOut = getRedeemAmountOut(amountIn);\n        CreditToken(credit).burnFrom(msg.sender, amountIn);\n        pegTokenBalance -= amountOut;\n        ERC20(pegToken).safeTransfer(to, amountOut);\n        emit Redeem(block.timestamp, to, amountIn, amountOut);\n    }\n\n    /// @notice set `redemptionsPaused`\n    /// governor-only, to allow full governance to update the psm mechanisms,\n    /// or automated processes to pause redemptions under certain conditions.\n    function setRedemptionsPaused(\n        bool paused\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        redemptionsPaused = paused;\n        emit RedemptionsPaused(block.timestamp, paused);\n    }\n}"
    }
  ]
}