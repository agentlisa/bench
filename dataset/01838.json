{
  "Title": "H-1: Stale inflationMultiplier in L1ECOBridge",
  "Content": "# Issue H-1: Stale inflationMultiplier in L1ECOBridge \n\nSource: https://github.com/sherlock-audit/2023-05-ecoprotocol-judging/issues/126 \n\n## Found by \n0xRobocop, Dug, GimelSec, J4de, n33k, nobody2018, toshii\n## Summary \n\n`L1ECOBridge::inflationMultiplier` is updated through `L1ECOBridge::rebase` on Ethereum, and it is used in `_initiateERC20Deposit` and `finalizeERC20Withdrawal` to convert between token amount and `_gonsAmount`. However, if `rebase` is not called in a timely manner, the `inflationMultiplier` value can be stale and inconsistent with the value of L1 ECO token during transfer, leading to incorrect token amounts in deposit and withdraw.\n\n## Vulnerability Detail\n\nThe `inflationMultiplier` value is updated in `rebase` with an independent transaction on L1 as shown below:\n\n```solidity\n    function rebase(uint32 _l2Gas) external {\n        inflationMultiplier = IECO(l1Eco).getPastLinearInflation(block.number);\n```\n\nHowever, in both `_initiateERC20Deposit`, `transferFrom` is called before the `inflationMultiplier` is used, which can lead to inconsistent results if `rebase` is not called on time for the `inflationMultiplier` to be updated. The code snippet for `_initiateERC20Deposit` is as follows:\n\n```solidity\n        IECO(_l1Token).transferFrom(_from, address(this), _amount);\n        _amount = _amount * inflationMultiplier;\n```\n`finalizeERC20Withdrawal` has the same problem.\n\n```solidity\n        uint256 _amount = _gonsAmount / inflationMultiplier;\n        bytes memory _ecoTransferMessage = abi.encodeWithSelector(IERC20.transfer.selector,_to,_amount);\n```\n\nThe same problem does not exist in L2ECOBridge. Because the L2 rebase function updates inflationMultiplier and rebase l2Eco token synchronously.\n\n```solidity\n    function rebase(uint256 _inflationMultiplier)\n        external\n        virtual\n        onlyFromCrossDomainAccount(l1TokenBridge)\n        validRebaseMultiplier(_inflationMultiplier)\n    {\n        inflationMultiplier = _inflationMultiplier;\n        l2Eco.rebase(_inflationMultiplier);\n        emit RebaseInitiated(_inflationMultiplier);\n    }\n```\n\n## Impact\n\nThe attacker can steal tokens with this.\n\nHe can deposit to L1 bridge when he observes a stale larger value and he will receive more tokens on L2.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-ecoprotocol/blob/main/op-eco/contracts/bridge/L1ECOBridge.sol#L244-L251\n\nhttps://github.com/sherlock-audit/2023-05-ecoprotocol/blob/main/op-eco/contracts/bridge/L1ECOBridge.sol#L333-L335\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCalling `IECO(l1Eco).getPastLinearInflation(block.number)` instead of using `inflationMultiplier`.\n\n\n\n\n## Discussion\n\n**syjcnss**\n\nEscalate for 10 USDC.\n\nThis is different from #52 which is about desynced inflationMultiplier between L1&L2 bridges.\n\n#17, #83, #110 and #126 are about desynced inflationMultiplier between the L1ECOBridge and the L1 ECO token.\n\nIn L1, the actually transfered gos amount will be different from the gos amount deposited if the inflationMultiplier is stale and not updated by calling rebase. This has nothing to do with the L2 inflationMultiplier.\n\n```solidity\nbridge/L1ECOBridge.sol:_initiateERC20Deposit\n\nIECO(_l1Token).transferFrom(_from, address(this), _amount);    // <- transfer underlying gos amount(_amount * 'inflationMultiplier' inside the L1 ECO token) of tokens to deposit\n_amount = _amount * inflationMultiplier;  // <- record a wrong gos deposited token amount if inflationMultiplier is stale\n```\n\nIn the [PoC](\nhttps://github.com/sherlock-audit/2023-05-ecoprotocol-judging/issues/52#issuecomment-1572906790), @albertnbrown proves that a desynced inflationMultiplier between L1&L2 bridges does not cause a problem. The PoC has a synced value between L1ECOBridge and the L1 ECO token at desposit because the constructor initiated inflationMultiplier with IECO(l1Eco).getPastLinearInflation(block.number). So it doesn't invalidate this issue.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> This is different from #52 which is about desynced inflationMultiplier between L1&L2 bridges.\n> \n> #17, #83, #110 and #126 are about desynced inflationMultiplier between the L1ECOBridge and the L1 ECO token.\n> \n> In L1, the actually transfered gos amount will be different from the gos amount deposited if the inflationMultiplier is stale and not updated by calling rebase. This has nothing to do with the L2 inflationMultiplier.\n> \n> ```solidity\n> bridge/L1ECOBridge.sol:_initiateERC20Deposit\n> \n> IECO(_l1Token).transferFrom(_from, address(this), _amount);    // <- transfer underlying gos amount(_amount * 'inflationMultiplier' inside the L1 ECO token) of tokens to deposit\n> _amount = _amount * inflationMultiplier;  // <- record a wrong gos deposited token amount if inflationMultiplier is stale\n> ```\n> \n> In the [PoC](\n> https://github.com/sherlock-audit/2023-05-ecoprotocol-judging/issues/52#issuecomment-1572906790), @albertnbrown proves that a desynced inflationMultiplier between L1&L2 bridges does not cause a problem. The PoC has a synced value between L1ECOBridge and the L1 ECO token at desposit because the constructor initiated inflationMultiplier with IECO(l1Eco).getPastLinearInflation(block.number). So it doesn't invalidate this issue.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**albertnbrown**\n\nThis is a legitimate high issue and we found it and addressed it on our own already, but were having trouble looking through the duplicates for #52 for issues like this to correctly reward them. Thanks for escalating it for visibility.\n\n**albertnbrown**\n\nWe fixed this here https://github.com/eco-association/op-eco/pull/40\n\n**ctf-sec**\n\nI agree with \n\n> This is different from https://github.com/sherlock-audit/2023-05-ecoprotocol-judging/issues/52 which is about desynced inflationMultiplier between L1&L2 bridges.\n\nhttps://github.com/sherlock-audit/2023-05-ecoprotocol-judging/issues/17, https://github.com/sherlock-audit/2023-05-ecoprotocol-judging/issues/83, https://github.com/sherlock-audit/2023-05-ecoprotocol-judging/issues/110 and https://github.com/sherlock-audit/2023-05-ecoprotocol-judging/issues/126 are about desynced inflationMultiplier between the L1ECOBridge and the L1 ECO token.\n\nwhile this is the context read me\n![image](https://github.com/sherlock-audit/2023-05-ecoprotocol-judging/assets/114844362/3e013124-0f41-4385-8bd1-5f51fc547e50)\n\n#17, #83, #110 and #126 and #13\n\nare all duplicate of #126, can mark as high severity\n\n\n**hrishibhat**\n\nEscalation accepted\n\nValid high \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid high \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.\n\n**0xffff11**\n\nApproved fix in: https://github.com/eco-association/op-eco/pull/40\n\n\n**0xffff11**\n\nFixed confirmed. Using the token inflationMultiplier  instead of the bridge inflationMultiplier\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/80",
  "Code": [
    {
      "filename": "op-eco/contracts/bridge/L1ECOBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/* Interface Imports */\nimport {IL1ECOBridge} from \"../interfaces/bridge/IL1ECOBridge.sol\";\nimport {IL1ERC20Bridge} from \"@eth-optimism/contracts/L1/messaging/IL1ERC20Bridge.sol\";\nimport {IL2ECOBridge} from \"../interfaces/bridge/IL2ECOBridge.sol\";\nimport {IL2ERC20Bridge} from \"@eth-optimism/contracts/L2/messaging/IL2ERC20Bridge.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IECO} from \"@helix-foundation/currency/contracts/currency/IECO.sol\";\nimport {ITransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n/* Contract Imports */\nimport {CrossDomainEnabledUpgradeable} from \"./CrossDomainEnabledUpgradeable.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\n/**\n * @title L1ECOBridge\n * @dev The L1 ECO Bridge is a contract which stores deposited L1 ECO\n * that is in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits\n * and listening to it for newly finalized withdrawals.\n * It also acts as the authorized source of L1 governance decisions as seen by the L2.\n * All governance related data and decisions are passed through this contract so that the\n * L2 contracts can maintain and trust a single source of L1 messages.\n */\ncontract L1ECOBridge is IL1ECOBridge, CrossDomainEnabledUpgradeable {\n    /**\n     * @dev L2 side of the bridge\n     */\n    address public l2TokenBridge;\n\n    /**\n     * @dev L1 ECO address\n     */\n    address public l1Eco;\n\n    /**\n     * @dev L2 ECO address\n     */\n    address public l2Eco;\n\n    /**\n     * @dev L1 proxy admin that manages this proxy contract\n     */\n    ProxyAdmin public l1ProxyAdmin;\n\n    /**\n     * @dev L2 upgrader role\n     */\n    address public upgrader;\n\n    /**\n     * @dev Current inflation multiplier\n     */\n    uint256 public inflationMultiplier;\n\n    /**\n     * @dev Modifier requiring sender to be EOA.  This check could be bypassed by a malicious\n     * contract via initcode, but it takes care of the user error we want to avoid.\n     */\n    modifier onlyEOA() {\n        // Used to stop deposits from contracts (avoid accidentally lost tokens)\n        require(msg.sender.code.length == 0, \"L1ECOBridge: Account not EOA\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check that the L1 token is the same as the one set in the constructor\n     * @param _l1Token L1 token address to check\n     */\n    modifier isL1EcoToken(address _l1Token) {\n        require(\n            _l1Token == l1Eco,\n            \"L1ECOBridge: invalid L2 token address\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to check that the L2 token is the same as the one set in the constructor\n     * @param _l2Token L2 token address to check\n     */\n    modifier isL2EcoToken(address _l2Token) {\n        require(\n            _l2Token == l2Eco,\n            \"L1ECOBridge: invalid L2 token address\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier for gating upgrade functionality behind an authorized ECO protocol governace contract\n     */\n    modifier onlyUpgrader() {\n        require(\n            msg.sender == upgrader,\n            \"L1ECOBridge: caller not authorized to upgrade L2 contracts.\"\n        );\n        _;\n    }\n\n    /**\n     * Disable the implementation contract\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     */\n    function initialize(\n        address _l1messenger,\n        address _l2TokenBridge,\n        address _l1Eco,\n        address _l2Eco,\n        address _l1ProxyAdmin,\n        address _upgrader\n    ) public initializer {\n        CrossDomainEnabledUpgradeable.__CrossDomainEnabledUpgradeable_init(\n            _l1messenger\n        );\n        l2TokenBridge = _l2TokenBridge;\n        l1Eco = _l1Eco;\n        l2Eco = _l2Eco;\n        l1ProxyAdmin = ProxyAdmin(_l1ProxyAdmin);\n        upgrader = _upgrader;\n        inflationMultiplier = IECO(_l1Eco).getPastLinearInflation(\n            block.number\n        );\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeECO(address _impl, uint32 _l2Gas)\n        external\n        virtual\n        onlyUpgrader\n    {\n        bytes memory message = abi.encodeWithSelector(\n            IL2ECOBridge.upgradeECO.selector,\n            _impl\n        );\n\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n        emit UpgradeL2ECO(_impl);\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeL2Bridge(address _impl, uint32 _l2Gas)\n        external\n        virtual\n        onlyUpgrader\n    {\n        bytes memory message = abi.encodeWithSelector(\n            IL2ECOBridge.upgradeSelf.selector,\n            _impl\n        );\n\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n        emit UpgradeL2Bridge(_impl);\n    }\n\n     /**\n     * @inheritdoc IL1ECOBridge\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeSelf(address _newBridgeImpl) external virtual onlyUpgrader {\n        //cast to a payable address since l2EcoToken is the proxy address of a ITransparentUpgradeableProxy contract\n        address payable proxyAddr = payable(address(this));\n\n        ITransparentUpgradeableProxy proxy = ITransparentUpgradeableProxy(\n            proxyAddr\n        );\n        l1ProxyAdmin.upgrade(proxy, _newBridgeImpl);\n\n        emit UpgradeSelf(_newBridgeImpl);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     * @param _l1Token must be the ECO L1 token address.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual onlyEOA isL1EcoToken(_l1Token) isL2EcoToken(_l2Token) {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _l2Gas,\n            _data\n        );\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     * @param _l1Token must be the ECO L1 token address.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual isL1EcoToken(_l1Token) isL2EcoToken(_l2Token) {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            _to,\n            _amount,\n            _l2Gas,\n            _data\n        );\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     * @param _l1Token is always the ECO L1 token address.\n     * @param _l2Token is always the ECO L2 token address.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _gonsAmount,\n        bytes calldata _data\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {\n        uint256 _amount = _gonsAmount / inflationMultiplier;\n\n        // equivalent to IECO(_l1Token).transfer(_to, _amount); but is revert safe\n        bytes memory _ecoTransferMessage = abi.encodeWithSelector(\n            IERC20.transfer.selector,\n            _to,\n            _amount\n        );\n        (bool success, bytes memory returnData) = _l1Token.call{value: 0}(\n            _ecoTransferMessage\n        );\n\n        // make sure that the call to transfer didn't revert or return false\n        if (success && abi.decode(returnData, (bool))) {\n            // if successful, emit an event\n            emit ERC20WithdrawalFinalized(\n                _l1Token,\n                _l2Token,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        } else {\n            // if the transfer fails, create a return tx\n            bytes memory message = abi.encodeWithSelector(\n                IL2ERC20Bridge.finalizeDeposit.selector,\n                _l1Token,\n                _l2Token,\n                _to, // switched the _to and _from here to bounce back the deposit to the sender\n                _from,\n                _gonsAmount,\n                _data\n            );\n\n            // Send message up to L1 bridge\n            sendCrossDomainMessage(l2TokenBridge, 0, message);\n            // Emit an event to signal success event listeners to expect failure\n            emit WithdrawalFailed(\n                _l1Token,\n                _l2Token,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        }\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     */\n    function rebase(uint32 _l2Gas) external {\n        inflationMultiplier = IECO(l1Eco).getPastLinearInflation(\n            block.number\n        );\n\n        bytes memory message = abi.encodeWithSelector(\n            IL2ECOBridge.rebase.selector,\n            inflationMultiplier\n        );\n\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by informing the L2 ECO token\n     * contract of the deposit and pulling in the L1 funds from the depositor\n     *\n     * @param _l1Token Address of the L1 ECO token contract\n     * @param _l2Token Address of the L2 ECO token contract\n     * @param _from Account to pull the deposit from on L1\n     * @param _to Account to give the deposit to on L2\n     * @param _amount Amount of ECO being deposited.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2.\n     */\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) internal {\n        // When a deposit is initiated on L1, the L1 Bridge transfers the funds to itself for future\n        // withdrawals.\n\n        IECO(_l1Token).transferFrom(_from, address(this), _amount);\n        // gons move across the bridge, with inflation multipliers on either side to correctly scale balances\n        _amount = _amount * inflationMultiplier;\n\n        // Construct calldata for _l2Token.finalizeDeposit(_to, _amount)\n        bytes memory message = abi.encodeWithSelector(\n            //call parent interface IL2ERC20Bridge to get the selector\n            IL2ERC20Bridge.finalizeDeposit.selector,\n            _l1Token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _data\n        );\n\n        // Send calldata into L2\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n\n        emit ERC20DepositInitiated(\n            _l1Token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _data\n        );\n    }\n}"
    },
    {
      "filename": "op-eco/contracts/bridge/L1ECOBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/* Interface Imports */\nimport {IL1ECOBridge} from \"../interfaces/bridge/IL1ECOBridge.sol\";\nimport {IL1ERC20Bridge} from \"@eth-optimism/contracts/L1/messaging/IL1ERC20Bridge.sol\";\nimport {IL2ECOBridge} from \"../interfaces/bridge/IL2ECOBridge.sol\";\nimport {IL2ERC20Bridge} from \"@eth-optimism/contracts/L2/messaging/IL2ERC20Bridge.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IECO} from \"@helix-foundation/currency/contracts/currency/IECO.sol\";\nimport {ITransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n/* Contract Imports */\nimport {CrossDomainEnabledUpgradeable} from \"./CrossDomainEnabledUpgradeable.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\n/**\n * @title L1ECOBridge\n * @dev The L1 ECO Bridge is a contract which stores deposited L1 ECO\n * that is in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits\n * and listening to it for newly finalized withdrawals.\n * It also acts as the authorized source of L1 governance decisions as seen by the L2.\n * All governance related data and decisions are passed through this contract so that the\n * L2 contracts can maintain and trust a single source of L1 messages.\n */\ncontract L1ECOBridge is IL1ECOBridge, CrossDomainEnabledUpgradeable {\n    /**\n     * @dev L2 side of the bridge\n     */\n    address public l2TokenBridge;\n\n    /**\n     * @dev L1 ECO address\n     */\n    address public l1Eco;\n\n    /**\n     * @dev L2 ECO address\n     */\n    address public l2Eco;\n\n    /**\n     * @dev L1 proxy admin that manages this proxy contract\n     */\n    ProxyAdmin public l1ProxyAdmin;\n\n    /**\n     * @dev L2 upgrader role\n     */\n    address public upgrader;\n\n    /**\n     * @dev Current inflation multiplier\n     */\n    uint256 public inflationMultiplier;\n\n    /**\n     * @dev Modifier requiring sender to be EOA.  This check could be bypassed by a malicious\n     * contract via initcode, but it takes care of the user error we want to avoid.\n     */\n    modifier onlyEOA() {\n        // Used to stop deposits from contracts (avoid accidentally lost tokens)\n        require(msg.sender.code.length == 0, \"L1ECOBridge: Account not EOA\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check that the L1 token is the same as the one set in the constructor\n     * @param _l1Token L1 token address to check\n     */\n    modifier isL1EcoToken(address _l1Token) {\n        require(\n            _l1Token == l1Eco,\n            \"L1ECOBridge: invalid L2 token address\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to check that the L2 token is the same as the one set in the constructor\n     * @param _l2Token L2 token address to check\n     */\n    modifier isL2EcoToken(address _l2Token) {\n        require(\n            _l2Token == l2Eco,\n            \"L1ECOBridge: invalid L2 token address\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier for gating upgrade functionality behind an authorized ECO protocol governace contract\n     */\n    modifier onlyUpgrader() {\n        require(\n            msg.sender == upgrader,\n            \"L1ECOBridge: caller not authorized to upgrade L2 contracts.\"\n        );\n        _;\n    }\n\n    /**\n     * Disable the implementation contract\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     */\n    function initialize(\n        address _l1messenger,\n        address _l2TokenBridge,\n        address _l1Eco,\n        address _l2Eco,\n        address _l1ProxyAdmin,\n        address _upgrader\n    ) public initializer {\n        CrossDomainEnabledUpgradeable.__CrossDomainEnabledUpgradeable_init(\n            _l1messenger\n        );\n        l2TokenBridge = _l2TokenBridge;\n        l1Eco = _l1Eco;\n        l2Eco = _l2Eco;\n        l1ProxyAdmin = ProxyAdmin(_l1ProxyAdmin);\n        upgrader = _upgrader;\n        inflationMultiplier = IECO(_l1Eco).getPastLinearInflation(\n            block.number\n        );\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeECO(address _impl, uint32 _l2Gas)\n        external\n        virtual\n        onlyUpgrader\n    {\n        bytes memory message = abi.encodeWithSelector(\n            IL2ECOBridge.upgradeECO.selector,\n            _impl\n        );\n\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n        emit UpgradeL2ECO(_impl);\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeL2Bridge(address _impl, uint32 _l2Gas)\n        external\n        virtual\n        onlyUpgrader\n    {\n        bytes memory message = abi.encodeWithSelector(\n            IL2ECOBridge.upgradeSelf.selector,\n            _impl\n        );\n\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n        emit UpgradeL2Bridge(_impl);\n    }\n\n     /**\n     * @inheritdoc IL1ECOBridge\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeSelf(address _newBridgeImpl) external virtual onlyUpgrader {\n        //cast to a payable address since l2EcoToken is the proxy address of a ITransparentUpgradeableProxy contract\n        address payable proxyAddr = payable(address(this));\n\n        ITransparentUpgradeableProxy proxy = ITransparentUpgradeableProxy(\n            proxyAddr\n        );\n        l1ProxyAdmin.upgrade(proxy, _newBridgeImpl);\n\n        emit UpgradeSelf(_newBridgeImpl);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     * @param _l1Token must be the ECO L1 token address.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual onlyEOA isL1EcoToken(_l1Token) isL2EcoToken(_l2Token) {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _l2Gas,\n            _data\n        );\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     * @param _l1Token must be the ECO L1 token address.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual isL1EcoToken(_l1Token) isL2EcoToken(_l2Token) {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            _to,\n            _amount,\n            _l2Gas,\n            _data\n        );\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     * @param _l1Token is always the ECO L1 token address.\n     * @param _l2Token is always the ECO L2 token address.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _gonsAmount,\n        bytes calldata _data\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {\n        uint256 _amount = _gonsAmount / inflationMultiplier;\n\n        // equivalent to IECO(_l1Token).transfer(_to, _amount); but is revert safe\n        bytes memory _ecoTransferMessage = abi.encodeWithSelector(\n            IERC20.transfer.selector,\n            _to,\n            _amount\n        );\n        (bool success, bytes memory returnData) = _l1Token.call{value: 0}(\n            _ecoTransferMessage\n        );\n\n        // make sure that the call to transfer didn't revert or return false\n        if (success && abi.decode(returnData, (bool))) {\n            // if successful, emit an event\n            emit ERC20WithdrawalFinalized(\n                _l1Token,\n                _l2Token,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        } else {\n            // if the transfer fails, create a return tx\n            bytes memory message = abi.encodeWithSelector(\n                IL2ERC20Bridge.finalizeDeposit.selector,\n                _l1Token,\n                _l2Token,\n                _to, // switched the _to and _from here to bounce back the deposit to the sender\n                _from,\n                _gonsAmount,\n                _data\n            );\n\n            // Send message up to L1 bridge\n            sendCrossDomainMessage(l2TokenBridge, 0, message);\n            // Emit an event to signal success event listeners to expect failure\n            emit WithdrawalFailed(\n                _l1Token,\n                _l2Token,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        }\n    }\n\n    /**\n     * @inheritdoc IL1ECOBridge\n     */\n    function rebase(uint32 _l2Gas) external {\n        inflationMultiplier = IECO(l1Eco).getPastLinearInflation(\n            block.number\n        );\n\n        bytes memory message = abi.encodeWithSelector(\n            IL2ECOBridge.rebase.selector,\n            inflationMultiplier\n        );\n\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by informing the L2 ECO token\n     * contract of the deposit and pulling in the L1 funds from the depositor\n     *\n     * @param _l1Token Address of the L1 ECO token contract\n     * @param _l2Token Address of the L2 ECO token contract\n     * @param _from Account to pull the deposit from on L1\n     * @param _to Account to give the deposit to on L2\n     * @param _amount Amount of ECO being deposited.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2.\n     */\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) internal {\n        // When a deposit is initiated on L1, the L1 Bridge transfers the funds to itself for future\n        // withdrawals.\n\n        IECO(_l1Token).transferFrom(_from, address(this), _amount);\n        // gons move across the bridge, with inflation multipliers on either side to correctly scale balances\n        _amount = _amount * inflationMultiplier;\n\n        // Construct calldata for _l2Token.finalizeDeposit(_to, _amount)\n        bytes memory message = abi.encodeWithSelector(\n            //call parent interface IL2ERC20Bridge to get the selector\n            IL2ERC20Bridge.finalizeDeposit.selector,\n            _l1Token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _data\n        );\n\n        // Send calldata into L2\n        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n\n        emit ERC20DepositInitiated(\n            _l1Token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _data\n        );\n    }\n}"
    }
  ]
}