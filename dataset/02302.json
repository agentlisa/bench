{
  "Title": "H-3: Signers can bypass checks to add new modules to a safe by abusing reentrancy",
  "Content": "# Issue H-3: Signers can bypass checks to add new modules to a safe by abusing reentrancy \n\nSource: https://github.com/sherlock-audit/2023-02-hats-judging/issues/41 \n\n## Found by \nobront, roguereddwarf\n\n## Summary\n\nThe `checkAfterExecution()` function has checks to ensure that new modules cannot be added by signers. This is a crucial check, because adding a new module could give them unlimited power to make any changes (with no guards in place) in the future. However, by abusing reentrancy, the parameters used by the check can be changed so that this crucial restriction is violated.\n\n## Vulnerability Detail\n\nThe `checkAfterExecution()` is intended to uphold important invariants after each signer transaction is completed. This is intended to restrict certain dangerous signer behaviors, the most important of which is adding new modules. This was an issue caught in the previous audit and fixed by comparing the hash of the modules before execution to the has of the modules after.\n\nBefore:\n```solidity\n(address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n_existingModulesHash = keccak256(abi.encode(modules));\n```\n\nAfter:\n```solidity\n(address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\nif (keccak256(abi.encode(modules)) != _existingModulesHash) {\n    revert SignersCannotChangeModules();\n}\n```\nThis is further emphasized in the comments, where it is specified:\n\n> /// @notice Post-flight check to prevent `safe` signers from removing this contract guard, changing any modules, or changing the threshold\n\n### Why Restricting Modules is Important\n\nModules are the most important thing to check. This is because modules have unlimited power not only to execute transactions but to skip checks in the future. Creating an arbitrary new module is so bad that it is equivalent to the other two issues together: getting complete control over the safe (as if threshold was set to 1) and removing the guard (because they aren't checked in module transactions).\n\nHowever, this important restriction can be violated by abusing reentrancy into this function.\n\n### Reentrancy Disfunction\n\nTo see how this is possible, we first have to take a quick detour regarding reentrancy. It appears that the protocol is attempting to guard against reentrancy with the `guardEntries` variable. It is incremented in `checkTransaction()` (before a transaction is executed) and decremented in `checkAfterExecution()` (after the transaction has completed).\n\nThe only protection it provides is in its risk of underflowing, explained in the comments as:\n\n> // leave checked to catch underflows triggered by re-erntry attempts\n\nHowever, any attempt to reenter and send an additional transaction midstream of another transaction would first trigger the `checkTransaction()` function. This would increment `_guardEntries` and would lead to it not underflowing.\n\nIn order for this system to work correctly, the `checkTransaction()` function should simply set `_guardEntries = 1`. This would result in an underflow with the second decrement. But, as it is currently designed, there is no reentrancy protection.\n\n### Using Reentrancy to Bypass Module Check\n\nRemember that the module invariant is upheld by taking a snapshot of the hash of the modules in `checkTransaction()` and saving it in the `_existingModulesHash` variable.\n\nHowever, imagine the following set of transactions:\n- Signers send a transaction via the safe, and modules are snapshotted to `_existingModulesHash`\n- The transaction uses the Multicall functionality of the safe, and performs the following actions:\n- First, it adds the malicious module to the safe\n- Then, it calls `execTransaction()` on itself with any another transaction\n- The second call will call `checkTransaction()`\n- This will update `_existingModulesHash` to the new list of modules, including the malicious one\n- The second call will execute, which doesn't matter (could just be an empty transaction)\n- After the transaction, `checkAfterExecution()` will be called, and the modules will match\n- After the full transaction is complete, `checkAfterExecution()` will be called for the first transaction, but since `_existingModulesHash` will be overwritten, the module check will pass\n\n## Impact\n\nAny number of signers who are above the threshold will be able to give themselves unlimited access over the safe with no restriction going forward.\n\n## Code Snippet\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L495-L498\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L522-L525\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a more typical reentrancy guard format, such as checking to ensure `_guardEntries == 0` at the top of `checkTransaction()` or simply setting `_guardEntries = 1` in `checkTransaction()` instead of incrementing it.\n\n## Discussion\n\n**zobront**\n\nEscalate for 10 USDC\n\nTo successfully duplicate a High Severity issue, it is required for an issue to meet a burden of proof of understanding the exploit. \n\n#67 clearly meets this burden of proof. It explains the same exploit described in this report and deserves to be duplicated with it.\n\n#105 and #124 do not explain any exploit. They simply noticed that the reentrancy guard wouldn't work, couldn't find a way to take advantage of that, and submitted it without a way to use it. \n\nMy recommendation is that they are not valid issues, but at the very least they should be moved to a separate Medium issue to account for the fact that they did not find a High Severity exploit.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> To successfully duplicate a High Severity issue, it is required for an issue to meet a burden of proof of understanding the exploit. \n> \n> #67 clearly meets this burden of proof. It explains the same exploit described in this report and deserves to be duplicated with it.\n> \n> #105 and #124 do not explain any exploit. They simply noticed that the reentrancy guard wouldn't work, couldn't find a way to take advantage of that, and submitted it without a way to use it. \n> \n> My recommendation is that they are not valid issues, but at the very least they should be moved to a separate Medium issue to account for the fact that they did not find a High Severity exploit.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cducrest**\n\nIt's a bit ambitious to have 4 issues describing the same line of codes as incorrect / vulnerable not being marked as duplicate, especially when they provide the same recommendation. I feel like going into such depths to describe the impact may not be necessary to ensure the safety of the protocol. \n\nHowever, I agree that it can also feel weird that we would be awarded the same while your issue provides much more details. I could not find anything in the Sherlock docs pertaining to this situation, but maybe there should be a reward for the best issue describing a vulnerability.\n\nWhen first submitting these issues, I feel like I may take the risk that the issue is treated as medium / low by not providing enough details. Perhaps are you already awarded for having provided such details by ensuring your issue is considered valid?\n\n**hrishibhat**\n\nEscalation accepted\n\nGiven that issues #41 & #67 have identified a valid attack path, considering #105 & #124 as a medium as it identifies underlying re-entrancy issue. \n\nNote: Sherlock will make note of the above comments and discuss internally to add additional instructions in the guide to help resolve such scenarios in the future.\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Given that issues #41 & #67 have identified a valid attack path, considering #105 & #124 as a medium as it identifies underlying re-entrancy issue. \n> \n> Note: Sherlock will make note of the above comments and discuss internally to add additional instructions in the guide to help resolve such scenarios in the future.\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/48",
  "Code": [
    {
      "filename": "src/HatsSignerGateBase.sol",
      "content": "// SPDX-License-Identifier: CC0\npragma solidity >=0.8.13;\n\nimport { Test, console2 } from \"forge-std/Test.sol\"; // remove after testing\nimport \"./HSGLib.sol\";\nimport { HatsOwnedInitializable } from \"hats-auth/HatsOwnedInitializable.sol\";\nimport { BaseGuard } from \"zodiac/guard/BaseGuard.sol\";\nimport { IAvatar } from \"zodiac/interfaces/IAvatar.sol\";\nimport { StorageAccessible } from \"@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol\";\nimport { IGnosisSafe, Enum } from \"./Interfaces/IGnosisSafe.sol\";\nimport { SignatureDecoder } from \"@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol\";\n\nabstract contract HatsSignerGateBase is BaseGuard, SignatureDecoder, HatsOwnedInitializable {\n    /// @notice The multisig to which this contract is attached\n    IGnosisSafe public safe;\n\n    /// @notice The minimum signature threshold for the `safe`\n    uint256 public minThreshold;\n\n    /// @notice The highest level signature threshold for the `safe`\n    uint256 public targetThreshold;\n\n    /// @notice The maximum number of signers allowed for the `safe`\n    uint256 public maxSigners;\n\n    /// @notice The current number of signers on the `safe`\n    uint256 public signerCount;\n\n    /// @notice The version of HatsSignerGate used in this contract\n    string public version;\n\n    /// @notice The number of modules enabled on the `safe`, as enabled via this contract\n    uint256 public enabledModuleCount;\n\n    /// @dev Temporary record of the existing modules on the `safe` when a transaction is submitted\n    bytes32 internal _existingModulesHash;\n    \n    /// @dev A simple re-entrency guard\n    uint256 internal _guardEntries;\n\n    /// @dev The head pointer used in the GnosisSafe owners linked list, as well as the module linked list\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    /// @dev The storage slot used by GnosisSafe to store the guard address\n    ///      keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Makes the singleton unusable by setting its owner to the 1-address\n    constructor() payable initializer {\n        _HatsOwned_init(1, address(0x1));\n    }\n\n    /// @notice Initializes a new instance\n    /// @dev Can only be called once\n    /// @param initializeParams ABI-encoded bytes with initialization parameters\n    function setUp(bytes calldata initializeParams) public payable virtual initializer { }\n\n    /// @notice Internal function to initialize a new instance\n    /// @param _ownerHatId The hat id of the hat that owns this instance of HatsSignerGate\n    /// @param _safe The multisig to which this instance of HatsSignerGate is attached\n    /// @param _hats The Hats Protocol address\n    /// @param _minThreshold The minimum threshold for the `_safe`\n    /// @param _targetThreshold The maxium threshold for the `_safe`\n    /// @param _maxSigners The maximum number of signers allowed on the `_safe`\n    /// @param _version The current version of HatsSignerGate\n    function _setUp(\n        uint256 _ownerHatId,\n        address _safe,\n        address _hats,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners,\n        string memory _version,\n        uint256 _existingModuleCount\n    ) internal {\n        _HatsOwned_init(_ownerHatId, _hats);\n        maxSigners = _maxSigners;\n        safe = IGnosisSafe(_safe);\n\n        _setTargetThreshold(_targetThreshold);\n        _setMinThreshold(_minThreshold);\n        version = _version;\n        enabledModuleCount = _existingModuleCount + 1; // this contract is enabled as well\n    }\n\n    /// @notice Checks if `_account` is a valid signer\n    /// @dev Must be implemented by all flavors of HatsSignerGate\n    /// @param _account The address to check\n    /// @return valid Whether `_account` is a valid signer\n    function isValidSigner(address _account) public view virtual returns (bool valid) { }\n\n    /// @notice Sets a new target threshold, and changes `safe`'s threshold if appropriate\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_targetThreshold` is greater than `maxSigners`.\n    /// @param _targetThreshold The new target threshold to set\n    function setTargetThreshold(uint256 _targetThreshold) public onlyOwner {\n        if (_targetThreshold != targetThreshold) {\n            _setTargetThreshold(_targetThreshold);\n\n            if (signerCount > 1) _setSafeThreshold(_targetThreshold);\n\n            emit HSGLib.TargetThresholdSet(_targetThreshold);\n        }\n    }\n\n    /// @notice Internal function to set the target threshold\n    /// @dev Reverts if `_targetThreshold` is greater than `maxSigners`\n    /// @param _targetThreshold The new target threshold to set\n    function _setTargetThreshold(uint256 _targetThreshold) internal {\n        if (_targetThreshold > maxSigners) {\n            revert InvalidTargetThreshold();\n        }\n\n        targetThreshold = _targetThreshold;\n    }\n\n    /// @notice Internal function to set the threshold for the `safe`\n    /// @dev Forwards the threshold-setting call to `safe.ExecTransactionFromModule`\n    /// @param _threshold The threshold to set on the `safe`\n    function _setSafeThreshold(uint256 _threshold) internal {\n        uint256 newThreshold = _threshold;\n        uint256 signerCount_ = signerCount; // save an SLOAD\n\n        // ensure that txs can't execute if fewer signers than target threshold\n        if (signerCount_ <= _threshold) {\n            newThreshold = signerCount_;\n        }\n        if (newThreshold != safe.getThreshold()) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", newThreshold);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Sets a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function setMinThreshold(uint256 _minThreshold) public onlyOwner {\n        _setMinThreshold(_minThreshold);\n        emit HSGLib.MinThresholdSet(_minThreshold);\n    }\n\n    /// @notice Internal function to set a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function _setMinThreshold(uint256 _minThreshold) internal {\n        if (_minThreshold > maxSigners || _minThreshold > targetThreshold) {\n            revert InvalidMinThreshold();\n        }\n\n        minThreshold = _minThreshold;\n    }\n\n    /// @notice Allows the owner to enable a new module on the `safe`\n    /// @dev Increments the `enabledModuleCount` to include the new module in the allowed list (see `checkTransaction` and `checkAfterExecution`)\n    /// @param _module The address of the module to enable\n    function enableNewModule(address _module) external onlyOwner {\n        ++enabledModuleCount;\n\n        bytes memory data = abi.encodeWithSignature(\"enableModule(address)\", _module);\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            data, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecEnableModule();\n        }\n    }\n\n    /// @notice Tallies the number of existing `safe` owners that wear a signer hat, sets `signerCount` to that value, and updates the `safe` threshold if necessary\n    /// @dev Does NOT remove invalid `safe` owners\n    function reconcileSignerCount() public {\n        address[] memory owners = safe.getOwners();\n        uint256 validSignerCount = _countValidSigners(owners);\n\n        if (validSignerCount > maxSigners) {\n            revert MaxSignersReached();\n        }\n\n        // update the signer count accordingly\n        signerCount = validSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold();\n        uint256 newThreshold;\n        uint256 target = targetThreshold; // save SLOADs\n\n        if (validSignerCount <= target && validSignerCount != currentThreshold) {\n            newThreshold = validSignerCount;\n        } else if (validSignerCount > target && currentThreshold < target) {\n            newThreshold = target;\n        }\n        if (newThreshold > 0) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", validSignerCount);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Internal function to count the number of valid signers in an array of addresses\n    /// @param owners The addresses to check for validity\n    /// @return validSignerCount The number of valid signers in `owners`\n    function _countValidSigners(address[] memory owners) internal view returns (uint256 validSignerCount) {\n        uint256 length = owners.length;\n        // count the existing safe owners that wear the signer hat\n        for (uint256 i; i < length;) {\n            if (isValidSigner(owners[i])) {\n                // shouldn't overflow given reasonable owners array length\n                unchecked {\n                    ++validSignerCount;\n                }\n            }\n            // shouldn't overflow given reasonable owners array length\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Internal function that adds `_signer` as an owner on `safe`, updating the threshold if appropriate\n    /// @dev Unsafe. Does not check if `_signer` is a valid signer\n    /// @param _owners Array of owners on the `safe`\n    /// @param _currentSignerCount The current number of signers\n    /// @param _signer The address to add as a new `safe` owner\n    function _grantSigner(address[] memory _owners, uint256 _currentSignerCount, address _signer) internal {\n        uint256 newSignerCount = _currentSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold(); // view function\n        uint256 newThreshold = currentThreshold;\n\n        bytes memory addOwnerData;\n\n        // if the only owner is a non-signer (ie this module set as an owner on initialization), replace it with _signer\n        if (_owners.length == 1 && _owners[0] == address(this)) {\n            // prevOwner will always be the sentinel when owners.length == 1\n\n            // set up the swapOwner call\n            addOwnerData = abi.encodeWithSignature(\n                \"swapOwner(address,address,address)\",\n                SENTINEL_OWNERS, // prevOwner\n                address(this), // oldOwner\n                _signer // newOwner\n            );\n            unchecked {\n                // shouldn't overflow given MaxSignersReached check higher in call stack\n                ++newSignerCount;\n            }\n        } else {\n            // otherwise, add the claimer as a new owner\n\n            unchecked {\n                // shouldn't overflow given MaxSignersReached check higher in call stack\n                ++newSignerCount;\n            }\n\n            // ensure that txs can't execute if fewer signers than target threshold\n            if (newSignerCount <= targetThreshold) {\n                newThreshold = newSignerCount;\n            }\n\n            // set up the addOwner call\n            addOwnerData = abi.encodeWithSignature(\"addOwnerWithThreshold(address,uint256)\", _signer, newThreshold);\n        }\n\n        // increment signer count\n        signerCount = newSignerCount;\n\n        // execute the call\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            addOwnerData, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecAddSigner();\n        }\n    }\n\n    /// @notice Internal function that adds `_signer` as an owner on `safe` by swapping with an existing (invalid) owner\n    /// @dev Unsafe. Does not check if `_signer` is a valid signer.\n    /// @param _owners Array of owners on the `safe`\n    /// @param _ownerCount The number of owners on the `safe` (length of `_owners` array)\n    /// @param _maxSigners The maximum number of signers allowed\n    /// @param _currentSignerCount The current number of signers\n    /// @param _signer The address to add as a new `safe` owner\n    /// @return success Whether an invalid signer was found and successfully replaced with `_signer`\n    function _swapSigner(\n        address[] memory _owners,\n        uint256 _ownerCount,\n        uint256 _maxSigners,\n        uint256 _currentSignerCount,\n        address _signer\n    ) internal returns (bool success) {\n        address ownerToCheck;\n        bytes memory data;\n\n        for (uint256 i; i < _ownerCount - 1;) {\n            ownerToCheck = _owners[i];\n\n            if (!isValidSigner(ownerToCheck)) {\n                // prep the swap\n                data = abi.encodeWithSignature(\n                    \"swapOwner(address,address,address)\",\n                    _findPrevOwner(_owners, ownerToCheck), // prevOwner\n                    ownerToCheck, // oldOwner\n                    _signer // newOwner\n                );\n\n                // execute the swap, reverting if it fails for some reason\n                success = safe.execTransactionFromModule(\n                    address(safe), // to\n                    0, // value\n                    data, // data\n                    Enum.Operation.Call // operation\n                );\n\n                if (!success) {\n                    revert FailedExecRemoveSigner();\n                }\n\n                // increment the signer count if signerCount was correct, ie `reconcileSignerCount` was called prior\n                if (_currentSignerCount < _maxSigners) ++signerCount;\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Removes an invalid signer from the `safe`, updating the threshold if appropriate\n    /// @param _signer The address to remove if not a valid signer\n    function removeSigner(address _signer) public virtual {\n        if (isValidSigner(_signer)) {\n            revert StillWearsSignerHat(_signer);\n        }\n\n        _removeSigner(_signer);\n    }\n\n    /// @notice Internal function to remove a signer from the `safe`, updating the threshold if appropriate\n    /// @dev Unsafe. Does not check for signer validity before removal\n    /// @param _signer The address to remove\n    function _removeSigner(address _signer) internal {\n        bytes memory removeOwnerData;\n        address[] memory owners = safe.getOwners();\n        uint256 currentSignerCount = signerCount; // save an SLOAD\n        uint256 newSignerCount;\n\n        if (currentSignerCount < 2 && owners.length == 1) {\n            // signerCount could be 0 after reconcileSignerCount\n            // make address(this) the only owner\n            removeOwnerData = abi.encodeWithSignature(\n                \"swapOwner(address,address,address)\",\n                SENTINEL_OWNERS, // prevOwner\n                _signer, // oldOwner\n                address(this) // newOwner\n            );\n\n            // newSignerCount is already 0\n        } else {\n            uint256 currentThreshold = safe.getThreshold();\n            uint256 newThreshold = currentThreshold;\n            uint256 validSignerCount = _countValidSigners(owners);\n\n            if (validSignerCount == currentSignerCount) {\n                newSignerCount = currentSignerCount;\n            } else {\n                newSignerCount = currentSignerCount - 1;\n            }\n\n            // ensure that txs can't execute if fewer signers than target threshold\n            if (newSignerCount <= targetThreshold) {\n                newThreshold = newSignerCount;\n            }\n\n            removeOwnerData = abi.encodeWithSignature(\n                \"removeOwner(address,address,uint256)\", _findPrevOwner(owners, _signer), _signer, newThreshold\n            );\n        }\n\n        // update signerCount\n        signerCount = newSignerCount;\n\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            removeOwnerData, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecRemoveSigner();\n        }\n    }\n\n    /// @notice Internal function to find the previous owner of an `_owner` in an array of `_owners`, ie the pointer to the owner to remove from the `safe` owners linked list\n    /// @param _owners An array of addresses\n    /// @param _owner The address after the one to find\n    /// @return prevOwner The owner previous to `_owner` in the `safe` linked list\n    function _findPrevOwner(address[] memory _owners, address _owner) internal pure returns (address prevOwner) {\n        prevOwner = SENTINEL_OWNERS;\n\n        for (uint256 i; i < _owners.length;) {\n            if (_owners[i] == _owner) {\n                if (i == 0) break;\n                prevOwner = _owners[i - 1];\n            }\n            // shouldn't overflow given reasonable _owners array length\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // solhint-disallow-next-line payable-fallback\n    fallback() external {\n        // We don't revert on fallback to avoid issues in case of a Safe upgrade\n        // E.g. The expected check method might change and then the Safe would be locked.\n    }\n\n    /// @notice Pre-flight check on a `safe` transaction to ensure that it s signers are valid, called from within `safe.execTransactionFromModule()`\n    /// @dev Overrides All params mirror params for `safe.execTransactionFromModule()`\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address // msgSender\n    ) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        uint256 safeOwnerCount = safe.getOwners().length;\n        // uint256 validSignerCount = _countValidSigners(safe.getOwners());\n\n        // ensure that safe threshold is correct\n        reconcileSignerCount();\n\n        if (safeOwnerCount < minThreshold) {\n            revert BelowMinThreshold(minThreshold, safeOwnerCount);\n        }\n\n        // get the tx hash; view function\n        bytes32 txHash = safe.getTransactionHash(\n            // Transaction info\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            // Payment info\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            // Signature info\n            // We subtract 1 since nonce was just incremented in the parent function call\n            safe.nonce() - 1 // view function\n        );\n\n        uint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n\n        // revert if there aren't enough valid signatures\n        if (validSigCount < safe.getThreshold() || validSigCount < minThreshold) {\n            revert InvalidSigners();\n        }\n\n        // record existing modules for post-flight check\n        // SENTINEL_OWNERS and SENTINEL_MODULES are both address(0x1)\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n        _existingModulesHash = keccak256(abi.encode(modules));\n\n        unchecked {\n            ++_guardEntries;\n        }\n    }\n\n    /// @notice Post-flight check to prevent `safe` signers from removing this contract guard, changing any modules, or changing the threshold\n    /// @dev Modified from https://github.com/gnosis/zodiac-guard-mod/blob/988ebc7b71e352f121a0be5f6ae37e79e47a4541/contracts/ModGuard.sol#L86\n    function checkAfterExecution(bytes32, bool) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        if (\n            abi.decode(StorageAccessible(address(safe)).getStorageAt(uint256(GUARD_STORAGE_SLOT), 1), (address))\n                != address(this)\n        ) {\n            revert CannotDisableThisGuard(address(this));\n        }\n\n        if (safe.getThreshold() != _getCorrectThreshold()) {\n            revert SignersCannotChangeThreshold();\n        }\n\n        // SENTINEL_OWNERS and SENTINEL_MODULES are both address(0x1)\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\n        if (keccak256(abi.encode(modules)) != _existingModulesHash) {\n            revert SignersCannotChangeModules();\n        }\n\n        // leave checked to catch underflows triggered by re-erntry attempts\n        --_guardEntries;\n    }\n\n    /// @notice Internal function to calculate the threshold that `safe` should have, given the correct `signerCount`, `minThreshold`, and `targetThreshold`\n    /// @return _threshold The correct threshold\n    function _getCorrectThreshold() internal view returns (uint256 _threshold) {\n        uint256 count = _countValidSigners(safe.getOwners());\n        uint256 min = minThreshold;\n        uint256 max = targetThreshold;\n        if (count < min) _threshold = min;\n        else if (count > max) _threshold = max;\n        else _threshold = count;\n    }\n\n    /// @notice Counts the number of hats-valid signatures within a set of `signatures`\n    /// @dev modified from https://github.com/safe-global/safe-contracts/blob/c36bcab46578a442862d043e12a83fec41143dec/contracts/GnosisSafe.sol#L240\n    /// @param dataHash The signed data\n    /// @param signatures The set of signatures to check\n    /// @return validSigCount The number of hats-valid signatures\n    function countValidSignatures(bytes32 dataHash, bytes memory signatures, uint256 sigCount)\n        public\n        view\n        returns (uint256 validSigCount)\n    {\n        // There cannot be an owner with address 0.\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n\n        for (i; i < sigCount;) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner =\n                    ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n\n            if (isValidSigner(currentOwner)) {\n                // shouldn't overflow given reasonable sigCount\n                unchecked {\n                    ++validSigCount;\n                }\n            }\n            // shouldn't overflow given reasonable sigCount\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/HatsSignerGateBase.sol",
      "content": "// SPDX-License-Identifier: CC0\npragma solidity >=0.8.13;\n\nimport { Test, console2 } from \"forge-std/Test.sol\"; // remove after testing\nimport \"./HSGLib.sol\";\nimport { HatsOwnedInitializable } from \"hats-auth/HatsOwnedInitializable.sol\";\nimport { BaseGuard } from \"zodiac/guard/BaseGuard.sol\";\nimport { IAvatar } from \"zodiac/interfaces/IAvatar.sol\";\nimport { StorageAccessible } from \"@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol\";\nimport { IGnosisSafe, Enum } from \"./Interfaces/IGnosisSafe.sol\";\nimport { SignatureDecoder } from \"@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol\";\n\nabstract contract HatsSignerGateBase is BaseGuard, SignatureDecoder, HatsOwnedInitializable {\n    /// @notice The multisig to which this contract is attached\n    IGnosisSafe public safe;\n\n    /// @notice The minimum signature threshold for the `safe`\n    uint256 public minThreshold;\n\n    /// @notice The highest level signature threshold for the `safe`\n    uint256 public targetThreshold;\n\n    /// @notice The maximum number of signers allowed for the `safe`\n    uint256 public maxSigners;\n\n    /// @notice The current number of signers on the `safe`\n    uint256 public signerCount;\n\n    /// @notice The version of HatsSignerGate used in this contract\n    string public version;\n\n    /// @notice The number of modules enabled on the `safe`, as enabled via this contract\n    uint256 public enabledModuleCount;\n\n    /// @dev Temporary record of the existing modules on the `safe` when a transaction is submitted\n    bytes32 internal _existingModulesHash;\n    \n    /// @dev A simple re-entrency guard\n    uint256 internal _guardEntries;\n\n    /// @dev The head pointer used in the GnosisSafe owners linked list, as well as the module linked list\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    /// @dev The storage slot used by GnosisSafe to store the guard address\n    ///      keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Makes the singleton unusable by setting its owner to the 1-address\n    constructor() payable initializer {\n        _HatsOwned_init(1, address(0x1));\n    }\n\n    /// @notice Initializes a new instance\n    /// @dev Can only be called once\n    /// @param initializeParams ABI-encoded bytes with initialization parameters\n    function setUp(bytes calldata initializeParams) public payable virtual initializer { }\n\n    /// @notice Internal function to initialize a new instance\n    /// @param _ownerHatId The hat id of the hat that owns this instance of HatsSignerGate\n    /// @param _safe The multisig to which this instance of HatsSignerGate is attached\n    /// @param _hats The Hats Protocol address\n    /// @param _minThreshold The minimum threshold for the `_safe`\n    /// @param _targetThreshold The maxium threshold for the `_safe`\n    /// @param _maxSigners The maximum number of signers allowed on the `_safe`\n    /// @param _version The current version of HatsSignerGate\n    function _setUp(\n        uint256 _ownerHatId,\n        address _safe,\n        address _hats,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners,\n        string memory _version,\n        uint256 _existingModuleCount\n    ) internal {\n        _HatsOwned_init(_ownerHatId, _hats);\n        maxSigners = _maxSigners;\n        safe = IGnosisSafe(_safe);\n\n        _setTargetThreshold(_targetThreshold);\n        _setMinThreshold(_minThreshold);\n        version = _version;\n        enabledModuleCount = _existingModuleCount + 1; // this contract is enabled as well\n    }\n\n    /// @notice Checks if `_account` is a valid signer\n    /// @dev Must be implemented by all flavors of HatsSignerGate\n    /// @param _account The address to check\n    /// @return valid Whether `_account` is a valid signer\n    function isValidSigner(address _account) public view virtual returns (bool valid) { }\n\n    /// @notice Sets a new target threshold, and changes `safe`'s threshold if appropriate\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_targetThreshold` is greater than `maxSigners`.\n    /// @param _targetThreshold The new target threshold to set\n    function setTargetThreshold(uint256 _targetThreshold) public onlyOwner {\n        if (_targetThreshold != targetThreshold) {\n            _setTargetThreshold(_targetThreshold);\n\n            if (signerCount > 1) _setSafeThreshold(_targetThreshold);\n\n            emit HSGLib.TargetThresholdSet(_targetThreshold);\n        }\n    }\n\n    /// @notice Internal function to set the target threshold\n    /// @dev Reverts if `_targetThreshold` is greater than `maxSigners`\n    /// @param _targetThreshold The new target threshold to set\n    function _setTargetThreshold(uint256 _targetThreshold) internal {\n        if (_targetThreshold > maxSigners) {\n            revert InvalidTargetThreshold();\n        }\n\n        targetThreshold = _targetThreshold;\n    }\n\n    /// @notice Internal function to set the threshold for the `safe`\n    /// @dev Forwards the threshold-setting call to `safe.ExecTransactionFromModule`\n    /// @param _threshold The threshold to set on the `safe`\n    function _setSafeThreshold(uint256 _threshold) internal {\n        uint256 newThreshold = _threshold;\n        uint256 signerCount_ = signerCount; // save an SLOAD\n\n        // ensure that txs can't execute if fewer signers than target threshold\n        if (signerCount_ <= _threshold) {\n            newThreshold = signerCount_;\n        }\n        if (newThreshold != safe.getThreshold()) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", newThreshold);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Sets a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function setMinThreshold(uint256 _minThreshold) public onlyOwner {\n        _setMinThreshold(_minThreshold);\n        emit HSGLib.MinThresholdSet(_minThreshold);\n    }\n\n    /// @notice Internal function to set a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function _setMinThreshold(uint256 _minThreshold) internal {\n        if (_minThreshold > maxSigners || _minThreshold > targetThreshold) {\n            revert InvalidMinThreshold();\n        }\n\n        minThreshold = _minThreshold;\n    }\n\n    /// @notice Allows the owner to enable a new module on the `safe`\n    /// @dev Increments the `enabledModuleCount` to include the new module in the allowed list (see `checkTransaction` and `checkAfterExecution`)\n    /// @param _module The address of the module to enable\n    function enableNewModule(address _module) external onlyOwner {\n        ++enabledModuleCount;\n\n        bytes memory data = abi.encodeWithSignature(\"enableModule(address)\", _module);\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            data, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecEnableModule();\n        }\n    }\n\n    /// @notice Tallies the number of existing `safe` owners that wear a signer hat, sets `signerCount` to that value, and updates the `safe` threshold if necessary\n    /// @dev Does NOT remove invalid `safe` owners\n    function reconcileSignerCount() public {\n        address[] memory owners = safe.getOwners();\n        uint256 validSignerCount = _countValidSigners(owners);\n\n        if (validSignerCount > maxSigners) {\n            revert MaxSignersReached();\n        }\n\n        // update the signer count accordingly\n        signerCount = validSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold();\n        uint256 newThreshold;\n        uint256 target = targetThreshold; // save SLOADs\n\n        if (validSignerCount <= target && validSignerCount != currentThreshold) {"
    }
  ]
}