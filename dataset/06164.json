{
  "Title": "[L-07] Low level `call` will always succeed for non-existent addresses",
  "Content": "\nhttps://docs.soliditylang.org/en/latest/control-structures.html#error-handling-assert-require-revert-and-exceptions:\n> The low-level functions call, `delegatecall` and `staticcall` return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.\n\nCalls are done in these instances:\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/main/contracts/cgp/util/Caller.sol#L18\n\n```solidity\nFile: cgp/util/Caller.sol\n\n18:        (bool success, ) = target.call{ value: nativeValue }(callData);\n```\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/main/contracts/interchain-governance-executor/InterchainProposalExecutor.sol#L76\n\n```solidity\nFile: interchain-governance-executor/InterchainProposalExecutor.sol\n76:            (bool success, bytes memory result) = call.target.call{ value: call.value }(call.callData);\n```\n\nThis is mentioned in the [Automated findings report](https://gist.github.com/thebrittfactor/c400e0012d0092316699c53843ecad41#low-23-contract-existence-is-not-checked-before-low-level-call) but the instances identified are wrong.\n\n### Recommendation\n\nWhere applicable, consider adding a check if there is code on the target.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/cgp/util/Caller.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ICaller } from '../interfaces/ICaller.sol';\n\ncontract Caller is ICaller {\n    /**\n     * @dev Calls a target address with specified calldata and optionally sends value.\n     */\n    function _call(\n        address target,\n        bytes calldata callData,\n        uint256 nativeValue\n    ) internal {\n        if (nativeValue > address(this).balance) revert InsufficientBalance();\n\n        (bool success, ) = target.call{ value: nativeValue }(callData);\n        if (!success) {\n            revert ExecutionFailed();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/interchain-governance-executor/InterchainProposalExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { StringToAddress } from '../gmp-sdk/util/AddressString.sol';\nimport { AxelarExecutable } from '../gmp-sdk/executable/AxelarExecutable.sol';\nimport { IInterchainProposalExecutor } from './interfaces/IInterchainProposalExecutor.sol';\nimport { InterchainCalls } from './lib/InterchainCalls.sol';\n\n/**\n * @title InterchainProposalExecutor\n * @dev This contract is intended to be the destination contract for `InterchainProposalSender` contract.\n * The proposal will be finally executed from this contract on the destination chain.\n *\n * The contract maintains whitelists for proposal senders and proposal callers. Proposal senders\n * are InterchainProposalSender contracts at the source chain and proposal callers are contracts\n * that call the InterchainProposalSender at the source chain.\n * For most governance system, the proposal caller should be the Timelock contract.\n *\n * This contract is abstract and some of its functions need to be implemented in a derived contract.\n */\ncontract InterchainProposalExecutor is IInterchainProposalExecutor, AxelarExecutable, Ownable {\n    // Whitelisted proposal callers. The proposal caller is the contract that calls the `InterchainProposalSender` at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedCallers;\n\n    // Whitelisted proposal senders. The proposal sender is the `InterchainProposalSender` contract address at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedSenders;\n\n    constructor(address _gateway, address _owner) AxelarExecutable(_gateway) {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @dev Executes the proposal. The source address must be a whitelisted sender.\n     * @param sourceAddress The source address\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal override {\n        _beforeProposalExecuted(sourceChain, sourceAddress, payload);\n\n        // Check that the source address is whitelisted\n        if (!whitelistedSenders[sourceChain][StringToAddress.toAddress(sourceAddress)]) {\n            revert NotWhitelistedSourceAddress();\n        }\n\n        // Decode the payload\n        (address interchainProposalCaller, InterchainCalls.Call[] memory calls) = abi.decode(payload, (address, InterchainCalls.Call[]));\n\n        // Check that the caller is whitelisted\n        if (!whitelistedCallers[sourceChain][interchainProposalCaller]) {\n            revert NotWhitelistedCaller();\n        }\n\n        // Execute the proposal with the given arguments\n        _executeProposal(calls);\n\n        _onProposalExecuted(sourceChain, sourceAddress, interchainProposalCaller, payload);\n\n        emit ProposalExecuted(keccak256(abi.encode(sourceChain, sourceAddress, interchainProposalCaller, payload)));\n    }\n\n    /**\n     * @dev Executes the proposal. Calls each target with the respective value, signature, and data.\n     * @param calls The calls to execute.\n     */\n    function _executeProposal(InterchainCalls.Call[] memory calls) internal {\n        for (uint256 i = 0; i < calls.length; i++) {\n            InterchainCalls.Call memory call = calls[i];\n            (bool success, bytes memory result) = call.target.call{ value: call.value }(call.callData);\n\n            if (!success) {\n                _onTargetExecutionFailed(call, result);\n            } else {\n                _onTargetExecuted(call, result);\n            }\n        }\n    }\n\n    /**\n     * @dev Set the proposal caller whitelist status\n     * @param sourceChain The source chain\n     * @param sourceCaller The source caller\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalCaller(\n        string calldata sourceChain,\n        address sourceCaller,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedCallers[sourceChain][sourceCaller] = whitelisted;\n        emit WhitelistedProposalCallerSet(sourceChain, sourceCaller, whitelisted);\n    }\n\n    /**\n     * @dev Set the proposal sender whitelist status\n     * @param sourceChain The source chain\n     * @param sourceSender The source sender\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalSender(\n        string calldata sourceChain,\n        address sourceSender,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedSenders[sourceChain][sourceSender] = whitelisted;\n        emit WhitelistedProposalSenderSet(sourceChain, sourceSender, whitelisted);\n    }\n\n    /**\n     * @dev A callback function that is called before the proposal is executed.\n     * This function can be used to handle the payload before the proposal is executed.\n     * @param sourceChain The source chain from where the proposal was sent.\n     * @param sourceAddress The source address that sent the proposal. The source address should be the `InterchainProposalSender` contract address at the source chain.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, calldata.\n     */\n    function _beforeProposalExecuted(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload before the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called after the proposal is executed.\n     * This function emits an event containing the hash of the payload to signify successful execution.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _onProposalExecuted(\n        string calldata, /* sourceChain */\n        string calldata, /* sourceAddress */\n        address, /* caller */\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload after the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called when the execution of a target contract within a proposal fails.\n     * This function will revert the transaction providing the failure reason if present in the failure data.\n     * @param result The return data from the failed call to the target contract.\n     */\n    function _onTargetExecutionFailed(\n        InterchainCalls.Call memory, /* call */\n        bytes memory result\n    ) internal virtual {\n        // You can add your own logic here to handle the failure of the target contract execution. The code below is just an example.\n        if (result.length > 0) {\n            // The failure data is a revert reason string.\n            assembly {\n                revert(add(32, result), mload(result))\n            }\n        } else {\n            // There is no failure data, just revert with no reason.\n            revert ProposalExecuteFailed();\n        }\n    }\n\n    /**\n     * @dev Called after a target is successfully executed. The derived contract should implement this function.\n     * This function should do some post-execution work, such as emitting events.\n     * @param call The call that has been executed.\n     * @param result The result of the call.\n     */\n    function _onTargetExecuted(InterchainCalls.Call memory call, bytes memory result) internal virtual {\n        // You can add your own logic here to handle the success of each target contract execution.\n    }\n}"
    }
  ]
}