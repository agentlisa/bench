{
  "Title": "[L-03] Users can DOS themselves by executing",
  "Content": "<h2 id=\"l-03-users-can-dos-themselves-by-executing-prepareunlock0-many-times\" style=\"position:relative;\"><a href=\"#l-03-users-can-dos-themselves-by-executing-prepareunlock0-many-times\" aria-label=\"l 03 users can dos themselves by executing prepareunlock0 many times permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-03] Users can DOS themselves by executing <code>prepareUnlock(0)</code> many times</h2>\n<p>There’s no check on the amount, and every call add another entry to an array. When the user finally calls <code>executeUnlocks()</code> they’ll run out of gas</p>\n<p><em>There is 1 instance of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"30\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">protocol</span><span class=\"mtk1\">/</span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">BkdLocker</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">118</span><span class=\"mtk1\">      </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">prepareUnlock</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">119</span><span class=\"mtk1\">          </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">120</span><span class=\"mtk1\">              </span><span class=\"mtk12\">totalStashed</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">] + </span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> &lt;= </span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">],</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">121</span><span class=\"mtk1\">              </span><span class=\"mtk8\">\"Amount exceeds locked balance\"</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">122</span><span class=\"mtk1\">:         );</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L118-L122\">https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L118-L122</a></p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "protocol/contracts/BkdLocker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/EnumerableExtensions.sol\";\nimport \"../libraries/UncheckedMath.sol\";\nimport \"../interfaces/IBkdLocker.sol\";\nimport \"../interfaces/tokenomics/IMigrationContract.sol\";\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\n\ncontract BkdLocker is IBkdLocker, Authorization, Preparable {\n    using ScaledMath for uint256;\n    using UncheckedMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableMapping for EnumerableMapping.AddressToUintMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;\n\n    bytes32 internal constant _START_BOOST = \"startBoost\";\n    bytes32 internal constant _MAX_BOOST = \"maxBoost\";\n    bytes32 internal constant _INCREASE_PERIOD = \"increasePeriod\";\n    bytes32 internal constant _WITHDRAW_DELAY = \"withdrawDelay\";\n\n    // User-specific data\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public boostFactors;\n    mapping(address => uint256) public lastUpdated;\n    mapping(address => WithdrawStash[]) public stashedGovTokens;\n    mapping(address => uint256) public totalStashed;\n\n    // Global data\n    uint256 public totalLocked;\n    uint256 public totalLockedBoosted;\n    uint256 public lastMigrationEvent;\n    EnumerableMapping.AddressToUintMap private _replacedRewardTokens;\n\n    // Reward token data\n    mapping(address => RewardTokenData) public rewardTokenData;\n    address public override rewardToken;\n    IERC20 public immutable govToken;\n\n    constructor(\n        address _rewardToken,\n        address _govToken,\n        IRoleManager roleManager\n    ) Authorization(roleManager) {\n        rewardToken = _rewardToken;\n        govToken = IERC20(_govToken);\n    }\n\n    function initialize(\n        uint256 startBoost,\n        uint256 maxBoost,\n        uint256 increasePeriod,\n        uint256 withdrawDelay\n    ) external override onlyGovernance {\n        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);\n        _setConfig(_START_BOOST, startBoost);\n        _setConfig(_MAX_BOOST, maxBoost);\n        _setConfig(_INCREASE_PERIOD, increasePeriod);\n        _setConfig(_WITHDRAW_DELAY, withdrawDelay);\n    }\n\n    /**\n     * @notice Sets a new token to be the rewardToken. Fees are then accumulated in this token.\n     * @dev Previously used rewardTokens can be set again here.\n     */\n    function migrate(address newRewardToken) external override onlyGovernance {\n        _replacedRewardTokens.remove(newRewardToken);\n        _replacedRewardTokens.set(rewardToken, block.timestamp);\n        lastMigrationEvent = block.timestamp;\n        rewardToken = newRewardToken;\n    }\n\n    /**\n     * @notice Lock gov. tokens.\n     * @dev The amount needs to be approved in advance.\n     */\n    function lock(uint256 amount) external override {\n        return lockFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Deposit fees (in the rewardToken) to be distributed to lockers of gov. tokens.\n     * @dev `deposit` or `depositFor` needs to be called at least once before this function can be called\n     * @param amount Amount of rewardToken to deposit.\n     */\n    function depositFees(uint256 amount) external override {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted);\n        curRewardTokenData.feeBalance += amount;\n        emit FeesDeposited(amount);\n    }\n\n    function claimFees() external override {\n        claimFees(rewardToken);\n    }\n\n    /**\n     * @notice Checkpoint function to update user data, in particular the boost factor.\n     */\n    function userCheckpoint(address user) external override {\n        _userCheckpoint(user, 0, balances[user]);\n    }\n\n    /**\n     * @notice Prepare unlocking of locked gov. tokens.\n     * @dev A delay is enforced and unlocking can only be executed after that.\n     * @param amount Amount of gov. tokens to prepare for unlocking.\n     */\n    function prepareUnlock(uint256 amount) external override {\n        require(\n            totalStashed[msg.sender] + amount <= balances[msg.sender],\n            \"Amount exceeds locked balance\"\n        );\n        totalStashed[msg.sender] += amount;\n        stashedGovTokens[msg.sender].push(\n            WithdrawStash(block.timestamp + currentUInts256[_WITHDRAW_DELAY], amount)\n        );\n        emit WithdrawPrepared(msg.sender, amount);\n    }\n\n    /**\n     * @notice Execute all prepared gov. token withdrawals.\n     */\n    function executeUnlocks() external override {\n        uint256 totalAvailableToWithdraw;\n        WithdrawStash[] storage stashedWithdraws = stashedGovTokens[msg.sender];\n        uint256 length = stashedWithdraws.length;\n        require(length > 0, \"No entries\");\n        uint256 i = length;\n        while (i > 0) {\n            i = i - 1;\n            if (stashedWithdraws[i].releaseTime <= block.timestamp) {\n                totalAvailableToWithdraw += stashedWithdraws[i].amount;\n\n                stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];\n\n                stashedWithdraws.pop();\n            }\n        }\n        totalStashed[msg.sender] -= totalAvailableToWithdraw;\n        uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;\n        _userCheckpoint(msg.sender, 0, newTotal);\n        totalLocked -= totalAvailableToWithdraw;\n        govToken.safeTransfer(msg.sender, totalAvailableToWithdraw);\n        emit WithdrawExecuted(msg.sender, totalAvailableToWithdraw);\n    }\n\n    function getUserShare(address user) external view override returns (uint256) {\n        return getUserShare(user, rewardToken);\n    }\n\n    /**\n     * @notice Get the boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the boosted balance for.\n     * @return boosted balance for user.\n     */\n    function boostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the vote weight for a user.\n     * @dev This does not invlude the gov. tokens queued for withdrawal.\n     * @param user Address to get the vote weight for.\n     * @return vote weight for user.\n     */\n    function balanceOf(address user) external view override returns (uint256) {\n        return (balances[user] - totalStashed[user]).scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the share of the total boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the share of the total boosted balance for.\n     * @return share of the total boosted balance for user.\n     */\n    function getShareOfTotalBoostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]).scaledDiv(totalLockedBoosted);\n    }\n\n    function getStashedGovTokens(address user)\n        external\n        view\n        override\n        returns (WithdrawStash[] memory)\n    {\n        return stashedGovTokens[user];\n    }\n\n    function claimableFees(address user) external view override returns (uint256) {\n        return claimableFees(user, rewardToken);\n    }\n\n    /**\n     * @notice Claim fees accumulated in the Locker.\n     */\n    function claimFees(address _rewardToken) public override {\n        require(\n            _rewardToken == rewardToken || _replacedRewardTokens.contains(_rewardToken),\n            Error.INVALID_ARGUMENT\n        );\n        _userCheckpoint(msg.sender, 0, balances[msg.sender]);\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n        uint256 claimable = curRewardTokenData.userShares[msg.sender];\n        curRewardTokenData.userShares[msg.sender] = 0;\n        curRewardTokenData.feeBalance -= claimable;\n        IERC20(_rewardToken).safeTransfer(msg.sender, claimable);\n        emit RewardsClaimed(msg.sender, _rewardToken, claimable);\n    }\n\n    /**\n     * @notice Lock gov. tokens on behalf of another user.\n     * @dev The amount needs to be approved in advance.\n     * @param user Address of user to lock on behalf of.\n     * @param amount Amount of gov. tokens to lock.\n     */\n    function lockFor(address user, uint256 amount) public override {\n        govToken.safeTransferFrom(msg.sender, address(this), amount);\n        _userCheckpoint(user, amount, balances[user] + amount);\n        totalLocked += amount;\n        emit Locked(user, amount);\n    }\n\n    function getUserShare(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return rewardTokenData[_rewardToken].userShares[user];\n    }\n\n    function claimableFees(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 currentShare;\n        uint256 userBalance = balances[user];\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n\n        // Compute the share earned by the user since they last updated\n        if (userBalance > 0) {\n            currentShare += (curRewardTokenData.feeIntegral -\n                curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                    userBalance.scaledMul(boostFactors[user])\n                );\n        }\n        return curRewardTokenData.userShares[user] + currentShare;\n    }\n\n    function computeNewBoost(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    ) public view override returns (uint256) {\n        uint256 newBoost;\n        uint256 balance = balances[user];\n        uint256 startBoost = currentUInts256[_START_BOOST];\n        if (balance == 0 || newTotal == 0) {\n            newBoost = startBoost;\n        } else {\n            uint256 maxBoost = currentUInts256[_MAX_BOOST];\n            newBoost = boostFactors[user];\n            newBoost += (block.timestamp - lastUpdated[user])\n                .scaledDiv(currentUInts256[_INCREASE_PERIOD])\n                .scaledMul(maxBoost - startBoost);\n            if (newBoost > maxBoost) {\n                newBoost = maxBoost;\n            }\n            if (newTotal <= balance) {\n                return newBoost;\n            }\n            newBoost =\n                newBoost.scaledMul(balance.scaledDiv(newTotal)) +\n                startBoost.scaledMul(amountAdded.scaledDiv(newTotal));\n        }\n        return newBoost;\n    }\n\n    function _userCheckpoint(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    ) internal {\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        // Compute the share earned by the user since they last updated\n        uint256 userBalance = balances[user];\n        if (userBalance > 0) {\n            curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -\n                curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                    userBalance.scaledMul(boostFactors[user])\n                );\n\n            // Update values for previous rewardTokens\n            if (lastUpdated[user] < lastMigrationEvent) {\n                uint256 length = _replacedRewardTokens.length();\n                for (uint256 i; i < length; i = i.uncheckedInc()) {\n                    (address token, uint256 replacedAt) = _replacedRewardTokens.at(i);\n                    if (lastUpdated[user] < replacedAt) {\n                        RewardTokenData storage prevRewardTokenData = rewardTokenData[token];\n                        prevRewardTokenData.userShares[user] += (prevRewardTokenData.feeIntegral -\n                            prevRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                                userBalance.scaledMul(boostFactors[user])\n                            );\n                        prevRewardTokenData.userFeeIntegrals[user] = prevRewardTokenData\n                            .feeIntegral;\n                    }\n                }\n            }\n        }\n\n        uint256 newBoost = computeNewBoost(user, amountAdded, newTotal);\n        totalLockedBoosted =\n            totalLockedBoosted +\n            newTotal.scaledMul(newBoost) -\n            balances[user].scaledMul(boostFactors[user]);\n\n        // Update user values\n        curRewardTokenData.userFeeIntegrals[user] = curRewardTokenData.feeIntegral;\n        lastUpdated[user] = block.timestamp;\n        boostFactors[user] = newBoost;\n        balances[user] = newTotal;\n    }\n}"
    }
  ]
}