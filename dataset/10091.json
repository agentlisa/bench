{
  "Title": "[M-01] Improper implementation of slippage check",
  "Content": "_Submitted by WatchPug, also found by gzeon_\n\n[`Zap.sol` L216-L238](https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L216-L238)\n\n```solidity\nfunction redeem(IERC20 token, uint amount, uint poolId, int128 idx, uint minOut)\n    external\n    defend\n    blockLocked\n    whenNotPaused\n    returns(uint out)\n{\n    ibbtc.safeTransferFrom(msg.sender, address(this), amount);\n\n    Pool memory pool = pools[poolId];\n    if (poolId < 3) { // setts\n        settPeak.redeem(poolId, amount);\n        pool.sett.withdrawAll();\n        pool.deposit.remove_liquidity_one_coin(pool.lpToken.balanceOf(address(this)), idx, minOut);\n    } else if (poolId == 3) { // byvwbtc\n        byvWbtcPeak.redeem(amount);\n        IbyvWbtc(address(pool.sett)).withdraw(); // withdraws all available\n    } else {\n        revert(\"INVALID_POOL_ID\");\n    }\n    out = token.balanceOf(address(this));\n    token.safeTransfer(msg.sender, out);\n}\n```\n\nIn the current implementation of. `Zap.sol#redeem()`, the `outAmount` of `IbyvWbtc.withdraw()` is not controlled by `minOut`.\n\n##### Recommendation\nConsider implementing the `minOut` check in between L236 and L237.\n\n```solidity\n...\nout = token.balanceOf(address(this));\nrequire(out >= _minOut, \"Slippage Check\");\ntoken.safeTransfer(msg.sender, out);\n}\n```\n\n**[GalloDaSballo (BadgerDAO) confirmed](https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/47#issuecomment-971668838):**\n > Agree with the finding, not having slippage check at end means people can get rekt, we'll add as suggested\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2021-11-badgerdao-zaps-contest",
  "Code": [
    {
      "filename": "contracts/Zap.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n// unused imports; required for a forced contract compilation\nimport {TransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/ProxyAdmin.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20, SafeMath} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/Initializable.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport {AccessControlDefendedBase} from \"./common/AccessControlDefended.sol\";\n\nimport {ISett} from \"./interfaces/ISett.sol\";\nimport {IBadgerSettPeak, IByvWbtcPeak} from \"./interfaces/IPeak.sol\";\nimport {IbBTC} from \"./interfaces/IbBTC.sol\";\nimport {IbyvWbtc} from \"./interfaces/IbyvWbtc.sol\";\n\ncontract Zap is Initializable, Pausable, AccessControlDefendedBase {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    IBadgerSettPeak public constant settPeak = IBadgerSettPeak(0x41671BA1abcbA387b9b2B752c205e22e916BE6e3);\n    IByvWbtcPeak public constant byvWbtcPeak = IByvWbtcPeak(0x825218beD8BE0B30be39475755AceE0250C50627);\n    IERC20 public constant ibbtc = IERC20(0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F);\n    IERC20 public constant ren = IERC20(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D);\n    IERC20 public constant wbtc = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n    IController public constant controller = IController(0x63cF44B2548e4493Fd099222A1eC79F3344D9682);\n\n    struct Pool {\n        IERC20 lpToken;\n        ICurveFi deposit;\n        ISett sett;\n    }\n    Pool[4] public pools;\n\n    address public governance;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, \"NOT_OWNER\");\n        _;\n    }\n\n    function init(address _governance) initializer external {\n        _setGovernance(_governance);\n        pools[0] = Pool({ // crvRenWBTC [ ren, wbtc ]\n            lpToken: IERC20(0x49849C98ae39Fff122806C06791Fa73784FB3675),\n            deposit: ICurveFi(0x93054188d876f558f4a66B2EF1d97d16eDf0895B),\n            sett: ISett(0x6dEf55d2e18486B9dDfaA075bc4e4EE0B28c1545)\n        });\n        pools[1] = Pool({ // crvRenWSBTC [ ren, wbtc, sbtc ]\n            lpToken: IERC20(0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3),\n            deposit: ICurveFi(0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714),\n            sett: ISett(0xd04c48A53c111300aD41190D63681ed3dAd998eC)\n        });\n        pools[2] = Pool({ // tbtc-sbtcCrv [ tbtc, ren, wbtc, sbtc ]\n            lpToken: IERC20(0x64eda51d3Ad40D56b9dFc5554E06F94e1Dd786Fd),\n            deposit: ICurveFi(0xaa82ca713D94bBA7A89CEAB55314F9EfFEdDc78c),\n            sett: ISett(0xb9D076fDe463dbc9f915E5392F807315Bf940334)\n        });\n        pools[3] = Pool({ // Exclusive to wBTC\n            lpToken: wbtc,\n            deposit: ICurveFi(0x0),\n            sett: ISett(0x4b92d19c11435614CD49Af1b589001b7c08cD4D5) // byvWbtc\n        });\n\n        // Since we don't hold any tokens in this contract, we can optimize gas usage in mint calls by providing infinite approvals\n        for (uint i = 0; i < pools.length; i++) {\n            Pool memory pool = pools[i];\n            pool.lpToken.safeApprove(address(pool.sett), uint(-1));\n            if (i < 3) {\n                ren.safeApprove(address(pool.deposit), uint(-1));\n                wbtc.safeApprove(address(pool.deposit), uint(-1));\n                IERC20(address(pool.sett)).safeApprove(address(settPeak), uint(-1));\n            } else {\n                IERC20(address(pool.sett)).safeApprove(address(byvWbtcPeak), uint(-1));\n            }\n        }\n        pools[2].lpToken.safeApprove(address(pools[2].deposit), uint(-1));\n    }\n\n    /**\n    * @notice Mint ibbtc with wBTC / renBTC\n    * @param token wBTC or renBTC address\n    * @param amount wBTC or renBTC amount\n    * @param poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=yvWbtc\n    * @param idx Index of the token in the curve pool while adding liquidity; redundant for yvWbtc\n    * @param minOut Minimum amount of ibbtc to mint. Use for capping slippage while adding liquidity to curve pool.\n    * @return _ibbtc Minted ibbtc amount\n    */\n    function mint(IERC20 token, uint amount, uint poolId, uint idx, uint minOut)\n        external\n        defend\n        blockLocked\n        whenNotPaused\n        returns(uint _ibbtc)\n    {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        Pool memory pool = pools[poolId];\n        if (poolId < 3) { // setts\n            _addLiquidity(pool.deposit, amount, poolId + 2, idx); // pools are such that the #tokens they support is +2 from their poolId.\n            pool.sett.deposit(pool.lpToken.balanceOf(address(this)));\n            _ibbtc = settPeak.mint(poolId, pool.sett.balanceOf(address(this)), new bytes32[](0));\n        } else if (poolId == 3) { // byvwbtc\n            IbyvWbtc(address(pool.sett)).deposit(new bytes32[](0)); // pulls all available\n            _ibbtc = byvWbtcPeak.mint(pool.sett.balanceOf(address(this)), new bytes32[](0));\n        } else {\n            revert(\"INVALID_POOL_ID\");\n        }\n\n        require(_ibbtc >= minOut, \"INSUFFICIENT_IBBTC\"); // used for capping slippage in curve pools\n        ibbtc.safeTransfer(msg.sender, _ibbtc);\n    }\n\n    /**\n    * @dev Add liquidity to curve btc pools\n    * @param amount wBTC / renBTC amount\n    * @param pool Curve btc pool\n    * @param numTokens # supported tokens for the curve pool\n    * @param idx Index of the supported token in the curve pool in question\n    */\n    function _addLiquidity(ICurveFi pool, uint amount, uint numTokens, uint idx) internal {\n        if (numTokens == 2) {\n            uint[2] memory amounts;\n            amounts[idx] = amount;\n            pool.add_liquidity(amounts, 0);\n        }\n\n        if (numTokens == 3) {\n            uint[3] memory amounts;\n            amounts[idx] = amount;\n            pool.add_liquidity(amounts, 0);\n        }\n\n        if (numTokens == 4) {\n            uint[4] memory amounts;\n            amounts[idx] = amount;\n            pool.add_liquidity(amounts, 0);\n        }\n    }\n\n    /**\n    * @notice Calculate the most optimal route and expected ibbtc amount when minting with wBTC / renBtc.\n    * @dev Use returned params poolId, idx and bBTC in the call to mint(...)\n           The last param `minOut` in mint(...) should be a bit less than the returned bBTC value.\n           For instance 0.2% - 1% lesser depending on slippage tolerange.\n    * @param amount renBTC amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc\n    * @return idx Index of the supported token in the curve pool (poolId). Should be ignored for poolId=3\n    * @return bBTC Expected ibbtc. Not for precise calculations. Doesn't factor in (deposit) fee charged by the curve pool / byvwbtc.\n    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token\n    */\n    function calcMint(address token, uint amount) external view returns(uint poolId, uint idx, uint bBTC, uint fee) {\n        if (token == address(ren)) {\n            return calcMintWithRen(amount);\n        }\n        if (token == address(wbtc)) {\n            return calcMintWithWbtc(amount);\n        }\n        revert(\"INVALID_TOKEN\");\n    }\n\n    /**\n    * @notice Calculate mint through renWBTC pool route and expected ibbtc amount when minting with renBTC.\n    * @dev Use returned params poolId, idx and bBTC in the call to mint(...)\n           The last param `minOut` in mint(...) should be a bit more than the returned bBTC value.\n           For instance 0.2% - 1% higher depending on slippage tolerange.\n    * @param amount renBTC amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv\n    * @return idx Index of the supported token in the curve pool (poolId)\n    * @return bBTC Expected ibbtc. Not for precise calculations. Doesn't factor in fee charged by the curve pool\n    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token\n    */\n    function calcMintWithRen(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {\n        uint _ibbtc;\n        uint _fee;\n\n        // poolId=0, idx=0\n        (bBTC, fee) = curveLPToIbbtc(0, pools[0].deposit.calc_token_amount([amount,0], true));\n    }\n\n    /**\n    * @notice Calculate mint through renWBTC pool route and expected ibbtc amount when minting with wBTC.\n    * @dev Use returned params poolId, idx and bBTC in the call to mint(...)\n           The last param `minOut` in mint(...) should be a bit more than the returned bBTC value.\n           For instance 0.2% - 1% higher depending on slippage tolerange.\n    * @param amount renBTC amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc\n    * @return idx Index of the supported token in the curve pool (poolId). Should be ignored for poolId=3\n    * @return bBTC Expected ibbtc. Not for precise calculations. Doesn't factor in (deposit) fee charged by the curve pool / byvwbtc.\n    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token\n    */\n    function calcMintWithWbtc(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {\n        uint _ibbtc;\n        uint _fee;\n\n        // poolId=0\n        (bBTC, fee) = curveLPToIbbtc(0, pools[0].deposit.calc_token_amount([0,amount], true));\n        idx = 1;\n    }\n\n    /**\n    * @dev Curve LP token amount to expected ibbtc amount\n    */\n    function curveLPToIbbtc(uint poolId, uint _lp) public view returns(uint bBTC, uint fee) {\n        Pool memory pool = pools[poolId];\n        uint _sett = _lp.mul(1e18).div(pool.sett.getPricePerFullShare());\n        return settPeak.calcMint(poolId, _sett);\n    }\n\n    // Redeem Methods\n\n    function redeem(IERC20 token, uint amount, uint poolId, int128 idx, uint minOut)\n        external\n        defend\n        blockLocked\n        whenNotPaused\n        returns(uint out)\n    {\n        ibbtc.safeTransferFrom(msg.sender, address(this), amount);\n\n        Pool memory pool = pools[poolId];\n        if (poolId < 3) { // setts\n            settPeak.redeem(poolId, amount);\n            pool.sett.withdrawAll();\n            pool.deposit.remove_liquidity_one_coin(pool.lpToken.balanceOf(address(this)), idx, minOut);\n        } else if (poolId == 3) { // byvwbtc\n            byvWbtcPeak.redeem(amount);\n            IbyvWbtc(address(pool.sett)).withdraw(); // withdraws all available\n        } else {\n            revert(\"INVALID_POOL_ID\");\n        }\n        out = token.balanceOf(address(this));\n        token.safeTransfer(msg.sender, out);\n    }\n\n    /**\n    * @notice Calculate redeem through renWBTC pool route and expected token amount when redeeming ibbtc.\n    * @dev Use returned params poolId, idx and out in the call to redeem(...)\n           The last param `redeem` in mint(...) should be a bit less than the returned `out` value.\n           For instance 0.2% - 1% lesser depending on slippage tolerange.\n    * @param amount ibbtc amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc\n    * @return idx Index of the supported token in the curve pool (poolId). Should be ignored for poolId=3\n    * @return out Expected amount for token. Not for precise calculations. Doesn't factor in (deposit) fee charged by the curve pool / byvwbtc.\n    * @return fee Fee being charged by ibbtc + setts. Denominated in corresponding sett token\n    */\n    function calcRedeem(address token, uint amount) external view returns(uint poolId, uint idx, uint out, uint fee) {\n        if (token == address(ren)) {\n            return calcRedeemInRen(amount);\n        }\n        if (token == address(wbtc)) {\n            return calcRedeemInWbtc(amount);\n        }\n        revert(\"INVALID_TOKEN\");\n    }\n\n    /**\n    * @notice Calculate redeem through renWBTC pool route and expected renbtc amount when redeeming ibbtc.\n    * @dev Use returned params poolId, idx and renAmount in the call to redeem(...)\n           The last param `minOut` in redeem(...) should be a bit less than the returned renAmount value.\n           For instance 0.2% - 1% lesser depending on slippage tolerange.\n    * @param amount ibbtc amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv\n    * @return idx Index of the supported token in the curve pool (poolId)\n    * @return renAmount Expected renBtc. Not for precise calculations. Doesn't factor in fee charged by the curve pool\n    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token\n    */\n    function calcRedeemInRen(uint amount) public view returns(uint poolId, uint idx, uint renAmount, uint fee) {\n        uint _lp;\n        uint _fee;\n        uint _ren;\n\n        // poolId=0, idx=0\n        (_lp, fee) = ibbtcToCurveLP(0, amount);\n        renAmount = pools[0].deposit.calc_withdraw_one_coin(_lp, 0);\n    }\n\n    /**\n    * @notice Calculate the most optimal route and expected wbtc amount when redeeming ibbtc.\n    * @dev Use returned params poolId, idx and wbtc in the call to redeem(...)\n           The last param `minOut` in redeem(...) should be a bit less than the returned wbtc value.\n           For instance 0.2% - 1% lesser depending on slippage tolerange.\n    * @param amount ibbtc amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc\n    * @return idx Index of the supported token in the curve pool (poolId)\n    * @return wBTCAmount Expected wbtc. Not for precise calculations. Doesn't factor in fee charged by the curve pool\n    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token\n    */\n    function calcRedeemInWbtc(uint amount) public view returns(uint poolId, uint idx, uint wBTCAmount, uint fee) {\n        uint _lp;\n        uint _fee;\n        uint _wbtc;\n\n        // poolId=0, idx=0\n        (_lp, fee) = ibbtcToCurveLP(0, amount);\n        wBTCAmount = pools[0].deposit.calc_withdraw_one_coin(_lp, 1);\n        idx = 1;\n    }\n\n    function ibbtcToCurveLP(uint poolId, uint bBtc) public view returns(uint lp, uint fee) {\n        uint sett;\n        uint max;\n        (sett,fee,max) = settPeak.calcRedeem(poolId, bBtc);\n        Pool memory pool = pools[poolId];\n        if (bBtc > max) {\n            return (0,fee);\n        } else {\n            // pesimistically charge 0.5% on the withdrawal.\n            // Actual fee might be lesser if the vault keeps keeps a buffer\n            uint strategyFee = sett.mul(controller.strategies(pool.lpToken).withdrawalFee()).div(10000);\n            lp = sett.sub(strategyFee).mul(pool.sett.getPricePerFullShare()).div(1e18);\n            fee = fee.add(strategyFee);\n        }\n    }\n\n    // Governance controls\n\n    function setGovernance(address _governance) external onlyGovernance {\n        _setGovernance(_governance);\n    }\n\n    function _setGovernance(address _governance) internal {\n        require(_governance != address(0), \"NULL_ADDRESS\");\n        governance = _governance;\n    }\n\n    function approveContractAccess(address account) external onlyGovernance {\n        _approveContractAccess(account);\n    }\n\n    function revokeContractAccess(address account) external onlyGovernance {\n        _revokeContractAccess(account);\n    }\n\n    function pause() external onlyGovernance {\n        _pause();\n    }\n\n    function unpause() external onlyGovernance {\n        _unpause();\n    }\n}\n\ninterface ICurveFi {\n    function add_liquidity(uint[2] calldata amounts, uint min_mint_amount) external;\n    function calc_token_amount(uint[2] calldata amounts, bool isDeposit) external view returns(uint);\n\n    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;\n    function calc_token_amount(uint[3] calldata amounts, bool isDeposit) external view returns(uint);\n\n    function add_liquidity(uint[4] calldata amounts, uint min_mint_amount) external;\n    function calc_token_amount(uint[4] calldata amounts, bool isDeposit) external view returns(uint);\n\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;\n    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns(uint);\n}\n\ninterface IStrategy {\n    function withdrawalFee() external view returns(uint);\n}\n\ninterface IController {\n    function strategies(IERC20 token) external view returns(IStrategy);\n}"
    }
  ]
}