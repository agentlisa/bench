{
  "Title": "[M-01] The governance will fail to add an ecosystem token if someone creates a hToken that uses that ecosystem token",
  "Content": "\nEcosystem tokens are tokens that don't have an underlying token address in any branch and only the global representation exists. The governance adds them by calling `addEcosystemToken()` where the `_ecoTokenGlobalAddress` will be the Maia or Hermes token, as the sponsor mentioned, or any other tokens that could be added in the future.\n\nThe problem is that anyone can create a hToken where the underlying asset is the ecosystem token and then this mapping will get updated in `setAddresses()`:\n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootPort.sol#L252>\n\n```solidity\n252:  getLocalTokenFromUnderlying[_underlyingAddress][_srcChainId] = _localAddress;\n```\n\nThe `_underlyingAddress` equals to the `_ecoTokenGlobalAddress` and when the admin calls `addEcosystemToken()`, it will then revert because of this check that is incorrect:\n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootPort.sol#L493>\n\n```solidity\n\n493:   if (getLocalTokenFromUnderlying[_ecoTokenGlobalAddress][localChainId] != address(0)) {\n494:       revert AlreadyAddedEcosystemToken();\n495:   }\n```\n\n`getLocalTokenFromUnderlying[_ecoTokenGlobalAddress]` will not be a zero address because it was set when the attacker added the hToken.\n\nThe check here is redundant. Even if someone creates a hToken where the underlying asset will be the ecosystem token, it will not be tied to the ecosystem token in any way, as it has a different global address and a different local address.\n\n### Impact\n\nThe governance will fail to add the ecosystem tokens. They will not work with this part of Ulysses because an attacker can easily create a hToken before the ecosystem token is set.\n\n### Proof of Concept\n\nAdd this to `RootTest.t.sol`\n\n```solidity\nfunction testAddEcosystemTokenAttack() public {\n        //arbitrumMockToken will be the Maia or Hermes token\n        hevm.deal(address(this), 1 ether);\n\n        //Attacker adds the Maia or Hermes token\n        arbitrumCoreRouter.addLocalToken{value: 0.0005 ether}(\n            address(arbitrumMockToken), GasParams(0.5 ether, 0.5 ether)\n        );\n\n        newArbitrumAssetGlobalAddress =\n            RootPort(rootPort).getLocalTokenFromUnderlying(address(arbitrumMockToken), rootChainId);\n\n        require(\n            RootPort(rootPort).getGlobalTokenFromLocal(address(newArbitrumAssetGlobalAddress), rootChainId)\n                == address(newArbitrumAssetGlobalAddress),\n            \"Token should be added\"\n        );\n        require(\n            RootPort(rootPort).getLocalTokenFromGlobal(newArbitrumAssetGlobalAddress, rootChainId)\n                == address(newArbitrumAssetGlobalAddress),\n            \"Token should be added\"\n        );\n        require(\n            RootPort(rootPort).getUnderlyingTokenFromLocal(address(newArbitrumAssetGlobalAddress), rootChainId)\n                == address(arbitrumMockToken),\n            \"Token should be added\"\n        );\n\n        //The admin will then fail to add an ecosystem token because the tx reverts\n        rootPort.addEcosystemToken(address(arbitrumMockToken));\n\n    }\n```\n\nAs you can see here, the tx reverts because of that check and the admin will fail to add the ecosystem token.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nRemove this check as it's redundant, as setting the ecosystem tokens when initializing is not the best solution because other tokens can be added in the future.\n\n```solidity\nif (getLocalTokenFromUnderlying[_ecoTokenGlobalAddress][localChainId] != address(0)) {\n     revert AlreadyAddedEcosystemToken();\n}\n```\n\n### Assessed type\n\nDoS\n\n**[0xBugsy (Maia) disputed and commented](https://github.com/code-423n4/2023-09-maia-findings/issues/881#issuecomment-1767127915):**\n > If the token has not yet been added to the system, a new one can simply be deployed. In addition, this can be done in a multicall paired with the token deployment itself for added security. Removing this check would lead to added governance power / responsibility.  \n\n**[alcueca (judge) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/881#issuecomment-1779208866):**\n > Regardless of the mitigation, which might not be great, the issue is that if an ecosystem token is not set, an attacker can add it as an underlying of some other token. Then, it will not be possible to set it anymore as a global address (because the ecosystem token already is an underlying token).\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/881#issuecomment-1779289541):**\n > The attacker would have to act between token deployment and adding it as an ecosystem token. The only way for that to happen would need to come from a governance/setup mistake.\n> \n> The check cannot be overridden if there is any deposits of that underlying or there would be funds lost. Mitigation could be improved by this, allowing an ecosystem token to override a global token if its total supply is zero. This way, any mistake can be circumvented without any redeployment (if the ecosystem token is not distributed yet) and our setup can be more flexible.\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/881#issuecomment-1779443849):**\n > Adding an ecosystem token immediately after creation is not obvious, or in the documentation. This is then a valid DoS attack, which you can mitigate with careful governance.\n\n**[0xLightt (Maia) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-09-maia-findings/issues/881#issuecomment-1789442225):**\n > Updated review and feedback to reflect our opinion on this issue.\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/881#issuecomment-1807194674):**\n > Addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/e715c2157e8cb0fc2fd27b1fb921620df2db17d5). \n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-09-maia-findings/issues/881).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/RootPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {IERC20hTokenRootFactory} from \"./interfaces/IERC20hTokenRootFactory.sol\";\nimport {IRootBridgeAgent as IBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootPort, ICoreRootRouter, GasParams, VirtualAccount} from \"./interfaces/IRootPort.sol\";\n\nimport {ERC20hTokenRoot} from \"./token/ERC20hTokenRoot.sol\";\n\n/// @title Root Port - Omnichain Token Management Contract\n/// @author MaiaDAO\ncontract RootPort is Ownable, IRootPort {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                            SETUP STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice True if setup is still ongoing, false otherwise.\n    bool internal _setup;\n\n    /// @notice True if core setup is still ongoing, false otherwise.\n    bool internal _setupCore;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT PORT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint256 public immutable localChainId;\n\n    /// @notice The address of local branch port responsible for handling local transactions.\n    address public localBranchPortAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootRouterAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootBridgeAgentAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        VIRTUAL ACCOUNT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from user address to Virtual Account.\n    mapping(address user => VirtualAccount account) public getUserAccount;\n\n    /// @notice Holds the mapping from Virtual account to router address => bool.\n    /// @notice Stores whether a router is approved to spend a virtual account.\n    mapping(VirtualAccount acount => mapping(address router => bool allowed)) public isRouterApproved;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from address to Bridge Agent.\n    mapping(uint256 chainId => bool isActive) public isChainId;\n\n    /// @notice Mapping from address to isBridgeAgent (bool).\n    mapping(address bridgeAgent => bool isActive) public isBridgeAgent;\n\n    /// @notice Bridge Agents deployed in root chain.\n    address[] public bridgeAgents;\n\n    /// @notice Mapping address Bridge Agent => address Bridge Agent Manager\n    mapping(address bridgeAgent => address bridgeAgentManager) public getBridgeAgentManager;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address bridgeAgentFactory => bool isActive) public isBridgeAgentFactory;\n\n    /// @notice Bridge Agents deployed in root chain.\n    address[] public bridgeAgentFactories;\n\n    /*///////////////////////////////////////////////////////////////\n                            hTOKENS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping with all global hTokens deployed in the system.\n    mapping(address token => bool isGlobalToken) public isGlobalAddress;\n\n    /// @notice ChainId -> Local Address -> Global Address\n    mapping(address chainId => mapping(uint256 localAddress => address globalAddress)) public getGlobalTokenFromLocal;\n\n    /// @notice ChainId -> Global Address -> Local Address\n    mapping(address chainId => mapping(uint256 globalAddress => address localAddress)) public getLocalTokenFromGlobal;\n\n    /// @notice ChainId -> Underlying Address -> Local Address\n    mapping(address chainId => mapping(uint256 underlyingAddress => address localAddress)) public\n        getLocalTokenFromUnderlying;\n\n    /// @notice Mapping from Local Address to Underlying Address.\n    mapping(address chainId => mapping(uint256 localAddress => address underlyingAddress)) public\n        getUnderlyingTokenFromLocal;\n\n    /*///////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Root Port.\n     * @param _localChainId layer zero chain id of the local chain.\n     */\n    constructor(uint256 _localChainId) {\n        localChainId = _localChainId;\n        isChainId[_localChainId] = true;\n\n        _initializeOwner(msg.sender);\n        _setup = true;\n        _setupCore = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     *  @notice Function to initialize the Root Port.\n     *   @param _bridgeAgentFactory The address of the Bridge Agent Factory.\n     *   @param _coreRootRouter The address of the Core Root Router.\n     */\n    function initialize(address _bridgeAgentFactory, address _coreRootRouter) external onlyOwner {\n        require(_bridgeAgentFactory != address(0), \"Bridge Agent Factory cannot be 0 address.\");\n        require(_coreRootRouter != address(0), \"Core Root Router cannot be 0 address.\");\n        require(_setup, \"Setup ended.\");\n        _setup = false;\n\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n\n        coreRootRouterAddress = _coreRootRouter;\n    }\n\n    /**\n     *  @notice Function to initialize the Root Chain Core Contracts in Port Storage.\n     *   @param _coreRootBridgeAgent The address of the Core Root Bridge Agent.\n     *   @param _coreLocalBranchBridgeAgent The address of the Core Arbitrum Branch Bridge Agent.\n     *   @param _localBranchPortAddress The address of the Arbitrum Branch Port.\n     */\n    function initializeCore(\n        address _coreRootBridgeAgent,\n        address _coreLocalBranchBridgeAgent,\n        address _localBranchPortAddress\n    ) external onlyOwner {\n        require(_coreRootBridgeAgent != address(0), \"Core Root Bridge Agent cannot be 0 address.\");\n        require(_coreLocalBranchBridgeAgent != address(0), \"Core Local Branch Bridge Agent cannot be 0 address.\");\n        require(_localBranchPortAddress != address(0), \"Local Branch Port Address cannot be 0 address.\");\n        require(isBridgeAgent[_coreRootBridgeAgent], \"Core Bridge Agent doesn't exist.\");\n        require(_setupCore, \"Core Setup ended.\");\n        _setupCore = false;\n\n        coreRootBridgeAgentAddress = _coreRootBridgeAgent;\n        localBranchPortAddress = _localBranchPortAddress;\n        IBridgeAgent(_coreRootBridgeAgent).syncBranchBridgeAgent(_coreLocalBranchBridgeAgent, localChainId);\n        getBridgeAgentManager[_coreRootBridgeAgent] = owner();\n    }\n\n    /// @notice Function being overriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function getLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _getLocalToken(_localAddress, _srcChainId, _dstChainId);\n    }\n\n    /**\n     * @notice View Function returns Local Token's Local Address on another chain.\n     * @param _localAddress The address of the token in the local chain.\n     * @param _srcChainId The chainId of the chain where the token is deployed.\n     * @param _dstChainId The chainId of the chain for which the token address is requested.\n     */\n    function _getLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        internal\n        view\n        returns (address)\n    {\n        address globalAddress = getGlobalTokenFromLocal[_localAddress][_srcChainId];\n        return getLocalTokenFromGlobal[globalAddress][_dstChainId];\n    }\n\n    /// @inheritdoc IRootPort\n    function getUnderlyingTokenFromGlobal(address _globalAddress, uint256 _srcChainId)\n        external\n        view\n        override\n        returns (address)\n    {\n        address localAddress = getLocalTokenFromGlobal[_globalAddress][_srcChainId];\n        return getUnderlyingTokenFromLocal[localAddress][_srcChainId];\n    }\n\n    /// @inheritdoc IRootPort\n    function isGlobalToken(address _globalAddress, uint256 _srcChainId) external view override returns (bool) {\n        return getLocalTokenFromGlobal[_globalAddress][_srcChainId] != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isLocalToken(address _localAddress, uint256 _srcChainId) external view override returns (bool) {\n        return getGlobalTokenFromLocal[_localAddress][_srcChainId] != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        external\n        view\n        returns (bool)\n    {\n        return _getLocalToken(_localAddress, _srcChainId, _dstChainId) != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isUnderlyingToken(address _underlyingToken, uint256 _srcChainId) external view override returns (bool) {\n        return getLocalTokenFromUnderlying[_underlyingToken][_srcChainId] != address(0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        hTOKEN MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function setAddresses(\n        address _globalAddress,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _srcChainId\n    ) external override requiresCoreRootRouter {\n        if (_globalAddress == address(0)) revert InvalidGlobalAddress();\n        if (_localAddress == address(0)) revert InvalidLocalAddress();\n        if (_underlyingAddress == address(0)) revert InvalidUnderlyingAddress();\n\n        isGlobalAddress[_globalAddress] = true;\n        getGlobalTokenFromLocal[_localAddress][_srcChainId] = _globalAddress;\n        getLocalTokenFromGlobal[_globalAddress][_srcChainId] = _localAddress;\n        getLocalTokenFromUnderlying[_underlyingAddress][_srcChainId] = _localAddress;\n        getUnderlyingTokenFromLocal[_localAddress][_srcChainId] = _underlyingAddress;\n\n        emit LocalTokenAdded(_underlyingAddress, _localAddress, _globalAddress, _srcChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function setLocalAddress(address _globalAddress, address _localAddress, uint256 _srcChainId)\n        external\n        override\n        requiresCoreRootRouter\n    {\n        if (_localAddress == address(0)) revert InvalidLocalAddress();\n\n        getGlobalTokenFromLocal[_localAddress][_srcChainId] = _globalAddress;\n        getLocalTokenFromGlobal[_globalAddress][_srcChainId] = _localAddress;\n\n        emit GlobalTokenAdded(_localAddress, _globalAddress, _srcChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        hTOKEN ACCOUNTING FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function bridgeToRoot(address _recipient, address _hToken, uint256 _amount, uint256 _deposit, uint256 _srcChainId)\n        external\n        override\n        requiresBridgeAgent\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        if (_amount - _deposit > 0) {\n            unchecked {\n                _hToken.safeTransfer(_recipient, _amount - _deposit);\n            }\n        }\n\n        if (_deposit > 0) if (!ERC20hTokenRoot(_hToken).mint(_recipient, _deposit, _srcChainId)) revert UnableToMint();\n    }\n\n    /// @inheritdoc IRootPort\n    function bridgeToRootFromLocalBranch(address _from, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        _hToken.safeTransferFrom(_from, address(this), _amount);\n    }\n\n    function bridgeToLocalBranchFromRoot(address _to, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        _hToken.safeTransfer(_to, _amount);\n    }\n\n    /// @inheritdoc IRootPort\n    function burn(address _from, address _hToken, uint256 _amount, uint256 _srcChainId)\n        external\n        override\n        requiresBridgeAgent\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n        ERC20hTokenRoot(_hToken).burn(_from, _amount, _srcChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function burnFromLocalBranch(address _from, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        ERC20hTokenRoot(_hToken).burn(_from, _amount, localChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function mintToLocalBranch(address _to, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n        if (!ERC20hTokenRoot(_hToken).mint(_to, _amount, localChainId)) revert UnableToMint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    VIRTUAL ACCOUNT MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function fetchVirtualAccount(address _user) external override returns (VirtualAccount account) {\n        account = getUserAccount[_user];\n        if (address(account) == address(0)) account = addVirtualAccount(_user);\n    }\n\n    /**\n     * @notice Creates a new virtual account for a user.\n     * @param _user address of the user to associate a virtual account with.\n     */\n    function addVirtualAccount(address _user) internal returns (VirtualAccount newAccount) {\n        if (_user == address(0)) revert InvalidUserAddress();\n\n        newAccount = new VirtualAccount{salt: keccak256(abi.encode(_user))}(_user, address(this));\n        getUserAccount[_user] = newAccount;\n\n        emit VirtualAccountCreated(_user, address(newAccount));\n    }\n\n    /// @inheritdoc IRootPort\n    function toggleVirtualAccountApproved(VirtualAccount _userAccount, address _router)\n        external\n        override\n        requiresBridgeAgent\n    {\n        isRouterApproved[_userAccount][_router] = !isRouterApproved[_userAccount][_router];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT ADDITION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function addBridgeAgent(address _manager, address _bridgeAgent) external override requiresBridgeAgentFactory {\n        if (isBridgeAgent[_bridgeAgent]) revert AlreadyAddedBridgeAgent();\n\n        bridgeAgents.push(_bridgeAgent);\n        getBridgeAgentManager[_bridgeAgent] = _manager;\n        isBridgeAgent[_bridgeAgent] = true;\n\n        emit BridgeAgentAdded(_bridgeAgent, _manager);\n    }\n\n    /// @inheritdoc IRootPort\n    function syncBranchBridgeAgentWithRoot(\n        address _newBranchBridgeAgent,\n        address _rootBridgeAgent,\n        uint256 _branchChainId\n    ) external override requiresCoreRootRouter {\n        if (IBridgeAgent(_rootBridgeAgent).getBranchBridgeAgent(_branchChainId) != address(0)) {\n            revert AlreadyAddedBridgeAgent();\n        }\n        if (!IBridgeAgent(_rootBridgeAgent).isBranchBridgeAgentAllowed(_branchChainId)) {\n            revert BridgeAgentNotAllowed();\n        }\n        IBridgeAgent(_rootBridgeAgent).syncBranchBridgeAgent(_newBranchBridgeAgent, _branchChainId);\n\n        emit BridgeAgentSynced(_newBranchBridgeAgent, _rootBridgeAgent, _branchChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function toggleBridgeAgent(address _bridgeAgent) external override onlyOwner {\n        isBridgeAgent[_bridgeAgent] = !isBridgeAgent[_bridgeAgent];\n\n        emit BridgeAgentToggled(_bridgeAgent);\n    }\n\n    /// @inheritdoc IRootPort\n    function addBridgeAgentFactory(address _bridgeAgentFactory) external override onlyOwner {\n        if (isBridgeAgentFactory[_bridgeAgentFactory]) revert AlreadyAddedBridgeAgentFactory();\n\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n\n        emit BridgeAgentFactoryAdded(_bridgeAgentFactory);\n    }\n\n    /// @inheritdoc IRootPort\n    function toggleBridgeAgentFactory(address _bridgeAgentFactory) external override onlyOwner {\n        isBridgeAgentFactory[_bridgeAgentFactory] = !isBridgeAgentFactory[_bridgeAgentFactory];\n\n        emit BridgeAgentFactoryToggled(_bridgeAgentFactory);\n    }\n\n    /// @inheritdoc IRootPort\n    function addNewChain(\n        address _coreBranchBridgeAgentAddress,\n        uint256 _chainId,\n        string memory _wrappedGasTokenName,\n        string memory _wrappedGasTokenSymbol,\n        uint8 _wrappedGasTokenDecimals,\n        address _newLocalBranchWrappedNativeTokenAddress,\n        address _newUnderlyingBranchWrappedNativeTokenAddress\n    ) external override onlyOwner {\n        // Check if chain already added\n        if (isChainId[_chainId]) revert AlreadyAddedChain();\n\n        // Create new global token for new chain's wrapped native token\n        address newGlobalToken = address(\n            IERC20hTokenRootFactory(ICoreRootRouter(coreRootRouterAddress).hTokenFactoryAddress()).createToken(\n                _wrappedGasTokenName, _wrappedGasTokenSymbol, _wrappedGasTokenDecimals\n            )\n        );\n\n        // Sync new branch bridge agent with root core bridge agent\n        IBridgeAgent(ICoreRootRouter(coreRootRouterAddress).bridgeAgentAddress()).syncBranchBridgeAgent(\n            _coreBranchBridgeAgentAddress, _chainId\n        );\n\n        // Update State\n\n        // 1. Add new chain to chainId mapping\n        isChainId[_chainId] = true;\n        // 2. Add new chain to global address mapping\n        isGlobalAddress[newGlobalToken] = true;\n        // 3. Add new branch local token to global token address mapping\n        getGlobalTokenFromLocal[_newLocalBranchWrappedNativeTokenAddress][_chainId] = newGlobalToken;\n        // 4. Add new global token to branch local token address mapping\n        getLocalTokenFromGlobal[newGlobalToken][_chainId] = _newLocalBranchWrappedNativeTokenAddress;\n        // 5. Add new branch underlying token to branch local token address mapping\n        getLocalTokenFromUnderlying[_newUnderlyingBranchWrappedNativeTokenAddress][_chainId] =\n            _newLocalBranchWrappedNativeTokenAddress;\n        // 6. Add new branch local token to branch underlying token address mapping\n        getUnderlyingTokenFromLocal[_newLocalBranchWrappedNativeTokenAddress][_chainId] =\n            _newUnderlyingBranchWrappedNativeTokenAddress;\n\n        emit NewChainAdded(_chainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function addEcosystemToken(address _ecoTokenGlobalAddress) external override onlyOwner {\n        // Check if token already added\n        if (isGlobalAddress[_ecoTokenGlobalAddress]) revert AlreadyAddedEcosystemToken();\n\n        // Check if token is already a underlying token in current chain\n        if (getUnderlyingTokenFromLocal[_ecoTokenGlobalAddress][localChainId] != address(0)) {\n            revert AlreadyAddedEcosystemToken();\n        }\n\n        // Check if token is already a local branch token in current chain\n        if (getLocalTokenFromUnderlying[_ecoTokenGlobalAddress][localChainId] != address(0)) {\n            revert AlreadyAddedEcosystemToken();\n        }\n\n        // Update State\n        // 1. Add new global token to global address mapping\n        isGlobalAddress[_ecoTokenGlobalAddress] = true;\n        // 2. Add new branch local token address to global token mapping\n        getGlobalTokenFromLocal[_ecoTokenGlobalAddress][localChainId] = _ecoTokenGlobalAddress;\n        // 3. Add new global token to branch local token address mapping\n        getLocalTokenFromGlobal[_ecoTokenGlobalAddress][localChainId] = _ecoTokenGlobalAddress;\n\n        emit EcosystemTokenAdded(_ecoTokenGlobalAddress);\n    }\n\n    /// @inheritdoc IRootPort\n    function setCoreRootRouter(address _coreRootRouter, address _coreRootBridgeAgent) external override onlyOwner {\n        if (_coreRootRouter == address(0)) revert InvalidCoreRootRouter();\n        if (_coreRootBridgeAgent == address(0)) revert InvalidCoreRootBridgeAgent();\n\n        coreRootRouterAddress = _coreRootRouter;\n        coreRootBridgeAgentAddress = _coreRootBridgeAgent;\n        getBridgeAgentManager[_coreRootBridgeAgent] = owner();\n\n        emit CoreRootSet(_coreRootRouter, _coreRootBridgeAgent);\n    }\n\n    /// @inheritdoc IRootPort\n    function setCoreBranchRouter(\n        address _refundee,\n        address _coreBranchRouter,\n        address _coreBranchBridgeAgent,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable override onlyOwner {\n        if (_coreBranchRouter == address(0)) revert InvalidCoreBranchRouter();\n        if (_coreBranchBridgeAgent == address(0)) revert InvalidCoreBrancBridgeAgent();\n\n        ICoreRootRouter(coreRootRouterAddress).setCoreBranch{value: msg.value}(\n            _refundee, _coreBranchRouter, _coreBranchBridgeAgent, _dstChainId, _gParams\n        );\n\n        emit CoreBranchSet(_coreBranchRouter, _coreBranchBridgeAgent, _dstChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function syncNewCoreBranchRouter(address _coreBranchRouter, address _coreBranchBridgeAgent, uint16 _dstChainId)\n        external\n        override\n        onlyOwner\n    {\n        if (_coreBranchRouter == address(0)) revert InvalidCoreBranchRouter();\n        if (_coreBranchBridgeAgent == address(0)) revert InvalidCoreBrancBridgeAgent();\n\n        IBridgeAgent(coreRootBridgeAgentAddress).syncBranchBridgeAgent(_coreBranchBridgeAgent, _dstChainId);\n\n        emit CoreBranchSynced(_coreBranchRouter, _coreBranchBridgeAgent, _dstChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent Factory.\n    modifier requiresBridgeAgentFactory() {\n        if (!isBridgeAgentFactory[msg.sender]) revert UnrecognizedBridgeAgentFactory();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent.\n    modifier requiresBridgeAgent() {\n        if (!isBridgeAgent[msg.sender]) revert UnrecognizedBridgeAgent();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is the Root Chain's Core Router.\n    modifier requiresCoreRootRouter() {\n        if (msg.sender != coreRootRouterAddress) revert UnrecognizedCoreRootRouter();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is the Root Chain's Local Branch Port.\n    modifier requiresLocalBranchPort() {\n        if (msg.sender != localBranchPortAddress) revert UnrecognizedLocalBranchPort();\n        _;\n    }\n}"
    },
    {
      "filename": "src/RootPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {IERC20hTokenRootFactory} from \"./interfaces/IERC20hTokenRootFactory.sol\";\nimport {IRootBridgeAgent as IBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootPort, ICoreRootRouter, GasParams, VirtualAccount} from \"./interfaces/IRootPort.sol\";\n\nimport {ERC20hTokenRoot} from \"./token/ERC20hTokenRoot.sol\";\n\n/// @title Root Port - Omnichain Token Management Contract\n/// @author MaiaDAO\ncontract RootPort is Ownable, IRootPort {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                            SETUP STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice True if setup is still ongoing, false otherwise.\n    bool internal _setup;\n\n    /// @notice True if core setup is still ongoing, false otherwise.\n    bool internal _setupCore;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT PORT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint256 public immutable localChainId;\n\n    /// @notice The address of local branch port responsible for handling local transactions.\n    address public localBranchPortAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootRouterAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootBridgeAgentAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        VIRTUAL ACCOUNT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from user address to Virtual Account.\n    mapping(address user => VirtualAccount account) public getUserAccount;\n\n    /// @notice Holds the mapping from Virtual account to router address => bool.\n    /// @notice Stores whether a router is approved to spend a virtual account.\n    mapping(VirtualAccount acount => mapping(address router => bool allowed)) public isRouterApproved;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from address to Bridge Agent.\n    mapping(uint256 chainId => bool isActive) public isChainId;\n\n    /// @notice Mapping from address to isBridgeAgent (bool).\n    mapping(address bridgeAgent => bool isActive) public isBridgeAgent;\n\n    /// @notice Bridge Agents deployed in root chain.\n    address[] public bridgeAgents;\n\n    /// @notice Mapping address Bridge Agent => address Bridge Agent Manager\n    mapping(address bridgeAgent => address bridgeAgentManager) public getBridgeAgentManager;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address bridgeAgentFactory => bool isActive) public isBridgeAgentFactory;\n\n    /// @notice Bridge Agents deployed in root chain.\n    address[] public bridgeAgentFactories;\n\n    /*///////////////////////////////////////////////////////////////\n                            hTOKENS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping with all global hTokens deployed in the system.\n    mapping(address token => bool isGlobalToken) public isGlobalAddress;\n\n    /// @notice ChainId -> Local Address -> Global Address\n    mapping(address chainId => mapping(uint256 localAddress => address globalAddress)) public getGlobalTokenFromLocal;\n\n    /// @notice ChainId -> Global Address -> Local Address\n    mapping(address chainId => mapping(uint256 globalAddress => address localAddress)) public getLocalTokenFromGlobal;\n\n    /// @notice ChainId -> Underlying Address -> Local Address\n    mapping(address chainId => mapping(uint256 underlyingAddress => address localAddress)) public\n        getLocalTokenFromUnderlying;\n\n    /// @notice Mapping from Local Address to Underlying Address.\n    mapping(address chainId => mapping(uint256 localAddress => address underlyingAddress)) public\n        getUnderlyingTokenFromLocal;\n\n    /*///////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Root Port.\n     * @param _localChainId layer zero chain id of the local chain.\n     */\n    constructor(uint256 _localChainId) {\n        localChainId = _localChainId;\n        isChainId[_localChainId] = true;\n\n        _initializeOwner(msg.sender);\n        _setup = true;\n        _setupCore = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     *  @notice Function to initialize the Root Port.\n     *   @param _bridgeAgentFactory The address of the Bridge Agent Factory.\n     *   @param _coreRootRouter The address of the Core Root Router.\n     */\n    function initialize(address _bridgeAgentFactory, address _coreRootRouter) external onlyOwner {\n        require(_bridgeAgentFactory != address(0), \"Bridge Agent Factory cannot be 0 address.\");\n        require(_coreRootRouter != address(0), \"Core Root Router cannot be 0 address.\");\n        require(_setup, \"Setup ended.\");\n        _setup = false;\n\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n\n        coreRootRouterAddress = _coreRootRouter;\n    }\n\n    /**\n     *  @notice Function to initialize the Root Chain Core Contracts in Port Storage.\n     *   @param _coreRootBridgeAgent The address of the Core Root Bridge Agent.\n     *   @param _coreLocalBranchBridgeAgent The address of the Core Arbitrum Branch Bridge Agent.\n     *   @param _localBranchPortAddress The address of the Arbitrum Branch Port.\n     */\n    function initializeCore(\n        address _coreRootBridgeAgent,\n        address _coreLocalBranchBridgeAgent,\n        address _localBranchPortAddress\n    ) external onlyOwner {\n        require(_coreRootBridgeAgent != address(0), \"Core Root Bridge Agent cannot be 0 address.\");\n        require(_coreLocalBranchBridgeAgent != address(0), \"Core Local Branch Bridge Agent cannot be 0 address.\");\n        require(_localBranchPortAddress != address(0), \"Local Branch Port Address cannot be 0 address.\");\n        require(isBridgeAgent[_coreRootBridgeAgent], \"Core Bridge Agent doesn't exist.\");\n        require(_setupCore, \"Core Setup ended.\");\n        _setupCore = false;\n\n        coreRootBridgeAgentAddress = _coreRootBridgeAgent;\n        localBranchPortAddress = _localBranchPortAddress;\n        IBridgeAgent(_coreRootBridgeAgent).syncBranchBridgeAgent(_coreLocalBranchBridgeAgent, localChainId);\n        getBridgeAgentManager[_coreRootBridgeAgent] = owner();\n    }\n\n    /// @notice Function being overriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function getLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _getLocalToken(_localAddress, _srcChainId, _dstChainId);\n    }\n\n    /**\n     * @notice View Function returns Local Token's Local Address on another chain.\n     * @param _localAddress The address of the token in the local chain.\n     * @param _srcChainId The chainId of the chain where the token is deployed.\n     * @param _dstChainId The chainId of the chain for which the token address is requested.\n     */\n    function _getLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        internal\n        view\n        returns (address)\n    {\n        address globalAddress = getGlobalTokenFromLocal[_localAddress][_srcChainId];\n        return getLocalTokenFromGlobal[globalAddress][_dstChainId];\n    }\n\n    /// @inheritdoc IRootPort\n    function getUnderlyingTokenFromGlobal(a"
    }
  ]
}