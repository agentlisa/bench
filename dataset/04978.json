{
  "Title": "[G-37] Using `bool`s for storage incurs overhead",
  "Content": "\nUtilizing booleans for storage is less gas-efficient compared to using types that consume a full word like uint256. Every write operation on a boolean necessitates an extra SLOAD operation to read the slot's current value, modify the boolean bits, and then write back. This additional step is the compiler's measure against contract upgrades and pointer aliasing.\n\nTo enhance gas efficiency, consider using `uint256(0)` for false and `uint256(1)` for true, bypassing the extra Gwarmaccess (100 gas) incurred by the SLOAD.\n\n1 issue instance in 1 file:\n\n```solidity\nFile: pt-v5-vault/src/PrizeVaultFactory.sol\n69: mapping(address vault => bool deployedByFactory) public deployedVaults;\n```\n\n[69](https://github.com/code-423n4/2024-03-pooltogether/blob/main/pt-v5-vault/src/PrizeVaultFactory.sol#L69)\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-pooltogether",
  "Code": [
    {
      "filename": "pt-v5-vault/src/PrizeVaultFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC20, IERC4626 } from \"openzeppelin/token/ERC20/extensions/ERC4626.sol\";\n\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\n\nimport { PrizeVault } from \"./PrizeVault.sol\";\n\n/// @title  PoolTogether V5 Prize Vault Factory\n/// @author PoolTogether Inc. & G9 Software Inc.\n/// @notice Factory contract for deploying new prize vaults using a standard underlying ERC4626 yield vault.\ncontract PrizeVaultFactory {\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Events\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Emitted when a new PrizeVault has been deployed by this factory.\n    /// @param vault The vault that was deployed\n    /// @param yieldVault The underlying yield vault\n    /// @param prizePool The prize pool the vault contributes to\n    /// @param name The name of the vault token\n    /// @param symbol The symbol for the vault token\n    event NewPrizeVault(\n        PrizeVault indexed vault,\n        IERC4626 indexed yieldVault,\n        PrizePool indexed prizePool,\n        string name,\n        string symbol\n    );\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Variables\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The yield buffer to use for vault deployments.\n    /// @dev The yield buffer is expected to be of insignificant value and is used to cover rounding\n    /// errors on deposits and withdrawals. Yield is expected to accrue faster than the yield buffer\n    /// can be reasonably depleted.\n    ///\n    /// The yield buffer should be set as high as possible while still being considered\n    /// insignificant for the lowest precision per dollar asset that is expected to be supported.\n    /// \n    /// Precision per dollar (PPD) can be calculated by: (10 ^ DECIMALS) / ($ value of 1 asset).\n    /// For example, USDC has a PPD of (10 ^ 6) / ($1) = 10e6 p/$.\n    /// \n    /// As a rule of thumb, assets with lower PPD than USDC should not be assumed to be compatible since\n    /// the potential loss of a single unit rounding error is likely too high to be made up by yield at \n    /// a reasonable rate. Actual results may vary based on expected gas costs, asset fluctuation, and\n    /// yield accrual rates.\n    ///\n    /// The yield buffer of vaults deployed by this factory is 1e5. This means that if you deploy a \n    /// vault with USDC as the underlying asset, you will have to approve this factory to spend 1e5\n    /// USDC ($0.10) to be sent to the prize vault during deployment. This value will cover the first\n    /// 100k rounding errors on deposits and withdraws to the vault and is not recoverable by the \n    /// deployer.\n    ///\n    /// If the yield buffer is depleted on a vault, the vault will prevent any further \n    /// deposits if it would result in a rounding error and any rounding errors incurred by withdrawals\n    /// will not be covered by yield. The yield buffer will be replenished automatically as yield accrues\n    /// on deposits.\n    uint256 public constant YIELD_BUFFER = 1e5;\n\n    /// @notice List of all vaults deployed by this factory.\n    PrizeVault[] public allVaults;\n\n    /// @notice Mapping to verify if a Vault has been deployed via this factory.\n    mapping(address vault => bool deployedByFactory) public deployedVaults;\n\n    /// @notice Mapping to store deployer nonces for CREATE2\n    mapping(address deployer => uint256 nonce) public deployerNonces;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // External Functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Deploy a new vault\n    /// @dev Emits a `NewPrizeVault` event with the vault details.\n    /// @dev `claimer` can be set to address zero if none is available yet.\n    /// @dev The caller MUST approve this factory to spend underlying assets equal to `YIELD_BUFFER` so the yield\n    /// buffer can be filled on deployment. This value is unrecoverable and is expected to be insignificant.\n    /// @param _name Name of the ERC20 share minted by the vault\n    /// @param _symbol Symbol of the ERC20 share minted by the vault\n    /// @param _yieldVault Address of the ERC4626 vault in which assets are deposited to generate yield\n    /// @param _prizePool Address of the PrizePool that computes prizes\n    /// @param _claimer Address of the claimer\n    /// @param _yieldFeeRecipient Address of the yield fee recipient\n    /// @param _yieldFeePercentage Yield fee percentage\n    /// @param _owner Address that will gain ownership of this contract\n    /// @return PrizeVault The newly deployed PrizeVault\n    function deployVault(\n      string memory _name,\n      string memory _symbol,\n      IERC4626 _yieldVault,\n      PrizePool _prizePool,\n      address _claimer,\n      address _yieldFeeRecipient,\n      uint32 _yieldFeePercentage,\n      address _owner\n    ) external returns (PrizeVault) {\n        PrizeVault _vault = new PrizeVault{\n            salt: keccak256(abi.encode(msg.sender, deployerNonces[msg.sender]++))\n        }(\n            _name,\n            _symbol,\n            _yieldVault,\n            _prizePool,\n            _claimer,\n            _yieldFeeRecipient,\n            _yieldFeePercentage,\n            YIELD_BUFFER,\n            _owner\n        );\n\n        // A donation to fill the yield buffer is made to ensure that early depositors have\n        // rounding errors covered in the time before yield is actually generated.\n        IERC20(_vault.asset()).transferFrom(msg.sender, address(_vault), YIELD_BUFFER);\n\n        allVaults.push(_vault);\n        deployedVaults[address(_vault)] = true;\n\n        emit NewPrizeVault(\n            _vault,\n            _yieldVault,\n            _prizePool,\n            _name,\n            _symbol\n        );\n\n        return _vault;\n    }\n\n    /// @notice Total number of vaults deployed by this factory.\n    /// @return uint256 Number of vaults deployed by this factory.\n    function totalVaults() external view returns (uint256) {\n        return allVaults.length;\n    }\n}"
    }
  ]
}