{
  "Title": "M-1: An earner can still continue earning even after being removed from the approved list.",
  "Content": "# Issue M-1: An earner can still continue earning even after being removed from the approved list. \n\nSource: https://github.com/sherlock-audit/2023-10-mzero-judging/issues/33 \n\n## Found by \n00001111x0, 0xpiken, araj, pkqs90\n## Summary\nAn earner can still continue earning even after being removed from the approved list.\n\n## Vulnerability Detail\nA `M` holder is eligible to earn the `Earner Rate` when they are approved by TTG.  The approved `M` holder can call [`startEarning()`](https://github.com/sherlock-audit/2023-10-mzero/blob/main/protocol/src/MToken.sol#L100-L103) then begin to earn the `Earner Rate`. They also can [`stopEarning()`](https://github.com/sherlock-audit/2023-10-mzero/blob/main/protocol/src/MToken.sol#L106-L108) to quit earning. \n\nHowever, when an approved `M` holder is disapproved, only the disapproved holder themselves can choose to stop earning; no one else has the authority to force them to quit earning.\n\n`Earner Rate` is calculated in [`StableEarnerRateModel#rate()`](https://github.com/sherlock-audit/2023-10-mzero/blob/main/protocol/src/rateModels/StableEarnerRateModel.sol) as below:\n```solidity\n    function rate() external view returns (uint256) {\n        uint256 safeEarnerRate_ = getSafeEarnerRate(\n            IMinterGateway(minterGateway).totalActiveOwedM(),\n            IMToken(mToken).totalEarningSupply(),\n            IMinterGateway(minterGateway).minterRate()\n        );\n\n        return UIntMath.min256(maxRate(), (RATE_MULTIPLIER * safeEarnerRate_) / ONE);\n    }\n\n    function getSafeEarnerRate(\n        uint240 totalActiveOwedM_,\n        uint240 totalEarningSupply_,\n        uint32 minterRate_\n    ) public pure returns (uint32) {\n        // solhint-disable max-line-length\n        // When `totalActiveOwedM_ >= totalEarningSupply_`, it is possible for the earner rate to be higher than the\n        // minter rate and still ensure cashflow safety over some period of time (`RATE_CONFIDENCE_INTERVAL`). To ensure\n        // cashflow safety, we start with `cashFlowOfActiveOwedM >= cashFlowOfEarningSupply` over some time `dt`.\n        // Effectively: p1 * (exp(rate1 * dt) - 1) >= p2 * (exp(rate2 * dt) - 1)\n        //          So: rate2 <= ln(1 + (p1 * (exp(rate1 * dt) - 1)) / p2) / dt\n        // 1. totalActive * (delta_minterIndex - 1) >= totalEarning * (delta_earnerIndex - 1)\n        // 2. totalActive * (delta_minterIndex - 1) / totalEarning >= delta_earnerIndex - 1\n        // 3. 1 + (totalActive * (delta_minterIndex - 1) / totalEarning) >= delta_earnerIndex\n        // Substitute `delta_earnerIndex` with `exponent((earnerRate * dt) / SECONDS_PER_YEAR)`:\n        // 4. 1 + (totalActive * (delta_minterIndex - 1) / totalEarning) >= exponent((earnerRate * dt) / SECONDS_PER_YEAR)\n        // 5. ln(1 + (totalActive * (delta_minterIndex - 1) / totalEarning)) >= (earnerRate * dt) / SECONDS_PER_YEAR\n        // 6. ln(1 + (totalActive * (delta_minterIndex - 1) / totalEarning)) * SECONDS_PER_YEAR / dt >= earnerRate\n\n        // When `totalActiveOwedM_ < totalEarningSupply_`, the instantaneous earner cash flow must be less than the\n        // instantaneous minter cash flow. To ensure instantaneous cashflow safety, we we use the derivatives of the\n        // previous starting inequality, and substitute `dt = 0`.\n        // Effectively: p1 * rate1 >= p2 * rate2\n        //          So: rate2 <= p1 * rate1 / p2\n        // 1. totalActive * minterRate >= totalEarning * earnerRate\n        // 2. totalActive * minterRate / totalEarning >= earnerRate\n        // solhint-enable max-line-length\n\n        if (totalActiveOwedM_ == 0) return 0;\n\n        if (totalEarningSupply_ == 0) return type(uint32).max;\n\n        if (totalActiveOwedM_ <= totalEarningSupply_) {//@audit-info rate is slashed\n            // NOTE: `totalActiveOwedM_ * minterRate_` can revert due to overflow, so in some distant future, a new\n            //       rate model contract may be needed that handles this differently.\n            return uint32((uint256(totalActiveOwedM_) * minterRate_) / totalEarningSupply_);\n        }\n\n        uint48 deltaMinterIndex_ = ContinuousIndexingMath.getContinuousIndex(\n            ContinuousIndexingMath.convertFromBasisPoints(minterRate_),\n            RATE_CONFIDENCE_INTERVAL\n        );//@audit-info deltaMinterIndex for 30 days\n\n        // NOTE: `totalActiveOwedM_ * deltaMinterIndex_` can revert due to overflow, so in some distant future, a new\n        //       rate model contract may be needed that handles this differently.\n        int256 lnArg_ = int256(\n            _EXP_SCALED_ONE +\n                ((uint256(totalActiveOwedM_) * (deltaMinterIndex_ - _EXP_SCALED_ONE)) / totalEarningSupply_)\n        );\n\n        int256 lnResult_ = wadLn(lnArg_ * _WAD_TO_EXP_SCALER) / _WAD_TO_EXP_SCALER;\n\n        uint256 expRate_ = (uint256(lnResult_) * ContinuousIndexingMath.SECONDS_PER_YEAR) / RATE_CONFIDENCE_INTERVAL;\n\n        if (expRate_ > type(uint64).max) return type(uint32).max;\n\n        // NOTE: Do not need to do `UIntMath.safe256` because it is known that `lnResult_` will not be negative.\n        uint40 safeRate_ = ContinuousIndexingMath.convertToBasisPoints(uint64(expRate_));\n\n        return (safeRate_ > type(uint32).max) ? type(uint32).max : uint32(safeRate_);\n    }\n```\nAs we can see, the rate may vary due to the changes in `MToken#totalEarningSupply()`, therefore the earning of fixed principal amount could be decreased if `totalEarningSupply()` increases.  In some other cases the total earning rewards increases significantly if `totalEarningSupply()` increases, resulting in less `excessOwedM` sending to `ttgVault` when [`MinterGateway#updateIndex()`](https://github.com/sherlock-audit/2023-10-mzero/blob/main/protocol/src/MinterGateway.sol#L432-L449) is called.\n\nCopy below codes to [Integration.t.sol](https://github.com/sherlock-audit/2023-10-mzero/blob/main/protocol/test/integration/Integration.t.sol) and run `forge test --match-test test_aliceStillEarnAfterDisapproved`\n```solidity\n    function test_AliceStillEarnAfterDisapproved() external {\n\n        _registrar.updateConfig(MAX_EARNER_RATE, 40000);\n        _minterGateway.activateMinter(_minters[0]);\n\n        uint256 collateral = 1_000_000e6;\n        _updateCollateral(_minters[0], collateral);\n\n        _mintM(_minters[0], 400e6, _bob);\n        _mintM(_minters[0], 400e6, _alice);\n        uint aliceInitialBalance = _mToken.balanceOf(_alice);\n        uint bobInitialBalance = _mToken.balanceOf(_bob);\n        //@audit-info alice and bob had the same M balance\n        assertEq(aliceInitialBalance, bobInitialBalance);\n        //@audit-info alice and bob started earning\n        vm.prank(_alice);\n        _mToken.startEarning();\n        vm.prank(_bob);\n        _mToken.startEarning();\n\n        vm.warp(block.timestamp + 1 days);\n        uint aliceEarningDay1 = _mToken.balanceOf(_alice) - aliceInitialBalance;\n        uint bobEarningDay1 = _mToken.balanceOf(_bob) - bobInitialBalance;\n        //@audit-info Alice and Bob have earned the same M in day 1\n        assertNotEq(aliceEarningDay1, 0);\n        assertEq(aliceEarningDay1, bobEarningDay1);\n        //@audit-info Alice was removed from earner list\n        _registrar.removeFromList(TTGRegistrarReader.EARNERS_LIST, _alice);\n        vm.warp(block.timestamp + 1 days);\n        uint aliceEarningDay2 = _mToken.balanceOf(_alice) - aliceInitialBalance - aliceEarningDay1;\n        uint bobEarningDay2 = _mToken.balanceOf(_bob) - bobInitialBalance - bobEarningDay1;\n        //@audit-info Alice still earned M in day 2 even she was removed from earner list, the amount of which is same as Bob's earning\n        assertNotEq(aliceEarningDay2, 0);\n        assertEq(aliceEarningDay2, bobEarningDay2);\n\n        uint earnerRateBefore = _mToken.earnerRate();\n        //@audit-info Only Alice can stop herself from earning\n        vm.prank(_alice);\n        _mToken.stopEarning();\n        uint earnerRateAfter = _mToken.earnerRate();\n        //@audit-info The earning rate was almost doubled after Alice called `stopEarning`\n        assertApproxEqRel(earnerRateBefore*2, earnerRateAfter, 0.01e18);\n        vm.warp(block.timestamp + 1 days);\n        uint aliceEarningDay3 = _mToken.balanceOf(_alice) - aliceInitialBalance - aliceEarningDay1 - aliceEarningDay2;\n        uint bobEarningDay3 = _mToken.balanceOf(_bob) - bobInitialBalance - bobEarningDay1 - bobEarningDay2;\n        //@audit-info Alice earned nothing \n        assertEq(aliceEarningDay3, 0);\n        //@audit-info Bob's earnings on day 3 were almost twice as much as what he earned on day 2.\n        assertApproxEqRel(bobEarningDay2*2, bobEarningDay3, 0.01e18);\n    }\n```\n## Impact\n- The earnings of eligible users could potentially be diluted.\n- The `excessOwedM` to ZERO vault holders could be diluted\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-10-mzero/blob/main/protocol/src/MToken.sol#L106-L108\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIntroduce a method that allows anyone to stop the disapproved earner from earning:\n```solidity\n    function stopEarning(address account_) external {\n        if (_isApprovedEarner(account_)) revert IsApprovedEarner();\n        _stopEarning(account_);\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid; medium(2)\n\n\n\n**toninorair**\n\nValid issue, medium severity. Great catch ðŸ‘ \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/124",
  "Code": [
    {
      "filename": "protocol/src/MToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.23;\n\nimport { ERC20Extended } from \"../lib/common/src/ERC20Extended.sol\";\nimport { UIntMath } from \"../lib/common/src/libs/UIntMath.sol\";\n\nimport { IERC20 } from \"../lib/common/src/interfaces/IERC20.sol\";\n\nimport { TTGRegistrarReader } from \"./libs/TTGRegistrarReader.sol\";\n\nimport { IContinuousIndexing } from \"./interfaces/IContinuousIndexing.sol\";\nimport { IMToken } from \"./interfaces/IMToken.sol\";\nimport { IRateModel } from \"./interfaces/IRateModel.sol\";\n\nimport { ContinuousIndexing } from \"./abstract/ContinuousIndexing.sol\";\nimport { ContinuousIndexingMath } from \"./libs/ContinuousIndexingMath.sol\";\n\n/*\n\nâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—\nâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘    â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘\nâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘\nâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘\nâ–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘\nâ•šâ•â•     â•šâ•â•       â•šâ•â•    â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•\n                                                           \n\n*/\n\n/**\n * @title  MToken\n * @author M^0 Labs\n * @notice ERC20 M Token.\n */\ncontract MToken is IMToken, ContinuousIndexing, ERC20Extended {\n    /* ============ Structs ============ */\n\n    /**\n     * @notice MToken balance struct.\n     * @param  isEarning  True if the account is earning, false otherwise.\n     * @param  rawBalance Balance (for a non earning account) or balance principal (for an earning account).\n     */\n    struct MBalance {\n        bool isEarning;\n        uint240 rawBalance;\n    }\n\n    /* ============ Variables ============ */\n\n    /// @inheritdoc IMToken\n    address public immutable minterGateway;\n\n    /// @inheritdoc IMToken\n    address public immutable ttgRegistrar;\n\n    /// @inheritdoc IMToken\n    uint240 public totalNonEarningSupply;\n\n    /// @inheritdoc IMToken\n    uint112 public principalOfTotalEarningSupply;\n\n    /// @notice The balance of M for non-earner or principal of earning M balance for earners.\n    mapping(address account => MBalance balance) internal _balances;\n\n    /* ============ Modifiers ============ */\n\n    /// @dev Modifier to check if caller is Minter Gateway.\n    modifier onlyMinterGateway() {\n        if (msg.sender != minterGateway) revert NotMinterGateway();\n\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructs the M Token contract.\n     * @param  ttgRegistrar_ The address of the TTG Registrar contract.\n     * @param  minterGateway_     The address of Minter Gateway.\n     */\n    constructor(address ttgRegistrar_, address minterGateway_) ContinuousIndexing() ERC20Extended(\"M by M^0\", \"MONEY\", 6) {\n        if ((ttgRegistrar = ttgRegistrar_) == address(0)) revert ZeroTTGRegistrar();\n        if ((minterGateway = minterGateway_) == address(0)) revert ZeroMinterGateway();\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc IMToken\n    function mint(address account_, uint256 amount_) external onlyMinterGateway {\n        _mint(account_, amount_);\n    }\n\n    /// @inheritdoc IMToken\n    function burn(address account_, uint256 amount_) external onlyMinterGateway {\n        _burn(account_, amount_);\n    }\n\n    /// @inheritdoc IMToken\n    function startEarning() external {\n        _revertIfNotApprovedEarner(msg.sender);\n        _startEarning(msg.sender);\n    }\n\n    /// @inheritdoc IMToken\n    function stopEarning() external {\n        _stopEarning(msg.sender);\n    }\n\n    /* ============ View/Pure Functions ============ */\n\n    /// @inheritdoc IMToken\n    function rateModel() public view returns (address rateModel_) {\n        return TTGRegistrarReader.getEarnerRateModel(ttgRegistrar);\n    }\n\n    /// @inheritdoc IMToken\n    function earnerRate() public view returns (uint32 earnerRate_) {\n        return _latestRate;\n    }\n\n    /// @inheritdoc IMToken\n    function totalEarningSupply() public view returns (uint240 totalEarningSupply_) {\n        return _getPresentAmount(principalOfTotalEarningSupply);\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() external view returns (uint256 totalSupply_) {\n        unchecked {\n            return totalNonEarningSupply + totalEarningSupply();\n        }\n    }\n\n    /// @inheritdoc IMToken\n    function principalBalanceOf(address account_) external view returns (uint240 balance_) {\n        MBalance storage mBalance_ = _balances[account_];\n\n        // Treat the raw balance as principal for earner.\n        return mBalance_.isEarning ? uint112(mBalance_.rawBalance) : 0;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account_) external view returns (uint256 balance_) {\n        MBalance storage mBalance_ = _balances[account_];\n\n        return\n            mBalance_.isEarning\n                ? _getPresentAmount(uint112(mBalance_.rawBalance)) // Treat the raw balance as principal for earner.\n                : mBalance_.rawBalance;\n    }\n\n    /// @inheritdoc IMToken\n    function isEarning(address account_) external view returns (bool isEarning_) {\n        return _balances[account_].isEarning;\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function currentIndex() public view override(ContinuousIndexing, IContinuousIndexing) returns (uint128) {\n        // NOTE: Safe to use unchecked here, since `block.timestamp` is always greater than `latestUpdateTimestamp`.\n        unchecked {\n            return\n                // NOTE: Cap the index to `type(uint128).max` to prevent overflow in present value math.\n                UIntMath.bound128(\n                    ContinuousIndexingMath.multiplyIndicesDown(\n                        latestIndex,\n                        ContinuousIndexingMath.getContinuousIndex(\n                            ContinuousIndexingMath.convertFromBasisPoints(_latestRate),\n                            uint32(block.timestamp - latestUpdateTimestamp)\n                        )\n                    )\n                );\n        }\n    }\n\n    /* ============ Internal Interactive Functions ============ */\n\n    /**\n     * @dev   Adds principal to `_balances` of an earning account.\n     * @param account_         The account to add principal to.\n     * @param principalAmount_ The principal amount to add.\n     */\n    function _addEarningAmount(address account_, uint112 principalAmount_) internal {\n        // NOTE: Safe to use unchecked here since overflow of the total supply is checked in `_mint`.\n        unchecked {\n            _balances[account_].rawBalance += principalAmount_;\n            principalOfTotalEarningSupply += principalAmount_;\n        }\n    }\n\n    /**\n     * @dev   Adds amount to `_balances` of a non-earning account.\n     * @param account_ The account to add amount to.\n     * @param amount_  The amount to add.\n     */\n    function _addNonEarningAmount(address account_, uint240 amount_) internal {\n        // NOTE: Safe to use unchecked here since overflow of the total supply is checked in `_mint`.\n        unchecked {\n            _balances[account_].rawBalance += amount_;\n            totalNonEarningSupply += amount_;\n        }\n    }\n\n    /**\n     * @dev   Burns amount of earning or non-earning M from account.\n     * @param account_ The account to burn from.\n     * @param amount_  The present amount to burn.\n     */\n    function _burn(address account_, uint256 amount_) internal {\n        _revertIfInsufficientAmount(amount_);\n\n        emit Transfer(account_, address(0), amount_);\n\n        if (_balances[account_].isEarning) {\n            // NOTE: When burning a present amount, round the principal up in favor of the protocol.\n            _subtractEarningAmount(account_, _getPrincipalAmountRoundedUp(UIntMath.safe240(amount_)));\n            updateIndex();\n        } else {\n            _subtractNonEarningAmount(account_, UIntMath.safe240(amount_));\n        }\n    }\n\n    /**\n     * @dev   Mints amount of earning or non-earning M to account.\n     * @param recipient_ The account to mint to.\n     * @param amount_    The present amount to mint.\n     */\n    function _mint(address recipient_, uint256 amount_) internal {\n        _revertIfInsufficientAmount(amount_);\n        _revertIfInvalidRecipient(recipient_);\n\n        emit Transfer(address(0), recipient_, amount_);\n\n        uint240 safeAmount_ = UIntMath.safe240(amount_);\n\n        unchecked {\n            // As an edge case precaution, prevent a mint that, if all tokens (earning and non-earning) were converted\n            // to a principal earning amount, would overflow the `uint112 principalOfTotalEarningSupply`.\n            if (\n                uint256(totalNonEarningSupply) + safeAmount_ > type(uint240).max ||\n                // NOTE: Round the principal up for worst case.\n                uint256(principalOfTotalEarningSupply) +\n                    _getPrincipalAmountRoundedUp(totalNonEarningSupply + safeAmount_) >=\n                type(uint112).max\n            ) {\n                revert OverflowsPrincipalOfTotalSupply();\n            }\n        }\n\n        if (_balances[recipient_].isEarning) {\n            // NOTE: When minting a present amount, round the principal down in favor of the protocol.\n            _addEarningAmount(recipient_, _getPrincipalAmountRoundedDown(safeAmount_));\n            updateIndex();\n        } else {\n            _addNonEarningAmount(recipient_, safeAmount_);\n        }\n    }\n\n    /**\n     * @dev   Starts earning for account.\n     * @param account_ The account to start earning for.\n     */\n    function _startEarning(address account_) internal {\n        MBalance storage mBalance_ = _balances[account_];\n\n        if (mBalance_.isEarning) return;\n\n        emit StartedEarning(account_);\n\n        mBalance_.isEarning = true;\n\n        // Treat the raw balance as present amount for non earner.\n        uint240 amount_ = mBalance_.rawBalance;\n\n        if (amount_ == 0) return;\n\n        // NOTE: When converting a non-earning balance into an earning balance,\n        // round the principal down in favor of the protocol.\n        uint112 principalAmount_ = _getPrincipalAmountRoundedDown(amount_);\n\n        _balances[account_].rawBalance = principalAmount_;\n\n        unchecked {\n            principalOfTotalEarningSupply += principalAmount_;\n            totalNonEarningSupply -= amount_;\n        }\n\n        updateIndex();\n    }\n\n    /**\n     * @dev   Stops earning for account.\n     * @param account_ The account to stop earning for.\n     */\n    function _stopEarning(address account_) internal {\n        MBalance storage mBalance_ = _balances[account_];\n\n        if (!mBalance_.isEarning) return;\n\n        emit StoppedEarning(account_);\n\n        mBalance_.isEarning = false;\n\n        // Treat the raw balance as principal for earner.\n        uint112 principalAmount_ = uint112(_balances[account_].rawBalance);\n\n        if (principalAmount_ == 0) return;\n\n        uint240 amount_ = _getPresentAmount(principalAmount_);\n\n        _balances[account_].rawBalance = amount_;\n\n        unchecked {\n            totalNonEarningSupply += amount_;\n            principalOfTotalEarningSupply -= principalAmount_;\n        }\n\n        updateIndex();\n    }\n\n    /**\n     * @dev   Subtracts principal from `_balances` of an earning account.\n     * @param account_         The account to subtract principal from.\n     * @param principalAmount_ The principal amount to subtract.\n     */\n    function _subtractEarningAmount(address account_, uint112 principalAmount_) internal {\n        uint256 rawBalance_ = _balances[account_].rawBalance;\n\n        if (rawBalance_ < principalAmount_) revert InsufficientBalance(account_, rawBalance_, principalAmount_);\n\n        unchecked {\n            // Overflow not possible given the above check.\n            _balances[account_].rawBalance -= principalAmount_;\n            principalOfTotalEarningSupply -= principalAmount_;\n        }\n    }\n\n    /**\n     * @dev   Subtracts amount from `_balances` of a non-earning account.\n     * @param account_ The account to subtract amount from.\n     * @param amount_  The amount to subtract.\n     */\n    function _subtractNonEarningAmount(address account_, uint240 amount_) internal {\n        uint256 rawBalance_ = _balances[account_].rawBalance;\n\n        if (rawBalance_ < amount_) revert InsufficientBalance(account_, rawBalance_, amount_);\n\n        unchecked {\n            // Overflow not possible given the above check.\n            _balances[account_].rawBalance -= amount_;\n            totalNonEarningSupply -= amount_;\n        }\n    }\n\n    /**\n     * @dev   Transfer M between both earning and non-earning accounts.\n     * @param sender_    The account to transfer from. It can be either earning or non-earning account.\n     * @param recipient_ The account to transfer to. It can be either earning or non-earning account.\n     * @param amount_    The present amount to transfer.\n     */\n    function _transfer(address sender_, address recipient_, uint256 amount_) internal override {\n        _revertIfInvalidRecipient(recipient_);\n\n        emit Transfer(sender_, recipient_, amount_);\n\n        uint240 safeAmount_ = UIntMath.safe240(amount_);\n\n        bool senderIsEarning_ = _balances[sender_].isEarning; // Only using the sender's earning status more than once.\n\n        // If this is an in-kind transfer, then...\n        if (senderIsEarning_ == _balances[recipient_].isEarning) {\n            // NOTE: When subtracting a present amount from an earner, round the principal up in favor of the protocol.\n            return\n                _transferAmountInKind( // perform an in-kind transfer with...\n                    sender_,\n                    recipient_,\n                    senderIsEarning_ ? _getPrincipalAmountRoundedUp(safeAmount_) : safeAmount_ // the appropriate amount\n                );\n        }\n\n        // If this is not an in-kind transfer, then...\n        if (senderIsEarning_) {\n            // either the sender is earning and the recipient is not, or...\n            // NOTE: When subtracting a present amount from an earner, round the principal up in favor of the protocol.\n            _subtractEarningAmount(sender_, _getPrincipalAmountRoundedUp(safeAmount_));\n            _addNonEarningAmount(recipient_, safeAmount_);\n        } else {\n            // the sender is not earning and the recipient is.\n            // NOTE: When adding a present amount to an earner, round the principal down in favor of the protocol.\n            _subtractNonEarningAmount(sender_, safeAmount_);\n            _addEarningAmount(recipient_, _getPrincipalAmountRoundedDown(safeAmount_));\n        }\n\n        updateIndex();\n    }\n\n    /**\n     * @dev   Transfer M between same earning status accounts.\n     * @param sender_    The account to transfer from.\n     * @param recipient_ The account to transfer to.\n     * @param amount_    The amount (present or principal) to transfer.\n     */\n    function _transferAmountInKind(address sender_, address recipient_, uint240 amount_) internal {\n        _balances[sender_].rawBalance -= amount_;\n\n        // NOTE: When transferring an amount in kind, the `rawBalance` can't overflow\n        //       since the total supply would have overflowed first when minting.\n        unchecked {\n            _balances[recipient_].rawBalance += amount_;\n        }\n    }\n\n    /* ============ Internal View/Pure Functions ============ */\n\n    /**\n     * @dev    Returns the present amount (rounded down) given the principal amount, using the current index.\n     *         All present amounts are rounded down in favor of the protocol.\n     * @param  principalAmount_ The principal amount.\n     * @return The present amount.\n     */\n    function _getPresentAmount(uint112 principalAmount_) internal view returns (uint240) {\n        return _getPresentAmount(principalAmount_, currentIndex());\n    }\n\n    /**\n     * @dev    Returns the present amount (rounded down) given the principal amount and an index.\n     *         All present amounts are rounded down in favor of the protocol, since they are assets.\n     * @param  principalAmount_ The principal amount.\n     * @param  index_           An index\n     * @return The present amount.\n     */\n    function _getPresentAmount(uint112 principalAmount_, uint128 index_) internal pure returns (uint240) {\n        return _getPresentAmountRoundedDown(principalAmount_, index_);\n    }\n\n    /**\n     * @dev    Checks if earner was approved by TTG.\n     * @param  account_    The account to check.\n     * @return True if approved, false otherwise.\n     */\n    function _isApprovedEarner(address account_) internal view returns (bool) {\n        return\n            TTGRegistrarReader.isEarnersListIgnored(ttgRegistrar) ||\n            TTGRegistrarReader.isApprovedEarner(ttgRegistrar, account_);\n    }\n\n    /**\n     * @dev    Gets the current earner rate from TTG approved rate model contract.\n     * @return rate_ The current earner rate.\n     */\n    function _rate() internal view override returns (uint32 rate_) {\n        (bool success_, bytes memory returnData_) = rateModel().staticcall(\n            abi.encodeWithSelector(IRateModel.rate.selector)\n        );\n\n        rate_ = (success_ && returnData_.length >= 32) ? UIntMath.bound32(abi.decode(returnData_, (uint256))) : 0;\n    }\n\n    /**\n     * @dev   Reverts if the amount of a `mint` or `burn` is equal to 0.\n     * @param amount_ Amount to check.\n     */\n    function _revertIfInsufficientAmount(uint256 amount_) internal pure {\n        if (amount_ == 0) revert InsufficientAmount(amount_);\n    }\n\n    /**\n     * @dev   Reverts if the recipient of a `mint` or `transfer` is address(0).\n     * @param recipient_ Address of the recipient to check.\n     */\n    function _revertIfInvalidRecipient(address recipient_) internal pure {\n        if (recipient_ == address(0)) revert InvalidRecipient(recipient_);\n    }\n\n    /**\n     * @dev   Reverts if account is not approved earner.\n     * @param account_ The account to check.\n     */\n    function _revertIfNotApprovedEarner(address account_) internal view {\n        if (!_isApprovedEarner(account_)) revert NotApprovedEarner();\n    }\n}"
    },
    {
      "filename": "protocol/src/MinterGateway.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.23;\n\nimport { SignatureChecker } from \"../lib/common/src/libs/SignatureChecker.sol\";\n\nimport { ERC712Extended } from \"../lib/common/src/ERC712Extended.sol\";\nimport { UIntMath } from \"../lib/common/src/libs/UIntMath.sol\";\n\nimport { TTGRegistrarReader } from \"./libs/TTGRegistrarReader.sol\";\n\nimport { IContinuousIndexing } from \"./interfaces/IContinuousIndexing.sol\";\nimport { IMToken } from \"./interfaces/IMToken.sol\";\nimport { IMinterGateway } from \"./interfaces/IMinterGateway.sol\";\nimport { IRateModel } from \"./interfaces/IRateModel.sol\";\n\nimport { ContinuousIndexing } from \"./abstract/ContinuousIndexing.sol\";\nimport { ContinuousIndexingMath } from \"./libs/ContinuousIndexingMath.sol\";\n\n/*\n\nâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—\nâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•\nâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• \nâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•  \nâ–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   \nâ•šâ•â•     â•šâ•â•â•šâ•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•     â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•   \n                                                                                                                  \n\n*/\n\n/**\n * @title  MinterGateway\n * @author M^0 Labs\n * @notice Minting Gateway of M Token for all approved by TTG and activated minters.\n */\ncontract MinterGateway is IMinterGateway, ContinuousIndexing, ERC712Extended {\n    /* ============ Structs ============ */\n\n    /**\n     * @notice Mint proposal struct.\n     * @param  id          The unique ID of the mint proposal.\n     * @param  createdAt   The timestamp at which the mint proposal was created.\n     * @param  destination The address to mint M to.\n     * @param  amount      The amount of M to mint.\n     */\n    struct MintProposal {\n        // 1st slot\n        uint48 id;\n        uint40 createdAt;\n        address destination;\n        // 2nd slot\n        uint240 amount;\n    }\n\n    /**\n     * @notice Minter state struct.\n     * @param  isActive                Whether the minter is active or not.\n     * @param  isDeactivated           Whether the minter is deactivated or not.\n     * @param  collateral              The amount of collateral the minter has.\n     * @param  totalPendingRetrievals  The total amount of pending retrievals.\n     * @param  updateTimestamp         The timestamp at which the minter last updated their collateral.\n     * @param  penalizedUntilTimestamp The timestamp until which the minter is penalized.\n     * @param  frozenUntilTimestamp    The timestamp until which the minter is frozen.\n     */\n    struct MinterState {\n        // 1st slot\n        bool isActive;\n        bool isDeactivated;\n        uint240 collateral;\n        // 2nd slot\n        uint240 totalPendingRetrievals;\n        // 3rd slot\n        uint40 updateTimestamp;\n        uint40 penalizedUntilTimestamp;\n        uint40 frozenUntilTimestamp;\n    }\n\n    /* ============ Variables ============ */\n\n    /// @inheritdoc IMinterGateway\n    uint16 public constant ONE = 10_000;\n\n    /// @inheritdoc IMinterGateway\n    uint32 public constant MAX_MINT_RATIO = 65_000;\n\n    // solhint-disable-next-line max-line-length\n    /// @dev keccak256(\"UpdateCollateral(address minter,uint256 collateral,uint256[] retrievalIds,bytes32 metadataHash,uint256 timestamp)\")\n    /// @inheritdoc IMinterGateway\n    bytes32 public constant UPDATE_COLLATERAL_TYPEHASH =\n        0x22b57ca54bd15c6234b29e87aa1d76a0841b6e65e63d7acacef989de0bc3ff9e;\n\n    /// @inheritdoc IMinterGateway\n    address public immutable ttgRegistrar;\n\n    /// @inheritdoc IMinterGateway\n    address public immutable ttgVault;\n\n    /// @inheritdoc IMinterGateway\n    address public immutable mToken;\n\n    /// @inheritdoc IMinterGateway\n    uint240 public totalInactiveOwedM;\n\n    /// @inheritdoc IMinterGateway\n    uint112 public principalOfTotalActiveOwedM;\n\n    /// @dev Nonce used to generate unique mint proposal IDs.\n    uint48 internal _mintNonce;\n\n    /// @dev Nonce used to generate unique retrieval proposal IDs.\n    uint48 internal _retrievalNonce;\n\n    /// @dev The state of each minter, their collaterals, relevant timestamps, and total pending retrievals.\n    mapping(address minter => MinterState state) internal _minterStates;\n\n    /// @dev The mint proposals of minter (mint ID, creation timestamp, destination, amount).\n    mapping(address minter => MintProposal proposal) internal _mintProposals;\n\n    /// @dev The owed M of active and inactive minters (principal of active, inactive).\n    mapping(address minter => uint240 rawOwedM) internal _rawOwedM;\n\n    /// @dev The pending collateral retrievals of minter (retrieval ID, amount).\n    mapping(address minter => mapping(uint48 retrievalId => uint240 amount)) internal _pendingCollateralRetrievals;\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * @notice Only allow active minter to call function.\n     * @param  minter_ The address of the minter to check.\n     */\n    modifier onlyActiveMinter(address minter_) {\n        _revertIfInactiveMinter(minter_);\n\n        _;\n    }\n\n    /// @notice Only allow approved validator in TTG to call function.\n    modifier onlyApprovedValidator() {\n        _revertIfNotApprovedValidator(msg.sender);\n\n        _;\n    }\n\n    /// @notice Only allow unfrozen minter to call function.\n    modifier onlyUnfrozenMinter() {\n        _revertIfFrozenMinter(msg.sender);\n\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor.\n     * @param  ttgRegistrar_ The address of the TTG Registrar contract.\n     * @param  mToken_        The address of the M Token.\n     */\n    constructor(address ttgRegistrar_, address mToken_) ContinuousIndexing() ERC712Extended(\"MinterGateway\") {\n        if ((ttgRegistrar = ttgRegistrar_) == address(0)) revert ZeroTTGRegistrar();\n        if ((ttgVault = TTGRegistrarReader.getVault(ttgRegistrar_)) == address(0)) revert ZeroTTGVault();\n        if ((mToken = mToken_) == address(0)) revert ZeroMToken();\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc IMinterGateway\n    function updateCollateral(\n        uint256 collateral_,\n        uint256[] calldata retrievalIds_,\n        bytes32 metadataHash_,\n        address[] calldata validators_,\n        uint256[] calldata timestamps_,\n        bytes[] calldata signatures_\n    ) external onlyActiveMinter(msg.sender) returns (uint40 minTimestamp_) {\n        if (validators_.length != signatures_.length || signatures_.length != timestamps_.length) {\n            revert SignatureArrayLengthsMismatch();\n        }\n\n        // Verify that enough valid signatures are provided, and get the minimum timestamp across all valid signatures.\n        minTimestamp_ = _verifyValidatorSignatures(\n            msg.sender,\n            collateral_,\n            retrievalIds_,\n            metadataHash_,\n            validators_,\n            timestamps_,\n            signatures_\n        );\n\n        uint240 safeCollateral_ = UIntMath.safe240(collateral_);\n        uint240 totalResolvedCollateralRetrieval_ = _resolvePendingRetrievals(msg.sender, retrievalIds_);\n\n        emit CollateralUpdated(\n            msg.sender,\n            safeCollateral_,\n            totalResolvedCollateralRetrieval_,\n            metadataHash_,\n            minTimestamp_\n        );\n\n        _imposePenaltyIfMissedCollateralUpdates(msg.sender);\n\n        _updateCollateral(msg.sender, safeCollateral_, minTimestamp_);\n\n        _imposePenaltyIfUndercollateralized(msg.sender);\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the collateral\n        //       update can result in a new rate, we should update the index here to lock in that rate.\n        updateIndex();\n    }\n\n    /// @inheritdoc IMinterGateway\n    function proposeRetrieval(uint256 collateral_) external onlyActiveMinter(msg.sender) returns (uint48 retrievalId_) {\n        if (collateral_ == 0) revert ZeroRetrievalAmount();\n\n        unchecked {\n            retrievalId_ = ++_retrievalNonce;\n        }\n\n        MinterState storage minterState_ = _minterStates[msg.sender];\n        uint240 currentCollateral_ = minterState_.collateral;\n        uint240 safeCollateral_ = UIntMath.safe240(collateral_);\n        uint240 updatedTotalPendingRetrievals_ = minterState_.totalPendingRetrievals + safeCollateral_;\n\n        // NOTE: Revert if collateral is less than sum of all pending retrievals even if there is no owed M by minter.\n        if (currentCollateral_ < updatedTotalPendingRetrievals_) {\n            revert RetrievalsExceedCollateral(updatedTotalPendingRetrievals_, currentCollateral_);\n        }\n\n        minterState_.totalPendingRetrievals = updatedTotalPendingRetrievals_;\n        _pendingCollateralRetrievals[msg.sender][retrievalId_] = safeCollateral_;\n\n        _revertIfUndercollateralized(msg.sender, 0);\n\n        emit RetrievalCreated(retrievalId_, msg.sender, safeCollateral_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function proposeMint(\n        uint256 amount_,\n        address destination_\n    ) external onlyActiveMinter(msg.sender) onlyUnfrozenMinter returns (uint48 mintId_) {\n        if (amount_ == 0) revert ZeroMintAmount();\n        if (destination_ == address(0)) revert ZeroMintDestination();\n\n        uint240 safeAmount_ = UIntMath.safe240(amount_);\n\n        _revertIfUndercollateralized(msg.sender, safeAmount_); // Ensure minter remains sufficiently collateralized.\n\n        unchecked {\n            mintId_ = ++_mintNonce;\n        }\n\n        _mintProposals[msg.sender] = MintProposal(mintId_, uint40(block.timestamp), destination_, safeAmount_);\n\n        emit MintProposed(mintId_, msg.sender, safeAmount_, destination_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function mintM(\n        uint256 mintId_\n    ) external onlyActiveMinter(msg.sender) onlyUnfrozenMinter returns (uint112 principalAmount_, uint240 amount_) {\n        MintProposal storage mintProposal_ = _mintProposals[msg.sender];\n\n        uint48 id_;\n        uint40 createdAt_;\n        address destination_;\n        (id_, createdAt_, destination_, amount_) = (\n            mintProposal_.id,\n            mintProposal_.createdAt,\n            mintProposal_.destination,\n            mintProposal_.amount\n        );\n\n        if (id_ != mintId_) revert InvalidMintProposal();\n\n        unchecked {\n            // Check that mint proposal is executable.\n            uint40 activeAt_ = createdAt_ + mintDelay();\n            if (block.timestamp < activeAt_) revert PendingMintProposal(activeAt_);\n\n            uint40 expiresAt_ = activeAt_ + mintTTL();\n            if (block.timestamp > expiresAt_) revert ExpiredMintProposal(expiresAt_);\n        }\n\n        _revertIfUndercollateralized(msg.sender, amount_); // Ensure minter remains sufficiently collateralized.\n\n        delete _mintProposals[msg.sender]; // Delete mint request.\n\n        // Adjust principal of active owed M for minter.\n        // NOTE: When minting a present amount, round the principal up in favor of the protocol.\n        principalAmount_ = _getPrincipalAmountRoundedUp(amount_);\n        uint112 principalOfTotalActiveOwedM_ = principalOfTotalActiveOwedM;\n\n        emit MintExecuted(id_, principalAmount_, amount_);\n\n        unchecked {\n            uint256 newPrincipalOfTotalActiveOwedM_ = uint256(principalOfTotalActiveOwedM_) + principalAmount_;\n\n            // As an edge case precaution, prevent a mint that, if all owed M (active and inactive) was converted to\n            // a principal active amount, would overflow the `uint112 principalOfTotalActiveOwedM`.\n            if (\n                // NOTE: Round the principal up for worst case.\n                newPrincipalOfTotalActiveOwedM_ + _getPrincipalAmountRoundedUp(totalInactiveOwedM) >= type(uint112).max\n            ) {\n                revert OverflowsPrincipalOfTotalOwedM();\n            }\n\n            principalOfTotalActiveOwedM = uint112(newPrincipalOfTotalActiveOwedM_);\n            _rawOwedM[msg.sender] += principalAmount_; // Treat rawOwedM as principal since minter is active.\n        }\n\n        IMToken(mToken).mint(destination_, amount_);\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the mint\n        //       can result in a new rate, we should update the index here to lock in that rate.\n        updateIndex();\n    }\n\n    /// @inheritdoc IMinterGateway\n    function burnM(address minter_, uint256 maxAmount_) external returns (uint112 principalAmount_, uint240 amount_) {\n        (principalAmount_, amount_) = burnM(\n            minter_,\n            _getPrincipalAmountRoundedDown(UIntMath.safe240(maxAmount_)),\n            maxAmount_\n        );\n    }\n\n    /// @inheritdoc IMinterGateway\n    function burnM(\n        address minter_,\n        uint256 maxPrincipalAmount_,\n        uint256 maxAmount_\n    ) public returns (uint112 principalAmount_, uint240 amount_) {\n        if (maxPrincipalAmount_ == 0 || maxAmount_ == 0) revert ZeroBurnAmount();\n\n        bool isActive_ = _minterStates[minter_].isActive;\n\n        if (isActive_) {\n            // NOTE: Penalize only for missed collateral updates, not for undercollateralization.\n            // Undercollateralization within one update interval is forgiven.\n            _imposePenaltyIfMissedCollateralUpdates(minter_);\n\n            (principalAmount_, amount_) = _repayForActiveMinter(\n                minter_,\n                UIntMath.safe112(maxPrincipalAmount_),\n                UIntMath.safe240(maxAmount_)\n            );\n\n            emit BurnExecuted(minter_, principalAmount_, amount_, msg.sender);\n        } else {\n            amount_ = _repayForInactiveMinter(minter_, UIntMath.safe240(maxAmount_));\n\n            emit BurnExecuted(minter_, amount_, msg.sender);\n        }\n\n        IMToken(mToken).burn(msg.sender, amount_); // Burn actual M tokens\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the burn\n        //       can result in a new rate, we should update the index here to lock in that rate.\n        updateIndex();\n    }\n\n    /// @inheritdoc IMinterGateway\n    function cancelMint(address minter_, uint256 mintId_) external onlyApprovedValidator {\n        uint48 id_ = _mintProposals[minter_].id;\n\n        if (id"
    }
  ]
}