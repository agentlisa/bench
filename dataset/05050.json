{
  "Title": "[M-20] Max magnitude lock check will lead to a DoS and possible monopolization of `gov/Option` on `twTAP`/`TapiocaOptionBroker`",
  "Content": "\n<https://github.com/Tapioca-DAO/tap-token/blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/governance/twTAP.sol#L315>\n\n<https://github.com/Tapioca-DAO/tap-token/blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/options/TapiocaOptionBroker.sol#L261>\n\n### Vulnerability details\n\nThere is a max magnitude lock check in the `twTAP.participate` function, it can't be greater than 4x the cumulative:\n\n        if (magnitude >= pool.cumulative * 4) revert NotValid();\n\nBecause the param `_duration` can't be less than `EPOCH_DURATION = 7 days = 604800`, lets assume `pool.cumulative` is x, and solve for its minimum value without DoS:\n\n    (604800 * 604800 + x * x)**0.5 - x < 4 * x\n\nSolution derived: `the x, pool.cumulative, must be >= 123455`.\n\nThe main issue is that, when a user participates the lock with `divergenceForce = false`, his participation will decrease `pool.cumulative`. Meanwhile, if there are positions previously entered with `divergenceForce = true` that are now exiting, then `pool.cumulative` will be reduced to below 123455.\n\n### Impact\n\nTAP cannot be staked until `pool.cumulative` rises to 123455, and the system will remain under the DoS for even months until positions with `divergenceForce = false` can exit (arrive at the unlocking time). During this DoS period, the attacker has the potential to monopolize gov.\n\nThe same issue is also in the `TapiocaOptionBroker`. The following PoC uses the `twTap` as the exploit case.\n\n### Proof of Concept\n\nFlow of attack:\n\n1. The user1 locked some  (with `hasVotingPower = true`) for a duration = 1004800 (11.6 days).\n2. After 11.6 days and before the user1 unlocks, the user2 lock some TAP (with `hasVotingPower = true`) for a duration = 1172776 (13.5 days).\n3. The user1 unlocks his `twTap` position.\n4. After this unlocking, the `pool.cumulative` will be 77922, which is `<` 123455.\n\nSo the `twTAP` will be DoS until the user2 (attacker) unlocks, which has to wait about 13.5 days. During this DoS period, the attacker is the only voter of the gov, the attack could have complete control of gov.\n\n```\ndef computeMagnitude(_duration, cumulative):\n    return int((_duration**2 + cumulative**2)**0.5) - cumulative\n\ndef assetValid4(_magnitude, _cumulative, tag):\n    # print(_magnitude, _cumulative * 4)\n    assert _magnitude < _cumulative * 4, f\"Not Valid here #{tag}\"\n\ndef update(_duration, _averageMagnitude, _cumulative, _NO):\n    print(f\"======{_NO}======\")\n    magnitude0 = computeMagnitude(_duration, _cumulative)\n    print(\"duration, cumulative_before\", _duration, _cumulative)\n    assetValid4(magnitude0, _cumulative, _NO)\n    _averageMagnitude = int((_averageMagnitude + magnitude0) / _NO)\n    if _duration >= _cumulative:\n        print(\"cumulative_delta\", _averageMagnitude)\n        _cumulative += _averageMagnitude\n    else:\n        print(\"cumulative_delta\", -_averageMagnitude)\n        _cumulative -= _averageMagnitude\n    print(\"averageMagnitude,cumulative_after\", _averageMagnitude, _cumulative)\n    return _averageMagnitude, _cumulative\n\ndef main():\n    averageMagnitude = 0\n    cumulative = 7 * 24 * 3600\n    # 1\n    NO = 1\n    duration0 = 1004800\n    averageMagnitude, cumulative = update(duration0, averageMagnitude, cumulative, NO)\n    cache_c_delta0 = averageMagnitude\n    \n    # 2 \n    NO += 1\n    duration1 = 1172776\n    averageMagnitude, cumulative = update(duration1, averageMagnitude, cumulative, NO)\n\n    # after #1 unlock\n    # pool.cumulative -= #1.averageMagnitude\n    print(\"=================\")\n    cumulative_after_unlock = cumulative - cache_c_delta0\n    print(cumulative_after_unlock, cumulative_after_unlock <= 123454)\n    \nmain()\n```\n\nThe above py script simulates the math process of the attack, print log:\n\n    ╰─ python3 cumulative.py\n    ======1======\n    duration, cumulative_before 1004800 604800\n    cumulative_delta 567977\n    averageMagnitude,cumulative_after 567977 1172777\n    ======2======\n    duration, cumulative_before 1172776 1172777\n    cumulative_delta -526878\n    averageMagnitude,cumulative_after 526878 645899\n    =================\n    77922 True\n\n### Recommendation\n\nSet the minimum threshold for the check, such as 7 days; if the duration meets `EPOCH_DURATION <= duration <= minimum threshold || magnitude < pool.cumulative * 4`, then lock-in is permitted.\n\n### Assessed type\n\nContext\n\n**[0xWeiss (Tapioca) acknowledged](https://github.com/code-423n4/2024-02-tapioca-findings/issues/98#issuecomment-2125608685)**\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-02-tapioca-findings/issues/98).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/governance/twTAP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IPearlmit, PearlmitHandler} from \"tapioca-periph/Pearlmit/PearlmitHandler.sol\";\nimport {ERC721NftLoader} from \"tap-token/erc721NftLoader/ERC721NftLoader.sol\";\nimport {ERC721Permit} from \"tapioca-periph/utils/ERC721Permit.sol\";\nimport {ERC721PermitStruct} from \"tap-token/tokens/ITapToken.sol\";\nimport {TapToken} from \"tap-token/tokens/TapToken.sol\";\nimport {TWAML} from \"tap-token/options/twAML.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n// Justification for data sizes:\n// - 56 bits can represent over 2 billion years in seconds\n// - TAP has a maximum supply of 100 million, and a precision of 10^18. Any\n//   amount will therefore fit in (lg 10^26 = 87) bits.\n// - The multiplier has a maximum of 1 million; dMAX = 100 * 1e4, which fits\n//   in 20 bits.\n// - A week is 86400 * 7 = 604800 seconds; less than 2^20. Even if we start\n//   counting at the (Unix) epoch, we will run out of `expiry` before we\n//   saturate the week fields.\nstruct Participation {\n    uint256 averageMagnitude;\n    bool hasVotingPower;\n    bool divergenceForce; // 0 negative, 1 positive\n    bool tapReleased; // allow restaking while rewards may still accumulate\n    uint56 expiry; // expiry timestamp. Big enough for over 2 billion years..\n    uint88 tapAmount; // amount of TAP locked\n    uint24 multiplier; // Votes = multiplier * tapAmount\n    uint40 lastInactive; // One week BEFORE the staker gets a share of rewards\n    uint40 lastActive; // Last week that the staker shares in rewards\n}\n\nstruct TWAMLPool {\n    uint256 totalParticipants;\n    uint256 averageMagnitude;\n    uint256 totalDeposited;\n    uint256 cumulative;\n}\n\nstruct WeekTotals {\n    // For [0..currentWeek] this is a cumulative total: it consists of the\n    // active votes in the previous week, minus the votes known to expire this\n    // week. For future weeks, it is a negative number corresponding to the\n    // expiring votes.\n    int256 netActiveVotes;\n    // rewardTokens index -> amount\n    mapping(uint256 => uint256) totalDistPerVote;\n}\n\ncontract TwTAP is TWAML, ERC721, ERC721Permit, Ownable, PearlmitHandler, ERC721NftLoader, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    TapToken public immutable tapOFT;\n\n    /// ===== TWAML ======\n    TWAMLPool public twAML; // sglAssetId => twAMLPool\n\n    mapping(uint256 => Participation) public participants; // tokenId => part.\n\n    /// @dev Virtual total amount to add to the total when computing twAML participation right. Default 10_000 * 1e18.\n    uint256 private VIRTUAL_TOTAL_AMOUNT = 10_000 ether;\n\n    uint256 MIN_WEIGHT_FACTOR = 1000; // In BPS, default 10%\n    uint256 constant dMAX = 1_000_000; // 100 * 1e4; 0% - 100% voting power multiplier\n    uint256 constant dMIN = 0;\n    uint256 public constant EPOCH_DURATION = 7 days;\n    uint256 public constant MAX_LOCK_DURATION = 100 * 365 days; // 100 years\n\n    // If we assume 128 bit balances for the reward token -- which fit 1e40\n    // \"tokens\" at the most commonly used 1e18 precision -- then we can use the\n    // other 128 bits to store the tokens allotted to a single vote more\n    // accurately. Votes in turn are proportional to the amount of TAP locked,\n    // weighted by a multiplier. This number is at most 107 bits long (see\n    // definition of `Participation` struct).\n    // the weight ranges from 10-100% where 1% = 1e4, so 1 million (20 bits).\n    // the multiplier is at most 100% = 1M (20 bits), so votes is at most a\n    // 107-bit number.\n    uint256 constant DIST_PRECISION = 2 ** 128; //2 ** 128;\n\n    IERC20[] public rewardTokens;\n    mapping(IERC20 => uint256) public rewardTokenIndex; // Index 0 is reserved with 0x0 address\n    uint256 public maxRewardTokens;\n\n    // tokenId -> rewardTokens index -> amount\n    mapping(uint256 => mapping(uint256 => uint256)) public claimed;\n\n    // The current week is determined by creation, but there are values that\n    // need to be updated weekly. If, for any reason whatsoever, this cannot\n    // be done in time, the `lastProcessedWeek` will be behind until this is\n    // done.\n    uint256 public mintedTWTap;\n    uint256 public creation; // Week 0 starts here\n    uint256 public lastProcessedWeek;\n    mapping(uint256 => WeekTotals) public weekTotals;\n\n    event LogMaxRewardsLength(uint256 indexed _oldLength, uint256 indexed _newLength, uint256 indexed _currentLength);\n\n    error NotAuthorized();\n    error AdvanceWeekFirst();\n    error NotValid();\n    error Registered();\n    error TokenLimitReached();\n    error NotApproved(uint256 tokenId, address spender);\n    error Duplicate();\n    error LockNotExpired();\n    error LockNotAWeek();\n    error LockTooLong();\n    error AdvanceEpochFirst();\n\n    /// =====-------======\n    constructor(address payable _tapOFT, IPearlmit _pearlmit, address _owner)\n        ERC721NftLoader(\"Time Weighted TAP\", \"twTAP\", _owner)\n        ERC721Permit(\"Time Weighted TAP\")\n        PearlmitHandler(_pearlmit)\n    {\n        tapOFT = TapToken(_tapOFT);\n        creation = block.timestamp;\n\n        rewardTokens.push(IERC20(address(0x0))); // 0 index is reserved\n\n        maxRewardTokens = 30;\n\n        // Seed the cumulative with 1 week of magnitude\n        twAML.cumulative = EPOCH_DURATION;\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Participate(address indexed participant, uint256 indexed tapAmount, uint256 indexed multiplier);\n    event AMLDivergence(\n        uint256 indexed cumulative, uint256 indexed averageMagnitude, uint256 indexed totalParticipants\n    );\n    event ExitPosition(uint256 indexed tokenId, uint256 indexed amount);\n\n    // ==========\n    //    READ\n    // ==========\n\n    /**\n     * @inheritdoc ERC721NftLoader\n     */\n    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721NftLoader) returns (string memory) {\n        return ERC721NftLoader.tokenURI(tokenId);\n    }\n\n    /**\n     * @notice Return the address of reward tokens.\n     */\n    function getRewardTokens() external view returns (IERC20[] memory) {\n        return rewardTokens;\n    }\n\n    function currentWeek() public view returns (uint256) {\n        return (block.timestamp - creation) / EPOCH_DURATION;\n    }\n\n    /// @notice Return the participation of a token. Returns 0 votes for expired tokens.\n    function getParticipation(uint256 _tokenId) external view returns (Participation memory participant) {\n        participant = participants[_tokenId];\n        if (participant.expiry <= block.timestamp) {\n            participant.multiplier = 0;\n        }\n        return participant;\n    }\n\n    /**\n     * @notice Amount currently claimable for each reward token.\n     * @dev index 0 will ALWAYS return 0, as it's used by address(0x0).\n     * @dev Should be safe to claim even after position exit.\n     * @return claimable amounts mapped by reward token\n     */\n    function claimable(uint256 _tokenId) public view returns (uint256[] memory) {\n        uint256 len = rewardTokens.length;\n        uint256[] memory result = new uint256[](len);\n\n        Participation memory position = participants[_tokenId];\n        uint256 votes;\n        unchecked {\n            // Math is safe: Types fit\n            votes = uint256(position.tapAmount) * uint256(position.multiplier);\n        }\n\n        if (votes == 0) {\n            return result;\n        }\n\n        // If the \"last processed week\" is behind the actual week, rewards\n        // get processed as if it were earlier.\n        uint256 week = lastProcessedWeek;\n        if (week <= position.lastInactive) {\n            return result;\n        }\n        if (position.lastActive < week) {\n            week = position.lastActive;\n        }\n\n        WeekTotals storage cur = weekTotals[week];\n        WeekTotals storage prev = weekTotals[position.lastInactive];\n\n        for (uint256 i; i < len;) {\n            // Math is safe (but we do the checks anyway):\n            //\n            // -- The `totalDistPerVote[i]` values are increasing as a\n            //    function of weeks (see `advanceWeek()`), and if `week`\n            //    were not greater than `position.lastInactive`, this bit\n            //    of code would not be reached (see above). Therefore the\n            //    subtraction in the calculation of `net` cannot underflow.\n            //\n            // -- `votes * net` is at most the entire reward amount given\n            //    out, ever, in units of\n            //\n            //        (reward tokens) * DIST_PRECISION.\n            //\n            //    If this number were to exceed 256 bits, then\n            //    `distributeReward` would revert.\n            //\n            // -- `claimed[_tokenId][i]` is the sum of all (the i-th values\n            //    of) previous calls to the current function that were made\n            //    by `_claimRewards()`. Let there be n such calls, and let\n            //    r_j be `result[i]`, c_j be `claimed[_tokenId][i]`, and\n            //    net_j be `net` during that j-th call. Then, up to a\n            //    multiplication by votes / DIST_PRECISION:\n            //\n            //              c_1 = 0 <= net_1,\n            //\n            //    and, for n > 1:\n            //\n            //              c_n = r_(n-1) + r_(n-2) + ... + r_1\n            //                  = r_(n-1) + c_(n-1)\n            //                  = (net_(n-1) - c_(n-1) + c_(n-1)\n            //                  = net_(n-1)\n            //                  <= net_n,\n            //\n            //    so that the subtraction net_n - c_n does not underflow.\n            //    (The rounding the calculation favors the greater first\n            //    term).\n            //    (TODO: Word better?)\n            //\n            uint256 net = cur.totalDistPerVote[i] - prev.totalDistPerVote[i];\n            result[i] = ((votes * net) / DIST_PRECISION) - claimed[_tokenId][i];\n            unchecked {\n                ++i;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the hash of the struct used by the permit function.\n     * @param _permitData Struct containing permit data.\n     */\n    function getTypedDataHash(ERC721PermitStruct calldata _permitData) public view returns (bytes32) {\n        bytes32 permitTypeHash_ = keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n\n        bytes32 structHash_ = keccak256(\n            abi.encode(\n                permitTypeHash_, _permitData.spender, _permitData.tokenId, _permitData.nonce, _permitData.deadline\n            )\n        );\n        return _hashTypedDataV4(structHash_);\n    }\n\n    // ===========\n    //    WRITE\n    // ===========\n\n    /// @notice Participate in twAML voting and mint an twTap position\n    /// @dev Requires a Pearlmit approval for the TAP amount\n    ///\n    /// @param _participant The address of the participant\n    /// @param _amount The amount of TAP to participate with\n    /// @param _duration The duration of the lock\n    function participate(address _participant, uint256 _amount, uint256 _duration)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (uint256 tokenId)\n    {\n        if (_duration < EPOCH_DURATION) revert LockNotAWeek();\n        if (_duration > MAX_LOCK_DURATION) revert LockTooLong();\n        if (_timestampToWeek(block.timestamp) > currentWeek()) revert AdvanceEpochFirst();\n\n        // Transfer TAP to this contract\n        {\n            // tapOFT.transferFrom(msg.sender, address(this), _amount);\n            bool isErr = pearlmit.transferFromERC20(msg.sender, address(this), address(tapOFT), _amount);\n            if (isErr) revert NotAuthorized();\n        }\n\n        // Copy to memory\n        TWAMLPool memory pool = twAML;\n\n        uint256 magnitude = computeMagnitude(_duration, pool.cumulative);\n        // Revert if the lock 4x the cumulative\n        if (magnitude >= pool.cumulative * 4) revert NotValid();\n        uint256 multiplier = computeTarget(dMIN, dMAX, magnitude, pool.cumulative);\n\n        // Calculate twAML voting weight\n        bool divergenceForce;\n        bool hasVotingPower = _amount >= computeMinWeight(pool.totalDeposited + VIRTUAL_TOTAL_AMOUNT, MIN_WEIGHT_FACTOR);\n        if (hasVotingPower) {\n            pool.totalParticipants++; // Save participation\n            pool.averageMagnitude = (pool.averageMagnitude + magnitude) / pool.totalParticipants; // compute new average magnitude\n\n            // Compute and save new cumulative\n            divergenceForce = _duration >= pool.cumulative;\n\n            if (divergenceForce) {\n                pool.cumulative += pool.averageMagnitude;\n            } else {\n                // TODO: Strongly suspect this is never less. Prove it.\n                if (pool.cumulative > pool.averageMagnitude) {\n                    pool.cumulative -= pool.averageMagnitude;\n                } else {\n                    pool.cumulative = 0;\n                }\n            }\n\n            // Save new weight\n            pool.totalDeposited += _amount;\n\n            twAML = pool; // Save twAML participation\n            emit AMLDivergence(pool.cumulative, pool.averageMagnitude, pool.totalParticipants);\n        }\n\n        uint256 expiry = block.timestamp + _duration;\n        // Eligibility starts NEXT week, and lasts until the week that the lock\n        // expires. This is guaranteed to be at least one week later by the\n        // check on `_duration`.\n        // If a user locks right before the current week ends, and have a\n        // duration slightly over one week, straddling the two starting points,\n        // then that user is eligible for the rewards during both weeks; the\n        // price for this maneuver is a lower multiplier, and loss of voting\n        // power in the DAO after the lock expires.\n        uint256 w0 = currentWeek();\n        uint256 w1 = (expiry - creation) / EPOCH_DURATION;\n\n        // Save twAML participation\n        // Casts are safe: see struct definition\n        tokenId = ++mintedTWTap;\n        uint256 votes = _amount * multiplier;\n        participants[tokenId] = Participation({\n            averageMagnitude: pool.averageMagnitude,\n            hasVotingPower: hasVotingPower,\n            divergenceForce: divergenceForce,\n            tapReleased: false,\n            expiry: uint56(expiry),\n            tapAmount: uint88(_amount),\n            multiplier: uint24(multiplier),\n            lastInactive: uint40(w0),\n            lastActive: uint40(w1)\n        });\n\n        // w0 + 1 = lastInactive + 1 = first active\n        // w1 + 1 = lastActive + 1 = first inactive\n        // Cast is safe: `votes` is the product of a uint88 and a uint24\n        weekTotals[w0 + 1].netActiveVotes += int256(votes);\n        weekTotals[w1 + 1].netActiveVotes -= int256(votes);\n\n        // Mint twTAP position\n        _safeMint(_participant, tokenId);\n\n        emit Participate(_participant, _amount, multiplier);\n        // TODO: Mint event?\n    }\n\n    /**\n     * @notice claims all rewards distributed since token mint or last claim.\n     * @dev Should be safe to claim even after position exit.\n     *\n     * @param _tokenId tokenId whose rewards to claim\n     * @param _to address to receive the rewards\n     *\n     * @return amounts_ Claimed amount of each reward token.\n     */\n    function claimRewards(uint256 _tokenId, address _to)\n        external\n        nonReentrant\n        whenNotPaused\n        returns (uint256[] memory amounts_)\n    {\n        _requireClaimPermission(_to, _tokenId);\n        amounts_ = _claimRewards(_tokenId, _to);\n    }\n\n    /**\n     * @notice Exit a twAML participation, delete the voting power if existing and send the TAP to `_to`.\n     *\n     * @param _tokenId The tokenId of the twTAP position.\n     * @param _to address to receive the TAP.\n     *\n     * @return tapAmount_ The amount of TAP released.\n     */\n    function exitPosition(uint256 _tokenId, address _to)\n        external\n        nonReentrant\n        whenNotPaused\n        returns (uint256 tapAmount_)\n    {\n        {\n            address owner_ = ownerOf(_tokenId);\n            if (_to != owner_) {\n                _requireClaimPermission(_to, _tokenId);\n            }\n        }\n        tapAmount_ = _releaseTap(_tokenId, _to);\n    }\n\n    /// @notice Indicate that (a) week(s) have passed and update running totals\n    /// @notice Reverts if called in week 0. Let it.\n    /// @param _limit Maximum number of weeks to process in one call\n    function advanceWeek(uint256 _limit) public nonReentrant {\n        // TODO: Make whole function unchecked\n        uint256 week = lastProcessedWeek;\n        uint256 goal = currentWeek();\n        unchecked {\n            if (goal - week > _limit) {\n                goal = week + _limit;\n            }\n        }\n        uint256 len = rewardTokens.length;\n        while (week < goal) {\n            WeekTotals storage prev = weekTotals[week];\n            WeekTotals storage next = weekTotals[++week];\n            // TODO: Prove that math is safe\n            next.netActiveVotes += prev.netActiveVotes;\n            for (uint256 i; i < len;) {\n                next.totalDistPerVote[i] += prev.totalDistPerVote[i];\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        lastProcessedWeek = goal;\n    }\n\n    /// @notice distributes a reward among all tokens, weighted by voting power\n    /// @notice The reward gets allocated to all positions that have locked in\n    /// @notice the current week. Fails, intentionally, if this number is zero.\n    /// @notice Total rewards cannot exceed 2^128 tokens.\n    /// @param _rewardTokenId index of the reward in `rewardTokens`\n    /// @param _amount amount of reward token to distribute.\n    function distributeReward(uint256 _rewardTokenId, uint256 _amount) external nonReentrant {\n        if (lastProcessedWeek != currentWeek()) revert AdvanceWeekFirst();\n        if (_amount == 0) revert NotValid();\n        if (_rewardTokenId == 0) revert NotValid(); // @dev rewardTokens[0] is 0x0\n\n        WeekTotals storage totals = weekTotals[lastProcessedWeek];\n        IERC20 rewardToken = rewardTokens[_rewardTokenId];\n        // If this is a DBZ then there are no positions to give the reward to.\n        // Since reward eligibility starts in the week after locking, there is\n        // no way to give out rewards THIS week.\n        // Cast is safe: `netActiveVotes` is at most zero by construction of\n        // weekly totals and the requirement that they are up to date.\n        // TODO: Word this better\n        totals.totalDistPerVote[_rewardTokenId] += (_amount * DIST_PRECISION) / uint256(totals.netActiveVotes);\n\n        rewardToken.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    // =========\n    //   OWNER\n    // =========\n\n    /**\n     * @notice Set the `VIRTUAL_TOTAL_AMOUNT` state variable.\n     * @param _virtualTotalAmount The new state variable value.\n     */\n    function setVirtualTotalAmount(uint256 _virtualTotalAmount) external onlyOwner {\n        VIRTUAL_TOTAL_AMOUNT = _virtualTotalAmount;\n    }\n\n    /**\n     * @notice Set the minimum weight factor.\n     * @param _minWeightFactor The new minimum weight factor.\n     */\n    function setMinWeightFactor(uint256 _minWeightFactor) external onlyOwner {\n        MIN_WEIGHT_FACTOR = _minWeightFactor;\n    }\n\n    function setMaxRewardTokensLength(uint256 _length) external onlyOwner {\n        emit LogMaxRewardsLength(maxRewardTokens, _length, rewardTokens.length);\n        maxRewardTokens = _length;\n    }\n\n    /**\n     * @notice Add a reward token to the list of reward tokens.\n     * @param _token The address of the reward token.\n     */\n    // TODO Check if it should be one type of token only? Like OFT?\n    function addRewardToken(IERC20 _token) external onlyOwner returns (uint256) {\n        if (rewardTokenIndex[_token] != 0) revert Registered();\n        if (rewardTokens.length + 1 > maxRewardTokens) {\n            revert TokenLimitReached();\n        }\n        rewardTokens.push(_token);\n\n        uint256 newTokenIndex = rewardTokens.length - 1;\n        rewardTokenIndex[_token] = newTokenIndex;\n\n        return newTokenIndex;\n    }\n\n    /**\n     * @notice Un/Pauses this contract.\n     */\n    function setPause(bool _pauseState) external onlyOwner {\n        if (_pauseState) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // ============\n    //   INTERNAL\n    // ============\n\n    /// @notice returns week for timestamp\n    function _timestampToWeek(uint256 timestamp) internal view returns (uint256) {\n        return ((timestamp - creation) / EPOCH_DURATION);\n    }\n\n    /**\n     * @dev Use `_isApprovedOrOwner()` internally.\n     */\n    function _requireClaimPermission(address _to, uint256 _tokenId) internal view {\n        if (!_isApprovedOrOwner(_to, _tokenId) && !isERC721Approved(_ownerOf(_tokenId), _to, address(this), _tokenId)) {\n            revert NotApproved(_tokenId, msg.sender);\n        }\n    }\n\n    /**\n     * @dev Claim rewards on a token.\n     * @return amounts_ Claimed amount of each reward token.\n     */\n    function _claimRewards(uint256 _tokenId, address _to) internal returns (uint256[] memory amounts_) {\n        amounts_ = claimable(_tokenId);\n        uint256 len = amounts_.length;\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                uint256 amount = amounts_[i];\n                if (amount > 0) {\n                    // Math is safe: `amount` calculated safely in `claimable()`\n                    claimed[_tokenId][i] += amount;\n                    rewardTokens[i].safeTransfer(_to, amount);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Release the TAP locked in a position whose votes have expired.\n     * @dev Clean up the twAML participation and delete the voting power if existing.\n     * @dev !!!!!!!!!! Make sure to verify ownership of `_tokenId` and `_to` !!!!!!!!!!\n     *\n     * @param _tokenId tokenId whose locked TAP to claim\n     * @param _to address to receive the TAP\n     */\n    function _releaseTap(uint256 _tokenId, address _to) internal returns (uint256 releasedAmount) {\n        Participation memory position = participants[_tokenId];\n        if (position.expiry > block.timestamp) revert LockNotExpired();\n        if (position.tapReleased) {\n            return 0;\n        }\n\n        releasedAmount = position.tapAmount;\n\n        // Remove participation\n        if (position.hasVotingPower) {\n            TWAMLPool memory pool = twAML;\n            unchecked {\n                --pool.totalParticipants;\n            }\n\n            // Inverse of the participation. The participation entry tracks\n            // the average magnitude as it was at the time the participant\n            // entered. When going the other way around, this value matches the\n            // one in the pool, but here it does not.\n            if (position.divergenceForce) {\n                if (pool.cumulative > position.averageMagnitude) {\n                    pool.cumulative -= position.averageMagnitude;\n                } else {\n                    pool.cumulative = 0;\n                }\n            } else {\n                pool.cumulative += position.averageMagnitude;\n            }\n\n            // Save new weight\n            pool.totalDeposited -= position.tapAmount;\n\n            twAML = pool; // Save twAML exit\n            emit AMLDivergence(pool.cumulative, pool.averageMagnitude, pool.totalParticipants); // Register new voting power event\n        }\n\n        participants[_tokenId].tapReleased = true;\n        tapOFT.transfer(_to, releasedAmount);\n\n        emit ExitPosition(_tokenId, releasedAmount);\n    }\n\n    /// @notice Checks if an element is in an array\n    /// @param _check The element to check\n    /// @param _array The array to check in\n    function _existInArray(address _check, address[] memory _array) internal pure returns (bool) {\n        uint256 len = _array.length;\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                if (_array[i] == _check) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /// @notice Returns the chain ID of the current network.\n    /// @dev Used for dev purposes.\n    function _getChainId() internal view virtual returns (uint256) {\n        return block.chainid;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/options/TapiocaOptionBroker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {TapiocaOptionLiquidityProvision, LockPosition, SingularityPool} from \"./TapiocaOptionLiquidityProvision.sol\";\nimport {IPearlmit, PearlmitHandler} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {TapToken} from \"tap-token/tokens/TapToken.sol\";\nimport {OTAP, TapOption} from \"./oTAP.sol\";\nimport {TWAML} from \"./twAML.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nstruct Participation {\n    bool hasVotingPower;\n    bool divergenceForce; // 0 negative, 1 positive\n    uint256 averageMagnitude;\n}\n\nstruct TWAMLPool {\n    uint256 totalParticipants;\n    uint256 averageMagnitude;\n    uint256 totalDeposited;\n    uint256 cumulative;\n}\n\nstruct PaymentTokenOracle {\n    ITapiocaOracle oracle;\n    bytes oracleData;\n}\n\ncontract TapiocaOptionBroker is Pausable, Ownable, PearlmitHandler, IERC721Receiver, TWAML, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    TapiocaOptionLiquidityProvision public immutable tOLP;\n    bytes public tapOracleData;\n    TapToken public immutable tapOFT;\n    OTAP public immutable oTAP;\n    ITapiocaOracle public tapOracle;\n\n    uint256 public epochTAPValuation; // TAP price for the current epoch\n    uint256 public epoch; // Represents the number of weeks since the start of the contract\n\n    mapping(uint256 => Participation) public participants; // tOLPTokenID => Participation\n    mapping(uint256 => mapping(uint256 => uint256)) public oTAPCalls; // oTAPTokenID => epoch => amountExercised\n\n    mapping(uint256 => mapping(uint256 => uint256)) public singularityGauges; // epoch => sglAssetId => availableTAP\n\n    mapping(ERC20 => PaymentTokenOracle) public paymentTokens; // Token address => PaymentTokenOracle\n    address public paymentTokenBeneficiary; // Where to collect the payment tokens\n\n    /// ===== TWAML ======\n    mapping(uint256 => TWAMLPool) public twAML; // sglAssetId => twAMLPool\n\n    /// @dev Virtual total amount to add to the total when computing twAML participation right. Default 10_000 * 1e18.\n    uint256 private VIRTUAL_TOTAL_AMOUNT = 10_000 ether;\n\n    uint256 public MIN_WEIGHT_FACTOR = 1000; // In BPS, default 10%\n    uint256 constant dMAX = 500_000; // 50 * 1e4; 0% - 50% discount\n    uint256 constant dMIN = 0;\n    uint256 public immutable EPOCH_DURATION; // 7 days = 604800\n\n    /// @notice starts time for emissions\n    /// @dev initialized in the constructor with block.timestamp\n    uint256 public immutable emissionsStartTime;\n\n    /// @notice Total amount of participation per epoch\n    mapping(uint256 epoch => mapping(uint256 sglAssetID => int256 netAmount)) public netDepositedForEpoch;\n    /// =====-------======\n\n    error NotEqualDurations();\n    error NotAuthorized();\n    error NoActiveSingularities();\n    error NoLiquidity();\n    error OptionExpired();\n    error PaymentTokenNotSupported();\n    error OneEpochCooldown();\n    error TooHigh();\n    error TooLong();\n    error TooLow();\n    error DurationTooShort();\n    error PositionNotValid();\n    error LockNotExpired();\n    error TooSoon();\n    error Failed();\n    error TransferFailed();\n    error SingularityInRescueMode();\n    error PaymentTokenValuationNotValid();\n    error LockExpired();\n    error AdvanceEpochFirst();\n\n    constructor(\n        address _tOLP,\n        address _oTAP,\n        address payable _tapOFT,\n        address _paymentTokenBeneficiary,\n        uint256 _epochDuration,\n        IPearlmit _pearlmit,\n        address _owner\n    ) PearlmitHandler(_pearlmit) {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n        tOLP = TapiocaOptionLiquidityProvision(_tOLP);\n\n        if (_epochDuration != TapiocaOptionLiquidityProvision(_tOLP).EPOCH_DURATION()) revert NotEqualDurations();\n\n        tapOFT = TapToken(_tapOFT);\n        oTAP = OTAP(_oTAP);\n        EPOCH_DURATION = _epochDuration;\n        emissionsStartTime = block.timestamp;\n\n        _transferOwnership(_owner);\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Participate(\n        uint256 indexed epoch, uint256 indexed sglAssetID, uint256 totalDeposited, uint256 tokenId, uint256 discount\n    );\n    event AMLDivergence(uint256 indexed epoch, uint256 cumulative, uint256 averageMagnitude, uint256 totalParticipants);\n    event ExerciseOption(\n        uint256 indexed epoch, address indexed to, ERC20 indexed paymentToken, uint256 oTapTokenID, uint256 amount\n    );\n    event NewEpoch(uint256 indexed epoch, uint256 extractedTAP, uint256 epochTAPValuation);\n    event ExitPosition(uint256 indexed epoch, uint256 tolpTokenId, uint256 amount);\n    event SetPaymentToken(ERC20 indexed paymentToken, ITapiocaOracle oracle, bytes oracleData);\n    event SetTapOracle(ITapiocaOracle indexed oracle, bytes indexed oracleData);\n\n    // ==========\n    //    READ\n    // ==========\n    /// @notice Returns the current week given a timestamp\n    function timestampToWeek(uint256 timestamp) external view returns (uint256) {\n        if (timestamp == 0) {\n            timestamp = block.timestamp;\n        }\n        if (timestamp < emissionsStartTime) return 0;\n\n        return _timestampToWeek(timestamp);\n    }\n\n    /// @notice Returns the current week\n    function getCurrentWeek() external view returns (uint256) {\n        return _timestampToWeek(block.timestamp);\n    }\n\n    /// @notice Returns the details of an OTC deal for a given oTAP token ID and a payment token.\n    ///         The oracle uses the last peeked value, and not the latest one, so the payment amount may be different.\n    /// @param _oTAPTokenID The oTAP token ID\n    /// @param _paymentToken The payment token\n    /// @param _tapAmount The amount of TAP to be exchanged. If 0 it will use the full amount of TAP eligible for the deal\n    /// @return eligibleTapAmount The amount of TAP eligible for the deal\n    /// @return paymentTokenAmount The amount of payment tokens required for the deal\n    /// @return tapAmount The amount of TAP to be exchanged\n    function getOTCDealDetails(uint256 _oTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        view\n        returns (uint256 eligibleTapAmount, uint256 paymentTokenAmount, uint256 tapAmount)\n    {\n        // Load data\n        (, TapOption memory oTAPPosition) = oTAP.attributes(_oTAPTokenID);\n        LockPosition memory tOLPLockPosition = tOLP.getLock(oTAPPosition.tOLP);\n\n        {\n            if (!_isPositionActive(tOLPLockPosition)) revert OptionExpired();\n        }\n\n        uint256"
    }
  ]
}