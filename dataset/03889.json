{
  "Title": "Potentially `approved` cache miss",
  "Content": "##### Description\nAt lines https://github.com/abyssfinance/abyss-lockup/blob/8fe1a854a9b01dc1aa35272b82fd22655d4f42d1/contracts/AbyssSafe3.sol#L202-L216 contract has approval caching mechanism, that works fine if token supports infinity approval, so in other cases cached approve might tell wrong info.\n\n##### Recommendation\nIt is recommended to check approval permanently\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/AbyssSafe3.sol",
      "content": "/*\n░█████╗░██████╗░██╗░░░██╗░██████╗░██████╗  ███████╗██╗███╗░░██╗░█████╗░███╗░░██╗░█████╗░███████╗\n██╔══██╗██╔══██╗╚██╗░██╔╝██╔════╝██╔════╝  ██╔════╝██║████╗░██║██╔══██╗████╗░██║██╔══██╗██╔════╝\n███████║██████╦╝░╚████╔╝░╚█████╗░╚█████╗░  █████╗░░██║██╔██╗██║███████║██╔██╗██║██║░░╚═╝█████╗░░\n██╔══██║██╔══██╗░░╚██╔╝░░░╚═══██╗░╚═══██╗  ██╔══╝░░██║██║╚████║██╔══██║██║╚████║██║░░██╗██╔══╝░░\n██║░░██║██████╦╝░░░██║░░░██████╔╝██████╔╝  ██║░░░░░██║██║░╚███║██║░░██║██║░╚███║╚█████╔╝███████╗\n╚═╝░░╚═╝╚═════╝░░░░╚═╝░░░╚═════╝░╚═════╝░  ╚═╝░░░░░╚═╝╚═╝░░╚══╝╚═╝░░╚═╝╚═╝░░╚══╝░╚════╝░╚══════╝\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../contracts/interfaces/IAbyssLockup.sol\";\n\n/**\n * Abyss Finance's AbyssSafe Contract\n * The main smart contract that is responsible for deposits and withdrawal of tokens.\n */\ncontract AbyssSafe3 is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 public tokenContract;\n    IAbyssLockup public lockupContract;\n    uint256 private _lockupTime;\n    uint256 private _abyssRequired;\n\n    /**\n     * @dev The parameter responsible for global disabling and enabling of new deposits.\n     */\n    bool public disabled;\n\n    /**\n     * @dev Here we store data for each locked token address of a specific wallet.\n     *\n     * - deposited - Amount of deposited tokens.\n     * - requested - Amount of requested tokens for withdrawing.\n     * - timestamp - Token deposit time or token unlock time established at an active withdrawal request\n     */\n    struct Data {\n        uint256 deposited;\n        uint256 divFactorDeposited;\n        uint256 requested;\n        uint256 divFactorRequested;\n        uint256 timestamp;\n    }\n\n    /**\n     * @dev Here we store data for every ever locked token on this smart contract.\n     *\n     * - disabled - A true value implies that this token cannot be deposited on the smart contract, while all other actions are allowed.\n     * - approved - A true value implies that lockupContract is approved on transferFrom this smart contract.\n     * - deposited - A total deposited token amount on the smart contract for the token address.\n     * - requested - A total requested token amount from the smart contract.\n     */\n    struct Token {\n        bool disabled;\n        bool approved;\n        uint256 deposited;\n        uint256 divFactorDeposited;\n        uint256 requested;\n        uint256 divFactorRequested;\n    }\n\n    mapping (address => mapping (address => Data)) private _data;\n    mapping (address => Token) private _tokens;\n\n    /**\n     * @dev Stores the amount of Abyss required for withdrawals after deposit for the caller's address.\n     */\n    mapping (address => uint256) private _rates;\n\n    constructor(address token, address lockup, uint256 lockupTime, uint256 abyssRequired) public {\n        tokenContract = IERC20(address(token));\n        lockupContract = IAbyssLockup(address(lockup));\n        _lockupTime = lockupTime;\n        _abyssRequired = abyssRequired;\n    }\n\n    // VIEW FUNCTIONS\n\n    /**\n     * @dev Lockup delay (in seconds) after withdrawal request.\n     */\n    function lockupTime() public view returns (uint256) {\n        return _lockupTime;\n    }\n\n    /**\n     * @dev Amount of Abyss required for service usage.\n     */\n    function abyssRequired() public view returns (uint256) {\n        return _abyssRequired;\n    }\n\n    /**\n     * @dev Amount of Abyss required for withdrawal requests and withdraw after deposit is made.\n     */\n    function rate(address account) public view returns (uint256) {\n        return _rates[account];\n    }\n\n    /**\n     * @dev Time of possible `token` withdrawal for the `account` if withdrawal request was made.\n     * Time of `token` deposit if there were no withdrawal requests by the `account`.\n     */\n    function timestamp(address account, address token) public view returns (uint256) {\n        return _data[account][token].timestamp;\n    }\n\n    /**\n     * @dev Amount of `token` deposited by the `account`.\n     */\n    function deposited(address account, address token) public view returns (uint256) {\n        return _data[account][token].deposited;\n    }\n\n    /**\n     * @dev Amount of `token` requested for withdrawal by the `account`.\n     */\n    function requested(address account, address token) public view returns (uint256) {\n        return _data[account][token].requested;\n    }\n\n    /**\n     * @dev divFactor (rebase support) for specific `account` and `token` deposited.\n     */\n    function divFactorDeposited(address account, address token) public view returns (uint256) {\n        return _data[account][token].divFactorDeposited;\n    }\n\n    /**\n     * @dev divFactor (rebase support) for specific `account` and `token` requested.\n     */\n    function divFactorRequested(address account, address token) public view returns (uint256) {\n        return _data[account][token].divFactorRequested;\n    }\n\n    /**\n     * @dev Total mount of `token` deposited to this smart contract.\n     */\n    function totalDeposited(address token) public view returns (uint256) {\n        return _tokens[token].deposited;\n    }\n\n    /**\n     * @dev Total mount of `token` requested for withdrawal from this smart contract.\n     */\n    function totalRequested(address token) public view returns (uint256) {\n        return _tokens[token].requested;\n    }\n\n    /**\n     * @dev divFactor (rebase support) for specific `token` deposited.\n     */\n    function totalDivFactorDeposited(address token) public view returns (uint256) {\n        return _tokens[token].divFactorDeposited;\n    }\n\n    /**\n     * @dev divFactor (rebase support) for specific `token` requested.\n     */\n    function totalDivFactorRequested(address token) public view returns (uint256) {\n        return _tokens[token].divFactorRequested;\n    }\n\n    // ACTION FUNCTIONS\n\n    /**\n     * @dev Moves `amount` of `token` from the caller's account to this smart contract.\n     *\n     * Requirements:\n     *\n     * - Contract is active and deposits for a specific token are not prohibited.\n     * - Required Abyss amount is available on the account.\n     * - Token smart contract has the right to move the tokens intended for deposit.\n     * - User’s balance is greater than zero and greater than the amount they intend to deposit.\n     */\n    function deposit(address token, uint256 amount) public nonReentrant isAllowed(msg.sender, token) returns (bool) {\n        require(disabled == false && _tokens[token].disabled == false, \"AbyssSafe: disabled\");\n\n        uint256 _tempFreeDeposits;\n\n        if (_abyssRequired > 0 && token != address(tokenContract)) {\n            _tempFreeDeposits = lockupContract.freeDeposits();\n            require(_tempFreeDeposits > 0 || tokenContract.balanceOf(msg.sender) >= _abyssRequired, \"AbyssSafe: not enough Abyss\");\n        }\n\n        require(IERC20(address(token)).allowance(msg.sender, address(lockupContract)) > amount, \"AbyssSafe: you need to approve token first\");\n        require(IERC20(address(token)).balanceOf(msg.sender) >= amount && amount > 0, \"AbyssSafe: you cannot lock this amount\");\n\n        if (IERC20(address(token)).balanceOf(address(this)) == 0 && _tokens[token].deposited > 0) {\n            revert(\"AbyssSafe: something went wrong\");\n        }\n        /**\n         * @dev Verifies that the `lockupContract` has permission to move a given token located on this contract.\n         */\n        if (_tokens[token].approved == false) {\n\n            /**\n             * @dev Add permission to move `token` from this contract for `lockupContract`.\n             */\n            SafeERC20.safeApprove(IERC20(address(token)), address(lockupContract), uint256(-1));\n            /**\n             * @dev Verify that the permission was correctly applied to exclude any future uncertainties.\n             */\n            require(IERC20(address(token)).allowance(address(this), address(lockupContract)) > 0, \"AbyssSafe: allowance issue\");\n            /**\n             * @dev Add verification flag to improve efficiency and avoid revisiting the token smart contract, for gas economy.\n             */\n            _tokens[token].approved = true;\n        }\n\n        uint256 _tempBalanceSafe = IERC20(address(token)).balanceOf(address(this));\n\n        /**\n         * @dev Code that supports rebase of specific `token`.\n         */\n        if (_tokens[token].deposited != _tempBalanceSafe) {\n            if (_tokens[token].deposited > 0) {\n\n                _tokens[token].divFactorDeposited = SafeMath.div(\n                                                        SafeMath.mul(\n                                                            _tokens[token].divFactorDeposited,\n                                                            _tempBalanceSafe\n                                                            ),\n                                                        _tokens[token].deposited\n                                                        );\n\n                _tokens[token].deposited = _tempBalanceSafe;\n\n            } else {\n                lockupContract.externalTransfer(token, address(this), owner(), _tempBalanceSafe, 0, 0, 0);\n            }\n        }\n\n        if (_tokens[token].divFactorDeposited == 0) {\n            _tokens[token].divFactorDeposited = 1e36;\n        }\n\n        if (_data[msg.sender][token].divFactorDeposited == 0) {\n\n            _data[msg.sender][token].divFactorDeposited = _tokens[token].divFactorDeposited;\n\n        } else if (_data[msg.sender][token].divFactorDeposited != _tokens[token].divFactorDeposited) {\n            _data[msg.sender][token].deposited = SafeMath.div(\n                                                      SafeMath.mul(\n                                                          _data[msg.sender][token].deposited,\n                                                          _tokens[token].divFactorDeposited\n                                                          ),\n                                                      _data[msg.sender][token].divFactorDeposited\n                                                      );\n\n            _data[msg.sender][token].divFactorDeposited = _tokens[token].divFactorDeposited;\n        }\n\n        /**\n         * @dev Increases the number of deposited User tokens.\n         */\n        _data[msg.sender][token].deposited = SafeMath.add(_data[msg.sender][token].deposited, amount);\n\n        /**\n         * @dev Changes the total amount of deposited tokens.\n         */\n        _tokens[token].deposited = SafeMath.add(_tokens[token].deposited, amount);\n\n        /**\n         * @dev Writes down the cost of using the service so that any future amount requirement\n         * increases won’t affect pre-existing users until they make a new deposit.\n         */\n        if (_tempFreeDeposits > 0) {\n            _rates[msg.sender] = 0;\n        } else {\n            _rates[msg.sender] = _abyssRequired;\n        }\n\n        emit Deposit(msg.sender, token, amount);\n\n        /**\n         * @dev Moves `amount` of `token` from the caller's account to this smart contract with the help of `lockupContract` smart contract.\n         */\n        lockupContract.externalTransfer(token, msg.sender, address(this), amount, _abyssRequired, 0, 0);\n        return true;\n    }\n\n    /**\n     * @dev Creates withdrawal request for the full amount of `token` deposited to this smart contract by the caller's account.\n     *\n     * Requirements:\n     *\n     * - Required Abyss amount is available on the account.\n     * - There is no pending active withdrawal request for `token` by the caller's account.\n     * - The caller has any amount of `token` deposited to this smart contract.\n     * - User’s balance is greater than zero and greater than the amount they intend to deposit.\n     */\n    function request(address token, uint256 amount) external nonReentrant isAllowed(msg.sender, token) returns (bool) {\n        require(\n            _rates[msg.sender] == 0 ||\n            token == address(tokenContract) ||\n            tokenContract.balanceOf(msg.sender) >= _rates[msg.sender],\n            \"AbyssSafe: not enough Abyss\");\n        require(_data[msg.sender][token].requested == 0, \"AbyssSafe: you already requested\");\n        require(_data[msg.sender][token].deposited > 0, \"AbyssSafe: nothing to withdraw\");\n\n        uint256 _tempBalanceSafe = IERC20(address(token)).balanceOf(address(this));\n        require(_tempBalanceSafe > 0, \"AbyssSafe: something went wrong\");\n\n        /**\n         * @dev Code that supports rebase of specific `token`.\n         */\n        if (_tokens[token].deposited != _tempBalanceSafe) {\n\n            _tokens[token].divFactorDeposited = SafeMath.div(\n                                                    SafeMath.mul(\n                                                        _tokens[token].divFactorDeposited,\n                                                        _tempBalanceSafe\n                                                        ),\n                                                    _tokens[token].deposited\n                                                    );\n\n            _tokens[token].deposited = _tempBalanceSafe;\n\n        }\n\n        if (_data[msg.sender][token].divFactorDeposited != _tokens[token].divFactorDeposited) {\n\n            _data[msg.sender][token].deposited = SafeMath.div(\n                                                      SafeMath.mul(\n                                                          _data[msg.sender][token].deposited,\n                                                          _tokens[token].divFactorDeposited\n                                                          ),\n                                                      _data[msg.sender][token].divFactorDeposited\n                                                      );\n\n            if (_tokens[token].deposited > _data[msg.sender][token].deposited) {\n                if (SafeMath.sub(_tokens[token].deposited, _data[msg.sender][token].deposited) == 1) {\n                    _data[msg.sender][token].deposited = _tokens[token].deposited;\n                }\n            }\n\n            _data[msg.sender][token].divFactorDeposited = _tokens[token].divFactorDeposited;\n        }\n\n        uint256 _tempLockupBalance = IERC20(address(token)).balanceOf(address(lockupContract));\n        uint256 _tempDepositedLockup = IAbyssLockup(address(lockupContract)).deposited(token);\n        uint256 _tempLockupDivFactor = IAbyssLockup(address(lockupContract)).divFactor(token);\n\n        if (_tempDepositedLockup != _tempLockupBalance) {\n            if (_tempDepositedLockup > 0) {\n\n                _tempLockupDivFactor = SafeMath.div(\n                                            SafeMath.mul(\n                                                _tempLockupDivFactor,\n                                                _tempLockupBalance\n                                                ),\n                                            _tempDepositedLockup\n                                            );\n\n            } else {\n                lockupContract.externalTransfer(token, address(lockupContract), owner(), _tempLockupBalance, 0, 0, 0);\n            }\n        }\n\n        if (_tokens[token].divFactorRequested != _tempLockupDivFactor) {\n\n            if (_tokens[token].divFactorRequested != 0) {\n\n                _tokens[token].divFactorRequested = SafeMath.div(\n                                                        SafeMath.mul(\n                                                            _tokens[token].divFactorRequested,\n                                                            _tempLockupBalance\n                                                            ),\n                                                        _tempDepositedLockup\n                                                        );\n\n                _tokens[token].requested =  SafeMath.div(\n                                                SafeMath.mul(\n                                                    _tokens[token].requested,\n                                                    _tokens[token].divFactorRequested\n                                                    ),\n                                                1e36\n                                                );\n            } else {\n                _tokens[token].divFactorRequested = _tempLockupDivFactor;\n            }\n        } else if (_tempLockupDivFactor == 0) {\n            _tempLockupDivFactor = 1e36;\n            _tokens[token].divFactorRequested = 1e36;\n        }\n\n        _data[msg.sender][token].divFactorRequested = _tokens[token].divFactorRequested;\n\n        if (_data[msg.sender][token].deposited < amount || amount == 0) {\n            amount = _data[msg.sender][token].deposited;\n        }\n\n        /**\n         * @dev Changes the total amount of deposited `token` by the amount of withdrawing request in the decreasing direction.\n         */\n        _tokens[token].deposited = SafeMath.sub(_tokens[token].deposited, amount);\n\n        /**\n         * @dev Changes the total amount of requested `token by the sum of the withdrawing request in the increasing direction.\n         */\n        _tokens[token].requested = SafeMath.add(_tokens[token].requested, amount);\n\n        /**\n         * @dev The requested amount of the caller's tokens for withdrawal request becomes equal to the amount requested.\n         */\n        _data[msg.sender][token].requested = amount;\n\n        /**\n         * @dev Changes the caller's amount of deposited `token` by the amount of withdrawing request in the decreasing direction.\n         */\n\n        if (amount == _data[msg.sender][token].deposited) {\n            delete _data[msg.sender][token].deposited;\n            delete _data[msg.sender][token].divFactorDeposited;\n            if (_tokens[token].deposited == 0) {\n                delete _tokens[token].divFactorDeposited;\n            }\n        } else {\n            _data[msg.sender][token].deposited = SafeMath.sub(_data[msg.sender][token].deposited, amount);\n        }\n\n        /**\n         * @dev Sets a date for `lockupTime` seconds from the current date.\n         */\n        _data[msg.sender][token].timestamp = SafeMath.add(block.timestamp, _lockupTime);\n\n        _tempLockupBalance = SafeMath.add(_tempLockupBalance, amount);\n\n        emit Request(msg.sender, token, amount, _data[msg.sender][token].timestamp);\n\n        /**\n         * @dev If `token` balance on this smart contract is greater than zero,\n         * sends tokens to the 'lockupContract' smart contract.\n         */\n\n        lockupContract.externalTransfer(token, address(this), address(lockupContract), amount, 0, _tempLockupBalance, _tempLockupDivFactor);\n        return true;\n    }\n\n    /**\n     * @dev Cancels withdrawal request for the full amount of `token` requested from this smart contract by the caller's account.\n     *\n     * Requirement:\n     *\n     * - There is a pending active withdrawal request for `token` by the caller's account.\n     */\n    function cancel(address token) external nonReentrant isAllowed(msg.sender, token) returns (bool) {\n        require(_data[msg.sender][token].requested > 0, \"AbyssSafe: nothing to cancel\");\n\n        uint256 _tempAmount = _data[msg.sender][token].requested;\n\n        uint256 _tempLockupBalance = IERC20(address(token)).balanceOf(address(lockupContract));\n        require(_tempLockupBalance > 0, \"AbyssSafe: something went wrong\");\n\n        uint256 _tempBalanceSafe = IERC20(address(token)).balanceOf(address(this));\n        uint256 _tempDepositedLockup = IAbyssLockup(address(lockupContract)).deposited(token);\n        uint256 _tempLockupDivFactor = IAbyssLockup(address(lockupContract)).divFactor(token);\n\n        /**\n         * @dev Code that supports rebase of specific `token`.\n         */\n        if (_tokens[token].deposited != _tempBalanceSafe) {\n            if (_tokens[token].deposited > 0) {\n\n                _tokens[token].divFactorDeposited = SafeMath.div(\n                                                        SafeMath.mul(\n                                                            _tokens[token].divFactorDeposited,\n                                                            _tempBalanceSafe\n                                                            ),\n                                                        _tokens[token].deposited\n                                                        );\n\n                _tokens[token].deposited = _tempBalanceSafe;\n\n            } else {\n                lockupContract.externalTransfer(token, address(this), owner(), _tempBalanceSafe, 0, _tempLockupBalance, _tempLockupDivFactor);\n            }\n        }\n\n        if (_tokens[token].divFactorDeposited == 0) {\n            _tokens[token].divFactorDeposited = 1e36;\n        }\n\n        if (_data[msg.sender][token].divFactorDeposited == 0) {\n            _data[msg.sender][token].divFactorDeposited = _tokens[token].divFactorDeposited;\n        }\n\n        if (_data[msg.sender][token].divFactorDeposited != _tokens[token].divFactorDeposited) {\n\n            _data[msg.sender][token].deposited = SafeMath.div(\n                                                    SafeMath.mul(\n                                                        _data[msg.sender][token].deposited,\n                                                        _tokens[token].divFactorDeposited\n                                                        ),\n                                                    _data[msg.sender][token].divFactorDeposited\n                                                    );\n\n            _data[msg.sender][token].divFactorDeposited = _tokens[token].divFactorDeposited;\n\n        }\n\n        if (_tempDepositedLockup != _tempLockupBalance) {\n\n            _tempLockupDivFactor = SafeMath.div(\n                                        SafeMath.mul(\n                                            _tempLockupDivFactor,\n                                            _tempLockupBalance\n                                            ),\n                                        _tempDepositedLockup\n                                        );\n        }\n\n        if (_tokens[token].divFactorRequested != _tempLockupDivFactor) {\n\n            _tokens[token].requested =  SafeMath.div(\n                                                  SafeMath.mul(\n                                                      _tokens[token].requested,\n                                                      _tempLockupDivFactor\n                                                      ),\n                                                  _tokens[token].divFactorRequested\n                                                  );\n\n            if (_tempLockupBalance > _tokens[token].requested) {\n                if (SafeMath.sub(_tempLockupBalance, _tokens[token].requested) == 1) {\n                    _tokens[token].requested = _tempLockupBalance;\n                }\n            }\n\n            _tokens[token].divFactorRequested = SafeMath.div(\n                                                    SafeMath.mul(\n                                                        _tokens[token].divFactorRequested,\n                                                        _tempLockupBalance\n                                                        ),\n                                                    _tempDepositedLockup\n                                                    );\n\n        }\n\n        if (_data[msg.sender][token].divFactorRequested != _tokens[token].divFactorRequested) {\n\n            _tempAmount = SafeMath.div(\n                                SafeMath.mul(\n                                      _tempAmount,\n                                      _tempLockupDivFactor\n                                      ),\n                                _data[msg.sender][token].divFactorRequested\n                                );\n\n            if (_tempLockupBalance > _tempAmount) {\n               if (SafeMath.sub(_tempLockupBalance, _tempAmount) == 1) {\n                  _tempAmount = _tempLockupBalance;\n               }\n            }\n\n            _data[msg.sender][token].divFactorRequested = _tokens[token].divFactorRequested;\n        }\n\n        delete _data[msg.sender][token].divFactorRequested;\n\n        /**\n         * @dev Changes the total amount of deposited `token` by the amount of withdrawing request in the increasing direction.\n         */\n        _tokens[token].deposited = SafeMath.add(_tokens[token].deposited, _tempAmount);\n\n        /**\n         * @dev Changes the total amount of requested `token` by the cancelation withdrawal amount in the decreasing direction.\n         */\n        _tokens[token].requested = SafeMath.sub(_tokens[token].requested, _tempAmount);\n\n        /**\n         * @dev Removes `token` divFactor if balance of the requested `token` is 0 after withdraw cancelation.\n         */\n        if (_tokens[token].requested == 0) {\n            delete _tokens[token].divFactorRequested;\n        }\n\n        /**\n         * @dev Taking withdrawal request cancellation into account, restores the caller's `token` balance.\n         */\n        _data[msg.sender][token].deposited = SafeMath.add(_data[msg.sender][token].deposited, _tempAmount);\n\n        /**\n         * @dev Resets information on the number of `token` requested by the caller for withdrawal request.\n         */\n        delete _data[msg.sender][token].requested;\n\n        /**\n         * @dev Calculates the new balance of `token` on `lockup` smart contract.\n         */\n        _tempLockupBalance = SafeMath.sub(_tempLockupBalance, _tempAmount);\n\n        /**\n         * @dev Removes divFactor on `lockup` smart contract if balane of the `token` is 0 after withdraw.\n         */\n        if (_tempLockupBalance == 0) {\n            _tempLockupDivFactor = 1;\n        }\n\n        emit Cancel(msg.sender, token, _tempAmount, _data[msg.sender][token].timestamp);\n\n        /**\n         * @dev Reset the unblocking time to zero.\n         */\n        delete _data[msg.sender][token].timestamp;\n\n        lockupContract.externalTransfer(token, address(lockupContract), address(this), _tempAmount, 0, _tempLockupBalance, _tempLockupDivFactor);\n        return true;\n    }\n\n    /**\n     * @dev Withdraws the full amount of `token` requested from this smart contract by the caller's account.\n     *\n     * Requirement:\n     *\n     * - Required Abyss amount is available on the account.\n     * - There is pending active withdrawal request for `token` by the caller's account.\n     * - Required amount of time has already passed since withrawal request execution.\n     * - User’s balance is greater than zero and greater than the amount they intend to deposit.\n     */\n    function withdraw(address token) external nonReentrant isAllowed(msg.sender, token) returns (bool) {\n        require(\n            _rates[msg.sender] == 0 ||\n            token == address(tokenContract) ||\n            tokenContract.balanceOf(msg.sender) >= _rates[msg.sender],\n            \"AbyssSafe: not enough Abyss\");\n        require(_data[msg.sender][token].requested > 0, \"AbyssSafe: request withdraw first\");\n        require(_data[msg.sender][token].timestamp < block.timestamp, \"AbyssSafe: patience you must have!\");\n\n        uint256 _tempAmount = _data[msg.sender][token].requested;\n\n        uint256 _tempLockupBalance = IERC20(address(token)).balanceOf(address(lockupContract));\n        require(_tempLockupBalance > 0, \"AbyssSafe: something went wrong\");\n\n        uint256 _tempDepositedLockup = IAbyssLockup(address(lockupContract)).deposited(token);\n        uint256 _tempLockupDivFactor = IAbyssLockup(address(lockupContract)).divFactor(token);\n\n        /**\n         * @dev Code that supports rebase of specific `token`.\n         */\n        if (_tempDepositedLockup != _tempLockupBalance) {\n\n            _tempLockupDivFactor = SafeMath.div(\n                                        SafeMath.mul(\n                                            _tempLockupDivFactor,\n                                            _tempLockupBalance\n                                            ),\n                                        _tempDepositedLockup\n                                        );\n        }\n\n        if (_tokens[token].divFactorRequested != _tempLockupDivFactor) {\n\n            _tokens[token].requested = SafeMath.div(\n                                                  SafeMath.mul(\n                                                      _tokens[token].requested,\n                                                      _tempLockupDivFactor\n                                                      ),\n                                                  _tokens[token].divFactorRequested\n                                                  );\n\n            if (_tempLockupBalance > _tokens[token].requested) {\n                if (SafeMath.sub(_tempLockupBalance, _tokens[token].requested) == 1) {\n                    _tokens[token].requested = _tempLockupBalance;\n                }\n            }\n\n            _tokens[token].divFactorRequested = SafeMath.div(\n                                                    SafeMath.mul(\n                                                        _tokens[token].divFactorRequested,\n                                                        _tempLockupBalance\n                                                        ),\n                                                    _tempDepositedLockup\n                                                    );\n\n        }\n\n        if (_data[msg.sender][token].divFactorRequested != _tokens[token].divFactorRequested) {\n\n            _tempAmount = SafeMath.div(\n                                SafeMath.mul(\n                                      _tempAmount,\n                                      _tempLockupDivFactor\n                                      ),\n                                _data[msg.sender][token].divFactorRequested\n                                );\n\n            if (_tokens[token].requested > _tempAmount) {\n                if (SafeMath.sub(_tokens[token].requested, _tempAmount) == 1) {\n                    _tempAmount = _tokens[token].requested;\n                }\n            }\n\n        }\n\n        delete _data[msg.sender][token].divFactorRequested;\n\n        /**\n         * @dev Changes the total amount of requested `token` by the cancelation withdrawal amount in the decreasing direction.\n         */\n\n        _tokens[token].requested = SafeMath.sub(_tokens[token].requested, _tempAmount);\n\n\n        /**\n         * @dev Removes `token` divFactor if balance of the requested `token` is 0 after withdraw.\n         */\n        if (_tokens[token].requested == 0) {\n            delete _tokens[token].divFactorRequested;\n        }\n\n        /**\n         * @dev Removes information about amount of requested `token`.\n         */\n        delete _data[msg.sender][token].requested;\n\n        emit Withdraw(msg.sender, token, _tempAmount, _data[msg.sender][token].timestamp);\n\n        /**\n         * @dev Reset the unblocking time to zero.\n         */\n        delete _data[msg.sender][token].timestamp;\n\n        /**\n         * @dev Calculates the new balance of `token` on `lockup` smart contract.\n         */\n\n        _tempLockupBalance = SafeMath.sub(_tempLockupBalance, _tempAmount);\n\n        /**\n         * @dev Removes divFactor on `lockup` smart contract if balane of the `token` is 0 after withdraw.\n         */\n        if (_tempLockupBalance == 0) {\n            _tempLockupDivFactor = 1;\n        }\n\n        /**\n         * @dev Withdraws tokens to the caller's address.\n         */\n\n        lockupContract.externalTransfer(token, address(lockupContract), msg.sender, _tempAmount, 0, _tempLockupBalance, _tempLockupDivFactor);\n        return true;\n\n    }\n\n    // ADMIN FUNCTIONS\n\n    /**\n     * @dev Initializes configuration of a given smart contract, with a specified\n     * address for the `lockupContract` smart contract.\n     *\n     * This value is immutable: it can only be set once.\n     */\n    function initialize(address lockupContract_) external onlyOwner returns (bool) {\n        require(address(lockupContract) == address(0), \"AbyssSafe: already initialized\");\n        lockupContract = IAbyssLockup(lockupContract_);\n        return true;\n    }\n\n    /**\n     * @dev Configurates smart contract allowing modification in the amount of\n     * required Abyss to use the smart contract.\n     *\n     * NOTE: The price for pre-existing users will remain unchanged until\n     * a new token deposit is made. This aspect has been considered to prevent\n     * possibility of increase pricing for already made deposits.\n     *\n     * Also, this function allows disabling of deposit"
    }
  ]
}