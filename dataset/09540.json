{
  "Title": "[L-03] Missing checks for `address(0x0)` when assigning values to `address` state variables",
  "Content": "\n1.  File: src/AxelarGateway.sol (line [67](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/AxelarGateway.sol#L67))\n\n```solidity\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-axelar",
  "Code": [
    {
      "filename": "src/AxelarGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';\n\nimport { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\nimport { TokenDeployer } from './TokenDeployer.sol';\n\nabstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    error NotSelf();\n    error InvalidCodeHash();\n    error SetupFailed();\n    error InvalidAmount();\n    error TokenDoesNotExist(string symbol);\n    error TokenAlreadyExists(string symbol);\n    error TokenDeployFailed(string symbol);\n    error TokenContractDoesNotExist(address token);\n    error BurnFailed(string symbol);\n    error MintFailed(string symbol);\n    error TokenIsFrozen(string symbol);\n\n    enum Role {\n        Admin,\n        Owner,\n        Operator\n    }\n\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION =\n        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    // AUDIT: constants should be literal and their derivation should be in comments\n    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');\n\n    uint8 internal constant OLD_KEY_RETENTION = 16;\n\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address tokenDeployerImplementation) {\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string memory destinationChain,\n        string memory destinationAddress,\n        string memory symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string memory destinationChain,\n        string memory destinationContractAddress,\n        bytes memory payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string memory destinationChain,\n        string memory destinationContractAddress,\n        bytes memory payload,\n        string memory symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(\n            msg.sender,\n            destinationChain,\n            destinationContractAddress,\n            keccak256(payload),\n            payload,\n            symbol,\n            amount\n        );\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return\n            getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            msg.sender,\n            payloadHash,\n            symbol,\n            amount\n        );\n        valid = getBool(key);\n        if (valid) {\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function allTokensFrozen() public view override returns (bool) {\n        return getBool(KEY_ALL_TOKENS_FROZEN);\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory symbol) public view override returns (bool) {\n        return getBool(_getFreezeTokenKey(symbol));\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; i++) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function freezeToken(string memory symbol) external override onlyAdmin {\n        _setBool(_getFreezeTokenKey(symbol), true);\n\n        emit TokenFrozen(symbol);\n    }\n\n    function unfreezeToken(string memory symbol) external override onlyAdmin {\n        _setBool(_getFreezeTokenKey(symbol), false);\n\n        emit TokenUnfrozen(symbol);\n    }\n\n    function freezeAllTokens() external override onlyAdmin {\n        _setBool(KEY_ALL_TOKENS_FROZEN, true);\n\n        emit AllTokensFrozen();\n    }\n\n    function unfreezeAllTokens() external override onlyAdmin {\n        _setBool(KEY_ALL_TOKENS_FROZEN, false);\n\n        emit AllTokensUnfrozen();\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length > 0) {\n            (bool success, ) = newImplementation.delegatecall(\n                abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)\n            );\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* Internal Functions *|\n    \\**********************/\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            _checkTokenStatus(symbol);\n\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20BurnFrom.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                BurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        BurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    function _deployToken(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 cap,\n        address tokenAddress\n    ) internal {\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(TokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified addressed.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            _checkTokenStatus(symbol);\n\n            bool success = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, account, amount)\n            );\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            BurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnToken(string memory symbol, bytes32 salt) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            _checkTokenStatus(symbol);\n\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(\n                    IERC20.transfer.selector,\n                    address(this),\n                    IERC20(tokenAddress).balanceOf(address(depositHandler))\n                )\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool))))\n                revert BurnFailed(symbol);\n\n            depositHandler.destroy(address(this));\n        } else {\n            BurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function _approveContractCall(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    ) internal {\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function _approveContractCallWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    ) internal {\n        _setContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount\n        );\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash\n                )\n            );\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    function _checkTokenStatus(string memory symbol) internal view {\n        if (getBool(_getFreezeTokenKey(symbol)) || getBool(KEY_ALL_TOKENS_FROZEN)) revert TokenIsFrozen(symbol);\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash),\n            true\n        );\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(\n                commandId,\n                sourceChain,\n                sourceAddress,\n                contractAddress,\n                payloadHash,\n                symbol,\n                amount\n            ),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}"
    }
  ]
}