{
  "Title": "[H02] Delegators can prevent service providers from deregistering endpoints",
  "Content": "Under some conditions, delegators may prevent service providers from deregistering endpoints. This can happen innocently or maliciously.\n\n\nConsider the case where a service provider has registered more than one endpoint and that the service provider has staked the minimum amount of stake. Suppose delegators have delegated to this service provider the maximum amount of stake.\n\n\nWhen the service provider attempts to deregister one of the endpoints, their call to the [`deregister` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L224) may fail [on line 300](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L300). This is because the [`_validateBalanceInternal` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L773) [requires that `_amount <= spDetails[_sp].maxAccountStake`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L780), which may not be true if enough stake has been delegated to the service provider.\n\n\nConsider adjusting the logic of the `deregister` function to handle the case where `Staking(stakingAddress).totalStakedFor(_sp) > maxAccountStake`.\n\n\n***Update:** Partially fixed in [pull request #570](https://github.com/AudiusProject/audius-protocol/pull/570). The fix may introduce new attack vectors to the codebase. For example, in the [`removeDelegator` function](https://github.com/AudiusProject/audius-protocol/blob/7328cbe3db1ae90c1cf4415768d9b33cb0294bb8/eth-contracts/contracts/DelegateManager.sol#L472) the stake of the delegator is unstaked instantly. This could allow a service provider to bypass a slashing process by using sybil delegators and then removing its delegated stake before the slash takes place. This will reduce the slashing punishment significantly. Consider modifying the `removeDelegator` function to set a timelock so the slashing mechanism cannot be bypassed in that way. Furthermore, allowing a service provider to call this function at anytime could introduce further incentive problems. To mitigate this, consider adding a requirement on the `removeDelegator` function so it can only be called if the sum of stakes for a service provider is bigger than `spDetails[_sp].maxAccountStake`.*\n\n\n***Update:** Fixed in [pull request #657](https://github.com/AudiusProject/audius-protocol/pull/657). The `removeDelegator` function now implements a timelock.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "eth-contracts/contracts/ServiceProviderFactory.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"./ServiceTypeManager.sol\";\nimport \"./ClaimsManager.sol\";\nimport \"./Staking.sol\";\n\n\ncontract ServiceProviderFactory is InitializableV2 {\n    using SafeMath for uint;\n\n    address private stakingAddress;\n    address private delegateManagerAddress;\n    address private governanceAddress;\n    address private serviceTypeManagerAddress;\n    address private claimsManagerAddress;\n    uint private decreaseStakeLockupDuration;\n\n    /// @dev - Stores following entities\n    ///        1) Directly staked amount by SP, not including delegators\n    ///        2) % Cut of delegator tokens taken during reward\n    ///        3) Bool indicating whether this SP has met min/max requirements\n    ///        4) Number of endpoints registered by SP\n    ///        5) Minimum total stake for this account\n    ///        6) Maximum total stake for this account\n    struct ServiceProviderDetails {\n        uint deployerStake;\n        uint deployerCut;\n        bool validBounds;\n        uint numberOfEndpoints;\n        uint minAccountStake;\n        uint maxAccountStake;\n    }\n\n    /// @dev - Data structure for time delay during withdrawal\n    struct DecreaseStakeRequest {\n        uint decreaseAmount;\n        uint lockupExpiryBlock;\n    }\n\n    /// @dev - Mapping of service provider address to details\n    mapping(address => ServiceProviderDetails) spDetails;\n\n    /// @dev - Minimum staked by service provider account deployer\n    /// @dev - Static regardless of total number of endpoints for a given account\n    uint minDeployerStake;\n\n    /// @dev - standard - imitates relationship between Ether and Wei\n    uint8 private constant DECIMALS = 18;\n\n    /// @dev - denominator for deployer cut calculations\n    /// @dev - user values are intended to be x/DEPLOYER_CUT_BASE\n    uint private constant DEPLOYER_CUT_BASE = 100;\n\n    /// @dev - Struct maintaining information about sp\n    /// @dev - blocknumber is block.number when endpoint registered\n    struct ServiceEndpoint {\n        address owner;\n        string endpoint;\n        uint blocknumber;\n        address delegateOwnerWallet;\n    }\n\n    /// @dev - Uniquely assigned serviceProvider ID, incremented for each service type\n    /// @notice - Keeps track of the total number of services registered regardless of\n    ///           whether some have been deregistered since\n    mapping(bytes32 => uint) serviceProviderTypeIDs;\n\n    /// @dev - mapping of (serviceType -> (serviceInstanceId <-> serviceProviderInfo))\n    /// @notice - stores the actual service provider data like endpoint and owner wallet\n    ///           with the ability lookup by service type and service id */\n    mapping(bytes32 => mapping(uint => ServiceEndpoint)) serviceProviderInfo;\n\n    /// @dev - mapping of keccak256(endpoint) to uint ID\n    /// @notice - used to check if a endpoint has already been registered and also lookup\n    /// the id of an endpoint\n    mapping(bytes32 => uint) serviceProviderEndpointToId;\n\n    /// @dev - mapping of address -> sp id array */\n    /// @notice - stores all the services registered by a provider. for each address,\n    /// provides the ability to lookup by service type and see all registered services\n    mapping(address => mapping(bytes32 => uint[])) serviceProviderAddressToId;\n\n    /// @dev - Mapping of service provider -> decrease stake request\n    mapping(address => DecreaseStakeRequest) decreaseStakeRequests;\n\n    event RegisteredServiceProvider(\n      uint _spID,\n      bytes32 _serviceType,\n      address _owner,\n      string _endpoint,\n      uint256 _stakeAmount\n    );\n\n    event DeregisteredServiceProvider(\n      uint _spID,\n      bytes32 _serviceType,\n      address _owner,\n      string _endpoint,\n      uint256 _unstakeAmount\n    );\n\n    event UpdatedStakeAmount(\n      address _owner,\n      uint256 _stakeAmount\n    );\n\n    event UpdateEndpoint(\n      bytes32 _serviceType,\n      address _owner,\n      string _oldEndpoint,\n      string _newEndpoint,\n      uint spId\n    );\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _governanceAddress - Governance proxy address\n     */\n    function initialize (address _governanceAddress) public initializer\n    {\n        governanceAddress = _governanceAddress;\n\n        // Configure direct minimum stake for deployer\n        minDeployerStake = 5 * 10**uint256(DECIMALS);\n\n        // 10 blocks for lockup duration\n        decreaseStakeLockupDuration = 10;\n\n        InitializableV2.initialize();\n    }\n\n    /**\n     * @notice Register a new endpoint to the account of msg.sender\n     * @dev Transfers stake from service provider into staking pool\n     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\n     * @param _endpoint - url of the service to register - url of the service to register\n     * @param _stakeAmount - amount to stake, must be within bounds in ServiceTypeManager\n     * @param _delegateOwnerWallet - wallet to delegate some permissions for some basic management properties\n     */\n    function register(\n        bytes32 _serviceType,\n        string calldata _endpoint,\n        uint256 _stakeAmount,\n        address _delegateOwnerWallet\n    ) external returns (uint spID)\n    {\n        _requireIsInitialized();\n        require(serviceTypeManagerAddress != address(0x00), \"serviceTypeManagerAddress not set\");\n        require(stakingAddress != address(0x00), \"stakingAddress not set\");\n\n        require(\n            ServiceTypeManager(serviceTypeManagerAddress).serviceTypeIsValid(_serviceType),\n            \"Valid service type required\");\n\n        // Stake token amount from msg.sender\n        if (_stakeAmount > 0) {\n            require(!_claimPending(msg.sender), \"No claim expected to be pending prior to stake transfer\");\n            Staking(stakingAddress).stakeFor(msg.sender, _stakeAmount);\n        }\n\n        require (\n            serviceProviderEndpointToId[keccak256(bytes(_endpoint))] == 0,\n            \"Endpoint already registered\");\n\n        uint newServiceProviderID = serviceProviderTypeIDs[_serviceType].add(1);\n        serviceProviderTypeIDs[_serviceType] = newServiceProviderID;\n\n        // Index spInfo\n        serviceProviderInfo[_serviceType][newServiceProviderID] = ServiceEndpoint({\n            owner: msg.sender,\n            endpoint: _endpoint,\n            blocknumber: block.number,\n            delegateOwnerWallet: _delegateOwnerWallet\n        });\n\n        // Update endpoint mapping\n        serviceProviderEndpointToId[keccak256(bytes(_endpoint))] = newServiceProviderID;\n\n        // Update (address -> type -> ids[])\n        serviceProviderAddressToId[msg.sender][_serviceType].push(newServiceProviderID);\n\n        // Increment number of endpoints for this address\n        spDetails[msg.sender].numberOfEndpoints = spDetails[msg.sender].numberOfEndpoints.add(1);\n\n        // Update deployer total\n        spDetails[msg.sender].deployerStake = (\n            spDetails[msg.sender].deployerStake.add(_stakeAmount)\n        );\n\n        // Update min and max totals for this service provider\n        (uint typeMin, uint typeMax) = ServiceTypeManager(\n            serviceTypeManagerAddress\n        ).getServiceTypeStakeInfo(_serviceType);\n        spDetails[msg.sender].minAccountStake = spDetails[msg.sender].minAccountStake.add(typeMin);\n        spDetails[msg.sender].maxAccountStake = spDetails[msg.sender].maxAccountStake.add(typeMax);\n\n        // Confirm both aggregate account balance and directly staked amount are valid\n        this.validateAccountStakeBalance(msg.sender);\n        uint currentlyStakedForOwner = Staking(stakingAddress).totalStakedFor(msg.sender);\n\n\n        // Indicate this service provider is within bounds\n        spDetails[msg.sender].validBounds = true;\n\n        emit RegisteredServiceProvider(\n            newServiceProviderID,\n            _serviceType,\n            msg.sender,\n            _endpoint,\n            currentlyStakedForOwner\n        );\n\n        return newServiceProviderID;\n    }\n\n    /**\n     * @notice Deregister an endpoint from the account of msg.sender\n     * @dev Unstakes all tokens for service provider if this is the last endpoint\n     * @param _serviceType - type of service to deregister\n     * @param _endpoint - endpoint to deregister\n     * @return spId of the service that was deregistered\n     */\n    function deregister(\n        bytes32 _serviceType,\n        string calldata _endpoint\n    ) external returns (uint deregisteredSpID)\n    {\n        _requireIsInitialized();\n\n        // Unstake on deregistration if and only if this is the last service endpoint\n        uint unstakeAmount = 0;\n        bool unstaked = false;\n        // owned by the service provider\n        if (spDetails[msg.sender].numberOfEndpoints == 1) {\n            unstakeAmount = spDetails[msg.sender].deployerStake;\n\n            // Submit request to decrease stake, overriding any pending request\n            decreaseStakeRequests[msg.sender] = DecreaseStakeRequest({\n                decreaseAmount: unstakeAmount,\n                lockupExpiryBlock: block.number.add(decreaseStakeLockupDuration)\n            });\n\n            unstaked = true;\n        }\n\n        require (\n            serviceProviderEndpointToId[keccak256(bytes(_endpoint))] != 0,\n            \"Endpoint not registered\");\n\n        // Cache invalided service provider ID\n        uint deregisteredID = serviceProviderEndpointToId[keccak256(bytes(_endpoint))];\n\n        // Update endpoint mapping\n        serviceProviderEndpointToId[keccak256(bytes(_endpoint))] = 0;\n\n        require(\n            keccak256(bytes(serviceProviderInfo[_serviceType][deregisteredID].endpoint)) == keccak256(bytes(_endpoint)),\n            \"Invalid endpoint for service type\");\n\n        require (\n            serviceProviderInfo[_serviceType][deregisteredID].owner == msg.sender,\n            \"Only callable by endpoint owner\");\n\n        // Update info mapping\n        delete serviceProviderInfo[_serviceType][deregisteredID];\n        // Reset id, update array\n        uint spTypeLength = serviceProviderAddressToId[msg.sender][_serviceType].length;\n        for (uint i = 0; i < spTypeLength; i ++) {\n            if (serviceProviderAddressToId[msg.sender][_serviceType][i] == deregisteredID) {\n                // Overwrite element to be deleted with last element in array\n                serviceProviderAddressToId[msg.sender][_serviceType][i] = serviceProviderAddressToId[msg.sender][_serviceType][spTypeLength - 1];\n                // Reduce array size, exit loop\n                serviceProviderAddressToId[msg.sender][_serviceType].length--;\n                // Confirm this ID has been found for the service provider\n                break;\n            }\n        }\n\n        // Decrement number of endpoints for this address\n        spDetails[msg.sender].numberOfEndpoints -= 1;\n\n        // Update min and max totals for this service provider\n        (uint typeMin, uint typeMax) = ServiceTypeManager(\n            serviceTypeManagerAddress\n        ).getServiceTypeStakeInfo(_serviceType);\n        spDetails[msg.sender].minAccountStake = spDetails[msg.sender].minAccountStake.sub(typeMin);\n        spDetails[msg.sender].maxAccountStake = spDetails[msg.sender].maxAccountStake.sub(typeMax);\n\n        emit DeregisteredServiceProvider(\n            deregisteredID,\n            _serviceType,\n            msg.sender,\n            _endpoint,\n            unstakeAmount);\n\n        // Confirm both aggregate account balance and directly staked amount are valid\n        // Only if unstake operation has not occurred\n        if (!unstaked) {\n            this.validateAccountStakeBalance(msg.sender);\n            // Indicate this service provider is within bounds\n            spDetails[msg.sender].validBounds = true;\n        }\n\n        return deregisteredID;\n    }\n\n    /**\n     * @notice Increase stake for service provider\n     * @param _increaseStakeAmount - amount to increase staked amount by\n     * @return New total stake for service provider\n     */\n    function increaseStake(\n        uint256 _increaseStakeAmount\n    ) external returns (uint newTotalStake)\n    {\n        _requireIsInitialized();\n\n        // Confirm owner has an endpoint\n        require(\n            spDetails[msg.sender].numberOfEndpoints > 0,\n            \"Registered endpoint required to increase stake\"\n        );\n        require(\n            !_claimPending(msg.sender),\n            \"No claim expected to be pending prior to stake transfer\"\n        );\n\n        Staking stakingContract = Staking(\n            stakingAddress\n        );\n\n        // Stake increased token amount for msg.sender\n        stakingContract.stakeFor(msg.sender, _increaseStakeAmount);\n\n        uint newStakeAmount = stakingContract.totalStakedFor(msg.sender);\n\n        // Update deployer total\n        spDetails[msg.sender].deployerStake = (\n            spDetails[msg.sender].deployerStake.add(_increaseStakeAmount)\n        );\n\n        // Confirm both aggregate account balance and directly staked amount are valid\n        this.validateAccountStakeBalance(msg.sender);\n\n        // Indicate this service provider is within bounds\n        spDetails[msg.sender].validBounds = true;\n\n        emit UpdatedStakeAmount(\n            msg.sender,\n            newStakeAmount\n        );\n\n        return newStakeAmount;\n    }\n\n    /**\n     * @notice Request to decrease stake. This sets a lockup for decreaseStakeLockupDuration after\n               which the actual decreaseStake can be called\n     * @dev Decreasing stake is only processed in a service provider is within valid bounds\n     * @param _decreaseStakeAmount - amount to decrease stake by in wei\n     * @return New total stake amount after the lockup\n     */\n    function requestDecreaseStake(uint _decreaseStakeAmount)\n    external returns (uint newStakeAmount)\n    {\n        _requireIsInitialized();\n        require(\n            !_claimPending(msg.sender),\n            \"No claim expected to be pending prior to stake transfer\"\n        );\n\n        Staking stakingContract = Staking(\n            stakingAddress\n        );\n\n        uint currentStakeAmount = stakingContract.totalStakedFor(msg.sender);\n\n        // Prohibit decreasing stake to invalid bounds\n        _validateBalanceInternal(msg.sender, (currentStakeAmount.sub(_decreaseStakeAmount)));\n\n        decreaseStakeRequests[msg.sender] = DecreaseStakeRequest({\n            decreaseAmount: _decreaseStakeAmount,\n            lockupExpiryBlock: block.number.add(decreaseStakeLockupDuration)\n        });\n\n        return currentStakeAmount.sub(_decreaseStakeAmount);\n    }\n\n    /**\n     * @notice Cancel a decrease stake request during the lockup\n     * @dev Either called by the service provider via DelegateManager or governance\n            during a slash action\n     * @param _account - address of service provider\n     */\n    function cancelDecreaseStakeRequest(address _account) external\n    {\n        require(\n            msg.sender == _account || msg.sender == delegateManagerAddress,\n            \"Only callable from owner or DelegateManager\"\n        );\n        require(_decreaseRequestIsPending(_account), \"Decrease stake request must be pending\");\n\n        // Clear decrease stake request\n        decreaseStakeRequests[_account] = DecreaseStakeRequest({\n            decreaseAmount: 0,\n            lockupExpiryBlock: 0\n        });\n    }\n\n    /**\n     * @notice Actually decrease a stake. Must have called requestDecreaseStake and waited for the\n               lockup period to expire\n     * @return New total stake after decrease\n     */\n    function decreaseStake() external returns (uint newTotalStake)\n    {\n        _requireIsInitialized();\n\n        require(_decreaseRequestIsPending(msg.sender), \"Decrease stake request must be pending\");\n        require(\n            decreaseStakeRequests[msg.sender].lockupExpiryBlock <= block.number,\n            \"Lockup must be expired\"\n        );\n\n        Staking stakingContract = Staking(\n            stakingAddress\n        );\n\n        // Decrease staked token amount for msg.sender\n        stakingContract.unstakeFor(msg.sender, decreaseStakeRequests[msg.sender].decreaseAmount);\n\n        // Query current stake\n        uint newStakeAmount = stakingContract.totalStakedFor(msg.sender);\n\n        // Update deployer total\n        spDetails[msg.sender].deployerStake = (\n            spDetails[msg.sender].deployerStake.sub(decreaseStakeRequests[msg.sender].decreaseAmount)\n        );\n\n        // Confirm both aggregate account balance and directly staked amount are valid\n        // During registration this validation is bypassed since no endpoints remain\n        if (spDetails[msg.sender].numberOfEndpoints > 0) {\n            this.validateAccountStakeBalance(msg.sender);\n        }\n\n        // Indicate this service provider is within bounds\n        spDetails[msg.sender].validBounds = true;\n\n        // Clear decrease stake request\n        delete decreaseStakeRequests[msg.sender];\n\n        emit UpdatedStakeAmount(\n            msg.sender,\n            newStakeAmount\n        );\n\n        return newStakeAmount;\n    }\n\n    /**\n     * @notice Update delegate owner wallet for a given endpoint\n     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\n     * @param _endpoint - url of the service to register - url of the service to register\n     * @param _updatedDelegateOwnerWallet - address of new delegate wallet\n     */\n    function updateDelegateOwnerWallet(\n        bytes32 _serviceType,\n        string calldata _endpoint,\n        address _updatedDelegateOwnerWallet\n    ) external\n    {\n        uint spID = this.getServiceProviderIdFromEndpoint(_endpoint);\n\n        require(\n            serviceProviderInfo[_serviceType][spID].owner == msg.sender,\n            \"Invalid update operation, wrong owner\");\n\n        serviceProviderInfo[_serviceType][spID].delegateOwnerWallet = _updatedDelegateOwnerWallet;\n    }\n\n    /**\n     * @notice Update the endpoint for a given service\n     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\n     * @param _oldEndpoint - old endpoint currently registered\n     * @param _oldEndpoint - new endpoint to replace old endpoint\n     */\n    function updateEndpoint(\n        bytes32 _serviceType,\n        string calldata _oldEndpoint,\n        string calldata _newEndpoint\n    ) external returns (uint spID)\n    {\n        uint spId = this.getServiceProviderIdFromEndpoint(_oldEndpoint);\n\n        require (spId != 0, \"Could not find service provider with that endpoint\");\n\n        ServiceEndpoint memory sp = serviceProviderInfo[_serviceType][spId];\n\n        require(sp.owner == msg.sender,\"Invalid update endpoint operation, wrong owner\");\n\n        require(\n            keccak256(bytes(sp.endpoint)) == keccak256(bytes(_oldEndpoint)),\n            \"Old endpoint doesn't match what's registered for the service provider\"\n        );\n\n        // invalidate old endpoint\n        serviceProviderEndpointToId[keccak256(bytes(sp.endpoint))] = 0;\n\n        // update to new endpoint\n        sp.endpoint = _newEndpoint;\n        serviceProviderInfo[_serviceType][spId] = sp;\n        serviceProviderEndpointToId[keccak256(bytes(_newEndpoint))] = spId;\n        return spId;\n    }\n\n    /**\n     * @notice Update service provider balance\n     * @dev Called by DelegateManager by functions modifying entire stake like claim and slash\n     * @param _serviceProvider - address of service provider\n     * @param _amount - new amount of direct state for service provider\n     */\n    function updateServiceProviderStake(\n        address _serviceProvider,\n        uint _amount\n     ) external\n    {\n        require(delegateManagerAddress != address(0x00), \"delegateManagerAddress not set\");\n        require(\n            msg.sender == delegateManagerAddress,\n            \"updateServiceProviderStake - only callable by DelegateManager\"\n        );\n        // Update SP tracked total\n        spDetails[_serviceProvider].deployerStake = _amount;\n        _updateServiceProviderBoundStatus(_serviceProvider);\n    }\n\n    /**\n     * @notice Update service provider cut of claims\n     * @notice Update service provider cut as % of delegate claim, divided by the deployerCutBase.\n     * @dev SPs will interact with this value as a percent, value translation done client side\n       @dev A value of 5 dictates a 5% cut, with ( 5 / 100 ) * delegateReward going to an SP from each delegator each round.\n     * @param _serviceProvider - address of service provider\n     * @param _cut - new deployer cut value\n     */\n    function updateServiceProviderCut(\n        address _serviceProvider,\n        uint _cut\n    ) external\n    {\n        require(\n            msg.sender == _serviceProvider,\n            \"Service Provider cut update operation restricted to deployer\");\n\n        require(\n            _cut <= DEPLOYER_CUT_BASE,\n            \"Service Provider cut cannot exceed base value\");\n        spDetails[_serviceProvider].deployerCut = _cut;\n    }\n\n    /// @notice Update service provider lockup duration\n    function updateDecreaseStakeLockupDuration(uint _duration) external {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n\n        decreaseStakeLockupDuration = _duration;\n    }\n\n    /// @notice Get denominator for deployer cut calculations\n    function getServiceProviderDeployerCutBase()\n    external pure returns (uint base)\n    {\n        return DEPLOYER_CUT_BASE;\n    }\n\n    /// @notice Get total number of service providers for a given serviceType\n    function getTotalServiceTypeProviders(bytes32 _serviceType)\n    external view returns (uint numberOfProviders)\n    {\n        return serviceProviderTypeIDs[_serviceType];\n    }\n\n    /// @notice Get service provider id for an endpoint\n    function getServiceProviderIdFromEndpoint(string calldata _endpoint)\n    external view returns (uint spID)\n    {\n        return serviceProviderEndpointToId[keccak256(bytes(_endpoint))];\n    }\n\n    /// @notice Get minDeployerStake\n    function getMinDeployerStake()\n    external view returns (uint min)\n    {\n        return minDeployerStake;\n    }\n\n    /**\n     * @notice Get service provider ids for a given service provider and service type\n     * @return List of service ids of that type for a service provider\n     */\n    function getServiceProviderIdsFromAddress(address _ownerAddress, bytes32 _serviceType)\n    external view returns (uint[] memory spIds)\n    {\n        return serviceProviderAddressToId[_ownerAddress][_serviceType];\n    }\n\n    /**\n     * @notice Get information about a service endpoint given its service id\n     * @param _serviceType - type of service, must be a valid service from ServiceTypeManager\n     * @param _serviceId - id of service\n     */\n    function getServiceEndpointInfo(bytes32 _serviceType, uint _serviceId)\n    external view returns (address owner, string memory endpoint, uint blockNumber, address delegateOwnerWallet)\n    {\n        ServiceEndpoint memory sp = serviceProviderInfo[_serviceType][_serviceId];\n        return (sp.owner, sp.endpoint, sp.blocknumber, sp.delegateOwnerWallet);\n    }\n\n    /**\n     * @notice Get information about a service provider given their address\n     * @param _sp - address of service provider\n     */\n    function getServiceProviderDetails(address _sp)\n    external view returns (\n        uint deployerStake,\n        uint deployerCut,\n        bool validBounds,\n        uint numberOfEndpoints,\n        uint minAccountStake,\n        uint maxAccountStake)\n    {\n        return (\n            spDetails[_sp].deployerStake,\n            spDetails[_sp].deployerCut,\n            spDetails[_sp].validBounds,\n            spDetails[_sp].numberOfEndpoints,\n            spDetails[_sp].minAccountStake,\n            spDetails[_sp].maxAccountStake\n        );\n    }\n\n    /**\n     * @notice Get information about pending decrease stake requests for service provider\n     * @param _sp - address of service provider\n     */\n    function getPendingDecreaseStakeRequest(address _sp)\n    external view returns (uint amount, uint lockupExpiryBlock)\n    {\n        return (\n            decreaseStakeRequests[_sp].decreaseAmount,\n            decreaseStakeRequests[_sp].lockupExpiryBlock\n        );\n    }\n\n    /// @notice Get current unstake lockup duration\n    function getDecreaseStakeLockupDuration()\n    external view returns (uint duration)\n    {\n        return decreaseStakeLockupDuration;\n    }\n\n    /**\n     * @notice Validate that the total service provider balance is between the min and max stakes\n               for all their registered services and validate  direct stake for sp is above minimum\n     * @param _sp - address of service provider\n     */\n    function validateAccountStakeBalance(address _sp)\n    external view\n    {\n        _validateBalanceInternal(_sp, Staking(stakingAddress).totalStakedFor(_sp));\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /// @notice Get the Staking address\n    function getStakingAddress() external view returns (address addr) {\n        return stakingAddress;\n    }\n\n    /// @notice Get the DelegateManager address\n    function getDelegateManagerAddress() external view returns (address addr) {\n        return delegateManagerAddress;\n    }\n\n    /// @notice Get the ServiceTypeManager address\n    function getServiceTypeManagerAddress() external view returns (address addr) {\n        return serviceTypeManagerAddress;\n    }\n\n    /// @notice Get the ClaimsManager address\n    function getClaimsManagerAddress() external view returns (address addr) {\n        return claimsManagerAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _address - address for new Governance contract\n     */\n    function setGovernanceAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        governanceAddress = _address;\n    }\n\n    /**\n     * @notice Set the Staking address\n     * @dev Only callable by Governance address\n     * @param _address - address for new Staking contract\n     */\n    function setStakingAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        stakingAddress = _address;\n    }\n\n    /**\n     * @notice Set the DelegateManager address\n     * @dev Only callable by Governance address\n     * @param _address - address for new DelegateManager contract\n     */\n    function setDelegateManagerAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        delegateManagerAddress = _address;\n    }\n\n    /**\n     * @notice Set the ServiceTypeManager address\n     * @dev Only callable by Governance address\n     * @param _address - address for new ServiceTypeManager contract\n     */\n    function setServiceTypeManagerAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        serviceTypeManagerAddress = _address;\n    }\n\n    /**\n     * @notice Set the ClaimsManager address\n     * @dev Only callable by Governance address\n     * @param _address - address for new ClaimsManager contract\n     */\n    function setClaimsManagerAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        claimsManagerAddress = _address;\n    }\n\n    /**\n     * @notice Update status in spDetails if the bounds for a service provider is valid\n     */\n    function _updateServiceProviderBoundStatus(address _serviceProvider) internal {\n        // Validate bounds for total stake\n        uint totalSPStake = Staking(stakingAddress).totalStakedFor(_serviceProvider);\n        if (totalSPStake < spDetails[_serviceProvider].minAccountStake ||\n            totalSPStake > spDetails[_serviceProvider].maxAccountStake) {\n            // Indicate this service provider is out of bounds\n            spDetails[_serviceProvider].validBounds = false;\n        } else {\n            // Indicate this service provider is within bounds\n            spDetails[_serviceProvider].validBounds = true;\n        }\n    }\n\n    /**\n     * @notice Compare a given amount input against valid min and max bounds for service provider\n     * @param _sp - address of service provider\n     * @param _amount - amount in wei to compare\n     */\n    function _validateBalanceInternal(address _sp, uint _amount) internal view\n    {\n        require(\n            _amount >= spDetails[_sp].minAccountStake,\n            \"Minimum stake requirement not met\");\n\n        require(\n            _amount <= spDetails[_sp].maxAccountStake,\n            \"Maximum stake amount exceeded\");\n\n        require(\n            spDetails[_sp].deployerStake == 0 || spDetails[_sp].deployerStake >= minDeployerStake,\n            \"Direct stake restriction violated for this service provider\");\n    }\n\n    /**\n     * @notice Get whether a decrease request has been initiated for service provider\n     * @param _serviceProvider - address of service provider\n     * return Boolean of whether decrease request has been initiated\n     */\n    function _decreaseRequestIsPending(address _serviceProvider)\n    internal view returns (bool pending)\n    {\n        return (\n            (decreaseStakeRequests[_serviceProvider].lockupExpiryBlock > 0) &&\n            (decreaseStakeRequests[_serviceProvider].decreaseAmount > 0)\n        );\n    }\n\n    /**\n     * @notice Boolean indicating whether a claim is pending for this service provider\n     */\n     /**\n     * @notice Get whether a claim is pending for this service provider\n     * @param _sp - address of service provider\n     * return Boolean of whether claim is pending\n     */\n    function _claimPending(address _sp) internal view returns (bool pending) {\n        return ClaimsManager(claimsManagerAddress).claimPending(_sp);\n    }\n}"
    }
  ]
}