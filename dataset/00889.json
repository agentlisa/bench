{
  "Title": "H-3: Incorrect Spot Price",
  "Content": "# Issue H-3: Incorrect Spot Price \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/81 \n\n## Found by \nxiaoming90\n## Summary\n\nMultiple discrepancies between the implementation of Leverage Vault's `_calcSpotPrice` function and SDK were observed, which indicate that the computed spot price is incorrect.\n\nIf the spot price is incorrect, it might potentially fail to detect the pool has been manipulated. In the worst-case scenario, the trade proceeds to execute against the manipulated pool, leading to a loss of assets.\n\n## Vulnerability Detail\n\nThe `BalancerSpotPrice._calculateStableMathSpotPrice` function relies on the `StableMath._calcSpotPrice` to compute the spot price of two tokens.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol#L93\n\n```solidity\nFile: BalancerSpotPrice.sol\n78:     function _calculateStableMathSpotPrice(\n..SNIP..\n86:         // Apply scale factors\n87:         uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n88: \n89:         uint256 invariant = StableMath._calculateInvariant(\n90:             ampParam, StableMath._balances(scaledPrimary, secondary), true // round up\n91:         );\n92: \n93:         spotPrice = StableMath._calcSpotPrice(ampParam, invariant, scaledPrimary, secondary);\n```\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/math/StableMath.sol#L90\n\n```solidity\nFile: StableMath.sol\n087:     /**\n088:      * @dev Calculates the spot price of token Y in token X.\n089:      */\n090:     function _calcSpotPrice(\n091:         uint256 amplificationParameter,\n092:         uint256 invariant, \n093:         uint256 balanceX,\n094:         uint256 balanceY\n095:     ) internal pure returns (uint256) {\n096:         /**************************************************************************************************************\n097:         //                                                                                                           //\n098:         //                             2.a.x.y + a.y^2 + b.y                                                         //\n099:         // spot price Y/X = - dx/dy = -----------------------                                                        //\n100:         //                             2.a.x.y + a.x^2 + b.x                                                         //\n101:         //                                                                                                           //\n102:         // n = 2                                                                                                     //\n103:         // a = amp param * n                                                                                         //\n104:         // b = D + a.(S - D)                                                                                         //\n105:         // D = invariant                                                                                             //\n106:         // S = sum of balances but x,y = 0 since x  and y are the only tokens                                        //\n107:         **************************************************************************************************************/\n108: \n109:         unchecked {\n110:             uint256 a = (amplificationParameter * 2) / _AMP_PRECISION;\n111:             uint256 b = Math.mul(invariant, a).sub(invariant);\n112: \n113:             uint256 axy2 = Math.mul(a * 2, balanceX).mulDown(balanceY); // n = 2\n114: \n115:             // dx = a.x.y.2 + a.y^2 - b.y\n116:             uint256 derivativeX = axy2.add(Math.mul(a, balanceY).mulDown(balanceY)).sub(b.mulDown(balanceY));\n117: \n118:             // dy = a.x.y.2 + a.x^2 - b.x\n119:             uint256 derivativeY = axy2.add(Math.mul(a, balanceX).mulDown(balanceX)).sub(b.mulDown(balanceX));\n120: \n121:             // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\n122:             // space. We use `divUp` as it prevents the result from being zero, which would make the logarithm revert. A\n123:             // result of zero is therefore only possible with zero balances, which are prevented via other means.\n124:             return derivativeX.divUp(derivativeY);\n125:         }\n126:     }\n```\n\nOn a high level, the spot price is computed by determining the pool derivatives. The Balancer SDK's provide a feature to compute the [spot price of any two tokens](https://github.com/balancer/balancer-sdk/blob/develop/balancer-js/src/modules/pools/pool-types/concerns/stablePhantom/spotPrice.spec.ts) within a pool, and it leverages the [`_poolDerivatives`](https://github.com/balancer/balancer-sor/blob/73d6b435c1429bbfc199b39b38a36e581838d2c3/src/pools/phantomStablePool/phantomStableMath.ts#L507) function.\n\nThe existing function for computing the spot price of any two tokens of a composable pool has the following errors or discrepancies from the approach used to compute the spot price in Balancer SDK, which might lead to an inaccurate spot price being computed.\n\n**Instance 1**\n\nThe comments and SDK add `b.y` and `b.x` to the numerator and denominator, respectively, in the formula. However, the code performs a subtraction.\n\n**Instance  2**\n\nPer the comment and SDK code, $b = (S - D) a + D$.\n\nHowever, assuming that $S$ is zero (for a two-token pool), the following code in the Leverage Vault to compute $b$ is not equivalent to the above.\n\n```solidity\nuint256 b = Math.mul(invariant, a).sub(invariant);\n```\n\n**Instance 3**\n\nThe $S$ in the code will always be zero because the code is catered only for two-token pools. However, for a composable pool, it can support up to five (5) tokens in a pool. $S$ should be as follows, where $balances$ is all the tokens in a composable pool except for BPT.\n\n$$\nS = \\sum_{i \\neq \\text{tokenIndexIn}, i \\neq \\text{tokenIndexOut}} \\text{balances}[i]\n$$\n\n**Instance 4**\n\nThe amplification factor is scaled by  `A * 2` in the code, while the SDK scaled it by  `A * 2^2` (ATimesNpowN). https://github.com/balancer/balancer-sor/blob/73d6b435c1429bbfc199b39b38a36e581838d2c3/src/pools/stablePool/stableMath.ts#L235C63-L235C74\n\n**Instance 5**\n\nPer [SDK](https://github.com/balancer/balancer-sor/blob/73d6b435c1429bbfc199b39b38a36e581838d2c3/src/pools/stablePool/stableMath.ts#L364), the amplification factor is scaled down by $n^{(n - 1)}$ where $n$ is the number of tokens in a composable pool (excluding BPT).  Otherwise, this was not implemented within the code.\n\n## Impact\n\nThe spot price is used to verify if the pool has been manipulated before executing certain key vault actions (e.g. reinvest rewards). If the spot price is incorrect, it might potentially fail to detect the pool has been manipulated or result in unintended reverts due to false positives. In the worst-case scenario, the trade proceeds to execute against the manipulated pool, leading to a loss of assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol#L93\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/math/StableMath.sol#L90\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nGiven multiple discrepancies between the implementation of Leverage Vault's `_calcSpotPrice` function and SDK and due to the lack of information on the web, it is recommended to reach out to the Balancer's protocol team to identify the actual formula used to determine a spot price of any two tokens within a composable pool and check out if the formula in the SDK is up-to-date to be used against the composable pool.\n\nIt is also recommended to implement additional tests to ensure that the `_calcSpotPrice` returns the correct spot price of composable pools.\n\nIn addition, the `StableMath._calcSpotPrice` function is no longer used or found within the current version of Balancer's composable pool. Thus, there is no guarantee that the math within the `StableMath._calcSpotPrice` works with the current implementation. It is recommended to use the existing method in the current Composable Pool's StableMath, such as `_calcOutGivenIn` (ensure the fee is excluded) to compute the spot price.\n\n\n\n## Discussion\n\n**jeffywu**\n\nCan confirm that this code no longer exists in the latest version of StableMath for the new ComposableStablePool, currently confirming with the Balancer team on how to approach this.\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/63\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"forge-std/console.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {StableMath} from \"./math/StableMath.sol\";\nimport {IComposablePool, IWeightedPool} from \"../../../interfaces/balancer/IBalancerPool.sol\";\nimport {IBalancerVault} from \"../../../interfaces/balancer/IBalancerVault.sol\";\n\n/**\n * @notice External, singleton helper contract deployed to calculate spot prices for Balancer pools.\n * Currently supports Composable pools with any number of tokens and Weighted2Token pools.\n */\ncontract BalancerSpotPrice {\n    uint256 internal constant BALANCER_PRECISION = 1e18;\n\n    /// @notice Returns the weighted pool spot price and balances. Only the spot price on the\n    /// secondary token is returned.\n    function getWeightedSpotPrices(\n        bytes32 poolId,\n        address poolAddress,\n        uint256 primaryIndex,\n        uint8 primaryDecimals\n    ) external view returns (uint256[] memory balances, uint256[] memory spotPrices) {\n        (/* */, balances, /* */) = Deployments.BALANCER_VAULT.getPoolTokens(poolId);\n        // Only two token pools are supported\n        require(balances.length == 2);\n        spotPrices = new uint256[](2);\n\n        uint256[] memory weights = IWeightedPool(poolAddress).getNormalizedWeights();\n\n        // Spot price calculation is specified at the link below. Do not account for swap fees\n        // because we're using this price to compare to the oracle price and adding swap fees\n        // would unnecessarily increase the price deviation.\n        // https://docs.balancer.fi/reference/math/weighted-math.html#typescript\n        // secondaryBalance * primaryWeight * primaryDecimals \n        // --------------------------------------------------- \n        //          primaryBalance * secondaryWeight\n        uint256 secondaryIndex = 1 - primaryIndex;\n\n        // There is a chance of a uint256 overflow if the balances[secondaryIndex] > 10**36\n        uint256 numerator = balances[secondaryIndex] * weights[primaryIndex] * (10 ** primaryDecimals);\n        uint256 denominator = balances[primaryIndex] * weights[secondaryIndex];\n        spotPrices[secondaryIndex] = numerator / denominator;\n    }\n\n    /// @notice Returns the composable pool spot price and balances. Pool token spot\n    /// prices are not returned, pool token balance is returned.\n    function getComposableSpotPrices(\n        bytes32 poolId,\n        address poolAddress,\n        uint256 primaryIndex\n    ) external view returns (uint256[] memory balances, uint256[] memory spotPrices) {\n        address[] memory tokens;\n        (tokens, balances, /* */) = Deployments.BALANCER_VAULT.getPoolTokens(poolId);\n        uint256[] memory scalingFactors = IComposablePool(poolAddress).getScalingFactors();\n\n        (\n            uint256 ampParam,\n            /* bool isUpdating */,\n            uint256 precision\n        ) = IComposablePool(poolAddress).getAmplificationParameter();\n        require(precision == StableMath._AMP_PRECISION);\n\n        // The primary index spot price is left as zero.\n        spotPrices = new uint256[](tokens.length);\n        uint256 scaledPrimary = balances[primaryIndex] * scalingFactors[primaryIndex] / BALANCER_PRECISION;\n        for (uint256 i; i < tokens.length; i++) {\n            if (i == primaryIndex) continue;\n            if (tokens[i] == poolAddress) continue;\n\n            spotPrices[i] = _calculateStableMathSpotPrice(\n                ampParam, scalingFactors, balances, scaledPrimary, primaryIndex, i\n            );\n        }\n    }\n\n    function _calculateStableMathSpotPrice(\n        uint256 ampParam,\n        uint256[] memory scalingFactors,\n        uint256[] memory balances,\n        uint256 scaledPrimary,\n        uint256 primaryIndex,\n        uint256 index2\n    ) internal pure returns (uint256 spotPrice) {\n        // Apply scale factors\n        uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n\n        uint256 invariant = StableMath._calculateInvariant(\n            ampParam, StableMath._balances(scaledPrimary, secondary), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice(ampParam, invariant, scaledPrimary, secondary);\n\n        // Remove scaling factors from spot price\n        spotPrice = spotPrice * scalingFactors[primaryIndex] / scalingFactors[index2];\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/math/StableMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Math} from \"./Math.sol\";\nimport {FixedPoint} from \"./FixedPoint.sol\";\n\nlibrary StableMath {\n    using FixedPoint for uint256;\n    \n    uint256 internal constant _AMP_PRECISION = 1e3;\n\n    error CalculationDidNotConverge();\n\n    // Note on unchecked arithmetic:\n    // This contract performs a large number of additions, subtractions, multiplications and divisions, often inside\n    // loops. Since many of these operations are gas-sensitive (as they happen e.g. during a swap), it is important to\n    // not make any unnecessary checks. We rely on a set of invariants to avoid having to use checked arithmetic (the\n    // Math library), including:\n    //  - the number of tokens is bounded by _MAX_STABLE_TOKENS\n    //  - the amplification parameter is bounded by _MAX_AMP * _AMP_PRECISION, which fits in 23 bits\n    //  - the token balances are bounded by 2^112 (guaranteed by the Vault) times 1e18 (the maximum scaling factor),\n    //    which fits in 172 bits\n    //\n    // This means e.g. we can safely multiply a balance by the amplification parameter without worrying about overflow.\n\n    // Computes the invariant given the current balances, using the Newton-Raphson approximation.\n    // The amplification parameter equals: A n^(n-1)\n    function _calculateInvariant(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        /**********************************************************************************************\n        // invariant                                                                                 //\n        // D = invariant                                                  D^(n+1)                    //\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n        // S = sum of balances                                             n^n P                     //\n        // P = product of balances                                                                   //\n        // n = number of tokens                                                                      //\n        *********x************************************************************************************/\n\n        unchecked {\n            // We support rounding up or down.\n            uint256 sum = 0;\n            uint256 numTokens = balances.length;\n            for (uint256 i = 0; i < numTokens; i++) {\n                sum = sum.add(balances[i]);\n            }\n            if (sum == 0) {\n                return 0;\n            }\n\n            uint256 prevInvariant = 0;\n            uint256 invariant = sum;\n            uint256 ampTimesTotal = amplificationParameter * numTokens;\n\n            for (uint256 i = 0; i < 255; i++) {\n                uint256 P_D = balances[0] * numTokens;\n                for (uint256 j = 1; j < numTokens; j++) {\n                    P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\n                }\n                prevInvariant = invariant;\n                invariant = Math.div(\n                    Math.mul(Math.mul(numTokens, invariant), invariant).add(\n                        Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n                    ),\n                    Math.mul(numTokens + 1, invariant).add(\n                        // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n                        Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION, !roundUp)\n                    ),\n                    roundUp\n                );\n\n                if (invariant > prevInvariant) {\n                    if (invariant - prevInvariant <= 1) {\n                        return invariant;\n                    }\n                } else if (prevInvariant - invariant <= 1) {\n                    return invariant;\n                }\n            }\n        }\n\n        revert CalculationDidNotConverge();\n    }\n\n    /**\n     * @dev Calculates the spot price of token Y in token X.\n     */\n    function _calcSpotPrice(\n        uint256 amplificationParameter,\n        uint256 invariant, \n        uint256 balanceX,\n        uint256 balanceY\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        //                                                                                                           //\n        //                             2.a.x.y + a.y^2 + b.y                                                         //\n        // spot price Y/X = - dx/dy = -----------------------                                                        //\n        //                             2.a.x.y + a.x^2 + b.x                                                         //\n        //                                                                                                           //\n        // n = 2                                                                                                     //\n        // a = amp param * n                                                                                         //\n        // b = D + a.(S - D)                                                                                         //\n        // D = invariant                                                                                             //\n        // S = sum of balances but x,y = 0 since x  and y are the only tokens                                        //\n        **************************************************************************************************************/\n\n        unchecked {\n            uint256 a = (amplificationParameter * 2) / _AMP_PRECISION;\n            uint256 b = Math.mul(invariant, a).sub(invariant);\n\n            uint256 axy2 = Math.mul(a * 2, balanceX).mulDown(balanceY); // n = 2\n\n            // dx = a.x.y.2 + a.y^2 - b.y\n            uint256 derivativeX = axy2.add(Math.mul(a, balanceY).mulDown(balanceY)).sub(b.mulDown(balanceY));\n\n            // dy = a.x.y.2 + a.x^2 - b.x\n            uint256 derivativeY = axy2.add(Math.mul(a, balanceX).mulDown(balanceX)).sub(b.mulDown(balanceX));\n\n            // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\n            // space. We use `divUp` as it prevents the result from being zero, which would make the logarithm revert. A\n            // result of zero is therefore only possible with zero balances, which are prevented via other means.\n            return derivativeX.divUp(derivativeY);\n        }\n    }\n\n    function _balances(uint256 balanceX, uint256 balanceY) internal pure returns (uint256[] memory balances) {\n        balances = new uint256[](2);\n        balances[0] = balanceX;\n        balances[1] = balanceY;\n    }\n\n    // This function calculates the balance of a given token (tokenIndex)\n    // given all the other balances and the invariant\n    function _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint256 tokenIndex\n    ) internal pure returns (uint256) {\n        // Rounds result up overall\n        unchecked {\n            uint256 ampTimesTotal = amplificationParameter * balances.length;\n            uint256 sum = balances[0];\n            uint256 P_D = balances[0] * balances.length;\n            for (uint256 j = 1; j < balances.length; j++) {\n                P_D = Math.divDown(Math.mul(Math.mul(P_D, balances[j]), balances.length), invariant);\n                sum = sum.add(balances[j]);\n            }\n            // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\n            sum = sum - balances[tokenIndex];\n\n            uint256 inv2 = Math.mul(invariant, invariant);\n            // We remove the balance fromm c by multiplying it\n            uint256 c = Math.mul(\n                Math.mul(Math.divUp(inv2, Math.mul(ampTimesTotal, P_D)), _AMP_PRECISION),\n                balances[tokenIndex]\n            );\n            uint256 b = sum.add(Math.mul(Math.divDown(invariant, ampTimesTotal), _AMP_PRECISION));\n\n            // We iterate to find the balance\n            uint256 prevTokenBalance = 0;\n            // We multiply the first iteration outside the loop with the invariant to set the value of the\n            // initial approximation.\n            uint256 tokenBalance = Math.divUp(inv2.add(c), invariant.add(b));\n\n            for (uint256 i = 0; i < 255; i++) {\n                prevTokenBalance = tokenBalance;\n\n                tokenBalance = Math.divUp(\n                    Math.mul(tokenBalance, tokenBalance).add(c),\n                    Math.mul(tokenBalance, 2).add(b).sub(invariant)\n                );\n\n                if (tokenBalance > prevTokenBalance) {\n                    if (tokenBalance - prevTokenBalance <= 1) {\n                        return tokenBalance;\n                    }\n                } else if (prevTokenBalance - tokenBalance <= 1) {\n                    return tokenBalance;\n                }\n            }\n        }\n\n        revert CalculationDidNotConverge();\n    }\n\n    function _calcTokenOutGivenExactBptIn(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256 tokenIndex,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage,\n        uint256 currentInvariant\n    ) internal pure returns (uint256) {\n        // Token out, so we round down overall.\n\n        unchecked {\n            uint256 newInvariant = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply).mulUp(currentInvariant);\n\n            // Calculate amount out without fee\n            uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amp,\n                balances,\n                newInvariant,\n                tokenIndex\n            );\n            uint256 amountOutWithoutFee = balances[tokenIndex].sub(newBalanceTokenIndex);\n\n            // First calculate the sum of all token balances, which will be used to calculate\n            // the current weight of each token\n            uint256 sumBalances = 0;\n            for (uint256 i = 0; i < balances.length; i++) {\n                sumBalances = sumBalances.add(balances[i]);\n            }\n\n            // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n            // in swap fees.\n            uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\n            uint256 taxablePercentage = currentWeight.complement();\n\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n            // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n            uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\n            uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n            // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n            return nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\n        }\n    }\n\n    // Computes how many tokens can be taken out of a pool if `tokenAmountIn` are sent, given the current balances.\n    // The amplification parameter equals: A n^(n-1)\n    function _calcOutGivenIn(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint256 tokenAmountIn,\n        uint256 invariant\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        // outGivenIn token x for y - polynomial equation to solve                                                   //\n        // ay = amount out to calculate                                                                              //\n        // by = balance token out                                                                                    //\n        // y = by - ay (finalBalanceOut)                                                                             //\n        // D = invariant                                               D                     D^(n+1)                 //\n        // A = amplification coefficient               y^2 + ( S - ----------  - D) * y -  ------------- = 0         //\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\n        // S = sum of final balances but y                                                                           //\n        // P = product of final balances but y                                                                       //\n        **************************************************************************************************************/\n\n        // Amount out, so we round down overall.\n        unchecked {\n            balances[tokenIndexIn] = balances[tokenIndexIn].add(tokenAmountIn);\n\n            uint256 finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amplificationParameter,\n                balances,\n                invariant,\n                tokenIndexOut\n            );\n\n            // No need to use checked arithmetic since `tokenAmountIn` was actually added to the same balance right before\n            // calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\n            balances[tokenIndexIn] = balances[tokenIndexIn] - tokenAmountIn;\n\n            return balances[tokenIndexOut].sub(finalBalanceOut).sub(1);\n        }\n    }\n}"
    },
    {
      "filename": "src/pools/stablePool/stableMath.ts",
      "content": "import { BigNumber, formatFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as EONE } from '@ethersproject/constants';\nimport {\n    BigNumber as OldBigNumber,\n    bnum,\n    ZERO,\n    ONE,\n} from '../../utils/bignumber';\nimport { StablePoolPairData } from './stablePool';\n// All functions are adapted from the solidity ones to be found on:\n// https://github.com/balancer-labs/balancer-core-v2/blob/master/contracts/pools/stable/StableMath.sol\n\n// TODO: implement all up and down rounding variations\n\n/**********************************************************************************************\n    // invariant                                                                                 //\n    // D = invariant to compute                                                                  //\n    // A = amplifier                n * D^2 + A * n^n * S * (n^n * P / D^(n−1))                  //\n    // S = sum of balances         ____________________________________________                  //\n    // P = product of balances    (n+1) * D + ( A * n^n − 1)* (n^n * P / D^(n−1))                //\n    // n = number of tokens                                                                      //\n    **********************************************************************************************/\nexport function _invariant(\n    A: BigNumber,\n    balances: OldBigNumber[] // balances\n): OldBigNumber {\n    let sum = ZERO;\n    const totalCoins = balances.length;\n    for (let i = 0; i < totalCoins; i++) {\n        sum = sum.plus(balances[i]);\n    }\n    if (sum.isZero()) {\n        return ZERO;\n    }\n    let prevInv = ZERO;\n    let inv = sum;\n\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const ATimesNpowN = AAdjusted.times(totalCoins ** totalCoins); // A*n^n\n\n    for (let i = 0; i < 255; i++) {\n        let P_D = bnum(totalCoins).times(balances[0]);\n        for (let j = 1; j < totalCoins; j++) {\n            //P_D is rounded up\n            P_D = P_D.times(balances[j]).times(totalCoins).div(inv);\n        }\n        prevInv = inv;\n        //inv is rounded up\n        inv = bnum(totalCoins)\n            .times(inv)\n            .times(inv)\n            .plus(ATimesNpowN.times(sum).times(P_D))\n            .div(\n                bnum(totalCoins + 1)\n                    .times(inv)\n                    .plus(ATimesNpowN.minus(1).times(P_D))\n            );\n        // Equality with the precision of 1\n        if (inv.gt(prevInv)) {\n            if (inv.minus(prevInv).lt(bnum(10 ** -18))) {\n                break;\n            }\n        } else if (prevInv.minus(inv).lt(bnum(10 ** -18))) {\n            break;\n        }\n    }\n    //Result is rounded up\n    return inv;\n}\n\n// Adapted from StableMath.sol, _outGivenIn()\n// * Added swap fee at very first line\n/**********************************************************************************************\n    // outGivenIn token x for y - polynomial equation to solve                                   //\n    // ay = amount out to calculate                                                              //\n    // by = balance token out                                                                    //\n    // y = by - ay                                                                               //\n    // D = invariant                               D                     D^(n+1)                 //\n    // A = amplifier               y^2 + ( S - ----------  - 1) * y -  ------------- = 0         //\n    // n = number of tokens                    (A * n^n)               A * n^2n * P              //\n    // S = sum of final balances but y                                                           //\n    // P = product of final balances but y                                                       //\n    **********************************************************************************************/\nexport function _exactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    let tokenAmountIn = amount;\n    tokenAmountIn = tokenAmountIn\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n\n    //Invariant is rounded up\n    const inv = _invariant(A, balances);\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = bnum(balances.length);\n    let n_pow_n = ONE;\n    let x = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        n_pow_n = n_pow_n.times(totalCoins);\n\n        if (i == tokenIndexIn) {\n            x = balances[i].plus(tokenAmountIn);\n        } else if (i != tokenIndexOut) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    //Calculate out balance\n    const y = _solveAnalyticalBalance(sum, inv, A, n_pow_n, p);\n\n    //Result is rounded down\n    // return balances[tokenIndexOut] > y ? balances[tokenIndexOut].minus(y) : 0;\n    return balances[tokenIndexOut].minus(y);\n}\n\n// Adapted from StableMath.sol, _inGivenOut()\n// * Added swap fee at very last line\n/**********************************************************************************************\n    // inGivenOut token x for y - polynomial equation to solve                                   //\n    // ax = amount in to calculate                                                               //\n    // bx = balance token in                                                                     //\n    // x = bx + ax                                                                               //\n    // D = invariant                               D                     D^(n+1)                 //\n    // A = amplifier               x^2 + ( S - ----------  - 1) * x -  ------------- = 0         //\n    // n = number of tokens                    (A * n^n)               A * n^2n * P              //\n    // S = sum of final balances but x                                                           //\n    // P = product of final balances but x                                                       //\n    **********************************************************************************************/\nexport function _tokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const tokenAmountOut = amount;\n    //Invariant is rounded up\n    const inv = _invariant(A, balances);\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = bnum(balances.length);\n    let n_pow_n = ONE;\n    let x = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        n_pow_n = n_pow_n.times(totalCoins);\n\n        if (i == tokenIndexOut) {\n            x = balances[i].minus(tokenAmountOut);\n        } else if (i != tokenIndexIn) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    //Calculate in balance\n    const y = _solveAnalyticalBalance(sum, inv, A, n_pow_n, p);\n\n    //Result is rounded up\n    return y\n        .minus(balances[tokenIndexIn])\n        .multipliedBy(EONE.toString())\n        .div(EONE.sub(swapFee).toString());\n}\n\n//This function calcuates the analytical solution to find the balance required\nexport function _solveAnalyticalBalance(\n    sum: OldBigNumber,\n    inv: OldBigNumber,\n    A: BigNumber,\n    n_pow_n: OldBigNumber,\n    p: OldBigNumber\n): OldBigNumber {\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const oldBN_A = bnum(formatFixed(A, 3));\n    //Round up p\n    p = p.times(inv).div(oldBN_A.times(n_pow_n).times(n_pow_n));\n    //Round down b\n    const b = sum.plus(inv.div(oldBN_A.times(n_pow_n)));\n    const c = inv\n        .minus(b)\n        .plus(inv.minus(b).times(inv.minus(b)).plus(p.times(4)).sqrt());\n    //Round up y\n    return c.div(2);\n}\n\n//////////////////////\n////  These functions have been added exclusively for the SORv2\n//////////////////////\n\nfunction _poolDerivatives(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    is_first_derivative: boolean,\n    wrt_out: boolean\n): OldBigNumber {\n    const totalCoins = balances.length;\n    const D = _invariant(A, balances);\n    let S = ZERO;\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn && i != tokenIndexOut) {\n            S = S.plus(balances[i]);\n        }\n    }\n    const x = balances[tokenIndexIn];\n    const y = balances[tokenIndexOut];\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const a = AAdjusted.times(totalCoins ** totalCoins); // = ATimesNpowN\n    const b = S.minus(D).times(a).plus(D);\n    const twoaxy = bnum(2).times(a).times(x).times(y);\n    const partial_x = twoaxy.plus(a.times(y).times(y)).plus(b.times(y));\n    const partial_y = twoaxy.plus(a.times(x).times(x)).plus(b.times(x));\n    let ans;\n    if (is_first_derivative) {\n        ans = partial_x.div(partial_y);\n    } else {\n        const partial_xx = bnum(2).times(a).times(y);\n        const partial_yy = bnum(2).times(a).times(x);\n        const partial_xy = partial_xx.plus(partial_yy).plus(b);\n        const numerator = bnum(2)\n            .times(partial_x)\n            .times(partial_y)\n            .times(partial_xy)\n            .minus(partial_xx.times(partial_y.pow(2)))\n            .minus(partial_yy.times(partial_x.pow(2)));\n        const denominator = partial_x.pow(2).times(partial_y);\n        ans = numerator.div(denominator);\n        if (wrt_out) {\n            ans = ans.times(partial_y).div(partial_x);\n        }\n    }\n    return ans;\n}\n\n/////////\n/// SpotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(EONE.sub(swapFee).toString()).div(EONE.toString())\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _exactTokenInForTokenOut(amount, poolPairData)\n    );\n    let ans = _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        false\n    );\n    ans = ONE.div(ans.times(EONE.sub(swapFee).toString()).div(EONE.toString()));\n    return ans;\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactTokenOut(amount, poolPairData)\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amount);\n    let ans = _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        true\n    );\n    ans = ONE.div(ans.times(EONE.sub(swapFee).toString()).div(EONE.toString()));\n    return ans;\n}\n\n/////////\n///  Derivatives of spotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(EONE.sub(swapFee).toString()).div(EONE.toString())\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _exactTokenInForTokenOut(amount, poolPairData)\n    );\n    return _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        false,\n        false\n    );\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactTokenOut(amount, poolPairData)\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amount);\n    const feeFactor = EONE.div(swapFee).toString();\n    return _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        false,\n        true\n    ).div(feeFactor);\n}\n\n// The following are used in front-end helper functions\n\nfunction _feeFactor(\n    balances: OldBigNumber[],\n    tokenIndex: number,\n    swapFee: BigNumber\n): OldBigNumber {\n    let sumBalances = ZERO;\n    for (let i = 0; i < balances.length; i++) {"
    }
  ]
}