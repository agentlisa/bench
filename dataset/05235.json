{
  "Title": "[H-05] User can evade `liquidation` by depositing the minimum of tokens and gain time to not be liquidated",
  "Content": "\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol#L140> \n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol#L70>\n\nThe [CollateralAndLiquidity](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol) contract contains a critical vulnerability that allows a user undergoing liquidation to evade the process by manipulating the `user.cooldownExpiration` variable. This manipulation is achieved through the [CollateralAndLiquidity::depositCollateralAndIncreaseShare](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol#L70) function, specifically within the [StakingRewards::\\_increaseUserShare](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L57) function (code line [#70](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L70)):\n\n<Details>\n\n```solidity\nFile: StakingRewards.sol\n57: \tfunction _increaseUserShare( address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown ) internal\n58: \t\t{\n59: \t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n60: \t\trequire( increaseShareAmount != 0, \"Cannot increase zero share\" );\n61: \n62: \t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n63: \n64: \t\tif ( useCooldown )\n65: \t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n66: \t\t\t{\n67: \t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n68: \n69: \t\t\t// Update the cooldown expiration for future transactions\n70: \t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n71: \t\t\t}\n72: \n73: \t\tuint256 existingTotalShares = totalShares[poolID];\n74: \n75: \t\t// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.\n76: \t\t// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.\n77: \t\t// The virtual rewards will be deducted later when calculating the user's owed rewards.\n78:         if ( existingTotalShares != 0 ) // prevent / 0\n79:         \t{\n80: \t\t\t// Round up in favor of the protocol.\n81: \t\t\tuint256 virtualRewardsToAdd = Math.ceilDiv( totalRewards[poolID] * increaseShareAmount, existingTotalShares );\n82: \n83: \t\t\tuser.virtualRewards += uint128(virtualRewardsToAdd);\n84: \t        totalRewards[poolID] += uint128(virtualRewardsToAdd);\n85: \t        }\n86: \n87: \t\t// Update the deposit balances\n88: \t\tuser.userShare += uint128(increaseShareAmount);\n89: \t\ttotalShares[poolID] = existingTotalShares + increaseShareAmount;\n90: \n91: \t\temit UserShareIncreased(wallet, poolID, increaseShareAmount);\n92: \t\t}\n```\n\n</details>\n\nMalicious user can perform front-running of the `liquidation` function by depositing small amounts of tokens to his position, incrementing the `user.cooldownExpiration` variable. Consequently, the execution of the `liquidation` function will be reverted with the error message `Must wait for the cooldown to expire.` This vulnerability could lead to attackers evading liquidation, potentially causing the system to enter into debt as liquidations are avoided.\n\n### Proof of Concept\n\nA test case, named `testUserLiquidationMayBeAvoided`, has been created to demonstrate the potential misuse of the system. The test involves the following steps:\n\n1.  User Alice deposits and borrow the maximum amount.\n2.  The collateral price crashes.\n3.  Alice maliciously front-runs the `liquidation` execution by depositing a the minimum amount using the `collateralAndLiquidity::depositCollateralAndIncreaseShare` function.\n4.  The `liquidation` transaction is reverted by \"Must wait for the cooldown to expire\" error.\n\n<details>\n\n```solidity\n// Filename: src/stable/tests/CollateralAndLiquidity.t.sol:TestCollateral\n// $ forge test --match-test \"testUserLiquidationMayBeAvoided\" --rpc-url https://yoururl -vv\n//\n    function testUserLiquidationMayBeAvoided() public {\n        // Liquidatable user can avoid liquidation\n        //\n\t\t// Have bob deposit so alice can withdraw everything without DUST reserves restriction\n        _depositHalfCollateralAndBorrowMax(bob);\n        //\n        // 1. Alice deposit and borrow the max amount\n        // Deposit and borrow for Alice\n        _depositHalfCollateralAndBorrowMax(alice);\n        // Check if Alice has a position\n        assertTrue(_userHasCollateral(alice));\n        //\n        // 2. Crash the collateral price\n        _crashCollateralPrice();\n        vm.warp( block.timestamp + 1 days );\n        //\n        // 3. Alice maliciously front run the liquidation action and deposit a DUST amount\n        vm.prank(alice);\n\t\tcollateralAndLiquidity.depositCollateralAndIncreaseShare(PoolUtils.DUST + 1, PoolUtils.DUST + 1, 0, block.timestamp, false );\n        //\n        // 4. The function alice liquidation will be reverted by \"Must wait for the cooldown to expire\"\n        vm.expectRevert( \"Must wait for the cooldown to expire\" );\n        collateralAndLiquidity.liquidateUser(alice);\n    }\n```\n</details>\n\n### Recommended Mitigation Steps\n\nConsider modifying the [liquidation](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol#L154) function as follows:\n\n<details>\n\n```diff\n\tfunction liquidateUser( address wallet ) external nonReentrant\n\t\t{\n\t\trequire( wallet != msg.sender, \"Cannot liquidate self\" );\n\n\t\t// First, make sure that the user's collateral ratio is below the required level\n\t\trequire( canUserBeLiquidated(wallet), \"User cannot be liquidated\" );\n\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\n\t\t// Withdraw the liquidated collateral from the liquidity pool.\n\t\t// The liquidity is owned by this contract so when it is withdrawn it will be reclaimed by this contract.\n\t\t(uint256 reclaimedWBTC, uint256 reclaimedWETH) = pools.removeLiquidity(wbtc, weth, userCollateralAmount, 0, 0, totalShares[collateralPoolID] );\n\n\t\t// Decrease the user's share of collateral as it has been liquidated and they no longer have it.\n--\t\t_decreaseUserShare( wallet, collateralPoolID, userCollateralAmount, true );\n++\t\t _decreaseUserShare( wallet, collateralPoolID, userCollateralAmount, false );\n\n\t\t// The caller receives a default 5% of the value of the liquidated collateral.\n\t\tuint256 rewardPercent = stableConfig.rewardPercentForCallingLiquidation();\n\n\t\tuint256 rewardedWBTC = (reclaimedWBTC * rewardPercent) / 100;\n\t\tuint256 rewardedWETH = (reclaimedWETH * rewardPercent) / 100;\n\n\t\t// Make sure the value of the rewardAmount is not excessive\n\t\tuint256 rewardValue = underlyingTokenValueInUSD( rewardedWBTC, rewardedWETH ); // in 18 decimals\n\t\tuint256 maxRewardValue = stableConfig.maxRewardValueForCallingLiquidation(); // 18 decimals\n\t\tif ( rewardValue > maxRewardValue )\n\t\t\t{\n\t\t\trewardedWBTC = (rewardedWBTC * maxRewardValue) / rewardValue;\n\t\t\trewardedWETH = (rewardedWETH * maxRewardValue) / rewardValue;\n\t\t\t}\n\n\t\t// Reward the caller\n\t\twbtc.safeTransfer( msg.sender, rewardedWBTC );\n\t\tweth.safeTransfer( msg.sender, rewardedWETH );\n\n\t\t// Send the remaining WBTC and WETH to the Liquidizer contract so that the tokens can be converted to USDS and burned (on Liquidizer.performUpkeep)\n\t\twbtc.safeTransfer( address(liquidizer), reclaimedWBTC - rewardedWBTC );\n\t\tweth.safeTransfer( address(liquidizer), reclaimedWETH - rewardedWETH );\n\n\t\t// Have the Liquidizer contract remember the amount of USDS that will need to be burned.\n\t\tuint256 originallyBorrowedUSDS = usdsBorrowedByUsers[wallet];\n\t\tliquidizer.incrementBurnableUSDS(originallyBorrowedUSDS);\n\n\t\t// Clear the borrowedUSDS for the user who was liquidated so that they can simply keep the USDS they previously borrowed.\n\t\tusdsBorrowedByUsers[wallet] = 0;\n\t\t_walletsWithBorrowedUSDS.remove(wallet);\n\n\t\temit Liquidation(msg.sender, wallet, reclaimedWBTC, reclaimedWETH, originallyBorrowedUSDS);\n\t\t}\n```\n\n</details>\n\nThis modification ensures that the `user.cooldownExpiration` expiration check does not interfere with the `liquidation` process, mitigating the identified security risk.\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/312#issuecomment-1960801151):**\n > The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:\n> \n> https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9\n> \n\n**Status:** Mitigation confirmed. Full details in reports from [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/45), [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/65), and [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/28).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/stable/CollateralAndLiquidity.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"./interfaces/ICollateralAndLiquidity.sol\";\nimport \"./interfaces/IStableConfig.sol\";\nimport \"./interfaces/ILiquidizer.sol\";\nimport \"../staking/Liquidity.sol\";\n\n// The deployed contract through which all liquidity on the exchange is deposited and withdrawn.\n// Also allows users to deposit WBTC/WETH liquidity as collateral for borrowing USDS stablecoin.\n\n// The default initial collateralization ratio of collateral / borrowed USDS is 200%.\n// The minimum default collateral ratio is 110%, below which positions can be liquidated by any user.\n// Users who call the liquidation function on undercollateralized positions receive a default 5% of the liquidated collateral (up to a default max value of $500).\n// Liquidated users lose their deposited WBTC/WETH collateral and keep the USDS that they borrowed.\n\ncontract CollateralAndLiquidity is Liquidity, ICollateralAndLiquidity\n    {\n    event CollateralDeposited(address indexed depositor, uint256 amountWBTC, uint256 amountWETH, uint256 liquidity);\n    event CollateralWithdrawn(address indexed withdrawer, uint256 collateralWithdrawn, uint256 reclaimedWBTC, uint256 reclaimedWETH);\n    event BorrowedUSDS(address indexed borrower, uint256 amountBorrowed);\n    event RepaidUSDS(address indexed repayer, uint256 amountRepaid);\n    event Liquidation(address indexed liquidator, address indexed liquidatee, uint256 reclaimedWBTC, uint256 reclaimedWETH, uint256 originallyBorrowedUSDS);\n\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IUSDS;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IStableConfig immutable public stableConfig;\n\tIPriceAggregator immutable public priceAggregator;\n    IUSDS immutable public usds;\n\tIERC20 immutable public wbtc;\n\tIERC20 immutable public weth;\n\tILiquidizer immutable public liquidizer;\n\n\t// Cached for efficiency\n\tuint256 immutable public wbtcTenToTheDecimals;\n    uint256 immutable public wethTenToTheDecimals;\n\n   \t// Keeps track of wallets that have borrowed USDS (so that they can be checked easily for sufficient collateral ratios)\n   \tEnumerableSet.AddressSet private _walletsWithBorrowedUSDS;\n\n\t// The amount of USDS that has been borrowed by each user\n    mapping(address=>uint256) public usdsBorrowedByUsers;\n\n\n    constructor( IPools _pools, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig, IStableConfig _stableConfig, IPriceAggregator _priceAggregator, ILiquidizer _liquidizer )\n\t\tLiquidity( _pools, _exchangeConfig, _poolsConfig, _stakingConfig )\n    \t{\n\t\tpriceAggregator = _priceAggregator;\n        stableConfig = _stableConfig;\n        liquidizer = _liquidizer;\n\n\t\tusds = _exchangeConfig.usds();\n\t\twbtc = exchangeConfig.wbtc();\n\t\tweth = exchangeConfig.weth();\n\n\t\twbtcTenToTheDecimals = 10 ** IERC20Metadata(address(wbtc)).decimals();\n\t\twethTenToTheDecimals = 10 ** IERC20Metadata(address(weth)).decimals();\n    \t}\n\n\n\t// Deposit WBTC/WETH liqudity as collateral and increase the caller's collateral share for future rewards.\n\t// Requires exchange access for the sending wallet (through depositLiquidityAndIncreaseShare)\n\tfunction depositCollateralAndIncreaseShare( uint256 maxAmountWBTC, uint256 maxAmountWETH, uint256 minLiquidityReceived, uint256 deadline, bool useZapping ) external nonReentrant ensureNotExpired(deadline)  returns (uint256 addedAmountWBTC, uint256 addedAmountWETH, uint256 addedLiquidity)\n\t\t{\n\t\t// Have the user deposit the specified WBTC/WETH liquidity and increase their collateral share\n\t\t(addedAmountWBTC, addedAmountWETH, addedLiquidity) = _depositLiquidityAndIncreaseShare( wbtc, weth, maxAmountWBTC, maxAmountWETH, minLiquidityReceived, useZapping );\n\n\t\temit CollateralDeposited(msg.sender, addedAmountWBTC, addedAmountWETH, addedLiquidity);\n\t\t}\n\n\n\t// Withdraw WBTC/WETH collateral and claim any pending rewards.\n    function withdrawCollateralAndClaim( uint256 collateralToWithdraw, uint256 minReclaimedWBTC, uint256 minReclaimedWETH, uint256 deadline ) external nonReentrant ensureNotExpired(deadline) returns (uint256 reclaimedWBTC, uint256 reclaimedWETH)\n\t\t{\n\t\t// Make sure that the user has collateral and if they have borrowed USDS that collateralToWithdraw doesn't bring their collateralRatio below allowable levels.\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( collateralToWithdraw <= maxWithdrawableCollateral(msg.sender), \"Excessive collateralToWithdraw\" );\n\n\t\t// Withdraw the WBTC/WETH liquidity from the liquidity pool (sending the reclaimed tokens back to the user)\n\t\t(reclaimedWBTC, reclaimedWETH) = _withdrawLiquidityAndClaim( wbtc, weth, collateralToWithdraw, minReclaimedWBTC, minReclaimedWETH );\n\n\t\temit CollateralWithdrawn(msg.sender, collateralToWithdraw, reclaimedWBTC, reclaimedWETH);\n\t\t}\n\n\n\t// Borrow USDS using existing collateral, making sure that the amount being borrowed does not exceed maxBorrowable\n\t// Requires exchange access for the sending wallet\n    function borrowUSDS( uint256 amountBorrowed ) external nonReentrant\n\t\t{\n\t\trequire( exchangeConfig.walletHasAccess(msg.sender), \"Sender does not have exchange access\" );\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( amountBorrowed <= maxBorrowableUSDS(msg.sender), \"Excessive amountBorrowed\" );\n\n\t\t// Increase the borrowed amount for the user\n\t\tusdsBorrowedByUsers[msg.sender] += amountBorrowed;\n\n\t\t// Remember that the user has borrowed USDS (so they can later be checked for sufficient collateralization ratios and liquidated if necessary)\n\t\t_walletsWithBorrowedUSDS.add(msg.sender);\n\n\t\t// Mint USDS and send it to the user\n\t\tusds.mintTo( msg.sender, amountBorrowed );\n\n\t\temit BorrowedUSDS(msg.sender, amountBorrowed);\n\t\t}\n\n\n     // Repay borrowed USDS and adjust the user's usdsBorrowedByUser\n     function repayUSDS( uint256 amountRepaid ) external nonReentrant\n\t\t{\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( amountRepaid <= usdsBorrowedByUsers[msg.sender], \"Cannot repay more than the borrowed amount\" );\n\t\trequire( amountRepaid > 0, \"Cannot repay zero amount\" );\n\n\t\t// Decrease the borrowed amount for the user\n\t\tusdsBorrowedByUsers[msg.sender] -= amountRepaid;\n\n\t\t// Have the user send the USDS to the USDS contract so that it can later be burned (on USDS.performUpkeep)\n\t\tusds.safeTransferFrom(msg.sender, address(usds), amountRepaid);\n\n\t\t// Have USDS remember that the USDS should be burned\n\t\tliquidizer.incrementBurnableUSDS( amountRepaid );\n\n\t\t// Check if the user no longer has any borrowed USDS\n\t\tif ( usdsBorrowedByUsers[msg.sender] == 0 )\n\t\t\t_walletsWithBorrowedUSDS.remove(msg.sender);\n\n\t\temit RepaidUSDS(msg.sender, amountRepaid);\n\t\t}\n\n\n\t// Liquidate a position which has fallen under the minimum collateral ratio.\n\t// A default 5% of the value of the collateral is sent to the caller, with the rest being sent to the Liquidator for later conversion to USDS which is then burned.\n\tfunction liquidateUser( address wallet ) external nonReentrant\n\t\t{\n\t\trequire( wallet != msg.sender, \"Cannot liquidate self\" );\n\n\t\t// First, make sure that the user's collateral ratio is below the required level\n\t\trequire( canUserBeLiquidated(wallet), \"User cannot be liquidated\" );\n\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\n\t\t// Withdraw the liquidated collateral from the liquidity pool.\n\t\t// The liquidity is owned by this contract so when it is withdrawn it will be reclaimed by this contract.\n\t\t(uint256 reclaimedWBTC, uint256 reclaimedWETH) = pools.removeLiquidity(wbtc, weth, userCollateralAmount, 0, 0, totalShares[collateralPoolID] );\n\n\t\t// Decrease the user's share of collateral as it has been liquidated and they no longer have it.\n\t\t_decreaseUserShare( wallet, collateralPoolID, userCollateralAmount, true );\n\n\t\t// The caller receives a default 5% of the value of the liquidated collateral.\n\t\tuint256 rewardPercent = stableConfig.rewardPercentForCallingLiquidation();\n\n\t\tuint256 rewardedWBTC = (reclaimedWBTC * rewardPercent) / 100;\n\t\tuint256 rewardedWETH = (reclaimedWETH * rewardPercent) / 100;\n\n\t\t// Make sure the value of the rewardAmount is not excessive\n\t\tuint256 rewardValue = underlyingTokenValueInUSD( rewardedWBTC, rewardedWETH ); // in 18 decimals\n\t\tuint256 maxRewardValue = stableConfig.maxRewardValueForCallingLiquidation(); // 18 decimals\n\t\tif ( rewardValue > maxRewardValue )\n\t\t\t{\n\t\t\trewardedWBTC = (rewardedWBTC * maxRewardValue) / rewardValue;\n\t\t\trewardedWETH = (rewardedWETH * maxRewardValue) / rewardValue;\n\t\t\t}\n\n\t\t// Reward the caller\n\t\twbtc.safeTransfer( msg.sender, rewardedWBTC );\n\t\tweth.safeTransfer( msg.sender, rewardedWETH );\n\n\t\t// Send the remaining WBTC and WETH to the Liquidizer contract so that the tokens can be converted to USDS and burned (on Liquidizer.performUpkeep)\n\t\twbtc.safeTransfer( address(liquidizer), reclaimedWBTC - rewardedWBTC );\n\t\tweth.safeTransfer( address(liquidizer), reclaimedWETH - rewardedWETH );\n\n\t\t// Have the Liquidizer contract remember the amount of USDS that will need to be burned.\n\t\tuint256 originallyBorrowedUSDS = usdsBorrowedByUsers[wallet];\n\t\tliquidizer.incrementBurnableUSDS(originallyBorrowedUSDS);\n\n\t\t// Clear the borrowedUSDS for the user who was liquidated so that they can simply keep the USDS they previously borrowed.\n\t\tusdsBorrowedByUsers[wallet] = 0;\n\t\t_walletsWithBorrowedUSDS.remove(wallet);\n\n\t\temit Liquidation(msg.sender, wallet, reclaimedWBTC, reclaimedWETH, originallyBorrowedUSDS);\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// The current market value in USD for a given amount of BTC and ETH using the PriceAggregator\n\t// Returns the value with 18 decimals\n\tfunction underlyingTokenValueInUSD( uint256 amountBTC, uint256 amountETH ) public view returns (uint256)\n\t\t{\n\t\t// Prices from the price feed have 18 decimals\n\t\tuint256 btcPrice = priceAggregator.getPriceBTC();\n        uint256 ethPrice = priceAggregator.getPriceETH();\n\n\t\t// Keep the 18 decimals from the price and remove the decimals from the token balance\n\t\tuint256 btcValue = ( amountBTC * btcPrice ) / wbtcTenToTheDecimals;\n\t\tuint256 ethValue = ( amountETH * ethPrice ) / wethTenToTheDecimals;\n\n\t\treturn btcValue + ethValue;\n\t\t}\n\n\n\t// The current market value of all WBTC/WETH collateral that has been deposited\n\t// Returns the value with 18 decimals\n\tfunction totalCollateralValueInUSD() public view returns (uint256)\n\t\t{\n\t\t(uint256 reservesWBTC, uint256 reservesWETH) = pools.getPoolReserves(wbtc, weth);\n\n\t\treturn underlyingTokenValueInUSD( reservesWBTC, reservesWETH );\n\t\t}\n\n\n\t// The current market value of the user's collateral in USD\n\t// Returns the value with 18 decimals\n\tfunction userCollateralValueInUSD( address wallet ) public view returns (uint256)\n\t\t{\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\t\tif ( userCollateralAmount == 0 )\n\t\t\treturn 0;\n\n\t\tuint256 totalCollateralShares = totalShares[collateralPoolID];\n\n\t\t// Determine how much collateral share the user currently has\n\t\t(uint256 reservesWBTC, uint256 reservesWETH) = pools.getPoolReserves(wbtc, weth);\n\n\t\tuint256 userWBTC = (reservesWBTC * userCollateralAmount ) / totalCollateralShares;\n\t\tuint256 userWETH = (reservesWETH * userCollateralAmount ) / totalCollateralShares;\n\n\t\treturn underlyingTokenValueInUSD( userWBTC, userWETH );\n\t\t}\n\n\n\t// The maximum amount of collateral that can be withdrawn while keeping the collateral ratio above a default of 200%\n\t// Returns value with 18 decimals\n\tfunction maxWithdrawableCollateral( address wallet ) public view returns (uint256)\n\t\t{\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\n\t\t// If the user has no collateral then they can't withdraw any collateral\n\t\tif ( userCollateralAmount == 0 )\n\t\t\treturn 0;\n\n\t\t// When withdrawing, require that the user keep at least the inital collateral ratio (default 200%)\n\t\tuint256 requiredCollateralValueAfterWithdrawal = ( usdsBorrowedByUsers[wallet] * stableConfig.initialCollateralRatioPercent() ) / 100;\n\t\tuint256 userCollateralValue = userCollateralValueInUSD( wallet );\n\n\t\t// If the user doesn't even have the minimum amount of required collateral then return zero\n\t\tif ( userCollateralValue <= requiredCollateralValueAfterWithdrawal )\n\t\t\treturn 0;\n\n\t\t// The maximum withdrawable value in USD\n\t\tuint256 maxWithdrawableValue = userCollateralValue - requiredCollateralValueAfterWithdrawal;\n\n\t\t// Return the collateralAmount that can be withdrawn\n\t\treturn userCollateralAmount * maxWithdrawableValue / userCollateralValue;\n   \t\t}\n\n\n\t// The maximum amount of USDS that can be borrowed given the user's current collateral and existing balance of borrowedUSDS.\n\t// Max borrowable USDS defaults to 50% of collateral value.\n\t// Returns value with 18 decimals.\n\tfunction maxBorrowableUSDS( address wallet ) public view returns (uint256)\n\t\t{\n\t\t// If the user doesn't have any collateral, then they can't borrow any USDS\n\t\tif ( userShareForPool( wallet, collateralPoolID ) == 0 )\n\t\t\treturn 0;\n\n\t\t// The user's current collateral value will determine the maximum amount that can be borrowed\n\t\tuint256 userCollateralValue  = userCollateralValueInUSD( wallet );\n\n\t\tif ( userCollateralValue < stableConfig.minimumCollateralValueForBorrowing() )\n\t\t\treturn 0;\n\n\t\tuint256 maxBorrowableAmount = ( userCollateralValue * 100 ) / stableConfig.initialCollateralRatioPercent();\n\n\t\t// Already borrowing more than the max?\n\t\tif ( usdsBorrowedByUsers[wallet] >= maxBorrowableAmount )\n\t\t\treturn 0;\n\n\t\treturn maxBorrowableAmount - usdsBorrowedByUsers[wallet];\n   \t\t}\n\n\n\tfunction numberOfUsersWithBorrowedUSDS() public view returns (uint256)\n\t\t{\n\t\treturn _walletsWithBorrowedUSDS.length();\n\t\t}\n\n\n\t// Confirm that a user can be liquidated - that they have borrowed USDS and that their collateral value / borrowedUSDS ratio is less than the minimum required\n\tfunction canUserBeLiquidated( address wallet ) public view returns (bool)\n\t\t{\n\t\t// Check the current collateral ratio for the user\n\t\tuint256 usdsBorrowedAmount = usdsBorrowedByUsers[wallet];\n\t\tif ( usdsBorrowedAmount == 0 )\n\t\t\treturn false;\n\n\t\tuint256 userCollateralValue = userCollateralValueInUSD(wallet);\n\n\t\t// Make sure the user's position is under collateralized\n\t\treturn (( userCollateralValue * 100 ) / usdsBorrowedAmount) < stableConfig.minimumCollateralRatioPercent();\n\t\t}\n\n\n\tfunction findLiquidatableUsers( uint256 startIndex, uint256 endIndex ) public view returns (address[] memory)\n\t\t{\n\t\taddress[] memory liquidatableUsers = new address[](endIndex - startIndex + 1);\n\t\tuint256 count = 0;\n\n\t\t// Cache\n\t\tuint256 totalCollateralShares = totalShares[collateralPoolID];\n\t\tuint256 totalCollateralValue = totalCollateralValueInUSD();\n\n\t\tif ( totalCollateralValue != 0 )\n\t\t\tfor ( uint256 i = startIndex; i <= endIndex; i++ )\n\t\t\t\t{\n\t\t\t\taddress wallet = _walletsWithBorrowedUSDS.at(i);\n\n\t\t\t\t// Determine the minCollateralValue a user needs to have based on their borrowedUSDS\n\t\t\t\tuint256 minCollateralValue = (usdsBorrowedByUsers[wallet] * stableConfig.minimumCollateralRatioPercent()) / 100;\n\n\t\t\t\t// Determine minCollateral in terms of minCollateralValue\n\t\t\t\tuint256 minCollateral = (minCollateralValue * totalCollateralShares) / totalCollateralValue;\n\n\t\t\t\t// Make sure the user has at least minCollateral\n\t\t\t\tif ( userShareForPool( wallet, collateralPoolID ) < minCollateral )\n\t\t\t\t\tliquidatableUsers[count++] = wallet;\n\t\t\t\t}\n\n\t\t// Resize the array to match the actual number of liquidatable positions found\n\t\taddress[] memory resizedLiquidatableUsers = new address[](count);\n\t\tfor ( uint256 i = 0; i < count; i++ )\n\t\t\tresizedLiquidatableUsers[i] = liquidatableUsers[i];\n\n\t\treturn resizedLiquidatableUsers;\n\t\t}\n\n\n\tfunction findLiquidatableUsers() external view returns (address[] memory)\n\t\t{\n\t\tif ( numberOfUsersWithBorrowedUSDS() == 0 )\n\t\t\treturn new address[](0);\n\n\t\treturn findLiquidatableUsers( 0, numberOfUsersWithBorrowedUSDS() - 1 );\n\t\t}\n\t}"
    },
    {
      "filename": "src/stable/CollateralAndLiquidity.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"./interfaces/ICollateralAndLiquidity.sol\";\nimport \"./interfaces/IStableConfig.sol\";\nimport \"./interfaces/ILiquidizer.sol\";\nimport \"../staking/Liquidity.sol\";\n\n// The deployed contract through which all liquidity on the exchange is deposited and withdrawn.\n// Also allows users to deposit WBTC/WETH liquidity as collateral for borrowing USDS stablecoin.\n\n// The default initial collateralization ratio of collateral / borrowed USDS is 200%.\n// The minimum default collateral ratio is 110%, below which positions can be liquidated by any user.\n// Users who call the liquidation function on undercollateralized positions receive a default 5% of the liquidated collateral (up to a default max value of $500).\n// Liquidated users lose their deposited WBTC/WETH collateral and keep the USDS that they borrowed.\n\ncontract CollateralAndLiquidity is Liquidity, ICollateralAndLiquidity\n    {\n    event CollateralDeposited(address indexed depositor, uint256 amountWBTC, uint256 amountWETH, uint256 liquidity);\n    event CollateralWithdrawn(address indexed withdrawer, uint256 collateralWithdrawn, uint256 reclaimedWBTC, uint256 reclaimedWETH);\n    event BorrowedUSDS(address indexed borrower, uint256 amountBorrowed);\n    event RepaidUSDS(address indexed repayer, uint256 amountRepaid);\n    event Liquidation(address indexed liquidator, address indexed liquidatee, uint256 reclaimedWBTC, uint256 reclaimedWETH, uint256 originallyBorrowedUSDS);\n\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IUSDS;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IStableConfig immutable public stableConfig;\n\tIPriceAggregator immutable public priceAggregator;\n    IUSDS immutable public usds;\n\tIERC20 immutable public wbtc;\n\tIERC20 immutable public weth;\n\tILiquidizer immutable public liquidizer;\n\n\t// Cached for efficiency\n\tuint256 immutable public wbtcTenToTheDecimals;\n    uint256 immutable public wethTenToTheDecimals;\n\n   \t// Keeps track of wallets that have borrowed USDS (so that they can be checked easily for sufficient collateral ratios)\n   \tEnumerableSet.AddressSet private _walletsWithBorrowedUSDS;\n\n\t// The amount of USDS that has been borrowed by each user\n    mapping(address=>uint256) public usdsBorrowedByUsers;\n\n\n    constructor( IPools _pools, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig, IStableConfig _stableConfig, IPriceAggregator _priceAggregator, ILiquidizer _liquidizer )\n\t\tLiquidity( _pools, _exchangeConfig, _poolsConfig, _stakingConfig )\n    \t{\n\t\tpriceAggregator = _priceAggregator;\n        stableConfig = _stableConfig;\n        liquidizer = _liquidizer;\n\n\t\tusds = _exchangeConfig.usds();\n\t\twbtc = exchangeConfig.wbtc();\n\t\tweth = exchangeConfig.weth();\n\n\t\twbtcTenToTheDecimals = 10 ** IERC20Metadata(address(wbtc)).decimals();\n\t\twethTenToTheDecimals = 10 ** IERC20Metadata(address(weth)).decimals();\n    \t}\n\n\n\t// Deposit WBTC/WETH liqudity as collateral and increase the caller's collateral share for future rewards.\n\t// Requires exchange access for the sending wallet (through depositLiquidityAndIncreaseShare)\n\tfunction depositCollateralAndIncreaseShare( uint256 maxAmountWBTC, uint256 maxAmountWETH, uint256 minLiquidityReceived, uint256 deadline, bool useZapping ) external nonReentrant ensureNotExpired(deadline)  returns (uint256 addedAmountWBTC, uint256 addedAmountWETH, uint256 addedLiquidity)\n\t\t{\n\t\t// Have the user deposit the specified WBTC/WETH liquidity and increase their collateral share\n\t\t(addedAmountWBTC, addedAmountWETH, addedLiquidity) = _depositLiquidityAndIncreaseShare( wbtc, weth, maxAmountWBTC, maxAmountWETH, minLiquidityReceived, useZapping );\n\n\t\temit CollateralDeposited(msg.sender, addedAmountWBTC, addedAmountWETH, addedLiquidity);\n\t\t}\n\n\n\t// Withdraw WBTC/WETH collateral and claim any pending rewards.\n    function withdrawCollateralAndClaim( uint256 collateralToWithdraw, uint256 minReclaimedWBTC, uint256 minReclaimedWETH, uint256 deadline ) external nonReentrant ensureNotExpired(deadline) returns (uint256 reclaimedWBTC, uint256 reclaimedWETH)\n\t\t{\n\t\t// Make sure that the user has collateral and if they have borrowed USDS that collateralToWithdraw doesn't bring their collateralRatio below allowable levels.\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( collateralToWithdraw <= maxWithdrawableCollateral(msg.sender), \"Excessive collateralToWithdraw\" );\n\n\t\t// Withdraw the WBTC/WETH liquidity from the liquidity pool (sending the reclaimed tokens back to the user)\n\t\t(reclaimedWBTC, reclaimedWETH) = _withdrawLiquidityAndClaim( wbtc, weth, collateralToWithdraw, minReclaimedWBTC, minReclaimedWETH );\n\n\t\temit CollateralWithdrawn(msg.sender, collateralToWithdraw, reclaimedWBTC, reclaimedWETH);\n\t\t}\n\n\n\t// Borrow USDS using existing collateral, making sure that the amount being borrowed does not exceed maxBorrowable\n\t// Requires exchange access for the sending wallet\n    function borrowUSDS( uint256 amountBorrowed ) external nonReentrant\n\t\t{\n\t\trequire( exchangeConfig.walletHasAccess(msg.sender), \"Sender does not have exchange access\" );\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( amountBorrowed <= maxBorrowableUSDS(msg.sender), \"Excessive amountBorrowed\" );\n\n\t\t// Increase the borrowed amount for the user\n\t\tusdsBorrowedByUsers[msg.sender] += amountBorrowed;\n\n\t\t// Remember that the user has borrowed USDS (so they can later be checked for sufficient collateralization ratios and liquidated if necessary)\n\t\t_walletsWithBorrowedUSDS.add(msg.sender);\n\n\t\t// Mint USDS and send it to the user\n\t\tusds.mintTo( msg.sender, amountBorrowed );\n\n\t\temit BorrowedUSDS(msg.sender, amountBorrowed);\n\t\t}\n\n\n     // Repay borrowed USDS and adjust the user's usdsBorrowedByUser\n     function repayUSDS( uint256 amountRepaid ) external nonReentrant\n\t\t{\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( amountRepaid <= usdsBorrowedByUsers[msg.sender], \"Cannot repay more than the borrowed amount\" );\n\t\trequire( amountRepaid > 0, \"Cannot repay zero amount\" );\n\n\t\t// Decrease the borrowed amount for the user\n\t\tusdsBorrowedByUsers[msg.sender] -= amountRepaid;\n\n\t\t// Have the user send the USDS to the USDS contract so that it can later be burned (on USDS.performUpkeep)\n\t\tusds.safeTransferFrom(msg.sender, address(usds), amountRepaid);\n\n\t\t// Have USDS remember that the USDS should be burned\n\t\tliquidizer.incrementBurnableUSDS( amountRepaid );\n\n\t\t// Check if the user no longer has any borrowed USDS\n\t\tif ( usdsBorrowedByUsers[msg.sender] == 0 )\n\t\t\t_walletsWithBorrowedUSDS.remove(msg.sender);\n\n\t\temit RepaidUSDS(msg.sender, amountRepaid);\n\t\t}\n\n\n\t// Liquidate a position which has fallen under the minimum collateral ratio.\n\t// A default 5% of the value of the collateral is sent to the caller, with the rest being sent to the Liquidator for later conversion to USDS which is then burned.\n\tfunction liquidateUser( address wallet ) external nonReentrant\n\t\t{\n\t\trequire( wallet != msg.sender, \"Cannot liquidate self\" );\n\n\t\t// First, make sure that the user's collateral ratio is below the required level\n\t\trequire( canUserBeLiquidated(wallet), \"User cannot be liquidated\" );\n\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\n\t\t// Withdraw the liquidated collateral from the liquidity pool.\n\t\t// The liquidity is owned by this contract so when it is withdrawn it will be reclaimed by this contract.\n\t\t(uint256 reclaimedWBTC, uint256 reclaimedWETH) = pools.removeLiquidity(wbtc, weth, userCollateralAmount, 0, 0, totalShares[collateralPoolID] );\n\n\t\t// Decrease the user's share of collateral as it has been liquidated and they no longer have it.\n\t\t_decreaseUserShare( wallet, collateralPoolID, userCollateralAmount, true );\n\n\t\t// The caller receives a default 5% of the value of the liquidated collateral.\n\t\tuint256 rewardPercent = stableConfig.rewardPercentForCallingLiquidation();\n\n\t\tuint256 rewardedWBTC = (reclaimedWBTC * rewardPercent) / 100;\n\t\tuint256 rewardedWETH = (reclaimedWETH * rewardPercent) / 100;\n\n\t\t// Make sure the value of the rewardAmount is not excessive\n\t\tuint256 rewardValue = underlyingTokenValueInUSD( rewardedWBTC, rewardedWETH ); // in 18 decimals\n\t\tuint256 maxRewardValue = stableConfig.maxRewardValueForCallingLiquidation(); // 18 decimals\n\t\tif ( rewardValue > maxRewardValue )\n\t\t\t{\n\t\t\trewardedWBTC = (rewardedWBTC * maxRewardValue) / rewardValue;\n\t\t\trewardedWETH = (rewardedWETH * maxRewardValue) / rewardValue;\n\t\t\t}\n\n\t\t// Reward the caller\n\t\twbtc.safeTransfer( msg.sender, rewardedWBTC );\n\t\tweth.safeTransfer( msg.sender, rewardedWETH );\n\n\t\t// Send the remaining WBTC and WETH to the Liquidizer contract so that the tokens can be converted to USDS and burned (on Liquidizer.performUpkeep)\n\t\twbtc.safeTransfer( address(liquidizer), reclaimedWBTC - rewardedWBTC );\n\t\tweth.safeTransfer( address(liquidizer), reclaimedWETH - rewardedWETH );\n\n\t\t// Have the Liquidizer contract remember the amount of USDS that will need to be burned.\n\t\tuint256 originallyBorrowedUSDS = usdsBorrowedByUsers[wallet];\n\t\tliquidizer.incrementBurnableUSDS(originallyBorrowedUSDS);\n\n\t\t// Clear the borrowedUSDS for the user who was liquidated so that they can simply keep the USDS they previously borrowed.\n\t\tusdsBorrowedByUsers[wallet] = 0;\n\t\t_walletsWithBorrowedUSDS.remove(wallet);\n\n\t\temit Liquidation(msg.sender, wallet, reclaimedWBTC, reclaimedWETH, originallyBorrowedUSDS);\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// The current market value in USD for a given amount of BTC and ETH using the PriceAggregator\n\t// Returns the value with 18 decimals\n\tfunction underlyingTokenValueInUSD( uint256 amountBTC, uint256 amountETH ) public view returns (uint256)\n\t\t{\n\t\t// Prices from the price feed have 18 decimals\n\t\tuint256 btcPrice = priceAggregator.getPriceBTC();\n        uint256 ethPrice = priceAggregator.getPriceETH();\n\n\t\t// Keep the 18 decimals from the price and remove the decimals from the token balance\n\t\tuint256 btcValue = ( amountBTC * btcPrice ) / wbtcTenToTheDecimals;\n\t\tuint256 ethValue = ( amountETH * ethPrice ) / wethTenToTheDecimals;\n\n\t\treturn btcValue + ethValue;\n\t\t}\n\n\n\t// The current market value of all WBTC/WETH collateral that has been deposited\n\t// Returns the value with 18 decimals\n\tfunction totalCollateralValueInUSD() public view returns (uint256)\n\t\t{\n\t\t(uint256 reservesWBTC, uint256 reservesWETH) = pools.getPoolReserves(wbtc, weth);\n\n\t\treturn underlyingTokenValueInUSD( reservesWBTC, reservesWETH );\n\t\t}\n\n\n\t// The current market value of the user's collateral in USD\n\t// Returns the value with 18 decimals\n\tfunction userCollateralValueInUSD( address wallet ) public view returns (uint256)\n\t\t{\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\t\tif ( userCollateralAmount == 0 )\n\t\t\treturn 0;\n\n\t\tuint256 totalCollateralShares = totalShares[collateralPoolID];\n\n\t\t// Determine how much collateral share the user currently has\n\t\t(uint256 reservesWBTC, uint256 reservesWETH) = pools.getPoolReserves(wbtc, weth);\n\n\t\tuint256 userWBTC = (reservesWBTC * userCollateralAmount ) / totalCollateralShares;\n\t\tuint256 userWETH = (reservesWETH * userCollateralAmount ) / totalCollateralShares;\n\n\t\treturn underlyingTokenValueInUSD( userWBTC, userWETH );\n\t\t}\n\n\n\t// The maximum amount of collateral that can be withdrawn while keeping the collateral ratio above a default of 200%\n\t// Returns value with 18 decimals\n\tfunction maxWithdrawableCollateral( address wallet ) public view returns (uint256)\n\t\t{\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\n\t\t// If the user has no collateral then they can't withdraw any collateral\n\t\tif ( userCollateralAmount == 0 )\n\t\t\treturn 0;\n\n\t\t// When withdrawing, require that the user keep at least the inital collateral ratio (default 200%)\n\t\tuint256 requiredCollateralValueAfterWithdrawal = ( usdsBorrowedByUsers[wallet] * stableConfig.initialCollateralRatioPercent() ) / 100;\n\t\tuint256 userCollateralValue = userCollateralValueInUSD( wallet );\n\n\t\t// If the user doesn't even have the minimum amount of required collateral then return zero\n\t\tif ( userCollateralValue <= requiredCollateralValueAfterWithdrawal )\n\t\t\treturn 0;\n\n\t\t// The maximum withdrawable value in USD\n\t\tuint256 maxWithdrawableValue = userCollateralValue - requiredCollateralValueAfterWithdrawal;\n\n\t\t// Return the collateralAmount that can be withdrawn\n\t\treturn userCollateralAmount * maxWithdrawableValue / userCollateralValue;\n   \t\t}\n\n\n\t// The maximum amount of USDS that can be borrowed given the user's current collateral and existing balance of borrowedUSDS.\n\t// Max borrowable USDS defaults to 50% of collateral value.\n\t// Returns value with 18 decimals.\n\tfunction maxBorrowableUSDS( address wallet ) public view returns (uint256)\n\t\t{\n\t\t// If the user doesn't have any collateral, then they can't borrow any USDS\n\t\tif ( userShareForPool( wallet, collateralPoolID ) == 0 )\n\t\t\treturn 0;\n\n\t\t// The user's current collateral value will determine the maximum amount that can be borrowed\n\t\tuint256 userCollateralValue  = userCollateralValueInUSD( wallet );\n\n\t\tif ( userCollateralValue < stableConfig.minimumCollateralValueForBorrowing() )\n\t\t\treturn 0;\n\n\t\tuint256 maxBorrowableAmount = ( userCollateralValue * 100 ) / stableConfig.initialCollateralRatioPercent();\n\n\t\t// Already borrowing more than the max?\n\t\tif ( usdsBorrowedByUsers[wallet] >= maxBorrowableAmount )\n\t\t\treturn 0;\n\n\t\treturn maxBorrowableAmount - usdsBorrowedByUsers[wallet];\n   \t\t}\n\n\n\tfunction numberOfUsersWithBorrowedUSDS() public view returns (uint256)\n\t\t{\n\t\treturn _walletsWithBorrowedUSDS.length();\n\t\t}\n\n\n\t// Confirm that a user can be liquidated - that they have borrowed USDS and that their collateral value / borrowedUSDS ratio is less than the minimum required\n\tfunction canUserBeLiquidated( address wallet ) public view returns (bool)\n\t\t{\n\t\t// Check the current collateral ratio for the user\n\t\tuint256 usdsBorrowedAmount = usdsBorrowedByUsers[wallet];\n\t\tif ( usdsBorrowedAmount == 0 )\n\t\t\treturn false;\n\n\t\tuint256 userCollateralValue = userCollateralValueInUSD(wallet);\n\n\t\t// Make sure the user's position is under collateralized\n\t\treturn (( userCollateralValue * 100 ) / usdsBorrowedAmount) < stableConfig.minimumCollateralRatioPercent();\n\t\t}\n\n\n\tfunction findLiquidatableUsers( uint256 startIndex, uint256 endIndex ) public view returns (address[] memory)\n\t\t{\n\t\taddress[] memory liquidatableUsers = new address[](endIndex - startIndex + 1);\n\t\tuint256 count = 0;\n\n\t\t// Cache\n\t\tuint256 totalCollateralShares = totalShares[collateralPoolID];\n\t\tuint256 totalCollateralValue = totalCollateralValueInUSD();\n\n\t\tif ( totalCollateralValue != 0 )\n\t\t\tfor ( uint256 i = startIndex; i <= endIndex; i++ )\n\t\t\t\t{\n\t\t\t\taddress wallet = _walletsWithBorrowedUSDS.at(i);\n\n\t\t\t\t// Determine the minCollateralValue a user needs to have based on their borrowedUSDS\n\t\t\t\tuint256 minCollateralValue = (usdsBorrowedByUsers[wallet] * stableConfig.minimumCollateralRatioPercent()) / 100;\n\n\t\t\t\t// Determine minCollateral in terms of minCollateralValue\n\t\t\t\tuint256 minCollateral = (minCollateralValue * totalCollateralShares) / totalCollateralValue;\n\n\t\t\t\t// Make sure the user has at least minCollateral\n\t\t\t\tif ( userShareForPool( wallet, collateralPoolID ) < minCollateral )\n\t\t\t\t\tliquidatableUsers[count++] = wallet;\n\t\t\t\t}\n\n\t\t// Resize the array to match the actual number of liquidatable positions found\n\t\taddress[] memory resizedLiquidatableUsers = new address[](count);\n\t\tfor ( uint256 i = 0; i < count; i++ )\n\t\t\tresizedLiquidatableUsers[i] = liquidatableUsers[i];\n\n\t\treturn resizedLiquidatableUsers;\n\t\t}\n\n\n\tfunction findLiquidatableUsers() external view returns (address[] memory)\n\t\t{\n\t\tif ( numberOfUsersWithBorrowedUSDS() == 0 )\n\t\t\treturn new address[](0);\n\n\t\treturn findLiquidatableUsers( 0, numberOfUsersWithBorrowedUSDS() - 1 );\n\t\t}\n\t}"
    },
    {
      "filename": "src/stable/CollateralAndLiquidity.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidi"
    }
  ]
}