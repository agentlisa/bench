{
  "Title": "[M-07] Improper Approval Mechanism of Clearing House",
  "Content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/ClearingHouse.sol#L148-L151><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/ClearingHouse.sol#L160-L165><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L637-L641><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/CollateralToken.sol#L566-L577>\n\nThe `ClearingHouse` implementation performs a `@solmate`-based `safeApprove` instruction (\\[1]) with the remaining `balanceOf(address(this))` but contains code handling any remainder of funds that may remain in the contract \\[2]. Investigation of the `payDebtViaClearingHouse` function will indicate that the function may not consume the maximum approval that was set to the `TRANSFER_PROXY` \\[3].\n\nAs a result, any consequent invocation of `_execute` via `safeTransferFrom` from OpenSea with a `paymentToken` (i.e. `identifier`) such as USDT would fail. Given that the `ClearingHouse` of a particular `collateralId` is created only once, this vulnerability will impact consequent listings and cause them to fatally fail for a token that has been used in the past and is part of the non-compliant EIP-20 tokens, with USDT being the prime and most popular example.\n\nThe code in USDT that causes this complication is as follows:\n\n```sol\nrequire(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n```\n\n### Proof of Concept\n\nThe vulnerability is clearly defined above, however, for testing purposes, the `ClearingHouse::safeTransferFrom` function of a particular clearing house instance can be invoked twice with the same arguments. The second invocation will fail provided that the first invocation provided a token balance that exceeds the number of funds necessary for the debt payment which should be denoted in USDT.\n\nOn an important note, if the code used `safeApprove` from `@openzeppelin` this issue would affect any token, however, it is limited to non-standard tokens due to the usage of the `@solmate` implementation of `safeApprove`.\n\n### Tools Used\n\nManual review of the codebase. Historically, findings pertaining to incorrect approval mechanisms that do not support USDT have been marked as \"medium\" in severity in the past in the following cases:\n\n*   [Rubicon](https://code4rena.com/reports/2022-05-rubicon/#m-08-usdt-is-not-supported-because-of-approval-mechanism)\n*   [Duality Focus](https://code4rena.com/reports/2022-04-dualityfocus/#m-03-not-calling-approve0-before-setting-a-new-approval-causes-the-call-to-revert-when-used-with-tether-usdt)\n\n### Recommended Mitigation Steps\n\nWe advise approvals to be properly handled by evaluating whether a non-zero approval already exists and in such an instance nullifying it before re-setting it to a non-zero value. Example below:\n\n```sol\n// Optimizing lookup\naddress transferProxy = address(ASTARIA_ROUTER.TRANSFER_PROXY());\n\n// If existing approval is non-zero -> set it to zero\nif (ERC20(paymentToken).allowance(address(this), transferProxy) != 0) {\n    ERC20(paymentToken).safeApprove(transferProxy, 0);\n}\n\n// Set non-zero approval\nERC20(paymentToken).safeApprove(transferProxy, payment - liquidatorPayment);\n```\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {IERC1155} from \"core/interfaces/IERC1155.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {AmountDeriver} from \"seaport/lib/AmountDeriver.sol\";\nimport {Order} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\ncontract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n  using Bytes32AddressLib for bytes32;\n  using SafeTransferLib for ERC20;\n\n  struct ClearingHouseStorage {\n    ILienToken.AuctionData auctionStack;\n  }\n\n  uint256 private constant CLEARING_HOUSE_STORAGE_SLOT =\n    uint256(keccak256(\"xyz.astaria.ClearingHouse.storage.location\")) - 1;\n\n  function ROUTER() public pure returns (IAstariaRouter) {\n    return IAstariaRouter(_getArgAddress(0));\n  }\n\n  function COLLATERAL_ID() public pure returns (uint256) {\n    return _getArgUint256(21);\n  }\n\n  function IMPL_TYPE() public pure returns (uint8) {\n    return _getArgUint8(20);\n  }\n\n  function _getStorage()\n    internal\n    pure\n    returns (ClearingHouseStorage storage s)\n  {\n    uint256 slot = CLEARING_HOUSE_STORAGE_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function setAuctionData(ILienToken.AuctionData calldata auctionData)\n    external\n  {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    //only execute from the conduit\n    require(msg.sender == address(ASTARIA_ROUTER.LIEN_TOKEN()));\n\n    ClearingHouseStorage storage s = _getStorage();\n    s.auctionStack = auctionData;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    return interfaceId == type(IERC1155).interfaceId;\n  }\n\n  function balanceOf(address account, uint256 id)\n    external\n    view\n    returns (uint256)\n  {\n    return type(uint256).max;\n  }\n\n  function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    external\n    view\n    returns (uint256[] memory output)\n  {\n    output = new uint256[](accounts.length);\n    for (uint256 i; i < accounts.length; ) {\n      output[i] = type(uint256).max;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function setApprovalForAll(address operator, bool approved) external {}\n\n  function isApprovedForAll(address account, address operator)\n    external\n    view\n    returns (bool)\n  {\n    return true;\n  }\n\n  function _execute(\n    address tokenContract, // collateral token sending the fake nft\n    address to, // buyer\n    uint256 encodedMetaData, //retrieve token address from the encoded data\n    uint256 // space to encode whatever is needed,\n  ) internal {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    ClearingHouseStorage storage s = _getStorage();\n    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n\n    uint256 currentOfferPrice = _locateCurrentAmount({\n      startAmount: s.auctionStack.startAmount,\n      endAmount: s.auctionStack.endAmount,\n      startTime: s.auctionStack.startTime,\n      endTime: s.auctionStack.endTime,\n      roundUp: true //we are a consideration we round up\n    });\n    uint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\n    require(payment >= currentOfferPrice, \"not enough funds received\");\n\n    uint256 collateralId = _getArgUint256(21);\n    // pay liquidator fees here\n\n    ILienToken.AuctionStack[] storage stack = s.auctionStack.stack;\n\n    uint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);\n\n    ERC20(paymentToken).safeTransfer(\n      s.auctionStack.liquidator,\n      liquidatorPayment\n    );\n\n    ERC20(paymentToken).safeApprove(\n      address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n      payment - liquidatorPayment\n    );\n\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      paymentToken,\n      collateralId,\n      payment - liquidatorPayment,\n      s.auctionStack.stack\n    );\n\n    if (ERC20(paymentToken).balanceOf(address(this)) > 0) {\n      ERC20(paymentToken).safeTransfer(\n        ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),\n        ERC20(paymentToken).balanceOf(address(this))\n      );\n    }\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n  }\n\n  function safeTransferFrom(\n    address from, // the from is the offerer\n    address to,\n    uint256 identifier,\n    uint256 amount,\n    bytes calldata data //empty from seaport\n  ) public {\n    //data is empty and useless\n    _execute(from, to, identifier, amount);\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) public {}\n\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external override returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  function validateOrder(Order memory order) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    Order[] memory listings = new Order[](1);\n    listings[0] = order;\n\n    ERC721(order.parameters.offer[0].token).approve(\n      ASTARIA_ROUTER.COLLATERAL_TOKEN().getConduit(),\n      order.parameters.offer[0].identifierOrCriteria\n    );\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().SEAPORT().validate(listings);\n  }\n\n  function transferUnderlying(\n    address tokenContract,\n    uint256 tokenId,\n    address target\n  ) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n  }\n\n  function settleLiquidatorNFTClaim() external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ClearingHouseStorage storage s = _getStorage();\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      address(0),\n      COLLATERAL_ID(),\n      0,\n      s.auctionStack.stack\n    );\n  }\n}"
    },
    {
      "filename": "src/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {IERC1155} from \"core/interfaces/IERC1155.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {AmountDeriver} from \"seaport/lib/AmountDeriver.sol\";\nimport {Order} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\ncontract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n  using Bytes32AddressLib for bytes32;\n  using SafeTransferLib for ERC20;\n\n  struct ClearingHouseStorage {\n    ILienToken.AuctionData auctionStack;\n  }\n\n  uint256 private constant CLEARING_HOUSE_STORAGE_SLOT =\n    uint256(keccak256(\"xyz.astaria.ClearingHouse.storage.location\")) - 1;\n\n  function ROUTER() public pure returns (IAstariaRouter) {\n    return IAstariaRouter(_getArgAddress(0));\n  }\n\n  function COLLATERAL_ID() public pure returns (uint256) {\n    return _getArgUint256(21);\n  }\n\n  function IMPL_TYPE() public pure returns (uint8) {\n    return _getArgUint8(20);\n  }\n\n  function _getStorage()\n    internal\n    pure\n    returns (ClearingHouseStorage storage s)\n  {\n    uint256 slot = CLEARING_HOUSE_STORAGE_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function setAuctionData(ILienToken.AuctionData calldata auctionData)\n    external\n  {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    //only execute from the conduit\n    require(msg.sender == address(ASTARIA_ROUTER.LIEN_TOKEN()));\n\n    ClearingHouseStorage storage s = _getStorage();\n    s.auctionStack = auctionData;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    return interfaceId == type(IERC1155).interfaceId;\n  }\n\n  function balanceOf(address account, uint256 id)\n    external\n    view\n    returns (uint256)\n  {\n    return type(uint256).max;\n  }\n\n  function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    external\n    view\n    returns (uint256[] memory output)\n  {\n    output = new uint256[](accounts.length);\n    for (uint256 i; i < accounts.length; ) {\n      output[i] = type(uint256).max;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function setApprovalForAll(address operator, bool approved) external {}\n\n  function isApprovedForAll(address account, address operator)\n    external\n    view\n    returns (bool)\n  {\n    return true;\n  }\n\n  function _execute(\n    address tokenContract, // collateral token sending the fake nft\n    address to, // buyer\n    uint256 encodedMetaData, //retrieve token address from the encoded data\n    uint256 // space to encode whatever is needed,\n  ) internal {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    ClearingHouseStorage storage s = _getStorage();\n    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n\n    uint256 currentOfferPrice = _locateCurrentAmount({\n      startAmount: s.auctionStack.startAmount,\n      endAmount: s.auctionStack.endAmount,\n      startTime: s.auctionStack.startTime,\n      endTime: s.auctionStack.endTime,\n      roundUp: true //we are a consideration we round up\n    });\n    uint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\n    require(payment >= currentOfferPrice, \"not enough funds received\");\n\n    uint256 collateralId = _getArgUint256(21);\n    // pay liquidator fees here\n\n    ILienToken.AuctionStack[] storage stack = s.auctionStack.stack;\n\n    uint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);\n\n    ERC20(paymentToken).safeTransfer(\n      s.auctionStack.liquidator,\n      liquidatorPayment\n    );\n\n    ERC20(paymentToken).safeApprove(\n      address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n      payment - liquidatorPayment\n    );\n\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      paymentToken,\n      collateralId,\n      payment - liquidatorPayment,\n      s.auctionStack.stack\n    );\n\n    if (ERC20(paymentToken).balanceOf(address(this)) > 0) {\n      ERC20(paymentToken).safeTransfer(\n        ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),\n        ERC20(paymentToken).balanceOf(address(this))\n      );\n    }\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n  }\n\n  function safeTransferFrom(\n    address from, // the from is the offerer\n    address to,\n    uint256 identifier,\n    uint256 amount,\n    bytes calldata data //empty from seaport\n  ) public {\n    //data is empty and useless\n    _execute(from, to, identifier, amount);\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) public {}\n\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external override returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  function validateOrder(Order memory order) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    Order[] memory listings = new Order[](1);\n    listings[0] = order;\n\n    ERC721(order.parameters.offer[0].token).approve(\n      ASTARIA_ROUTER.COLLATERAL_TOKEN().getConduit(),\n      order.parameters.offer[0].identifierOrCriteria\n    );\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().SEAPORT().validate(listings);\n  }\n\n  function transferUnderlying(\n    address tokenContract,\n    uint256 tokenId,\n    address target\n  ) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n  }\n\n  function settleLiquidatorNFTClaim() external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ClearingHouseStorage storage s = _getStorage();\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      address(0),\n      COLLATERAL_ID(),\n      0,\n      s.auctionStack.stack\n    );\n  }\n}"
    },
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\nimport {Initializable} from \"./utils/Initializable.sol\";\n\n/**\n * @title LienToken\n * @notice This contract handles the creation, payments, buyouts, and liquidations of tokenized NFT-collateralized debt (liens). Vaults which originate loans against supported collateral are issued a LienToken representing the right to loan repayments and auctioned funds on liquidation.\n */\ncontract LienToken is ERC721, ILienToken, AuthInitializable {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  uint256 private constant LIEN_SLOT =\n    uint256(keccak256(\"xyz.astaria.LienToken.storage.location\")) - 1;\n\n  bytes32 constant ACTIVE_AUCTION = bytes32(\"ACTIVE_AUCTION\");\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(Authority _AUTHORITY, ITransferProxy _TRANSFER_PROXY)\n    public\n    initializer\n  {\n    __initAuth(msg.sender, address(_AUTHORITY));\n    __initERC721(\"Astaria Lien Token\", \"ALT\");\n    LienStorage storage s = _loadLienStorageSlot();\n    s.TRANSFER_PROXY = _TRANSFER_PROXY;\n    s.maxLiens = uint8(5);\n  }\n\n  function _loadLienStorageSlot()\n    internal\n    pure\n    returns (LienStorage storage s)\n  {\n    uint256 slot = LIEN_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function file(File calldata incoming) external requiresAuth {\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    LienStorage storage s = _loadLienStorageSlot();\n    if (what == FileType.CollateralToken) {\n      s.COLLATERAL_TOKEN = ICollateralToken(abi.decode(data, (address)));\n    } else if (what == FileType.AstariaRouter) {\n      s.ASTARIA_ROUTER = IAstariaRouter(abi.decode(data, (address)));\n    } else {\n      revert UnsupportedFile();\n    }\n    emit FileUpdated(what, data);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ILienToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function buyoutLien(ILienToken.LienActionBuyout calldata params)\n    external\n    validateStack(params.encumber.lien.collateralId, params.encumber.stack)\n    returns (Stack[] memory, Stack memory newStack)\n  {\n    if (block.timestamp >= params.encumber.stack[params.position].point.end) {\n      revert InvalidState(InvalidStates.EXPIRED_LIEN);\n    }\n    LienStorage storage s = _loadLienStorageSlot();\n    if (!s.ASTARIA_ROUTER.isValidVault(msg.sender)) {\n      revert InvalidSender();\n    }\n    return _buyoutLien(s, params);\n  }\n\n  function _buyoutLien(\n    LienStorage storage s,\n    ILienToken.LienActionBuyout calldata params\n  ) internal returns (Stack[] memory newStack, Stack memory newLien) {\n    //the borrower shouldn't incur more debt from the buyout than they already owe\n    (, newLien) = _createLien(s, params.encumber);\n    if (\n      !s.ASTARIA_ROUTER.isValidRefinance({\n        newLien: params.encumber.lien,\n        position: params.position,\n        stack: params.encumber.stack\n      })\n    ) {\n      revert InvalidRefinance();\n    }\n\n    if (\n      s.collateralStateHash[params.encumber.lien.collateralId] == ACTIVE_AUCTION\n    ) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    (uint256 owed, uint256 buyout) = _getBuyout(\n      s,\n      params.encumber.stack[params.position]\n    );\n\n    if (params.encumber.lien.details.maxAmount < owed) {\n      revert InvalidBuyoutDetails(params.encumber.lien.details.maxAmount, owed);\n    }\n\n    uint256 potentialDebt = 0;\n    for (uint256 i = params.encumber.stack.length; i > 0; ) {\n      uint256 j = i - 1;\n      // should not be able to purchase lien if any lien in the stack is expired (and will be liquidated)\n      if (block.timestamp >= params.encumber.stack[j].point.end) {\n        revert InvalidState(InvalidStates.EXPIRED_LIEN);\n      }\n\n      potentialDebt += _getOwed(\n        params.encumber.stack[j],\n        params.encumber.stack[j].point.end\n      );\n\n      if (\n        potentialDebt >\n        params.encumber.stack[j].lien.details.liquidationInitialAsk\n      ) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\n      unchecked {\n        --i;\n      }\n    }\n\n    address payee = _getPayee(\n      s,\n      params.encumber.stack[params.position].point.lienId\n    );\n    s.TRANSFER_PROXY.tokenTransferFrom(\n      params.encumber.stack[params.position].lien.token,\n      msg.sender,\n      payee,\n      buyout\n    );\n\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).handleBuyoutLien(\n        IPublicVault.BuyoutLienParams({\n          lienSlope: calculateSlope(params.encumber.stack[params.position]),\n          lienEnd: params.encumber.stack[params.position].point.end,\n          increaseYIntercept: buyout -\n            params.encumber.stack[params.position].point.amount\n        })\n      );\n    }\n\n    newStack = _replaceStackAtPositionWithNewLien(\n      s,\n      params.encumber.stack,\n      params.position,\n      newLien,\n      params.encumber.stack[params.position].point.lienId\n    );\n    uint256 maxPotentialDebt;\n    uint256 n = newStack.length;\n    uint256 i;\n    for (i; i < n; ) {\n      maxPotentialDebt += _getOwed(newStack[i], newStack[i].point.end);\n      //no need to check validity before the position we're buying\n      if (i == params.position) {\n        if (maxPotentialDebt > params.encumber.lien.details.maxPotentialDebt) {\n          revert InvalidState(InvalidStates.DEBT_LIMIT);\n        }\n      }\n      if (\n        i > params.position &&\n        (maxPotentialDebt > newStack[i].lien.details.maxPotentialDebt)\n      ) {\n        revert InvalidState(InvalidStates.DEBT_LIMIT);\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    s.collateralStateHash[params.encumber.lien.collateralId] = keccak256(\n      abi.encode(newStack)\n    );\n  }\n\n  function _replaceStackAtPositionWithNewLien(\n    LienStorage storage s,\n    ILienToken.Stack[] calldata stack,\n    uint256 position,\n    Stack memory newLien,\n    uint256 oldLienId\n  ) internal returns (ILienToken.Stack[] memory newStack) {\n    newStack = stack;\n    newStack[position] = newLien;\n    _burn(oldLienId);\n    delete s.lienMeta[oldLienId];\n  }\n\n  function getInterest(Stack calldata stack) public view returns (uint256) {\n    return _getInterest(stack, block.timestamp);\n  }\n\n  /**\n   * @dev Computes the interest accrued for a lien since its last payment.\n   * @param stack The Lien for the loan to calculate interest for.\n   * @param timestamp The timestamp at which to compute interest for.\n   */\n  function _getInterest(Stack memory stack, uint256 timestamp)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 delta_t = timestamp - stack.point.last;\n\n    return (delta_t * stack.lien.details.rate).mulWadDown(stack.point.amount);\n  }\n\n  modifier validateStack(uint256 collateralId, Stack[] memory stack) {\n    LienStorage storage s = _loadLienStorageSlot();\n    bytes32 stateHash = s.collateralStateHash[collateralId];\n    if (stateHash == bytes32(0) && stack.length != 0) {\n      revert InvalidState(InvalidStates.EMPTY_STATE);\n    }\n    if (stateHash != bytes32(0) && keccak256(abi.encode(stack)) != stateHash) {\n      revert InvalidState(InvalidStates.INVALID_HASH);\n    }\n    _;\n  }\n\n  function stopLiens(\n    uint256 collateralId,\n    uint256 auctionWindow,\n    Stack[] calldata stack,\n    address liquidator\n  ) external validateStack(collateralId, stack) requiresAuth {\n    _stopLiens(\n      _loadLienStorageSlot(),\n      collateralId,\n      auctionWindow,\n      stack,\n      liquidator\n    );\n  }\n\n  function _stopLiens(\n    LienStorage storage s,\n    uint256 collateralId,\n    uint256 auctionWindow,\n    Stack[] calldata stack,\n    address liquidator\n  ) internal {\n    AuctionData memory auctionData;\n    auctionData.liquidator = liquidator;\n    auctionData.stack = new AuctionStack[](stack.length);\n    s.auctionData[collateralId].liquidator = liquidator;\n    uint256 i;\n    for (; i < stack.length; ) {\n      AuctionStack memory auctionStack;\n\n      auctionStack.lienId = stack[i].point.lienId;\n      auctionStack.end = stack[i].point.end;\n      uint88 owed = _getOwed(stack[i], block.timestamp);\n      auctionStack.amountOwed = owed;\n      s.lienMeta[auctionStack.lienId].atLiquidation = true;\n      auctionData.stack[i] = auctionStack;\n      address payee = _getPayee(s, auctionStack.lienId);\n      if (_isPublicVault(s, payee)) {\n        // update the public vault state and get the liquidation accountant back if any\n        address withdrawProxyIfNearBoundary = IPublicVault(payee)\n          .updateVaultAfterLiquidation(\n            auctionWindow,\n            IPublicVault.AfterLiquidationParams({\n              lienSlope: calculateSlope(stack[i]),\n              newAmount: owed,\n              lienEnd: stack[i].point.end\n            })\n          );\n\n        if (withdrawProxyIfNearBoundary != address(0)) {\n          _setPayee(s, auctionStack.lienId, withdrawProxyIfNearBoundary);\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    s.collateralStateHash[collateralId] = ACTIVE_AUCTION;\n    auctionData.startTime = block.timestamp.safeCastTo48();\n    auctionData.endTime = (block.timestamp + auctionWindow).safeCastTo48();\n    auctionData.startAmount = stack[0]\n      .lien\n      .details\n      .liquidationInitialAsk\n      .safeCastTo88();\n    auctionData.endAmount = uint88(1000 wei);\n    s.COLLATERAL_TOKEN.getClearingHouse(collateralId).setAuctionData(\n      auctionData\n    );\n  }\n\n  function tokenURI(uint256 tokenId)\n    public\n    view\n    override(ERC721, IERC721)\n    returns (string memory)\n  {\n    if (!_exists(tokenId)) {\n      revert InvalidTokenId(tokenId);\n    }\n    return \"\";\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 id\n  ) public override(ERC721, IERC721) {\n    LienStorage storage s = _loadLienStorageSlot();\n    if (_isPublicVault(s, to)) {\n      revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);\n    }\n    if (s.lienMeta[id].atLiquidation) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    delete s.lienMeta[id].payee;\n    emit PayeeChanged(id, address(0));\n    super.transferFrom(from, to, id);\n  }\n\n  function ASTARIA_ROUTER() public view returns (IAstariaRouter) {\n    return _loadLienStorageSlot().ASTARIA_ROUTER;\n  }\n\n  function COLLATERAL_TOKEN() public view returns (ICollateralToken) {\n    return _loadLienStorageSlot().COLLATERAL_TOKEN;\n  }\n\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    return _loadERC721Slot()._ownerOf[tokenId] != address(0);\n  }\n\n  function createLien(ILienToken.LienActionEncumber memory params)\n    external\n    requiresAuth\n    validateStack(params.lien.collateralId, params.stack)\n    returns (\n      uint256 lienId,\n      Stack[] memory newStack,\n      uint256 lienSlope\n    )\n  {\n    LienStorage storage s = _loadLienStorageSlot();\n    //0 - 4 are valid\n    Stack memory newStackSlot;\n    (lienId, newStackSlot) = _createLien(s, params);\n\n    newStack = _appendStack(s, params.stack, newStackSlot);\n    s.collateralStateHash[params.lien.collateralId] = keccak256(\n      abi.encode(newStack)\n    );\n\n    lienSlope = calculateSlope(newStackSlot);\n    emit AddLien(\n      params.lien.collateralId,\n      uint8(params.stack.length),\n      lienId,\n      newStackSlot\n    );\n    emit LienStackUpdated(\n      params.lien.collateralId,\n      uint8(params.stack.length),\n      StackAction.ADD,\n      uint8(newStack.length)\n    );\n  }\n\n  function _createLien(\n    LienStorage storage s,\n    ILienToken.LienActionEncumber memory params\n  ) internal returns (uint256 newLienId, ILienToken.Stack memory newSlot) {\n    if (s.collateralStateHash[params.lien.collateralId] == ACTIVE_AUCTION) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    if (\n      params.lien.details.liquidationInitialAsk < params.amount ||\n      params.lien.details.liquidationInitialAsk == 0\n    ) {\n      revert InvalidState(InvalidStates.INVALID_LIQUIDATION_INITIAL_ASK);\n    }\n\n    if (params.stack.length > 0) {\n      if (params.lien.collateralId != params.stack[0].lien.collateralId) {\n        revert InvalidState(InvalidStates.COLLATERAL_MISMATCH);\n      }\n\n      if (params.lien.token != params.stack[0].lien.token) {\n        revert InvalidState(InvalidStates.ASSET_MISMATCH);\n      }\n    }\n\n    newLienId = uint256(keccak256(abi.encode(params.lien)));\n    Point memory point = Point({\n      lienId: newLienId,\n      amount: params.amount.safeCastTo88(),\n      last: block.timestamp.safeCastTo40(),\n      end: (block.timestamp + params.lien.details.duration).safeCastTo40()\n    });\n    _mint(params.receiver, newLienId);\n    return (newLienId, Stack({lien: params.lien, point: point}));\n  }\n\n  function _appendStack(\n    LienStorage storage s,\n    Stack[] memory stack,\n    Stack memory newSlot\n  ) internal returns (Stack[] memory newStack) {\n    if (stack.length >= s.maxLiens) {\n      revert InvalidState(InvalidStates.MAX_LIENS);\n    }\n\n    newStack = new Stack[](stack.length + 1);\n    newStack[stack.length] = newSlot;\n\n    uint256 potentialDebt = _getOwed(newSlot, newSlot.point.end);\n    for (uint256 i = stack.length; i > 0; ) {\n      uint256 j = i - 1;\n      newStack[j] = stack[j];\n      if (block.timestamp >= newStack[j].point.end) {\n        revert InvalidState(InvalidStates.EXPIRED_LIEN);\n      }\n\n      unchecked {\n        potentialDebt += _getOwed(newStack[j], newStack[j].point.end);\n      }\n      if (potentialDebt > newStack[j].lien.details.liquidationInitialAsk) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\n      unchecked {\n        --i;\n      }\n    }\n    if (\n      stack.length > 0 && potentialDebt > newSlot.lien.details.maxPotentialDebt\n    ) {\n      revert InvalidState(InvalidStates.DEBT_LIMIT);\n    }\n  }\n\n  function payDebtViaClearingHouse(\n    address token,\n    uint256 collateralId,\n    uint256 payment,\n    AuctionStack[] memory auctionStack\n  ) external {\n    LienStorage storage s = _loadLienStorageSlot();\n    require(\n      msg.sender == address(s.COLLATERAL_TOKEN.getClearingHouse(collateralId))\n    );\n\n    _payDebt(s, token, payment, msg.sender, auctionStack);\n    delete s.collateralStateHash[collateralId];\n  }\n\n  function _payDebt(\n    LienStorage storage s,\n    address token,\n    uint256 payment,\n    address payer,\n    AuctionStack[] memory stack\n  ) internal returns (uint256 totalSpent) {\n    uint256 i;\n    for (; i < stack.length;) {\n      uint256 spent;\n      unchecked {\n        spent = _paymentAH(s, token, stack, i, payment, payer);\n        totalSpent += spent;\n        payment -= spent;\n        ++i;\n      }\n    }\n  }\n\n  function getAuctionData(uint256 collateralId)\n    external\n    view\n    returns (AuctionData memory)\n  {\n    return _loadLienStorageSlot().auctionData[collateralId];\n  }\n\n  function getAuctionLiquidator(uint256 collateralId)\n    external\n    view\n    returns (address liquidator)\n  {\n    liquidator = _loadLienStorageSlot().auctionData[collateralId].liquidator;\n    if (liquidator == address(0)) {\n      revert InvalidState(InvalidStates.COLLATERAL_NOT_LIQUIDATED);\n    }\n  }\n\n  function getAmountOwingAtLiquidation(ILienToken.Stack calldata stack)\n    public\n    view\n    returns (uint256)\n  {\n    return\n      _loadLienStorageSlot()\n        .auctionData[stack.lien.collateralId]\n        .stack[stack.point.lienId]\n        .amountOwed;\n  }\n\n  function validateLien(Lien memory lien) public view returns (uint256 lienId) {\n    lienId = uint256(keccak256(abi.encode(lien)));\n    if (!_exists(lienId)) {\n      revert InvalidState(InvalidStates.INVALID_LIEN_ID);\n    }\n  }\n\n  function getCollateralState(uint256 collateralId)\n    external\n    view\n    returns (bytes32)\n  {\n    return _loadLienStorageSlot().collateralStateHash[collateralId];\n  }\n\n  function getBuyout(Stack calldata stack)\n    public\n    view\n    returns (uint256 owed, uint256 buyout)\n  {\n    return _getBuyout(_loadLienStorageSlot(), stack);\n  }\n\n  function _getBuyout(LienStorage storage s, Stack calldata stack)\n    internal\n    view\n    returns (uint256 owed, uint256 buyout)\n  {\n    owed = _getOwed(stack, block.timestamp);\n    buyout =\n      owed +\n      s.ASTARIA_ROUTER.getBuyoutFee(_getRemainingInterest(s, stack));\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    Stack[] calldata stack,\n    uint256 amount\n  )\n    public\n    validateStack(collateralId, stack)\n    returns (Stack[] memory newStack)\n  {\n    return _makePayment(_loadLienStorageSlot(), stack, amount);\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    Stack[] calldata stack,\n    uint8 position,\n    uint256 amount\n  )\n    external\n    validateStack(collateralId, stack)\n    returns (Stack[] memory newStack)\n  {\n    LienStorage storage s = _loadLienStorageSlot();\n    (newStack, ) = _payment(s, stack, position, amount, msg.sender);\n    _updateCollateralStateHash(s, collateralId, newStack);\n  }\n\n  function _paymentAH(\n    LienStorage storage s,\n    address token,\n    AuctionStack[] memory stack,\n    uint256 position,\n    uint256 payment,\n    address payer\n  ) internal returns (uint256) {\n    uint256 lienId"
    }
  ]
}