{
  "Title": "Block header incorrect input",
  "Content": "##### Description\nIn the function for extracting data from block header tx can fail without any information in case of incorrect input:\nhttps://github.com/lidofinance/curve-merkle-oracle/blob/ae093b308999a564ed3f23d52c6c5dce946dbfa7/contracts/StateProofVerifier.sol#L65\n\n##### Recommendation\nWe recommend to add following check:\n```solidity=\nrequire(headerFields.length > 11, \"INCORRECT_HEADER\");\n```\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/StateProofVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport {RLPReader} from \"hamdiallam/Solidity-RLP@2.0.4/contracts/RLPReader.sol\";\nimport {MerklePatriciaProofVerifier} from \"./MerklePatriciaProofVerifier.sol\";\n\n\n/**\n * @title A helper library for verification of Merkle Patricia account and state proofs.\n */\nlibrary StateProofVerifier {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    uint256 constant HEADER_STATE_ROOT_INDEX = 3;\n    uint256 constant HEADER_NUMBER_INDEX = 8;\n    uint256 constant HEADER_TIMESTAMP_INDEX = 11;\n\n    struct BlockHeader {\n        bytes32 hash;\n        bytes32 stateRootHash;\n        uint256 number;\n        uint256 timestamp;\n    }\n\n    struct Account {\n        bool exists;\n        uint256 nonce;\n        uint256 balance;\n        bytes32 storageRoot;\n        bytes32 codeHash;\n    }\n\n    struct SlotValue {\n        bool exists;\n        uint256 value;\n    }\n\n\n    /**\n     * @notice Parses block header and verifies its presence onchain within the latest 256 blocks.\n     * @param _headerRlpBytes RLP-encoded block header.\n     */\n    function verifyBlockHeader(bytes memory _headerRlpBytes)\n        internal view returns (BlockHeader memory)\n    {\n        BlockHeader memory header = parseBlockHeader(_headerRlpBytes);\n        // ensure that the block is actually in the blockchain\n        require(header.hash == blockhash(header.number), \"blockhash mismatch\");\n        return header;\n    }\n\n\n    /**\n     * @notice Parses RLP-encoded block header.\n     * @param _headerRlpBytes RLP-encoded block header.\n     */\n    function parseBlockHeader(bytes memory _headerRlpBytes)\n        internal pure returns (BlockHeader memory)\n    {\n        BlockHeader memory result;\n        RLPReader.RLPItem[] memory headerFields = _headerRlpBytes.toRlpItem().toList();\n\n        result.stateRootHash = bytes32(headerFields[HEADER_STATE_ROOT_INDEX].toUint());\n        result.number = headerFields[HEADER_NUMBER_INDEX].toUint();\n        result.timestamp = headerFields[HEADER_TIMESTAMP_INDEX].toUint();\n        result.hash = keccak256(_headerRlpBytes);\n\n        return result;\n    }\n\n\n    /**\n     * @notice Verifies Merkle Patricia proof of an account and extracts the account fields.\n     *\n     * @param _addressHash Keccak256 hash of the address corresponding to the account.\n     * @param _stateRootHash MPT root hash of the Ethereum state trie.\n     */\n    function extractAccountFromProof(\n        bytes32 _addressHash, // keccak256(abi.encodePacked(address))\n        bytes32 _stateRootHash,\n        RLPReader.RLPItem[] memory _proof\n    )\n        internal pure returns (Account memory)\n    {\n        bytes memory acctRlpBytes = MerklePatriciaProofVerifier.extractProofValue(\n            _stateRootHash,\n            abi.encodePacked(_addressHash),\n            _proof\n        );\n\n        Account memory account;\n\n        if (acctRlpBytes.length == 0) {\n            return account;\n        }\n\n        RLPReader.RLPItem[] memory acctFields = acctRlpBytes.toRlpItem().toList();\n        require(acctFields.length == 4);\n\n        account.exists = true;\n        account.nonce = acctFields[0].toUint();\n        account.balance = acctFields[1].toUint();\n        account.storageRoot = bytes32(acctFields[2].toUint());\n        account.codeHash = bytes32(acctFields[3].toUint());\n\n        return account;\n    }\n\n\n    /**\n     * @notice Verifies Merkle Patricia proof of a slot and extracts the slot's value.\n     *\n     * @param _slotHash Keccak256 hash of the slot position.\n     * @param _storageRootHash MPT root hash of the account's storage trie.\n     */\n    function extractSlotValueFromProof(\n        bytes32 _slotHash,\n        bytes32 _storageRootHash,\n        RLPReader.RLPItem[] memory _proof\n    )\n        internal pure returns (SlotValue memory)\n    {\n        bytes memory valueRlpBytes = MerklePatriciaProofVerifier.extractProofValue(\n            _storageRootHash,\n            abi.encodePacked(_slotHash),\n            _proof\n        );\n\n        SlotValue memory value;\n\n        if (valueRlpBytes.length != 0) {\n            value.exists = true;\n            value.value = valueRlpBytes.toRlpItem().toUint();\n        }\n\n        return value;\n    }\n\n}"
    }
  ]
}