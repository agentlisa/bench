{
  "Title": "M-1: User Can Vote Even When They Have 0 Locked Mento (Edge Case)",
  "Content": "# Issue M-1: User Can Vote Even When They Have 0 Locked Mento (Edge Case) \n\nSource: https://github.com/sherlock-audit/2024-02-mento-judging/issues/14 \n\n## Found by \nComposableSecurity, HHK, Kose, ParthMandale, sakshamguruji, slylandro, y4y\n## Summary\n\nThere exists an edge case where the user will be withdrawing his entire locked MENTO amount and even then will be able to vote , this is depicted by a PoC to make things clearer.\n\n## Vulnerability Detail\n\nThe flow to receiving voting power can be understood in simple terms as follows ->\n\nUsers locks his MENTO and chooses a delegate-> received veMENTO which gives them(delegatee) voting power (there's cliff and slope at play too)\n\nThe veMENTO is not a standard ERC20 , it is depicted through \"lines\" , voting power declines ( ie. slope period) with time\nand with time you can withdraw more of your MENTO.\n\nThe edge case where the user will be withdrawing his entire locked MENTO amount and even then will be able\nto vote is as follows ->\n\n1.) User has locked his MENTO balance in the Locking.sol\n\n2.) The owner of the contract \"stops\" the contract for some emergency reason.\n\n3.) In this stopped state the user calls withdraw() which calls getAvailableForWithdraw() here https://github.com/sherlock-audit/2024-02-mento/blob/main/mento-core/contracts/governance/locking/Locking.sol#L97\n\n4.) Since the contract is stopped , the `getAvailableForWithdraw` will return the entire locked amount of the user as withdrawable \n\n```solidity\nfunction getAvailableForWithdraw(address account) public view returns (uint96) {\n    uint96 value = accounts[account].amount;\n    if (!stopped) {\n      uint32 currentBlock = getBlockNumber();\n      uint32 time = roundTimestamp(currentBlock);\n      uint96 bias = accounts[account].locked.actualValue(time, currentBlock);\n      value = value - (bias);\n    }\n    return value;\n ```\n \n 5.) The user receives his entire locked amount in L101.\n \n 6.) The owner \"start()\" the contract again \n \n 7.) Since the user's veMENTO power was not effected by the above flow , there still exists veMENTO a.k.a voting power to the delegate,\n and the user's delegate is still able to vote on proposals (even when the user has withdrew everything).\n \n POC\n \n Import console log first in the file , paste this test in the `GovernanceIntegration.t.sol`\n \n ```solidity\n function test_Poc_Stop() public {\n\n    vm.prank(governanceTimelockAddress);\n    mentoToken.transfer(alice, 10_000e18);\n\n    vm.prank(governanceTimelockAddress);\n    mentoToken.transfer(bob, 10_000e18);\n\n    vm.prank(alice);\n    locking.lock(alice, alice, 10_000e18, 1, 103);\n\n    vm.prank(bob);\n    locking.lock(bob, bob, 1500e18, 1, 103);\n\n    vm.timeTravel(BLOCKS_DAY);\n\n    uint256 newVotingDelay = BLOCKS_DAY;\n    uint256 newVotingPeriod = 2 * BLOCKS_WEEK;\n    uint256 newThreshold = 5000e18;\n    uint256 newQuorum = 10; //10%\n    uint256 newMinDelay = 3 days;\n    uint32 newMinCliff = 6;\n    uint32 newMinSlope = 12;\n\n    vm.prank(alice);\n    (\n      uint256 proposalId,\n      address[] memory targets,\n      uint256[] memory values,\n      bytes[] memory calldatas,\n      string memory description\n    ) = Proposals._proposeChangeSettings(\n        mentoGovernor,\n        governanceTimelock,\n        locking,\n        newVotingDelay,\n        newVotingPeriod,\n        newThreshold,\n        newQuorum,\n        newMinDelay,\n        newMinCliff,\n        newMinSlope\n      );\n\n    // ~10 mins\n    vm.timeTravel(120);\n\n    \n\n    vm.startPrank(governanceTimelockAddress);\n    locking.stop();\n    vm.stopPrank();\n\n    uint bal2 = mentoToken.balanceOf(alice);\n    console.log(bal2);\n\n    vm.startPrank(alice);\n    locking.withdraw();\n    vm.stopPrank();\n\n    vm.startPrank(governanceTimelockAddress);\n    locking.start();\n    vm.stopPrank();\n\n    uint bal = mentoToken.balanceOf(alice);\n    console.log(bal);\n    vm.prank(alice);\n    \n\n    console.log(mentoGovernor.castVote(proposalId, 1));\n  }\n  ```\n \n You can see the Alice withdrew her entire locked amount and still was able to caste her vote.\n\n\n## Impact\n\n User still able to vote even when the entire locked amount is withdrawn.\n\n## Code Snippet\n\n https://github.com/sherlock-audit/2024-02-mento/blob/main/mento-core/contracts/governance/locking/Locking.sol#L111-L119\n\n## Tool used\n\nFoundry\n\n## Recommendation\n\n When the entire amount is withdrawn adjust the logic to remove the corresponding lines for the delegator.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nValid medium, users retain vote in an edge case scenario then holds when owners stops (pause) contract\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/187",
  "Code": [
    {
      "filename": "mento-core/contracts/governance/locking/Locking.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n// solhint-disable func-name-mixedcase\n\nimport \"./LockingBase.sol\";\nimport \"./LockingRelock.sol\";\nimport \"./LockingVotes.sol\";\nimport \"./interfaces/ILocking.sol\";\n\n/**\n * @title Locking\n * @notice Implements locking mechanism for tokens to enable voting power accumulation\n * @notice https://github.com/rarible/locking-contracts/tree/4f189a96b3e85602dedfbaf69d9a1f5056d835eb\n */\ncontract Locking is ILocking, LockingBase, LockingRelock, LockingVotes {\n  using LibBrokenLine for LibBrokenLine.BrokenLine;\n\n  /**\n   * @notice Initializes the locking contract.\n   * @dev Sets up the base locking parameters and initializes ownership and context setup\n   * @param _token Address of the ERC20 that will be locked. (Mento Token)\n   * @param _startingPointWeek Origin week number for the week-based time system\n   * @param _minCliffPeriod Minimum cliff period for locks\n   * @param _minSlopePeriod Minimum slope period for locks\n   */\n  function __Locking_init(\n    IERC20Upgradeable _token,\n    uint32 _startingPointWeek,\n    uint32 _minCliffPeriod,\n    uint32 _minSlopePeriod\n  ) external initializer {\n    __LockingBase_init_unchained(_token, _startingPointWeek, _minCliffPeriod, _minSlopePeriod);\n    __Ownable_init_unchained();\n    __Context_init_unchained();\n  }\n\n  /**\n   * @notice Stops the locking functionality\n   * @dev Can only be called by the owner while locking is active (meaning not stopped)\n   */\n  function stop() external onlyOwner notStopped {\n    stopped = true;\n    emit StopLocking(msg.sender);\n  }\n\n  /**\n   * @notice Restarts the locking functionality after it has been stopped\n   * @dev Can only be called by the owner while locking is stopped\n   */\n  function start() external onlyOwner isStopped {\n    stopped = false;\n    emit StartLocking(msg.sender);\n  }\n\n  /**\n   * @notice Locks a specified amount of tokens for a given period\n   * @dev Can not be called when locking is stopped\n   * @dev Delegate is not optional, it can be set to the lock owner if no delegate is desired\n   * @param account Account for which tokens are being locked\n   * @param _delegate Address that will receive the voting power from the locked tokens\n   * @param amount Amount of tokens to lock\n   * @param slopePeriod Period over which the tokens will unlock\n   * @param cliff Initial period during which tokens remain locked and do not start unlocking\n   * @return Id for the created lock\n   */\n  function lock(\n    address account,\n    address _delegate,\n    uint96 amount,\n    uint32 slopePeriod,\n    uint32 cliff\n  ) external override notStopped returns (uint256) {\n    require(amount > 0, \"zero amount\");\n    require(cliff <= MAX_CLIFF_PERIOD, \"cliff too big\");\n    require(slopePeriod <= MAX_SLOPE_PERIOD, \"period too big\");\n    require(account != address(0), \"account is zero\");\n    require(_delegate != address(0), \"delegate is zero\");\n\n    counter++;\n\n    uint32 currentBlock = getBlockNumber();\n    uint32 time = roundTimestamp(currentBlock);\n    addLines(account, _delegate, amount, slopePeriod, cliff, time, currentBlock);\n    accounts[account].amount = accounts[account].amount + (amount);\n\n    // slither-disable-next-line reentrancy-events\n    require(token.transferFrom(msg.sender, address(this), amount), \"transfer failed\");\n\n    emit LockCreate(counter, account, _delegate, time, amount, slopePeriod, cliff);\n    return counter;\n  }\n\n  /**\n   * @notice Withdraws unlocked tokens for the caller\n   */\n  function withdraw() external {\n    uint96 value = getAvailableForWithdraw(msg.sender);\n    if (value > 0) {\n      accounts[msg.sender].amount = accounts[msg.sender].amount - (value);\n      // slither-disable-next-line reentrancy-events\n      require(token.transfer(msg.sender, value), \"transfer failed\");\n    }\n    emit Withdraw(msg.sender, value);\n  }\n\n  /**\n   * @notice Calculates the amount available for withdrawal by an account\n   * @param account The account to check the withdrawable amount for\n   * @return The amount of tokens available for withdrawal\n   */\n  function getAvailableForWithdraw(address account) public view returns (uint96) {\n    uint96 value = accounts[account].amount;\n    if (!stopped) {\n      uint32 currentBlock = getBlockNumber();\n      uint32 time = roundTimestamp(currentBlock);\n      uint96 bias = accounts[account].locked.actualValue(time, currentBlock);\n      value = value - (bias);\n    }\n    return value;\n  }\n\n  /**\n   * @notice Returns the total amount of tokens locked for an account\n   * @param account The account to check locked amount for\n   * @return The locked amount for the account\n   */\n  function locked(address account) external view returns (uint256) {\n    return accounts[account].amount;\n  }\n\n  /**\n   * @notice Retrieves the account and delegate associated with a given lock ID\n   * @param id The id of the lock\n   * @return _account The account that owns the lock\n   * @return _delegate The account that owns the voting power\n   */\n  function getAccountAndDelegate(uint256 id) external view returns (address _account, address _delegate) {\n    _account = locks[id].account;\n    _delegate = locks[id].delegate;\n  }\n\n  /**\n   * @notice Returns \"current week\" of the contract. The Locking contract works with a week-based time system\n   * for managing locks and voting power. The current week number is calculated based on the number of weeks passed\n   * since the starting point week. The starting point is set during the contract initialization.\n   */\n  function getWeek() external view returns (uint256) {\n    return roundTimestamp(getBlockNumber());\n  }\n\n  /**\n   * @notice Changes the delegate for a specific lock\n   * @dev Updates the delegation and adjusts the voting power accordingly\n   * @param id The unique identifier for the lock whose delegate is to be changed\n   * @param newDelegate The address to which the delegation will be transferred\n   */\n  function delegateTo(uint256 id, address newDelegate) external notStopped {\n    require(newDelegate != address(0), \"delegate is zero\");\n\n    address account = verifyLockOwner(id);\n    address _delegate = locks[id].delegate;\n    uint32 currentBlock = getBlockNumber();\n    uint32 time = roundTimestamp(currentBlock);\n    accounts[_delegate].balance.update(time);\n    (uint96 bias, uint96 slope, uint32 cliff) = accounts[_delegate].balance.remove(id, time, currentBlock);\n    LibBrokenLine.Line memory line = LibBrokenLine.Line(time, bias, slope, cliff);\n    accounts[newDelegate].balance.update(time);\n    accounts[newDelegate].balance.addOneLine(id, line, currentBlock);\n    locks[id].delegate = newDelegate;\n    emit Delegate(id, account, newDelegate, time);\n  }\n\n  /**\n   * @notice Returns the current total supply of veMENTO tokens\n   * @return The total supply of veMENTO tokens\n   */\n  function totalSupply() external view returns (uint256) {\n    if ((totalSupplyLine.initial.bias == 0) || (stopped)) {\n      return 0;\n    }\n    uint32 currentBlock = getBlockNumber();\n    uint32 time = roundTimestamp(currentBlock);\n    return totalSupplyLine.actualValue(time, currentBlock);\n  }\n\n  /**\n   * @notice Retrieves the veMENTO balance of an account\n   * @param account The account to check the balance for\n   * @return The accounts balance of veMENTO tokens\n   */\n  function balanceOf(address account) external view returns (uint256) {\n    if ((accounts[account].balance.initial.bias == 0) || (stopped)) {\n      return 0;\n    }\n    uint32 currentBlock = getBlockNumber();\n    uint32 time = roundTimestamp(currentBlock);\n    return accounts[account].balance.actualValue(time, currentBlock);\n  }\n\n  /**\n   * @notice Returns the name of the token\n   */\n  function name() public view virtual returns (string memory) {\n    return \"Mento Vote-Escrow\";\n  }\n\n  /**\n   * @notice Returns the symbol of the token\n   */\n  function symbol() public view virtual returns (string memory) {\n    return \"veMENTO\";\n  }\n\n  /**\n   * @notice Returns the decimal points of the token\n   */\n  function decimals() public view virtual returns (uint8) {\n    return 18;\n  }\n\n  uint256[50] private __gap;\n}"
    },
    {
      "filename": "mento-core/contracts/governance/locking/Locking.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n// solhint-disable func-name-mixedcase\n\nimport \"./LockingBase.sol\";\nimport \"./LockingRelock.sol\";\nimport \"./LockingVotes.sol\";\nimport \"./interfaces/ILocking.sol\";\n\n/**\n * @title Locking\n * @notice Implements locking mechanism for tokens to enable voting power accumulation\n * @notice https://github.com/rarible/locking-contracts/tree/4f189a96b3e85602dedfbaf69d9a1f5056d835eb\n */\ncontract Locking is ILocking, LockingBase, LockingRelock, LockingVotes {\n  using LibBrokenLine for LibBrokenLine.BrokenLine;\n\n  /**\n   * @notice Initializes the locking contract.\n   * @dev Sets up the base locking parameters and initializes ownership and context setup\n   * @param _token Address of the ERC20 that will be locked. (Mento Token)\n   * @param _startingPointWeek Origin week number for the week-based time system\n   * @param _minCliffPeriod Minimum cliff period for locks\n   * @param _minSlopePeriod Minimum slope period for locks\n   */\n  function __Locking_init(\n    IERC20Upgradeable _token,\n    uint32 _startingPointWeek,\n    uint32 _minCliffPeriod,\n    uint32 _minSlopePeriod\n  ) external initializer {\n    __LockingBase_init_unchained(_token, _startingPointWeek, _minCliffPeriod, _minSlopePeriod);\n    __Ownable_init_unchained();\n    __Context_init_unchained();\n  }\n\n  /**\n   * @notice Stops the locking functionality\n   * @dev Can only be called by the owner while locking is active (meaning not stopped)\n   */\n  function stop() external onlyOwner notStopped {\n    stopped = true;\n    emit StopLocking(msg.sender);\n  }\n\n  /**\n   * @notice Restarts the locking functionality after it has been stopped\n   * @dev Can only be called by the owner while locking is stopped\n   */\n  function start() external onlyOwner isStopped {\n    stopped = false;\n    emit StartLocking(msg.sender);\n  }\n\n  /**\n   * @notice Locks a specified amount of tokens for a given period\n   * @dev Can not be called when locking is stopped\n   * @dev Delegate is not optional, it can be set to the lock owner if no delegate is desired\n   * @param account Account for which tokens are being locked\n   * @param _delegate Address that will receive the voting power from the locked tokens\n   * @param amount Amount of tokens to lock\n   * @param slopePeriod Period over which the tokens will unlock\n   * @param cliff Initial period during which tokens remain locked and do not start unlocking\n   * @return Id for the created lock\n   */\n  function lock(\n    address account,\n    address _delegate,\n    uint96 amount,\n    uint32 slopePeriod,\n    uint32 cliff\n  ) external override notStopped returns (uint256) {\n    require(amount > 0, \"zero amount\");\n    require(cliff <= MAX_CLIFF_PERIOD, \"cliff too big\");\n    require(slopePeriod <= MAX_SLOPE_PERIOD, \"period too big\");\n    require(account != address(0), \"account is zero\");\n    require(_delegate != address(0), \"delegate is zero\");\n\n    counter++;\n\n    uint32 currentBlock = getBlockNumber();\n    uint32 time = roundTimestamp(currentBlock);\n    addLines(account, _delegate, amount, slopePeriod, cliff, time, currentBlock);\n    accounts[account].amount = accounts[account].amount + (amount);\n\n    // slither-disable-next-line reentrancy-events\n    require(token.transferFrom(msg.sender, address(this), amount), \"transfer failed\");\n\n    emit LockCreate(counter, account, _delegate, time, amount, slopePeriod, cliff);\n    return counter;\n  }\n\n  /**\n   * @notice Withdraws unlocked tokens for the caller\n   */\n  function withdraw() external {\n    uint96 value = getAvailableForWithdraw(msg.sender);\n    if (value > 0) {\n      accounts[msg.sender].amount = accounts[msg.sender].amount - (value);\n      // slither-disable-next-line reentrancy-events\n      require(token.transfer(msg.sender, value), \"transfer failed\");\n    }\n    emit Withdraw(msg.sender, value);\n  }\n\n  /**\n   * @notice Calculates the amount available for withdrawal by an account\n   * @param account The account to check the withdrawable amount for\n   * @return The amount of tokens available for withdrawal\n   */\n  function getAvailableForWithdraw(address account) public view returns (uint96) {\n    uint96 value = accounts[account].amount;\n    if (!stopped) {\n      uint32 currentBlock = getBlockNumber();\n      uint32 time = roundTimestamp(currentBlock);\n      uint96 bias = accounts[account].locked.actualValue(time, currentBlock);\n      value = value - (bias);\n    }\n    return value;\n  }\n\n  /**\n   * @notice Returns the total amount of tokens locked for an account\n   * @param account The account to check locked amount for\n   * @return The locked amount for the account\n   */\n  function locked(address account) external view returns (uint256) {\n    return accounts[account].amount;\n  }\n\n  /**\n   * @notice Retrieves the account and delegate associated with a given lock ID\n   * @param id The id of the lock\n   * @return _account The account that owns the lock\n   * @return _delegate The account that owns the voting power\n   */\n  function getAccountAndDelegate(uint256 id) external view returns (address _account, address _delegate) {\n    _account = locks[id].account;\n    _delegate = locks[id].delegate;\n  }\n\n  /**\n   * @notice Returns \"current week\" of the contract. The Locking contract works with a week-based time system\n   * for managing locks and voting power. The current week number is calculated based on the number of weeks passed\n   * since the starting point week. The starting point is set during the contract initialization.\n   */\n  function getWeek() external view returns (uint256) {\n    return roundTimestamp(getBlockNumber());\n  }\n\n  /**\n   * @notice Changes the delegate for a specific lock\n   * @dev Updates the delegation and adjusts the voting power accordingly\n   * @param id The unique identifier for the lock whose delegate is to be changed\n   * @param newDelegate The address to which the delegation will be transferred\n   */\n  function delegateTo(uint256 id, address newDelegate) external notStopped {\n    require(newDelegate != address(0), \"delegate is zero\");\n\n    address account = verifyLockOwner(id);\n    address _delegate = locks[id].delegate;\n    uint32 currentBlock = getBlockNumber();\n    uint32 time = roundTimestamp(currentBlock);\n    accounts[_delegate].balance.update(time);\n    (uint96 bias, uint96 slope, uint32 cliff) = accounts[_delegate].balance.remove(id, time, currentBlock);\n    LibBrokenLine.Line memory line = LibBrokenLine.Line(time, bias, slope, cliff);\n    accounts[newDelegate].balance.update(time);\n    accounts[newDelegate].balance.addOneLine(id, line, currentBlock);\n    locks[id].delegate = newDelegate;\n    emit Delegate(id, account, newDelegate, time);\n  }\n\n  /**\n   * @notice Returns the current total supply of veMENTO tokens\n   * @return The total supply of veMENTO tokens\n   */\n  function totalSupply() external view returns (uint256) {\n    if ((totalSupplyLine.initial.bias == 0) || (stopped)) {\n      return 0;\n    }\n    uint32 currentBlock = getBlockNumber();\n    uint32 time = roundTimestamp(currentBlock);\n    return totalSupplyLine.actualValue(time, currentBlock);\n  }\n\n  /**\n   * @notice Retrieves the veMENTO balance of an account\n   * @param account The account to check the balance for\n   * @return The accounts balance of veMENTO tokens\n   */\n  function balanceOf(address account) external view returns (uint256) {\n    if ((accounts[account].balance.initial.bias == 0) || (stopped)) {\n      return 0;\n    }\n    uint32 currentBlock = getBlockNumber();\n    uint32 time = roundTimestamp(currentBlock);\n    return accounts[account].balance.actualValue(time, currentBlock);\n  }\n\n  /**\n   * @notice Returns the name of the token\n   */\n  function name() public view virtual returns (string memory) {\n    return \"Mento Vote-Escrow\";\n  }\n\n  /**\n   * @notice Returns the symbol of the token\n   */\n  function symbol() public view virtual returns (string memory) {\n    return \"veMENTO\";\n  }\n\n  /**\n   * @notice Returns the decimal points of the token\n   */\n  function decimals() public view virtual returns (uint8) {\n    return 18;\n  }\n\n  uint256[50] private __gap;\n}"
    }
  ]
}