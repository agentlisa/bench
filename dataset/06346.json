{
  "Title": "[G-03] Redundant checks can be omitted",
  "Content": "\nIn the `Swapper.swapExactOutputWithPermit()` function performs a check to verify that the `amountIn` is less than the `amountInMax` amount as follows:\n\n        if (amountIn > amountInMax) revert TooBigAmountIn(); \n\nBut this is a redundant check since the same check is performed as shown below, in the `SignatureTransfer.sol` contract which is a parent contract of `Permit2.sol` contract. This is called inside the `Swapper._swap()` function.\n\n        if (requestedAmount > permit.permitted.amount) revert InvalidAmount(permit.permitted.amount);\n\nHence the redundant call inside the `Swapper.swapExactOutputWithPermit()` function can be omitted to save gas.\n\nhttps://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Swapper.sol#L139\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-01-dev-test-repo",
  "Code": [
    {
      "filename": "contracts/transmuter/facets/Swapper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { Address } from \"oz/utils/Address.sol\";\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"oz/utils/math/Math.sol\";\nimport { SafeCast } from \"oz/utils/math/SafeCast.sol\";\n\nimport { IAgToken } from \"interfaces/IAgToken.sol\";\nimport { ISwapper } from \"interfaces/ISwapper.sol\";\nimport { IPermit2, PermitTransferFrom } from \"interfaces/external/permit2/IPermit2.sol\";\nimport { SignatureTransferDetails, TokenPermissions } from \"interfaces/external/permit2/IPermit2.sol\";\n\nimport { LibHelpers } from \"../libraries/LibHelpers.sol\";\nimport { LibManager } from \"../libraries/LibManager.sol\";\nimport { LibOracle } from \"../libraries/LibOracle.sol\";\nimport { LibStorage as s } from \"../libraries/LibStorage.sol\";\nimport { LibWhitelist } from \"../libraries/LibWhitelist.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n// Struct to help storing local variables to avoid stack too deep issues\nstruct LocalVariables {\n    bool isMint;\n    bool isExact;\n    uint256 lowerExposure;\n    uint256 upperExposure;\n    int256 lowerFees;\n    int256 upperFees;\n    uint256 amountToNextBreakPoint;\n    uint256 stablecoinsIssued;\n    uint256 otherStablecoinSupply;\n}\n\n/// @title Swapper\n/// @author Angle Labs, Inc.\n/// @dev In all the functions of this contract, one of `tokenIn` or `tokenOut` must be the stablecoin, and\n/// one of `tokenOut` or `tokenIn` must be an accepted collateral. Depending on the `tokenIn` or `tokenOut` given,\n/// the functions will either handle a mint or a burn operation\n/// @dev In case of a burn, they will also revert if the system does not have enough of `amountOut` for `tokenOut`.\n/// This balance must be available either directly on the contract or, when applicable, through the underlying\n/// strategies that manage the collateral\n/// @dev Functions here may be paused for some collateral assets (for either mint or burn), in which case they'll revert\n/// @dev In case of a burn again, the swap functions will revert if the call concerns a collateral that requires a\n/// whitelist but the `to` address does not have it. The quote functions will not revert in this case.\n/// @dev Calling one of the swap functions in a burn case does not require any prior token approval\ncontract Swapper is ISwapper {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using Address for address;\n    using Math for uint256;\n\n    // The `to` address is not indexed as there cannot be 4 indexed addresses in an event.\n    event Swap(\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        address indexed from,\n        address to\n    );\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                               EXTERNAL ACTION FUNCTIONS                                            \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    // For the four functions below, a value of `0` for the `deadline` parameters means that there will be no timestamp\n    // check for when the swap is actually executed.\n\n    /// @inheritdoc ISwapper\n    /// @dev `msg.sender` must have approved this contract for at least `amountIn` for `tokenIn` for mint transactions\n    function swapExactInput(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address tokenIn,\n        address tokenOut,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut) {\n        (bool mint, Collateral storage collatInfo) = _getMintBurn(tokenIn, tokenOut, deadline);\n        amountOut = mint\n            ? _quoteMintExactInput(collatInfo, amountIn)\n            : _quoteBurnExactInput(tokenOut, collatInfo, amountIn);\n        if (amountOut < amountOutMin) revert TooSmallAmountOut();\n        _swap(amountIn, amountOut, tokenIn, tokenOut, to, mint, collatInfo, \"\");\n    }\n\n    /// @inheritdoc ISwapper\n    function swapExactInputWithPermit(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address tokenIn,\n        address to,\n        uint256 deadline,\n        bytes memory permitData\n    ) external returns (uint256 amountOut) {\n        (address tokenOut, Collateral storage collatInfo) = _getMint(tokenIn, deadline);\n        amountOut = _quoteMintExactInput(collatInfo, amountIn);\n        if (amountOut < amountOutMin) revert TooSmallAmountOut();\n        permitData = _buildPermitTransferPayload(amountIn, amountIn, tokenIn, deadline, permitData, collatInfo);\n        _swap(amountIn, amountOut, tokenIn, tokenOut, to, true, collatInfo, permitData);\n    }\n\n    /// @inheritdoc ISwapper\n    /// @dev `msg.sender` must have approved this contract for an amount bigger than what `amountIn` will\n    /// be before calling this function for a mint. Approving the contract for `tokenIn` with `amountInMax`\n    /// will always be enough in this case\n    function swapExactOutput(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address tokenIn,\n        address tokenOut,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountIn) {\n        (bool mint, Collateral storage collatInfo) = _getMintBurn(tokenIn, tokenOut, deadline);\n        amountIn = mint\n            ? _quoteMintExactOutput(collatInfo, amountOut)\n            : _quoteBurnExactOutput(tokenOut, collatInfo, amountOut);\n        if (amountIn > amountInMax) revert TooBigAmountIn();\n        _swap(amountIn, amountOut, tokenIn, tokenOut, to, mint, collatInfo, \"\");\n    }\n\n    /// @inheritdoc ISwapper\n    function swapExactOutputWithPermit(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address tokenIn,\n        address to,\n        uint256 deadline,\n        bytes memory permitData\n    ) public returns (uint256 amountIn) {\n        (address tokenOut, Collateral storage collatInfo) = _getMint(tokenIn, deadline);\n        amountIn = _quoteMintExactOutput(collatInfo, amountOut);\n        if (amountIn > amountInMax) revert TooBigAmountIn();\n        permitData = _buildPermitTransferPayload(amountIn, amountInMax, tokenIn, deadline, permitData, collatInfo);\n        _swap(amountIn, amountOut, tokenIn, tokenOut, to, true, collatInfo, permitData);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                     VIEW HELPERS                                                   \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    // If these functions return a 0 `amountOut` or `amountIn` value, then calling one of the swap functions above\n    // will not do anything.\n\n    /// @inheritdoc ISwapper\n    function quoteIn(uint256 amountIn, address tokenIn, address tokenOut) external view returns (uint256 amountOut) {\n        (bool mint, Collateral storage collatInfo) = _getMintBurn(tokenIn, tokenOut, 0);\n        if (mint) return _quoteMintExactInput(collatInfo, amountIn);\n        else {\n            amountOut = _quoteBurnExactInput(tokenOut, collatInfo, amountIn);\n            _checkAmounts(collatInfo, amountOut);\n        }\n    }\n\n    /// @inheritdoc ISwapper\n    function quoteOut(uint256 amountOut, address tokenIn, address tokenOut) external view returns (uint256 amountIn) {\n        (bool mint, Collateral storage collatInfo) = _getMintBurn(tokenIn, tokenOut, 0);\n        if (mint) return _quoteMintExactOutput(collatInfo, amountOut);\n        else {\n            _checkAmounts(collatInfo, amountOut);\n            return _quoteBurnExactOutput(tokenOut, collatInfo, amountOut);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   INTERNAL ACTIONS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Processes the internal metric updates and the transfers following mint or burn operations\n    function _swap(\n        uint256 amountIn,\n        uint256 amountOut,\n        address tokenIn,\n        address tokenOut,\n        address to,\n        bool mint,\n        Collateral storage collatInfo,\n        bytes memory permitData\n    ) internal {\n        if (amountIn > 0 && amountOut > 0) {\n            TransmuterStorage storage ts = s.transmuterStorage();\n            if (mint) {\n                uint128 changeAmount = (amountOut.mulDiv(BASE_27, ts.normalizer, Math.Rounding.Up)).toUint128();\n                // The amount of stablecoins issued from a collateral are not stored as absolute variables, but\n                // as variables normalized by a `normalizer`\n                collatInfo.normalizedStables += uint216(changeAmount);\n                ts.normalizedStables += changeAmount;\n                if (permitData.length > 0) {\n                    PERMIT_2.functionCall(permitData);\n                } else if (collatInfo.isManaged > 0)\n                    IERC20(tokenIn).safeTransferFrom(\n                        msg.sender,\n                        LibManager.transferRecipient(collatInfo.managerData.config),\n                        amountIn\n                    );\n                else IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n                if (collatInfo.isManaged > 0) {\n                    LibManager.invest(amountIn, collatInfo.managerData.config);\n                }\n                IAgToken(tokenOut).mint(to, amountOut);\n            } else {\n                if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))\n                    revert NotWhitelisted();\n                uint128 changeAmount = ((amountIn * BASE_27) / ts.normalizer).toUint128();\n                // This will underflow when the system is trying to burn more stablecoins than what has been issued\n                // from this collateral\n                collatInfo.normalizedStables -= uint216(changeAmount);\n                ts.normalizedStables -= changeAmount;\n                IAgToken(tokenIn).burnSelf(amountIn, msg.sender);\n                if (collatInfo.isManaged > 0)\n                    LibManager.release(tokenOut, to, amountOut, collatInfo.managerData.config);\n                else IERC20(tokenOut).safeTransfer(to, amountOut);\n            }\n            emit Swap(tokenIn, tokenOut, amountIn, amountOut, msg.sender, to);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                     INTERNAL VIEW                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Computes the `amountOut` of stablecoins to mint from `tokenIn` of a collateral with data `collatInfo`\n    function _quoteMintExactInput(\n        Collateral storage collatInfo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        uint256 oracleValue = LibOracle.readMint(collatInfo.oracleConfig);\n        amountOut = LibHelpers.convertDecimalTo(oracleValue * amountIn, 18 + collatInfo.decimals, 18);\n        amountOut = _quoteFees(collatInfo, QuoteType.MintExactInput, amountOut);\n    }\n\n    /// @notice Computes the `amountIn` of collateral to get during a mint of `amountOut` of stablecoins\n    function _quoteMintExactOutput(\n        Collateral storage collatInfo,\n        uint256 amountOut\n    ) internal view returns (uint256 amountIn) {\n        uint256 oracleValue = LibOracle.readMint(collatInfo.oracleConfig);\n        amountIn = _quoteFees(collatInfo, QuoteType.MintExactOutput, amountOut);\n        amountIn = LibHelpers.convertDecimalTo((amountIn * BASE_18) / oracleValue, 18, collatInfo.decimals);\n    }\n\n    /// @notice Computes the `amountIn` of stablecoins to burn to release `amountOut` of `collateral`\n    function _quoteBurnExactOutput(\n        address collateral,\n        Collateral storage collatInfo,\n        uint256 amountOut\n    ) internal view returns (uint256 amountIn) {\n        (uint256 ratio, uint256 oracleValue) = LibOracle.getBurnOracle(collateral, collatInfo.oracleConfig);\n        amountIn = Math.mulDiv(LibHelpers.convertDecimalTo(amountOut, collatInfo.decimals, 18), oracleValue, ratio);\n        amountIn = _quoteFees(collatInfo, QuoteType.BurnExactOutput, amountIn);\n    }\n\n    /// @notice Computes the `amountOut` of `collateral` to give during a burn operation of `amountIn` of stablecoins\n    function _quoteBurnExactInput(\n        address collateral,\n        Collateral storage collatInfo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        (uint256 ratio, uint256 oracleValue) = LibOracle.getBurnOracle(collateral, collatInfo.oracleConfig);\n        amountOut = _quoteFees(collatInfo, QuoteType.BurnExactInput, amountIn);\n        amountOut = LibHelpers.convertDecimalTo((amountOut * ratio) / oracleValue, 18, collatInfo.decimals);\n    }\n\n    /// @notice Computes the fees to apply during a mint or burn operation\n    /// @dev This function leverages the mathematical computations of the appendix of the Transmuter whitepaper\n    /// @dev Cost of the function is linear in the length of the `xFeeMint` or `xFeeBurn` array\n    function _quoteFees(\n        Collateral storage collatInfo,\n        QuoteType quoteType,\n        uint256 amountStable\n    ) internal view returns (uint256) {\n        LocalVariables memory v;\n        v.isMint = _isMint(quoteType);\n        v.isExact = _isExact(quoteType);\n        uint256 n = v.isMint ? collatInfo.xFeeMint.length : collatInfo.xFeeBurn.length;\n\n        uint256 currentExposure;\n        {\n            TransmuterStorage storage ts = s.transmuterStorage();\n            uint256 normalizedStablesMem = ts.normalizedStables;\n            // Handling the initialisation and constant fees\n            if (normalizedStablesMem == 0 || n == 1)\n                return _computeFee(quoteType, amountStable, v.isMint ? collatInfo.yFeeMint[0] : collatInfo.yFeeBurn[0]);\n            // Increasing precision for `currentExposure` because otherwise if there is a factor 1e9 between total\n            // stablecoin supply and one specific collateral, exposure can be null\n            currentExposure = uint64((collatInfo.normalizedStables * BASE_18) / normalizedStablesMem);\n\n            uint256 normalizerMem = ts.normalizer;\n            // Store the current amount of stablecoins issued from this collateral\n            v.stablecoinsIssued = (uint256(collatInfo.normalizedStables) * normalizerMem) / BASE_27;\n            v.otherStablecoinSupply = (normalizerMem * normalizedStablesMem) / BASE_27 - v.stablecoinsIssued;\n        }\n\n        uint256 amount;\n        // Finding in which segment the current exposure to the collateral is\n        uint256 i = LibHelpers.findLowerBound(\n            v.isMint,\n            v.isMint ? collatInfo.xFeeMint : collatInfo.xFeeBurn,\n            uint64(BASE_9),\n            uint64(currentExposure)\n        );\n\n        while (i < n - 1) {\n            // We compute a linear by part function on the amount swapped\n            // The `amountToNextBreakPoint` variable is the `b_{i+1}` value from the whitepaper\n            if (v.isMint) {\n                v.lowerExposure = collatInfo.xFeeMint[i];\n                v.upperExposure = collatInfo.xFeeMint[i + 1];\n                v.lowerFees = collatInfo.yFeeMint[i];\n                v.upperFees = collatInfo.yFeeMint[i + 1];\n                v.amountToNextBreakPoint =\n                    (v.otherStablecoinSupply * v.upperExposure) /\n                    (BASE_9 - v.upperExposure) -\n                    v.stablecoinsIssued;\n            } else {\n                // The exposures in the burn case are decreasing\n                v.lowerExposure = collatInfo.xFeeBurn[i];\n                v.upperExposure = collatInfo.xFeeBurn[i + 1];\n                v.lowerFees = collatInfo.yFeeBurn[i];\n                v.upperFees = collatInfo.yFeeBurn[i + 1];\n                // The `b_{i+1}` value in the burn case is the opposite value of the mint case\n                v.amountToNextBreakPoint =\n                    v.stablecoinsIssued -\n                    (v.otherStablecoinSupply * v.upperExposure) /\n                    (BASE_9 - v.upperExposure);\n            }\n            // Computing the `g_i(0)` value from the whitepaper\n            int256 currentFees;\n            // We can only enter the else in the first iteration of the loop as otherwise we will\n            // always be at the beginning of the new segment\n            if (v.lowerExposure * BASE_9 == currentExposure) currentFees = v.lowerFees;\n            else if (v.lowerFees == v.upperFees) currentFees = v.lowerFees;\n            else {\n                // This is the opposite of the `b_i` value from the whitepaper.\n                uint256 amountFromPrevBreakPoint = v.isMint\n                    ? v.stablecoinsIssued - (v.otherStablecoinSupply * v.lowerExposure) / (BASE_9 - v.lowerExposure)\n                    : (v.otherStablecoinSupply * v.lowerExposure) / (BASE_9 - v.lowerExposure) - v.stablecoinsIssued;\n\n                //  slope = (upperFees - lowerFees) / (amountToNextBreakPoint + amountFromPrevBreakPoint)\n                // `currentFees` is the `g(0)` value from the whitepaper\n                currentFees =\n                    v.lowerFees +\n                    int256(\n                        (uint256(v.upperFees - v.lowerFees) * amountFromPrevBreakPoint) /\n                            (v.amountToNextBreakPoint + amountFromPrevBreakPoint)\n                    );\n            }\n            {\n                // In the mint case, when `!v.isExact`: = `b_{i+1} * (1+(g_i(0)+f_{i+1})/2)`\n                uint256 amountToNextBreakPointNormalizer = v.isExact ? v.amountToNextBreakPoint : v.isMint\n                    ? _invertFeeMint(v.amountToNextBreakPoint, int64(v.upperFees + currentFees) / 2)\n                    : _applyFeeBurn(v.amountToNextBreakPoint, int64(v.upperFees + currentFees) / 2);\n\n                if (amountToNextBreakPointNormalizer >= amountStable) {\n                    int64 midFee;\n                    if (v.isExact) {\n                        // `(g_i(0) + g_i(M)) / 2 = g(0) + (f_{i+1} - g(0)) * M / (2 * b_{i+1})`\n                        midFee = int64(\n                            currentFees +\n                                int256(\n                                    amountStable.mulDiv(\n                                        uint256((v.upperFees - currentFees)),\n                                        2 * amountToNextBreakPointNormalizer,\n                                        Math.Rounding.Up\n                                    )\n                                )\n                        );\n                    } else {\n                        // Here instead of computing the closed form expression for `m_t` derived in the whitepaper,\n                        // we are computing: `(g(0)+g_i(m_t))/2 = g(0)+(f_{i+1}-f_i)/(b_{i+1}-b_i)m_t/2\n\n                        // ac4 is the value of `2M(f_{i+1}-f_i)/(b_{i+1}-b_i) = 2M(f_{i+1}-g(0))/b_{i+1}` used\n                        // in the computation of `m_t` in both the mint and burn case\n                        uint256 ac4 = BASE_9.mulDiv(\n                            2 * amountStable * uint256(v.upperFees - currentFees),\n                            v.amountToNextBreakPoint,\n                            Math.Rounding.Up\n                        );\n\n                        if (v.isMint) {\n                            // In the mint case:\n                            // `m_t = (-1-g(0)+sqrt[(1+g(0))**2+2M(f_{i+1}-g(0))/b_{i+1})]/((f_{i+1}-g(0))/b_{i+1})`\n                            // And so: g(0)+(f_{i+1}-f_i)/(b_{i+1}-b_i)m_t/2\n                            //                      = (g(0)-1+sqrt[(1+g(0))**2+2M(f_{i+1}-g(0))/b_{i+1})])\n                            midFee = int64(\n                                (int256(\n                                    Math.sqrt((uint256(int256(BASE_9) + currentFees)) ** 2 + ac4, Math.Rounding.Up)\n                                ) +\n                                    currentFees -\n                                    int256(BASE_9)) / 2\n                            );\n                        } else {\n                            // In the burn case:\n                            // `m_t = (1-g(0)+sqrt[(1-g(0))**2-2M(f_{i+1}-g(0))/b_{i+1})]/((f_{i+1}-g(0))/b_{i+1})`\n                            // And so: g(0)+(f_{i+1}-f_i)/(b_{i+1}-b_i)m_t/2\n                            //                      = (g(0)+1-sqrt[(1-g(0))**2-2M(f_{i+1}-g(0))/b_{i+1})])\n\n                            uint256 baseMinusCurrentSquared = (uint256(int256(BASE_9) - currentFees)) ** 2;\n                            // Mathematically, this condition is always verified, but rounding errors may make this\n                            // mathematical invariant break, in which case we consider that the square root is null\n                            if (baseMinusCurrentSquared < ac4) midFee = int64((currentFees + int256(BASE_9)) / 2);\n                            else\n                                midFee = int64(\n                                    int256(\n                                        Math.mulDiv(\n                                            uint256(\n                                                currentFees +\n                                                    int256(BASE_9) -\n                                                    int256(Math.sqrt(baseMinusCurrentSquared - ac4, Math.Rounding.Down))\n                                            ),\n                                            1,\n                                            2,\n                                            Math.Rounding.Up\n                                        )\n                                    )\n                                );\n                        }\n                    }\n                    return amount + _computeFee(quoteType, amountStable, midFee);\n                } else {\n                    amountStable -= amountToNextBreakPointNormalizer;\n                    amount += !v.isExact ? v.amountToNextBreakPoint : v.isMint\n                        ? _invertFeeMint(v.amountToNextBreakPoint, int64(v.upperFees + currentFees) / 2)\n                        : _applyFeeBurn(v.amountToNextBreakPoint, int64(v.upperFees + currentFees) / 2);\n                    currentExposure = v.upperExposure * BASE_9;\n                    ++i;\n                    // Update for the rest of the swaps the stablecoins issued from the asset\n                    v.stablecoinsIssued = v.isMint\n                        ? v.stablecoinsIssued + v.amountToNextBreakPoint\n                        : v.stablecoinsIssued - v.amountToNextBreakPoint;\n                }\n            }\n        }\n        // If `i == n-1`, we are in an area where fees are constant\n        return\n            amount +\n            _computeFee(quoteType, amountStable, v.isMint ? collatInfo.yFeeMint[n - 1] : collatInfo.yFeeBurn[n - 1]);\n    }\n\n    /// @notice Checks whether a managed collateral asset still has enough collateral available to process\n    /// a transfer\n    function _checkAmounts(Collateral storage collatInfo, uint256 amountOut) internal view {\n        // Checking if enough is available for collateral assets that involve manager addresses\n        if (collatInfo.isManaged > 0 && LibManager.maxAvailable(collatInfo.managerData.config) < amountOut)\n            revert InvalidSwap();\n    }\n\n    /// @notice Checks whether a swap from `tokenIn` to `tokenOut` is a mint or a burn, whether the\n    /// collateral provided is paused or not and in case of whether the swap is not occuring too late\n    /// @dev The function reverts if the `tokenIn` and `tokenOut` given do not correspond to the stablecoin\n    /// and to an accepted collateral asset of the system\n    function _getMintBurn(\n        address tokenIn,\n        address tokenOut,\n        uint256 deadline\n    ) internal view returns (bool mint, Collateral storage collatInfo) {\n        if (deadline != 0 && block.timestamp > deadline) revert TooLate();\n        TransmuterStorage storage ts = s.transmuterStorage();\n        address _agToken = address(ts.agToken);\n        if (tokenIn == _agToken) {\n            collatInfo = ts.collaterals[tokenOut];\n            if (collatInfo.isBurnLive == 0) revert Paused();\n            mint = false;\n        } else if (tokenOut == _agToken) {\n            collatInfo = ts.collaterals[tokenIn];\n            if (collatInfo.isMintLive == 0) revert Paused();\n            mint = true;\n        } else revert InvalidTokens();\n    }\n\n    /// @notice Checks whether `tokenIn` is a valid unpaused collateral and the deadline\n    function _getMint(\n        address tokenIn,\n        uint256 deadline\n    ) internal view returns (address tokenOut, Collateral storage collatInfo) {\n        if (deadline != 0 && block.timestamp > deadline) revert TooLate();\n        TransmuterStorage storage ts = s.transmuterStorage();\n        collatInfo = ts.collaterals[tokenIn];\n        if (collatInfo.isMintLive == 0) revert Paused();\n        tokenOut = address(ts.agToken);\n    }\n\n    /// @notice Builds a permit2 `permitTransferFrom` payload for a `tokenIn` transfer\n    /// @dev The transfer should be from `msg.sender` to this contract or a manager\n    function _buildPermitTransferPayload(\n        uint256 amount,\n        uint256 approvedAmount,\n        address tokenIn,\n        uint256 deadline,\n        bytes memory permitData,\n        Collateral storage collatInfo\n    ) internal view returns (bytes memory payload) {\n        Permit2Details memory details;\n        if (collatInfo.isManaged > 0) details.to = LibManager.transferRecipient(collatInfo.managerData.config);\n        else details.to = address(this);\n        (details.nonce, details.signature) = abi.decode(permitData, (uint256, bytes));\n        payload = abi.encodeWithSelector(\n            IPermit2.permitTransferFrom.selector,\n            PermitTransferFrom({\n                permitted: TokenPermissions({ token: tokenIn, amount: approvedAmount }),\n                nonce: details.nonce,\n                deadline: deadline\n            }),\n            SignatureTransferDetails({ to: details.to, requestedAmount: amount }),\n            msg.sender,\n            details.signature\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                     INTERNAL PURE                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Applies or inverts `fees` to an `amount` based on the type of operation\n    function _computeFee(QuoteType quoteType, uint256 amount, int64 fees) internal pure returns (uint256) {\n        return\n            quoteType == QuoteType.MintExactInput ? _applyFeeMint(amount, fees) : quoteType == QuoteType.MintExactOutput\n                ? _invertFeeMint(amount, fees)\n                : quoteType == QuoteType.BurnExactInput\n                ? _applyFeeBurn(amount, fees)\n                : _invertFeeBurn(amount, fees);\n    }\n\n    /// @notice Checks whether an operation is a mint operation or not\n    function _isMint(QuoteType quoteType) internal pure returns (bool) {\n        return quoteType == QuoteType.MintExactInput || quoteType == QuoteType.MintExactOutput;\n    }\n\n    /// @notice Checks whether a swap involves an amount of stablecoins that is known in exact in advance or not\n    function _isExact(QuoteType quoteType) internal pure returns (bool) {\n        return quoteType == QuoteType.MintExactOutput || quoteType == QuoteType.BurnExactInput;\n    }\n\n    /// @notice Applies `fees` to an `amountIn` of assets to get an `amountOut` of stablecoins\n    function _applyFeeMint(uint256 amountIn, int64 fees) internal pure returns (uint256 amountOut) {\n        if (fees >= 0) {\n            uint256 castedFees = uint256(int256(fees));\n            // Consider that if fees are above `BASE_12` this is equivalent to infinite fees\n            if (castedFees >= BASE_12) revert InvalidSwap();\n            amountOut = (amountIn * BASE_9) / (BASE_9 + castedFees);\n        } else amountOut = (amountIn * BASE_9) / (BASE_9 - uint256(int256(-fees)));\n    }\n\n    /// @notice Gets from an `amountOut` of stablecoins and with `fees`, the `amountIn` of assets\n    /// that need to be brought during a mint\n    function _invertFeeMint(uint256 amountOut, int64 fees) internal pure returns (uint256 amountIn) {\n        if (fees >= 0) {\n            uint256 castedFees = uint256(int256(fees));\n            // Consider that if fees are above `BASE_12` this is equivalent to infinite fees\n            if (castedFees >= BASE_12) revert InvalidSwap();\n            amountIn = amountOut.mulDiv(BASE_9 + castedFees, BASE_9, Math.Rounding.Up);\n        } else amountIn = amountOut.mulDiv(BASE_9 - uint256(int256(-fees)), BASE_9, Math.Rounding.Up);\n    }\n\n    /// @notice Applies `fees` to an `amountIn` of stablecoins to get an `amountOut` of assets\n    function _applyFeeBurn(uint256 amountIn, int64 fees) internal pure returns (uint256 amountOut) {\n        if (fees >= 0) {\n            uint256 castedFees = uint256(int256(fees));\n            if (castedFees >= MAX_BURN_FEE) revert InvalidSwap();\n            amountOut = ((BASE_9 - castedFees) * amountIn) / BASE_9;\n        } else amountOut = ((BASE_9 + uint256(int256(-fees))) * amountIn) / BASE_9;\n    }\n\n    /// @notice Gets from an `amountOut` of assets and with `fees` the `amountIn` of stablecoins that need\n    /// to be brought during a burn\n    function _invertFeeBurn(uint256 amountOut, int64 fees) internal pure returns (uint256 amountIn) {\n        if (fees >= 0) {\n            uint256 castedFees = uint256(int256(fees));\n            if (castedFees >= MAX_BURN_FEE) revert InvalidSwap();\n            amountIn = amountOut.mulDiv(BASE_9, BASE_9 - castedFees, Math.Rounding.Up);\n        } else amountIn = amountOut.mulDiv(BASE_9, BASE_9 + uint256(int256(-fees)), Math.Rounding.Up);\n    }\n}"
    }
  ]
}