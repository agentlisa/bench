{
  "Title": "H-1: repayBorrow calls wrong frozen info update for overdue repayments",
  "Content": "# Issue H-1: repayBorrow calls wrong frozen info update for overdue repayments \n\nSource: https://github.com/sherlock-audit/2022-10-union-finance-judging/issues/143 \n\n## Found by \nhyh\n\n## Summary\n\nUToken's repayBorrow() calls frozen info update with wrong account, that end up not doing anything meaningful in the majority of cases, which leaves the stakers' account frozen info not updated, which leads to Comptroller accounting with the stale figures via debtWriteOff().\n\n## Vulnerability Detail\n\nUser facing UToken's repayBorrow() calling _repayBorrowFresh() end up calling `IUserManager(userManager).updateFrozenInfo(borrower, 0)` to update frozen coin age data. However in the most cases it is pointless to call this function for the borrower as most borrowers do not have issued loans and the state of these issued loans didn't changed when this account paid own debt.\n\nI.e. `IUserManager(userManager).updateFrozenInfo(staker, 0)` is a proper call and it should be done for all borrower's stakers to reflect the changed state of their issued loans, which got healthier as borrower paid full interest or even made a prepayment with repayBorrow().\n\nThis way repayBorrow() do not update borrower's stakers frozen coin age info and this way direct UserManager's batchUpdateFrozenInfo() and Comptroller's withdrawRewards() remain the only venues for lender's account total health update.\n\n## Impact\n\nGiven that stakers are unaware of this lacking update, and assuming that frozen info update is taking place on each repayment, so frozen info is up to date, and not calling manually batchUpdateFrozenInfo() before each debtWriteOff(), they invoke Comptroller accounting update with stale `totalFrozen` in `totalStaked - totalFrozen`, diminishing `effectiveAmount` in Comptroller’s inflation calculations.\n\nAs this is UNION reward miscalculation without low probability prerequisites (i.e. base functionality not working as intended), setting the severity to be high.\n\n## Code Snippet\n\nWhen a borrower is overdue, `repayBorrow() -> _repayBorrowFresh()` calls for \n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/market/UToken.sol#L573-L626\n\n```solidity\n    function _repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 amount\n    ) internal {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n\n        uint256 interest = calculatingInterest(borrower);\n        uint256 borrowedAmount = borrowBalanceStoredInternal(borrower);\n        uint256 repayAmount = amount > borrowedAmount ? borrowedAmount : amount;\n        if (repayAmount == 0) revert AmountZero();\n\n        uint256 toReserveAmount;\n        uint256 toRedeemableAmount;\n\n        if (repayAmount >= interest) {\n            // If the repayment amount is greater than the interest (min payment)\n            bool isOverdue = checkIsOverdue(borrower);\n\n            // Interest is split between the reserves and the uToken minters based on\n            // the reserveFactorMantissa When set to WAD all the interest is paid to teh reserves.\n            // any interest that isn't sent to the reserves is added to the redeemable amount\n            // and can be redeemed by uToken minters.\n            toReserveAmount = (interest * reserveFactorMantissa) / WAD;\n            toRedeemableAmount = interest - toReserveAmount;\n\n            // Update the total borrows to reduce by the amount of principal that has\n            // been paid off\n            totalBorrows -= (repayAmount - interest);\n\n            // Update the account borrows to reflect the repayment\n            accountBorrows[borrower].principal = borrowedAmount - repayAmount;\n            accountBorrows[borrower].interest = 0;\n\n            if (getBorrowed(borrower) == 0) {\n                // If the principal is now 0 we can reset the last repaid block to 0.\n                // which indicates that the borrower has no outstanding loans.\n                accountBorrows[borrower].lastRepay = 0;\n            } else {\n                // Save the current block number as last repaid\n                accountBorrows[borrower].lastRepay = getBlockNumber();\n            }\n\n            // Call update locked on the userManager to lock this borrowers stakers. This function\n            // will revert if the account does not have enough vouchers to cover the repay amount. ie\n            // the borrower is trying to repay more than is locked (owed)\n            IUserManager(userManager).updateLocked(borrower, uint96(repayAmount - interest), false);\n\n            if (isOverdue) {\n                // For borrowers that are paying back overdue balances we need to update their\n                // frozen balance and the global total frozen balance on the UserManager\n                IUserManager(userManager).updateFrozenInfo(borrower, 0);\n            }\n        }\n```\n\nHowever, `updateFrozenInfo() -> _updateFrozen() -> getFrozenInfo()` aims to update overdue info from lender perspective, cycling through `vouchees` array of the issued loans:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L438-L466\n\n```solidity\n    function getFrozenInfo(address staker, uint256 pastBlocks)\n        public\n        view\n        returns (uint256 memberTotalFrozen, uint256 memberFrozenCoinAge)\n    {\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 voucheesLength = vouchees[staker].length;\n        // Loop through all of the stakers vouchees sum their total\n        // locked balance and sum their total memberFrozenCoinAge\n        for (uint256 i = 0; i < voucheesLength; i++) {\n            // Get the vouchee record and look up the borrowers voucher record\n            // to get the locked amount and lastUpdate block number\n            Vouchee memory vouchee = vouchees[staker][i];\n            Vouch memory vouch = vouchers[vouchee.borrower][vouchee.voucherIndex];\n\n            uint256 lastUpdated = vouch.lastUpdated;\n            uint256 diff = block.number - lastUpdated;\n\n            if (overdueBlocks < diff) {\n                uint96 locked = vouch.locked;\n                memberTotalFrozen += locked;\n                if (pastBlocks >= diff) {\n                    memberFrozenCoinAge += (locked * diff);\n                } else {\n                    memberFrozenCoinAge += (locked * pastBlocks);\n                }\n            }\n        }\n    }\n```\n\nA borrower can also be a staker, but the intersection is reasonably small, i.e. calling `IUserManager(userManager).updateFrozenInfo(borrower, 0)` will be a noop in the vast majority of cases.\n\nIt is also called in Comptroller via user-facing withdrawRewards() invoking _getUserInfo() that calls updateFrozenInfo(): \n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol#L231-L245\n\n```solidity\n    function withdrawRewards(address account, address token)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (uint256)\n    {\n        IUserManager userManager = _getUserManager(token);\n\n        // Lookup account state from UserManager\n        (\n            UserManagerAccountState memory userManagerAccountState,\n            Info memory userInfo,\n            uint256 pastBlocks\n        ) = _getUserInfo(userManager, account, token, 0);\n```\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol#L361-L384\n\n```solidity\n    function _getUserInfo(\n        IUserManager userManager,\n        address account,\n        address token,\n        uint256 futureBlocks\n    )\n        internal\n        returns (\n            UserManagerAccountState memory,\n            Info memory,\n            uint256\n        )\n    {\n        Info memory userInfo = users[account][token];\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n\n        UserManagerAccountState memory userManagerAccountState;\n        (userManagerAccountState.totalFrozen, userManagerAccountState.pastBlocksFrozenCoinAge) = userManager\n            .updateFrozenInfo(account, pastBlocks);\n```\n\nwithdrawRewards() is a staker reward withdrawal function.\n\nThe impact of the frozen info not being updated on borrower’s repay is `comptroller.updateTotalStaked` proceeds with the stale `totalFrozen` figure:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L726-L788\n\n```solidity\n    function debtWriteOff(\n        address staker,\n        address borrower,\n        uint96 amount\n    ) external {\n        if (amount == 0) revert AmountZero();\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 lastRepay = uToken.getLastRepay(borrower);\n\n        // This function is only callable by the public if the loan is overdue by\n        // overdue blocks + maxOverdueBlocks. This stops the system being left with\n        // debt that is overdue indefinitely and no ability to do anything about it.\n        if (block.number <= lastRepay + overdueBlocks + maxOverdueBlocks) {\n            if (staker != msg.sender) revert AuthFailed();\n        }\n\n        Index memory index = voucherIndexes[borrower][staker];\n        if (!index.isSet) revert VoucherNotFound();\n        Vouch storage vouch = vouchers[borrower][index.idx];\n\n        if (amount > vouch.locked) revert ExceedsLocked();\n\n        // update staker staked amount\n        stakers[staker].stakedAmount -= amount;\n        stakers[staker].locked -= amount;\n        totalStaked -= amount;\n\n        // update vouch trust amount\n        vouch.trust -= amount;\n        vouch.locked -= amount;\n\n        // Update total frozen and member frozen. We don't want to move th\n        // burden of calling updateFrozenInfo into this function as it is quite\n        // gas intensive. Instead we just want to remove the amount that was\n        // frozen which is now being written off. However, it is possible that\n        // member frozen has not been updated prior to calling debtWriteOff and\n        // the amount being written off could be greater than the amount frozen.\n        // To avoid an underflow here we need to check this condition\n        uint256 stakerFrozen = memberFrozen[staker];\n        if (amount > stakerFrozen) {\n            // The amount being written off is more than the amount that has\n            // been previously frozen for this staker. Reset their frozen stake\n            // to zero and adjust totalFrozen\n            memberFrozen[staker] = 0;\n            totalFrozen -= stakerFrozen;\n        } else {\n            totalFrozen -= amount;\n            memberFrozen[staker] -= amount;\n        }\n\n        if (vouch.trust == 0) {\n            cancelVouch(staker, borrower);\n        }\n\n        // Notify the AssetManager and the UToken market of the debt write off\n        // so they can adjust their balances accordingly\n        IAssetManager(assetManager).debtWriteOff(stakingToken, uint256(amount));\n        uToken.debtWriteOff(borrower, uint256(amount));\n\n        comptroller.updateTotalStaked(stakingToken, totalStaked - totalFrozen);\n\n        emit LogDebtWriteOff(msg.sender, borrower, uint256(amount));\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider calling it for borrower's staker instead:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/market/UToken.sol#L621-L625\n\n```solidity\n            if (isOverdue) {\n                // For borrowers that are paying back overdue balances we need to update their\n                // frozen balance and the global total frozen balance on the UserManager\n-               IUserManager(userManager).updateFrozenInfo(borrower, 0);\n+\t\t... // cycle all stakers of the borrower\n+                  IUserManager(userManager).updateFrozenInfo(staker, 0);\n            }\n```\n\nAn alternative to this is to call updateFrozenInfo() in updateLocked() as it implements closely related logic.\n\n## Discussion\n\n**kingjacob**\n\nThis is as designed, The contract assumes a minimal level of activity or a keeper to keep reward calcs up to date.\n\n**dmitriia**\n\nIt's not about updating one staker or all of them, it's updating **staker**, not the borrower: calling `IUserManager(userManager).updateFrozenInfo(borrower, 0)` is just pointless, most borrowers will not have stakes of their own, and those stakes, if exist, aren't updated on repayBorrow.\n\nIn other words:\n* Bob opens trust for Alice\n* Alice borrows, then repays\n* `updateFrozenInfo` is called for Alice, while she doesn't have any stakes and frozen info is irrelevant for her\n* `updateFrozenInfo` should be called for Bob\n* ideally for all Alice stakers, but it's design question indeed, the issue is about calling for Bob instead of Alice\n\n\n**kingjacob**\n\n@dmitriia gotcha, youre probably right on this.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/11",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/market/UToken.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\nimport {IInterestRateModel} from \"../interfaces/IInterestRateModel.sol\";\n\n/**\n *  @title UToken Contract\n *  @dev Union accountBorrows can borrow and repay thru this component.\n */\ncontract UToken is IUToken, Controller, ERC20PermitUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* -------------------------------------------------------------------\n      Types \n    ------------------------------------------------------------------- */\n\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interest;\n        uint256 interestIndex;\n        uint256 lastRepay; //Calculate if it is overdue\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Wad do you want\n     */\n    uint256 public constant WAD = 1e18;\n\n    /**\n     * @dev Maximum borrow rate that can ever be applied (.005% / block)\n     */\n    uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.005e16;\n\n    /**\n     *  @dev Maximum fraction of interest that can be set aside for reserves\n     */\n    uint256 internal constant RESERVE_FACTORY_MAX_MANTISSA = 1e18;\n\n    /**\n     *  @dev Initial exchange rate used when minting the first UTokens (used when totalSupply = 0)\n     */\n    uint256 public initialExchangeRateMantissa;\n\n    /**\n     *  @dev Fraction of interest currently set aside for reserves\n     */\n    uint256 public reserveFactorMantissa;\n\n    /**\n     *  @dev Block number that interest was last accrued at\n     */\n    uint256 public accrualBlockNumber;\n\n    /**\n     *  @dev Accumulator of the total earned interest rate since the opening of the market\n     */\n    uint256 public borrowIndex;\n\n    /**\n     *  @dev Total amount of outstanding borrows of the underlying in this market\n     */\n    uint256 public totalBorrows;\n\n    /**\n     *  @dev Total amount of reserves of the underlying held in this marke\n     */\n    uint256 public totalReserves;\n\n    /**\n     *  @dev Calculates the exchange rate from the underlying to the uToken\n     */\n    uint256 public totalRedeemable;\n\n    /**\n     *  @dev overdue duration, based on the number of blocks\n     */\n    uint256 public override overdueBlocks;\n\n    /**\n     *  @dev fee paid at loan origin\n     */\n    uint256 public originationFee;\n\n    /**\n     *  @dev The debt limit for the whole system\n     */\n    uint256 public debtCeiling;\n\n    /**\n     *  @dev Max amount that can be borrowed by a single member\n     */\n    uint256 public maxBorrow;\n\n    /**\n     *  @dev Min amount that can be borrowed by a single member\n     */\n    uint256 public minBorrow;\n\n    /**\n     *  @dev Asset manager contract address\n     */\n    address public assetManager;\n\n    /**\n     *  @dev User manager contract address\n     */\n    address public userManager;\n\n    /**\n     * @dev Address of underlying token\n     */\n    address public underlying;\n\n    /**\n     * @dev Interest rate model used for calculating interest rate\n     */\n    IInterestRateModel public interestRateModel;\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error AccrueInterestFailed();\n    error AmountExceedGlobalMax();\n    error AmountExceedMaxBorrow();\n    error AmountLessMinBorrow();\n    error AmountZero();\n    error BorrowRateExceedLimit();\n    error WithdrawFailed();\n    error CallerNotMember();\n    error CallerNotUserManager();\n    error InitExchangeRateNotZero();\n    error InsufficientFundsLeft();\n    error MemberIsOverdue();\n    error ReserveFactoryExceedLimit();\n    error DepositToAssetManagerFailed();\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Change of the interest rate model\n     *  @param oldInterestRateModel Old interest rate model address\n     *  @param newInterestRateModel New interest rate model address\n     */\n    event LogNewMarketInterestRateModel(address oldInterestRateModel, address newInterestRateModel);\n\n    /**\n     *  @dev Mint uToken by depositing token\n     *  @param minter address of minter\n     *  @param underlyingAmount amount of underlying token\n     *  @param uTokenAmount amount of uToken\n     */\n    event LogMint(address minter, uint256 underlyingAmount, uint256 uTokenAmount);\n\n    /**\n     *  @dev Redeem token for uToken\n     */\n    event LogRedeem(address redeemer, uint256 amountIn, uint256 amountOut, uint256 redeemAmount);\n\n    /**\n     *  @dev Token added to the reserves\n     *  @param reserver address of sender that added to reservers\n     *  @param actualAddAmount amount of tokens added\n     *  @param totalReservesNew new total reserve amount\n     */\n    event LogReservesAdded(address reserver, uint256 actualAddAmount, uint256 totalReservesNew);\n\n    /**\n     *  @dev Token removed from the reserves\n     *  @param receiver reciever address of tokens\n     *  @param reduceAmount amount of tokens to withdraw\n     *  @param totalReservesNew new total reserves amount\n     */\n    event LogReservesReduced(address receiver, uint256 reduceAmount, uint256 totalReservesNew);\n\n    /**\n     *  @dev Event borrow\n     *  @param account Member address\n     *  @param amount Borrow amount\n     *  @param fee Origination fee\n     */\n    event LogBorrow(address indexed account, address indexed to, uint256 amount, uint256 fee);\n\n    /**\n     *  @dev Event repay\n     *  @param account Member address\n     *  @param amount Repay amount\n     */\n    event LogRepay(address indexed payer, address indexed account, uint256 amount);\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev modifier limit member\n     */\n    modifier onlyMember(address account) {\n        if (!IUserManager(userManager).checkIsMember(account)) revert CallerNotMember();\n        _;\n    }\n\n    modifier onlyUserManager() {\n        if (msg.sender != userManager) revert CallerNotUserManager();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __UToken_init(\n        string memory name_,\n        string memory symbol_,\n        address underlying_,\n        uint256 initialExchangeRateMantissa_,\n        uint256 reserveFactorMantissa_,\n        uint256 originationFee_,\n        uint256 debtCeiling_,\n        uint256 maxBorrow_,\n        uint256 minBorrow_,\n        uint256 overdueBlocks_,\n        address admin_\n    ) public initializer {\n        if (initialExchangeRateMantissa_ == 0) revert InitExchangeRateNotZero();\n        if (reserveFactorMantissa_ > RESERVE_FACTORY_MAX_MANTISSA) revert ReserveFactoryExceedLimit();\n        Controller.__Controller_init(admin_);\n        ERC20Upgradeable.__ERC20_init(name_, symbol_);\n        ERC20PermitUpgradeable.__ERC20Permit_init(name_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        underlying = underlying_;\n        originationFee = originationFee_;\n        debtCeiling = debtCeiling_;\n        maxBorrow = maxBorrow_;\n        minBorrow = minBorrow_;\n        overdueBlocks = overdueBlocks_;\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        reserveFactorMantissa = reserveFactorMantissa_;\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = WAD;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev set Asset Manager contract address\n     *  Accept claims only from the admin\n     */\n    function setAssetManager(address assetManager_) external onlyAdmin {\n        assetManager = assetManager_;\n    }\n\n    /**\n     *  @dev set User Manager contract address\n     *  Accept claims only from the admin\n     */\n    function setUserManager(address userManager_) external onlyAdmin {\n        userManager = userManager_;\n    }\n\n    /**\n     *  @dev Change loan origination fee value\n     *  Accept claims only from the admin\n     *  @param originationFee_ Fees deducted for each loan transaction\n     */\n    function setOriginationFee(uint256 originationFee_) external override onlyAdmin {\n        originationFee = originationFee_;\n    }\n\n    /**\n     *  @dev Update the market debt ceiling to a fixed amount, for example, 1 billion DAI etc.\n     *  Accept claims only from the admin\n     *  @param debtCeiling_ The debt limit for the whole system\n     */\n    function setDebtCeiling(uint256 debtCeiling_) external override onlyAdmin {\n        debtCeiling = debtCeiling_;\n    }\n\n    /**\n     *  @dev Update the minimum loan size\n     *  Accept claims only from the admin\n     *  @param minBorrow_ Minimum loan amount per user\n     */\n    function setMinBorrow(uint256 minBorrow_) external override onlyAdmin {\n        minBorrow = minBorrow_;\n    }\n\n    /**\n     *  @dev Update the max loan size\n     *  Accept claims only from the admin\n     *  @param maxBorrow_ Max loan amount per user\n     */\n    function setMaxBorrow(uint256 maxBorrow_) external override onlyAdmin {\n        maxBorrow = maxBorrow_;\n    }\n\n    /**\n     *  @dev Change loan overdue duration, based on the number of blocks\n     *  Accept claims only from the admin\n     *  @param overdueBlocks_ Maximum late repayment block. The number of arrivals is a default\n     */\n    function setOverdueBlocks(uint256 overdueBlocks_) external override onlyAdmin {\n        overdueBlocks = overdueBlocks_;\n    }\n\n    /**\n     *  @dev Change to a different interest rate model\n     *  Accept claims only from the admin\n     *  @param newInterestRateModel_ New interest rate model address\n     */\n    function setInterestRateModel(address newInterestRateModel_) external override onlyAdmin {\n        address oldInterestRateModel = address(interestRateModel);\n        address newInterestRateModel = newInterestRateModel_;\n        interestRateModel = IInterestRateModel(newInterestRateModel);\n        emit LogNewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n    }\n\n    /**\n     *  @dev set reserve factor mantissa\n     *  Accept claims only from the admin\n     */\n    function setReserveFactor(uint256 reserveFactorMantissa_) external override onlyAdmin {\n        if (reserveFactorMantissa_ > RESERVE_FACTORY_MAX_MANTISSA) revert ReserveFactoryExceedLimit();\n        reserveFactorMantissa = reserveFactorMantissa_;\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Returns the remaining amount that can be borrowed from the market.\n     *  @return Remaining total amount\n     */\n    function getRemainingDebtCeiling() public view override returns (uint256) {\n        return debtCeiling >= totalBorrows ? debtCeiling - totalBorrows : 0;\n    }\n\n    /**\n     *  @dev Get the last repay block\n     *  @param account Member address\n     *  @return lastRepay\n     */\n    function getLastRepay(address account) public view override returns (uint256) {\n        return accountBorrows[account].lastRepay;\n    }\n\n    /**\n     *  @dev Check if the member's loan is overdue\n     *  @param account Member address\n     *  @return isOverdue\n     */\n    function checkIsOverdue(address account) public view override returns (bool isOverdue) {\n        if (getBorrowed(account) != 0) {\n            uint256 lastRepay = getLastRepay(account);\n            uint256 diff = getBlockNumber() - lastRepay;\n            isOverdue = overdueBlocks < diff;\n        }\n    }\n\n    /**\n     *  @dev Get the origination fee\n     *  @param amount Amount to be calculated\n     *  @return Handling fee\n     */\n    function calculatingFee(uint256 amount) public view override returns (uint256) {\n        return (originationFee * amount) / WAD;\n    }\n\n    /**\n     *  @dev Get the borrowed principle\n     *  @param account Member address\n     *  @return borrowed\n     */\n    function getBorrowed(address account) public view override returns (uint256) {\n        return accountBorrows[account].principal;\n    }\n\n    /**\n     *  @dev Get a member's current owed balance, including the principle and interest but without updating the user's states.\n     *  @param account Member address\n     *  @return Borrowed amount\n     */\n    function borrowBalanceView(address account) public view override returns (uint256) {\n        return getBorrowed(account) + calculatingInterest(account);\n    }\n\n    /**\n     *  @dev Get a member's total owed, including the principle and the interest calculated based on the interest index.\n     *  @param account Member address\n     *  @return Borrowed amount\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (uint256) {\n        BorrowSnapshot memory loan = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (loan.principal == 0) {\n            return 0;\n        }\n\n        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndex;\n        return principalTimesIndex / loan.interestIndex;\n    }\n\n    /**\n     *  @dev Get the borrowing interest rate per block\n     *  @return Borrow rate\n     */\n    function borrowRatePerBlock() public view override returns (uint256) {\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate();\n        if (borrowRateMantissa > BORROW_RATE_MAX_MANTISSA) revert BorrowRateExceedLimit();\n\n        return borrowRateMantissa;\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this UToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint256) {\n        return interestRateModel.getSupplyRate(reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the UToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint256) {\n        uint256 totalSupply_ = totalSupply();\n        return totalSupply_ == 0 ? initialExchangeRateMantissa : (totalRedeemable * WAD) / totalSupply_;\n    }\n\n    /**\n     *  @dev Calculating member's borrowed interest\n     *  @param account Member address\n     *  @return Interest amount\n     */\n    function calculatingInterest(address account) public view override returns (uint256) {\n        BorrowSnapshot memory loan = accountBorrows[account];\n\n        if (loan.principal == 0) {\n            return 0;\n        }\n\n        uint256 borrowRate = borrowRatePerBlock();\n        uint256 currentBlockNumber = getBlockNumber();\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;\n        uint256 simpleInterestFactor = borrowRate * blockDelta;\n        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;\n\n        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndexNew;\n        uint256 balance = principalTimesIndex / loan.interestIndex;\n\n        return balance - getBorrowed(account);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint256) {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external view override returns (uint256) {\n        return (exchangeRateStored() * balanceOf(owner)) / WAD;\n    }\n\n    /* -------------------------------------------------------------------\n       Borrowing/Repay Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Borrowing from the market\n     *  Accept claims only from the member\n     *  Borrow amount must in the range of creditLimit, minBorrow, maxBorrow, debtCeiling and not overdue\n     *  @param amount Borrow amount\n     */\n    function borrow(address to, uint256 amount) external override onlyMember(msg.sender) whenNotPaused nonReentrant {\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        if (amount < minBorrow) revert AmountLessMinBorrow();\n        if (amount > getRemainingDebtCeiling()) revert AmountExceedGlobalMax();\n\n        // Calculate the origination fee\n        uint256 fee = calculatingFee(amount);\n\n        if (borrowBalanceView(msg.sender) + amount + fee > maxBorrow) revert AmountExceedMaxBorrow();\n        if (checkIsOverdue(msg.sender)) revert MemberIsOverdue();\n        if (amount > assetManagerContract.getLoanableAmount(underlying)) revert InsufficientFundsLeft();\n        if (!accrueInterest()) revert AccrueInterestFailed();\n\n        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);\n\n        // Initialize the last repayment date to the current block number\n        if (getLastRepay(msg.sender) == 0) {\n            accountBorrows[msg.sender].lastRepay = getBlockNumber();\n        }\n\n        uint256 accountBorrowsNew = borrowedAmount + amount + fee;\n        uint256 totalBorrowsNew = totalBorrows + amount + fee;\n\n        // Update internal balances\n        accountBorrows[msg.sender].principal += amount + fee;\n        uint256 newPrincipal = getBorrowed(msg.sender);\n        accountBorrows[msg.sender].interest = accountBorrowsNew - newPrincipal;\n        accountBorrows[msg.sender].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        // The origination fees contribute to the reserve and not to the\n        // uDAI minters redeemable amount.\n        totalReserves += fee;\n\n        // Withdraw the borrowed amount of tokens from the assetManager and send them to the borrower\n        if (!assetManagerContract.withdraw(underlying, to, amount)) revert WithdrawFailed();\n\n        // Call update locked on the userManager to lock this borrowers stakers. This function\n        // will revert if the account does not have enough vouchers to cover the borrow amount. ie\n        // the borrower is trying to borrow more than is able to be underwritten\n        IUserManager(userManager).updateLocked(msg.sender, uint96(amount + fee), true);\n\n        emit LogBorrow(msg.sender, to, amount, fee);\n    }\n\n    /**\n     * @notice Repay outstanding borrow\n     * @dev Repay borrow see _repayBorrowFresh\n     */\n    function repayBorrow(address borrower, uint256 repayAmount) external override whenNotPaused nonReentrant {\n        _repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    /**\n     *  @dev Repay the loan\n     *  Accept claims only from the member\n     *  Updated member lastPaymentEpoch only when the repayment amount is greater than interest\n     *  @param payer Payer address\n     *  @param borrower Borrower address\n     *  @param amount Repay amount\n     */\n    function _repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 amount\n    ) internal {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n\n        uint256 interest = calculatingInterest(borrower);\n        uint256 borrowedAmount = borrowBalanceStoredInternal(borrower);\n        uint256 repayAmount = amount > borrowedAmount ? borrowedAmount : amount;\n        if (repayAmount == 0) revert AmountZero();\n\n        uint256 toReserveAmount;\n        uint256 toRedeemableAmount;\n\n        if (repayAmount >= interest) {\n            // If the repayment amount is greater than the interest (min payment)\n            bool isOverdue = checkIsOverdue(borrower);\n\n            // Interest is split between the reserves and the uToken minters based on\n            // the reserveFactorMantissa When set to WAD all the interest is paid to teh reserves.\n            // any interest that isn't sent to the reserves is added to the redeemable amount\n            // and can be redeemed by uToken minters.\n            toReserveAmount = (interest * reserveFactorMantissa) / WAD;\n            toRedeemableAmount = interest - toReserveAmount;\n\n            // Update the total borrows to reduce by the amount of principal that has\n            // been paid off\n            totalBorrows -= (repayAmount - interest);\n\n            // Update the account borrows to reflect the repayment\n            accountBorrows[borrower].principal = borrowedAmount - repayAmount;\n            accountBorrows[borrower].interest = 0;\n\n            if (getBorrowed(borrower) == 0) {\n                // If the principal is now 0 we can reset the last repaid block to 0.\n                // which indicates that the borrower has no outstanding loans.\n                accountBorrows[borrower].lastRepay = 0;\n            } else {\n                // Save the current block number as last repaid\n                accountBorrows[borrower].lastRepay = getBlockNumber();\n            }\n\n            // Call update locked on the userManager to lock this borrowers stakers. This function\n            // will revert if the account does not have enough vouchers to cover the repay amount. ie\n            // the borrower is trying to repay more than is locked (owed)\n            IUserManager(userManager).updateLocked(borrower, uint96(repayAmount - interest), false);\n\n            if (isOverdue) {\n                // For borrowers that are paying back overdue balances we need to update their\n                // frozen balance and the global total frozen balance on the UserManager\n                IUserManager(userManager).updateFrozenInfo(borrower, 0);\n            }\n        } else {\n            // For repayments that don't pay off the minimum we just need to adjust the\n            // global balances and reduce the amount of interest accrued for the borrower\n            toReserveAmount = (repayAmount * reserveFactorMantissa) / WAD;\n            toRedeemableAmount = repayAmount - toReserveAmount;\n            accountBorrows[borrower].interest = interest - repayAmount;\n        }\n\n        totalReserves += toReserveAmount;\n        totalRedeemable += toRedeemableAmount;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        // Transfer underlying token that have been repaid and then deposit\n        // then in the asset manager so they can be distributed between the\n        // underlying money markets\n        IERC20Upgradeable(underlying).safeTransferFrom(payer, address(this), repayAmount);\n        _depositToAssetManager(repayAmount);\n\n        emit LogRepay(payer, borrower, repayAmount);\n    }\n\n    /**\n     *  @dev Accrue interest\n     *  @return Accrue interest finished\n     */\n    function accrueInterest() public override returns (bool) {\n        uint256 borrowRate = borrowRatePerBlock();\n        uint256 currentBlockNumber = getBlockNumber();\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;\n\n        uint256 simpleInterestFactor = borrowRate * blockDelta;\n        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;\n\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n\n        return true;\n    }\n\n    function debtWriteOff(address borrower, uint256 amount) external override whenNotPaused onlyUserManager {\n        uint256 oldPrincipal = getBorrowed(borrower);\n        uint256 repayAmount = amount > oldPrincipal ? oldPrincipal : amount;\n\n        accountBorrows[borrower].principal = oldPrincipal - repayAmount;\n        totalBorrows -= repayAmount;\n    }\n\n    /* -------------------------------------------------------------------\n       Mint uToken Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Mint uTokens by depositing tokens\n     * @param mintAmount Amount of uTokens to mint\n     */\n    function mint(uint256 mintAmount) external override whenNotPaused nonReentrant {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n        uint256 exchangeRate = exchangeRateStored();\n        IERC20Upgradeable assetToken = IERC20Upgradeable(underlying);\n        uint256 balanceBefore = assetToken.balanceOf(address(this));\n        assetToken.safeTransferFrom(msg.sender, address(this), mintAmount);\n        uint256 balanceAfter = assetToken.balanceOf(address(this));\n        uint256 actualMintAmount = balanceAfter - balanceBefore;\n        totalRedeemable += actualMintAmount;\n        uint256 mintTokens = (actualMintAmount * WAD) / exchangeRate;\n        _mint(msg.sender, mintTokens);\n\n        _depositToAssetManager(actualMintAmount);\n\n        emit LogMint(msg.sender, actualMintAmount, mintTokens);\n    }\n\n    /**\n     * @notice User redeems uTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param amountIn The number of uTokens to redeem into underlying\n     *        (only one of amountIn or amountOut may be non-zero)\n     * @param amountOut The number of underlying tokens to receive from\n     *        (only one of amountIn or amountOut may be non-zero)\n     */\n    function redeem(uint256 amountIn, uint256 amountOut) external override whenNotPaused nonReentrant {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n        if (amountIn != 0 && amountOut != 0) revert AmountZero();\n\n        uint256 exchangeRate = exchangeRateStored();\n\n        // Amount of the uToken to burn\n        uint256 uTokenAmount;\n\n        // Amount of the underlying token to redeem\n        uint256 underlyingAmount;\n\n        if (amountIn > 0) {\n            // We calculate the exchange rate and the amount of underlying to be redeemed:\n            // uTokenAmount = amountIn\n            // underlyingAmount = amountIn x exchangeRateCurrent\n            uTokenAmount = amountIn;\n            underlyingAmount = (amountIn * exchangeRate) / WAD;\n        } else {\n            // We get the current exchange rate and calculate the amount to be redeemed:\n            // uTokenAmount = amountOut / exchangeRate\n            // underlyingAmount = amountOut\n            uTokenAmount = (amountOut * WAD) / exchangeRate;\n            underlyingAmount = amountOut;\n        }\n\n        totalRedeemable -= underlyingAmount;\n        _burn(msg.sender, uTokenAmount);\n\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        if (!assetManagerContract.withdraw(underlying, msg.sender, underlyingAmount)) revert WithdrawFailed();\n\n        emit LogRedeem(msg.sender, amountIn, amountOut, underlyingAmount);\n    }\n\n    /* -------------------------------------------------------------------\n       Reserve Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Add tokens to the reseve\n     * @param addAmount amount of tokens to add\n     */\n    function addReserves(uint256 addAmount) external override whenNotPaused nonReentrant {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n        IERC20Upgradeable assetToken = IERC20Upgradeable(underlying);\n        uint256 balanceBefore = assetToken.balanceOf(address(this));\n        assetToken.safeTransferFrom(msg.sender, address(this), addAmount);\n        uint256 balanceAfter = assetToken.balanceOf(address(this));\n        uint256 actualAddAmount = balanceAfter - balanceBefore;\n\n        totalReserves += actualAddAmount;\n\n        _depositToAssetManager(balanceAfter);\n\n        emit LogReservesAdded(msg.sender, actualAddAmount, totalReserves);\n    }\n\n    /**\n     * @dev Remove tokens to the reseve\n     * @param receiver address to recieve tokens\n     * @param reduceAmount amount of tokens to remove\n     */\n    function removeReserves(address receiver, uint256 reduceAmount)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlyAdmin\n    {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n\n        totalReserves -= reduceAmount;\n\n        if (!IAssetManager(assetManager).withdraw(underlying, receiver, reduceAmount)) revert WithdrawFailed();\n\n        emit LogReservesReduced(receiver, reduceAmount, totalReserves);\n    }\n\n    /* -------------------------------------------------------------------\n       Internal Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     *  @dev Deposit tokens to the asset manager\n     */\n    function _depositToAssetManager(uint256 amount) internal {\n        IERC20Upgradeable assetToken = IERC20Upgradeable(underlying);\n        assetToken.safeApprove(assetManager, 0); // Some ERC20 tokens (e.g. Tether) changed the behavior of approve to look like safeApprove\n        assetToken.safeApprove(assetManager, amount);\n        if (!IAssetManager(assetManager).deposit(underlying, amount)) revert DepositToAssetManagerFailed();\n    }\n}"
    },
    {
      "filename": "union-v2-contracts/contracts/user/UserManager.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\nimport {IComptroller} from \"../interfaces/IComptroller.sol\";\nimport {IUnionToken} from \"../interfaces/IUnionToken.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\n/**\n * @title UserManager Contract\n * @dev Manages the Union members stake and vouches.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* -------------------------------------------------------------------\n      Types \n    ------------------------------------------------------------------- */\n\n    struct Vouch {\n        // staker recieveing the vouch\n        address staker;\n        // trust amount\n        uint96 trust;\n        // amount of stake locked by this vouch\n        uint96 locked;\n        // block number of last update\n        uint64 lastUpdated;\n    }\n\n    struct Staker {\n        bool isMember;\n        uint96 stakedAmount;\n        uint96 locked;\n    }\n\n    struct Index {\n        bool isSet;\n        uint128 idx;\n    }\n\n    struct Vouchee {\n        address borrower;\n        uint96 voucherIndex;\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Max amount that can be staked of the staking token\n     */\n    uint96 public maxStakeAmount;"
    }
  ]
}