{
  "Title": "[M-04] LP unwrap / wrap is fully broken if master chef contract has insufficient reward token and block decollateralize wlp and wlp liquidation",
  "Content": "\n<https://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/wrapper/WLpMoeMasterChef.sol#L145> \n\n<https://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/core/InitCore.sol#L284>\n\nLP unwrap / wrap is fully broken if master chef contract has insufficient reward token.\n\n### Proof of Concept\n\nWe need to take a look at the external master chef contract that is not in the control of the init capital protocol team.\n\nWhen deposit / withdraw / harvest / claim, this function [\\_modify](https://github.com/traderjoe-xyz/moe-core/blob/5eb20a10cbe4ee01f8db20da950309cb297e3c09/src/MasterChef.sol#L257) is called, which is [this code](https://github.com/traderjoe-xyz/moe-core/blob/5eb20a10cbe4ee01f8db20da950309cb297e3c09/src/MasterChef.sol#L466)\n\n```solidity\n\tif (moeReward > 0) _moe.safeTransfer(account, moeReward);\n\n\tif (address(extraRewarder) != address(0)) {\n\t\textraRewarder.onModify(account, pid, oldBalance, newBalance, oldTotalSupply);\n\t}\n```\n\nAs we can see, when deposit / withdraw / harvest, the pending reward is transferred from master chef contract to msg.sender (which is the lp wrapper contract).\n\nWhen calling extraRewarder.onModify, the reward is transferred from extra rewarder to wrapper contract.\n\nBut someone needs to transfer the moe token into the master chef to ensure there is sufficient reward token balance.\n\nSomeone needs to transfer the reward token into extraReward contract to ensure there is sufficient reward token balance.\n\nIn case when there are insufficient reward token in master chef contract and extraReward, the code will revert:\n\n```solidity\n\tif (moeReward > 0) _moe.safeTransfer(account, moeReward);\n\n\tif (address(extraRewarder) != address(0)) {\n\t\textraRewarder.onModify(account, pid, oldBalance, newBalance, oldTotalSupply);\n\t}\n```\n\nSuppose the reward accounting update is that the wlp contract is entitled to get 10000 moe token and 100 usdc token as extra reward, but in master chef there are only 9000 token, attempting to transfer the 10000 more tokens will revert.\n\nThe impact is severe because this revert would block [lp unwrap](https://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/wrapper/WLpMoeMasterChef.sol#L145) and block original lp owner attemps to [decollateralize wlp](https://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/core/InitCore.sol#L284) and make liquidation revert as well.\n\n### Recommended Mitigation Steps\n\nWhen regular withdraw failed, the code should call [emergencyWithdraw](https://github.com/traderjoe-xyz/moe-core/blob/5eb20a10cbe4ee01f8db20da950309cb297e3c09/src/MasterChef.sol#L287).\n\nThis function does not claim reward, but at least this function can ensure withdraw wlp when decollateralize lp or liquidation transaction does not revert.\n\n**[fez-init (INIT) acknowledged](https://github.com/code-423n4/2024-01-init-capital-invitational-findings/issues/2#issuecomment-1931372935)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-init-capital-invitational",
  "Code": [
    {
      "filename": "contracts/wrapper/WLpMoeMasterChef.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\nimport {IWrapLpERC20Upgradeable} from '../interfaces/wrapper/IWrapLpERC20Upgradeable.sol';\nimport {IMasterChefRewarder} from '../interfaces/wrapper/moe/IMasterChefRewarder.sol';\nimport {IMasterChef} from '../interfaces/wrapper/moe/IMasterChef.sol';\nimport {IMoePair} from '../interfaces/wrapper/moe/IMoePair.sol';\nimport {IMoeFactory} from '../interfaces/wrapper/moe/IMoeFactory.sol';\nimport {IInitOracle} from '../interfaces/oracle/IInitOracle.sol';\nimport {IWNative} from '../interfaces/common/IWNative.sol';\n\nimport {ERC721} from '@openzeppelin-contracts/token/ERC721/ERC721.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Math} from '@openzeppelin-contracts/utils/math/Math.sol';\nimport {EnumerableSet} from '@openzeppelin-contracts/utils/structs/EnumerableSet.sol';\nimport {ERC721Upgradeable} from '@openzeppelin-contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol';\n\ncontract WLpMoeMasterChef is IWrapLpERC20Upgradeable, ERC721Upgradeable {\n    using Math for uint;\n    using UncheckedIncrement for uint;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // constants\n    uint private constant ONE_E18 = 1e18;\n    uint private constant ONE_E36 = 1e36;\n\n    // immutables\n    address public immutable MASTER_CHEF;\n    address public immutable MOE;\n    address public immutable MOE_FACTORY;\n    address public immutable WNATIVE;\n\n    // storages\n    // id\n    uint public lastId; // last wLp id\n    // id => lp token address\n    mapping(uint => address) public lps; // lp token address for each wLp id\n    // id => lp balances\n    mapping(uint => uint) private __lpBalances; // amount of lp token for each wLp id\n    // id => pid\n    mapping(uint => uint) public pids; // masterchef pool id for each wLp id\n    // id => tokens\n    mapping(uint => EnumerableSet.AddressSet) private __rewardTokens; // reward tokens for each wLp id\n    // id => token => acc reward per share for id\n    mapping(uint => mapping(address => uint)) public idAccRewardPerShares_e18; // acc reward per share for each token in each wLp id\n    // pid => token => acc reward per share for pid\n    mapping(uint => mapping(address => uint)) public pidAccRewardPerShares_e18; // acc reward per share for each reward token in masterchef pid\n\n    // modifiers\n    modifier onlyOwner(uint _id) {\n        _require(msg.sender == _ownerOf(_id), Errors.NOT_OWNER);\n        _;\n    }\n\n    // reward update\n    modifier updateRewards(uint _pid) {\n        // add MOE to __rewardTokens set\n        __rewardTokens[_pid].add(MOE);\n        // add extraReward to __rewardTokens set if there is extraRewarder\n        (address extraRewarder, address extraRewardToken) = _getExtraRewarderAndToken(_pid);\n        if (extraRewarder != address(0)) __rewardTokens[_pid].add(extraRewardToken);\n\n        uint lpSupply = IMasterChef(MASTER_CHEF).getDeposit(_pid, address(this));\n        address[] memory ___rewardTokens = __rewardTokens[_pid].values();\n        uint[] memory _pidAccRewardPerShares_e18 = new uint[](___rewardTokens.length);\n        uint[] memory rewardBeforeAmts = new uint[](___rewardTokens.length);\n        for (uint i; i < ___rewardTokens.length; i = i.uinc()) {\n            address rewardToken = ___rewardTokens[i];\n\n            _pidAccRewardPerShares_e18[i] = pidAccRewardPerShares_e18[_pid][rewardToken];\n            rewardBeforeAmts[i] = IERC20(rewardToken).balanceOf(address(this));\n        }\n        _;\n        for (uint i; i < ___rewardTokens.length; i = i.uinc()) {\n            address rewardToken = ___rewardTokens[i];\n            if (lpSupply != 0) {\n                _pidAccRewardPerShares_e18[i] +=\n                    ((IERC20(rewardToken).balanceOf(address(this)) - rewardBeforeAmts[i]) * ONE_E18) / lpSupply;\n            }\n\n            // update global\n            pidAccRewardPerShares_e18[_pid][rewardToken] = _pidAccRewardPerShares_e18[i];\n        }\n    }\n\n    // constructor\n    constructor(address _chef, address _factory, address _wNative) {\n        _disableInitializers();\n        MASTER_CHEF = _chef;\n        MOE_FACTORY = _factory;\n        WNATIVE = _wNative;\n        MOE = address(IMasterChef(_chef).getMoe());\n    }\n\n    // initializer\n    /// @dev initialize the contract, set the ERC721's name and symbol\n    /// @param _name ERC721's name\n    /// @param _symbol ERC721's symbol\n    function initialize(string calldata _name, string calldata _symbol) external initializer {\n        __ERC721_init(_name, _symbol);\n    }\n\n    // functions\n    // @inheritdoc IWrapLpERC20Upgradeable\n    function rewardTokens(uint _id) external view returns (address[] memory tokens) {\n        tokens = __rewardTokens[pids[_id]].values();\n    }\n\n    // @inheritdoc IWrapLpERC20Upgradeable\n    function wrap(address _lp, uint _amt, address _to, bytes calldata _extraData) external returns (uint id) {\n        // validate _lp is a moe pair\n        uint pid = abi.decode(_extraData, (uint));\n        _require(address(IMasterChef(MASTER_CHEF).getToken(pid)) == _lp, Errors.INCORRECT_PAIR);\n\n        // receive lp and records\n        IERC20(_lp).safeTransferFrom(msg.sender, address(this), _amt);\n        id = ++lastId;\n        lps[id] = _lp;\n        pids[id] = pid;\n        __lpBalances[id] = _amt;\n\n        // approve lp to masterchef\n        IERC20(_lp).safeApprove(MASTER_CHEF, _amt);\n\n        // deposit to masterchef\n        _depositToMasterChef(pid, _amt);\n\n        // update idAccRewardPerShares_e18\n        address[] memory ___rewardTokens = __rewardTokens[pid].values();\n        for (uint i; i < ___rewardTokens.length; i = i.uinc()) {\n            address rewardToken = ___rewardTokens[i];\n            idAccRewardPerShares_e18[id][rewardToken] = pidAccRewardPerShares_e18[pid][rewardToken];\n        }\n\n        // mint\n        _mint(_to, id);\n    }\n\n    // @inheritdoc IWrapLpERC20Upgradeable\n    // @return amtOut amount of lp token out\n    function unwrap(uint _id, uint _amt, address _to) external onlyOwner(_id) returns (bytes memory amtOut) {\n        // get user's balance\n        uint lpBalance = __lpBalances[_id];\n\n        // update records\n        __lpBalances[_id] = lpBalance - _amt;\n\n        // withdraw from masterchef\n        _withdrawFromMasterChef(pids[_id], _amt);\n\n        // transfer lp back\n        IERC20(lps[_id]).safeTransfer(_to, _amt);\n\n        // transfer reward tokens\n        _transferRewards(_id, lpBalance, _to);\n\n        amtOut = abi.encode(_amt);\n    }\n\n    // @inheritdoc IWrapLpERC20Upgradeable\n    function harvest(uint _id, address _to)\n        external\n        onlyOwner(_id)\n        returns (address[] memory tokens, uint[] memory amts)\n    {\n        // claim rewardToken from masterchef\n        _claimFromMasterChef(pids[_id]);\n\n        // transfer reward tokens\n        (tokens, amts) = _transferRewards(_id, __lpBalances[_id], _to);\n    }\n\n    // @inheritdoc IWrapLpERC20Upgradeable\n    function lp(uint _id) external view returns (address) {\n        return lps[_id];\n    }\n\n    // @inheritdoc IWrapLpERC20Upgradeable\n    function balanceOfLp(uint _id) external view returns (uint) {\n        return __lpBalances[_id];\n    }\n\n    // @inheritdoc IWrapLpERC20Upgradeable\n    function underlyingTokens(uint _id) external view returns (address[] memory tokens) {\n        tokens = new address[](2);\n        address _lp = lps[_id];\n        (tokens[0], tokens[1]) = (IMoePair(_lp).token0(), IMoePair(_lp).token1());\n    }\n\n    // @inheritdoc IWrapLpERC20Upgradeable\n    function calculatePrice_e36(uint _id, address _oracle) external view returns (uint price) {\n        address _lp = lps[_id];\n\n        address[] memory tokens = new address[](2);\n        (tokens[0], tokens[1]) = (IMoePair(_lp).token0(), IMoePair(_lp).token1());\n        (uint r0, uint r1,) = IMoePair(_lp).getReserves();\n        uint[] memory prices_e36 = IInitOracle(_oracle).getPrices_e36(tokens);\n\n        uint kLast = IMoePair(_lp).kLast();\n        uint totalSupply = IMoePair(_lp).totalSupply();\n\n        if (kLast == 0) {\n            // price = 2 * sqrt(r0 * p0) * sqrt(r1 * p1) / totalSupply\n            price = 2 * (r0 * prices_e36[0]).sqrt() * (r1 * prices_e36[1]).sqrt() / totalSupply;\n        } else {\n            // price = 2 * sqrt(klast * (p0 * p1 / totalSupply) / totalSupply)\n            price = 2 * (kLast.mulDiv(prices_e36[0].mulDiv(prices_e36[1], totalSupply), totalSupply)).sqrt();\n        }\n    }\n\n    /// @dev get wLp pending reward tokens\n    /// @param _id wLp id\n    /// @return tokens pending rewardToken tokens\n    /// @return amts amount of pending rewardToken tokens\n    function getPendingRewards(uint _id) external view returns (address[] memory tokens, uint[] memory amts) {\n        // get pending rewards from masterchef\n        uint pid = pids[_id];\n        uint[] memory _pids = new uint[](1);\n        _pids[0] = pid;\n        (uint[] memory moeRewards,, uint[] memory extraRewards) =\n            IMasterChef(MASTER_CHEF).getPendingRewards(address(this), _pids);\n        (address extraRewarder, address extraToken) = _getExtraRewarderAndToken(pid);\n\n        // update reward tokens (note: this does not modify state)\n        {\n            uint numToken = __rewardTokens[pid].length();\n            if (extraRewarder != address(0) && !__rewardTokens[pid].contains(extraToken)) {\n                tokens = new address[](numToken + 1);\n                for (uint i; i < numToken; i = i.uinc()) {\n                    tokens[i] = __rewardTokens[pid].at(i);\n                }\n                tokens[numToken] = extraToken;\n            } else {\n                // extraRewarder == address(0) or extraToken is alr in __rewardTokens[pid]\n                tokens = new address[](numToken);\n                tokens = __rewardTokens[pid].values();\n            }\n        }\n\n        uint lpSupply = IMasterChef(MASTER_CHEF).getDeposit(pid, address(this));\n        //  currentAccRewardPerShares_e18\n        uint[] memory currentAccRewardPerShares_e18 = new uint[](tokens.length);\n        for (uint i; i < tokens.length; i = i.uinc()) {\n            if (tokens[i] == MOE) {\n                currentAccRewardPerShares_e18[i] =\n                    pidAccRewardPerShares_e18[pid][MOE] + moeRewards[0] * ONE_E18 / lpSupply;\n            } else if (tokens[i] == extraToken) {\n                currentAccRewardPerShares_e18[i] =\n                    pidAccRewardPerShares_e18[pid][extraToken] + extraRewards[0] * ONE_E18 / lpSupply;\n            } else {\n                currentAccRewardPerShares_e18[i] = pidAccRewardPerShares_e18[pid][tokens[i]];\n            }\n        }\n\n        amts = new uint[](tokens.length);\n\n        // calculate pending __rewardTokens\n        for (uint i; i < tokens.length; i = i.uinc()) {\n            amts[i] = (currentAccRewardPerShares_e18[i] - idAccRewardPerShares_e18[_id][tokens[i]]) * __lpBalances[_id]\n                / ONE_E18;\n        }\n    }\n\n    /// @dev get lp extra rewardToken token address\n    /// @param _pid Moe masterchef pool's id\n    /// @return extraRewarder address of the extraRewarder\n    /// @return extraToken address of the extraReward Token\n    function _getExtraRewarderAndToken(uint _pid) internal view returns (address extraRewarder, address extraToken) {\n        // check if extra rewarder of farm is set before call\n        extraRewarder = address(IMasterChef(MASTER_CHEF).getExtraRewarder(_pid));\n        if (address(extraRewarder) != address(0)) {\n            // check if the extra reward is a native token\n            extraToken = address(IMasterChefRewarder(extraRewarder).getToken());\n            if (extraToken == address(0)) extraToken = WNATIVE;\n        }\n    }\n\n    /// @dev update rewards and deposit to masterchef\n    /// @param _pid Moe masterchef pool's id\n    function _depositToMasterChef(uint _pid, uint _amt) internal updateRewards(_pid) {\n        IMasterChef(MASTER_CHEF).deposit(_pid, _amt);\n    }\n\n    /// @dev update rewards and withdraw from masterchef\n    /// @param _pid Moe masterchef pool's id\n    function _withdrawFromMasterChef(uint _pid, uint _amt) internal updateRewards(_pid) {\n        IMasterChef(MASTER_CHEF).withdraw(_pid, _amt);\n    }\n\n    /// @dev update rewardToken and claim reward tokens from masterchef\n    /// @param _pid Moe masterchef pool's id\n    function _claimFromMasterChef(uint _pid) internal updateRewards(_pid) {\n        uint[] memory _pids = new uint[](1);\n        _pids[0] = _pid;\n\n        // claim reward tokens from masterchef\n        IMasterChef(MASTER_CHEF).claim(_pids);\n    }\n\n    /// @notice claim all reward tokens and update idAccRewardPerShares_e18 to the current pidAccRewardPerShares_e18\n    /// @dev update rewardToken and claim reward tokens from masterchef\n    /// @param _id wLp's id to transfer reward tokens\n    /// @param _amt share amount to transfer reward tokens\n    /// @param _to address to transfer reward tokens to\n    function _transferRewards(uint _id, uint _amt, address _to)\n        internal\n        returns (address[] memory tokens, uint[] memory amts)\n    {\n        uint pid = pids[_id];\n        tokens = __rewardTokens[pid].values();\n        amts = new uint[](tokens.length);\n\n        for (uint i; i < tokens.length; i = i.uinc()) {\n            address rewardToken = tokens[i];\n            uint amt = (pidAccRewardPerShares_e18[pid][rewardToken] - idAccRewardPerShares_e18[_id][rewardToken]) * _amt\n                / ONE_E18;\n            amts[i] = amt;\n            // update idAccRewardPerShares_e18\n            idAccRewardPerShares_e18[_id][rewardToken] = pidAccRewardPerShares_e18[pid][rewardToken];\n\n            if (amt > 0) IERC20(rewardToken).safeTransfer(_to, amt);\n        }\n    }\n\n    receive() external payable {\n        // wrap native token to wrap native on receive\n        IWNative(WNATIVE).deposit{value: msg.value}();\n    }\n}"
    },
    {
      "filename": "contracts/core/InitCore.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport {Multicall} from '../common/Multicall.sol';\nimport '../common/library/InitErrors.sol';\nimport '../common/library/ArrayLib.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\n\nimport {IInitCore} from '../interfaces/core/IInitCore.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {PoolConfig, TokenFactors, ModeStatus, IConfig} from '../interfaces/core/IConfig.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IBaseWrapLp} from '../interfaces/wrapper/IBaseWrapLp.sol';\nimport {IInitOracle} from '../interfaces/oracle/IInitOracle.sol';\nimport {ILiqIncentiveCalculator} from '../interfaces/core/ILiqIncentiveCalculator.sol';\nimport {ICallbackReceiver} from '../interfaces/receiver/ICallbackReceiver.sol';\nimport {IFlashReceiver} from '../interfaces/receiver/IFlashReceiver.sol';\nimport {IRiskManager} from '../interfaces/risk_manager/IRiskManager.sol';\n\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport {SafeCast} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {MathUpgradeable} from '@openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {EnumerableSet} from '@openzeppelin-contracts/utils/structs/EnumerableSet.sol';\n\ncontract InitCore is IInitCore, Multicall, ReentrancyGuardUpgradeable, UnderACM {\n    using SafeCast for uint;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using MathUpgradeable for uint;\n    using UncheckedIncrement for uint;\n\n    // constants\n    uint private constant ONE_E18 = 1e18;\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n    bytes32 private constant GOVERNOR = keccak256('governor');\n\n    // immutables\n    address public immutable POS_MANAGER;\n\n    // storages\n    address public config; // @inheritdoc IInitCore\n    address public oracle; // @inheritdoc IInitCore\n    address public liqIncentiveCalculator; // @inheritdoc IInitCore\n    address public riskManager; // @inheritdoc IInitCore\n    bool internal isMulticallTx;\n    EnumerableSet.UintSet internal uncheckedPosIds; // posIds that need to be checked after multicall\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyGovernor() {\n        ACM.checkRole(GOVERNOR, msg.sender);\n        _;\n    }\n\n    modifier onlyAuthorized(uint _posId) {\n        _require(IPosManager(POS_MANAGER).isAuthorized(msg.sender, _posId), Errors.NOT_AUTHORIZED);\n        _;\n    }\n\n    /// @dev keep track of the position and ensure that the position is healthy at the very end\n    /// @param _posId pos id to ensure health\n    modifier ensurePositionHealth(uint _posId) {\n        if (isMulticallTx) uncheckedPosIds.add(_posId);\n        _;\n        if (!isMulticallTx) _require(_isPosHealthy(_posId), Errors.POSITION_NOT_HEALTHY);\n    }\n\n    // constructor\n    constructor(address _posManager, address _acm) UnderACM(_acm) {\n        POS_MANAGER = _posManager;\n        _disableInitializers();\n    }\n\n    // initalize\n    /// @dev initialize contract and setup config, oracle, incentive calculator and risk manager addresses\n    /// @param _config config address\n    /// @param _oracle oracle address\n    /// @param _liqIncentiveCalculator liquidation incentive calculator address\n    /// @param _riskManager risk manager address\n    function initialize(address _config, address _oracle, address _liqIncentiveCalculator, address _riskManager)\n        external\n        initializer\n    {\n        __ReentrancyGuard_init();\n        _setConfig(_config);\n        _setOracle(_oracle);\n        _setLiqIncentiveCalculator(_liqIncentiveCalculator);\n        _setRiskManager(_riskManager);\n    }\n\n    // functions\n    /// @inheritdoc IInitCore\n    function mintTo(address _pool, address _to) public virtual nonReentrant returns (uint shares) {\n        // check pool status\n        PoolConfig memory poolConfig = IConfig(config).getPoolConfig(_pool);\n        _require(poolConfig.canMint, Errors.MINT_PAUSED);\n        // call mint at pool using _to\n        shares = ILendingPool(_pool).mint(_to);\n        // check supply cap after mint\n        _require(ILendingPool(_pool).totalAssets() <= poolConfig.supplyCap, Errors.SUPPLY_CAP_REACHED);\n    }\n\n    /// @inheritdoc IInitCore\n    function burnTo(address _pool, address _to) public virtual nonReentrant returns (uint amt) {\n        // check pool status\n        PoolConfig memory poolConfig = IConfig(config).getPoolConfig(_pool);\n        _require(poolConfig.canBurn, Errors.REDEEM_PAUSED);\n        // call burn at pool using _to\n        amt = ILendingPool(_pool).burn(_to);\n    }\n\n    /// @inheritdoc IInitCore\n    function borrow(address _pool, uint _amt, uint _posId, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n        returns (uint shares)\n    {\n        IConfig _config = IConfig(config);\n        // check pool and mode status\n        PoolConfig memory poolConfig = _config.getPoolConfig(_pool);\n        uint16 mode = _getPosMode(_posId);\n        // check if the mode is allow to borrow\n        _require(poolConfig.canBorrow && _config.getModeStatus(mode).canBorrow, Errors.BORROW_PAUSED);\n        // check if the position mode supports _pool\n        _require(_config.isAllowedForBorrow(mode, _pool), Errors.INVALID_MODE);\n        // get borrow shares (accrue interest)\n        shares = ILendingPool(_pool).debtAmtToShareCurrent(_amt);\n        // check shares != 0\n        _require(shares != 0, Errors.ZERO_VALUE);\n        // check borrow cap after borrow\n        _require(ILendingPool(_pool).totalDebt() + _amt <= poolConfig.borrowCap, Errors.BORROW_CAP_REACHED);\n        // update debt on the position\n        IPosManager(POS_MANAGER).updatePosDebtShares(_posId, _pool, shares.toInt256());\n        // call borrow from the pool with target _to\n        ILendingPool(_pool).borrow(_to, _amt);\n        // update debt on mode\n        IRiskManager(riskManager).updateModeDebtShares(mode, _pool, shares.toInt256());\n        emit Borrow(_pool, _posId, _to, _amt, shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function repay(address _pool, uint _shares, uint _posId)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        nonReentrant\n        returns (uint amt)\n    {\n        (, amt) = _repay(IConfig(config), _getPosMode(_posId), _posId, _pool, _shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function createPos(uint16 _mode, address _viewer) public virtual nonReentrant returns (uint posId) {\n        _require(_mode != 0, Errors.INVALID_MODE);\n        posId = IPosManager(POS_MANAGER).createPos(msg.sender, _mode, _viewer);\n        emit CreatePosition(msg.sender, posId, _mode, _viewer);\n    }\n\n    /// @inheritdoc IInitCore\n    function setPosMode(uint _posId, uint16 _mode)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        // get current collaterals in the position\n        (address[] memory pools,, address[] memory wLps, uint[][] memory ids,) =\n            IPosManager(POS_MANAGER).getPosCollInfo(_posId);\n\n        uint16 currentMode = _getPosMode(_posId);\n        ModeStatus memory currentModeStatus = _config.getModeStatus(currentMode);\n        ModeStatus memory newModeStatus = _config.getModeStatus(_mode);\n        if (pools.length != 0 || wLps.length != 0) {\n            _require(newModeStatus.canCollateralize, Errors.COLLATERALIZE_PAUSED);\n            _require(currentModeStatus.canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        }\n        // check that each position collateral belongs to the _mode\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForCollateral(_mode, pools[i]), Errors.INVALID_MODE);\n        }\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            // check if the wLp is whitelisted\n            _require(_config.whitelistedWLps(wLps[i]), Errors.TOKEN_NOT_WHITELISTED);\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                _require(_config.isAllowedForCollateral(_mode, IBaseWrapLp(wLps[i]).lp(ids[i][j])), Errors.INVALID_MODE);\n            }\n        }\n        // validate max wLp count\n        _validateModeMaxWLpCount(_config, _mode, _posId);\n        // get current debts in the position\n        uint[] memory shares;\n        (pools, shares) = IPosManager(POS_MANAGER).getPosBorrInfo(_posId);\n        IRiskManager _riskManager = IRiskManager(riskManager);\n        _require(newModeStatus.canBorrow, Errors.BORROW_PAUSED);\n        _require(currentModeStatus.canRepay && newModeStatus.canRepay, Errors.REPAY_PAUSED);\n        // check that each position debt belongs to the _mode\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForBorrow(_mode, pools[i]), Errors.INVALID_MODE);\n            // update debt on current mode\n            _riskManager.updateModeDebtShares(currentMode, pools[i], -shares[i].toInt256());\n            // update debt on new mode\n            _riskManager.updateModeDebtShares(_mode, pools[i], shares[i].toInt256());\n        }\n        // update position mode\n        IPosManager(POS_MANAGER).updatePosMode(_posId, _mode);\n        emit SetPositionMode(_posId, _mode);\n    }\n\n    /// @inheritdoc IInitCore\n    function collateralize(uint _posId, address _pool) public virtual onlyAuthorized(_posId) nonReentrant {\n        IConfig _config = IConfig(config);\n        // check mode status\n        uint16 mode = _getPosMode(_posId);\n        _require(_config.getModeStatus(mode).canCollateralize, Errors.COLLATERALIZE_PAUSED);\n        // check if the position mode supports _pool\n        _require(_config.isAllowedForCollateral(mode, _pool), Errors.INVALID_MODE);\n        // update collateral on the position\n        uint amtColl = IPosManager(POS_MANAGER).addCollateral(_posId, _pool);\n        emit Collateralize(_posId, _pool, amtColl);\n    }\n\n    /// @inheritdoc IInitCore\n    function decollateralize(uint _posId, address _pool, uint _shares, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        // check mode status\n        _require(IConfig(config).getModeStatus(_getPosMode(_posId)).canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        // take _pool from position to _to\n        uint amtDecoll = IPosManager(POS_MANAGER).removeCollateralTo(_posId, _pool, _shares, _to);\n        emit Decollateralize(_posId, _pool, _to, amtDecoll);\n    }\n\n    /// @inheritdoc IInitCore\n    function collateralizeWLp(uint _posId, address _wLp, uint _tokenId)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        uint16 mode = _getPosMode(_posId);\n        // check mode status\n        _require(_config.getModeStatus(mode).canCollateralize, Errors.COLLATERALIZE_PAUSED);\n        // check if the wLp is whitelisted\n        _require(_config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED);\n        // check if the position mode supports _wLp\n        _require(_config.isAllowedForCollateral(mode, IBaseWrapLp(_wLp).lp(_tokenId)), Errors.INVALID_MODE);\n        // update collateral on the position\n        uint amtColl = IPosManager(POS_MANAGER).addCollateralWLp(_posId, _wLp, _tokenId);\n        // validate max wLp count\n        _validateModeMaxWLpCount(_config, mode, _posId);\n        emit CollateralizeWLp(_posId, _wLp, _tokenId, amtColl);\n    }\n\n    /// @inheritdoc IInitCore\n    function decollateralizeWLp(uint _posId, address _wLp, uint _tokenId, uint _amt, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        // check mode status\n        _require(_config.getModeStatus(_getPosMode(_posId)).canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        // check wLp is whitelisted\n        _require(_config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED);\n        // update and take _wLp from position to _to\n        uint amtDecoll = IPosManager(POS_MANAGER).removeCollateralWLpTo(_posId, _wLp, _tokenId, _amt, _to);\n        emit DecollateralizeWLp(_posId, _wLp, _tokenId, _to, amtDecoll);\n    }\n\n    /// @inheritdoc IInitCore\n    function liquidate(uint _posId, address _poolToRepay, uint _repayShares, address _poolOut, uint _minShares)\n        public\n        virtual\n        nonReentrant\n        returns (uint shares)\n    {\n        LiquidateLocalVars memory vars = _liquidateInternal(_posId, _poolToRepay, _repayShares);\n\n        _require(vars.config.isAllowedForCollateral(vars.mode, _poolOut), Errors.TOKEN_NOT_WHITELISTED); // config and mode are already stored\n\n        vars.collToken = ILendingPool(_poolOut).underlyingToken();\n        vars.liqIncentive_e18 = ILiqIncentiveCalculator(liqIncentiveCalculator).getLiqIncentiveMultiplier_e18(\n            vars.mode, vars.health_e18, vars.repayToken, vars.collToken\n        );\n        vars.repayAmtWithLiqIncentive = (vars.repayAmt * vars.liqIncentive_e18) / ONE_E18;\n        {\n            uint[] memory prices_e36; // prices = [repayTokenPrice, collToken]\n            address[] memory tokens = new address[](2);\n            (tokens[0], tokens[1]) = (vars.repayToken, vars.collToken);\n            prices_e36 = IInitOracle(oracle).getPrices_e36(tokens);\n            // calculate _tokenOut amt to return to liquidator\n            shares = ILendingPool(_poolOut).toShares((vars.repayAmtWithLiqIncentive * prices_e36[0]) / prices_e36[1]);\n            // take min of what's available (for bad debt repayment)\n            shares = shares.min(IPosManager(POS_MANAGER).getCollAmt(_posId, _poolOut)); // take min of what's available\n            _require(shares >= _minShares, Errors.SLIPPAGE_CONTROL);\n        }\n        // take _tokenOut from position to msg.sender\n        if (shares > 0) IPosManager(POS_MANAGER).removeCollateralTo(_posId, _poolOut, shares, msg.sender);\n        // check that position's health <= maxHealth\n        // NOTE: bypass this for underwater position\n        if (vars.health_e18 != 0) _ensurePosHealthAfterLiq(vars.config, _posId, vars.mode);\n        emit Liquidate(_posId, msg.sender, _poolOut, shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function liquidateWLp(\n        uint _posId,\n        address _poolToRepay,\n        uint _repayShares,\n        address _wLp,\n        uint _tokenId,\n        uint _minlpOut\n    ) external virtual nonReentrant returns (uint lpAmtOut) {\n        LiquidateLocalVars memory vars = _liquidateInternal(_posId, _poolToRepay, _repayShares);\n\n        _require(vars.config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED); // config is already stored\n\n        vars.collToken = IBaseWrapLp(_wLp).lp(_tokenId);\n\n        vars.liqIncentive_e18 = ILiqIncentiveCalculator(liqIncentiveCalculator).getLiqIncentiveMultiplier_e18(\n            vars.mode, vars.health_e18, vars.repayToken, vars.collToken\n        );\n        vars.repayAmtWithLiqIncentive = (vars.repayAmt * vars.liqIncentive_e18) / ONE_E18;\n\n        uint wLpAmtToBurn;\n        {\n            address _oracle = oracle;\n            uint wLpAmt = IPosManager(POS_MANAGER).getCollWLpAmt(_posId, _wLp, _tokenId);\n            wLpAmtToBurn = IInitOracle(_oracle).getPrice_e36(vars.repayToken).mulDiv(\n                vars.repayAmtWithLiqIncentive, IBaseWrapLp(_wLp).calculatePrice_e36(_tokenId, _oracle)\n            );\n            // take min of what's available (for bad debt repayment)\n            wLpAmtToBurn = wLpAmtToBurn.min(wLpAmt);\n        }\n        // reduce and burn wLp to underlying for liquidator\n        if (wLpAmtToBurn > 0) {\n            lpAmtOut = IPosManager(POS_MANAGER).removeCollateralWLpTo(_posId, _wLp, _tokenId, wLpAmtToBurn, msg.sender);\n        }\n        _require(lpAmtOut >= _minlpOut, Errors.SLIPPAGE_CONTROL);\n        // check that position's health <= maxHealth\n        // NOTE: bypass this for underwater position\n        if (vars.health_e18 != 0) _ensurePosHealthAfterLiq(vars.config, _posId, vars.mode);\n        emit LiquidateWLp(_posId, msg.sender, _wLp, _tokenId, wLpAmtToBurn);\n    }\n\n    /// @inheritdoc IInitCore\n    function flash(address[] calldata _pools, uint[] calldata _amts, bytes calldata _data)\n        public\n        virtual\n        nonReentrant\n    {\n        // validate _pools and _amts length & validate _pools contain distinct addresses to avoid paying less flash fees\n        _require(_validateFlash(_pools, _amts), Errors.INVALID_FLASHLOAN);\n        // check that is not multicall tx\n        _require(!isMulticallTx, Errors.LOCKED_MULTICALL);\n        uint[] memory balanceBefores = new uint[](_pools.length);\n        address[] memory tokens = new address[](_pools.length);\n        IConfig _config = IConfig(config);\n        for (uint i; i < _pools.length; i = i.uinc()) {\n            PoolConfig memory poolConfig = _config.getPoolConfig(_pools[i]);\n            // check that flash is enabled\n            _require(poolConfig.canFlash, Errors.FLASH_PAUSED);\n            address token = ILendingPool(_pools[i]).underlyingToken();\n            tokens[i] = token;\n            // calculate return amt\n            balanceBefores[i] = IERC20(token).balanceOf(_pools[i]);\n            // take _amts[i] of _pools[i] to msg.sender\n            IERC20(token).safeTransferFrom(_pools[i], msg.sender, _amts[i]);\n        }\n        // execute callback\n        IFlashReceiver(msg.sender).flashCallback(_pools, _amts, _data);\n        // check pool balance after callback\n        for (uint i; i < _pools.length; i = i.uinc()) {\n            _require(IERC20(tokens[i]).balanceOf(_pools[i]) >= balanceBefores[i], Errors.INVALID_AMOUNT_TO_REPAY);\n        }\n    }\n\n    /// @dev multicall function with health check after all call\n    function multicall(bytes[] calldata data) public payable virtual override returns (bytes[] memory results) {\n        _require(!isMulticallTx, Errors.LOCKED_MULTICALL);\n        isMulticallTx = true;\n        // multicall\n        results = super.multicall(data);\n        // === loop uncheckedPosIds ===\n        uint[] memory posIds = uncheckedPosIds.values();\n        for (uint i; i < posIds.length; i = i.uinc()) {\n            // check position health\n            _require(_isPosHealthy(posIds[i]), Errors.POSITION_N"
    }
  ]
}