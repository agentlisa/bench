{
  "Title": "WrappedTokenBridge#recoverTokens will drain the whole token balance",
  "Content": "# WrappedTokenBridge#recoverTokens will drain the whole token balance\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/WrappedTokenBridge.sol#L140-L147\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/WrappedTokenBridge.sol#L140-L147</a>\n\n\n## Summary\n`recoverTokens` is supposed to retrieve tokens accidentally sent to the contract. However, if this function is called to recover the bridge's `token`, `wrappedToken`, or `LINK`, it will drain the whole balance of the contract, instead of just the amount that was sent by mistake.\n\n## Impact\nBridge's token balance would be drained.\n\n## Recommendations\nEither add the amount to recover as a function parameter, or disable recovery of these tokens.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/ccip/WrappedTokenBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IWrappedLST.sol\";\n\n/**\n * @title Wrapped token bridge\n * @notice Handles CCIP transfers with a wrapped token\n * @dev This contract can perform 2 functions:\n * - can wrap tokens and initiate a CCIP transfer of the wrapped tokens to a destination chain\n * - can receive a CCIP transfer of wrapped tokens, unwrap them, and send them to the receiver\n */\ncontract WrappedTokenBridge is Ownable, CCIPReceiver {\n    using SafeERC20 for IERC20;\n\n    IERC20 linkToken;\n\n    IERC20 token;\n    IWrappedLST wrappedToken;\n\n    event TokensTransferred(\n        bytes32 indexed messageId,\n        uint64 indexed destinationChainSelector,\n        address indexed sender,\n        address receiver,\n        uint256 tokenAmount,\n        address feeToken,\n        uint256 fees\n    );\n    event TokensReceived(\n        bytes32 indexed messageId,\n        uint64 indexed sourceChainSelector,\n        address indexed sender,\n        address receiver,\n        uint256 tokenAmount\n    );\n\n    error InvalidSender();\n    error InvalidValue();\n    error InsufficientFee();\n    error TransferFailed();\n    error FeeExceedsLimit();\n    error InvalidMessage();\n    error InvalidMsgValue();\n    error InvalidReceiver();\n\n    /**\n     * @notice Initializes the contract\n     * @param _router address of the CCIP router\n     * @param _linkToken address of the LINK token\n     * @param _token address of the unwrapped token\n     * @param _wrappedToken address of the wrapped token\n     **/\n    constructor(\n        address _router,\n        address _linkToken,\n        address _token,\n        address _wrappedToken\n    ) CCIPReceiver(_router) {\n        linkToken = IERC20(_linkToken);\n\n        token = IERC20(_token);\n        wrappedToken = IWrappedLST(_wrappedToken);\n\n        linkToken.approve(_router, type(uint256).max);\n        token.approve(_wrappedToken, type(uint256).max);\n        wrappedToken.approve(_router, type(uint256).max);\n    }\n\n    /**\n     * @notice ERC677 implementation to receive a token transfer to be wrapped and sent to a destination chain\n     * @param _sender address of sender\n     * @param _value amount of tokens transferred\n     * @param _calldata encoded calldata consisting of destinationChainSelector (uint64), receiver (address),\n     * maxLINKFee (uint256)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external {\n        if (msg.sender != address(token)) revert InvalidSender();\n        if (_value == 0) revert InvalidValue();\n\n        (uint64 destinationChainSelector, address receiver, uint256 maxLINKFee) = abi.decode(\n            _calldata,\n            (uint64, address, uint256)\n        );\n        _transferTokens(destinationChainSelector, _sender, receiver, _value, false, maxLINKFee);\n    }\n\n    /**\n     * @notice Wraps and transfers tokens to a destination chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _receiver address to receive tokens on destination chain\n     * @param _amount amount of tokens to transfer\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @param _maxLINKFee call will revert if LINK fee exceeds this value\n     **/\n    function transferTokens(\n        uint64 _destinationChainSelector,\n        address _receiver,\n        uint256 _amount,\n        bool _payNative,\n        uint256 _maxLINKFee\n    ) external payable onlyOwner returns (bytes32 messageId) {\n        if (_payNative == false && msg.value != 0) revert InvalidMsgValue();\n\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        return _transferTokens(_destinationChainSelector, msg.sender, _receiver, _amount, _payNative, _maxLINKFee);\n    }\n\n    /**\n     * @notice Returns the current fee for a token transfer\n     * @param _destinationChainSelector id of destination chain\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @return fee current fee\n     **/\n    function getFee(uint64 _destinationChainSelector, bool _payNative) external view returns (uint256) {\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            address(this),\n            1000 ether,\n            _payNative ? address(0) : address(linkToken)\n        );\n\n        return IRouterClient(this.getRouter()).getFee(_destinationChainSelector, evm2AnyMessage);\n    }\n\n    /**\n     * @notice Recovers tokens that were accidentally sent to this contract\n     * @param _tokens list of tokens to recover\n     * @param _receiver address to receive recovered tokens\n     **/\n    function recoverTokens(address[] calldata _tokens, address _receiver) external onlyOwner {\n        if (_receiver == address(0)) revert InvalidReceiver();\n\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            IERC20 tokenToTransfer = IERC20(_tokens[i]);\n            tokenToTransfer.safeTransfer(_receiver, tokenToTransfer.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @notice Wraps and transfers tokens to a destination chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _sender address of token sender\n     * @param _receiver address to receive tokens on destination chain\n     * @param _amount amount of tokens to transfer\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @param _maxLINKFee call will revert if LINK fee exceeds this value\n     **/\n    function _transferTokens(\n        uint64 _destinationChainSelector,\n        address _sender,\n        address _receiver,\n        uint256 _amount,\n        bool _payNative,\n        uint256 _maxLINKFee\n    ) internal returns (bytes32 messageId) {\n        uint256 preWrapBalance = wrappedToken.balanceOf(address(this));\n        wrappedToken.wrap(_amount);\n        uint256 amountToTransfer = wrappedToken.balanceOf(address(this)) - preWrapBalance;\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            _receiver,\n            amountToTransfer,\n            _payNative ? address(0) : address(linkToken)\n        );\n\n        IRouterClient router = IRouterClient(this.getRouter());\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (_payNative) {\n            if (fees > msg.value) revert InsufficientFee();\n            messageId = router.ccipSend{value: fees}(_destinationChainSelector, evm2AnyMessage);\n            if (fees < msg.value) {\n                (bool success, ) = _sender.call{value: msg.value - fees}(\"\");\n                if (!success) revert TransferFailed();\n            }\n        } else {\n            if (fees > _maxLINKFee) revert FeeExceedsLimit();\n            linkToken.safeTransferFrom(_sender, address(this), fees);\n            messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\n        }\n\n        emit TokensTransferred(\n            messageId,\n            _destinationChainSelector,\n            _sender,\n            _receiver,\n            amountToTransfer,\n            _payNative ? address(0) : address(linkToken),\n            fees\n        );\n        return messageId;\n    }\n\n    /**\n     * @notice Builds a CCIP message\n     * @param _receiver address to receive tokens on destination chain\n     * @param _amount amount of tokens to transfer\n     * @param _feeTokenAddress address of token that fees will be paid in\n     **/\n    function _buildCCIPMessage(\n        address _receiver,\n        uint256 _amount,\n        address _feeTokenAddress\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({token: address(wrappedToken), amount: _amount});\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_receiver),\n            data: \"\",\n            tokenAmounts: tokenAmounts,\n            extraArgs: \"0x\",\n            feeToken: _feeTokenAddress\n        });\n\n        return evm2AnyMessage;\n    }\n\n    /**\n     * @notice Processes a received message\n     * @param _message CCIP message\n     **/\n    function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        if (_message.destTokenAmounts.length != 1) revert InvalidMessage();\n\n        address tokenAddress = _message.destTokenAmounts[0].token;\n        uint256 tokenAmount = _message.destTokenAmounts[0].amount;\n        address receiver = abi.decode(_message.data, (address));\n\n        if (tokenAddress != address(wrappedToken) || receiver == address(0)) revert InvalidMessage();\n\n        uint256 preUnwrapBalance = token.balanceOf(address(this));\n        wrappedToken.unwrap(tokenAmount);\n        uint256 amountToTransfer = token.balanceOf(address(this)) - preUnwrapBalance;\n        token.safeTransfer(receiver, amountToTransfer);\n\n        emit TokensReceived(\n            _message.messageId,\n            _message.sourceChainSelector,\n            abi.decode(_message.sender, (address)),\n            receiver,\n            tokenAmount\n        );\n    }\n}"
    }
  ]
}