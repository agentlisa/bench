{
  "Title": "Rebalances are subject to sandwich attacks",
  "Content": "Rebalancing transactions are very meaningful events within the strategy lifecycle. Potentially large amounts of `WETH` and `USDC` might be involved, and given the necessary use of Uniswap V3 pools in any scenario (apart from OTC auctions) there are two potential scenarios in which placing a transaction before and after the rebalancing might be beneficial for a third party:\n\n\n* In the case of a third party willing to profit off the protocol, a `wethLimitPrice` is specified in both the [`leverageRebalance`](https://github.com/opynfinance/squeeth-monorepo/blob/521203dc26e5a2c3e26c6d4ad02d513e7df63237/packages/bull-vault/src/AuctionBull.sol#L371) and [`fullRebalance`](https://github.com/opynfinance/squeeth-monorepo/blob/521203dc26e5a2c3e26c6d4ad02d513e7df63237/packages/bull-vault/src/AuctionBull.sol#L299). This value determines the maximum slippage for each swap, so special care should be placed on the calculation of this value and the tolerance parameters in order to avoid being sandwiched out of this slippage.\n* A rebalancing event inevitably carries some costs for all the strategy depositors due to slippage, price impact and spread. This cost will always be a percentage of the entire strategy portfolio value. Any investor within the strategy can sandwich the rebalance transaction in order to exit before it happens, and re-enter it immediately afterwards. The incurred cost of doing so might be much lower than the rebalancing costs, so if executed correctly, they would avoid that extra cost at the expense of the rest of the depositors. Consider adding some restrictions in the depositing and withdrawing frequency (i.e. an individual user cannot deposit and withdraw on the same block).\n\n\nIn both cases, consider if these are relevant risks and always relay the rebalancing transaction through a private relay like [FlashBots](https://www.flashbots.net/) in order to avoid undesired reverts due to DoS attacks, and unexpected losses in slippage due to sandwich attacks.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/bull-vault/src/AuctionBull.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\n\npragma abicoder v2;\n\n// interface\nimport { IController } from \"squeeth-monorepo/interfaces/IController.sol\";\nimport { IBullStrategy } from \"./interface/IBullStrategy.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport { IEulerEToken } from \"./interface/IEulerEToken.sol\";\nimport { IEulerDToken } from \"./interface/IEulerDToken.sol\";\n// contract\nimport { Ownable } from \"openzeppelin/access/Ownable.sol\";\nimport { UniFlash } from \"./UniFlash.sol\";\nimport { UniOracle } from \"./UniOracle.sol\";\nimport { EIP712 } from \"openzeppelin/drafts/EIP712.sol\";\n// lib\nimport { StrategyMath } from \"squeeth-monorepo/strategy/base/StrategyMath.sol\"; // StrategyMath licensed under AGPL-3.0-only\nimport { ECDSA } from \"openzeppelin/cryptography/ECDSA.sol\";\n\n/**\n * Error code\n * AB0: caller is not auction manager\n * AB1: invalid delta after rebalance\n * AB2: invalid CR after rebalance\n * AB3: invalid CR lower and upper values\n * AB4: invalid delta lower and upper values\n * AB5: invalid clearing price\n * AB6: order is not taking the other side of the trade\n * AB7: current order price smaller than previous order price\n * AB8: current order price greater than previous order price\n * AB9: order price is less than clearing price\n * AB10: order price is greater than clearing price\n * AB11: order signer is different than order trader\n * AB12: order already expired\n * AB13: nonce already used\n * AB14: clearning price tolerance is too high\n * AB15: ETH limit price is out of tolerance range\n * AB16: WETH limit price tolerance is too high\n * AB17: price too low relative to Uniswap twap\n * AB18: price too high relative to Uniswap twap\n * AB19: auction manager can not be 0 address\n */\n\n/**\n * @notice AuctionBull contract\n * @author opyn team\n */\ncontract AuctionBull is UniFlash, Ownable, EIP712 {\n    using StrategyMath for uint256;\n\n    /// @dev typehash for signed orders\n    bytes32 private constant _FULL_REBALANCE_TYPEHASH = keccak256(\n        \"Order(uint256 bidId,address trader,uint256 quantity,uint256 price,bool isBuying,uint256 expiry,uint256 nonce)\"\n    );\n\n    /// @dev 1e18\n    uint256 internal constant ONE = 1e18;\n    /// @dev TWAP period\n    uint32 internal constant TWAP = 420;\n    /// @dev WETH decimals - USDC decimals\n    uint256 internal constant WETH_DECIMALS_DIFF = 1e12;\n\n    /// @dev full rebalance clearing price tolerance cannot exceed 20%\n    uint256 public constant MAX_FULL_REBALANCE_CLEARING_PRICE_TOLERANCE = 2e17; // 20%\n    /// @dev full rebalance WETH limit price tolerance cannot exceed 20%\n    uint256 public constant MAX_REBALANCE_WETH_LIMIT_PRICE_TOLERANCE = 2e17; // 20%\n\n    /// @dev USDC address\n    address private immutable usdc;\n    /// @dev WETH address\n    address private immutable weth;\n    address private immutable bullStrategy;\n    address private immutable ethWSqueethPool;\n    address private immutable ethUSDCPool;\n    address private immutable wPowerPerp;\n    address private immutable crab;\n    /// @dev euler eToken for WETH\n    address private immutable eToken;\n    /// @dev euler dToken for USDC\n    address private immutable dToken;\n\n    /// @dev highest delta the auction manager can rebalance to\n    uint256 public deltaUpper;\n    /// @dev lowest delta the auction manager can rebalance to\n    uint256 public deltaLower;\n    /// @dev highest CR the auction manager can rebalance to\n    uint256 public crUpper;\n    /// @dev lowest CR the auction manager can rebalance to\n    uint256 public crLower;\n    /// @dev full rebalance clearing price must be within this distance of the oSQTH:eth uniswap twap price\n    uint256 public fullRebalanceClearingPriceTolerance = 5e16; // 5%\n    /// @dev full rebalance WETH limit price must be within this distance of the eth:usd uniswap twap price\n    uint256 public rebalanceWethLimitPriceTolerance = 5e16; // 5%\n\n    /// @dev auction manager\n    address public auctionManager;\n\n    /// @dev store the used flag for a nonce for each address\n    mapping(address => mapping(uint256 => bool)) public nonces;\n\n    /// @dev enum to differentiate between Uniswap swap callback function source\n    enum FLASH_SOURCE {\n        LEVERAGE_REBALANCE_DECREASE_DEBT,\n        LEVERAGE_REBALANCE_INCREASE_DEBT,\n        FULL_REBALANCE_BORROW_USDC_BUY_WETH,\n        FULL_REBALANCE_REPAY_USDC_WITHDRAW_WETH,\n        FULL_REBALANCE_DEPOSIT_WETH_BORROW_USDC_DEPOSIT_INTO_CRAB,\n        FULL_REBALANCE_WITHDRAW_WETH_BORROW_USDC_DEPOSIT_INTO_CRAB\n    }\n\n    struct Order {\n        uint256 bidId;\n        address trader;\n        uint256 quantity;\n        uint256 price;\n        bool isBuying;\n        uint256 expiry;\n        uint256 nonce;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct ExecuteCrabDepositParams {\n        uint256 crabAmount;\n        uint256 wethTargetInEuler;\n        uint256 wethLimitPrice;\n        uint256 ethInCrab;\n        uint24 ethUsdcPoolFee;\n    }\n\n    struct ExecuteLeverageComponentRebalancingParams {\n        uint256 wethTargetInEuler;\n        uint256 wethLimitPrice;\n        uint24 ethUsdcPoolFee;\n    }\n\n    event SetCrUpperAndLower(\n        uint256 oldCrLower, uint256 oldCrUpper, uint256 newCrLower, uint256 newCrUpper\n    );\n    event SetDeltaUpperAndLower(\n        uint256 oldDeltaLower, uint256 oldDeltaUpper, uint256 newDeltaLower, uint256 newDeltaUpper\n    );\n    event LeverageRebalance(bool isSellingUsdc, uint256 usdcAmount, uint256 wethLimitAmount);\n\n    event FullRebalance(\n        uint256 crabAmount,\n        uint256 clearingPrice,\n        bool isDepositingInCrab,\n        uint256 wPowerPerpAmount,\n        uint256 wethTargetInEuler\n    );\n\n    event SetFullRebalanceClearingPriceTolerance(\n        uint256 _oldPriceTolerance, uint256 _newPriceTolerance\n    );\n    event SetRebalanceWethLimitPriceTolerance(\n        uint256 _oldWethLimitPriceTolerance, uint256 _newWethLimitPriceTolerance\n    );\n    event SetAuctionManager(address newAuctionManager, address oldAuctionManager);\n\n    event TransferToOrder(address trader, uint256 quanity, uint256 clearingPrice);\n\n    event TransferFromOrder(address trader, uint256 quanity, uint256 clearingPrice);\n\n    constructor(\n        address _auctionOwner,\n        address _auctionManager,\n        address _bull,\n        address _factory,\n        address _crab,\n        address _eToken,\n        address _dToken\n    ) UniFlash(_factory) Ownable() EIP712(\"AuctionBull\", \"1\") {\n        auctionManager = _auctionManager;\n        bullStrategy = _bull;\n        weth = IController(IBullStrategy(_bull).powerTokenController()).weth();\n        usdc = IController(IBullStrategy(_bull).powerTokenController()).quoteCurrency();\n        ethWSqueethPool = IController(IBullStrategy(_bull).powerTokenController()).wPowerPerpPool();\n        ethUSDCPool =\n            IController(IBullStrategy(_bull).powerTokenController()).ethQuoteCurrencyPool();\n        wPowerPerp = IController(IBullStrategy(_bull).powerTokenController()).wPowerPerp();\n        crab = _crab;\n        eToken = _eToken;\n        dToken = _dToken;\n\n        IERC20(IController(IBullStrategy(_bull).powerTokenController()).weth()).approve(\n            _bull, type(uint256).max\n        );\n        IERC20(IController(IBullStrategy(_bull).powerTokenController()).quoteCurrency()).approve(\n            _bull, type(uint256).max\n        );\n        IERC20(IController(IBullStrategy(_bull).powerTokenController()).wPowerPerp()).approve(\n            _bull, type(uint256).max\n        );\n\n        transferOwnership(_auctionOwner);\n    }\n\n    receive() external payable {\n        require(msg.sender == address(bullStrategy));\n    }\n\n    /**\n     * @notice sets the auction manager, who has permission to run fullRebalance() and leverageRebalance() functions to rebalance the strategy\n     * @param _auctionManager the new auction manager address\n     */\n    function setAuctionManager(address _auctionManager) external onlyOwner {\n        require(_auctionManager != address(0), \"AB19\");\n\n        emit SetAuctionManager(_auctionManager, auctionManager);\n\n        auctionManager = _auctionManager;\n    }\n\n    /**\n     * @notice owner can set a threshold, scaled by 1e18 that determines the maximum tolerance between a clearing sale price and the current uniswap twap price\n     * @param _fullRebalancePriceTolerance the OTC price tolerance, in percent, scaled by 1e18\n     */\n    function setFullRebalanceClearingPriceTolerance(uint256 _fullRebalancePriceTolerance)\n        external\n        onlyOwner\n    {\n        // tolerance cannot be more than 20%\n        require(_fullRebalancePriceTolerance <= MAX_FULL_REBALANCE_CLEARING_PRICE_TOLERANCE, \"AB14\");\n\n        emit SetFullRebalanceClearingPriceTolerance(\n            fullRebalanceClearingPriceTolerance, _fullRebalancePriceTolerance\n            );\n\n        fullRebalanceClearingPriceTolerance = _fullRebalancePriceTolerance;\n    }\n\n    /**\n     * @notice owner can set a threshold, scaled by 1e18 that determines the maximum tolerance between a WETH limit price and the current uniswap twap price\n     * @param _rebalanceWethLimitPriceTolerance the WETH limit price tolerance, in percent, scaled by 1e18\n     */\n    function setRebalanceWethLimitPriceTolerance(uint256 _rebalanceWethLimitPriceTolerance)\n        external\n        onlyOwner\n    {\n        // tolerance cannot be more than 20%\n        require(\n            _rebalanceWethLimitPriceTolerance <= MAX_REBALANCE_WETH_LIMIT_PRICE_TOLERANCE, \"AB16\"\n        );\n\n        emit SetRebalanceWethLimitPriceTolerance(\n            rebalanceWethLimitPriceTolerance, _rebalanceWethLimitPriceTolerance\n            );\n\n        rebalanceWethLimitPriceTolerance = _rebalanceWethLimitPriceTolerance;\n    }\n\n    /**\n     * @notice set strategy lower and upper collateral ratio\n     * @dev should only be callable by owner\n     * @param _crLower lower CR scaled by 1e18\n     * @param _crUpper upper CR scaled by 1e18\n     */\n    function setCrUpperAndLower(uint256 _crLower, uint256 _crUpper) external onlyOwner {\n        require(_crUpper > _crLower, \"AB3\");\n\n        emit SetCrUpperAndLower(crLower, crUpper, _crLower, _crUpper);\n\n        crLower = _crLower;\n        crUpper = _crUpper;\n    }\n\n    /**\n     * @notice set strategy lower and upper delta to ETH price\n     * @dev should only be callable by owner\n     * @param _deltaLower lower delta scaled by 1e18\n     * @param _deltaUpper upper delta scaled by 1e18\n     */\n    function setDeltaUpperAndLower(uint256 _deltaLower, uint256 _deltaUpper) external onlyOwner {\n        require(_deltaUpper > _deltaLower, \"AB4\");\n\n        emit SetDeltaUpperAndLower(deltaLower, deltaUpper, _deltaLower, _deltaUpper);\n\n        deltaLower = _deltaLower;\n        deltaUpper = _deltaUpper;\n    }\n\n    /**\n     * @dev rebalance delta and collateral ratio of strategy using an array of signed orders\n     * @param _orders list of orders\n     * @param _crabAmount amount of crab to withdraw or deposit\n     * @param _clearingPrice clearing price in WETH per oSQTH, in 1e18 units\n     * @param _wethTargetInEuler target WETH collateral amount in leverage component\n     * @param _wethLimitPrice limit price for WETH/USDC trade\n     * @param _isDepositingInCrab true if the rebalance will deposit into crab, false if withdrawing funds from crab\n     */\n    function fullRebalance(\n        Order[] memory _orders,\n        uint256 _crabAmount,\n        uint256 _clearingPrice,\n        uint256 _wethTargetInEuler,\n        uint256 _wethLimitPrice,\n        uint24 _ethUsdcPoolFee,\n        bool _isDepositingInCrab\n    ) external {\n        require(msg.sender == auctionManager, \"AB0\");\n        require(_clearingPrice > 0, \"AB5\");\n\n        _checkFullRebalanceClearingPrice(_clearingPrice, _isDepositingInCrab);\n        _checkRebalanceLimitPrice(_wethLimitPrice);\n\n        // get current crab vault state\n        (uint256 ethInCrab, uint256 squeethInCrab) =\n            IBullStrategy(bullStrategy).getCrabVaultDetails();\n        // total amount of oSQTH to trade given crab amount\n        uint256 wPowerPerpAmount = _calcWPowerPerpAmountFromCrab(\n            _isDepositingInCrab, _crabAmount, ethInCrab, squeethInCrab\n        );\n\n        _pullFundsFromOrders(_orders, wPowerPerpAmount, _clearingPrice, _isDepositingInCrab);\n\n        if (_isDepositingInCrab) {\n            /**\n             * if auction is depositing into crab:\n             * - if target WETH to have in Euler is greater than current amount in Euler, borrow USDC to buy more WETH and deposit in Euler\n             * - if target WETH to have in Euler is less than current amount in Euler, remove WETH from Euler\n             * - deposit into crab, pay auction traders wPowerPerp\n             */\n            _executeCrabDeposit(\n                ExecuteCrabDepositParams({\n                    crabAmount: _crabAmount,\n                    wethTargetInEuler: _wethTargetInEuler,\n                    wethLimitPrice: _wethLimitPrice,\n                    ethInCrab: ethInCrab,\n                    ethUsdcPoolFee: _ethUsdcPoolFee\n                })\n            );\n\n            _pushFundsFromOrders(_orders, wPowerPerpAmount, _clearingPrice, _isDepositingInCrab);\n        } else {\n            IBullStrategy(bullStrategy).redeemCrabAndWithdrawWEth(_crabAmount, wPowerPerpAmount);\n\n            _pushFundsFromOrders(_orders, wPowerPerpAmount, _clearingPrice, _isDepositingInCrab);\n\n            // rebalance bull strategy delta\n            _executeLeverageComponentRebalancing(\n                ExecuteLeverageComponentRebalancingParams({\n                    wethTargetInEuler: _wethTargetInEuler,\n                    wethLimitPrice: _wethLimitPrice,\n                    ethUsdcPoolFee: _ethUsdcPoolFee\n                })\n            );\n        }\n\n        // check that rebalance does not breach collateral ratio or delta tolerance\n        _isValidRebalance();\n\n        emit FullRebalance(\n            _crabAmount, _clearingPrice, _isDepositingInCrab, wPowerPerpAmount, _wethTargetInEuler\n            );\n    }\n\n    /**\n     * @notice change the strategy eth delta by increasing or decreasing USDC debt\n     * @dev can only be called by auction manager\n     * @param _isSellingUsdc true if strategy is selling USDC\n     * @param _usdcAmount USDC amount to trade\n     * @param _wethLimitPrice WETH/USDC limit price, scaled 1e18 units\n     * @param _poolFee USDC/WETH pool fee\n     */\n    function leverageRebalance(\n        bool _isSellingUsdc,\n        uint256 _usdcAmount,\n        uint256 _wethLimitPrice,\n        uint24 _poolFee\n    ) external {\n        require(msg.sender == auctionManager, \"AB0\");\n\n        _checkRebalanceLimitPrice(_wethLimitPrice);\n\n        if (_isSellingUsdc) {\n            // swap USDC to WETH\n            _exactInFlashSwap(\n                usdc,\n                weth,\n                _poolFee,\n                _usdcAmount,\n                _usdcAmount.mul(WETH_DECIMALS_DIFF).wdiv(_wethLimitPrice),\n                uint8(FLASH_SOURCE.LEVERAGE_REBALANCE_INCREASE_DEBT),\n                \"\"\n            );\n        } else {\n            // swap WETH to USDC\n            _exactOutFlashSwap(\n                weth,\n                usdc,\n                _poolFee,\n                _usdcAmount,\n                _usdcAmount.mul(WETH_DECIMALS_DIFF).wdiv(_wethLimitPrice),\n                uint8(FLASH_SOURCE.LEVERAGE_REBALANCE_DECREASE_DEBT),\n                abi.encodePacked(_usdcAmount)\n            );\n        }\n\n        _isValidRebalance();\n\n        emit LeverageRebalance(_isSellingUsdc, _usdcAmount, _wethLimitPrice);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @notice get current delta and bull collateral ratio\n     * @return delta and collateral ratio\n     */\n    function getCurrentDeltaAndCollatRatio() external view returns (uint256, uint256) {\n        return _getCurrentDeltaAndCollatRatio();\n    }\n\n    /**\n     * @notice allows an order to be cancelled by marking its nonce used for a given msg.sender\n     * @param _nonce the nonce to mark as used\n     */\n    function useNonce(uint256 _nonce) external {\n        _useNonce(msg.sender, _nonce);\n    }\n\n    /**\n     * @notice pulls funds from trader of auction orders (weth or wPowerPerp) depending on the direction of trade\n     * @param _orders list of orders\n     * @param remainingAmount amount of wPowerPerp to trade\n     * @param _clearingPrice clearing price weth/wPowerPerp, in 1e18 units\n     * @param _isDepositingInCrab true if the rebalance will deposit into Crab, false if withdrawing funds from crab\n     */\n    function _pullFundsFromOrders(\n        Order[] memory _orders,\n        uint256 remainingAmount,\n        uint256 _clearingPrice,\n        bool _isDepositingInCrab\n    ) internal {\n        // loop through orders, check each order validity\n        // pull funds from orders\n\n        uint256 prevPrice = _orders[0].price;\n        uint256 currentPrice;\n\n        uint256 ordersLength = _orders.length;\n        for (uint256 i; i < ordersLength; ++i) {\n            _verifyOrder(_orders[i], _clearingPrice, _isDepositingInCrab);\n\n            currentPrice = _orders[i].price;\n            // check that orders are in order\n            if (_isDepositingInCrab) {\n                require(currentPrice <= prevPrice, \"AB8\");\n            } else {\n                require(currentPrice >= prevPrice, \"AB7\");\n            }\n            prevPrice = currentPrice;\n\n            _transferFromOrder(_orders[i], remainingAmount, _clearingPrice);\n\n            if (remainingAmount > _orders[i].quantity) {\n                remainingAmount = remainingAmount.sub(_orders[i].quantity);\n            } else {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice pushes funds to trader of auction orders (weth or wPowerPerp) depending on the direction of trade\n     * @param _orders list of orders\n     * @param remainingAmount amount of wPowerPerp to trade\n     * @param _clearingPrice clearing price weth/wPowerPerp, in 1e18 units\n     * @param _isDepositingInCrab true if the rebalance will deposit into Crab, false if withdrawing funds from crab\n     */\n\n    function _pushFundsFromOrders(\n        Order[] memory _orders,\n        uint256 remainingAmount,\n        uint256 _clearingPrice,\n        bool _isDepositingInCrab\n    ) internal {\n        uint256 ordersLength = _orders.length;\n        for (uint256 i; i < ordersLength; ++i) {\n            _transferToOrder(_orders[i], remainingAmount, _clearingPrice);\n            if (remainingAmount > _orders[i].quantity) {\n                remainingAmount = remainingAmount.sub(_orders[i].quantity);\n            } else {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice execute crab deposit\n     * @param _params ExecuteCrabDepositParams struct\n     */\n    function _executeCrabDeposit(ExecuteCrabDepositParams memory _params) internal {\n        // total eth needed for this crab deposit\n        uint256 totalEthNeededForCrab =\n            _params.crabAmount.wdiv(IERC20(crab).totalSupply()).wmul(_params.ethInCrab);\n        // additional eth needed\n        uint256 ethNeededForCrab = totalEthNeededForCrab.sub(IERC20(weth).balanceOf(address(this)));\n        // WETH collateral in Euler\n        uint256 wethInCollateral = IEulerEToken(eToken).balanceOfUnderlying(address(bullStrategy));\n        if (_params.wethTargetInEuler > wethInCollateral) {\n            // crab deposit eth + collateral shortfall\n            uint256 wethToGet =\n                _params.wethTargetInEuler.sub(wethInCollateral).add(ethNeededForCrab);\n            // sell USDC to buy WETH\n            _exactOutFlashSwap(\n                usdc,\n                weth,\n                _params.ethUsdcPoolFee,\n                wethToGet,\n                wethToGet.wmul(_params.wethLimitPrice).div(WETH_DECIMALS_DIFF),\n                uint8(FLASH_SOURCE.FULL_REBALANCE_DEPOSIT_WETH_BORROW_USDC_DEPOSIT_INTO_CRAB),\n                abi.encodePacked(\n                    _params.wethTargetInEuler.sub(wethInCollateral), totalEthNeededForCrab\n                )\n            );\n        } else {\n            // WETH to take out of Euler\n            uint256 wethFromEuler = wethInCollateral.sub(_params.wethTargetInEuler);\n            // crab deposit eth - excess collateral\n            uint256 wethToGet = ethNeededForCrab.sub(wethFromEuler);\n            // sell USDC to buy WETH\n            _exactOutFlashSwap(\n                usdc,\n                weth,\n                _params.ethUsdcPoolFee,\n                wethToGet,\n                wethToGet.wmul(_params.wethLimitPrice).div(WETH_DECIMALS_DIFF),\n                uint8(FLASH_SOURCE.FULL_REBALANCE_WITHDRAW_WETH_BORROW_USDC_DEPOSIT_INTO_CRAB),\n                abi.encodePacked(wethFromEuler, totalEthNeededForCrab)\n            );\n        }\n    }\n\n    /**\n     * @dev Uniswap V3 internal callback\n     * @param _uniFlashSwapData UniFlashswapCallbackData struct\n     */\n    function _uniFlashSwap(UniFlashswapCallbackData memory _uniFlashSwapData) internal override {\n        if (\n            FLASH_SOURCE(_uniFlashSwapData.callSource)\n                == FLASH_SOURCE.LEVERAGE_REBALANCE_INCREASE_DEBT\n        ) {\n            IBullStrategy(bullStrategy).depositAndBorrowFromLeverage(\n                IERC20(weth).balanceOf(address(this)), _uniFlashSwapData.amountToPay\n            );\n\n            IERC20(usdc).transfer(_uniFlashSwapData.pool, _uniFlashSwapData.amountToPay);\n        } else if (\n            FLASH_SOURCE(_uniFlashSwapData.callSource)\n                == FLASH_SOURCE.LEVERAGE_REBALANCE_DECREASE_DEBT\n        ) {\n            uint256 usdcToRepay = abi.decode(_uniFlashSwapData.callData, (uint256));\n            // Repay some USDC debt\n            IBullStrategy(bullStrategy).auctionRepayAndWithdrawFromLeverage(\n                usdcToRepay, _uniFlashSwapData.amountToPay\n            );\n\n            IERC20(weth).transfer(_uniFlashSwapData.pool, _uniFlashSwapData.amountToPay);\n        } else if (\n            FLASH_SOURCE(_uniFlashSwapData.callSource)\n                == FLASH_SOURCE.FULL_REBALANCE_BORROW_USDC_BUY_WETH\n        ) {\n            uint256 wethToDeposit = abi.decode(_uniFlashSwapData.callData, (uint256));\n            IBullStrategy(bullStrategy).depositAndBorrowFromLeverage(\n                wethToDeposit, _uniFlashSwapData.amountToPay\n            );\n\n            IERC20(usdc).transfer(_uniFlashSwapData.pool, _uniFlashSwapData.amountToPay);\n        } else if (\n            FLASH_SOURCE(_uniFlashSwapData.callSource)\n                == FLASH_SOURCE.FULL_REBALANCE_REPAY_USDC_WITHDRAW_WETH\n        ) {\n            uint256 remainingWeth = abi.decode(_uniFlashSwapData.callData, (uint256));\n\n            IBullStrategy(bullStrategy).auctionRepayAndWithdrawFromLeverage(\n                IERC20(usdc).balanceOf(address(this)),\n                _uniFlashSwapData.amountToPay.sub(remainingWeth)\n            );\n\n            IERC20(weth).transfer(_uniFlashSwapData.pool, _uniFlashSwapData.amountToPay);\n        } else if (\n            FLASH_SOURCE(_uniFlashSwapData.callSource)\n                == FLASH_SOURCE.FULL_REBALANCE_DEPOSIT_WETH_BORROW_USDC_DEPOSIT_INTO_CRAB\n        ) {\n            (uint256 wethToLeverage, uint256 ethToCrab) =\n                abi.decode(_uniFlashSwapData.callData, (uint256, uint256));\n\n            IBullStrategy(bullStrategy).depositAndBorrowFromLeverage(\n                wethToLeverage, _uniFlashSwapData.amountToPay\n            );\n\n            IBullStrategy(bullStrategy).depositEthIntoCrab(ethToCrab);\n\n            IERC20(usdc).transfer(_uniFlashSwapData.pool, _uniFlashSwapData.amountToPay);\n        } else if (\n            FLASH_SOURCE(_uniFlashSwapData.callSource)\n                == FLASH_SOURCE.FULL_REBALANCE_WITHDRAW_WETH_BORROW_USDC_DEPOSIT_INTO_CRAB\n        ) {\n            (uint256 wethToWithdraw, uint256 ethToCrab) =\n                abi.decode(_uniFlashSwapData.callData, (uint256, uint256));\n\n            IBullStrategy(bullStrategy).auctionRepayAndWithdrawFromLeverage(0, wethToWithdraw);\n\n            IBullStrategy(bullStrategy).depositAndBorrowFromLeverage(\n                0, _uniFlashSwapData.amountToPay\n            );\n\n            IBullStrategy(bullStrategy).depositEthIntoCrab(ethToCrab);\n\n            IERC20(usdc).transfer(_uniFlashSwapData.pool, _uniFlashSwapData.amountToPay);\n        }\n    }\n\n    /**\n     * @notice rebalance bull strategy delta by borrowing or repaying USDC\n     * @param _params ExecuteLeverageComponentRebalancingParams struct\n     */\n    function _executeLeverageComponentRebalancing(\n        ExecuteLeverageComponentRebalancingParams memory _params\n    ) internal {\n        uint256 remainingWeth = IERC20(weth).balanceOf(address(this));\n        uint256 wethInCollateral = IEulerEToken(eToken).balanceOfUnderlying(address(bullStrategy));\n        if (_params.wethTargetInEuler > remainingWeth.add(wethInCollateral)) {\n            // borrow more USDC to buy WETH\n            uint256 wethToBuy = _params.wethTargetInEuler.sub(remainingWeth.add(wethInCollateral));\n            _exactOutFlashSwap(\n                usdc,\n                weth,\n                _params.ethUsdcPoolFee,\n                wethToBuy,\n                wethToBuy.wmul(_params.wethLimitPrice).div(WETH_DECIMALS_DIFF),\n                uint8(FLASH_SOURCE.FULL_REBALANCE_BORROW_USDC_BUY_WETH),\n                abi.encodePacked(wethToBuy.add(remainingWeth))\n            );\n        } else {\n            uint256 wethToSell = remainingWeth.add(wethInCollateral).sub(_params.wethTargetInEuler);\n            // repay USDC debt from WETH\n            _exactInFlashSwap(\n                weth,\n                usdc,\n                _params.ethUsdcPoolFee,\n                wethToSell,\n                wethToSell.wmul(_params.wethLimitPrice).div(WETH_DECIMALS_DIFF),\n                uint8(FLASH_SOURCE.FULL_REBALANCE_REPAY_USDC_WITHDRAW_WETH),\n                abi.encodePacked(remainingWeth)\n            );\n        }\n    }\n\n    /**\n     * @notice transfer payment to auction participant from contract\n     * @param _order Order struct\n     * @param _remainingAmount remaining amount to be transfered\n     * @param _clearingPrice clearing price in WETH/oSQTH determined at auction\n     */\n    function _transferToOrder(Order memory _order, uint256 _remainingAmount, uint256 _clearingPrice)\n        internal\n    {\n        // adjust quantity for partial fills\n        if (_remainingAmount < _order.quantity) {\n            _order.quantity = _remainingAmount;\n        }\n        if (_order.isBuying) {\n            // trader sent WETH and receives oSQTH\n            IERC20(wPowerPerp).transfer(_order.trader, _order.quantity);\n        } else {\n            // trader sent oSQTH and receives WETH\n            // WETH clearing price for the order\n            uint256 wethAmount = _order.quantity.wmul(_clearingPrice);\n            IERC20(weth).transfer(_order.trader, wethAmount);\n        }\n        emit TransferToOrder(_order.trader, _order.quantity, _clearingPrice);\n    }\n\n    /**\n     * @notice transfer payment from auction participant to contract\n     * @param _order Order struct\n     * @param _remainingAmount remaining amount to be transfered\n     * @param _clearingPrice clearing price in WETH/oSQTH determined at auction\n     */\n    function _transferFromOrder(\n        Order memory _order,\n        uint256 _remainingAmount,\n        uint256 _clearingPrice\n    ) internal {\n        // adjust quantity for partial fills\n        if (_remainingAmount < _order.quantity) {\n            _order.quantity = _remainingAmount;\n        }\n\n        if (_order.isBuying) {\n            // trader sends WETH and receives oSQTH\n            // WETH clearing price for the order\n            uint256 wethAmount = _order.quantity.wmul(_clearingPrice);\n            IERC20(weth).transferFrom(_order.trader, address(this), wethAmount);\n        } else {\n            // trader send oSQTH and receives WETH\n            IERC20(wPowerPerp).transferFrom(_order.trader, address(this), _order.quantity);\n        }\n        emit TransferFromOrder(_order.trader, _order.quantity, _clearingPrice);\n    }\n\n    /**\n     * @notice verify that an auction order is valid\n     * @param _order Order struct\n     * @param _clearingPrice clearing price in WETH/oSQTH\n     * @param _isDepositingInCrab true if rebalance is depositing into crab\n     */\n    function _verifyOrder(Order memory _order, uint256 _clearingPrice, bool _isDepositingInCrab)\n        internal\n    {\n        // check that order trade against hedge direction\n        require(_order.isBuying == _isDepositingInCrab, \"AB6\");\n        // check that order beats clearing price\n        if (_order.isBuying) {\n            require(_clearingPrice <= _order.price, \"AB9\");\n        } else {\n            require(_clearingPrice >= _order.price, \"AB10\");\n        }\n\n        _useNonce(_order.trader, _order.nonce);\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _FULL_REBALANCE_TYPEHASH,\n                _order.bidId,\n                _order.trader,\n                _order.quantity,\n                _order.price,\n                _order.isBuying,\n                _order.expiry,\n                _order.nonce\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n        address orderSigner = ECDSA.recover(hash, _order.v, _order.r, _order.s);\n        require(orderSigner == _order.trader, \"AB11\");\n        require(_order.expiry >= block.timestamp, \"AB12\");\n    }\n\n    /**\n     * @dev set nonce flag of the trader to true\n     * @param _trader address of the signer\n     * @param _nonce number that is to be traded only once\n     */\n    function _useNonce(address _trader, uint256 _nonce) internal {\n        require(!nonces[_trader][_nonce], \"AB13\");\n        nonces[_trader][_nonce] = true;\n    }\n\n    /**\n     * @notice check if strategy delta and collateral is within tolerance\n     */\n    function _isValidRebalance() internal view {\n        (uint256 delta, uint256 cr) = _getCurrentDeltaAndCollatRatio();\n\n        require(delta <= deltaUpper && delta >= deltaLower, \"AB1\");\n        require(cr <= crUpper && cr >= crLower, \"AB2\");\n    }\n\n    /**\n     * @dev calculate amount of wPowerPerp associated with a crab deposit or withdrawal\n     * @param _isDepositingInCrab true if depositing into crab\n     * @param _crabAmount amount of crab to deposit/withdraw\n     * @param _ethInCrab amount of eth collateral owned by crab strategy\n     * @param _squeethInCrab amount of squeeth debt owed by crab strategy\n     * @return wPowerPerpAmount\n     */\n    function _calcWPowerPerpAmountFromCrab(\n        bool _isDepositingInCrab,\n        uint256 _crabAmount,\n        uint256 _ethInCrab,\n        uint256 _squeethInCrab\n    ) internal view returns (uint256) {\n        uint256 wPowerPerpAmount;\n        if (_isDepositingInCrab) {\n            uint256 ethToDepositInCrab =\n                _crabAmount.wdiv(IERC20(crab).totalSupply()).wmul(_ethInCrab);\n            (wPowerPerpAmount,) =\n                _calcWsqueethToMintAndFee(ethToDepositInCrab, _squeethInCrab, _ethInCrab);\n        } else {\n            wPowerPerpAmount = _crabAmount.wmul(_squeethInCrab).wdiv(IERC20(crab).totalSupply());\n        }\n\n        return wPowerPerpAmount;\n    }\n\n    /**\n     * @notice get current bull strategy delta and collateral ratio\n     * @return delta and collateral ratio\n     */\n    function _getCurrentDeltaAndCollatRatio() internal view returns (uint256, uint256) {\n        (uint256 ethInCrab, uint256 squeethInCrab) =\n            IBullStrategy(bullStrategy).getCrabVaultDetails();\n        uint256 ethUsdPrice = UniOracle._getTwap(ethUSDCPool, weth, usdc, TWAP, false);\n        uint256 squeethEthPrice = UniOracle._getTwap(ethWSqueethPool, wPowerPerp, weth, TWAP, false);\n        uint256 crabUsdPrice = (\n            ethInCrab.wmul(ethUsdPrice).sub(squeethInCrab.wmul(squeethEthPrice).wmul(ethUsdPrice))\n        ).wdiv(IERC20(crab).totalSupply());\n\n        uint256 usdcDebt = IEulerDToken(dToken).balanceOf(address(bullStrategy));\n        uint256 wethInCollateral = IEulerEToken(eToken).balanceOfUnderlying(address(bullStrategy));\n\n        uint256 delta = (wethInCollateral.wmul(ethUsdPrice)).wdiv(\n            (IBullStrategy(bullStrategy).getCrabBalance().wmul(crabUsdPrice)).add(\n                wethInCollateral.wmul(ethUsdPrice)\n            ).sub(usdcDebt.mul(WETH_DECIMALS_DIFF))\n        );\n\n        uint256 cr = wethInCollateral.wmul(ethUsdPrice).wdiv(usdcDebt.mul(WETH_DECIMALS_DIFF));\n\n        return (delta, cr);\n    }\n\n    /**\n     * @dev calculate amount of wSqueeth to mint and fee based on ETH to deposit into crab\n     * @param _depositedEthAmount amount of ETH deposited\n     * @param _strategyDebtAmount amount of wPowerperp debt in stra"
    }
  ]
}