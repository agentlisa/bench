{
  "Title": "[G-20] Remove local-testing related code in `DiamondInit.sol`",
  "Content": "\n[File: ethereum/contracts/zksync/DiamondInit.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/DiamondInit.sol#L85-L87)\n\n```\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n```\n\nAccording to the above code, `assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);` is redundant and can be removed in production, since this line of code is dedicated for local testing only.\n\nThis can be confirmed in file `ethereum/contracts/zksync/Config.sol`, where constant `L2_TO_L1_LOG_SERIALIZE_SIZE` is defined as `88`. Since this is a constant value, its value will never change, thus this `assert` is unnecessary and can be removed.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/zksync/DiamondInit.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {IAllowList} from \"../common/interfaces/IAllowList.sol\";\nimport {IVerifier} from \"./interfaces/IVerifier.sol\";\nimport {IExecutor} from \"./interfaces/IExecutor.sol\";\nimport {Diamond} from \"./libraries/Diamond.sol\";\nimport {Base} from \"./facets/Base.sol\";\nimport {Verifier} from \"./Verifier.sol\";\nimport {VerifierParams} from \"./Storage.sol\";\n/* solhint-disable max-line-length */\nimport {L2_TO_L1_LOG_SERIALIZE_SIZE, EMPTY_STRING_KECCAK, DEFAULT_L2_LOGS_TREE_ROOT_HASH, L2_TX_MAX_GAS_LIMIT} from \"./Config.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev The contract is used only once to initialize the diamond proxy.\n/// @dev The deployment process takes care of this contract's initialization.\ncontract DiamondInit is Base {\n    /// @notice Struct that holds all data needed for initializing zkSync Diamond Proxy.\n    /// @dev We use struct instead of raw parameters in `initialize` function to prevent \"Stack too deep\" error\n    /// @param _verifier address of Verifier contract\n    /// @param _governor address who can manage critical updates in the contract\n    /// @param _admin address who can manage non-critical updates in the contract\n    /// @param _genesisBatchHash Batch hash of the genesis (initial) batch\n    /// @param _genesisIndexRepeatedStorageChanges The serial number of the shortcut storage key for genesis batch\n    /// @param _genesisBatchCommitment The zk-proof commitment for the genesis batch\n    /// @param _allowList The address of the allow list smart contract\n    /// @param _verifierParams Verifier config parameters that describes the circuit to be verified\n    /// @param _zkPorterIsAvailable The availability of zk porter shard\n    /// @param _l2BootloaderBytecodeHash The hash of bootloader L2 bytecode\n    /// @param _l2DefaultAccountBytecodeHash The hash of default account L2 bytecode\n    /// @param _priorityTxMaxGasLimit maximum number of the L2 gas that a user can request for L1 -> L2 transactions\n    struct InitializeData {\n        IVerifier verifier;\n        address governor;\n        address admin;\n        bytes32 genesisBatchHash;\n        uint64 genesisIndexRepeatedStorageChanges;\n        bytes32 genesisBatchCommitment;\n        IAllowList allowList;\n        VerifierParams verifierParams;\n        bool zkPorterIsAvailable;\n        bytes32 l2BootloaderBytecodeHash;\n        bytes32 l2DefaultAccountBytecodeHash;\n        uint256 priorityTxMaxGasLimit;\n    }\n\n    /// @dev Initialize the implementation to prevent any possibility of a Parity hack.\n    constructor() reentrancyGuardInitializer {}\n\n    /// @notice zkSync contract initialization\n    /// @return Magic 32 bytes, which indicates that the contract logic is expected to be used as a diamond proxy\n    /// initializer\n    function initialize(InitializeData calldata _initalizeData) external reentrancyGuardInitializer returns (bytes32) {\n        require(address(_initalizeData.verifier) != address(0), \"vt\");\n        require(_initalizeData.governor != address(0), \"vy\");\n        require(_initalizeData.admin != address(0), \"hc\");\n        require(_initalizeData.priorityTxMaxGasLimit <= L2_TX_MAX_GAS_LIMIT, \"vu\");\n\n        s.verifier = _initalizeData.verifier;\n        s.governor = _initalizeData.governor;\n        s.admin = _initalizeData.admin;\n\n        // We need to initialize the state hash because it is used in the commitment of the next batch\n        IExecutor.StoredBatchInfo memory storedBatchZero = IExecutor.StoredBatchInfo(\n            0,\n            _initalizeData.genesisBatchHash,\n            _initalizeData.genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _initalizeData.genesisBatchCommitment\n        );\n\n        s.storedBatchHashes[0] = keccak256(abi.encode(storedBatchZero));\n        s.allowList = _initalizeData.allowList;\n        s.verifierParams = _initalizeData.verifierParams;\n        s.zkPorterIsAvailable = _initalizeData.zkPorterIsAvailable;\n        s.l2BootloaderBytecodeHash = _initalizeData.l2BootloaderBytecodeHash;\n        s.l2DefaultAccountBytecodeHash = _initalizeData.l2DefaultAccountBytecodeHash;\n        s.priorityTxMaxGasLimit = _initalizeData.priorityTxMaxGasLimit;\n\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}"
    }
  ]
}