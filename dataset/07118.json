{
  "Title": "[M-04] Wrong init code hash",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/periphery/UniswapV2/libraries/UniswapV2Library.sol#L27\n\n\n# Vulnerability details\n\n## Impact\nAn init code hash is used to calculate the address of UniswapV2 pair contract. But the init code hash is not same as the latest UniswapV2 repository.\n\n## Proof of Concept\nUniswapV2Library.pairFor uses the following value as the init code hash of UniswapV2Pair. \n```\n    hex\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\" // init code hash\n```\n\nBut it is different from the [init code hash](https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol#L24) of the uniswap v2 repository.\n\nI tested this using one of the top UniswapV2 pairs. DAI-USDC is in the third place [here](https://v2.info.uniswap.org/pairs).\n\nThe token addresses are as follows:\n\nDAI: 0x6B175474E89094C44Da98b954EedeAC495271d0F\n\nUSDC: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n\nAnd the current UniswapV2Factory address is 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f [here](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/factory).\n\nThe pair address calculated is 0x6983E2Da04353C31c7C42B0EA900a40B1D5bf845. And we can't find pair contract in the address.\n\nSo I think the old version of UniswapV2Factory and pair are used here. And it can cause a risk when liquidity is not enough for the pair.\n\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nIntegrate the latest version of UniswapV2.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-numoen-contest",
  "Code": [
    {
      "filename": "src/periphery/UniswapV2/libraries/UniswapV2Library.sol",
      "content": "pragma solidity >=0.8.0;\n\nimport { IUniswapV2Pair } from \"../interfaces/IUniswapV2Pair.sol\";\n\n/// @notice Library for helpful UniswapV2 functions\n/// @author Uniswap (https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol)\n/// @dev Updated for newer solidity by removing safe math\nlibrary UniswapV2Library {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(\n      uint160( // extra cast for newer solidity\n        uint256(\n          keccak256(\n            abi.encodePacked(\n              hex\"ff\",\n              factory,\n              keccak256(abi.encodePacked(token0, token1)),\n              hex\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\" // init code hash\n            )\n          )\n        )\n      )\n    );\n  }\n\n  // fetches and sorts the reserves for a pair\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB\n  )\n    internal\n    view\n    returns (uint256 reserveA, uint256 reserveB)\n  {\n    (address token0,) = sortTokens(tokenA, tokenB);\n    (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n  }\n\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  )\n    internal\n    pure\n    returns (uint256 amountOut)\n  {\n    require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n    require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n    uint256 amountInWithFee = amountIn * 997;\n    uint256 numerator = amountInWithFee * reserveOut;\n    uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n    amountOut = numerator / denominator;\n  }\n\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  )\n    internal\n    pure\n    returns (uint256 amountIn)\n  {\n    require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n    uint256 numerator = reserveIn * amountOut * 1000;\n    uint256 denominator = (reserveOut - amountOut) * 997;\n    amountIn = (numerator / denominator) + 1;\n  }\n}"
    }
  ]
}