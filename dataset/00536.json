{
  "Title": "H-4: Victim's fund can be stolen due to rounding error and exchange rate manipulation",
  "Content": "# Issue H-4: Victim's fund can be stolen due to rounding error and exchange rate manipulation \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/94 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nBandit, LTDingZhen, cawfree, jennifer37, xAlismx, xiaoming90\n## Summary\n\nVictim's funds can be stolen by malicious users by exploiting the rounding error and through exchange rate manipulation.\n\n## Vulnerability Detail\n\nThe LST Adaptor attempts to guard against the well-known vault inflation attack by reverting the TX when the amount of shares minted is rounded down to zero in Line 78 below.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L71\n\n```solidity\nFile: BaseLSTAdapter.sol\n71:     function prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n72:         uint256 bufferEthCache = bufferEth; // cache storage reads\n73:         uint256 queueEthCache = withdrawalQueueEth; // cache storage reads\n74:         uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n75:         uint256 shares = previewDeposit(assets);\n76: \n77:         if (assets == 0) return (0, 0);\n78:         if (shares == 0) revert ZeroShares();\n```\n\nHowever, this control alone is not sufficient to guard against vault inflation attacks. \n\nLet's assume the following scenario (ignoring fee for simplicity's sake):\n\n1. The victim initiates a transaction that deposits 10 ETH as the underlying asset when there are no issued estETH shares.\n2. The attacker observes the victim’s transaction and deposits 1 wei of ETH (issuing 1 wei of estETH share) before the victim’s transaction. 1 wei of estETH share worth of PT and TY will be minted to the attacker.\n3. Then, the attacker executes a transaction to directly transfer 5 stETH to the adaptor. The exchange rate at this point is `1 wei / (5 ETH + 1 wei)`. Note that the [`totalAssets`](https://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/lido/StEtherAdapter.sol#L115) function uses the `balanceOf` function to compute the total underlying assets owned by the adaptor. Thus, this direct transfer will increase the total assets amount.\n4. When the victim’s transaction is executed, the number of estETH shares issued is calculated as `10 ETH * 1 wei / (5 ETH + 1 wei)`, resulting in 1 wei being issued due to round-down.\n5. The attacker will combine the PT + YT obtained earlier to redeem 1 wei of estETH share from the adaptor.\n6. The attacker, holding 50% of the issued estETH shares (indirectly via the PT+YT he owned), receives `(15 ETH + 1 wei) / 2` as the underlying asset. \n7. The attacker seizes 25% of the underlying asset (2.5 ETH) deposited by the victim.\n\nThis scenario demonstrates that even when a revert is triggered due to the number of issued estETH share being 0, it does not prevent the attacker from capturing the user’s funds through exchange rate manipulation.\n\n## Impact\n\nLoss of assets for the victim.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L71\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFollowing are some of the measures that could help to prevent such an attack:\n\n- Mint a certain amount of shares to zero address (dead address) during contract deployment (similar to what has been implemented in Uniswap V2)\n- Avoid using the `balanceOf` so that malicious users cannot transfer directly to the contract to increase the assets per share. Track the total assets internally via a variable.\n\n\n\n## Discussion\n\n**massun-onibakuchi**\n\nOpenzeppelin's ERC4626 with a decimalsOffset=0 in the virtual share mitigates the issue, but it is recognized that it does not completely resolve it. We plan to deposit a small amount of tokens after deployment.\n\n**ydspa**\n\nEscalate\nThis finding is not high.\nThis attack would be success only if the protocol team doesn't provide and keep any initial liquidity for the vault. However, in practical, we merely find protocol teams don't provide any fund to bootstrap projects. The likelihood of this attack is very low.\n\n**sherlock-admin2**\n\n> Escalate\n> This finding is not high.\n> This attack would be success only if the protocol team doesn't provide and keep any initial liquidity for the vault. However, in practical, we merely find protocol teams don't provide any fund to bootstrap projects. The likelihood of this attack is very low.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**massun-onibakuchi**\n\n> Escalate This finding is not high. This attack would be success only if the protocol team doesn't provide and keep any initial liquidity for the vault. However, in practical, we merely find protocol teams don't provide any fund to bootstrap projects. The likelihood of this attack is very low.\n\nAgree. This kind of inflation attack is not listed as a finding in the Mixbytes audit, which is still unpublished.\n\n**MehdiKarimi81**\n\nIf the protocol team doesn't provide initial liquidity it would be high, since it's not listed as a known issue and the protocol team didn't clear that they plan to provide initial liquidity, it can be considered as a high severity. \n\n**xiaoming9090**\n\nThe mitigation of minting some shares in advance to prevent this issue was not documented in the contest’s README. Thus, the issue remains valid and as it is, as mitigation cannot be applied retrospectively after the contest. Otherwise, it would be unfair to the Watsons to raise an issue that only gets invalid by a mitigation shared after the contest/audit.\n\n**cvetanovv**\n\nI disagree with the escalation and this report should remain a valid High. Nowhere in the Readme or Documentation is it described that the protocol knows and can prevent this attack.\n\n**Czar102**\n\nUncommunicated plans for issue mitigation don't constitute a reason for invalidation. I believe this was correctly judged – planning to reject the escalation and leave the issue as is.\n\n**Czar102**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ydspa](https://github.com/sherlock-audit/2024-01-napier-judging/issues/94/#issuecomment-1985343164): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "napier-v1/src/adapters/BaseLSTAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IWETH9} from \"../interfaces/IWETH9.sol\";\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\n\nimport {BaseAdapter} from \"../BaseAdapter.sol\";\nimport {ERC4626} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC4626.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {WETH} from \"../Constants.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapter is BaseAdapter, ERC4626, ReentrancyGuard {\n    using SafeCast for uint256;\n\n    uint256 constant BUFFER_PERCENTAGE_PRECISION = 1e18; // 1e18 = 100%\n    uint256 constant MIN_BUFFER_PERCENTAGE = 0.01 * 1e18; // 1%\n\n    /// @notice Rebalancer of the ETH buffer, can be set by the owner\n    /// @notice The account can request a withdrawal\n    address public rebalancer;\n\n    /// @notice Desired buffer percentage in WAD\n    uint256 public targetBufferPercentage = 0.1 * 1e18; // 10% desired buffer percentage\n\n    /// @notice Amount of ETH pending withdrawal\n    uint128 public withdrawalQueueEth;\n\n    /// @notice Amount of ETH available (Buffer), does not include pending withdrawal. Internal accounting of ETH\n    uint128 public bufferEth;\n\n    /// @notice Request ID of the withdrawal request\n    /// @dev 0 if there is no pending withdrawal request\n    uint256 public requestId;\n\n    error ZeroAssets();\n    error ZeroShares();\n    error InsufficientBuffer();\n    error BufferTooLarge();\n    error InvalidBufferPercentage();\n    error WithdrawalPending();\n    error NoPendingWithdrawal();\n    error NotRebalancer();\n    error NotImplemented();\n\n    /// @notice Reverts if the caller is not the rebalancer\n    modifier onlyRebalancer() {\n        if (rebalancer != msg.sender) revert NotRebalancer();\n        _;\n    }\n\n    /// @dev Adapter itself is the target token\n    constructor(address _rebalancer) BaseAdapter(WETH, address(this)) ERC4626((IWETH9(WETH))) {\n        rebalancer = _rebalancer;\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n        uint256 bufferEthCache = bufferEth; // cache storage reads\n        uint256 queueEthCache = withdrawalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (withdrawalQueueEth + bufferEth + assets - s) / (withdrawalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (withdrawalQueueEth + bufferEth + assets) - (withdrawalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (withdrawalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient: Doesn't stake any of the deposit\n        if (targetBufferEth >= availableEth + queueEthCache) {\n            bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        uint256 stakeAmount;\n        unchecked {\n            stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the stake amount exceeds 95% of the available ETH, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        //\n        // The condition: stakeAmount > availableEth, is equivalent to: queueEthCache > targetBufferEth\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        uint256 maxStakeAmount = (availableEth * 95) / 100;\n        if (stakeAmount > maxStakeAmount) {\n            stakeAmount = maxStakeAmount; // max 95% of the available ETH\n        }\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n\n    /// @notice Handles prefunded redemptions\n    /// @dev Withdraw from the buffer. If the buffer is insufficient, revert with an error\n    /// @param recipient The address to receive the redeemed WETH\n    /// @return The amount of redeemed WETH\n    /// @return The amount of shares burned\n    function prefundedRedeem(address recipient) external virtual returns (uint256, uint256) {\n        uint256 shares = balanceOf(address(this));\n        uint256 assets = previewRedeem(shares);\n\n        if (shares == 0) return (0, 0);\n        if (assets == 0) revert ZeroAssets();\n\n        uint256 bufferEthCache = bufferEth;\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n        if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        unchecked {\n            /// WRITE ///\n            // Reduce the buffer and burn the shares\n            bufferEth = (bufferEthCache - assets).toUint128(); // no underflow\n            _burn(address(this), shares);\n        }\n\n        /// INTERACT ///\n        IWETH9(WETH).transfer(recipient, assets);\n\n        return (assets, shares);\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIRTUAL METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Request a withdrawal of ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    /// @dev Reverts if the buffer is sufficient to cover the desired buffer percentage of the total assets\n    function requestWithdrawal() external virtual nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n\n        uint256 targetBufferEth = (totalAssets() * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        // If the buffer exceeds the target buffer, revert.\n        // If the buffer is insufficient, request a withdrawal to refill the buffer.\n        // note: use `>=` instead of `>` to prevent amount of ETH to withdraw to be 0\n        // note: At this point, `withdrawalQueueEth` is 0 because there is no pending withdrawal request.\n        // `nonStakedEth` = `bufferEth` + 0 = `bufferEth`\n        uint256 bufferEthCache = bufferEth;\n        if (bufferEthCache >= targetBufferEth) revert BufferTooLarge();\n\n        unchecked {\n            // Ensure that `withdrawAmount` is non-zero and withdrawalQueueEth is zero.\n            uint256 withdrawAmount = targetBufferEth - bufferEthCache; // no underflow\n\n            /// WRITE & INTERACT ///\n            // Record the pending withdrawal request\n            // Request a withdrawal\n            (uint256 queueAmount, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n            withdrawalQueueEth = queueAmount.toUint128();\n            requestId = _requestId;\n        }\n    }\n\n    /// @notice Request a withdrawal of all staked ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    function requestWithdrawalAll() external virtual;\n\n    /// @notice Claim the finized withdrawal request\n    /// @dev This function is called by anyone\n    /// @dev Reverts if there is no pending withdrawal request\n    function claimWithdrawal() external virtual;\n\n    /// @notice Stake the given amount of ETH into the yield source\n    /// @param stakeAmount The amount of ETH to stake\n    /// @return The actual amount of ETH spent\n    function _stake(uint256 stakeAmount) internal virtual returns (uint256);\n\n    /// @notice Request a withdrawal of the given amount of ETH from the yield source\n    /// @param withdrawAmount The amount of ETH to withdraw\n    /// @return queueAmount The amount of ETH withdrawn\n    /// @return requestId The request Id of the withdrawal request\n    function _requestWithdrawal(\n        uint256 withdrawAmount\n    ) internal virtual returns (uint256 queueAmount, uint256 requestId);\n\n    /// @dev Must be overridden by inheriting contracts\n    /// @inheritdoc ERC4626\n    function totalAssets() public view virtual override returns (uint256) {}\n\n    function scale() external view override returns (uint256) {\n        return convertToAssets(1e18);\n    }\n\n    /// @notice Returns the present buffer percentage in WAD. e.g) 10% => 0.1 * 1e18\n    function bufferPresentPercentage() external view returns (uint256) {\n        return ((bufferEth + withdrawalQueueEth) * BUFFER_PERCENTAGE_PRECISION) / totalAssets();\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADMIN METHOD\n    ////////////////////////////////////////////////////////\n\n    function setRebalancer(address _rebalancer) external onlyOwner {\n        rebalancer = _rebalancer;\n    }\n\n    /// @notice Set the maximum buffer percentage\n    /// @param _targetBufferPercentage The maximum buffer percentage in WAD\n    function setTargetBufferPercentage(uint256 _targetBufferPercentage) external onlyRebalancer {\n        if (_targetBufferPercentage < MIN_BUFFER_PERCENTAGE || _targetBufferPercentage > BUFFER_PERCENTAGE_PRECISION) {\n            revert InvalidBufferPercentage();\n        }\n        targetBufferPercentage = _targetBufferPercentage;\n    }\n\n    /////////////////////////////////////////////////////////\n    /// NOT IMPLEMENTED METHOD\n    /////////////////////////////////////////////////////////\n\n    /// @notice direct deposit,mint,redeem,withdraw should be reverted.\n    function deposit(uint256, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function mint(uint256, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function withdraw(uint256, address, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function redeem(uint256, address, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n}"
    },
    {
      "filename": "napier-v1/src/adapters/lido/StEtherAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IWETH9} from \"../../interfaces/IWETH9.sol\";\nimport {IStETH} from \"./interfaces/IStETH.sol\";\nimport {IWithdrawalQueueERC721} from \"./interfaces/IWithdrawalQueueERC721.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\nimport {BaseLSTAdapter} from \"../BaseLSTAdapter.sol\";\n\n/// @title StETHAdapter - estETH\n/// @dev Important security note:\n/// 1. The vault share price (estETH / WETH) increases as stETH accrues staking rewards.\n/// StETH withdrawals are processed by the Lido withdrawal queue contract.\n/// While waiting for the stETH withdrawal request to be finalized, estETH holders don't receive\n/// staking rewards from the pending stETH and still take risks during withdrawal.\n///\n/// 2. This contract doesn't independently keep track of the stETH balance, so it is possible\n/// for an attacker to directly transfer stETH to this contract, increase the share price.\ncontract StEtherAdapter is BaseLSTAdapter {\n    using SafeCast for uint256;\n\n    error InvariantViolation();\n\n    /// @notice stETH\n    IStETH constant STETH = IStETH(Constants.STETH);\n\n    /// @dev Lido WithdrawalQueueERC721\n    IWithdrawalQueueERC721 constant LIDO_WITHDRAWAL_QUEUE = IWithdrawalQueueERC721(Constants.LIDO_WITHDRAWAL_QUEUE);\n\n    receive() external payable {}\n\n    constructor(address _rebalancer) BaseLSTAdapter(_rebalancer) ERC20(\"Napier StETH Adapter\", \"eStETH\") {\n        STETH.approve(address(LIDO_WITHDRAWAL_QUEUE), type(uint256).max);\n    }\n\n    /// @notice Claim withdrawal from Lido\n    /// @dev Reverts if there is no pending withdrawal\n    /// @dev Reverts if the withdrawal request has not been finalized yet by Lido\n    /// @dev note estETH scale may be decreased if Lido has been slashed by misbehavior.\n    function claimWithdrawal() external override nonReentrant {\n        uint256 _requestId = requestId;\n        if (_requestId == 0) revert NoPendingWithdrawal();\n\n        /// WRITE ///\n        delete withdrawalQueueEth;\n        delete requestId;\n\n        /// INTERACT ///\n        // Claimed amount can be less than requested amount due to slashing.\n        uint256 balanceBefore = address(this).balance;\n        LIDO_WITHDRAWAL_QUEUE.claimWithdrawal(_requestId);\n        uint256 claimed = address(this).balance - balanceBefore;\n\n        /// WRITE ///\n        bufferEth += claimed.toUint128();\n\n        IWETH9(Constants.WETH).deposit{value: claimed}();\n    }\n\n    /// @inheritdoc BaseLSTAdapter\n    /// @dev Lido has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        uint256 stakeLimit = STETH.getCurrentStakeLimit();\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _stETHAmt = STETH.submit{value: stakeAmount}(address(this));\n\n        if (_stETHAmt == 0) revert InvariantViolation();\n        return stakeAmount;\n    }\n\n    /// @inheritdoc BaseLSTAdapter\n    /// @dev Lido has a limit on the amount of ETH that can be unstaked.\n    function requestWithdrawalAll() external override nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n        /// INTERACT ///\n        (uint256 queuedEth, uint256 _requestId) = _requestWithdrawal(STETH.balanceOf(address(this)));\n        /// WRITE ///\n        withdrawalQueueEth = queuedEth.toUint128();\n        requestId = _requestId;\n    }\n\n    /// @dev note stETH holders don't receive rewards but still take risks during withdrawal.\n    function _requestWithdrawal(uint256 withdrawAmount) internal override returns (uint256, uint256) {\n        // Validate withdrawAmount - https://docs.lido.fi/contracts/withdrawal-queue-erc721/#request\n        // The minimal amount for a request is 100 wei, and the maximum is 1000 eth\n        if (withdrawAmount < 100) return (0, 0);\n        if (withdrawAmount > 500 ether) withdrawAmount = 500 ether; // half of the maximum\n\n        // stETH amount\n        uint256[] memory _amounts = new uint256[](1);\n\n        /// INTERACT ///\n        // The amount of ether that will be withdrawn is limited to\n        // the number of stETH tokens transferred to this contract at the moment of request.\n        // So, we will not receive the rewards for the period of time while these tokens stay in the queue.\n        _amounts[0] = withdrawAmount;\n        uint256[] memory _requestIds = LIDO_WITHDRAWAL_QUEUE.requestWithdrawals(_amounts, address(this)); // Dev: Ensure id is not 0\n        if (_requestIds[0] == 0) revert InvariantViolation();\n\n        /// WRITE ///\n        return (withdrawAmount, _requestIds[0]);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        uint256 stEthBalance = STETH.balanceOf(address(this));\n        return withdrawalQueueEth + bufferEth + stEthBalance;\n    }\n}"
    },
    {
      "filename": "napier-v1/src/adapters/BaseLSTAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IWETH9} from \"../interfaces/IWETH9.sol\";\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\n\nimport {BaseAdapter} from \"../BaseAdapter.sol\";\nimport {ERC4626} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC4626.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {WETH} from \"../Constants.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapter is BaseAdapter, ERC4626, ReentrancyGuard {\n    using SafeCast for uint256;\n\n    uint256 constant BUFFER_PERCENTAGE_PRECISION = 1e18; // 1e18 = 100%\n    uint256 constant MIN_BUFFER_PERCENTAGE = 0.01 * 1e18; // 1%\n\n    /// @notice Rebalancer of the ETH buffer, can be set by the owner\n    /// @notice The account can request a withdrawal\n    address public rebalancer;\n\n    /// @notice Desired buffer percentage in WAD\n    uint256 public targetBufferPercentage = 0.1 * 1e18; // 10% desired buffer percentage\n\n    /// @notice Amount of ETH pending withdrawal\n    uint128 public withdrawalQueueEth;\n\n    /// @notice Amount of ETH available (Buffer), does not include pending withdrawal. Internal accounting of ETH\n    uint128 public bufferEth;\n\n    /// @notice Request ID of the withdrawal request\n    /// @dev 0 if there is no pending withdrawal request\n    uint256 public requestId;\n\n    error ZeroAssets();\n    error ZeroShares();\n    error InsufficientBuffer();\n    error BufferTooLarge();\n    error InvalidBufferPercentage();\n    error WithdrawalPending();\n    error NoPendingWithdrawal();\n    error NotRebalancer();\n    error NotImplemented();\n\n    /// @notice Reverts if the caller is not the rebalancer\n    modifier onlyRebalancer() {\n        if (rebalancer != msg.sender) revert NotRebalancer();\n        _;\n    }\n\n    /// @dev Adapter itself is the target token\n    constructor(address _rebalancer) BaseAdapter(WETH, address(this)) ERC4626((IWETH9(WETH))) {\n        rebalancer = _rebalancer;\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n        uint256 bufferEthCache = bufferEth; // cache storage reads\n        uint256 queueEthCache = withdrawalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (withdrawalQueueEth + bufferEth + assets - s) / (withdrawalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (withdrawalQueueEth + bufferEth + assets) - (withdrawalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (withdrawalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient: Doesn't stake any of the deposit\n        if (targetBufferEth >= availableEth + queueEthCache) {\n            bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        uint256 stakeAmount;\n        unchecked {\n            stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the stake amount exceeds 95% of the available ETH, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        //\n        // The condition: stakeAmount > availableEth, is equivalent to: queueEthCache > targetBufferEth\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        uint256 maxStakeAmount = (availableEth * 95) / 100;\n        if (stakeAmount > maxStakeAmount) {\n            stakeAmount = maxStakeAmount; // max 95% of the available ETH\n        }\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n\n    /// @notice Handles prefunded redemptions\n    /// @dev Withdraw from the buffer. If the buffer is insufficient, revert with an error\n    /// @param recipient The address to receive the redeemed WETH\n    /// @return The amount of redeemed WETH\n    /// @return The amount of shares burned\n    function prefundedRedeem(address recipient) external virtual returns (uint256, uint256) {\n        uint256 shares = balanceOf(address(this));\n        uint256 assets = previewRedeem(shares);\n\n        if (shares == 0) return (0, 0);\n        if (assets == 0) revert ZeroAssets();\n\n        uint256 bufferEthCache = bufferEth;\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n        if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        unchecked {\n            /// WRITE ///\n            // Reduce the buffer and burn the shares\n            bufferEth = (bufferEthCache - assets).toUint128(); // no underflow\n            _burn(address(this), shares);\n        }\n\n        /// INTERACT ///\n        IWETH9(WETH).transfer(recipient, assets);\n\n        return (assets, shares);\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIRTUAL METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Request a withdrawal of ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    /// @dev Reverts if the buffer is sufficient to cover the desired buffer percentage of the total assets\n    function requestWithdrawal() external virtual nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n\n        uint256 targetBufferEth = (totalAssets() * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        // If the buffer exceeds the target buffer, revert.\n        // If the buffer is insufficient, request a withdrawal to refill the buffer.\n        // note: use `>=` instead of `>` to prevent amount of ETH to withdraw to be 0\n        // note: At this point, `withdrawalQueueEth` is 0 because there is no pending withdrawal request.\n        // `nonStakedEth` = `bufferEth` + 0 = `bufferEth`\n        uint256 bufferEthCache = bufferEth;\n        if (bufferEthCache >= targetBufferEth) revert BufferTooLarge();\n\n        unchecked {\n            // Ensure that `withdrawAmount` is non-zero and withdrawalQueueEth is zero.\n            uint256 withdrawAmount = targetBufferEth - bufferEthCache; // no underflow\n\n            /// WRITE & INTERACT ///\n            // Record the pending withdrawal request\n            // Request a withdrawal\n            (uint256 queueAmount, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n            withdrawalQueueEth = queueAmount.toUint128();\n            requestId = _requestId;\n        }\n    }\n\n    /// @notice Request a withdrawal of all staked ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    function requestWithdrawalAll() external virtual;\n\n    /// @notice Claim the finized withdrawal request\n    /// @dev This function is called by anyone\n    /// @dev Reverts if there is no pending withdrawal request\n    function claimWithdrawal() external virtual;\n\n    /// @notice Stake the given amount of ETH into the yield source\n    /// @param stakeAmount The amount of ETH to stake\n    /// @return The actual amount of ETH spent\n    function _stake(uint256 stakeAmount) internal virtual returns (uint256);\n\n    /// @notice Request a withdrawal of the given amount of ETH from the yield source\n    /// @param withdrawAmount The amount of ETH to withdraw\n    /// @return queueAmount The amount of ETH withdrawn\n    /// @return requestId The request Id of the withdrawal request\n    function _requestWithdrawal(\n        uint256 withdrawAmount\n    ) internal virtual returns (uint256 queueAmount, uint256 requestId);\n\n    /// @dev Must be overridden by inheriting contracts\n    /// @inheritdoc ERC4626\n    function totalAssets() public view virtual override returns (uint256) {}\n\n    function scale() external view override returns (uint256) {\n        return convertToAssets(1e18);\n    }\n\n    /// @notice Returns the present buffer percentage in WAD. e.g) 10% => 0.1 * 1e18\n    function bufferPresentPercentage() external view returns (uint256) {\n        return ((bufferEth + withdrawalQueueEth) * BUFFER_PERCENTAGE_PRECISION) / totalAssets();\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADMIN METHOD\n    ////////////////////////////////////////////////////////\n\n    function setRebalancer(address _rebalancer) external onlyOwner {\n        rebalancer = _rebalancer;\n    }\n\n    /// @notice Set the maximum buffer percentage\n    /// @param _targetBufferPercentage The maximum buffer percentage in WAD\n    function setTargetBufferPercentage(uint256 _targetBufferPercentage) external onlyRebalancer {\n        if (_targetBufferPercentage < MIN_BUFFER_PERCENTAGE || _targetBufferPercentage > BUFFER_PERCENTAGE_PRECISION) {\n            revert InvalidBufferPercentage();\n        }\n        targetBufferPercentage = _targetBufferPercentage;\n    }\n\n    /////////////////////////////////////////////////////////\n    /// NOT IMPLEMENTED METHOD\n    /////////////////////////////////////////////////////////\n\n    /// @notice direct deposit,mint,redeem,withdraw should be reverted.\n    function deposit(uint256, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function mint(uint256, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function withdraw(uint256, address, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function redeem(uint256, address, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n}"
    }
  ]
}