{
  "Title": "[M-01] The Liquidity mining callpath sidecar owner can pull native tokens from the `Dex`",
  "Content": "\nThe owner of the liquidity mining sidecar can pull the native coins that are stored in the `CrocSwapDex` to reward the users.\n\n### Proof of Concept\n\nThe `setConcRewards` and `setAmbRewards` functions don't check if the quoted amount of rewards are actually sent by the caller. This allows the owner to specify any total amount of native coin which are available in the `CrocSwapDex` from which the funds will be used when distributing the rewards.\n\n```solidity\n    function setConcRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            concRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n```\n<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol#L65C7-L72>\n\n```solidity\n    function setAmbRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            ambRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n```\n<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol#L74-L81>\n\nAccording to [Ambient Docs](https://docs.ambient.finance/developers/token-transfers#native-ethereum) they allow for deposits in native tokens.\n\n### Demo\n\nUpdate TestLiquidityMining.js:\n\nThe funds added using `hardhat.setBalance()` is being used by the owner to distribute rewards\n\n```diff\ndiff --git a/canto_ambient/test_canto/TestLiquidityMining.js b/canto_ambient/test_canto/TestLiquidityMining.js\nindex bd21a32..b917308 100644\n--- a/canto_ambient/test_canto/TestLiquidityMining.js\n+++ b/canto_ambient/test_canto/TestLiquidityMining.js\n@@ -7,6 +7,7 @@ const { time } = require(\"@nomicfoundation/hardhat-network-helpers\");\n var keccak256 = require(\"@ethersproject/keccak256\").keccak256;\n \n const chai = require(\"chai\");\n+const { network, ethers } = require(\"hardhat\");\n const abi = new AbiCoder();\n \n const BOOT_PROXY_IDX = 0;\n@@ -218,7 +219,6 @@ describe(\"Liquidity Mining Tests\", function () {\n \t\t);\n \t\ttx = await dex.userCmd(2, mintConcentratedLiqCmd, {\n \t\t\tgasLimit: 6000000,\n-\t\t\tvalue: ethers.utils.parseUnits(\"10\", \"ether\"),\n \t\t});\n \t\tawait tx.wait();\n \n@@ -243,6 +243,17 @@ describe(\"Liquidity Mining Tests\", function () {\n \t\t\tBigNumber.from(\"999898351768\")\n \t\t);\n \n+\t\tlet dexBal = await ethers.provider.getBalance(dex.address);\n+\t\texpect(dexBal.eq(0)).to.be.eq(true);\n+\n+\t\t// dex gains native token from other methods\n+\t\tawait network.provider.send(\"hardhat_setBalance\", [\n+\t\t\tdex.address,\n+\t\t\tethers.utils.parseEther(\"2\").toHexString(),\n+\t\t  ]);\n+\t\tdexBal = await ethers.provider.getBalance(dex.address);\n+\t\texpect(dexBal.eq(ethers.utils.parseEther(\"2\"))).to.be.eq(true);\n+\n \t\t//////////////////////////////////////////////////\n \t\t// SET LIQUIDITY MINING REWARDS FOR CONCENTRATED LIQUIDITY\n \t\t//////////////////////////////////////////////////\n```\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nAdd a `msg.value` check in the rewards function to see that the total value is passed when call the functions.\n\n```diff\ndiff --git a/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol b/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol\nindex e6c63f7..44dd338 100644\n--- a/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol\n+++ b/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol\n@@ -65,6 +65,7 @@ contract LiquidityMiningPath is LiquidityMining {\n     function setConcRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n         // require(msg.sender == governance_, \"Only callable by governance\");\n         require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n+        require((1 +(weekTo - weekFrom) / WEEK) * weeklyReward == msg.value);\n         while (weekFrom <= weekTo) {\n             concRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n             weekFrom += uint32(WEEK);\n```\n\n### Assessed type\n\nRug-Pull\n\n**[OpenCoreCH (Canto) acknowledged and commented](https://github.com/code-423n4/2023-10-canto-findings/issues/295#issuecomment-1792892349):**\n> Rewards will be set and sent in the same Canto governance proposal.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-canto",
  "Code": [
    {
      "filename": "canto_ambient/contracts/callpaths/LiquidityMiningPath.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"../mixins/StorageLayout.sol\";\nimport \"../mixins/LiquidityMining.sol\";\nimport \"../libraries/ProtocolCmd.sol\";\n\n/* @title Liquidity mining callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains\n *         components related to CANTO liquidity mining.\n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary CrocSwap contract.\n * @dev Since this contract is a proxy sidecar, entrypoints need to be marked\n *      payable even though it doesn't directly handle msg.value. Otherwise it will\n *      fail on any. Because of this, this contract should never be used in any other\n *      context besides a proxy sidecar to CrocSwapDex. */\ncontract LiquidityMiningPath is LiquidityMining {\n    /* @notice Consolidated method for protocol control related commands. \n     *         Used to set reward rates */\n    function protocolCmd(bytes calldata cmd) public virtual {\n        (uint8 code, bytes32 poolHash, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) =\n            abi.decode(cmd, (uint8, bytes32, uint32, uint32, uint64));\n\n        if (code == ProtocolCmd.SET_CONC_REWARDS_CODE) {\n            setConcRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else if (code == ProtocolCmd.SET_AMB_REWARDS_CODE) {\n            setAmbRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else {\n            revert(\"Invalid protocol command\");\n        }\n    }\n\n    /* @notice Consolidated method for user commands.\n     *         Used for claiming liquidity mining rewards. */\n    function userCmd(bytes calldata input) public payable {\n        (uint8 code, bytes32 poolHash, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim) =\n            abi.decode(input, (uint8, bytes32, int24, int24, uint32[]));\n\n        if (code == UserCmd.CLAIM_CONC_REWARDS_CODE) {\n            claimConcentratedRewards(poolHash, lowerTick, upperTick, weeksToClaim);\n        } else if (code == UserCmd.CLAIM_AMB_REWARDS_CODE) {\n            claimAmbientRewards(poolHash, weeksToClaim);\n        } else {\n            revert(\"Invalid user command\");\n        }\n    }\n\n    function claimConcentratedRewards(bytes32 poolIdx, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim)\n        public\n        payable\n    {\n        claimConcentratedRewards(payable(msg.sender), poolIdx, lowerTick, upperTick, weeksToClaim);\n    }\n\n    function claimAmbientRewards(bytes32 poolIdx, uint32[] memory weeksToClaim) public payable {\n        claimAmbientRewards(payable(msg.sender), poolIdx, weeksToClaim);\n    }\n\n    function setConcRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            concRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    function setAmbRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            ambRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Croc sidecar proxy and used\n     *         in the correct slot. */\n    function acceptCrocProxyRole(address, uint16 slot) public pure returns (bool) {\n        return slot == CrocSlots.LIQUIDITY_MINING_PROXY_IDX;\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/callpaths/LiquidityMiningPath.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"../mixins/StorageLayout.sol\";\nimport \"../mixins/LiquidityMining.sol\";\nimport \"../libraries/ProtocolCmd.sol\";\n\n/* @title Liquidity mining callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains\n *         components related to CANTO liquidity mining.\n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary CrocSwap contract.\n * @dev Since this contract is a proxy sidecar, entrypoints need to be marked\n *      payable even though it doesn't directly handle msg.value. Otherwise it will\n *      fail on any. Because of this, this contract should never be used in any other\n *      context besides a proxy sidecar to CrocSwapDex. */\ncontract LiquidityMiningPath is LiquidityMining {\n    /* @notice Consolidated method for protocol control related commands. \n     *         Used to set reward rates */\n    function protocolCmd(bytes calldata cmd) public virtual {\n        (uint8 code, bytes32 poolHash, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) =\n            abi.decode(cmd, (uint8, bytes32, uint32, uint32, uint64));\n\n        if (code == ProtocolCmd.SET_CONC_REWARDS_CODE) {\n            setConcRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else if (code == ProtocolCmd.SET_AMB_REWARDS_CODE) {\n            setAmbRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else {\n            revert(\"Invalid protocol command\");\n        }\n    }\n\n    /* @notice Consolidated method for user commands.\n     *         Used for claiming liquidity mining rewards. */\n    function userCmd(bytes calldata input) public payable {\n        (uint8 code, bytes32 poolHash, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim) =\n            abi.decode(input, (uint8, bytes32, int24, int24, uint32[]));\n\n        if (code == UserCmd.CLAIM_CONC_REWARDS_CODE) {\n            claimConcentratedRewards(poolHash, lowerTick, upperTick, weeksToClaim);\n        } else if (code == UserCmd.CLAIM_AMB_REWARDS_CODE) {\n            claimAmbientRewards(poolHash, weeksToClaim);\n        } else {\n            revert(\"Invalid user command\");\n        }\n    }\n\n    function claimConcentratedRewards(bytes32 poolIdx, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim)\n        public\n        payable\n    {\n        claimConcentratedRewards(payable(msg.sender), poolIdx, lowerTick, upperTick, weeksToClaim);\n    }\n\n    function claimAmbientRewards(bytes32 poolIdx, uint32[] memory weeksToClaim) public payable {\n        claimAmbientRewards(payable(msg.sender), poolIdx, weeksToClaim);\n    }\n\n    function setConcRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            concRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    function setAmbRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            ambRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Croc sidecar proxy and used\n     *         in the correct slot. */\n    function acceptCrocProxyRole(address, uint16 slot) public pure returns (bool) {\n        return slot == CrocSlots.LIQUIDITY_MINING_PROXY_IDX;\n    }\n}"
    }
  ]
}