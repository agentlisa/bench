{
  "Title": "M-8: Problems with tokens that transfer less than amount. (Separate from fee-on-transfer issues!)",
  "Content": "# Issue M-8: Problems with tokens that transfer less than amount. (Separate from fee-on-transfer issues!) \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/379 \n\n## Found by \njkoppel\nSome tokens such as cUSDCv3  contain a special case for amount == type(uint256).max in their transfer functions that results in only the user's balance being transferred. This can be used to shut down several pool operations.\n\nThere are also problems with fee-on-transfer tokens, but that's a separate issue.\n\nThe contest FAQ states that all weird tokens should work with this protocol. I also asked the sponsor about this specific category of issues, and they said \"this does like something which can be taken advantage of !\"\n\n## Vulnerability Detail\n\nSeveral things that can go wrong with this:\n\n1. An attacker can put dust of this token in a wallet, and then call allo.fundPool() with type(uint256).max of this token. If the pool has not already been funded, then poolAmount will not be at type(uint256).max  despite nothing being in the pool. It is now not possible to fund the pool.\n\n2. Someone can do this in the DonationVotingMerkleDistributionVaultStrategy to set someones claim of this token to type(uint256).max . It is now impossible for anyone else to donate this token to them.\n\n## Impact\n\nPools cannot work with such tokens\n\n## Code Snippet\n\nSee, e.g.: https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/donation-voting-merkle-distribution-vault/DonationVotingMerkleDistributionVaultStrategy.sol#L125\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nExplicitly do not support these tokens\n\n\n\n## Discussion\n\n**jkoppel**\n\nEscalate.\n\nThis is not a duplicate of #19. This involves a separate class of token. The available attacks are different, as discussed in the write-up.  This is discussed in the issue write-up and confirmed with sponsor.\n\n**sherlock-admin2**\n\n > Escalate.\n> \n> This is not a duplicate of #19. This involves a separate class of token. The available attacks are different, as discussed in the write-up.  This is discussed in the issue write-up and confirmed with sponsor.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nAgree with escalation, this is a valid issue on its on and not at all related to FOT tokens since all ERC-20 tokens are supported.  \n\n**0x00ffDa**\n\nValid separate issue, but possibly Low since the impacts listed are DoS / griefing rather than loss of funds. \n\n**jkoppel**\n\nIt causes loss of the base fee.\n\n**0x00ffDa**\n\n> It causes loss of the base fee.\n\n... which can be refunded by the protocol owner using `Allo.recoverFunds()`.\n\n**jkoppel**\n\nThere's not clear guidance in the docs, but I can think of other cases where the existence of admin workarounds was insufficient to disqualify something as a medium. n.B. The fee is sent to the treasury, not the Allo contract. Can't use `recoverFunds`.\n\n**neeksec**\n\nSuggest to make this low/info.\n\nSince this is a rare token type and the impact(losing base fee which could be refunded by Allo team) is low.\n\n**Evert0x**\n\nPlanning to reject escalation and keep issue state as is.\n\nThe impact of this issue is not clear to me. \n> Pools cannot work with such tokens\n\nDoes this mean other pool users can't get out? What is the impact on people?\n\nIn case the impact is significant I will consider assigning medium. \n\n\n**jkoppel**\n\nI mentioned two attacks. It means that multiple attacks are available if someone creates a pool with this token or  tries to use it in donation voting, even though the contract is supposed to work with all token types. \n\n**MLON33**\n\nhttps://github.com/allo-protocol/allo-v2/pull/355\nhttps://github.com/allo-protocol/allo-v2/pull/381\n\n**Evert0x**\n\nCopied from README\n\n> Do you expect to use any of the following tokens with non-standard behaviour with the smart contracts?\nYes as we support all ERC20 tokens.\n\nIt's clear that the issue is in scope. The question to answer is, what is the impact of this issue?\n\nThe impact is basically\n- DOS on pool funding\n- DOS on donations\n- Small loss of funds that can technically be recovered but it isn't easy to do so. \n\nAlthough the language in the judging guidelines should be improved, I plan on making this a separate Medium because of the following rule. \n\n> Breaks core contract functionality, rendering the contract useless (should not be easily replaced without loss of funds) or leading to unknown potential exploits/loss of funds. \nEx: Unable to remove malicious user/collateral from the contract.\n\nThe two DOS attacks can break the core contract functionality. In case a pool is popular, it's a blow to the protocol if that pool is suddenly unavailable. It's not easily replaced.  \n\n\n\n\n**Evert0x**\n\nResult:\nMedium\nUnique \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [jkoppel](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/379/#issuecomment-1762790504): accepted\n\n**Evert0x**\n\n@jkoppel I might have misinterpreted the report and was under the assumption it would brick other deposits as well (e.g. USDC, WETH,..)\n\nBut I think the scope is only limited to tokens that have this special case \"amount == type(uint256).max\" in their transfer function\n\nIn that case the following rule should be applied as the issue is only related to these tokens.\n> Non-Standard tokens: Issues related to tokens with non-standard behaviors, such as [weird-tokens](https://github.com/d-xo/weird-erc20) are not considered valid by default unless these tokens are explicitly mentioned in the README.\n\n**jkoppel**\n\nBut it is mentioned in the README.\n\nThe protocol team was asked this question as part of the standard intake questionnaire.\n\n> Do you expect to use any of the following tokens with non-standard behaviour with the smart contracts?\n\nAs part of this question, they were presented a list of tokens with weird behavior, including this one.\n\nThey responded:\n\n> Yes as we support all ERC20 tokens.\n\nThis should be taken to mean the same as if they had listed every token they were asked about.\n\n**AhmadDecoded**\n\n@jkoppel \nPosted this in discord now posting it here.\n\nhey i think there is need to check the validity of the claim:\n```\nSome tokens such as cUSDCv3 contain a special case for amount == type(uint256).max in their transfer functions that results in only the user's balance being transferred. This can be used to shut down several pool operations.\n```\n\nWhich have been copied from :\n\nhttps://github.com/d-xo/weird-erc20\n\nBut as I confirmed from the compound dev, that is only true for internal transfer with in the compound v3 vaults\n\nThe code for the ctoken itself does not work like that and works as any standard erc20 token\n\nSo the token that you gave example of cusdcv3, that token itself would work fine with the protocol, so in this case the submission becomes arbitrary and invalid anyways, anyone can craft example of a token that may not work with one or other functionality.\n\nConsidering the sherlock rules just add another layer of argument.\n\n\n\n**AhmadDecoded**\n\n![image](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/assets/68193826/1bc1d034-c7c3-4c72-98a1-73b3b6fbc40f)\n\nHere you can see what the dev have to say, also you can look into code yourself, the functionality you mentioned is for internal transfer with in compound v3 vaults in comet files, transfer between accounts works as any normal working erc20 tokens.\n\n**nevillehuang**\n\nI found the ERC20 implementation of `transferFrom` of the [cUSDCv3 token](https://etherscan.io/address/0xbfc4feec175996c08c8f3a0469793a7979526065#code):\n\n```solidity\n    function transferFrom(address src, address dst, uint amount) override external returns (bool) {\n        transferInternal(msg.sender, src, dst, baseToken, amount);\n        return true;\n    }\n```\n\nwhich calls the internal `transferInternal` function here so I think the dev might be incorrect here.  If you call fundpool with type(uint256).max it seems like it does only transfer the amount of tokens the user owns.\n```solidity\n    function transferInternal(address operator, address src, address dst, address asset, uint amount) internal {\n        if (isTransferPaused()) revert Paused();\n        if (!hasPermission(src, operator)) revert Unauthorized();\n        if (src == dst) revert NoSelfTransfer();\n\n        if (asset == baseToken) {\n            if (amount == type(uint256).max) {\n                amount = balanceOf(src);\n            }\n            return transferBase(src, dst, amount);\n        } else {\n            return transferCollateral(src, dst, asset, safe128(amount));\n        }\n    }\n```\n\nNow comes the dilemma between whether this behavior is \"weird\" token or not (which is not considered valid in sherlocks guidelines) or is the contest READ.ME on the question about non-standard tokens takes priority (sherlock guidelines states the contest details is the single source of truth).  One thing important to note that while I could not find much data on the use of this token, it has a [total market valuation of >$350 million dollars](https://coinmarketcap.com/dexscan/ethereum/0x1be94918e967bcfda70456a3c7ca5dcf27b233a8/), which is quite significant. \n\nI will let @Evert0x decide on this one but I am leaning towards validating this issue. But perhaps moving forward, more defined rules revolving weird ERC20 tokens needs to be considered.\n\n**AhmadDecoded**\n\n@nevillehuang you are checking wrong contract üôÇ\nComet file represent the market for that token, not the token itself. \nThose all transfer functions are for internal transfers within that market. Should have asked before commenting.\n\nAs far as the question whether the behaviour is weird or not if it exists, this example have been taken directly from the weird tokens github repo.\n\n**AhmadDecoded**\n\n@quentin-abei you are trying to create mess to impose your decision on judge here. We are discussing validity as the token implementation is being misjudged here. If you want to comvince judge for your issue do it under your own issue, don't try negative reinforcement.\n\n**nevillehuang**\n\n> @nevillehuang you are checking wrong contract üôÇ Comet file represent the market for that token, not the token itself. Those all transfer functions are for internal transfers within that market. Should have asked before commenting.\n\nOh, could you then point me to the correct contract and function details? My understanding is cUSDv3 is a proxy of the implementation contract i linked. Perhaps @jkoppel should assist in this since burden of proof is on the watson.\n\n**jkoppel**\n\nNot having seen the discussion here, I just spent about 30 minutes hunting for the cUSDCv3 contract. The final answer would require unraveling their deployment scripts, but I'm pretty sure Neville is correct, sans a nitpick. \n\nThe description for the Comet repo is \"An efficient money market protocol for Ethereum and compatible chains (aka Compound III, Compound v3).\" So this looks like the right place.\n\nThere are no references to the string \"cUSDCv3\" in the code. But there are several in configuration files.\n\nComet.sol implements 5 of the 7 ERC20 methods, all but `name` and `symbol`.\n\nThis diagram states that Comet delegatecalls to CometExt: https://github.com/compound-finance/comet/blob/22cf923b6263177555272dde8b0791703895517d/diagrams/inheritance_diagram.uml . You can see that Comet does indeed implement fallback() and delegatecall's all other methods to another contract: https://github.com/compound-finance/comet/blob/22cf923b6263177555272dde8b0791703895517d/contracts/Comet.sol#L1318\n\nCometExt provides the missing name() and symbol() methods, which it pulls from data: https://github.com/compound-finance/comet/blob/22cf923b6263177555272dde8b0791703895517d/contracts/CometExt.sol#L71\n\nSo it looks indeed that Comet.sol is in fact the implementation code for cUSDCv3, and it does have the issue reported in the Weird ERC20 repo. \n\nIn conclusion: cUSDCv3 is almost certainly a deployment of Comet.sol where some functionality is provided by delegating to a deployment of CometExt.sol.\n\nI have also E-mailed the person who added this issue  to the Weird ERC20 repo to confirm.\n\n\nI think what probably caused the confusion is that the Compound dev saw the function name `transferInternal` and misunderstood it. It appears this dev has edited the documentation in this repo, but has not actually touched protocol code. https://github.com/compound-finance/comet/commits?author=ajb413\n\n**Evert0x**\n\nIt seems like @jkoppel is correct that the `cUSDCv3` token contains the behavior described in his initial report. \n\nIt's a hard judgment to make as the context QA doesn't align with the judging guidelines\n\nREADME states\n> Do you expect to use any of the following tokens with non-standard behavior with the smart contracts?\n> Yes as we support all ERC20 tokens.\n\nJudging rules state\n> Issues related to tokens with non-standard behaviors, such as [weird-tokens](https://github.com/d-xo/weird-erc20) are not considered valid by default unless these tokens are **explicitly** mentioned in the README.\n\n`cUSDCv3` is not explicitly mentioned in the README. But the protocol indicated they plan on supporting any token with non-standard behavior. \n\nThe last resort is to depend on the opinion of the protocol, they confirmed the issue and are even planning on fixing the issue. \n\n\n\n\n**AhmadDecoded**\n\nOk my mistake, I ran a simulation on tenderly, it does actually works like described.\n\nI will leave it here, now upto judge for the final decision about the ruling on the weird tokens.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "allo-v2/contracts/strategies/donation-voting-merkle-distribution-vault/DonationVotingMerkleDistributionVaultStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ISignatureTransfer} from \"permit2/ISignatureTransfer.sol\";\nimport {DonationVotingMerkleDistributionBaseStrategy} from\n    \"../donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeTransferLib} from \"solady/src/utils/SafeTransferLib.sol\";\n\n// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£ø‚£ø‚£ø‚£ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚£ø‚£ø‚£ø‚¢ø‚£ø‚£ø‚£ø‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∞‚£ø‚£ø‚£ø‚°ü‚†ò‚£ø‚£ø‚£ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚£æ‚£ø‚£ø‚£ø‚£ø‚£æ‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚°ø‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£¥‚£¥‚£∂‚£∂‚£∂‚£¶‚£¶‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†É‚†Ä‚†ô‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ø‚†Å‚†Ä‚†Ä‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∂‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†Å‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£ø‚£ø‚£ø‚£Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚†Ä‚£∞‚£ø‚£ø‚£ø‚°ø‚†ã‚†Å‚†Ä‚†Ä‚†à‚†ò‚†π‚£ø‚£ø‚£ø‚£ø‚£Ü‚†Ä‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£ø‚£ø‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚¢∞‚£ø‚£ø‚£ø‚£ø‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£ø‚£ø‚°Ä‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ü‚†Ä‚°Ä‚¢Ä‚†Ä‚°Ä‚¢Ä‚†Ä‚°Ä‚¢à‚¢ø‚°ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚°á‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚£†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†ã‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£∂‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚£ø‚£ø‚£ø‚°ø‚¢ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚¢ø‚£ø‚£ø‚£ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ø‚†Ç‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚†ô‚†õ‚†ø‚†ª‚†ª‚†õ‚†â‚†Ä‚†Ä‚†à‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∞‚£ø‚£ø‚£ø‚£ø‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ø‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£∑‚£Ä‚¢Ä‚†Ä‚†Ä‚†Ä‚°Ä‚£∞‚£æ‚£ø‚£ø‚£ø‚†è‚†Ä‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†õ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚£ø‚£ø‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ó‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ø‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚¢ø‚£ø‚£ø‚£ø‚£ø‚£æ‚£æ‚£∑‚£ø‚£ø‚£ø‚£ø‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä\n// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ô‚†ã‚†õ‚†ô‚†ã‚†õ‚†ô‚†ã‚†õ‚†ô‚†ã‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†ø‚†ª‚†ü‚†ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚†ü‚†ø‚†ü‚†ø‚†Ü‚†Ä‚†∏‚†ø‚†ø‚†ü‚†Ø‚†Ä‚†Ä‚†Ä‚†∏‚†ø‚†ø‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†ª‚†ª‚°ø‚£ø‚¢ø‚°ø‚°ø‚†ø‚†õ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n//                    allo.gitcoin.co\n\n/// @title Donation Voting Merkle Distribution Strategy\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Strategy for donation voting allocation with a merkle distribution\ncontract DonationVotingMerkleDistributionVaultStrategy is\n    DonationVotingMerkleDistributionBaseStrategy,\n    ReentrancyGuardUpgradeable\n{\n    /// @notice Stores the details of the allocations to claim.\n    struct Claim {\n        address recipientId;\n        address token;\n    }\n\n    /// ===============================\n    /// ========== Events =============\n    /// ===============================\n\n    /// @notice Emitted when a recipient has claimed their allocated funds\n    /// @param recipientId Id of the recipient\n    /// @param recipientAddress Address of the recipient\n    /// @param amount Amount of tokens claimed\n    /// @param token Address of the token\n    event Claimed(address indexed recipientId, address recipientAddress, uint256 amount, address token);\n\n    /// ================================\n    /// ========== Storage =============\n    /// ================================\n\n    /// @notice 'recipientId' => 'token' => 'amount'.\n    mapping(address => mapping(address => uint256)) public claims;\n\n    /// ===============================\n    /// ======== Constructor ==========\n    /// ===============================\n\n    /// @notice Constructor for the Donation Voting Merkle Distribution Strategy\n    /// @param _allo The 'Allo' contract\n    /// @param _name The name of the strategy\n    constructor(address _allo, string memory _name, ISignatureTransfer _permit2)\n        DonationVotingMerkleDistributionBaseStrategy(_allo, _name, _permit2)\n    {}\n\n    /// @notice Claim allocated tokens for recipients.\n    /// @dev Uses the merkle root to verify the claims. Allocation must have ended to claim.\n    /// @param _claims Claims to be claimed\n    function claim(Claim[] calldata _claims) external nonReentrant onlyAfterAllocation {\n        uint256 claimsLength = _claims.length;\n\n        // Loop through the claims\n        for (uint256 i; i < claimsLength;) {\n            Claim memory singleClaim = _claims[i];\n            Recipient memory recipient = _recipients[singleClaim.recipientId];\n            uint256 amount = claims[singleClaim.recipientId][singleClaim.token];\n\n            // If the claim amount is zero this will revert\n            if (amount == 0) {\n                revert INVALID();\n            }\n\n            /// Delete the claim from the mapping\n            delete claims[singleClaim.recipientId][singleClaim.token];\n\n            address token = singleClaim.token;\n\n            // Transfer the tokens to the recipient\n            _transferAmount(token, recipient.recipientAddress, amount);\n\n            // Emit that the tokens have been claimed and sent to the recipient\n            emit Claimed(singleClaim.recipientId, recipient.recipientAddress, amount, token);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// ================================\n    /// ============ Hooks =============\n    /// ================================\n\n    /// @notice After allocation hook to store the allocated tokens in the vault\n    /// @param _data The encoded recipientId, amount and token\n    /// @param _sender The sender of the allocation\n    function _afterAllocate(bytes memory _data, address _sender) internal override {\n        // Decode the '_data' to get the recipientId, amount and token\n        (address recipientId, Permit2Data memory p2Data) = abi.decode(_data, (address, Permit2Data));\n\n        // Get the token address\n        address token = p2Data.permit.permitted.token;\n        uint256 amount = p2Data.permit.permitted.amount;\n\n        if (token == NATIVE) {\n            if (msg.value < amount) {\n                revert AMOUNT_MISMATCH();\n            }\n            SafeTransferLib.safeTransferETH(address(this), amount);\n        } else {\n            PERMIT2.permitTransferFrom(\n                // The permit message.\n                p2Data.permit,\n                // The transfer recipient and amount.\n                ISignatureTransfer.SignatureTransferDetails({to: address(this), requestedAmount: amount}),\n                // Owner of the tokens and signer of the message.\n                _sender,\n                // The packed signature that was the result of signing\n                // the EIP712 hash of `_permit`.\n                p2Data.signature\n            );\n        }\n\n        // Update the total payout amount for the claim\n        claims[recipientId][token] += amount;\n    }\n}"
    },
    {
      "filename": "contracts/CometExt.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.15;\n\nimport \"./CometExtInterface.sol\";\n\ncontract CometExt is CometExtInterface {\n    /** Public constants **/\n\n    /// @notice The major version of this contract\n    string public override constant version = \"0\";\n\n    /** Internal constants **/\n\n    /// @dev The EIP-712 typehash for the contract's domain\n    bytes32 internal constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @dev The EIP-712 typehash for allowBySig Authorization\n    bytes32 internal constant AUTHORIZATION_TYPEHASH = keccak256(\"Authorization(address owner,address manager,bool isAllowed,uint256 nonce,uint256 expiry)\");\n\n    /// @dev The highest valid value for s in an ECDSA signature pair (0 < s < secp256k1n √∑ 2 + 1)\n    ///  See https://ethereum.github.io/yellowpaper/paper.pdf #307)\n    uint internal constant MAX_VALID_ECDSA_S = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n\n    /** Immutable symbol **/\n\n    /// @dev The ERC20 name for wrapped base token\n    bytes32 internal immutable name32;\n\n    /// @dev The ERC20 symbol for wrapped base token\n    bytes32 internal immutable symbol32;\n\n    /**\n     * @notice Construct a new protocol instance\n     * @param config The mapping of initial/constant parameters\n     **/\n    constructor(ExtConfiguration memory config) {\n        name32 = config.name32;\n        symbol32 = config.symbol32;\n    }\n\n    /** External getters for internal constants **/\n\n    function baseAccrualScale() override external pure returns (uint64) { return BASE_ACCRUAL_SCALE; }\n    function baseIndexScale() override external pure returns (uint64) { return BASE_INDEX_SCALE; }\n    function factorScale() override external pure returns (uint64) { return FACTOR_SCALE; }\n    function priceScale() override external pure returns (uint64) { return PRICE_SCALE; }\n    function maxAssets() override external pure returns (uint8) { return MAX_ASSETS; }\n\n    /**\n     * @notice Aggregate variables tracked for the entire market\n     **/\n    function totalsBasic() public override view returns (TotalsBasic memory) {\n        return TotalsBasic({\n            baseSupplyIndex: baseSupplyIndex,\n            baseBorrowIndex: baseBorrowIndex,\n            trackingSupplyIndex: trackingSupplyIndex,\n            trackingBorrowIndex: trackingBorrowIndex,\n            totalSupplyBase: totalSupplyBase,\n            totalBorrowBase: totalBorrowBase,\n            lastAccrualTime: lastAccrualTime,\n            pauseFlags: pauseFlags\n        });\n    }\n\n    /** Additional ERC20 functionality and approval interface **/\n\n    /**\n     * @notice Get the ERC20 name for wrapped base token\n     * @return The name as a string\n     */\n    function name() override public view returns (string memory) {\n        uint8 i;\n        for (i = 0; i < 32; ) {\n            if (name32[i] == 0) {\n                break;\n            }\n            unchecked { i++; }\n        }\n        bytes memory name_ = new bytes(i);\n        for (uint8 j = 0; j < i; ) {\n            name_[j] = name32[j];\n            unchecked { j++; }\n        }\n        return string(name_);\n    }\n\n    /**\n     * @notice Get the ERC20 symbol for wrapped base token\n     * @return The symbol as a string\n     */\n    function symbol() override external view returns (string memory) {\n        uint8 i;\n        for (i = 0; i < 32; ) {\n            if (symbol32[i] == 0) {\n                break;\n            }\n            unchecked { i++; }\n        }\n        bytes memory symbol_ = new bytes(i);\n        for (uint8 j = 0; j < i; ) {\n            symbol_[j] = symbol32[j];\n            unchecked { j++; }\n        }\n        return string(symbol_);\n    }\n\n    /**\n     * @notice Query the current collateral balance of an account\n     * @param account The account whose balance to query\n     * @param asset The collateral asset to check the balance for\n     * @return The collateral balance of the account\n     */\n    function collateralBalanceOf(address account, address asset) override external view returns (uint128) {\n        return userCollateral[account][asset].balance;\n    }\n\n    /**\n     * @notice Query the total accrued base rewards for an account\n     * @param account The account to query\n     * @return The accrued rewards, scaled by `BASE_ACCRUAL_SCALE`\n     */\n    function baseTrackingAccrued(address account) override external view returns (uint64) {\n        return userBasic[account].baseTrackingAccrued;\n    }\n\n    /**\n      * @notice Approve or disallow `spender` to transfer on sender's behalf\n      * @dev Note: this binary approval is unlike most other ERC20 tokens\n      * @dev Note: this grants full approval for spender to manage *all* the owner's assets\n      * @param spender The address of the account which may transfer tokens\n      * @param amount Either uint.max (to allow) or zero (to disallow)\n      * @return Whether or not the approval change succeeded\n      */\n    function approve(address spender, uint256 amount) override external returns (bool) {\n        if (amount == type(uint256).max) {\n            allowInternal(msg.sender, spender, true);\n        } else if (amount == 0) {\n            allowInternal(msg.sender, spender, false);\n        } else {\n            revert BadAmount();\n        }\n        return true;\n    }\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @dev Note: this binary allowance is unlike most other ERC20 tokens\n      * @dev Note: this allowance allows spender to manage *all* the owner's assets\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return Either uint.max (spender is allowed) or zero (spender is disallowed)\n      */\n    function allowance(address owner, address spender) override external view returns (uint256) {\n        return hasPermission(owner, spender) ? type(uint256).max : 0;\n    }\n\n    /**\n     * @notice Allow or disallow another address to withdraw, or transfer from the sender\n     * @param manager The account which will be allowed or disallowed\n     * @param isAllowed_ Whether to allow or disallow\n     */\n    function allow(address manager, bool isAllowed_) override external {\n        allowInternal(msg.sender, manager, isAllowed_);\n    }\n\n    /**\n     * @dev Stores the flag marking whether the manager is allowed to act on behalf of owner\n     */\n    function allowInternal(address owner, address manager, bool isAllowed_) internal {\n        isAllowed[owner][manager] = isAllowed_;\n        emit Approval(owner, manager, isAllowed_ ? type(uint256).max : 0);\n    }\n\n    /**\n     * @notice Sets authorization status for a manager via signature from signatory\n     * @param owner The address that signed the signature\n     * @param manager The address to authorize (or rescind authorization from)\n     * @param isAllowed_ Whether to authorize or rescind authorization from manager\n     * @param nonce The next expected nonce value for the signatory\n     * @param expiry Expiration time for the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function allowBySig(\n        address owner,\n        address manager,\n        bool isAllowed_,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) override external {\n        if (uint256(s) > MAX_VALID_ECDSA_S) revert InvalidValueS();\n        // v ‚àà {27, 28} (source: https://ethereum.github.io/yellowpaper/paper.pdf #308)\n        if (v != 27 && v != 28) revert InvalidValueV();\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), keccak256(bytes(version)), block.chainid, address(this)));\n        bytes32 structHash = keccak256(abi.encode(AUTHORIZATION_TYPEHASH, owner, manager, isAllowed_, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        if (signatory == address(0)) revert BadSignatory();\n        if (owner != signatory) revert BadSignatory();\n        if (nonce != userNonce[signatory]++) revert BadNonce();\n        if (block.timestamp >= expiry) revert SignatureExpired();\n        allowInternal(signatory, manager, isAllowed_);\n    }\n}"
    }
  ]
}