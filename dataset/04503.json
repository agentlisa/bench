{
  "Title": "Invalid address check uses assert",
  "Content": "The `relay` function of the `Marmo` contract [fails when the signer is the invalid address](https://github.com/ripio/marmo-contracts/blob/d3fb5922a4f01e47d585343d08cccfad659b3584/contracts/Marmo.sol#L103). This failure is executed with the `assert` function, so if somebody calls an invalidated contract by mistake, they will lose their gas.\n\n\nConsider using `require` instead of `assert` to be more forgiving and return the remaining gas when an invalidated contract is called. Also, the semantics of the `require` statement are closer to the intent of this feature.\n\n\n***Update:*** *Fixed in* [*pull request #34*](https://github.com/ripio/marmo-contracts/pull/34/files)*.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Marmo.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./commons/SigUtils.sol\";\n\n/*\n    Marmo wallet\n\n    It has a signer, and it accepts signed messages ´Intents´ (Meta-Txs)\n    all messages are composed by an interpreter and a ´data´ field.\n*/\ncontract Marmo {\n    event Relayed(bytes32 indexed _id, address _implementation, bytes _data);\n    event Canceled(bytes32 indexed _id);\n\n    // Invalid signer address, outside of restricted address range (0 - 65535)\n    address private constant INVALID_ADDRESS = address(65536);\n\n    // Random slot to store signer\n    bytes32 private constant SIGNER_SLOT = keccak256(\"marmo.wallet.signer\");\n\n    // [1 bit (canceled) 95 bits (block) 160 bits (relayer)]\n    mapping(bytes32 => bytes32) private intentReceipt;\n\n    function() external payable {}\n\n    // Inits the wallet, any address can Init\n    // it must be called using another contract\n    function init(address _signer) external payable {\n        address signer;\n        bytes32 signerSlot = SIGNER_SLOT;\n        assembly { signer := sload(signerSlot) }\n        require(signer == address(0), \"Signer already defined\");\n        assembly { sstore(signerSlot, _signer) }\n    }\n\n    // Signer of the Marmo wallet\n    // can perform transactions by signing Intents\n    function signer() public view returns (address _signer) {\n        bytes32 signerSlot = SIGNER_SLOT;\n        assembly { _signer := sload(signerSlot) }\n    } \n\n    // Address that relayed the `_id` intent\n    // address(0) if the intent was not relayed\n    function relayedBy(bytes32 _id) external view returns (address _relayer) {\n        (,,_relayer) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    // Block when the intent was relayed\n    // 0 if the intent was not relayed\n    function relayedAt(bytes32 _id) external view returns (uint256 _block) {\n        (,_block,) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    // True if the intent was canceled\n    // An executed intent can't be canceled and\n    // a Canceled intent can't be executed\n    function isCanceled(bytes32 _id) external view returns (bool _canceled) {\n        (_canceled,,) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    // Relay a signed intent\n    //\n    // The implementation receives data containing the id of the 'intent' and its data,\n    // and it will perform all subsequent calls.\n    //\n    // The same _implementation and _data combination can only be relayed once\n    //\n    // Returns the result of the 'delegatecall' execution\n    function relay(\n        address _implementation,\n        bytes calldata _data,\n        bytes calldata _signature\n    ) external payable returns (\n        bytes memory result\n    ) {\n        // Calculate ID from\n        // (this, _implementation, data)\n        // Any change in _data results in a different ID\n        bytes32 id = keccak256(\n            abi.encodePacked(\n                address(this),\n                _implementation,\n                keccak256(_data)\n            )\n        );\n\n        // Read receipt only once\n        // if the receipt is 0, the Intent was not canceled or relayed\n        if (intentReceipt[id] != bytes32(0)) {\n            // Decode the receipt and determine if the Intent was canceled or relayer\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[id]);\n            require(relayer == address(0), \"Intent already relayed\");\n            require(!canceled, \"Intent was canceled\");\n            revert(\"Unknown error\");\n        }\n\n        // Read the signer from storage, avoid multiples 'sload' ops\n        address _signer = signer();\n\n        // The signer 'INVALID_ADDRESS' is considered invalid and it will always throw\n        // this is meant to destroy the wallet safely\n        assert(_signer != INVALID_ADDRESS);\n\n        // Validate is the msg.sender is the signer or if the provided signature is valid\n        require(_signer == msg.sender || _signer == SigUtils.ecrecover2(id, _signature), \"Invalid signature\");\n\n        // Save the receipt before performing any other action\n        intentReceipt[id] = _encodeReceipt(false, block.number, msg.sender);\n\n        // Emit the 'relayed' event\n        emit Relayed(id, _implementation, _data);\n\n        // Perform 'delegatecall' to _implementation, appending the id of the intent\n        // to the beginning of the _data.\n\n        bool success;\n        (success, result) = _implementation.delegatecall(abi.encode(id, _data));\n\n        // If the 'delegatecall' failed, reverts the transaction\n        // forwarding the revert message\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    // Cancels a not executed Intent '_id'\n    // a canceled intent can't be executed\n    function cancel(bytes32 _id) external {\n        require(msg.sender == address(this), \"Only wallet can cancel txs\");\n\n        if (intentReceipt[_id] != bytes32(0)) {\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[_id]);\n            require(relayer == address(0), \"Intent already relayed\");\n            require(!canceled, \"Intent was canceled\");\n            revert(\"Unknown error\");\n        }\n\n        intentReceipt[_id] = _encodeReceipt(true, 0, address(0));\n    }\n\n    // Encodes an Intent receipt\n    // into a single bytes32\n    // canceled (1 bit) + block (95 bits) + relayer (160 bits)\n    // notice: Does not validate the _block length,\n    // a _block overflow would not corrupt the wallet state\n    function _encodeReceipt(\n        bool _canceled,\n        uint256 _block,\n        address _relayer\n    ) internal pure returns (bytes32 _receipt) {\n        assembly {\n            _receipt := or(shl(255, _canceled), or(shl(160, _block), _relayer))\n        }\n    }\n    \n    // Decodes an Intent receipt\n    // reverse of _encodeReceipt(bool,uint256,address)\n    function _decodeReceipt(bytes32 _receipt) internal pure returns (\n        bool _canceled,\n        uint256 _block,\n        address _relayer\n    ) {\n        assembly {\n            _canceled := shr(255, _receipt)\n            _block := and(shr(160, _receipt), 0x7fffffffffffffffffffffff)\n            _relayer := and(_receipt, 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}"
    }
  ]
}