{
  "Title": "[M-10] Users are susceptible to back-running when depositing ETH to `TridenRouter`",
  "Content": "_Submitted by broccoli_\n\n#### Impact\nThe `_depositToBentoBox` and `_depositFromUserToBentoBox` allow users to provide ETH to the router, which is later deposited to the `bento` contract for swapping other assets or providing liquidity. However, in these two functions, the input parameter does not represent the actual amount of ETH to deposit, and users have to calculate the actual amount and send it to the router, causing a back-run vulnerability if there are ETH left after the operation.\n\n#### Proof of Concept\n1.  A user wants to swap ETH to DAI. He calls `exactInputSingleWithNativeToken` on the router with the corresponding parameters and `params.amountIn` being 10. Before calling the function, he calculates `bento.toAmount(wETH, 10, true) = 15` and thus send 15 ETH to the router.\n2.  However, at the time when his transaction is executed, `bento.toAmount(wETH, amount, true)` becomes to `14`, which could happen if someone calls `harvest` on `bento` to update the `elastic` value of the `wETH` token.\n3.  As a result, only 14 ETH is transferred to the pool, and 1 ETH is left in the router. Anyone could back-run the user's transaction to retrieve the remaining 1 ETH from the router by calling the `refundETH` function.\n\nReferenced code: [TridentRouter.sol#L318-L351](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L318-L351)\n\n#### Recommended Mitigation Steps\nDirectly push the remaining ETH to the sender to prevent any ETH left in the router.\n\n**[maxsam4 (Sushi) confirmed](https://github.com/code-423n4/2021-09-sushitrident-findings/issues/179#issuecomment-934388751):**\n > I think it's low risk because it's basically arbitrage and we have protection for the user in terms of \"minOutputAmount\". I will be reworking ETH handling to avoid this issue completely.\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2021-09-sushitrident-findings/issues/179#issuecomment-950567287):**\n > It's a loss of funds, not arbitrage. It should be prevented or documented. Sustained.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-09-sushitrident",
  "Code": [
    {
      "filename": "contracts/TridentRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./interfaces/IBentoBoxMinimal.sol\";\nimport \"./interfaces/IPool.sol\";\nimport \"./interfaces/ITridentRouter.sol\";\nimport \"./utils/TridentHelper.sol\";\nimport \"./deployer/MasterDeployer.sol\";\n\n//import \"hardhat/console.sol\";\n\n/// @notice Router contract that helps in swapping across Trident pools.\ncontract TridentRouter is ITridentRouter, TridentHelper {\n    /// @notice BentoBox token vault.\n    IBentoBoxMinimal public immutable bento;\n    MasterDeployer public immutable masterDeployer;\n\n    /// @dev Used to ensure that `tridentSwapCallback` is called only by the authorized address.\n    /// These are set when someone calls a flash swap and reset afterwards.\n    address internal cachedMsgSender;\n    address internal cachedPool;\n\n    mapping(address => bool) internal whitelistedPools;\n\n    constructor(\n        IBentoBoxMinimal _bento,\n        MasterDeployer _masterDeployer,\n        address _wETH\n    ) TridentHelper(_wETH) {\n        _bento.registerProtocol();\n        bento = _bento;\n        masterDeployer = _masterDeployer;\n    }\n\n    receive() external payable {\n        require(msg.sender == wETH);\n    }\n\n    /// @notice Swaps token A to token B directly. Swaps are done on `bento` tokens.\n    /// @param params This includes the address of token A, pool, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pool for the swap.\n    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.\n    function exactInputSingle(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {\n        // @dev Prefund the pool with token A.\n        bento.transfer(params.tokenIn, msg.sender, params.pool, params.amountIn);\n        // @dev Trigger the swap in the pool.\n        amountOut = IPool(params.pool).swap(params.data);\n        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        require(amountOut >= params.amountOutMinimum, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Swaps token A to token B indirectly by using multiple hops.\n    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pools for the swaps.\n    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.\n    function exactInput(ExactInputParams calldata params) public payable returns (uint256 amountOut) {\n        // @dev Pay the first pool directly.\n        bento.transfer(params.tokenIn, msg.sender, params.path[0].pool, params.amountIn);\n        // @dev Call every pool in the path.\n        // Pool `N` should transfer its output tokens to pool `N+1` directly.\n        // The last pool should transfer its output tokens to the user.\n        // If the user wants to unwrap `wETH`, the final destination should be this contract and\n        // a batch call should be made to `unwrapWETH`.\n        for (uint256 i; i < params.path.length; i++) {\n            // We don't necessarily need this check but saving users from themseleves.\n            isWhiteListed(params.path[i].pool);\n            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);\n        }\n        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        require(amountOut >= params.amountOutMinimum, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Swaps token A to token B by using callbacks.\n    /// @param path Addresses of the pools and data required by the pools for the swaps.\n    /// @param amountOutMinimum Minimum amount of token B after the swap.\n    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.\n    /// This function will unlikely be used in production but it shows how to use callbacks. One use case will be arbitrage.\n    function exactInputLazy(uint256 amountOutMinimum, Path[] calldata path) public payable returns (uint256 amountOut) {\n        // @dev Call every pool in the path.\n        // Pool `N` should transfer its output tokens to pool `N+1` directly.\n        // The last pool should transfer its output tokens to the user.\n        for (uint256 i; i < path.length; i++) {\n            isWhiteListed(path[i].pool);\n            // @dev The cached `msg.sender` is used as the funder when the callback happens.\n            cachedMsgSender = msg.sender;\n            // @dev The cached pool must be the address that calls the callback.\n            cachedPool = path[i].pool;\n            amountOut = IPool(path[i].pool).flashSwap(path[i].data);\n        }\n        // @dev Resets the `cachedPool` to get a refund.\n        // `1` is used as the default value to avoid the storage slot being released.\n        cachedMsgSender = address(1);\n        cachedPool = address(1);\n        require(amountOut >= amountOutMinimum, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Swaps token A to token B directly. It's the same as `exactInputSingle` except\n    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.\n    /// @param params This includes the address of token A, pool, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pool for the swap.\n    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.\n    function exactInputSingleWithNativeToken(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {\n        // @dev Deposits the native ERC-20 token from the user into the pool's `bento`.\n        _depositToBentoBox(params.tokenIn, params.pool, params.amountIn);\n        // @dev Trigger the swap in the pool.\n        amountOut = IPool(params.pool).swap(params.data);\n        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        require(amountOut >= params.amountOutMinimum, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Swaps token A to token B indirectly by using multiple hops. It's the same as `exactInput` except\n    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.\n    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pools for the swaps.\n    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.\n    function exactInputWithNativeToken(ExactInputParams calldata params) public payable returns (uint256 amountOut) {\n        // @dev Deposits the native ERC-20 token from the user into the pool's `bento`.\n        _depositToBentoBox(params.tokenIn, params.path[0].pool, params.amountIn);\n        // @dev Call every pool in the path.\n        // Pool `N` should transfer its output tokens to pool `N+1` directly.\n        // The last pool should transfer its output tokens to the user.\n        for (uint256 i; i < params.path.length; i++) {\n            isWhiteListed(params.path[i].pool);\n            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);\n        }\n        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        require(amountOut >= params.amountOutMinimum, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Swaps multiple input tokens to multiple output tokens using multiple paths, in different percentages.\n    /// For example, you can swap 50 DAI + 100 USDC into 60% ETH and 40% BTC.\n    /// @param params This includes everything needed for the swap. Look at the `ComplexPathParams` struct for more details.\n    /// @dev This function is not optimized for single swaps and should only be used in complex cases where\n    /// the amounts are large enough that minimizing slippage by using multiple paths is worth the extra gas.\n    function complexPath(ComplexPathParams calldata params) public payable {\n        // @dev Deposit all initial tokens to respective pools and initiate the swaps.\n        // Input tokens come from the user - output goes to following pools.\n        for (uint256 i; i < params.initialPath.length; i++) {\n            if (params.initialPath[i].native) {\n                _depositToBentoBox(params.initialPath[i].tokenIn, params.initialPath[i].pool, params.initialPath[i].amount);\n            } else {\n                bento.transfer(params.initialPath[i].tokenIn, msg.sender, params.initialPath[i].pool, params.initialPath[i].amount);\n            }\n            isWhiteListed(params.initialPath[i].pool);\n            IPool(params.initialPath[i].pool).swap(params.initialPath[i].data);\n        }\n        // @dev Do all the middle swaps. Input comes from previous pools - output goes to following pools.\n        for (uint256 i; i < params.percentagePath.length; i++) {\n            uint256 balanceShares = bento.balanceOf(params.percentagePath[i].tokenIn, address(this));\n            uint256 transferShares = (balanceShares * params.percentagePath[i].balancePercentage) / uint256(10)**8;\n            bento.transfer(params.percentagePath[i].tokenIn, address(this), params.percentagePath[i].pool, transferShares);\n            isWhiteListed(params.percentagePath[i].pool);\n            IPool(params.percentagePath[i].pool).swap(params.percentagePath[i].data);\n        }\n        // @dev Do all the final swaps. Input comes from previous pools - output goes to the user.\n        for (uint256 i; i < params.output.length; i++) {\n            uint256 balanceShares = bento.balanceOf(params.output[i].token, address(this));\n            require(balanceShares >= params.output[i].minAmount, \"TOO_LITTLE_RECEIVED\");\n            if (params.output[i].unwrapBento) {\n                bento.withdraw(params.output[i].token, address(this), params.output[i].to, 0, balanceShares);\n            } else {\n                bento.transfer(params.output[i].token, address(this), params.output[i].to, balanceShares);\n            }\n        }\n    }\n\n    /// @notice Add liquidity to a pool.\n    /// @param tokenInput Token address and amount to add as liquidity.\n    /// @param pool Pool address to add liquidity to.\n    /// @param minLiquidity Minimum output liquidity - caps slippage.\n    /// @param data Data required by the pool to add liquidity.\n    function addLiquidity(\n        TokenInput[] memory tokenInput,\n        address pool,\n        uint256 minLiquidity,\n        bytes calldata data\n    ) public payable returns (uint256 liquidity) {\n        isWhiteListed(pool);\n        // @dev Send all input tokens to the pool.\n        for (uint256 i; i < tokenInput.length; i++) {\n            if (tokenInput[i].native) {\n                _depositToBentoBox(tokenInput[i].token, pool, tokenInput[i].amount);\n            } else {\n                bento.transfer(tokenInput[i].token, msg.sender, pool, tokenInput[i].amount);\n            }\n        }\n        liquidity = IPool(pool).mint(data);\n        require(liquidity >= minLiquidity, \"NOT_ENOUGH_LIQUIDITY_MINTED\");\n    }\n\n    /// @notice Add liquidity to a pool using callbacks - same as `addLiquidity`, but now with callbacks.\n    /// @dev The input tokens are sent to the pool during the callback.\n    function addLiquidityLazy(\n        address pool,\n        uint256 minLiquidity,\n        bytes calldata data\n    ) public payable returns (uint256 liquidity) {\n        isWhiteListed(pool);\n        cachedMsgSender = msg.sender;\n        cachedPool = pool;\n        // @dev The pool must ensure that there's not too much slippage.\n        liquidity = IPool(pool).mint(data);\n        cachedMsgSender = address(1);\n        cachedPool = address(1);\n        require(liquidity >= minLiquidity, \"NOT_ENOUGH_LIQUIDITY_MINTED\");\n    }\n\n    /// @notice Burn liquidity tokens to get back `bento` tokens.\n    /// @param pool Pool address.\n    /// @param liquidity Amount of liquidity tokens to burn.\n    /// @param data Data required by the pool to burn liquidity.\n    /// @param minWithdrawals Minimum amount of `bento` tokens to be returned.\n    function burnLiquidity(\n        address pool,\n        uint256 liquidity,\n        bytes calldata data,\n        IPool.TokenAmount[] memory minWithdrawals\n    ) public {\n        isWhiteListed(pool);\n        safeTransferFrom(pool, msg.sender, pool, liquidity);\n        IPool.TokenAmount[] memory withdrawnLiquidity = IPool(pool).burn(data);\n        for (uint256 i; i < minWithdrawals.length; i++) {\n            uint256 j;\n            for (; j < withdrawnLiquidity.length; j++) {\n                if (withdrawnLiquidity[j].token == minWithdrawals[i].token) {\n                    require(withdrawnLiquidity[j].amount >= minWithdrawals[i].amount, \"TOO_LITTLE_RECEIVED\");\n                    break;\n                }\n            }\n            // @dev A token that is present in `minWithdrawals` is missing from `withdrawnLiquidity`.\n            require(j < withdrawnLiquidity.length, \"INCORRECT_TOKEN_WITHDRAWN\");\n        }\n    }\n\n    /// @notice Burn liquidity tokens to get back `bento` tokens.\n    /// @dev The tokens are swapped automatically and the output is in a single token.\n    /// @param pool Pool address.\n    /// @param liquidity Amount of liquidity tokens to burn.\n    /// @param data Data required by the pool to burn liquidity.\n    /// @param minWithdrawal Minimum amount of tokens to be returned.\n    function burnLiquiditySingle(\n        address pool,\n        uint256 liquidity,\n        bytes calldata data,\n        uint256 minWithdrawal\n    ) public {\n        isWhiteListed(pool);\n        // @dev Use 'liquidity = 0' for prefunding.\n        safeTransferFrom(pool, msg.sender, pool, liquidity);\n        uint256 withdrawn = IPool(pool).burnSingle(data);\n        require(withdrawn >= minWithdrawal, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Used by the pool 'flashSwap' functionality to take input tokens from the user.\n    function tridentSwapCallback(bytes calldata data) external {\n        require(msg.sender == cachedPool, \"UNAUTHORIZED_CALLBACK\");\n        TokenInput memory tokenInput = abi.decode(data, (TokenInput));\n        // @dev Transfer the requested tokens to the pool.\n        if (tokenInput.native) {\n            _depositFromUserToBentoBox(tokenInput.token, cachedMsgSender, msg.sender, tokenInput.amount);\n        } else {\n            bento.transfer(tokenInput.token, cachedMsgSender, msg.sender, tokenInput.amount);\n        }\n        // @dev Resets the `msg.sender`'s authorization.\n        cachedMsgSender = address(1);\n    }\n\n    /// @notice Can be used by the pool 'mint' functionality to take tokens from the user.\n    function tridentMintCallback(bytes calldata data) external {\n        require(msg.sender == cachedPool, \"UNAUTHORIZED_CALLBACK\");\n        TokenInput[] memory tokenInput = abi.decode(data, (TokenInput[]));\n        // @dev Transfer the requested tokens to the pool.\n        for (uint256 i; i < tokenInput.length; i++) {\n            if (tokenInput[i].native) {\n                _depositFromUserToBentoBox(tokenInput[i].token, cachedMsgSender, msg.sender, tokenInput[i].amount);\n            } else {\n                bento.transfer(tokenInput[i].token, cachedMsgSender, msg.sender, tokenInput[i].amount);\n            }\n        }\n        // @dev Resets the `msg.sender`'s authorization.\n        cachedMsgSender = address(1);\n    }\n\n    /// @notice Recover mistakenly sent `bento` tokens.\n    function sweepBentoBoxToken(\n        address token,\n        uint256 amount,\n        address recipient\n    ) external {\n        bento.transfer(token, address(this), recipient, amount);\n    }\n\n    /// @notice Recover mistakenly sent ERC-20 tokens.\n    function sweepNativeToken(\n        address token,\n        uint256 amount,\n        address recipient\n    ) external {\n        safeTransfer(token, recipient, amount);\n    }\n\n    /// @notice Recover mistakenly sent ETH.\n    function refundETH() external payable {\n        if (address(this).balance != 0) safeTransferETH(msg.sender, address(this).balance);\n    }\n\n    /// @notice Unwrap this contract's `wETH` into ETH\n    function unwrapWETH(uint256 amountMinimum, address recipient) external {\n        uint256 balanceWETH = balanceOfThis(wETH);\n        require(balanceWETH >= amountMinimum, \"INSUFFICIENT_WETH\");\n        if (balanceWETH != 0) {\n            withdrawFromWETH(balanceWETH);\n            safeTransferETH(recipient, balanceWETH);\n        }\n    }\n\n    function _depositToBentoBox(\n        address token,\n        address recipient,\n        uint256 amount\n    ) internal {\n        if (token == wETH && address(this).balance != 0) {\n            uint256 underlyingAmount = bento.toAmount(wETH, amount, true);\n            if (address(this).balance >= underlyingAmount) {\n                // @dev Deposit ETH into `recipient` `bento` account.\n                bento.deposit{value: underlyingAmount}(address(0), address(this), recipient, 0, amount);\n                return;\n            }\n        }\n        // @dev Deposit ERC-20 token into `recipient` `bento` account.\n        bento.deposit(token, msg.sender, recipient, 0, amount);\n    }\n\n    function _depositFromUserToBentoBox(\n        address token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        if (token == wETH && address(this).balance != 0) {\n            uint256 underlyingAmount = bento.toAmount(wETH, amount, true);\n            if (address(this).balance >= underlyingAmount) {\n                // @dev Deposit ETH into `recipient` `bento` account.\n                bento.deposit{value: underlyingAmount}(address(0), address(this), recipient, 0, amount);\n                return;\n            }\n        }\n        // @dev Deposit ERC-20 token into `recipient` `bento` account.\n        bento.deposit(token, sender, recipient, 0, amount);\n    }\n\n    function isWhiteListed(address pool) internal {\n        if (!whitelistedPools[pool]) {\n            require(masterDeployer.pools(pool), \"INVALID POOL\");\n            whitelistedPools[pool] = true;\n        }\n    }\n}"
    }
  ]
}