{
  "Title": "[L06] Lack of input validation",
  "Content": "In the [`AddressBook` contract](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/AddressBook.sol#L13):\n\n\n* The [`setOtokenImpl` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/AddressBook.sol#L108) does not check if the given address is zero. Although this function is currently restricted to onlyOwner, future updates might allow other permitted roles to call this function.\n\n\nIn the [`Oracle` contract](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Oracle.sol#L16):\n\n\n* The [`getExpiryPrice` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Oracle.sol#L80) does not check if the asset exists in the platform or not.\n* The [`disputeExpiryPrice` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Oracle.sol#L215) allows the disputer to send a zero price value, and because it would be the final number after the disputing period is over, a zero price could revert a division calculation in other contracts that use that value.\n\n\nIn the [`Whitelist` contract](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Whitelist.sol#L12):\n\n\n* The [`whitelistProduct`](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Whitelist.sol#L131), [`whitelistCollateral`](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Whitelist.sol#L171), [`whitelistOtoken`](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Whitelist.sol#L193), and [`whitelisteCallee`](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Whitelist.sol#L215) functions do not check if the input is already whitelisted.\n* The [`blacklistProduct`](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Whitelist.sol#L153), [`blacklistCollateral`](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Whitelist.sol#L182), [`blacklistOtoken`](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Whitelist.sol#L204), and [`blacklistCallee`](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Whitelist.sol#L226) functions do not check if the input is already blacklisted.\n\n\nIn the [`Otoken` contract](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Otoken.sol#L16):\n\n\n* The [`_slice` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Otoken.sol#L224) does not check if the `_end` is before the `_start` and the operation is made without the protection of the `SafeMath` library. However, the function is only used once and both values cannot be less than 1, case that would end up with an empty string.\n\n\nIn the [`MarginVault` library](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/libs/MarginVault.sol#L16):\n\n\n* The [`removeShort`](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/libs/MarginVault.sol#L75), [`removeLong`](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/libs/MarginVault.sol#L132), and [`removeCollateral`](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/libs/MarginVault.sol#L190) functions do not check if the given amount is zero as the [counter functions to add assets do](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/libs/MarginVault.sol#L50).\n\n\nEven though this issue does not pose a security risk, the lack of validation on user-controlled parameters may result in erroneous transactions considering that some clients may default to sending null parameters if none are specified. To favor explicitness and avoid unexpected behaviors, consider implementing require statements where appropriate to validate these parameters.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/AddressBook.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\nimport {Ownable} from \"./packages/oz/Ownable.sol\";\nimport {OwnedUpgradeabilityProxy} from \"./packages/oz/upgradeability/OwnedUpgradeabilityProxy.sol\";\n\n/**\n * @author Opyn Team\n * @title AddressBook Module\n */\ncontract AddressBook is Ownable {\n    /// @dev Otoken implementation key\n    bytes32 private constant OTOKEN_IMPL = \"OTOKEN_IMPL\";\n    /// @dev OtokenFactory key\n    bytes32 private constant OTOKEN_FACTORY = \"OTOKEN_FACTORY\";\n    /// @dev Whitelist key\n    bytes32 private constant WHITELIST = \"WHITELIST\";\n    /// @dev Controller key\n    bytes32 private constant CONTROLLER = \"CONTROLLER\";\n    /// @dev MarginPool key\n    bytes32 private constant MARGIN_POOL = \"MARGIN_POOL\";\n    /// @dev MarginCalculator key\n    bytes32 private constant MARGIN_CALCULATOR = \"MARGIN_CALCULATOR\";\n    /// @dev LiquidationManager key\n    bytes32 private constant LIQUIDATION_MANAGER = \"LIQUIDATION_MANAGER\";\n    /// @dev Oracle key\n    bytes32 private constant ORACLE = \"ORACLE\";\n\n    /// @dev mapping between key and address\n    mapping(bytes32 => address) private addresses;\n\n    /// @notice emits an event when a new proxy is created\n    event ProxyCreated(bytes32 id, address proxy);\n    /// @notice emits an event when a new address is added\n    event AddressAdded(bytes32 id, address add);\n\n    /**\n     * @notice return Otoken implementation address\n     * @return Otoken implementation address\n     */\n    function getOtokenImpl() external view returns (address) {\n        return getAddress(OTOKEN_IMPL);\n    }\n\n    /**\n     * @notice return oTokenFactory address\n     * @return OtokenFactory address\n     */\n    function getOtokenFactory() external view returns (address) {\n        return getAddress(OTOKEN_FACTORY);\n    }\n\n    /**\n     * @notice return Whitelist address\n     * @return Whitelist address\n     */\n    function getWhitelist() external view returns (address) {\n        return getAddress(WHITELIST);\n    }\n\n    /**\n     * @notice return Controller address\n     * @return Controller address\n     */\n    function getController() external view returns (address) {\n        return getAddress(CONTROLLER);\n    }\n\n    /**\n     * @notice return MarginPool address\n     * @return MarginPool address\n     */\n    function getMarginPool() external view returns (address) {\n        return getAddress(MARGIN_POOL);\n    }\n\n    /**\n     * @notice return MarginCalculator address\n     * @return MarginCalculator address\n     */\n    function getMarginCalculator() external view returns (address) {\n        return getAddress(MARGIN_CALCULATOR);\n    }\n\n    /**\n     * @notice return LiquidationManager address\n     * @return LiquidationManager address\n     */\n    function getLiquidationManager() external view returns (address) {\n        return getAddress(LIQUIDATION_MANAGER);\n    }\n\n    /**\n     * @notice return Oracle address\n     * @return Oracle address\n     */\n    function getOracle() external view returns (address) {\n        return getAddress(ORACLE);\n    }\n\n    /**\n     * @notice set Otoken implementation address\n     * @dev can only be called by the addressbook owner\n     * @param _otokenImpl Otoken implementation address\n     */\n    function setOtokenImpl(address _otokenImpl) external onlyOwner {\n        setAddress(OTOKEN_IMPL, _otokenImpl);\n    }\n\n    /**\n     * @notice set OtokenFactory address\n     * @dev can only be called by the addressbook owner\n     * @param _otokenFactory OtokenFactory address\n     */\n    function setOtokenFactory(address _otokenFactory) external onlyOwner {\n        setAddress(OTOKEN_FACTORY, _otokenFactory);\n    }\n\n    /**\n     * @notice set Whitelist address\n     * @dev can only be called by the addressbook owner\n     * @param _whitelist Whitelist address\n     */\n    function setWhitelist(address _whitelist) external onlyOwner {\n        setAddress(WHITELIST, _whitelist);\n    }\n\n    /**\n     * @notice set Controller address\n     * @dev can only be called by the addressbook owner\n     * @param _controller Controller address\n     */\n    function setController(address _controller) external onlyOwner {\n        updateImpl(CONTROLLER, _controller);\n    }\n\n    /**\n     * @notice set MarginPool address\n     * @dev can only be called by the addressbook owner\n     * @param _marginPool MarginPool address\n     */\n    function setMarginPool(address _marginPool) external onlyOwner {\n        setAddress(MARGIN_POOL, _marginPool);\n    }\n\n    /**\n     * @notice set MarginCalculator address\n     * @dev can only be called by the addressbook owner\n     * @param _marginCalculator MarginCalculator address\n     */\n    function setMarginCalculator(address _marginCalculator) external onlyOwner {\n        setAddress(MARGIN_CALCULATOR, _marginCalculator);\n    }\n\n    /**\n     * @notice set LiquidationManager address\n     * @dev can only be called by the addressbook owner\n     * @param _liquidationManager LiquidationManager address\n     */\n    function setLiquidationManager(address _liquidationManager) external onlyOwner {\n        setAddress(LIQUIDATION_MANAGER, _liquidationManager);\n    }\n\n    /**\n     * @notice set Oracle address\n     * @dev can only be called by the addressbook owner\n     * @param _oracle Oracle address\n     */\n    function setOracle(address _oracle) external onlyOwner {\n        setAddress(ORACLE, _oracle);\n    }\n\n    /**\n     * @notice return an address for specific key\n     * @param _key key address\n     * @return address\n     */\n    function getAddress(bytes32 _key) public view returns (address) {\n        return addresses[_key];\n    }\n\n    /**\n     * @notice set a specific address for a specific key\n     * @dev can only be called by the addressbook owner\n     * @param _key key\n     * @param _address address\n     */\n    function setAddress(bytes32 _key, address _address) public onlyOwner {\n        addresses[_key] = _address;\n\n        emit AddressAdded(_key, _address);\n    }\n\n    /**\n     * @dev internal function to update the implementation of a specific component of the protocol\n     * @param _id id of the contract to be updated\n     * @param _newAddress address of the new implementation\n     **/\n    function updateImpl(bytes32 _id, address _newAddress) public onlyOwner {\n        address payable proxyAddress = address(uint160(getAddress(_id)));\n\n        bytes memory params = abi.encodeWithSignature(\"initialize(address,address)\", address(this), owner());\n\n        if (proxyAddress == address(0)) {\n            OwnedUpgradeabilityProxy proxy = new OwnedUpgradeabilityProxy();\n            setAddress(_id, address(proxy));\n            emit ProxyCreated(_id, address(proxy));\n            proxy.upgradeToAndCall(_newAddress, params);\n        } else {\n            OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(proxyAddress);\n            proxy.upgradeTo(_newAddress);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/AddressBook.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\nimport {Ownable} from \"./packages/oz/Ownable.sol\";\nimport {OwnedUpgradeabilityProxy} from \"./packages/oz/upgradeability/OwnedUpgradeabilityProxy.sol\";\n\n/**\n * @author Opyn Team\n * @title AddressBook Module\n */\ncontract AddressBook is Ownable {\n    /// @dev Otoken implementation key\n    bytes32 private constant OTOKEN_IMPL = \"OTOKEN_IMPL\";\n    /// @dev OtokenFactory key\n    bytes32 private constant OTOKEN_FACTORY = \"OTOKEN_FACTORY\";\n    /// @dev Whitelist key\n    bytes32 private constant WHITELIST = \"WHITELIST\";\n    /// @dev Controller key\n    bytes32 private constant CONTROLLER = \"CONTROLLER\";\n    /// @dev MarginPool key\n    bytes32 private constant MARGIN_POOL = \"MARGIN_POOL\";\n    /// @dev MarginCalculator key\n    bytes32 private constant MARGIN_CALCULATOR = \"MARGIN_CALCULATOR\";\n    /// @dev LiquidationManager key\n    bytes32 private constant LIQUIDATION_MANAGER = \"LIQUIDATION_MANAGER\";\n    /// @dev Oracle key\n    bytes32 private constant ORACLE = \"ORACLE\";\n\n    /// @dev mapping between key and address\n    mapping(bytes32 => address) private addresses;\n\n    /// @notice emits an event when a new proxy is created\n    event ProxyCreated(bytes32 id, address proxy);\n    /// @notice emits an event when a new address is added\n    event AddressAdded(bytes32 id, address add);\n\n    /**\n     * @notice return Otoken implementation address\n     * @return Otoken implementation address\n     */\n    function getOtokenImpl() external view returns (address) {\n        return getAddress(OTOKEN_IMPL);\n    }\n\n    /**\n     * @notice return oTokenFactory address\n     * @return OtokenFactory address\n     */\n    function getOtokenFactory() external view returns (address) {\n        return getAddress(OTOKEN_FACTORY);\n    }\n\n    /**\n     * @notice return Whitelist address\n     * @return Whitelist address\n     */\n    function getWhitelist() external view returns (address) {\n        return getAddress(WHITELIST);\n    }\n\n    /**\n     * @notice return Controller address\n     * @return Controller address\n     */\n    function getController() external view returns (address) {\n        return getAddress(CONTROLLER);\n    }\n\n    /**\n     * @notice return MarginPool address\n     * @return MarginPool address\n     */\n    function getMarginPool() external view returns (address) {\n        return getAddress(MARGIN_POOL);\n    }\n\n    /**\n     * @notice return MarginCalculator address\n     * @return MarginCalculator address\n     */\n    function getMarginCalculator() external view returns (address) {\n        return getAddress(MARGIN_CALCULATOR);\n    }\n\n    /**\n     * @notice return LiquidationManager address\n     * @return LiquidationManager address\n     */\n    function getLiquidationManager() external view returns (address) {\n        return getAddress(LIQUIDATION_MANAGER);\n    }\n\n    /**\n     * @notice return Oracle address\n     * @return Oracle address\n     */\n    function getOracle() external view returns (address) {\n        return getAddress(ORACLE);\n    }\n\n    /**\n     * @notice set Otoken implementation address\n     * @dev can only be called by the addressbook owner\n     * @param _otokenImpl Otoken implementation address\n     */\n    function setOtokenImpl(address _otokenImpl) external onlyOwner {\n        setAddress(OTOKEN_IMPL, _otokenImpl);\n    }\n\n    /**\n     * @notice set OtokenFactory address\n     * @dev can only be called by the addressbook owner\n     * @param _otokenFactory OtokenFactory address\n     */\n    function setOtokenFactory(address _otokenFactory) external onlyOwner {\n        setAddress(OTOKEN_FACTORY, _otokenFactory);\n    }\n\n    /**\n     * @notice set Whitelist address\n     * @dev can only be called by the addressbook owner\n     * @param _whitelist Whitelist address\n     */\n    function setWhitelist(address _whitelist) external onlyOwner {\n        setAddress(WHITELIST, _whitelist);\n    }\n\n    /**\n     * @notice set Controller address\n     * @dev can only be called by the addressbook owner\n     * @param _controller Controller address\n     */\n    function setController(address _controller) external onlyOwner {\n        updateImpl(CONTROLLER, _controller);\n    }\n\n    /**\n     * @notice set MarginPool address\n     * @dev can only be called by the addressbook owner\n     * @param _marginPool MarginPool address\n     */\n    function setMarginPool(address _marginPool) external onlyOwner {\n        setAddress(MARGIN_POOL, _marginPool);\n    }\n\n    /**\n     * @notice set MarginCalculator address\n     * @dev can only be called by the addressbook owner\n     * @param _marginCalculator MarginCalculator address\n     */\n    function setMarginCalculator(address _marginCalculator) external onlyOwner {\n        setAddress(MARGIN_CALCULATOR, _marginCalculator);\n    }\n\n    /**\n     * @notice set LiquidationManager address\n     * @dev can only be called by the addressbook owner\n     * @param _liquidationManager LiquidationManager address\n     */\n    function setLiquidationManager(address _liquidationManager) external onlyOwner {\n        setAddress(LIQUIDATION_MANAGER, _liquidationManager);\n    }\n\n    /**\n     * @notice set Oracle address\n     * @dev can only be called by the addressbook owner\n     * @param _oracle Oracle address\n     */\n    function setOracle(address _oracle) external onlyOwner {\n        setAddress(ORACLE, _oracle);\n    }\n\n    /**\n     * @notice return an address for specific key\n     * @param _key key address\n     * @return address\n     */\n    function getAddress(bytes32 _key) public view returns (address) {\n        return addresses[_key];\n    }\n\n    /**\n     * @notice set a specific address for a specific key\n     * @dev can only be called by the addressbook owner\n     * @param _key key\n     * @param _address address\n     */\n    function setAddress(bytes32 _key, address _address) public onlyOwner {\n        addresses[_key] = _address;\n\n        emit AddressAdded(_key, _address);\n    }\n\n    /**\n     * @dev internal function to update the implementation of a specific component of the protocol\n     * @param _id id of the contract to be updated\n     * @param _newAddress address of the new implementation\n     **/\n    function updateImpl(bytes32 _id, address _newAddress) public onlyOwner {\n        address payable proxyAddress = address(uint160(getAddress(_id)));\n\n        bytes memory params = abi.encodeWithSignature(\"initialize(address,address)\", address(this), owner());\n\n        if (proxyAddress == address(0)) {\n            OwnedUpgradeabilityProxy proxy = new OwnedUpgradeabilityProxy();\n            setAddress(_id, address(proxy));\n            emit ProxyCreated(_id, address(proxy));\n            proxy.upgradeToAndCall(_newAddress, params);\n        } else {\n            OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(proxyAddress);\n            proxy.upgradeTo(_newAddress);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Oracle.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\nimport {OpynPricerInterface} from \"./interfaces/OpynPricerInterface.sol\";\nimport {Ownable} from \"./packages/oz/Ownable.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\n\n/**\n * @author Opyn Team\n * @title Oracle Module\n * @notice The Oracle module sets, retrieves, and stores USD prices (USD per asset) for underlying, collateral, and strike assets\n * manages pricers that are used for different assets\n */\ncontract Oracle is Ownable {\n    using SafeMath for uint256;\n\n    /// @dev structure that stores price of asset and timestamp when the price was stored\n    struct Price {\n        uint256 price;\n        uint256 timestamp; // timestamp at which the price is pushed to this oracle\n    }\n\n    /// @dev mapping of asset pricer to its locking period\n    /// locking period is the period of time after the expiry timestamp where a price can not be pushed\n    mapping(address => uint256) internal pricerLockingPeriod;\n    /// @dev mapping of asset pricer to its dispute period\n    /// dispute period is the period of time after an expiry price has been pushed where a price can be disputed\n    mapping(address => uint256) internal pricerDisputePeriod;\n    /// @dev mapping between an asset and its pricer\n    mapping(address => address) internal assetPricer;\n    /// @dev mapping between asset, expiry timestamp, and the Price structure at the expiry timestamp\n    mapping(address => mapping(uint256 => Price)) internal storedPrice;\n    //// @dev disputer is a role defined by the owner that has the ability to dispute a price during the dispute period\n    address internal disputer;\n\n    /// @notice emits an event when the disputer is updated\n    event DisputerUpdated(address indexed newDisputer);\n    /// @notice emits an event when the pricer is updated for an asset\n    event PricerUpdated(address asset, address pricer);\n    /// @notice emits an event when the locking period is updated for a pricer\n    event PricerLockingPeriodUpdated(address indexed pricer, uint256 lockingPeriod);\n    /// @notice emits an event when the dispute period is updated for a pricer\n    event PricerDisputePeriodUpdated(address indexed pricer, uint256 disputePeriod);\n    /// @notice emits an event when an expiry price is updated for a specific asset\n    event ExpiryPriceUpdated(\n        address indexed asset,\n        uint256 indexed expirtyTimestamp,\n        uint256 price,\n        uint256 onchainTimestamp\n    );\n    /// @notice emits an event when the disputer disputes a price during the dispute period\n    event ExpiryPriceDisputed(\n        address indexed asset,\n        uint256 indexed expiryTimestamp,\n        uint256 disputedPrice,\n        uint256 newPrice,\n        uint256 disputeTimestamp\n    );\n\n    /**\n     * @notice get a live asset price from the asset's pricer contract\n     * @param _asset asset address\n     * @return price scaled by 1e8, denominated in USD\n     * e.g. 17368900000 => 175.689 USD\n     */\n    function getPrice(address _asset) external view returns (uint256) {\n        require(assetPricer[_asset] != address(0), \"Oracle: Pricer for this asset not set\");\n        return OpynPricerInterface(assetPricer[_asset]).getPrice();\n    }\n\n    /**\n     * @notice get the asset price at specific expiry timestamp\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @return price scaled by 1e8, denominated in USD\n     * @return isFinalized True, if the price is finalized, False if not\n     */\n    function getExpiryPrice(address _asset, uint256 _expiryTimestamp) external view returns (uint256, bool) {\n        uint256 price = storedPrice[_asset][_expiryTimestamp].price;\n        bool isFinalized = isDisputePeriodOver(_asset, _expiryTimestamp);\n        return (price, isFinalized);\n    }\n\n    /**\n     * @notice get the pricer for an asset\n     * @param _asset asset address\n     * @return pricer address\n     */\n    function getPricer(address _asset) external view returns (address) {\n        return assetPricer[_asset];\n    }\n\n    /**\n     * @notice get the disputer address\n     * @return disputer address\n     */\n    function getDisputer() external view returns (address) {\n        return disputer;\n    }\n\n    /**\n     * @notice get a pricer's locking period\n     * locking period is the period of time after the expiry timestamp where a price can not be pushed\n     * @dev during the locking period an expiry price can not be submitted to this contract\n     * @param _pricer pricer address\n     * @return locking period\n     */\n    function getPricerLockingPeriod(address _pricer) external view returns (uint256) {\n        return pricerLockingPeriod[_pricer];\n    }\n\n    /**\n     * @notice get a pricer's dispute period\n     * dispute period is the period of time after an expiry price has been pushed where a price can be disputed\n     * @dev during the dispute period, the disputer can dispute the submitted price and modify it\n     * @param _pricer pricer address\n     * @return dispute period\n     */\n    function getPricerDisputePeriod(address _pricer) external view returns (uint256) {\n        return pricerDisputePeriod[_pricer];\n    }\n\n    /**\n     * @notice check if the locking period is over for setting the asset price at a particular expiry timestamp\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @return True if locking period is over, False if not\n     */\n    function isLockingPeriodOver(address _asset, uint256 _expiryTimestamp) public view returns (bool) {\n        address pricer = assetPricer[_asset];\n        uint256 lockingPeriod = pricerLockingPeriod[pricer];\n\n        return now > _expiryTimestamp.add(lockingPeriod);\n    }\n\n    /**\n     * @notice check if the dispute period is over\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @return True if dispute period is over, False if not\n     */\n    function isDisputePeriodOver(address _asset, uint256 _expiryTimestamp) public view returns (bool) {\n        // check if the pricer has a price for this expiry timestamp\n        Price memory price = storedPrice[_asset][_expiryTimestamp];\n        if (price.timestamp == 0) {\n            return false;\n        }\n\n        address pricer = assetPricer[_asset];\n        uint256 disputePeriod = pricerDisputePeriod[pricer];\n        return now > price.timestamp.add(disputePeriod);\n    }\n\n    /**\n     * @notice sets the pricer for an asset\n     * @dev can only be called by the owner\n     * @param _asset asset address\n     * @param _pricer pricer address\n     */\n    function setAssetPricer(address _asset, address _pricer) external onlyOwner {\n        require(_pricer != address(0), \"Oracle: cannot set pricer to address(0)\");\n        assetPricer[_asset] = _pricer;\n\n        emit PricerUpdated(_asset, _asset);\n    }\n\n    /**\n     * @notice sets the locking period for a pricer\n     * @dev can only be called by the owner\n     * @param _pricer pricer address\n     * @param _lockingPeriod locking period\n     */\n    function setLockingPeriod(address _pricer, uint256 _lockingPeriod) external onlyOwner {\n        pricerLockingPeriod[_pricer] = _lockingPeriod;\n\n        emit PricerLockingPeriodUpdated(_pricer, _lockingPeriod);\n    }\n\n    /**\n     * @notice sets the dispute period for a pricer\n     * @dev can only be called by the owner\n     * for a composite pricer (ie CompoundPricer) that depends on or calls other pricers, ensure\n     * that the dispute period for the composite pricer is longer than the dispute period for the\n     * asset pricer that it calls to ensure safe usage as a dispute in the other pricer will cause\n     * the need for a dispute with the composite pricer's price\n     * @param _pricer pricer address\n     * @param _disputePeriod dispute period\n     */\n    function setDisputePeriod(address _pricer, uint256 _disputePeriod) external onlyOwner {\n        pricerDisputePeriod[_pricer] = _disputePeriod;\n\n        emit PricerDisputePeriodUpdated(_pricer, _disputePeriod);\n    }\n\n    /**\n     * @notice set the disputer address\n     * @dev can only be called by the owner\n     * @param _disputer disputer address\n     */\n    function setDisputer(address _disputer) external onlyOwner {\n        disputer = _disputer;\n\n        emit DisputerUpdated(_disputer);\n    }\n\n    /**\n     * @notice dispute an asset price during the dispute period\n     * @dev only the owner can dispute a price during the dispute period, by setting a new one\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @param _price the correct price\n     */\n    function disputeExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external {\n        require(msg.sender == disputer, \"Oracle: caller is not the disputer\");\n        require(!isDisputePeriodOver(_asset, _expiryTimestamp), \"Oracle: dispute period over\");\n\n        Price storage priceToUpdate = storedPrice[_asset][_expiryTimestamp];\n        uint256 oldPrice = priceToUpdate.price;\n        priceToUpdate.price = _price;\n\n        emit ExpiryPriceDisputed(_asset, _expiryTimestamp, oldPrice, _price, now);\n    }\n\n    /**\n     * @notice submits the expiry price to the oracle, can only be set from the pricer\n     * @dev asset price can only be set after the locking period is over and before the dispute period has started\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @param _price asset price at expiry\n     */\n    function setExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external {\n        require(\n            (msg.sender == assetPricer[_asset]) || (msg.sender == disputer),\n            \"Oracle: caller is not authorized to set expiry price\"\n        );\n        require(isLockingPeriodOver(_asset, _expiryTimestamp), \"Oracle: locking period is not over yet\");\n        require(storedPrice[_asset][_expiryTimestamp].timestamp == 0, \"Oracle: dispute period started\");\n\n        storedPrice[_asset][_expiryTimestamp] = Price(_price, now);\n        emit ExpiryPriceUpdated(_asset, _expiryTimestamp, _price, now);\n    }\n}"
    },
    {
      "filename": "contracts/Oracle.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\nimport {OpynPricerInterface} from \"./interfaces/OpynPricerInterface.sol\";\nimport {Ownable} from \"./packages/oz/Ownable.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\n\n/**\n * @author Opyn Team\n * @title Oracle Module\n * @notice The Oracle module sets, retrieves, and stores USD prices (USD per asset) for underlying, collateral, and strike assets\n * manages pricers that are used for different assets\n */\ncontract Oracle is Ownable {\n    using SafeMath for uint256;\n\n    /// @dev structure that stores price of asset and timestamp when the price was stored\n    struct Price {\n        uint256 price;\n        uint256 timestamp; // timestamp at which the price is pushed to this oracle\n    }\n\n    /// @dev mapping of asset pricer to its locking period\n    /// locking period is the period of time after the expiry timestamp where a price can not be pushed\n    mapping(address => uint256) internal pricerLockingPeriod;\n    /// @dev mapping of asset pricer to its dispute period\n    /// dispute period is the period of time after an expiry price has been pushed where a price can be disputed\n    mapping(address => uint256) internal pricerDisputePeriod;\n    /// @dev mapping between an asset and its pricer\n    mapping(address => address) internal assetPricer;\n    /// @dev mapping between asset, expiry timestamp, and the Price structure at the expiry timestamp\n    mapping(address => mapping(uint256 => Price)) internal storedPrice;\n    //// @dev disputer is a role defined by the owner that has the ability to dispute a price during the dispute period\n    address internal disputer;\n\n    /// @notice emits an event when the disputer is updated\n    event DisputerUpdated(address indexed newDisputer);\n    /// @notice emits an event when the pricer is updated for an asset\n    event PricerUpdated(address asset, address pricer);\n    /// @notice emits an event when the locking period is updated for a pricer\n    event PricerLockingPeriodUpdated(address indexed pricer, uint256 lockingPeriod);\n    /// @notice emits an event when the dispute period is updated for a pricer\n    event PricerDisputePeriodUpdated(address indexed pricer, uint256 disputePeriod);\n    /// @notice emits an event when an expiry price is updated for a specific asset\n    event ExpiryPriceUpdated(\n        address indexed asset,\n        uint256 indexed expirtyTimestamp,\n        uint256 price,\n        uint256 onchainTimestamp\n    );\n    /// @notice emits an event when the disputer disputes a price during the dispute period\n    event ExpiryPriceDisputed(\n        address indexed asset,\n        uint256 indexed expiryTimestamp,\n        uint256 disputedPrice,\n        uint256 newPrice,\n        uint256 disputeTimestamp\n    );\n\n    /**\n     * @notice get a live asset price from the asset's pricer contract\n     * @param _asset asset address\n     * @return price scaled by 1e8, denominated in USD\n     * e.g. 17368900000 => 175.689 USD\n     */\n    function getPrice(address _asset) external view returns (uint256) {\n        require(assetPricer[_asset] != address(0), \"Oracle: Pricer for this asset not set\");\n        return OpynPricerInterface(assetPricer[_asset]).getPrice();\n    }\n\n    /**\n     * @notice get the asset price at specific expiry timestamp\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @return price scaled by 1e8, denominated in USD\n     * @return isFinalized True, if the price is finalized, False if not\n     */\n    function getExpiryPrice(address _asset, uint256 _expiryTimestamp) external view returns (uint256, bool) {\n        uint256 price = storedPrice[_asset][_expiryTimestamp].price;\n        bool isFinalized = isDisputePeriodOver(_asset, _expiryTimestamp);\n        return (price, isFinalized);\n    }\n\n    /**\n     * @notice get the pricer for an asset\n     * @param _asset asset address\n     * @return pricer address\n     */\n    function getPricer(address _asset) external view returns (address) {\n        return assetPricer[_asset];\n    }\n\n    /**\n     * @notice get the disputer address\n     * @return disputer address\n     */\n    function getDisputer() external view returns (address) {\n        return disputer;\n    }\n\n    /**\n     * @notice get a pricer's locking period\n     * locking period is the period of time after the expiry timestamp where a price can not be pushed\n     * @dev during the locking period an expiry price can not be submitted to this contract\n     * @param _pricer pricer address\n     * @return locking period\n     */\n    function getPricerLockingPeriod(address _pricer) external view returns (uint256) {\n        return pricerLockingPeriod[_pricer];\n    }\n\n    /**\n     * @notice get a pricer's dispute period\n     * dispute period is the period of time after an expiry price has been pushed where a price can be disputed\n     * @dev during the dispute period, the disputer can dispute the submitted price and modify it\n     * @param _pricer pricer address\n     * @return dispute period\n     */\n    function getPricerDisputePeriod(address _pricer) external view returns (uint256) {\n        return pricerDisputePeriod[_pricer];\n    }\n\n    /**\n     * @notice check if the locking period is over for setting the asset price at a particular expiry timestamp\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @return True if locking period is over, False if not\n     */\n    function isLockingPeriodOver(address _asset, uint256 _expiryTimestamp) public view returns (bool) {\n        address pricer = assetPricer[_asset];\n        uint256 lockingPeriod = pricerLockingPeriod[pricer];\n\n        return now > _expiryTimestamp.add(lockingPeriod);\n    }\n\n    /**\n     * @notice check if the dispute period is over\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @return True if dispute period is over, False if not\n     */\n    function isDisputePeriodOver(address _asset, uint256 _expiryTimestamp) public view returns (bool) {\n        // check if the pricer has a price for this expiry timestamp\n        Price memory price = storedPrice[_asset][_expiryTimestamp];\n        if (price.timestamp == 0) {\n            return false;\n        }\n\n        address pricer = assetPricer[_asset];\n        uint256 disputePeriod = pricerDisputePeriod[pricer];\n        return now > price.timestamp.add(disputePeriod);\n    }\n\n    /**\n     * @notice sets the pricer for an asset\n     * @dev can only be called by the owner\n     * @param _asset asset address\n     * @param _pricer pricer address\n     */\n    function setAssetPricer(address _asset, address _pricer) external onlyOwner {\n        require(_pricer != address(0), \"Oracle: cannot set pricer to address(0)\");\n        assetPricer[_asset] = _pricer;\n\n        emit PricerUpdated(_asset, _asset);\n    }\n\n    /**\n     * @notice sets the locking period for a pricer\n     * @dev can only be called by the owner\n     * @param _pricer pricer address\n     * @param _lockingPeriod locking period\n     */\n    function setLockingPeriod(address _pricer, uint256 _lockingPeriod) external onlyOwner {\n        pricerLockingPeriod[_pricer] = _lockingPeriod;\n\n        emit PricerLockingPeriodUpdated(_pricer, _lockingPeriod);\n    }\n\n    /**\n     * @notice sets the dispute period for a pricer\n     * @dev can only be called by the owner\n     * for a composite pricer (ie CompoundPricer) that depends on or calls other pricers, ensure\n     * that the dispute period for the composite pricer is longer than the dispute period for the\n     * asset pricer that it calls to ensure safe usage as a dispute in the other pricer will cause\n     * the need for a dispute with the composite pricer's price\n     * @param _pricer pricer address\n     * @param _disputePeriod dispute period\n     */\n    function setDisputePeriod(address _pricer, uint256 _disputePeriod) external onlyOwner {\n        pricerDisputePeriod[_pricer] = _disputePeriod;\n\n        emit PricerDisputePeriodUpdated(_pricer, _disputePeriod);\n    }\n\n    /**\n     * @notice set the disputer address\n     * @dev can only be called by the owner\n     * @param _disputer disputer address\n     */\n    function setDisputer(address _disputer) external onlyOwner {\n        disputer = _disputer;\n\n        emit DisputerUpdated(_disputer);\n    }\n\n    /**\n     * @notice dispute an asset price during the dispute period\n     * @dev only the owner can dispute a price during the dispute period, by setting a new one\n     * @param _asset asset address\n     * @param _expiryTimestamp expiry timestamp\n     * @param _price the correct price\n     */\n    function disputeExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price"
    }
  ]
}