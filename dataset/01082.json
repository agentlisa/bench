{
  "Title": "M-4: First pool borrower pays extra interest",
  "Content": "# Issue M-4: First pool borrower pays extra interest \n\nSource: https://github.com/sherlock-audit/2023-09-ajna-judging/issues/26 \n\n## Found by \n0xkaden\n\nThere exists an exception in the interest logic in which the action of borrowing from a pool for the first time (or otherwise when there is 0 debt) does not trigger the inflator to update. As a result, the borrower's interest effectively started accruing at the last time the inflator was updated, before they even borrowed, causing them to pay more interest than intended.\n\n## Vulnerability Detail\n\nFor any function in which the current interest rate is important in a pool, we compute interest updates by accruing with `_accruePoolInterest` at the start of the function, then execute the main logic, then update the interest state accordingly with `_updateInterestState`. See below a simplified example for `ERC20Pool.drawDebt`:\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/ERC20Pool.sol#L130\n```solidity\nfunction drawDebt(\n    address borrowerAddress_,\n    uint256 amountToBorrow_,\n    uint256 limitIndex_,\n    uint256 collateralToPledge_\n) external nonReentrant {\n    PoolState memory poolState = _accruePoolInterest();\n\n   ...\n\n    DrawDebtResult memory result = BorrowerActions.drawDebt(\n        auctions,\n        deposits,\n        loans,\n        poolState,\n        _availableQuoteToken(),\n        borrowerAddress_,\n        amountToBorrow_,\n        limitIndex_,\n        collateralToPledge_\n    );\n\n    ...\n\n    // update pool interest rate state\n    _updateInterestState(poolState, result.newLup);\n\n   ...\n}\n```\n\nWhen accruing interest in `_accruePoolInterest`, we only update the state if `poolState_.t0Debt != 0`. Most notably, we don't set `poolState_.isNewInterestAccrued`. See below simplified logic from `_accruePoolInterest`:\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/base/Pool.sol#L552\n```solidity\n// check if t0Debt is not equal to 0, indicating that there is debt to be tracked for the pool\nif (poolState_.t0Debt != 0) {\n    ...\n\n    // calculate elapsed time since inflator was last updated\n    uint256 elapsed = block.timestamp - inflatorState.inflatorUpdate;\n\n    // set isNewInterestAccrued field to true if elapsed time is not 0, indicating that new interest may have accrued\n    poolState_.isNewInterestAccrued = elapsed != 0;\n\n    ...\n}\n```\n\nOf course before we actually update the state from the first borrow, the debt of the pool is 0, and recall that `_accruePoolInterest` runs before the main state changing logic of the function in `BorrowerActions.drawDebt`.\n\nAfter executing the main state changing logic in `BorrowerActions.drawDebt`, where we update state, including incrementing the pool and borrower debt as expected, we run the logic in `_updateInterestState`. Here we update the inflator if either `poolState_.isNewInterestAccrued` or `poolState_.debt == 0`.\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/base/Pool.sol#L686\n```solidity\n// update pool inflator\nif (poolState_.isNewInterestAccrued) {\n    inflatorState.inflator       = uint208(poolState_.inflator);\n    inflatorState.inflatorUpdate = uint48(block.timestamp);\n// if the debt in the current pool state is 0, also update the inflator and inflatorUpdate fields in inflatorState\n// slither-disable-next-line incorrect-equality\n} else if (poolState_.debt == 0) {\n    inflatorState.inflator       = uint208(Maths.WAD);\n    inflatorState.inflatorUpdate = uint48(block.timestamp);\n}\n```\n\nThe problem here is that since there was no debt at the start of the function, `poolState_.isNewInterestAccrued` is false and since there is debt now at the end of the function, `poolState_.debt == 0` is also false. As a result, the inflator is not updated. Updating the inflator here is paramount since it effectively marks a starting time at which interest accrues on the borrowers debt. Since we don't update the inflator, the borrowers debt effectively started accruing interest at the time of the last inflator update, which is an arbitrary duration.\n\nWe can prove this vulnerability by modifying `ERC20PoolBorrow.t.sol:testPoolBorrowAndRepay` to skip 100 days before initially drawing debt:\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/tests/forge/unit/ERC20Pool/ERC20PoolBorrow.t.sol#L94\n```solidity\nfunction testPoolBorrowAndRepay() external tearDown {\n    // check balances before borrow\n    assertEq(_quote.balanceOf(address(_pool)), 50_000 * 1e18);\n    assertEq(_quote.balanceOf(_lender),        150_000 * 1e18);\n\n    // @audit skip 100 days to break test\n    skip(100 days);\n\n    _drawDebt({\n        from: _borrower,\n        borrower: _borrower,\n        amountToBorrow: 21_000 * 1e18,\n        limitIndex: 3_000,\n        collateralToPledge: 100 * 1e18,\n        newLup: 2_981.007422784467321543 * 1e18\n    });\n\n    ...\n}\n```\n\nUnlike the result without skipping time before drawing debt, the test fails with output logs being off by amounts roughly corresponding to the unexpected interest.\n![image](https://github.com/sherlock-audit/2023-09-ajna-kadenzipfel/assets/30579067/6196d147-ff67-4781-aa76-cae408be759d)\n\n## Impact\n\nFirst borrower **always** pays extra interest, with losses depending upon time between adding liquidity and drawing debt and amount of debt drawn.\n\nNote also that there's an attack vector here in which the liquidity provider can intentionally create and fund the pool a long time before announcing it, causing the initial borrower to lose a significant amount to interest.\n\n## Code Snippet\n\nSee 'Vulnerability Detail' section for snippets.\n\n## Tool used\n\n- Manual Review\n- Forge\n\n## Recommendation\n\nWhen checking whether the debt of the pool is 0 to determine whether to reset the inflator, it should not only check whether the debt is 0 at the end of execution, but also whether the debt was 0 before execution. To do so, we should cache the debt at the start of the function and modify the `_updateInterestState` logic to be something like:\n\n```solidity\n// update pool inflator\nif (poolState_.isNewInterestAccrued) {\n    inflatorState.inflator       = uint208(poolState_.inflator);\n    inflatorState.inflatorUpdate = uint48(block.timestamp);\n// if the debt in the current pool state is 0, also update the inflator and inflatorUpdate fields in inflatorState\n// slither-disable-next-line incorrect-equality\n// @audit reset inflator if no debt before execution\n} else if (poolState_.debt == 0 || debtBeforeExecution == 0) {\n    inflatorState.inflator       = uint208(Maths.WAD);\n    inflatorState.inflatorUpdate = uint48(block.timestamp);\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/114",
  "Code": [
    {
      "filename": "ajna-core/src/ERC20Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }    from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { \n    IERC20Pool,\n    IERC20PoolBorrowerActions,\n    IERC20PoolImmutables,\n    IERC20PoolLenderActions\n}                              from './interfaces/pool/erc20/IERC20Pool.sol';\nimport { IERC20Taker }         from './interfaces/pool/erc20/IERC20Taker.sol';\n\nimport {\n    IPoolLenderActions,\n    IPoolKickerActions,\n    IPoolTakerActions,\n    IPoolSettlerActions\n}                            from './interfaces/pool/IPool.sol';\nimport {\n    IERC3156FlashBorrower,\n    IERC3156FlashLender\n}                            from './interfaces/pool/IERC3156FlashLender.sol';\n\nimport {\n    DrawDebtResult,\n    RepayDebtResult,\n    SettleParams,\n    SettleResult,\n    TakeResult\n}                    from './interfaces/pool/commons/IPoolInternals.sol';\nimport { PoolState } from './interfaces/pool/commons/IPoolState.sol';\n\nimport { FlashloanablePool } from './base/FlashloanablePool.sol';\n\nimport {\n    _getCollateralDustPricePrecisionAdjustment,\n    _roundToScale,\n    _roundUpToScale\n}                                               from './libraries/helpers/PoolHelper.sol';\nimport { \n    _revertIfAuctionClearable,\n    _revertAfterExpiry \n}                               from './libraries/helpers/RevertsHelper.sol';\n\nimport { Loans }    from './libraries/internal/Loans.sol';\nimport { Deposits } from './libraries/internal/Deposits.sol';\nimport { Maths }    from './libraries/internal/Maths.sol';\n\nimport { BorrowerActions } from './libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from './libraries/external/LenderActions.sol';\nimport { SettlerActions }  from './libraries/external/SettlerActions.sol';\nimport { TakerActions }    from './libraries/external/TakerActions.sol';\n\n/**\n *  @title  ERC20 Pool contract\n *  @notice Entrypoint of `ERC20` Pool actions for pool actors:\n *          - `Lenders`: add, remove and move quote tokens; transfer `LP`\n *          - `Borrowers`: draw and repay debt\n *          - `Traders`: add, remove and move quote tokens; add and remove collateral\n *          - `Kickers`: kick undercollateralized loans; settle auctions; claim bond rewards\n *          - `Bidders`: take auctioned collateral\n *          - `Reserve purchasers`: start auctions; take reserves\n *          - `Flash borrowers`: initiate flash loans on quote tokens and collateral\n *  @dev    Contract is `FlashloanablePool` with flash loan logic.\n *  @dev    Contract is base `Pool` with logic to handle `ERC20` collateral.\n *  @dev    Calls logic from external `PoolCommons`, `LenderActions`, `BorrowerActions` and `Auction` actions libraries.\n */\ncontract ERC20Pool is FlashloanablePool, IERC20Pool {\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /// @dev Immutable collateral scale arg offset.\n    uint256 internal constant COLLATERAL_SCALE = 93;\n\n    /****************************/\n    /*** Initialize Functions ***/\n    /****************************/\n\n    /// @inheritdoc IERC20Pool\n    function initialize(\n        uint256 rate_\n    ) external override {\n        if (isPoolInitialized) revert AlreadyInitialized();\n\n        inflatorState.inflator       = uint208(1e18);\n        inflatorState.inflatorUpdate = uint48(block.timestamp);\n\n        interestState.interestRate       = uint208(rate_);\n        interestState.interestRateUpdate = uint48(block.timestamp);\n\n        Loans.init(loans);\n\n        // increment initializations count to ensure these values can't be updated\n        isPoolInitialized = true;\n    }\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IERC20PoolImmutables\n    function collateralScale() external pure override returns (uint256) {\n        return _getArgUint256(COLLATERAL_SCALE);\n    }\n\n    /// @inheritdoc IERC20Pool\n    function bucketCollateralDust(uint256 bucketIndex_) external pure override returns (uint256) {\n        return _bucketCollateralDust(bucketIndex_);\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev    === Write state ===\n     *  @dev    - increment `poolBalances.pledgedCollateral` accumulator\n     *  @dev    - increment `poolBalances.t0Debt` accumulator\n     *  @dev    - update `t0Debt2ToCollateral` ratio\n     *  @dev    === Emit events ===\n     *  @dev    - `DrawDebt`\n     */\n    function drawDebt(\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256 collateralToPledge_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure the borrower is not charged for additional debt that they did not receive\n        amountToBorrow_     = _roundToScale(amountToBorrow_, poolState.quoteTokenScale);\n        // ensure the borrower is not credited with a fractional amount of collateral smaller than the token scale\n        collateralToPledge_ = _roundToScale(collateralToPledge_, _getArgUint256(COLLATERAL_SCALE));\n\n        DrawDebtResult memory result = BorrowerActions.drawDebt(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            _availableQuoteToken(),\n            borrowerAddress_,\n            amountToBorrow_,\n            limitIndex_,\n            collateralToPledge_\n        );\n\n        emit DrawDebt(borrowerAddress_, amountToBorrow_, collateralToPledge_, result.newLup);\n\n        // update in memory pool state struct\n        poolState.debt       = result.poolDebt;\n        poolState.t0Debt     = result.t0PoolDebt;\n        poolState.collateral = result.poolCollateral;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.debtPreAction,\n            result.debtPostAction,\n            result.collateralPreAction,\n            result.collateralPostAction\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, result.newLup);\n\n        if (collateralToPledge_ != 0) {\n            // update pool balances pledged collateral state\n            poolBalances.pledgedCollateral = poolState.collateral;\n\n            // move collateral from sender to pool\n            _transferCollateralFrom(msg.sender, collateralToPledge_);\n        }\n\n        if (amountToBorrow_ != 0) {\n            // update pool balances t0 debt state\n            poolBalances.t0Debt = poolState.t0Debt;\n\n            // move borrowed amount from pool to sender\n            _transferQuoteToken(msg.sender, amountToBorrow_);\n        }\n    }\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev    === Write state ===\n     *  @dev    - decrement `poolBalances.t0Debt accumulator`\n     *  @dev    - decrement `poolBalances.pledgedCollateral accumulator`\n     *  @dev    - update `t0Debt2ToCollateral` ratio\n     *  @dev    === Emit events ===\n     *  @dev    - `RepayDebt`\n     */\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_,\n        address collateralReceiver_,\n        uint256 limitIndex_\n    ) external nonReentrant returns (uint256 amountRepaid_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure accounting is performed using the appropriate token scale\n        if (maxQuoteTokenAmountToRepay_ != type(uint256).max)\n            maxQuoteTokenAmountToRepay_ = _roundToScale(maxQuoteTokenAmountToRepay_, poolState.quoteTokenScale);\n        collateralAmountToPull_         = _roundToScale(collateralAmountToPull_,     _getArgUint256(COLLATERAL_SCALE));\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxQuoteTokenAmountToRepay_,\n            collateralAmountToPull_,\n            limitIndex_\n        );\n\n        emit RepayDebt(borrowerAddress_, result.quoteTokenToRepay, collateralAmountToPull_, result.newLup);\n\n        // update in memory pool state struct\n        poolState.debt       = result.poolDebt;\n        poolState.t0Debt     = result.t0PoolDebt;\n        poolState.collateral = result.poolCollateral;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.debtPreAction,\n            result.debtPostAction,\n            result.collateralPreAction,\n            result.collateralPostAction\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.quoteTokenToRepay != 0) {\n            // update pool balances t0 debt state\n            poolBalances.t0Debt = poolState.t0Debt;\n\n            // move amount to repay from sender to pool\n            _transferQuoteTokenFrom(msg.sender, result.quoteTokenToRepay);\n        }\n        if (collateralAmountToPull_ != 0) {\n            // update pool balances pledged collateral state\n            poolBalances.pledgedCollateral = poolState.collateral;\n\n            // move collateral from pool to address specified as collateral receiver\n            _transferCollateral(collateralReceiver_, collateralAmountToPull_);\n        }\n\n        amountRepaid_ = result.quoteTokenToRepay;\n    }\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolLenderActions\n     *  @dev    === Reverts on ===\n     *  @dev    - `DustAmountNotExceeded()`\n     *  @dev    === Emit events ===\n     *  @dev    - `AddCollateral`\n     */\n    function addCollateral(\n        uint256 amountToAdd_,\n        uint256 index_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 bucketLP_) {\n        _revertAfterExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n\n        // revert if the dust amount was not exceeded, but round on the scale amount\n        if (amountToAdd_ != 0 && amountToAdd_ < _bucketCollateralDust(index_)) revert DustAmountNotExceeded();\n        amountToAdd_ = _roundToScale(amountToAdd_, _getArgUint256(COLLATERAL_SCALE));\n\n        bucketLP_ = LenderActions.addCollateral(\n            buckets,\n            deposits,\n            amountToAdd_,\n            index_\n        );\n\n        emit AddCollateral(msg.sender, index_, amountToAdd_, bucketLP_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, Deposits.getLup(deposits, poolState.debt));\n\n        // move required collateral from sender to pool\n        _transferCollateralFrom(msg.sender, amountToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev    === Emit events ===\n     *  @dev    - `RemoveCollateral`\n     */\n    function removeCollateral(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLP_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round the collateral amount appropriately based on token precision\n        maxAmount_ = _roundToScale(maxAmount_, _getArgUint256(COLLATERAL_SCALE));\n\n        (removedAmount_, redeemedLP_) = LenderActions.removeMaxCollateral(\n            buckets,\n            deposits,\n            _bucketCollateralDust(index_),\n            maxAmount_,\n            index_\n        );\n\n        emit RemoveCollateral(msg.sender, index_, removedAmount_, redeemedLP_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, Deposits.getLup(deposits, poolState.debt));\n\n        // move collateral from pool to lender\n        _transferCollateral(msg.sender, removedAmount_);\n    }\n\n    /*******************************/\n    /*** Pool Auctions Functions ***/\n    /*******************************/\n\n    /**\n     *  @inheritdoc IPoolSettlerActions\n     *  @dev    === Write state ===\n     *  @dev    - decrement `poolBalances.t0Debt` accumulator\n     *  @dev    - decrement `poolBalances.t0DebtInAuction` accumulator\n     *  @dev    - decrement `poolBalances.pledgedCollateral` accumulator\n     *  @dev    - no update of `t0Debt2ToCollateral` ratio as debt and collateral pre settle are not taken into account (pre debt and pre collateral = 0)\n     *  @dev     and loan is removed from auction queue only when there's no more debt (post debt = 0)\n     */\n    function settle(\n        address borrowerAddress_,\n        uint256 maxDepth_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        SettleResult memory result = SettlerActions.settlePoolDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            reserveAuction,\n            poolState,\n            SettleParams({\n                borrower:    borrowerAddress_,\n                poolBalance: _getNormalizedPoolQuoteTokenBalance(),\n                bucketDepth: maxDepth_\n            })\n        );\n\n        _updatePostSettleState(result, poolState);\n    }\n\n    /**\n     *  @inheritdoc IPoolTakerActions\n     *  @dev    === Write state ===\n     *  @dev    - decrement `poolBalances.t0Debt` accumulator\n     *  @dev    - decrement `poolBalances.t0DebtInAuction` accumulator\n     *  @dev    - decrement `poolBalances.pledgedCollateral` accumulator\n     *  @dev    - update `t0Debt2ToCollateral` ratio only if auction settled, debt and collateral pre action are considered 0\n     */\n    function take(\n        address        borrowerAddress_,\n        uint256        maxAmount_,\n        address        callee_,\n        bytes calldata data_\n    ) external override nonReentrant returns (uint256 collateralTaken_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 collateralTokenScale = _getArgUint256(COLLATERAL_SCALE);\n\n        // round requested collateral to an amount which can actually be transferred\n        maxAmount_ = _roundToScale(maxAmount_, collateralTokenScale);\n\n        TakeResult memory result = TakerActions.take(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxAmount_,\n            collateralTokenScale\n        );\n        // round quote token up to cover the cost of purchasing the collateral\n        result.quoteTokenAmount = _roundUpToScale(result.quoteTokenAmount, poolState.quoteTokenScale);\n\n        _updatePostTakeState(result, poolState);\n\n        _transferCollateral(callee_, result.collateralAmount);\n\n        if (data_.length != 0) {\n            IERC20Taker(callee_).atomicSwapCallback(\n                result.collateralAmount / collateralTokenScale,\n                result.quoteTokenAmount / poolState.quoteTokenScale,\n                data_\n            );\n        }\n\n        _transferQuoteTokenFrom(msg.sender, result.quoteTokenAmount);\n\n        collateralTaken_ = result.collateralAmount;\n    }\n\n    /**\n     *  @inheritdoc IPoolTakerActions\n     *  @dev    === Write state ===\n     *  @dev    - decrement `poolBalances.t0Debt` accumulator\n     *  @dev    - decrement `poolBalances.t0DebtInAuction` accumulator\n     *  @dev    - decrement `poolBalances.pledgedCollateral` accumulator\n     *  @dev    - update `t0Debt2ToCollateral` ratio only if auction settled, debt and collateral pre action are considered 0\n     */\n    function bucketTake(\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_\n    ) external override nonReentrant {\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        TakeResult memory result = TakerActions.bucketTake(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            depositTake_,\n            index_,\n            _getArgUint256(COLLATERAL_SCALE)\n        );\n\n        _updatePostTakeState(result, poolState);\n    }\n\n    /***************************/\n    /*** Flashloan Functions ***/\n    /***************************/\n\n    /**\n     *  @inheritdoc FlashloanablePool\n     *  @dev Override default implementation and allows flashloans for both quote and collateral token.\n     */\n    function _isFlashloanSupported(\n        address token_\n    ) internal virtual view override returns (bool) {\n        return token_ == _getArgAddress(QUOTE_ADDRESS) || token_ == _getArgAddress(COLLATERAL_ADDRESS);\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /**\n     *  @notice Helper function to transfer amount of collateral tokens from sender to pool contract.\n     *  @param  from_    Sender address.\n     *  @param  amount_  Amount to transfer from sender (`WAD` precision). Scaled to collateral precision before transfer.\n     */\n    function _transferCollateralFrom(address from_, uint256 amount_) internal {\n        // Transfer amount in favour of the pool\n        uint256 transferAmount = Maths.ceilDiv(amount_, _getArgUint256(COLLATERAL_SCALE));\n        IERC20(_getArgAddress(COLLATERAL_ADDRESS)).safeTransferFrom(from_, address(this), transferAmount);\n    }\n\n    /**\n     *  @notice Helper function to transfer amount of collateral tokens from pool contract.\n     *  @param  to_     Receiver address.\n     *  @param  amount_ Amount to transfer to receiver (`WAD` precision). Scaled to collateral precision before transfer.\n     */\n    function _transferCollateral(address to_, uint256 amount_) internal {\n        IERC20(_getArgAddress(COLLATERAL_ADDRESS)).safeTransfer(to_, amount_ / _getArgUint256(COLLATERAL_SCALE));\n    }\n\n    /**\n     *  @notice Helper function to calculate the minimum amount of collateral an actor may have in a bucket.\n     *  @param  bucketIndex_  Bucket index.\n     *  @return Amount of collateral dust amount of the bucket.\n     */\n    function _bucketCollateralDust(uint256 bucketIndex_) internal pure returns (uint256) {\n        // price precision adjustment will always be 0 for encumbered collateral\n        uint256 pricePrecisionAdjustment = _getCollateralDustPricePrecisionAdjustment(bucketIndex_);\n        // difference between the normalized scale and the collateral token's scale\n        return Maths.max(_getArgUint256(COLLATERAL_SCALE), 10 ** pricePrecisionAdjustment);\n    } \n}"
    },
    {
      "filename": "ajna-core/src/base/Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { Clone }           from '@clones/Clone.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { SafeERC20 }       from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }          from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {\n    IPool,\n    IPoolImmutables,\n    IPoolBorrowerActions,\n    IPoolLPActions,\n    IPoolLenderActions,\n    IPoolKickerActions,\n    IPoolTakerActions,\n    IPoolSettlerActions,\n    IPoolState,\n    IPoolDerivedState,\n    IERC20Token\n}                                    from '../interfaces/pool/IPool.sol';\nimport {\n    PoolState,\n    AuctionsState,\n    DepositsState,\n    Loan,\n    LoansState,\n    InflatorState,\n    EmaState,\n    InterestState,\n    PoolBalancesState,\n    ReserveAuctionState,\n    Bucket,\n    Lender,\n    Borrower,\n    Kicker,\n    BurnEvent,\n    Liquidation\n}                                   from '../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    SettleResult,\n    TakeResult,\n    RemoveQuoteParams,\n    MoveQuoteParams,\n    AddQuoteParams,\n    KickReserveAuctionParams\n}                                   from '../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _priceAt,\n    _roundToScale\n}                               from '../libraries/helpers/PoolHelper.sol';\nimport {\n    _revertIfAuctionDebtLocked,\n    _revertIfAuctionClearable,\n    _revertAfterExpiry\n}                               from '../libraries/helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../libraries/internal/Buckets.sol';\nimport { Deposits } from '../libraries/internal/Deposits.sol';\nimport { Loans }    from '../libraries/internal/Loans.sol';\nimport { Maths }    from '../libraries/internal/Maths.sol';\n\nimport { BorrowerActions } from '../libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from '../libraries/external/LenderActions.sol';\nimport { LPActions }       from '../libraries/external/LPActions.sol';\nimport { KickerActions }   from '../libraries/external/KickerActions.sol';\nimport { TakerActions }    from '../libraries/external/TakerActions.sol';\nimport { PoolCommons }     from '../libraries/external/PoolCommons.sol';\n\n/**\n *  @title  Pool Contract\n *  @dev    Base contract and entrypoint for commong logic of both `ERC20` and `ERC721` pools.\n */\nabstract contract Pool is Clone, ReentrancyGuard, Multicall, IPool {\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /// @dev Immutable pool type arg offset.\n    uint256 internal constant POOL_TYPE          = 0;\n    /// @dev Immutable `Ajna` token address arg offset.\n    uint256 internal constant AJNA_ADDRESS       = 1;\n    /// @dev Immutable collateral token address arg offset.\n    uint256 internal constant COLLATERAL_ADDRESS = 21;\n    /// @dev Immutable quote token address arg offset.\n    uint256 internal constant QUOTE_ADDRESS      = 41;\n    /// @dev Immutable quote token scale arg offset.\n    uint256 internal constant QUOTE_SCALE        = 61;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    AuctionsState       internal auctions;\n    DepositsState       internal deposits;\n    LoansState          internal loans;\n    InflatorState       internal inflatorState;\n    EmaState            internal emaState;\n    InterestState       internal interestState;\n    PoolBalancesState   internal poolBalances;\n    ReserveAuctionState internal reserveAuction;\n\n    /// @dev deposit index -> bucket mapping\n    mapping(uint256 => Bucket) internal buckets;\n\n    bool internal isPoolInitialized;\n\n    /// @dev owner address -> new owner address -> deposit index -> allowed amount mapping\n    mapping(address => mapping(address => mapping(uint256 => uint256))) private _lpAllowances;\n\n    /// @dev owner address -> transferor address -> approved flag mapping\n    mapping(address => mapping(address => bool)) public override approvedTransferors;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IPoolImmutables\n    function poolType() external pure override returns (uint8) {\n        return _getArgUint8(POOL_TYPE);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function collateralAddress() external pure override returns (address) {\n        return _getArgAddress(COLLATERAL_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenAddress() external pure override returns (address) {\n        return _getArgAddress(QUOTE_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenScale() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /// @inheritdoc IPoolLenderActions\n    function addQuoteToken(\n        uint256 amount_,\n        uint256 index_,\n        uint256 expiry_,\n        bool    revertIfBelowLup_\n    ) external override nonReentrant returns (uint256 bucketLP_) {\n        _revertAfterExpiry(expiry_);\n\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round to token precision\n        amount_ = _roundToScale(amount_, poolState.quoteTokenScale);\n\n        uint256 newLup;\n        (bucketLP_, newLup) = LenderActions.addQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            AddQuoteParams({\n                amount:           amount_,\n                index:            index_,\n                revertIfBelowLup: revertIfBelowLup_\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from lender to pool\n        _transferQuoteTokenFrom(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function moveQuoteToken(\n        uint256 maxAmount_,\n        uint256 fromIndex_,\n        uint256 toIndex_,\n        uint256 expiry_,\n        bool    revertIfBelowLup_\n    ) external override nonReentrant returns (uint256 fromBucketLP_, uint256 toBucketLP_, uint256 movedAmount_) {\n        _revertAfterExpiry(expiry_);\n\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, fromIndex_, poolState.inflator);\n\n        MoveQuoteParams memory moveParams;\n        moveParams.maxAmountToMove  = maxAmount_;\n        moveParams.fromIndex        = fromIndex_;\n        moveParams.toIndex          = toIndex_;\n        moveParams.thresholdPrice   = Loans.getMax(loans).thresholdPrice;\n        moveParams.revertIfBelowLup = revertIfBelowLup_;\n\n        uint256 newLup;\n        (\n            fromBucketLP_,\n            toBucketLP_,\n            movedAmount_,\n            newLup\n        ) = LenderActions.moveQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            moveParams\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function removeQuoteToken(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLP_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, index_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            removedAmount_,\n            redeemedLP_,\n            newLup\n        ) = LenderActions.removeQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            RemoveQuoteParams({\n                maxAmount:      Maths.min(maxAmount_, _availableQuoteToken()),\n                index:          index_,\n                thresholdPrice: Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from pool to lender\n        _transferQuoteToken(msg.sender, removedAmount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function updateInterest() external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n        _updateInterestState(poolState, Deposits.getLup(deposits, poolState.debt));\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /// @inheritdoc IPoolBorrowerActions\n    function stampLoan() external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 newLup = BorrowerActions.stampLoan(\n            auctions,\n            deposits,\n            loans,\n            poolState\n        );\n\n        _updateInterestState(poolState, newLup);\n    }\n\n    /*****************************/\n    /*** Liquidation Functions ***/\n    /*****************************/\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `poolBalances.t0DebtInAuction` and `poolBalances.t0Debt` accumulators\n     *  @dev    update `t0Debt2ToCollateral` ratio, debt and collateral post action are considered 0\n     */\n    function kick(\n        address borrower_,\n        uint256 npLimitIndex_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auction\n        KickResult memory result = KickerActions.kick(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            borrower_,\n            npLimitIndex_\n        );\n\n        // update in memory pool state struct\n        poolState.t0DebtInAuction += result.t0KickedDebt;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.t0KickedDebt,\n            0, // debt post kick (for loan in auction) not taken into account\n            result.collateralPreAction,\n            0  // collateral post kick (for loan in auction) not taken into account\n        );\n\n        // update pool balances state\n        poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n        // update pool interest rate state\n        _updateInterestState(poolState, result.lup);\n\n        if (result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     */\n    function lenderKick(\n        uint256 index_,\n        uint256 npLimitIndex_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auctions\n        KickResult memory result = KickerActions.lenderKick(\n            auctions,\n            deposits,\n            buckets,\n            loans,\n            poolState,\n            index_,\n            npLimitIndex_\n        );\n\n        // update in memory pool state struct\n        poolState.t0DebtInAuction += result.t0KickedDebt;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.t0KickedDebt,\n            0, // debt post kick (for loan in auction) not taken into account\n            result.collateralPreAction,\n            0 // collateral post kick (for loan in auction) not taken into account\n        );\n\n        // update pool balances state\n        poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n\n        // update pool interest rate state\n        _updateInterestState(poolState, result.lup);\n\n        // transfer from kicker to pool the difference to cover bond\n        if (result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    decrease kicker's `claimable` accumulator\n     *  @dev    decrease auctions `totalBondEscrowed` accumulator\n     */\n    function withdrawBonds(\n        address recipient_,\n        uint256 maxAmount_\n    ) external override nonReentrant {\n        uint256 claimable = auctions.kickers[msg.sender].claimable;\n\n        // the amount to claim is constrained by the claimable balance of sender\n        // claiming escrowed bonds is not constraiend by the pool balance\n        maxAmount_ = Maths.min(maxAmount_, claimable);\n\n        // revert if no amount to claim\n        if (maxAmount_ == 0) revert InsufficientLiquidity();\n\n        // decrement total bond escrowed\n        auctions.totalBondEscrowed             -= maxAmount_;\n        auctions.kickers[msg.sender].claimable -= maxAmount_;\n\n        emit BondWithdrawn(msg.sender, recipient_, maxAmount_);\n\n        _transferQuoteToken(recipient_, maxAmount_);\n    }\n\n    /*********************************/\n    /*** Reserve Auction Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `latestBurnEpoch` counter\n     *  @dev    update `reserveAuction.latestBurnEventEpoch` and burn event `timestamp` state\n     *  @dev    === Reverts on ===\n     *  @dev    2 weeks not passed `ReserveAuctionTooSoon()`\n     *  @dev    === Emit events ===\n     *  @dev    - `KickReserveAuction`\n     */\n    function kickReserveAuction() external override nonReentrant {\n        // start a new claimable reserve auction, passing in relevant parameters such as the current pool size, debt, balance, and inflator value\n        KickerActions.kickReserveAuction(\n            auctions,\n            reserveAuction,\n            KickReserveAuctionParams({\n                poolSize:    Deposits.treeSum(deposits),\n                t0PoolDebt:  poolBalances.t0Debt,\n                poolBalance: _getNormalizedPoolQuoteTokenBalance(),\n                inflator:    inflatorState.inflator"
    }
  ]
}