{
  "Title": "[G-07] Multiple accesses of a array should use a local variable cache",
  "Content": "The instances below point to the second+ access of a value inside an array, within a function. Caching an array's struct avoids re-calculating the array offsets into memory\n\n### Proof of concept\n\n<Details>\n\n```solidity\nstruct Person {\n    string name;\n    uint age;\n    uint id;\n}\n\ncontract NoCacheArrayElement {\n\n    Person[] students;\n\n    function createStudents() external  {\n        Person[] memory arrayOfPersons = new Person[](3); \n        Person memory newPerson1 = Person(\"Emmanuel\", 15,1);\n        Person memory newPerson2 = Person(\"Faustina\", 16,2);\n        Person memory newPerson3 = Person(\"Emmanuela\", 14,3);\n\n        arrayOfPersons[0] = newPerson1;\n        arrayOfPersons[1] = newPerson2;\n        arrayOfPersons[2] = newPerson3;\n\n        _addNewSet(arrayOfPersons);\n    }\n\n    function _addNewSet(Person[] memory _persons) internal {\n        uint len = _persons.length;\n        unchecked {\n            for(uint i; i < len; ++i) {\n                Person memory newStudent = Person(_persons[i].name, _persons[i].age, _persons[i].id);\n                students.push(newStudent);\n            }\n        }\n\n    }\n}\n```\n```\ntest for test/NoCacheArrayElement.t.sol:NoCacheArrayElementTest\n[PASS] test_createStudents() (gas: 230357)\n```\n\n```solidity\n\nstruct Person {\n    string name;\n    uint age;\n    uint id;\n}\n\ncontract CacheArrayElement {\n\n    Person[] students;\n\n    function createStudents() external  {\n        Person[] memory arrayOfPersons = new Person[](3); \n        Person memory newPerson1 = Person(\"Emmanuel\", 15,1);\n        Person memory newPerson2 = Person(\"Faustina\", 16,2);\n        Person memory newPerson3 = Person(\"Emmanuela\", 14,3);\n\n        arrayOfPersons[0] = newPerson1;\n        arrayOfPersons[1] = newPerson2;\n        arrayOfPersons[2] = newPerson3;\n\n        _addNewSet(arrayOfPersons);\n    }\n\n    function _addNewSet(Person[] memory _persons) internal {\n        uint len = _persons.length;\n        unchecked {\n            for(uint i; i < len; ++i) {\n                Person memory myPerson = _persons[i];\n                Person memory newStudent = Person(myPerson.name, myPerson.age, myPerson.id);\n                students.push(newStudent);\n            }\n        }\n\n    }\n}\n```\n```\ntest for test/Counter.t.sol:CacheArrayElementTest\n[PASS] test_createStudents() (gas: 230096)\n```\n</details>\n\n### 2 Instances\n1. ### Cache `hooks[i]` to avoid re-calculating the array offsets into memory\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L477&&#L485\n\n<details>\n\n```solidity\nfile: src/policies/Create.sol\n\n464:    function _addHooks(\n465:        Hook[] memory hooks,\n466:        SpentItem[] memory offerItems,\n467:        address rentalWallet\n468:    ) internal {\n469:        // Define hook target, offer item index, and an offer item.\n470:        address target;\n471:        uint256 itemIndex;\n472:        SpentItem memory offer;\n473:\n474:        // Loop through each hook in the payload.\n475:        for (uint256 i = 0; i < hooks.length; ++i) {\n476:            // Get the hook's target address.\n477:            target = hooks[i].target;   //@audit cache hooks[i];\n478:\n479:            // Check that the hook is reNFT-approved to execute on rental start.\n480:            if (!STORE.hookOnStart(target)) {\n481:                revert Errors.Shared_DisabledHook(target);\n482:            }\n483:\n484:            // Get the offer item index for this hook.\n485:            itemIndex = hooks[i].itemIndex;   //@audit cache hooks[i];\n486:\n487:            // Get the offer item for this hook.\n488:            offer = offerItems[itemIndex];\n489:\n490:            // Make sure the offer item is an ERC721 or ERC1155.\n491:            if (!offer.isRental()) {\n492:                revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:            }\n494:\n495:            // Call the hook with data about the rented item.\n496:            try\n497:                IHook(target).onStart(\n498:                    rentalWallet,\n499:                    offer.token,\n500:                    offer.identifier,\n501:                    offer.amount,\n502:                    hooks[i].extraData   //@audit cache hooks[i];\n503:                )\n.\n.\n.\n520:    }\n```\n\n```diff\ndiff --git a/src/policies/Create.sol b/src/policies/Create.sol\nindex 061180d..b2f4241 100644\n--- a/src/policies/Create.sol\n+++ b/src/policies/Create.sol\n@@ -470,11 +470,12 @@ contract Create is Policy, Signer, Zone, Accumulator {\n         address target;\n         uint256 itemIndex;\n         SpentItem memory offer;\n-\n+        Hook memory hook;\n         // Loop through each hook in the payload.\n         for (uint256 i = 0; i < hooks.length; ++i) {\n             // Get the hook's target address.\n-            target = hooks[i].target;\n+            hook = hooks[i];\n+            target = hook.target;\n\n             // Check that the hook is reNFT-approved to execute on rental start.\n             if (!STORE.hookOnStart(target)) {\n@@ -482,7 +483,7 @@ contract Create is Policy, Signer, Zone, Accumulator {\n             }\n\n             // Get the offer item index for this hook.\n-            itemIndex = hooks[i].itemIndex;\n+            itemIndex = hook.itemIndex;\n\n             // Get the offer item for this hook.\n             offer = offerItems[itemIndex];\n@@ -499,7 +500,7 @@ contract Create is Policy, Signer, Zone, Accumulator {\n                     offer.token,\n                     offer.identifier,\n                     offer.amount,\n-                    hooks[i].extraData\n+                    hook.extraData\n                 )\n             {} catch Error(string memory revertReason) {\n                 // Revert with reason given.\n```\n\n</details>\n\n2. ### Cache `items[i]` to avoid re-calculating the array offsets into memory\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L568-#L573\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L600-#L601\n\n<details>\n\n```solidity\nfile: src/policies/Create.sol\n\n530:    function _rentFromZone(\n531:        RentPayload memory payload,\n532:        SeaportPayload memory seaportPayload\n533:    ) internal {\n534:        // Check: make sure order metadata is valid with the given seaport order zone hash.\n535:        _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n536:\n537:        // Check: verify the fulfiller of the order is an owner of the recipient safe.\n538:        _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n539:\n540:        // Check: verify each execution was sent to the expected destination.\n541:        _executionInvariantChecks(\n542:            seaportPayload.totalExecutions,\n543:            payload.fulfillment.recipient\n544:        );\n545:\n546:        // Check: validate and process seaport offer and consideration items based\n547:        // on the order type.\n548:        Item[] memory items = _convertToItems(\n549:            seaportPayload.offer,\n550:            seaportPayload.consideration,\n551:            payload.metadata.orderType\n552:        );\n553:\n.\n.\n.\n567:            for (uint256 i; i < items.length; ++i) {\n568:                if (items[i].isRental()) {  //@audit cache items[i]\n569:                    // Insert the rental asset update into the dynamic array.\n570:                    _insert(\n571:                        rentalAssetUpdates,\n572:                        items[i].toRentalId(payload.fulfillment.recipient),  //@audit cache items[i]\n573:                        items[i].amount  //@audit cache items[i]\n574:                    );\n575:                }\n576:            }\n.\n.\n.\n599:            for (uint256 i = 0; i < items.length; ++i) {\n600:                if (items[i].isERC20()) {  //@audit cache items[i]\n601:                    ESCRW.increaseDeposit(items[i].token, items[i].amount);  //@audit cache items[i]\n602:                }\n603:            }\n.\n.\n.\n617:    }\n```\n\n```diff\ndiff --git a/src/policies/Create.sol b/src/policies/Create.sol\nindex 061180d..b5ddcbf 100644\n--- a/src/policies/Create.sol\n+++ b/src/policies/Create.sol\n@@ -561,16 +561,17 @@ contract Create is Policy, Signer, Zone, Accumulator {\n             // the rented amount. From this point on, new memory cannot be safely allocated until the\n             // accumulator no longer needs to include elements.\n             bytes memory rentalAssetUpdates = new bytes(0);\n-\n+            Item memory item;\n             // Check if each item is a rental. If so, then generate the rental asset update.\n             // Memory will become safe again after this block.\n             for (uint256 i; i < items.length; ++i) {\n-                if (items[i].isRental()) {\n+                item = items[i];\n+                if (item.isRental()) {\n                     // Insert the rental asset update into the dynamic array.\n                     _insert(\n                         rentalAssetUpdates,\n-                        items[i].toRentalId(payload.fulfillment.recipient),\n-                        items[i].amount\n+                        item.toRentalId(payload.fulfillment.recipient),\n+                        item.amount\n                     );\n                 }\n             }\n@@ -597,8 +598,9 @@ contract Create is Policy, Signer, Zone, Accumulator {\n             // Interaction: Increase the deposit value on the payment escrow so\n             // it knows how many tokens were sent to it.\n             for (uint256 i = 0; i < items.length; ++i) {\n-                if (items[i].isERC20()) {\n-                    ESCRW.increaseDeposit(items[i].token, items[i].amount);\n+                item = items[i];\n+                if (item.isERC20()) {\n+                    ESCRW.increaseDeposit(item.token, item.amount);\n                 }\n             }\n```\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/policies/Create.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {ZoneParameters} from \"@seaport-core/lib/rental/ConsiderationStructs.sol\";\nimport {ReceivedItem, SpentItem} from \"@seaport-types/lib/ConsiderationStructs.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {ZoneInterface} from \"@src/interfaces/IZone.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode, toRole} from \"@src/libraries/KernelUtils.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {Signer} from \"@src/packages/Signer.sol\";\nimport {Zone} from \"@src/packages/Zone.sol\";\nimport {Accumulator} from \"@src/packages/Accumulator.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {\n    RentalOrder,\n    RentPayload,\n    SeaportPayload,\n    Hook,\n    OrderFulfillment,\n    OrderMetadata,\n    OrderType,\n    Item,\n    ItemType,\n    SettleTo,\n    RentalId,\n    RentalAssetUpdate\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\n\n/**\n * @title Create\n * @notice Acts as an interface for all behavior related to creating a rental.\n */\ncontract Create is Policy, Signer, Zone, Accumulator {\n    using RentalUtils for Item;\n    using RentalUtils for Item[];\n    using RentalUtils for SpentItem;\n    using RentalUtils for ReceivedItem;\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) Signer() Zone() {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentals.selector);\n        requests[1] = Permissions(toKeycode(\"ESCRW\"), ESCRW.increaseDeposit.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                              View Functions                                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Retrieves the domain separator.\n     *\n     * @return The domain separator for the protocol.\n     */\n    function domainSeparator() external view returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    /**\n     * @notice Derives the rental order EIP-712 compliant hash from a `RentalOrder`.\n     *\n     * @param order Rental order converted to a hash.\n     */\n    function getRentalOrderHash(\n        RentalOrder memory order\n    ) external view returns (bytes32) {\n        return _deriveRentalOrderHash(order);\n    }\n\n    /**\n     * @notice Derives the rent payload EIP-712 compliant hash from a `RentPayload`.\n     *\n     * @param payload Rent payload converted to a hash.\n     */\n    function getRentPayloadHash(\n        RentPayload memory payload\n    ) external view returns (bytes32) {\n        return _deriveRentPayloadHash(payload);\n    }\n\n    /**\n     * @notice Derives the order metadata EIP-712 compliant hash from an `OrderMetadata`.\n     *\n     * @param metadata Order metadata converted to a hash.\n     */\n    function getOrderMetadataHash(\n        OrderMetadata memory metadata\n    ) external view returns (bytes32) {\n        return _deriveOrderMetadataHash(metadata);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Helper function to emit an event which signals a rental order has started.\n     *\n     * @param order     Rental order to emit.\n     * @param orderHash Order hash of the seaport order.\n     * @param extraData Any extra data to be emitted which was supplied by the offerer.\n     */\n    function _emitRentalOrderStarted(\n        RentalOrder memory order,\n        bytes32 orderHash,\n        bytes memory extraData\n    ) internal {\n        // Emit the event.\n        emit Events.RentalOrderStarted(\n            orderHash,\n            extraData,\n            order.seaportOrderHash,\n            order.items,\n            order.hooks,\n            order.orderType,\n            order.lender,\n            order.renter,\n            order.rentalWallet,\n            order.startTimestamp,\n            order.endTimestamp\n        );\n    }\n\n    /**\n     * @dev Processes the offer items for inclusion in a BASE order. All offer items must\n     *      adhere to the BASE order format, else execution will revert.\n     *\n     * @param rentalItems Running array of items that comprise the rental order.\n     * @param offers      Array of offer items to include in the the order.\n     * @param startIndex  Index to begin adding the offer items to the\n     *                    `rentalItems` array.\n     */\n    function _processBaseOrderOffer(\n        Item[] memory rentalItems,\n        SpentItem[] memory offers,\n        uint256 startIndex\n    ) internal pure {\n        // Must be at least one offer item.\n        if (offers.length == 0) {\n            revert Errors.CreatePolicy_OfferCountZero();\n        }\n\n        // Define elements of the item which depend on the token type.\n        ItemType itemType;\n\n        // Process each offer item.\n        for (uint256 i; i < offers.length; ++i) {\n            // Get the offer item.\n            SpentItem memory offer = offers[i];\n\n            // Handle the ERC721 item.\n            if (offer.isERC721()) {\n                itemType = ItemType.ERC721;\n            }\n            // Handle the ERC1155 item.\n            else if (offer.isERC1155()) {\n                itemType = ItemType.ERC1155;\n            }\n            // ERC20s are not supported as offer items in a BASE order.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n            }\n\n            // An ERC721 or ERC1155 offer item is considered a rented asset which will be\n            // returned to the lender upon expiration of the rental order.\n            rentalItems[i + startIndex] = Item({\n                itemType: itemType,\n                settleTo: SettleTo.LENDER,\n                token: offer.token,\n                amount: offer.amount,\n                identifier: offer.identifier\n            });\n        }\n    }\n\n    /**\n     * @dev Processes the offer items for inclusion in a PAY order. All offer items must\n     *      adhere to the PAY order format, else execution will revert.\n     *\n     * @param rentalItems Running array of items that comprise the rental order.\n     * @param offers      Array of offer items to include in the the order.\n     * @param startIndex  Index to begin adding the offer items to the\n     *                    `rentalItems` array.\n     */\n    function _processPayOrderOffer(\n        Item[] memory rentalItems,\n        SpentItem[] memory offers,\n        uint256 startIndex\n    ) internal pure {\n        // Keep track of each item type.\n        uint256 totalRentals;\n        uint256 totalPayments;\n\n        // Define elements of the item which depend on the token type.\n        ItemType itemType;\n        SettleTo settleTo;\n\n        // Process each offer item.\n        for (uint256 i; i < offers.length; ++i) {\n            // Get the offer item.\n            SpentItem memory offer = offers[i];\n\n            // Handle the ERC721 item.\n            if (offer.isERC721()) {\n                // The ERC721 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC721;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Handle the ERC1155 item.\n            else if (offer.isERC1155()) {\n                // The ERC1155 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC1155;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Process an ERC20 offer item.\n            else if (offer.isERC20()) {\n                // An ERC20 offer item is considered a payment to the renter upon\n                // expiration of the rental order.\n                itemType = ItemType.ERC20;\n                settleTo = SettleTo.RENTER;\n\n                // Increment payments.\n                totalPayments++;\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n            }\n\n            // Create the item.\n            rentalItems[i + startIndex] = Item({\n                itemType: itemType,\n                settleTo: settleTo,\n                token: offer.token,\n                amount: offer.amount,\n                identifier: offer.identifier\n            });\n        }\n\n        // PAY order offer must have at least one rental and one payment.\n        if (totalRentals == 0 || totalPayments == 0) {\n            revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n        }\n    }\n\n    /**\n     * @dev Processes the consideration items for inclusion in a BASE order. All\n     *      consideration items must adhere to the BASE order format, else\n     *      execution will revert.\n     *\n     * @param rentalItems    Running array of items that comprise the rental order.\n     * @param considerations Array of consideration items to include in the the order.\n     * @param startIndex     Index to begin adding the offer items to the\n     *                       `rentalItems` array.\n     */\n    function _processBaseOrderConsideration(\n        Item[] memory rentalItems,\n        ReceivedItem[] memory considerations,\n        uint256 startIndex\n    ) internal pure {\n        // Must be at least one consideration item.\n        if (considerations.length == 0) {\n            revert Errors.CreatePolicy_ConsiderationCountZero();\n        }\n\n        // Process each consideration item.\n        for (uint256 i; i < considerations.length; ++i) {\n            // Get the consideration item.\n            ReceivedItem memory consideration = considerations[i];\n\n            // Only process an ERC20 item.\n            if (!consideration.isERC20()) {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    consideration.itemType\n                );\n            }\n\n            // An ERC20 consideration item is considered a payment to the lender upon\n            // expiration of the rental order.\n            rentalItems[i + startIndex] = Item({\n                itemType: ItemType.ERC20,\n                settleTo: SettleTo.LENDER,\n                token: consideration.token,\n                amount: consideration.amount,\n                identifier: consideration.identifier\n            });\n        }\n    }\n\n    /**\n     * @dev Processes the consideration items for inclusion in a PAYEE order. All\n     *      consideration items must adhere to the PAYEE order format, else\n     *      execution will revert.\n     *\n     * @param considerations Array of consideration items to include in the the order.\n     */\n    function _processPayeeOrderConsideration(\n        ReceivedItem[] memory considerations\n    ) internal pure {\n        // Keep track of each item type.\n        uint256 totalRentals;\n        uint256 totalPayments;\n\n        // Process each consideration item.\n        for (uint256 i; i < considerations.length; ++i) {\n            // Get the consideration item.\n            ReceivedItem memory consideration = considerations[i];\n\n            // Process an ERC20 item.\n            if (consideration.isERC20()) {\n                totalPayments++;\n            }\n            // Process an ERC721 or ERC1155 consideration item.\n            else if (consideration.isRental()) {\n                totalRentals++;\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    consideration.itemType\n                );\n            }\n        }\n\n        // PAYEE order consideration must have at least one rental and one payment.\n        if (totalRentals == 0 || totalPayments == 0) {\n            revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n        }\n    }\n\n    /**\n     * @dev Converts an offer array and a consideration array into a single array of\n     *      `Item` which comprise a rental order. The offers and considerations must\n     *      adhere to a specific set of rules depending on the type of order being\n     *      constructed.\n     *\n     * @param offers         Array of Seaport offer items.\n     * @param considerations Array of seaport consideration items.\n     * @param orderType      Order type of the rental.\n     */\n    function _convertToItems(\n        SpentItem[] memory offers,\n        ReceivedItem[] memory considerations,\n        OrderType orderType\n    ) internal pure returns (Item[] memory items) {\n        // Initialize an array of items.\n        items = new Item[](offers.length + considerations.length);\n\n        // Process items for a base order.\n        if (orderType.isBaseOrder()) {\n            // Process offer items.\n            _processBaseOrderOffer(items, offers, 0);\n\n            // Process consideration items.\n            _processBaseOrderConsideration(items, considerations, offers.length);\n        }\n        // Process items for a pay order.\n        else if (orderType.isPayOrder()) {\n            // Process offer items.\n            _processPayOrderOffer(items, offers, 0);\n\n            // Assert that no consideration items are provided.\n            if (considerations.length > 0) {\n                revert Errors.CreatePolicy_ConsiderationCountNonZero(\n                    considerations.length\n                );\n            }\n        }\n        // Process items for a payee order.\n        else if (orderType.isPayeeOrder()) {\n            // Assert that no offer items are provided.\n            if (offers.length > 0) {\n                revert Errors.CreatePolicy_OfferCountNonZero(offers.length);\n            }\n\n            // Process consideration items.\n            _processPayeeOrderConsideration(considerations);\n        }\n        // Revert if order type is not supported.\n        else {\n            revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n        }\n    }\n\n    /**\n     * @dev When a rental order is created, process each hook one by one but only if\n     *      the hook's status is set to execute on a rental start.\n     *\n     * @param hooks        Array of hooks to process for the order.\n     * @param offerItems   Array of offer items which are referenced by the hooks\n     * @param rentalWallet Address of the rental wallet which is the recipient\n     *                     of the rented assets.\n     */\n    function _addHooks(\n        Hook[] memory hooks,\n        SpentItem[] memory offerItems,\n        address rentalWallet\n    ) internal {\n        // Define hook target, offer item index, and an offer item.\n        address target;\n        uint256 itemIndex;\n        SpentItem memory offer;\n\n        // Loop through each hook in the payload.\n        for (uint256 i = 0; i < hooks.length; ++i) {\n            // Get the hook's target address.\n            target = hooks[i].target;\n\n            // Check that the hook is reNFT-approved to execute on rental start.\n            if (!STORE.hookOnStart(target)) {\n                revert Errors.Shared_DisabledHook(target);\n            }\n\n            // Get the offer item index for this hook.\n            itemIndex = hooks[i].itemIndex;\n\n            // Get the offer item for this hook.\n            offer = offerItems[itemIndex];\n\n            // Make sure the offer item is an ERC721 or ERC1155.\n            if (!offer.isRental()) {\n                revert Errors.Shared_NonRentalHookItem(itemIndex);\n            }\n\n            // Call the hook with data about the rented item.\n            try\n                IHook(target).onStart(\n                    rentalWallet,\n                    offer.token,\n                    offer.identifier,\n                    offer.amount,\n                    hooks[i].extraData\n                )\n            {} catch Error(string memory revertReason) {\n                // Revert with reason given.\n                revert Errors.Shared_HookFailString(revertReason);\n            } catch Panic(uint256 errorCode) {\n                // Convert solidity panic code to string.\n                string memory stringErrorCode = LibString.toString(errorCode);\n\n                // Revert with panic code.\n                revert Errors.Shared_HookFailString(\n                    string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n                );\n            } catch (bytes memory revertData) {\n                // Fallback to an error that returns the byte data.\n                revert Errors.Shared_HookFailBytes(revertData);\n            }\n        }\n    }\n\n    /**\n     * @dev Initiates a rental order using a rental payload received by the fulfiller,\n     *      and a payload from seaport with data involving the assets that were\n     *      transferred in the order.\n     *\n     * @param payload Payload from the order fulfiller.\n     * @param seaportPayload Payload containing the result of a seaport order fulfillment.\n     */\n    function _rentFromZone(\n        RentPayload memory payload,\n        SeaportPayload memory seaportPayload\n    ) internal {\n        // Check: make sure order metadata is valid with the given seaport order zone hash.\n        _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n\n        // Check: verify the fulfiller of the order is an owner of the recipient safe.\n        _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n\n        // Check: verify each execution was sent to the expected destination.\n        _executionInvariantChecks(\n            seaportPayload.totalExecutions,\n            payload.fulfillment.recipient\n        );\n\n        // Check: validate and process seaport offer and consideration items based\n        // on the order type.\n        Item[] memory items = _convertToItems(\n            seaportPayload.offer,\n            seaportPayload.consideration,\n            payload.metadata.orderType\n        );\n\n        // PAYEE orders are considered mirror-images of a PAY order. So, PAYEE orders\n        // do not need to be processed in the same way that other order types do.\n        if (\n            payload.metadata.orderType.isBaseOrder() ||\n            payload.metadata.orderType.isPayOrder()\n        ) {\n            // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n            // the rented amount. From this point on, new memory cannot be safely allocated until the\n            // accumulator no longer needs to include elements.\n            bytes memory rentalAssetUpdates = new bytes(0);\n\n            // Check if each item is a rental. If so, then generate the rental asset update.\n            // Memory will become safe again after this block.\n            for (uint256 i; i < items.length; ++i) {\n                if (items[i].isRental()) {\n                    // Insert the rental asset update into the dynamic array.\n                    _insert(\n                        rentalAssetUpdates,\n                        items[i].toRentalId(payload.fulfillment.recipient),\n                        items[i].amount\n                    );\n                }\n            }\n\n            // Generate the rental order.\n            RentalOrder memory order = RentalOrder({\n                seaportOrderHash: seaportPayload.orderHash,\n                items: items,\n                hooks: payload.metadata.hooks,\n                orderType: payload.metadata.orderType,\n                lender: seaportPayload.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + payload.metadata.rentDuration\n            });\n\n            // Compute the order hash.\n            bytes32 orderHash = _deriveRentalOrderHash(order);\n\n            // Interaction: Update storage only if the order is a Base Order or Pay order.\n            STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n\n            // Interaction: Increase the deposit value on the payment escrow so\n            // it knows how many tokens were sent to it.\n            for (uint256 i = 0; i < items.length; ++i) {\n                if (items[i].isERC20()) {\n                    ESCRW.increaseDeposit(items[i].token, items[i].amount);\n                }\n            }\n\n            // Interaction: Process the hooks associated with this rental.\n            if (payload.metadata.hooks.length > 0) {\n                _addHooks(\n                    payload.metadata.hooks,\n                    seaportPayload.offer,\n                    payload.fulfillment.recipient\n                );\n            }\n\n            // Emit rental order started.\n            _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n        }\n    }\n\n    /**\n     * @dev Checks that the order metadata passed with the seaport order is expected.\n     *\n     * @param metadata Order metadata that was passed in with the fulfillment.\n     * @param zoneHash Hash of the order metadata that was passed in when the Seaport\n     *                 order was signed.\n     */\n    function _isValidOrderMetadata(\n        OrderMetadata memory metadata,\n        bytes32 zoneHash\n    ) internal view {\n        // Check that the rent duration specified is not zero.\n        if (metadata.rentDuration == 0) {\n            revert Errors.CreatePolicy_RentDurationZero();\n        }\n\n        // Check that the zone hash is equal to the derived hash of the metadata.\n        if (_deriveOrderMetadataHash(metadata) != zoneHash) {\n            revert Errors.CreatePolicy_InvalidOrderMetadataHash();\n        }\n    }\n\n    /**\n     * @dev Checks that an address is the owner of a protocol-deployed rental safe.\n     *\n     * @param owner Address of the potential safe owner.\n     * @param safe  Address of the potential protocol-deployed rental safe.\n     */\n    function _isValidSafeOwner(address owner, address safe) internal view {\n        // Make sure only protocol-deployed safes can rent.\n        if (STORE.deployedSafes(safe) == 0) {\n            revert Errors.CreatePolicy_InvalidRentalSafe(safe);\n        }\n\n        // Make sure the fulfiller is the owner of the recipient rental safe.\n        if (!ISafe(safe).isOwner(owner)) {\n            revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);\n        }\n    }\n\n    /**\n     * @dev Helper function to check that an execution performed by Seaport resulting\n     *      in the expected address receiving the asset.\n     *\n     * @param execution Execution that was performed by Seaport.\n     * @param expectedRecipient Address which should now own the rented asset.\n     */\n    function _checkExpectedRecipient(\n        ReceivedItem memory execution,\n        address expectedRecipient\n    ) internal pure {\n        if (execution.recipient != expectedRecipient) {\n            revert Errors.CreatePolicy_UnexpectedTokenRecipient(\n                execution.itemType,\n                execution.token,\n                execution.identifier,\n                execution.amount,\n                execution.recipient,\n                expectedRecipient\n            );\n        }\n    }\n\n    /**\n     * @dev After a Seaport order has been executed, invariant checks are made to ensure\n     *      that all assets are owned by the correct addresses. More specifically, all\n     *      ERC20 tokens are sent to the payment escrow module, and all rental assets\n     *      are in the intended recipient's rental safe.\n     *\n     * @param executions Each execution that was performed by Seaport.\n     * @param expectedRentalSafe The intended recipient of the rental assets.\n     */\n    function _executionInvariantChecks(\n        ReceivedItem[] memory executions,\n        address expectedRentalSafe\n    ) internal view {\n        for (uint256 i = 0; i < executions.length; ++i) {\n            ReceivedItem memory execution = executions[i];\n\n            // ERC20 invariant where the recipient must be the payment escrow.\n            if (execution.isERC20()) {\n                _checkExpectedRecipient(execution, address(ESCRW));\n            }\n            // ERC721 and ERC1155 invariants where the recipient must\n            // be the expected rental safe.\n            else if (execution.isRental()) {\n                _checkExpectedRecipient(execution, expectedRentalSafe);\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    execution.itemType\n                );\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Callback function implemented to make this contract a valid Seaport zone.\n     *         It can be considered the entrypoint to creating a rental. When a seaport\n     *         order specifies the create policy as its zone address, Seaport will call\n     *         this function after each order in the batch is processed. A call to\n     *         `validateOrder` is what kicks off the rental process, and performs steps\n     *         to convert a seaport order into a rental order which is stored\n     *         by the protocol.\n     *\n     * @param zoneParams Parameters from the seaport order.\n     *\n     * @return validOrderMagicValue A `bytes4` value to return back to Seaport.\n     */\n    function validateOrder(\n        ZoneParameters calldata zoneParams\n    ) external override onlyRole(\"SEAPORT\") returns (bytes4 validOrderMagicValue) {\n        // Decode the signed rental zone payload from the extra data.\n        (RentPayload memory payload, bytes memory signature) = abi.decode(\n            zoneParams.extraData,\n            (RentPayload, bytes)\n        );\n\n        // Create a payload of seaport data.\n        SeaportPayload memory seaportPayload = SeaportPayload({\n            orderHash: zoneParams.orderHash,\n            zoneHash: zoneParams.zoneHash,\n            offer: zoneParams.offer,\n            consideration: zoneParams.consideration,\n            totalExecutions: zoneParams.totalExecutions,\n            fulfiller: zoneParams.fulfiller,\n            offerer: zoneParams.offerer\n        });\n\n        // Check: The signature from the protocol signer has not expired.\n        _validateProtocolSignatureExpiration(payload.expiration);\n\n        // Check: The fulfiller is the intended fulfiller.\n        _validateFulfiller(payload.intendedFulfiller, seaportPayload.fulfiller);\n\n        // Recover the signer from the payload.\n        address signer = _recoverSignerFromPayload(\n            _deriveRentPayloadHash(payload),\n            signature\n        );\n\n        // Check: The data matches the signature and that the protocol signer is the one that signed.\n        if (!kernel.hasRole(signer, toRole(\"CREATE_SIGNER\"))) {\n            revert Errors.CreatePolicy_UnauthorizedCreatePolicySigner();\n        }\n\n        // Initiate the rental using the rental manager.\n        _rentFromZone(payload, seaportPayload);\n\n        // Return the selector of validateOrder as the magic value.\n        validOrderMagicValue = ZoneInterface.validateOrder.selector;\n    }\n}"
    },
    {
      "filename": "src/policies/Create.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {ZoneParameters} from \"@seaport-core/lib/rental/ConsiderationStructs.sol\";\nimport {ReceivedItem, SpentItem} from \"@seaport-types/lib/ConsiderationStructs.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {ZoneInterface} from \"@src/interfaces/IZone.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode, toRole} from \"@src/libraries/KernelUtils.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {Signer} from \"@src/packages/Signer.sol\";\nimport {Zone} from \"@src/packages/Zone.sol\";\nimport {Accumulator} from \"@src/packages/Accumulator.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {\n    RentalOrder,\n    RentPayload,\n    SeaportPayload,\n    Hook,\n    OrderFulfillment,\n    OrderMetadata,\n    OrderType,\n    Item,\n    ItemType,\n    SettleTo,\n    RentalId,\n    RentalAssetUpdate\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\n\n/**\n * @title Create\n * @notice Acts as an interface for all behavior related to creating a rental.\n */\ncontract Create is Policy, Signer, Zone, Accumulator {\n    using RentalUtils for Item;\n    using RentalUtils for Item[];\n    using RentalUtils for SpentItem;\n    using RentalUtils for ReceivedItem;\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) Signer() Zone() {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        ST"
    }
  ]
}