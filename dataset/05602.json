{
  "Title": "[H-03] Borrower has no way to update `maxTotalSupply` of `market` or close market.",
  "Content": "\nWithout the ability to update `maxTotalSupply`, `borrower` has no way to raise more assets in a specific market. Even worse, `borrower` has to pay extra interest for unused assets all the time because `borrower` has no way to reduce the max total supply of the market.\n\nSimilarly, `borrower` has to pay extra interest to the no-longer-used market all the time because there is no way to close it.\n\n### Proof of Concept\n\nThere are access controls on functions [`setMaxTotalSupply()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketConfig.sol#L134-L144) and [`closeMarket()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarket.sol#L142-L161), and only `WildcatMarketController` is allowed to access them; however, there is not a function in `WildcatMarketController` allowing the `borrower` to access them.\n\n### Recommended Mitigation Steps\n\nAdd `setMaxTotalSupply()` and `closeMarket()` in [`WildcatMarketController`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketController.sol) to allow the `borrower` access these functions:\n\n```solidity\n  function setMaxTotalSupply(address market, uint256 _maxTotalSupply) external onlyBorrower {\n    WildcatMarket(market).setMaxTotalSupply(_maxTotalSupply);\n  }\n  function closeMarket(address market) external onlyBorrower {\n    WildcatMarket(market).closeMarket();\n  }\n```\n\n### Assessed type\n\nAccess Control\n\n**[laurenceday (Wildcat) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/431#issuecomment-1803372151):**\n > Mitigated [here](https://github.com/wildcat-finance/wildcat-protocol/pull/57/commits/c32d6ad80776917673bbf7c5b61e3488c53f7210) and [here](https://github.com/wildcat-finance/wildcat-protocol/pull/57/commits/2b8a3e08644305cc169439f1bcf2c1795d6f1975).\n>\n > Lodging a protest against the High Risk decision, however:\n> \n> - Markets could still *effectively* be closed by all lenders redeeming their market tokens; the borrower handling these repayments ad hoc and the borrower removing all lenders from the appropriate controller to prevent future deposits. No funds are at risk here.\n> - The inability to increase or decrease the capacity from the controller - which can lead to more interest accruing to a lender that refuses to withdraw - is not a matter of funds being \"lost\" but rather a grieving.\n> \n> In either case, assets are *not* at direct risk *while in the market*: the definition of High Risk as given by the label is \"assets can be stolen/lost/compromised directly\".\n> \n> This does not apply here. It's certainly a Medium; however, and a valuable finding in and of itself.\n\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/431#issuecomment-1804284590):**\n > I partially agree with the sponsor. However, if the protocol was deployed with this bug, it would lack 2 core functionalities.\n> \n> A protocol being fully functional as intended, which is crucial to attract and keep customers/users with funds in the long term, can be considered a valuable asset itself.\n>\n> Although Medium severity is predestined for this category of findings which impede the function of a protocol, High severity seems justified given the impact.  \n> \n> The following might further clarify my reasoning:  \n> - Please also consider that not all findings that lead to lost or stolen funds will strictly yield a High severity finding, since it depends on the amount of funds at risk.  \n> - In contrast, not every impeded functionality will only yield Medium severity.  \n\n**[laurenceday (Wildcat) confirmed and commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/431#issuecomment-1810753921):**\n > Fair enough - not going to throw toys out of the pram over semantics. Appreciate the feedback!\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/market/WildcatMarketConfig.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport '../libraries/FeeMath.sol';\nimport '../libraries/SafeCastLib.sol';\nimport './WildcatMarketBase.sol';\n\ncontract WildcatMarketConfig is WildcatMarketBase {\n  using SafeCastLib for uint256;\n  using BoolUtils for bool;\n\n  // ===================================================================== //\n  //                      External Config Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns the maximum amount of underlying asset that can\n   *      currently be deposited to the market.\n   */\n  function maximumDeposit() external view returns (uint256) {\n    MarketState memory state = currentState();\n    return state.maximumDeposit();\n  }\n\n  /**\n   * @dev Returns the maximum supply the market can reach via\n   *      deposits (does not apply to interest accrual).\n   */\n  function maxTotalSupply() external view returns (uint256) {\n    return _state.maxTotalSupply;\n  }\n\n  /**\n   * @dev Returns the annual interest rate earned by lenders\n   *      in bips.\n   */\n  function annualInterestBips() external view returns (uint256) {\n    return _state.annualInterestBips;\n  }\n\n  function reserveRatioBips() external view returns (uint256) {\n    return _state.reserveRatioBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                  Sanctions                                 */\n  /* -------------------------------------------------------------------------- */\n\n  /// @dev Block a sanctioned account from interacting with the market\n  ///      and transfer its balance to an escrow contract.\n  // ******************************************************************\n  //          *  |\\**/|  *          *                                *\n  //          *  \\ == /  *          *                                *\n  //          *   | b|   *          *                                *\n  //          *   | y|   *          *                                *\n  //          *   \\ e/   *          *                                *\n  //          *    \\/    *          *                                *\n  //          *          *          *                                *\n  //          *          *          *                                *\n  //          *          *  |\\**/|  *                                *\n  //          *          *  \\ == /  *         _.-^^---....,,--       *\n  //          *          *   | b|   *    _--                  --_    *\n  //          *          *   | y|   *   <                        >)  *\n  //          *          *   \\ e/   *   |         O-FAC!          |  *\n  //          *          *    \\/    *    \\._                   _./   *\n  //          *          *          *       ```--. . , ; .--'''      *\n  //          *          *          *   üí∏        | |   |            *\n  //          *          *          *          .-=||  | |=-.    üí∏   *\n  //  üí∞ü§ëüí∞ *   üòÖ    *    üòê    *    üí∏    `-=#$%&%$#=-'         *\n  //   \\|/    *   /|\\    *   /|\\    *  üå™         | ;  :|    üå™       *\n  //   /\\     * üí∞/\\ üí∞ * üí∞/\\ üí∞ *    _____.,-#%&$@%#&#~,._____    *\n  // ******************************************************************\n  function nukeFromOrbit(address accountAddress) external nonReentrant {\n    if (!IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      revert BadLaunchCode();\n    }\n    MarketState memory state = _getUpdatedState();\n    _blockAccount(state, accountAddress);\n    _writeState(state);\n  }\n\n  /**\n   * @dev Unblock an account that was previously sanctioned and blocked\n   *      and has since been removed from the sanctions list or had\n   *      their sanctioned status overridden by the borrower.\n   */\n  function stunningReversal(address accountAddress) external nonReentrant {\n    Account memory account = _accounts[accountAddress];\n    if (account.approval != AuthRole.Blocked) {\n      revert AccountNotBlocked();\n    }\n\n    if (IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      revert NotReversedOrStunning();\n    }\n\n    account.approval = AuthRole.Null;\n    emit AuthorizationStatusUpdated(accountAddress, account.approval);\n\n    _accounts[accountAddress] = account;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                           External Config Setters                          */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Updates an account's authorization status based on whether the controller\n   *      has it marked as approved.\n   */\n  function updateAccountAuthorization(\n    address _account,\n    bool _isAuthorized\n  ) external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    Account memory account = _getAccount(_account);\n    if (_isAuthorized) {\n      account.approval = AuthRole.DepositAndWithdraw;\n    } else {\n      account.approval = AuthRole.WithdrawOnly;\n    }\n    _accounts[_account] = account;\n    _writeState(state);\n    emit AuthorizationStatusUpdated(_account, account.approval);\n  }\n\n  /**\n   * @dev Sets the maximum total supply - this only limits deposits and\n   *      does not affect interest accrual.\n   *\n   *      Can not be set lower than current total supply.\n   */\n  function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    if (_maxTotalSupply < state.totalSupply()) {\n      revert NewMaxSupplyTooLow();\n    }\n\n    state.maxTotalSupply = _maxTotalSupply.toUint128();\n    _writeState(state);\n    emit MaxTotalSupplyUpdated(_maxTotalSupply);\n  }\n\n  /**\n   * @dev Sets the annual interest rate earned by lenders in bips.\n   */\n  function setAnnualInterestBips(uint16 _annualInterestBips) public onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    if (_annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n\n    state.annualInterestBips = _annualInterestBips;\n    _writeState(state);\n    emit AnnualInterestBipsUpdated(_annualInterestBips);\n  }\n\n  /**\n   * @dev Adjust the market's reserve ratio.\n   *\n   *      If the new ratio is lower than the old ratio,\n   *      asserts that the market is not currently delinquent.\n   *\n   *      If the new ratio is higher than the old ratio,\n   *      asserts that the market will not become delinquent\n   *      because of the change.\n   */\n  function setReserveRatioBips(uint16 _reserveRatioBips) public onlyController nonReentrant {\n    if (_reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n\n    MarketState memory state = _getUpdatedState();\n\n    uint256 initialReserveRatioBips = state.reserveRatioBips;\n\n    if (_reserveRatioBips < initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert InsufficientReservesForOldLiquidityRatio();\n      }\n    }\n    state.reserveRatioBips = _reserveRatioBips;\n    if (_reserveRatioBips > initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert InsufficientReservesForNewLiquidityRatio();\n      }\n    }\n    _writeState(state);\n    emit ReserveRatioBipsUpdated(_reserveRatioBips);\n  }\n}"
    }
  ]
}