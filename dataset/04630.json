{
  "Title": "Refactor confusing finalization precondition",
  "Content": "The condition in [line 68](https://github.com/brave-intl/basic-attention-token-crowdsale/blob/17a5f8440a256a6dc5d8dd894b9615182c2901b2/contracts/BAToken.sol#L68-L70), is expressed in a very confusing way. It should be split into two conditional expressions: `totalSupply &lt; tokenCreationMin` and `block.number &lt;= fundingEndBlock &amp;&amp; totalSupply != tokenCreationCap`, each of which throws when true.\n\n\n**Update**: fixed in commit [09a1038c2ac0148b93876057fc056ae2a872fb88](https://github.com/brave-intl/basic-attention-token-crowdsale/commit/09a1038c2ac0148b93876057fc056ae2a872fb88).\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/BAToken.sol",
      "content": "pragma solidity ^0.4.10;\nimport \"./StandardToken.sol\";\nimport \"./SafeMath.sol\";\n\ncontract BAToken is StandardToken, SafeMath {\n\n    // metadata\n    string public constant name = \"Basic Attention Token\";\n    string public constant symbol = \"BAT\";\n    uint8 public constant decimals = 18;\n    string public version = \"0.9\";\n\n    // contracts\n    address public ethFundDeposit;      // deposit address for ETH for Brave International\n    address public batFundDeposit;      // deposit address for Brave internal use and Brave User Fund \n\n    // crowdsale parameters\n    bool public isFunding;              // State no longer important, but still useful for observation\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n    uint256 public batFund = 300 * 10**24;   // 300m BAT reserved for Brave\n    uint256 public constant tokenExchangeRate = 4000; // 4000 BAT tokens per 1 ETH\n    uint256 public constant tokenCreationCap =  1000 * 10**24; \n    uint256 public constant tokenCreationMin =  490 * 10**24; \n\n\n    // events\n    event LogRefund(address indexed to, uint256 value);\n\n\n    // constructor\n    function BAToken(\n        address _ethFundDeposit,\n        address _batFundDeposit,\n        uint256 _fundingStartBlock,\n        uint256 _fundingEndBlock)\n    {\n      isFunding = true;                      //controls crowdsale state\n      ethFundDeposit = _ethFundDeposit;\n      batFundDeposit = _batFundDeposit;\n      fundingStartBlock = _fundingStartBlock;\n      fundingEndBlock = _fundingEndBlock;\n      totalSupply = batFund;\n      balances[batFundDeposit] = batFund;    //Deposit optimistic Brave share\n    }\n\n    /// @dev Accepts ether and creates new BAT tokens.\n    function createTokens() payable external {\n      if (!isFunding) throw;\n      if (block.number < fundingStartBlock) throw;\n      if (block.number > fundingEndBlock) throw;\n      if (msg.value == 0) throw;\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\n      uint256 tmpSupply = safeAdd(totalSupply, tokens);\n      if(tokenCreationCap >= tmpSupply) {    // odd fractions won't be found\n        totalSupply += tokens;\n        balances[msg.sender] += tokens;\n        Transfer(0, msg.sender, tokens); // logs transfer\n      } else {\n        throw;                           // they need to get their money back if something goes wrong\n      }\n    }\n\n    /// @dev Ends the funding period and issues new BAT tokens to the User Growth Fund.\n    function finalize() external {\n      if (!isFunding) throw;\n      if (msg.sender != ethFundDeposit) throw; // this locks finalize to the ultimate ETH owner\n      if ((block.number <= fundingEndBlock ||\n           totalSupply < tokenCreationMin) &&\n          totalSupply < tokenCreationCap) throw;\n      // move to operational\n      isFunding = false;\n      if(!ethFundDeposit.send(this.balance)) throw;  // send the eth to Brave International\n    }\n\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\n    function refund() external {\n      if(!isFunding) throw;                       // prevents refund if operational\n      if (block.number <= fundingEndBlock) throw; // prevents refund until sale period is over\n      if(totalSupply >= tokenCreationMin) throw;  // no refunds if we sold enough\n      var batVal = balances[msg.sender];\n      if (batVal == 0) throw;\n      balances[msg.sender] = 0;\n      totalSupply -= batVal;\n      var ethVal = batVal / tokenExchangeRate;\n      LogRefund(msg.sender, ethVal);\n      if (!msg.sender.send(ethVal)) throw;       // if you're using a contract; make sure it works with .send gas limits\n    }\n\n}"
    }
  ]
}