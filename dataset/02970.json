{
  "Title": "M-5: First user can inflate `pointsPerShare` and cause `_correctPoints()` to revert due to overflow",
  "Content": "# Issue M-5: First user can inflate `pointsPerShare` and cause `_correctPoints()` to revert due to overflow \n\nSource: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/103 \n\n## Found by \nWATCHPUG, bin2chen\n\n## Summary\n\n`pointsPerShare` can be manipulated by the first user and cause `_correctPoints()` to revert later.\n\n## Vulnerability Detail\n\n`POINTS_MULTIPLIER` is an unusually large number as a precision fix for `pointsPerShare`: `type(uint128).max ~= 3.4e38`.\n\nThis makes it possible for the first user to manipulate the `pointsPerShare` to near `type(int256).max` and a later regular user can trigger the overflow of `_shares * _shares * ` in `_correctPoints()`.\n\n### PoC\n\n1. `deposit(1 wei)` lock for 10 mins, `mint()` 1 wei of shares;\n2. `distributeRewards(1000e18)`, `pointsPerShare += 1000e18 * type(uint128).max / 1` == 3e59;\n3. the victim `deposit(100e18)` for 1 year, `mint()` 150e18 shares;\n3. `_shares * pointsPerShare == -150e18 * 3e59 == -4.5e+79` which exceeds `type(int256).min`, thus the transaction will revert.\n\nThe attacker can also manipulate `pointsPerShare` to a slightly smaller number, so that `_shares * pointsPerShare` will only overflow after a certain amount of deposits.\n\n## Impact\n\nBy manipulating the `pointPerShare` precisely, the attacker can make it possible for the system to run normally for a little while and only to explode after a certain amount of deposits, as the `pointsPerShare` will be too large by then and all the `_mint` and `_burn` will revert due to overflow in `_correctPoints()`.\n\nThe users who deposited before will be unable to withdraw their funds.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/AbstractRewards.sol#L89-L99\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/BasePool.sol#L80-L88\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/AbstractRewards.sol#L125-L127\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n1. Add a minimal mint amount requirement for the first minter and send a portion of the initial shares to gov as a permanent reserve to avoid `pointPerShare` manipulating.\n2. Use a smaller number for `POINTS_MULTIPLIER`, eg, `1e12`.\n\n## Discussion\n\n**federava**\n\nAgree with the recommendation. Requiring a minimal amount for first minter/minting on deployment by governance should be enough to prevent the described manipulation.\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/13) from this issue\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/9",
  "Code": [
    {
      "filename": "merit-liquidity-mining/contracts/base/AbstractRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"../interfaces/IAbstractRewards.sol\";\nimport { SafeCastUpgradeable as SafeCast } from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Based on: https://github.com/indexed-finance/dividends/blob/master/contracts/base/AbstractDividends.sol\n * Renamed dividends to rewards.\n * @dev (OLD) Many functions in this contract were taken from this repository:\n * https://github.com/atpar/funds-distribution-token/blob/master/contracts/FundsDistributionToken.sol\n * which is an example implementation of ERC 2222, the draft for which can be found at\n * https://github.com/atpar/funds-distribution-token/blob/master/EIP-DRAFT.md\n *\n * This contract has been substantially modified from the original and does not comply with ERC 2222.\n * Many functions were renamed as \"rewards\" rather than \"funds\" and the core functionality was separated\n * into this abstract contract which can be inherited by anything tracking ownership of reward shares.\n */\nabstract contract AbstractRewards is Initializable, IAbstractRewards {\n  using SafeCast for uint128;\n  using SafeCast for uint256;\n  using SafeCast for int256;\n\n  error ZeroShareSupplyError();\n\n/* ========  Constants  ======== */\n  uint128 public constant POINTS_MULTIPLIER = type(uint128).max;\n\n/* ========  Internal Function References  ======== */\n  function(address) view returns (uint256) private getSharesOf;\n  function() view returns (uint256) private getTotalShares;\n\n/* ========  Storage  ======== */\n  uint256 public pointsPerShare;\n  mapping(address => int256) public pointsCorrection;\n  mapping(address => uint256) public withdrawnRewards;\n\n  function __AbstractRewards_init(\n    function(address) view returns (uint256) getSharesOf_,\n    function() view returns (uint256) getTotalShares_\n  ) internal onlyInitializing {\n    getSharesOf = getSharesOf_;\n    getTotalShares = getTotalShares_;\n  }\n\n/* ========  Public View Functions  ======== */\n  /**\n   * @dev Returns the total amount of rewards a given address is able to withdraw.\n   * @param _account Address of a reward recipient\n   * @return A uint256 representing the rewards `account` can withdraw\n   */\n  function withdrawableRewardsOf(address _account) public view override returns (uint256) {\n    return cumulativeRewardsOf(_account) - withdrawnRewards[_account];\n  }\n\n  /**\n   * @notice View the amount of rewards that an address has withdrawn.\n   * @param _account The address of a token holder.\n   * @return The amount of rewards that `account` has withdrawn.\n   */\n  function withdrawnRewardsOf(address _account) public view override returns (uint256) {\n    return withdrawnRewards[_account];\n  }\n\n  /**\n   * @notice View the amount of rewards that an address has earned in total.\n   * @dev accumulativeFundsOf(account) = withdrawableRewardsOf(account) + withdrawnRewardsOf(account)\n   * = (pointsPerShare * balanceOf(account) + pointsCorrection[account]) / POINTS_MULTIPLIER\n   * @param _account The address of a token holder.\n   * @return The amount of rewards that `account` has earned in total.\n   */\n  function cumulativeRewardsOf(address _account) public view override returns (uint256) {\n    return ((pointsPerShare * getSharesOf(_account)).toInt256() + pointsCorrection[_account]).toUint256() / POINTS_MULTIPLIER;\n  }\n\n/* ========  Dividend Utility Functions  ======== */\n\n  /** \n   * @notice Distributes rewards to token holders.\n   * @dev It reverts if the total shares is 0.\n   * It emits the `RewardsDistributed` event if the amount to distribute is greater than 0.\n   * About undistributed rewards:\n   *   In each distribution, there is a small amount which does not get distributed,\n   *   which is `(amount * POINTS_MULTIPLIER) % totalShares()`.\n   *   With a well-chosen `POINTS_MULTIPLIER`, the amount of funds that are not getting\n   *   distributed in a distribution can be less than 1 (base unit).\n   */\n  function _distributeRewards(uint256 _amount) internal {\n    uint256 shares = getTotalShares();\n    if (shares == 0) {\n      revert ZeroShareSupplyError();\n    }\n\n    if (_amount > 0) {\n      pointsPerShare = pointsPerShare + (_amount * POINTS_MULTIPLIER / shares);\n      emit RewardsDistributed(msg.sender, _amount);\n    }\n  }\n\n  /**\n   * @notice Prepares collection of owed rewards\n   * @dev It emits a `RewardsWithdrawn` event if the amount of withdrawn rewards is\n   * greater than 0.\n   */\n  function _prepareCollect(address _account) internal returns (uint256) {\n    uint256 _withdrawableDividend = withdrawableRewardsOf(_account);\n    if (_withdrawableDividend > 0) {\n      withdrawnRewards[_account] = withdrawnRewards[_account] + _withdrawableDividend;\n      emit RewardsWithdrawn(_account, _withdrawableDividend);\n    }\n    return _withdrawableDividend;\n  }\n\n  function _correctPointsForTransfer(address _from, address _to, uint256 _shares) internal {\n    int256 _magCorrection = (pointsPerShare * _shares).toInt256();\n    pointsCorrection[_from] = pointsCorrection[_from] + _magCorrection;\n    pointsCorrection[_to] = pointsCorrection[_to] - _magCorrection;\n  }\n\n  /**\n   * @dev Increases or decreases the points correction for `account` by\n   * `shares*pointsPerShare`.\n   */\n  function _correctPoints(address _account, int256 _shares) internal {\n    pointsCorrection[_account] = pointsCorrection[_account] + (_shares * (int256(pointsPerShare)));\n  }\n}"
    },
    {
      "filename": "merit-liquidity-mining/contracts/base/BasePool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { SafeERC20Upgradeable as SafeERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { ERC20VotesUpgradeable as ERC20Votes } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport { SafeCastUpgradeable as SafeCast } from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport { AccessControlEnumerableUpgradeable as AccessControlEnumerable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IBasePool.sol\";\nimport \"../interfaces/ITimeLockPool.sol\";\n\nimport \"./AbstractRewards.sol\";\nimport \"./BoringBatchable.sol\";\n\nabstract contract BasePool is Initializable, AccessControlEnumerable, ERC20Votes, AbstractRewards, IBasePool, BaseBoringBatchable {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    error MoreThanOneError();\n    error NoDepositTokenError();\n    error NotGovError();\n\n    IERC20 public depositToken;\n    IERC20 public rewardToken;\n    ITimeLockPool public escrowPool;\n    uint256 public escrowPortion; // how much is escrowed 1e18 == 100%\n    uint256 public escrowDuration; // escrow duration in seconds\n\n    bytes32 public constant GOV_ROLE = keccak256(\"GOV_ROLE\");\n\n    event RewardsClaimed(address indexed _from, address indexed _receiver, uint256 _escrowedAmount, uint256 _nonEscrowedAmount);\n\n    // Saves space calling _onlyGov instead having the code\n    modifier onlyGov() {\n        _onlyGov();\n        _;\n    }\n    \n    function _onlyGov() private view {\n        if (!hasRole(GOV_ROLE, _msgSender())) {\n            revert NotGovError();\n        }\n    }\n\n    function __BasePool_init(\n        string memory _name,\n        string memory _symbol,\n        address _depositToken,\n        address _rewardToken,\n        address _escrowPool,\n        uint256 _escrowPortion,\n        uint256 _escrowDuration\n    ) internal onlyInitializing {\n        __ERC20Permit_init(_name); // only initializes ERC712Permit\n        __ERC20_init(_name, _symbol); // unchained or not it only saves the variables\n        __AbstractRewards_init(balanceOf, totalSupply);\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        __AccessControlEnumerable_init();\n\n        if (_escrowPortion > 1e18) {\n            revert MoreThanOneError();\n        }\n        if (_depositToken == address(0)) {\n            revert NoDepositTokenError();\n        }\n        depositToken = IERC20(_depositToken);\n        rewardToken = IERC20(_rewardToken);\n        escrowPool = ITimeLockPool(_escrowPool);\n        escrowPortion = _escrowPortion;\n        escrowDuration = _escrowDuration;\n\n        if(_rewardToken != address(0) && _escrowPool != address(0)) {\n            IERC20(_rewardToken).safeApprove(_escrowPool, type(uint256).max);\n        }\n    }\n\n    function _mint(address _account, uint256 _amount) internal virtual override {\n\t\tsuper._mint(_account, _amount);\n        _correctPoints(_account, -(_amount.toInt256()));\n\t}\n\t\n\tfunction _burn(address _account, uint256 _amount) internal virtual override {\n\t\tsuper._burn(_account, _amount);\n        _correctPoints(_account, _amount.toInt256());\n\t}\n\n    function _transfer(address _from, address _to, uint256 _value) internal virtual override {\n\t\tsuper._transfer(_from, _to, _value);\n        _correctPointsForTransfer(_from, _to, _value);\n\t}\n\n    function distributeRewards(uint256 _amount) external override {\n        rewardToken.safeTransferFrom(_msgSender(), address(this), _amount);\n        _distributeRewards(_amount);\n    }\n\n    function claimRewards(address _receiver) external {\n        uint256 rewardAmount = _prepareCollect(_msgSender());\n        uint256 escrowedRewardAmount = rewardAmount * escrowPortion / 1e18;\n        uint256 nonEscrowedRewardAmount = rewardAmount - escrowedRewardAmount;\n\n        if(escrowedRewardAmount != 0 && address(escrowPool) != address(0)) {\n            escrowPool.deposit(escrowedRewardAmount, escrowDuration, _receiver);\n        }\n\n        // ignore dust\n        if(nonEscrowedRewardAmount > 1) {\n            rewardToken.safeTransfer(_receiver, nonEscrowedRewardAmount);\n        }\n\n        emit RewardsClaimed(_msgSender(), _receiver, escrowedRewardAmount, nonEscrowedRewardAmount);\n    }\n\n}"
    },
    {
      "filename": "merit-liquidity-mining/contracts/base/AbstractRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"../interfaces/IAbstractRewards.sol\";\nimport { SafeCastUpgradeable as SafeCast } from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Based on: https://github.com/indexed-finance/dividends/blob/master/contracts/base/AbstractDividends.sol\n * Renamed dividends to rewards.\n * @dev (OLD) Many functions in this contract were taken from this repository:\n * https://github.com/atpar/funds-distribution-token/blob/master/contracts/FundsDistributionToken.sol\n * which is an example implementation of ERC 2222, the draft for which can be found at\n * https://github.com/atpar/funds-distribution-token/blob/master/EIP-DRAFT.md\n *\n * This contract has been substantially modified from the original and does not comply with ERC 2222.\n * Many functions were renamed as \"rewards\" rather than \"funds\" and the core functionality was separated\n * into this abstract contract which can be inherited by anything tracking ownership of reward shares.\n */\nabstract contract AbstractRewards is Initializable, IAbstractRewards {\n  using SafeCast for uint128;\n  using SafeCast for uint256;\n  using SafeCast for int256;\n\n  error ZeroShareSupplyError();\n\n/* ========  Constants  ======== */\n  uint128 public constant POINTS_MULTIPLIER = type(uint128).max;\n\n/* ========  Internal Function References  ======== */\n  function(address) view returns (uint256) private getSharesOf;\n  function() view returns (uint256) private getTotalShares;\n\n/* ========  Storage  ======== */\n  uint256 public pointsPerShare;\n  mapping(address => int256) public pointsCorrection;\n  mapping(address => uint256) public withdrawnRewards;\n\n  function __AbstractRewards_init(\n    function(address) view returns (uint256) getSharesOf_,\n    function() view returns (uint256) getTotalShares_\n  ) internal onlyInitializing {\n    getSharesOf = getSharesOf_;\n    getTotalShares = getTotalShares_;\n  }\n\n/* ========  Public View Functions  ======== */\n  /**\n   * @dev Returns the total amount of rewards a given address is able to withdraw.\n   * @param _account Address of a reward recipient\n   * @return A uint256 representing the rewards `account` can withdraw\n   */\n  function withdrawableRewardsOf(address _account) public view override returns (uint256) {\n    return cumulativeRewardsOf(_account) - withdrawnRewards[_account];\n  }\n\n  /**\n   * @notice View the amount of rewards that an address has withdrawn.\n   * @param _account The address of a token holder.\n   * @return The amount of rewards that `account` has withdrawn.\n   */\n  function withdrawnRewardsOf(address _account) public view override returns (uint256) {\n    return withdrawnRewards[_account];\n  }\n\n  /**\n   * @notice View the amount of rewards that an address has earned in total.\n   * @dev accumulativeFundsOf(account) = withdrawableRewardsOf(account) + withdrawnRewardsOf(account)\n   * = (pointsPerShare * balanceOf(account) + pointsCorrection[account]) / POINTS_MULTIPLIER\n   * @param _account The address of a token holder.\n   * @return The amount of rewards that `account` has earned in total.\n   */\n  function cumulativeRewardsOf(address _account) public view override returns (uint256) {\n    return ((pointsPerShare * getSharesOf(_account)).toInt256() + pointsCorrection[_account]).toUint256() / POINTS_MULTIPLIER;\n  }\n\n/* ========  Dividend Utility Functions  ======== */\n\n  /** \n   * @notice Distributes rewards to token holders.\n   * @dev It reverts if the total shares is 0.\n   * It emits the `RewardsDistributed` event if the amount to distribute is greater than 0.\n   * About undistributed rewards:\n   *   In each distribution, there is a small amount which does not get distributed,\n   *   which is `(amount * POINTS_MULTIPLIER) % totalShares()`.\n   *   With a well-chosen `POINTS_MULTIPLIER`, the amount of funds that are not getting\n   *   distributed in a distribution can be less than 1 (base unit).\n   */\n  function _distributeRewards(uint256 _amount) internal {\n    uint256 shares = getTotalShares();\n    if (shares == 0) {\n      revert ZeroShareSupplyError();\n    }\n\n    if (_amount > 0) {\n      pointsPerShare = pointsPerShare + (_amount * POINTS_MULTIPLIER / shares);\n      emit RewardsDistributed(msg.sender, _amount);\n    }\n  }\n\n  /**\n   * @notice Prepares collection of owed rewards\n   * @dev It emits a `RewardsWithdrawn` event if the amount of withdrawn rewards is\n   * greater than 0.\n   */\n  function _prepareCollect(address _account) internal returns (uint256) {\n    uint256 _withdrawableDividend = withdrawableRewardsOf(_account);\n    if (_withdrawableDividend > 0) {\n      withdrawnRewards[_account] = withdrawnRewards[_account] + _withdrawableDividend;\n      emit RewardsWithdrawn(_account, _withdrawableDividend);\n    }\n    return _withdrawableDividend;\n  }\n\n  function _correctPointsForTransfer(address _from, address _to, uint256 _shares) internal {\n    int256 _magCorrection = (pointsPerShare * _shares).toInt256();\n    pointsCorrection[_from] = pointsCorrection[_from] + _magCorrection;\n    pointsCorrection[_to] = pointsCorrection[_to] - _magCorrection;\n  }\n\n  /**\n   * @dev Increases or decreases the points correction for `account` by\n   * `shares*pointsPerShare`.\n   */\n  function _correctPoints(address _account, int256 _shares) internal {\n    pointsCorrection[_account] = pointsCorrection[_account] + (_shares * (int256(pointsPerShare)));\n  }\n}"
    }
  ]
}