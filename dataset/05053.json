{
  "Title": "[M-24] Unordered Nonces open up to further MEV risks",
  "Content": "\nWhile a great effort was made to mitigate out of order nonce execution, the reality is that since `PermitC` allows unordered nonces, then nonces could be executed out of order. This opens up more problems than the original Permit Exploit. The original Permit exploit allowed to effectively always make multi-operations revert. This new scenario instead allows to use the order of nonces that will cause the most damage.\n\nThe most basic example would be using the reverse order to keep allowances to be non-zero. This may open up to more exploits, an example being claiming `TAP`, `twTAP` or rewards to router addresses by keeping the allowance as non-zero. Additionally, any time more than one Permit is issued, a race condition is available. This race condition would allow an exploiter to consume the nonces out of order, and then causes the transaction to revert. This, in contrast to the previous iteration, allows all possible sequences of combinations of allowances to determine the final result, while the original permit operation would allow only the proper sequence to be executed (with pauses between each step).\n\nThis additional risk can create scenarios in which outstanding allowance is left, which could incorrectly signal the willingness to claim tokens or the willingness to allow a target to bridge funds at a different time than intended. It's worth reiterating how `Signatures` can be executed as soon as made available on any mempool, whether a L2 or LayerZeros system.\n\n### POC\n\n- Victim signs Permit A, B and C.\n- Notice how any of the permutations of `[A, B, C]` could be used out of order.\n- Front-runner will execute those signatures at whichever order is best for them to leak the most value.\n\n### Mitigation\n\nThe only solution I have found is to ensure that all \"Macros\" in Magnetar always approve a specific contract at most once. Revokes are done without signatures, either by consuming the allowance via a `transferFrom` (which may not be possible) or by introducing a function that allows an operator to reset their allowance.\n\n### Assessed type\n\nMEV\n\n**[0xRektora (Tapioca) acknowledged and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/82#issuecomment-2016832977):**\n > If I remember correctly, the team from Limit Break did not build `PermitC` to have batched transaction, but it can be dangerous if implemented wrong. Will forward the message.\n>\n> As for Tapioca, we do have a batch function in [`Pearlmit`](https://github.com/Tapioca-DAO/tapioca-periph/blob/main/contracts/pearlmit/Pearlmit.sol#L78) that will force the signatures to be verified against the order they were sent to.\n>\n> We believe the solution to the griefing scenario would be to use something like [`permitTransferFromWithAdditionalDataERC20`](https://github.com/limitbreakinc/PermitC/blob/c431dc5e80690c1d8c3727f5992d519df3d38254/src/PermitC.sol#L523) on said batch, by effectively binding the whole Tx (approvals paired with compose messages) and force the approval to be executed only in the case, which would nullify the front-running  incentives.\n\n**[0xRektora (Tapioca) commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/82#issuecomment-2016902846):**\n > Limit Break answer -- \n> \n> >Yes - as designed it's explicitly allowed to use unordered nonces, so this would be valid.\n> A modification could be made to the `_checkAndInvalidateNonce` function if you want to do ordered where you have a tracker by account and make sure that `nonce == nextNonce[owner]`\n> but we don't want that for our base case as unordered nonces are required to execute orders out of sequence.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/pearlmit/Pearlmit.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {\n    PermitC, PermitC__SignatureTransferExceededPermitExpired, PackedApproval, ZERO_BYTES32\n} from \"permitc/PermitC.sol\";\n\n// Tapioca\nimport {PearlmitHash} from \"./PearlmitHash.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Pearlmit\n * @author Limit Break Inc., Tapioca\n * @notice Pearlmit inherit PermitC and implements a new `permitBatchTransferFrom()` function\n * to allow batch transfer of multiple token types.\n */\ncontract Pearlmit is PermitC {\n    constructor(string memory name, string memory version) PermitC(name, version) {}\n\n    /**\n     * @notice Permit batch transfer of multiple token types.\n     * @dev Check the validity of a permit batch transfer.\n     *      - Reverts if the permit is invalid.\n     *      - Reverts if the permit is expired.\n     * @dev Invalidate the nonce after checking it.\n     * @dev If past allowances for the token still exist, bypass the permit check.\n     *\n     * @param batch PermitBatchTransferFrom struct containing all necessary data for batch transfer.\n     * batch.approvals - array of SignatureApproval structs.\n     *      * batch.approvals.tokenType - type of token (0 = ERC20, 1 = ERC721, 2 = ERC1155).\n     *      * batch.approvals.token - address of the token.\n     *      * batch.approvals.id - id of the token (0 if ERC20).\n     *      * batch.approvals.amount - amount of the token (0 if ERC721).\n     *      * batch.approvals.operator - address of the operator to transfer the tokens to.\n     *      * batch.approvals.approvalExpiration - expiration of the approval.\n     * batch.owner - address of the owner of the tokens.\n     * batch.nonce - nonce of the owner.\n     * batch.sigDeadline - deadline for the signature.\n     * batch.signedPermit - signature of the permit.\n     */\n    function permitBatchTransferFrom(IPearlmit.PermitBatchTransferFrom calldata batch)\n        external\n        returns (bool[] memory errorStatus)\n    {\n        _checkPermitBatchApproval(batch);\n        uint256 numPermits = batch.approvals.length;\n        errorStatus = new bool[](numPermits);\n        for (uint256 i = 0; i < numPermits; ++i) {\n            IPearlmit.SignatureApproval calldata approval = batch.approvals[i];\n            if (approval.tokenType == uint8(IPearlmit.TokenType.ERC20)) {\n                errorStatus[i] = _transferFromERC20(approval.token, batch.owner, approval.operator, 0, approval.amount);\n            } else if (approval.tokenType == uint8(IPearlmit.TokenType.ERC721)) {\n                errorStatus[i] = _transferFromERC721(batch.owner, approval.operator, approval.token, approval.id);\n            } else if (approval.tokenType == uint8(IPearlmit.TokenType.ERC1155)) {\n                errorStatus[i] =\n                    _transferFromERC1155(approval.token, batch.owner, approval.operator, approval.id, approval.amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Permit batch approve of multiple token types.\n     * @dev If past allowances for the token still exist, bypass the permit check.\n     */\n    function permitBatchApprove(IPearlmit.PermitBatchTransferFrom calldata batch) external {\n        _checkPermitBatchApproval(batch);\n\n        uint256 numPermits = batch.approvals.length;\n        for (uint256 i = 0; i < numPermits; ++i) {\n            IPearlmit.SignatureApproval calldata approval = batch.approvals[i];\n            __storeApproval(\n                approval.token, approval.id, approval.amount, batch.sigDeadline, batch.owner, approval.operator\n            );\n        }\n    }\n\n    /**\n     * @dev Identical of PermitC._storeApproval.\n     */\n    function __storeApproval(\n        address token,\n        uint256 id,\n        uint200 amount,\n        uint48 expiration,\n        address owner,\n        address operator\n    ) internal {\n        PackedApproval storage allowed = _getPackedApprovalPtr(owner, token, id, ZERO_BYTES32, operator);\n        allowed.expiration = expiration;\n        allowed.amount = amount;\n\n        emit Approval({owner: owner, token: token, operator: operator, id: id, amount: amount, expiration: expiration});\n    }\n\n    /**\n     * @dev Generate the digest and check its validity against the permit.\n     * @dev If past allowances for the token still exist, bypass the permit check.\n     */\n    function _checkPermitBatchApproval(IPearlmit.PermitBatchTransferFrom calldata batch) internal {\n        // Check if the batch is already allowed\n        if (!_batchAllowanceCheck(batch)) {\n            bytes32 digest = _hashTypedDataV4(\n                PearlmitHash.hashBatchTransferFrom(\n                    batch.approvals, batch.nonce, batch.sigDeadline, masterNonce(batch.owner)\n                )\n            );\n\n            _checkBatchPermitData(batch.nonce, batch.sigDeadline, batch.owner, digest, batch.signedPermit);\n        }\n    }\n\n    /**\n     * @dev Checks if an approval has been already made and if it is still valid.\n     * This is to counter griefing attacks, where an attacker frontrun the approval.\n     */\n    function _batchAllowanceCheck(IPearlmit.PermitBatchTransferFrom calldata batch)\n        internal\n        returns (bool isBatchAllowed)\n    {\n        uint256 numPermits = batch.approvals.length;\n        isBatchAllowed = true;\n\n        for (uint256 i = 0; i < numPermits; ++i) {\n            IPearlmit.SignatureApproval calldata approval = batch.approvals[i];\n            (uint256 allowedAmount,) =\n                _allowance(batch.owner, approval.operator, approval.token, approval.id, ZERO_BYTES32);\n            if (allowedAmount < approval.amount) {\n                isBatchAllowed = false;\n                break;\n            }\n        }\n    }\n\n    /**\n     * @dev Check the validity of a permit batch transfer.\n     *      - Reverts if the permit is invalid.\n     *      - Reverts if the permit is expired.\n     * @dev Invalidate the nonce after checking it.\n     */\n    function _checkBatchPermitData(\n        uint256 nonce,\n        uint256 expiration,\n        address owner,\n        bytes32 digest,\n        bytes calldata signedPermit\n    ) internal {\n        if (block.timestamp > expiration) {\n            revert PermitC__SignatureTransferExceededPermitExpired();\n        }\n\n        _verifyPermitSignature(digest, signedPermit, owner);\n        _checkAndInvalidateNonce(owner, nonce);\n    }\n}"
    },
    {
      "filename": "src/PermitC.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Errors.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/interfaces/IERC1155.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {EIP712} from \"./openzeppelin-optimized/EIP712.sol\";\nimport {\n    ZERO_BYTES32,\n    ZERO, \n    ONE, \n    ORDER_STATE_OPEN,\n    ORDER_STATE_FILLED,\n    ORDER_STATE_CANCELLED,\n    SINGLE_USE_PERMIT_ADVANCED_TYPEHASH_STUB,\n    UPPER_BIT_MASK\n} from \"./Constants.sol\";\nimport {PackedApproval, OrderFillAmounts} from \"./DataTypes.sol\";\nimport {PermitHash} from './libraries/PermitHash.sol';\nimport {IPermitC} from './interfaces/IPermitC.sol';\n\n/*\n                                                     @@@@@@@@@@@@@@             \n                                                    @@@@@@@@@@@@@@@@@@(         \n                                                   @@@@@@@@@@@@@@@@@@@@@        \n                                                  @@@@@@@@@@@@@@@@@@@@@@@@      \n                                                           #@@@@@@@@@@@@@@      \n                                                               @@@@@@@@@@@@     \n                            @@@@@@@@@@@@@@*                    @@@@@@@@@@@@     \n                           @@@@@@@@@@@@@@@     @               @@@@@@@@@@@@     \n                          @@@@@@@@@@@@@@@     @                @@@@@@@@@@@      \n                         @@@@@@@@@@@@@@@     @@               @@@@@@@@@@@@      \n                        @@@@@@@@@@@@@@@     #@@             @@@@@@@@@@@@/       \n                        @@@@@@@@@@@@@@.     @@@@@@@@@@@@@@@@@@@@@@@@@@@         \n                       @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@            \n                      @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@             \n                     @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@           \n                    @@@@@@@@@@@@@@@     @@@@@&%%%%%%%%&&@@@@@@@@@@@@@@          \n                    @@@@@@@@@@@@@@      @@@@@               @@@@@@@@@@@         \n                   @@@@@@@@@@@@@@@     @@@@@                 @@@@@@@@@@@        \n                  @@@@@@@@@@@@@@@     @@@@@@                 @@@@@@@@@@@        \n                 @@@@@@@@@@@@@@@     @@@@@@@                 @@@@@@@@@@@        \n                @@@@@@@@@@@@@@@     @@@@@@@                 @@@@@@@@@@@&        \n                @@@@@@@@@@@@@@     *@@@@@@@               (@@@@@@@@@@@@         \n               @@@@@@@@@@@@@@@     @@@@@@@@             @@@@@@@@@@@@@@          \n              @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           \n             @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@            \n            @@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              \n           .@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 \n           @@@@@@@@@@@@@@%     @@@@@@@@@@@@@@@@@@@@@@@@(                        \n          @@@@@@@@@@@@@@@                                                       \n         @@@@@@@@@@@@@@@                                                        \n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         \n       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                          \n       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&                                          \n      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                           \n \n* @title PermitC\n* @custom:version 1.0.0\n* @author Limit Break, Inc.\n* @description Advanced approval management for ERC20, ERC721 and ERC1155 tokens\n*              allowing for single use permit transfers, time-bound approvals\n*              and order ID based transfers.\n*/\n\ncontract PermitC is EIP712, IPermitC {\n\n    /**\n     * @notice Map of approval details for the provided bytes32 hash to allow for multiple accessors\n     *\n     * @dev    By ID: keccak256(abi.encode(owner, operator, id, masterNonce)) => token => (amount, expiration)\n     * @dev    By Operator: keccak256(abi.encode(owner, operator, masterNonce)) => token => (amount, expiration)\n     */\n    mapping(bytes32 => mapping(address => PackedApproval)) private _approvals;\n\n    /**\n     * @notice Map of registered additional data hashes\n     *\n     * @dev    This is used to prevent someone from providing an invalid EIP712 envelope label\n     * @dev    and tricking a user into signing a different message than they expect.\n     */\n    mapping(bytes32 => bool) private _registeredHashes;\n\n    /// @dev Map of an address to a bitmap (slot => status)\n    mapping(address => mapping(uint256 => uint256)) private _unorderedNonces;\n\n    /**\n     * @notice Master nonce used to invalidate all outstanding approvals for an owner\n     *\n     * @dev    owner => masterNonce\n     * @dev    This is incremented when the owner calls lockdown()\n     */\n    mapping(address => uint256) private _masterNonces;\n\n    constructor(string memory name, string memory version) EIP712(name, version) {}\n\n    /**\n     * =================================================\n     * ================= Modifiers =====================\n     * =================================================\n     */\n\n    modifier onlyRegisteredAdvancedTypeHash(bytes32 advancedPermitHash) {\n        _requireAdvancedPermitHashIsRegistered(advancedPermitHash);\n        _;\n    }\n\n    /**\n     * =================================================\n     * ============== Approval Transfers ===============\n     * =================================================\n     */\n\n    /**\n     * @notice Approve an operator to spend a specific token / ID combination\n     * @notice This function is compatible with ERC20, ERC721 and ERC1155\n     * @notice To give unlimited approval for ERC20 and ERC1155, set amount to type(uint200).max\n     * @notice When approving an ERC721, you MUST set amount to `1`\n     * @notice When approving an ERC20, you MUST set id to `0`\n     *\n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. Updates the approval for an operator to use an amount of a specific token / ID combination\n     * @dev    2. If the expiration is 0, the approval is valid only in the context of the current block\n     * @dev    3. If the expiration is not 0, the approval is valid until the expiration timestamp\n     * @dev    4. If the provided amount is type(uint208).max, the approval is unlimited\n     *\n     * @param  token      The address of the token contract\n     * @param  id         The token ID\n     * @param  operator   The address of the operator\n     * @param  amount     The amount of tokens to approve\n     * @param  expiration The expiration timestamp of the approval\n     */\n    function approve(\n        address token, \n        uint256 id, \n        address operator, \n        uint200 amount, \n        uint48 expiration) external {\n        _storeApproval(token, id, amount, expiration, msg.sender, operator);\n    }\n\n    /**\n     * @notice Use a signed permit to increase the allowance for a provided operator\n     * @notice This function is compatible with ERC20, ERC721 and ERC1155\n     * @notice To give unlimited approval for ERC20 and ERC1155, set amount to type(uint200).max\n     * @notice When approving an ERC721, you MUST set amount to `1`\n     * @notice When approving an ERC20, you MUST set id to `0`\n     *\n     * @dev    - Throws if the permit has expired\n     * @dev    - Throws if the permit's nonce has already been used\n     * @dev    - Throws if the permit signature is does not recover to the provided owner\n     *\n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. Updates the approval for an operator to use an amount of a specific token / ID combination\n     * @dev    3. Sets the expiration of the approval to the expiration timestamp of the permit\n     * @dev    4. If the provided amount is type(uint208).max, the approval is unlimited\n     *\n     * @param  token                Address of the token to approve\n     * @param  id                   The token ID\n     * @param  nonce                The nonce of the permit\n     * @param  amount               The amount of tokens to approve\n     * @param  operator             The address of the operator\n     * @param  approvalExpiration   The expiration timestamp of the approval\n     * @param  sigDeadline          The deadline timestamp for the permit signature\n     * @param  owner                The owner of the tokens\n     * @param  signedPermit         The permit signature, signed by the owner\n     */\n    function updateApprovalBySignature(\n        address token,\n        uint256 id,\n        uint256 nonce,\n        uint200 amount,\n        address operator,\n        uint48 approvalExpiration,\n        uint48 sigDeadline,\n        address owner,\n        bytes calldata signedPermit\n    ) external {\n        if (block.timestamp > sigDeadline) {\n            revert PermitC__ApprovalTransferPermitExpiredOrUnset();\n        }\n        _checkAndInvalidateNonce(owner, nonce);\n        _verifyPermitSignature(\n            _hashTypedDataV4(\n                PermitHash.hashOnChainApproval(\n                    token,\n                    id,\n                    amount,\n                    nonce,\n                    operator,\n                    approvalExpiration,\n                    sigDeadline,\n                    _masterNonces[owner]\n                )\n            ),\n            signedPermit, \n            owner\n            );\n\n        _storeApproval(token, id, amount, approvalExpiration, owner, operator);\n    }\n\n    /**\n     * @notice Returns the amount of allowance an operator has and it's expiration for a specific token and id\n     * @notice If the expiration on the allowance has expired, returns 0\n     * @notice To retrieve allowance for ERC20, set id to `0`\n     * \n     * @param  owner    The owner of the token\n     * @param  operator The operator of the token\n     * @param  token    The address of the token contract\n     * @param  id       The token ID\n     *\n     * @return allowedAmount The amount of allowance the operator has\n     * @return expiration    The expiration timestamp of the allowance\n     */\n    function allowance(\n        address owner, \n        address operator, \n        address token, \n        uint256 id\n    ) external view returns (uint256 allowedAmount, uint256 expiration) {\n        return _allowance(owner, operator, token, id, ZERO_BYTES32);\n    }\n\n    /**\n     * =================================================\n     * ================ Signed Transfers ===============\n     * =================================================\n     */\n\n    /**\n     * @notice Registers the combination of a provided string with the `SINGLE_USE_PERMIT_ADVANCED_TYPEHASH_STUB` string\n     * @notice to create a valid additional data hash\n     *\n     * @dev    This function prevents malicious actors from changing the label of the EIP712 hash\n     * @dev    to a value that would fool an external user into signing a different message.\n     *\n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. The provided string is combined with the `SINGLE_USE_PERMIT_ADVANCED_TYPEHASH_STUB` string\n     * @dev    2. The combined string is hashed using keccak256\n     * @dev    3. The resulting hash is added to the `_registeredHashes` mapping\n     *\n     * @param  additionalDataTypeString The string to register as a valid additional data hash\n     */\n     function registerAdditionalDataHash(string calldata additionalDataTypeString) external {\n        bytes32 advancedPermitHash = \n            keccak256(bytes(string.concat(SINGLE_USE_PERMIT_ADVANCED_TYPEHASH_STUB, additionalDataTypeString)));\n        _registeredHashes[advancedPermitHash] = true;\n     }\n\n    /**\n     * @notice Transfer an ERC721 token from the owner to the recipient using a permit signature.\n     *\n     * @dev    Be advised that the permitted amount for ERC721 is always inferred to be 1, so signed permitted amount\n     * @dev    MUST always be set to 1.\n     *\n     * @dev    - Throws if the permit is expired\n     * @dev    - Throws if the nonce has already been used\n     * @dev    - Throws if the permit is not signed by the owner\n     * @dev    - Throws if the requested amount exceeds the permitted amount\n     * @dev    - Throws if the provided token address does not implement ERC721 transferFrom function\n     * @dev    - Returns `false` if the transfer fails\n     *\n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. Transfers the token from the owner to the recipient\n     * @dev    2. The nonce of the permit is marked as used\n     * @dev    3. Performs any additional checks in the before and after hooks\n     *\n     * @param token         The address of the token\n     * @param id            The ID of the token\n     * @param nonce         The nonce of the permit\n     * @param expiration    The expiration timestamp of the permit\n     * @param owner         The owner of the token\n     * @param to            The address to transfer the tokens to\n     * @param signedPermit  The permit signature, signed by the owner\n     *\n     * @return isError      True if the transfer failed, false otherwise\n     */\n    function permitTransferFromERC721(\n        address token,\n        uint256 id,\n        uint256 nonce,\n        uint256 expiration,\n        address owner,\n        address to,\n        bytes calldata signedPermit\n    ) external returns (bool isError) {\n        _checkPermitApproval(token, id, ONE, nonce, expiration, owner, ONE, signedPermit);\n        isError = _transferFromERC721(owner, to, token, id);\n    }\n\n\n    /**\n     * @notice Transfers an ERC721 token from the owner to the recipient using a permit signature\n     * @notice This function includes additional data to verify on the signature, allowing\n     * @notice protocols to extend the validation in one function call. NOTE: before calling this \n     * @notice function you MUST register the stub end of the additional data typestring using\n     * @notice the `registerAdditionalDataHash` function.\n     *\n     * @dev    Be advised that the permitted amount for ERC721 is always inferred to be 1, so signed permitted amount\n     * @dev    MUST always be set to 1.\n     *\n     * @dev    - Throws for any reason permitTransferFromERC721 would.\n     * @dev    - Throws if the additional data does not match the signature\n     * @dev    - Throws if the provided hash has not been registered as a valid additional data hash\n     * @dev    - Throws if the provided hash does not match the provided additional data\n     *\n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. Transfers the token from the owner to the recipient\n     * @dev    2. Performs any additional checks in the before and after hooks\n     * @dev    3. The nonce of the permit is marked as used\n     * \n     * @param  token                    The address of the token\n     * @param  id                       The ID of the token\n     * @param  nonce                    The nonce of the permit\n     * @param  expiration               The expiration timestamp of the permit\n     * @param  owner                    The owner of the token\n     * @param  to                       The address to transfer the tokens to\n     * @param  additionalData           The additional data to verify on the signature\n     * @param  advancedPermitHash       The hash of the additional data\n     * @param  signedPermit             The permit signature, signed by the owner\n     *\n     * @return isError                  True if the transfer failed, false otherwise\n     */\n    function permitTransferFromWithAdditionalDataERC721(\n        address token,\n        uint256 id,\n        uint256 nonce,\n        uint256 expiration,\n        address owner,\n        address to,\n        bytes32 additionalData,\n        bytes32 advancedPermitHash,\n        bytes calldata signedPermit\n   ) \n    external\n    onlyRegisteredAdvancedTypeHash(advancedPermitHash)\n    returns (bool isError) {\n        _checkPermitApprovalWithAdditionalData(\n            token, id, ONE, nonce, expiration, owner, ONE, signedPermit, additionalData, \n            advancedPermitHash\n        );\n        isError = _transferFromERC721(owner, to, token, id);\n    }\n\n    /**\n     * @notice Transfer an ERC1155 token from the owner to the recipient using a permit signature\n     *\n     * @dev    - Throws if the permit is expired\n     * @dev    - Throws if the nonce has already been used\n     * @dev    - Throws if the permit is not signed by the owner\n     * @dev    - Throws if the requested amount exceeds the permitted amount\n     * @dev    - Throws if the provided token address does not implement ERC1155 safeTransferFrom function\n     * @dev    - Returns `false` if the transfer fails\n     *\n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. Transfers the token (in the requested amount) from the owner to the recipient\n     * @dev    2. The nonce of the permit is marked as used\n     * @dev    3. Performs any additional checks in the before and after hooks\n     *\n     * @param token           The address of the token\n     * @param id              The ID of the token\n     * @param nonce           The nonce of the permit\n     * @param permitAmount    The amount of tokens permitted by the owner\n     * @param expiration      The expiration timestamp of the permit\n     * @param owner           The owner of the token\n     * @param to              The address to transfer the tokens to\n     * @param transferAmount  The amount of tokens to transfer\n     * @param signedPermit    The permit signature, signed by the owner\n     *\n     * @return isError        True if the transfer failed, false otherwise\n     */\n    function permitTransferFromERC1155(\n        address token,\n        uint256 id,\n        uint256 nonce,\n        uint256 permitAmount,\n        uint256 expiration,\n        address owner,\n        address to,\n        uint256 transferAmount,\n        bytes calldata signedPermit\n    ) external returns (bool isError) {\n        _checkPermitApproval(token, id, permitAmount, nonce, expiration, owner, transferAmount, signedPermit);\n        isError = _transferFromERC1155(token, owner, to, id, transferAmount);\n    }\n\n    /**\n     * @notice Transfers a token from the owner to the recipient using a permit signature\n     * @notice This function includes additional data to verify on the signature, allowing\n     * @notice protocols to extend the validation in one function call. NOTE: before calling this \n     * @notice function you MUST register the stub end of the additional data typestring using\n     * @notice the `registerAdditionalDataHash` function.\n     *\n     * @dev    - Throws for any reason permitTransferFrom would.\n     * @dev    - Throws if the additional data does not match the signature\n     * @dev    - Throws if the provided hash has not been registered as a valid additional data hash\n     * @dev    - Throws if the provided hash does not match the provided additional data\n     * @dev    - Throws if the provided hash has not been registered as a valid additional data hash\n     * @dev    - Returns `false` if the transfer fails\n     *\n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. Transfers the token (in the requested amount) from the owner to the recipient\n     * @dev    2. Performs any additional checks in the before and after hooks\n     * @dev    3. The nonce of the permit is marked as used\n     *\n     * @param  token                    The address of the token\n     * @param  id                       The ID of the token\n     * @param  nonce                    The nonce of the permit\n     * @param  permitAmount             The amount of tokens permitted by the owner\n     * @param  expiration               The expiration timestamp of the permit\n     * @param  owner                    The owner of the token\n     * @param  to                       The address to transfer the tokens to\n     * @param  transferAmount           The amount of tokens to transfer\n     * @param  additionalData           The additional data to verify on the signature\n     * @param  advancedPermitHash       The hash of the additional data\n     * @param  signedPermit             The permit signature, signed by the owner\n     *\n     * @return isError                  True if the transfer failed, false otherwise\n     */\n    function permitTransferFromWithAdditionalDataERC1155(\n        address token,\n        uint256 id,\n        uint256 nonce,\n        uint256 permitAmount,\n        uint256 expiration,\n        address owner,\n        address to,\n        uint256 transferAmount,\n        bytes32 additionalData,\n        bytes32 advancedPermitHash,\n        bytes calldata signedPermit\n    ) \n    external\n    onlyRegisteredAdvancedTypeHash(advancedPermitHash)\n    returns (bool isError) {\n        _checkPermitApprovalWithAdditionalData(\n            token, id, permitAmount, nonce, expiration, owner, transferAmount, signedPermit, additionalData, \n            advancedPermitHash\n        );\n        uint256 tmpId = id;\n        isError = _transferFromERC1155(token, owner, to, tmpId, transferAmount);\n    }\n\n    /**\n     * @notice Transfer an ERC20 token from the owner to the recipient using a permit signature.\n     *\n     * @dev    Be advised that the token ID for ERC20 is always inferred to be 0, so signed token ID\n     * @dev    MUST always be set to 0.\n     *\n     * @dev    - Throws if the permit is expired\n     * @dev    - Throws if the nonce has already been used\n     * @dev    - Throws if the permit is not signed by the owner\n     * @dev    - Throws if the requested amount exceeds the permitted amount\n     * @dev    - Throws if the provided token address does not implement ERC20 transferFrom function\n     * @dev    - Returns `false` if the transfer fails\n     *\n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. Transfers the token in the requested amount from the owner to the recipient\n     * @dev    2. The nonce of the permit is marked as used\n     * @dev    3. Performs any additional checks in the before and after hooks\n     *\n     * @param token         The address of the token\n     * @param nonce         The nonce of the permit\n     * @param permitAmount  The amount of tokens permitted by the owner\n     * @param expiration    The expiration timestamp of the permit\n     * @param owner         The owner of the token\n     * @param to            The address to transfer the tokens to\n     * @param signedPermit  The permit signature, signed by the owner\n     *\n     * @return isError      True if the transfer failed, false otherwise\n     */\n    function permitTransferFromERC20(\n        address token,\n        uint256 nonce,\n        uint256 permitAmount,\n        uint256 expiration,\n        address owner,\n        address to,\n        uint256 transferAmount,\n        bytes calldata signedPermit\n    ) external returns (bool isError) {\n        _checkPermitApproval(token, ZERO, permitAmount, nonce, expiration, owner, transferAmount, signedPermit);\n        isError = _transferFromERC20(token, owner, to, ZERO, transferAmount);\n    }\n\n    /**\n     * @notice Transfers an ERC20 token from the owner to the recipient using a permit signature\n     * @notice This function includes additional data to verify on the signature, allowing\n     * @notice protocols to extend the validation in one function call. NOTE: before calling this \n     * @notice function you MUST register the stub end of the additional data typestring using\n     * @notice the `registerAdditionalDataHash` function.\n     *\n     * @dev    Be advised that the token ID for ERC20 is always inferred to be 0, so signed token ID\n     * @dev    MUST always be set to 0.\n     *\n     * @dev    - Throws for any reason permitTransferFromERC20 would.\n     * @dev    - Throws if the additional data does not match the signature\n     * @dev    - Throws if the provided hash has not been registered as a valid additional data hash\n     * @dev    - Throws if the provided hash does not match the provided additional data\n     * @dev    - Returns `false` if the transfer fails\n     *\n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. Transfers the token (in the requested amount) from the owner to the recipient\n     * @dev    2. Performs any additional checks in the before and after hooks\n     * @dev    3. The nonce of the permit is marked as used\n     *\n     * @param  token                    The address of the token\n     * @param  nonce                    The nonce of the permit\n     * @param  permitAmount             The amount of tokens permitted by the owner\n     * @param  expiration               The expiration timestamp of the permit\n     * @param  owner                    The owner of the token\n     * @param  to                       The address to transfer the tokens to\n     * @param  transferAmount           The amount of tokens to transfer\n     * @param  additionalData           The additional data to verify on the signature\n     * @param  advancedPermitHash       The hash of the additional data\n     * @param  signedPermit             The permit signature, signed by the owner\n     *\n     * @return isError                  True if the transfer failed, false otherwise\n     */\n    function permitTransferFromWithAdditionalDataERC20(\n        address token,\n        uint256 nonce,\n        uint256 permitAmount,\n        uint256 expiration,\n        address owner,\n        address to,\n        uint256 transferAmount,\n        bytes32 additionalData,\n        bytes32 advancedPermitHash,\n        bytes calldata signedPermit\n    ) external onlyRegisteredAdvancedTypeHash(advancedPermitHash) returns (bool isError) {\n        _checkPermitApprovalWithAdditionalData(\n            token, ZERO, permitAmount, nonce, expiration, owner, transferAmount, signedPermit, additionalData, \n            advancedPermitHash\n        );\n        isError = _transferFromERC20(token, owner, to, ZERO, transferAmount);\n    }\n\n    /**\n     * @notice Returns true"
    }
  ]
}