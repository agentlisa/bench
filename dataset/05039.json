{
  "Title": "[H-04] Incorrect approval mechanism breaks all Magnetar functionality",
  "Content": "\nThe Magnetar contract hands out approvals to various contracts so that the target contracts can use any tokens held currently by the Magnetar contract.\n\nThe issue is that at some point of time, all the target contracts were refactored to use `permitC` to handle token transfers. However, this change wasn't reflected in the Magnetar contracts. Thus, instead of handing out `permitC` approvals, Magnetar hands out normal ERC20 approvals or yieldbox approvals. This essentially breaks the whole system.\n\nThere are numerous instances of this in the codebase. Essentially, almost every approval in the Magnetar contract is incorrect. Below are some examples, however the entire codebase needs to be checked for approvals and corrected.\n\nThe `_depositYBLendSGL` function in `MagnetarAssetCommonModule.sol` contract gives approval to the singularity contract via yieldbox. However, if we check the `_addTokens` function in the singularity contract below, we see the token transfers actually take place via `pearlmit`/`permitC`.\n\n```solidity\n_setApprovalForYieldBox(singularityAddress, yieldBox_);\n```\n\n<https://github.com/Tapioca-DAO/Tapioca-bar/blob/9d76b2fc7e2752ca8a816af2d748a0259af5ea42/contracts/markets/singularity/SGLCommon.sol#L165-L177>\n\nSince the Magnetar contract does not give `permitC` approval to the singularity contract, and instead only gives yieldbox approval, the singularity contract is unable to transfer tokens from the Magnetar contract.\n\nSimilarly, in the `_wrapSglReceipt` function, the Magnetar gives approval to the TOFT contract vie ERC20 approval:\n\n```solidity\nIERC20(sgl).approve(tReceiptAddress, fraction);\n```\n\nBut if we check the TOFT contract, we see the tokens are transferred via `permitC` and not with the raw tokens:\n\n<https://github.com/Tapioca-DAO/TapiocaZ/blob/57750b7e997e5a1654651af9b413bbd5ea508f59/contracts/tOFT/BaseTOFT.sol#L73>\n\nSince the Magnetar contract does not hand out the `permitC` approvals, most of the token transfers via Magnetar will fail.\n\n### Proof of Concept\n\nThe issue arises due to the target contracts using `permitC`, while Magnetar only giving approvals of the token itself or yieldbox. This can be verified by checking the Magnetar contract and the target contracts, as shown above.\n\n### Recommended Mitigation Steps\n\nRefactor Magnetar to give approvals via `permitC` throughout.\n\n**[cryptotechmaker (Tapioca) confirmed](https://github.com/code-423n4/2024-02-tapioca-findings/issues/125#issuecomment-2011767366)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/markets/singularity/SGLCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {ISingularity, IMarket} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {SGLStorage} from \"./SGLStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLCommon is SGLStorage {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error TooMuch();\n    error MinLimit();\n    error TransferFailed();\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() external {\n        _accrue();\n    }\n\n    function getInterestDetails()\n        external\n        view\n        returns (ISingularity.AccrueInfo memory _accrueInfo, uint256 utilization)\n    {\n        (_accrueInfo,,,,, utilization,) = _getInterestRate();\n    }\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getInterestRate()\n        internal\n        view\n        returns (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        )\n    {\n        _accrueInfo = accrueInfo;\n        _totalBorrow = totalBorrow;\n        _totalAsset = totalAsset;\n        extraAmount = 0;\n        feeFraction = 0;\n        logStartingInterest = false;\n\n        uint256 fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return (_accrueInfo, totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n        _accrueInfo.lastAccrued = block.timestamp.toUint64();\n\n        if (_totalBorrow.base == 0) {\n            // If there are no borrows, reset the interest rate\n            if (_accrueInfo.interestPerSecond != startingInterestPerSecond) {\n                _accrueInfo.interestPerSecond = startingInterestPerSecond;\n                logStartingInterest = true;\n            }\n            return (_accrueInfo, _totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n\n        // Accrue interest\n        extraAmount = (uint256(_totalBorrow.elastic) * _accrueInfo.interestPerSecond * elapsedTime) / 1e18;\n        _totalBorrow.elastic += extraAmount.toUint128();\n\n        //take accrued values into account\n        fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        uint256 feeAmount = (extraAmount * protocolFee) / FEE_PRECISION; // % of interest paid goes to fee\n        feeFraction = (feeAmount * _totalAsset.base) / (fullAssetAmount - feeAmount);\n        _accrueInfo.feesEarnedFraction += feeFraction.toUint128();\n        _totalAsset.base = _totalAsset.base + feeFraction.toUint128();\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Update interest rate\n        if (utilization < minimumTargetUtilization) {\n            uint256 underFactor =\n                ((minimumTargetUtilization - utilization) * FACTOR_PRECISION) / minimumTargetUtilization;\n            uint256 scale = interestElasticity + (underFactor * underFactor * elapsedTime);\n            _accrueInfo.interestPerSecond =\n                ((uint256(_accrueInfo.interestPerSecond) * interestElasticity) / scale).toUint64();\n            if (_accrueInfo.interestPerSecond < minimumInterestPerSecond) {\n                _accrueInfo.interestPerSecond = minimumInterestPerSecond; // 0.25% APR minimum\n            }\n        } else if (utilization > maximumTargetUtilization) {\n            uint256 overFactor = ((utilization - maximumTargetUtilization) * FACTOR_PRECISION) / fullUtilizationMinusMax;\n            uint256 scale = interestElasticity + (overFactor * overFactor * elapsedTime);\n            uint256 newInterestPerSecond = (uint256(_accrueInfo.interestPerSecond) * scale) / interestElasticity;\n            if (newInterestPerSecond > maximumInterestPerSecond) {\n                newInterestPerSecond = maximumInterestPerSecond; // 1000% APR maximum\n            }\n            _accrueInfo.interestPerSecond = newInterestPerSecond.toUint64();\n        }\n    }\n\n    function _accrueView() internal view override returns (Rebase memory _totalBorrow) {\n        (, _totalBorrow,,,,,) = _getInterestRate();\n    }\n\n    function _accrue() internal override {\n        (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        ) = _getInterestRate();\n\n        if (logStartingInterest) {\n            emit LogAccrue(0, 0, startingInterestPerSecond, 0);\n        } else {\n            emit LogAccrue(extraAmount, feeFraction, _accrueInfo.interestPerSecond, utilization);\n        }\n        accrueInfo = _accrueInfo;\n        totalBorrow = _totalBorrow;\n        totalAsset = _totalAsset;\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _assetId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(address from, address, uint256 _assetId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            if (share > yieldBox.balanceOf(address(this), _assetId) - total) {\n                revert TooMuch();\n            }\n        } else {\n            // yieldBox.transfer(from, address(this), _assetId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _assetId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n\n    /// @dev Concrete implementation of `addAsset`.\n    function _addAsset(address from, address to, bool skim, uint256 share) internal returns (uint256 fraction) {\n        Rebase memory _totalAsset = totalAsset;\n        uint256 totalAssetShare = _totalAsset.elastic;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, true);\n        fraction = allShare == 0 ? share : (share * _totalAsset.base) / allShare;\n        if (_totalAsset.base + fraction.toUint128() < 1000) {\n            return 0;\n        }\n        totalAsset = _totalAsset.add(share, fraction);\n\n        balanceOf[to] += fraction;\n        emit Transfer(address(0), to, fraction);\n\n        _addTokens(from, to, assetId, share, totalAssetShare, skim);\n        emit LogAddAsset(skim ? address(yieldBox) : from, to, share, fraction);\n    }\n\n    /// @dev Concrete implementation of `removeAsset`.\n    /// @param from The account to remove from. Should always be msg.sender except for `depositFeesToyieldBox()`.\n    function _removeAsset(address from, address to, uint256 fraction) internal returns (uint256 share) {\n        if (totalAsset.base == 0) {\n            return 0;\n        }\n        Rebase memory _totalAsset = totalAsset;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, false);\n        share = (fraction * allShare) / _totalAsset.base;\n\n        _totalAsset.base -= fraction.toUint128();\n        if (_totalAsset.base < 1000) revert MinLimit();\n\n        balanceOf[from] -= fraction;\n        emit Transfer(from, address(0), fraction);\n        _totalAsset.elastic -= share.toUint128();\n        totalAsset = _totalAsset;\n        emit LogRemoveAsset(from, to, share, fraction);\n        yieldBox.transfer(address(this), to, assetId, share);\n    }\n\n    /// @dev Return the equivalent of collateral borrow part in asset amount.\n    function _getAmountForBorrowPart(uint256 borrowPart) internal view returns (uint256) {\n        return totalBorrow.toElastic(borrowPart, false);\n    }\n\n    function _isWhitelisted(uint16 _chainId, address _contract) internal view returns (bool) {\n        return ICluster(penrose.cluster()).isWhitelisted(_chainId, _contract);\n    }\n\n    struct _ViewLiquidationStruct {\n        address user;\n        uint256 maxBorrowPart;\n        uint256 minLiquidationBonus;\n        uint256 exchangeRate;\n        IYieldBox yieldBox;\n        uint256 collateralId;\n        uint256 userCollateralShare;\n        uint256 userBorrowPart;\n        Rebase totalBorrow;\n        uint256 liquidationBonusAmount;\n        uint256 liquidationCollateralizationRate;\n        uint256 liquidationMultiplier;\n        uint256 exchangeRatePrecision;\n        uint256 feeDecimalsPrecision;\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/BaseTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Tapioca\nimport {BaseTapiocaOmnichainEngine} from \"tapioca-periph/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol\";\nimport {TOFTInitStruct, IToftVault} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {PearlmitHandler} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {BaseTOFTTokenMsgType} from \"./BaseTOFTTokenMsgType.sol\";\nimport {ModuleManager} from \"./modules/ModuleManager.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title BaseTOFT\n * @author TapiocaDAO\n * @notice Base TOFT contract for LZ V2\n */\nabstract contract BaseTOFT is ModuleManager, PearlmitHandler, BaseTapiocaOmnichainEngine, BaseTOFTTokenMsgType {\n    using SafeERC20 for IERC20;\n\n    IYieldBox public immutable yieldBox;\n    IToftVault public immutable vault;\n    uint256 public immutable hostEid;\n    address public immutable erc20;\n    ICluster public cluster;\n\n    error TOFT_AllowanceNotValid();\n    error TOFT_NotValid();\n    error TOFT_VaultWrongERC20();\n    error TOFT_VaultWrongOwner();\n\n    constructor(TOFTInitStruct memory _data)\n        BaseTapiocaOmnichainEngine(_data.name, _data.symbol, _data.endpoint, _data.delegate, _data.extExec, _data.pearlmit)\n    {\n        yieldBox = IYieldBox(_data.yieldBox);\n        cluster = ICluster(_data.cluster);\n        hostEid = _data.hostEid;\n        erc20 = _data.erc20;\n    }\n\n    /**\n     * @notice set the Cluster address.\n     * @param _cluster the new Cluster address\n     */\n    function setCluster(address _cluster) external virtual onlyOwner {\n        cluster = ICluster(_cluster);\n    }\n\n    function _wrap(address _fromAddress, address _toAddress, uint256 _amount, uint256 _feeAmount) internal virtual {\n        if (_fromAddress != msg.sender) {\n            if (allowance(_fromAddress, msg.sender) < _amount) {\n                revert TOFT_AllowanceNotValid();\n            }\n            _spendAllowance(_fromAddress, msg.sender, _amount);\n        }\n        if (_amount == 0) revert TOFT_NotValid();\n        // IERC20(erc20).safeTransferFrom(_fromAddress, address(vault), _amount);\n        bool isErr = pearlmit.transferFromERC20(_fromAddress, address(vault), erc20, _amount);\n        if (isErr) revert TOFT_NotValid();\n        _mint(_toAddress, _amount - _feeAmount);\n    }\n\n    function _wrapNative(address _toAddress, uint256 _amount, uint256 _feeAmount) internal virtual {\n        vault.depositNative{value: _amount}();\n        _mint(_toAddress, _amount - _feeAmount);\n    }\n\n    function _unwrap(address _toAddress, uint256 _amount) internal virtual {\n        _burn(msg.sender, _amount);\n        vault.withdraw(_toAddress, _amount);\n    }\n}"
    }
  ]
}