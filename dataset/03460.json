{
  "Title": "[L05] Useless or repeated code",
  "Content": "There are places in the codebase where code is either repeated or not needed. Some examples are:\n\n\n* [Lines 29-32](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/Registry.sol#L29-L32) of the `Registry` contract are useless, because the [`_add`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol#L53) function of the `EnumerableSet` contract [already performs these checks](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol#L54) against the values already being set.\n* [Lines 62](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L62), [67](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L67), [73](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L73) and [78](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L78) of the `SafeGuard` contract are all repeating the same exact operation. Consider encapsulating it into an internal function to avoid duplicating code.\n* [Lines 62-63](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L62-L63) and [67-68](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L67-L68) of `SafeGuard` are repeated. Consider encapsulating them into a single internal function.\n* The usage of `gasleft` to specify how much gas should be forwarded in the call of the function [`executeTransaction`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L80) is unnecessary. This is because, at that point of execution, the entire gas left will be used to continue the execution. If this is not for expliciteness, consider removing the `gas` parameter from the call.\n\n\nConsider applying the suggested fixed to produce a cleaner code and improve consistency and modularity over the codebase.\n\n\n**Update:** *Fixed in [PR #10](https://github.com/withtally/safeguard/pull/10) and commit [`7fd27df16fc879d990d36a167a0b6e719e578558`](https://github.com/withtally/safeguard/commit/7fd27df16fc879d990d36a167a0b6e719e578558).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Registry.sol",
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n// pragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./IRegistry.sol\";\n\n/**\n *  @title Registry contract storing information about all safeGuards deployed\n *  Used for querying and reverse querying available safeGuards for a given target+identifier transaction\n */\ncontract Registry is IRegistry {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice mapping of safeGuards and their version. Version starts from 1\n    mapping(address => uint8) public safeGuardVersion;\n\n    EnumerableSet.AddressSet private safeGuards;\n\n    /// @notice Register event emitted once new safeGuard is added to the registry\n    event Register(address indexed safeGuard, uint8 version);\n\n    /// @notice Register function for adding new safeGuard in the registry\n    /// @param safeGuard the address of the new SafeGuard\n    /// @param version the version of the safeGuard\n    function register(address safeGuard, uint8 version) external override {\n        require(version != 0, \"Registry: Invalid version\");\n        require(\n            !safeGuards.contains(safeGuard),\n            \"Registry: SafeGuard already registered\"\n        );\n\n        safeGuards.add(safeGuard);\n        safeGuardVersion[safeGuard] = version;\n\n        emit Register(safeGuard, version);\n    }\n\n    /**\n     * @notice Returns the safeGuard address by index\n     * @param index the index of the safeGuard in the set of safeGuards\n     */\n    function getSafeGuard(uint256 index)\n        external\n        view\n        override\n        returns (address)\n    {\n        require(index < safeGuards.length(), \"Registry: Invalid index\");\n\n        return safeGuards.at(index);\n    }\n\n    /// @notice Returns the count of all unique safeGuards\n    function getSafeGuardCount() external view override returns (uint256) {\n        return safeGuards.length();\n    }\n\n\n}"
    },
    {
      "filename": "contracts/SafeGuard.sol",
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"./ITimelock.sol\";\nimport \"hardhat/console.sol\";\n\ncontract SafeGuard is AccessControlEnumerable {\n\n    // Request info event\n    event QueueTransactionWithDescription(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta, string description);\n\n    bytes32 public constant SAFEGUARD_ADMIN_ROLE = keccak256(\"SAFEGUARD_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELER_ROLE = keccak256(\"CANCELER_ROLE\");\n    bytes32 public constant CREATOR_ROLE = keccak256(\"CREATOR_ROLE\");\n\n    ///@dev The address of the Timelock\n    ITimelock public timelock;\n\n    /**\n     * @dev Initializes the contract with a given Timelock address and administrator address.\n     */\n    constructor (address _admin, bytes32[] memory roles, address[] memory rolesAssignees) {\n        require(roles.length == rolesAssignees.length, \"SafeGuard::constructor: roles assignment arity mismatch\");\n        // set roles administrator\n        _setRoleAdmin(SAFEGUARD_ADMIN_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CANCELER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CREATOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n\n        // assign roles \n        for (uint i = 0; i < roles.length; i++) {\n            _setupRole(roles[i], rolesAssignees[i]);\n        }\n\n        // set admin rol to an address\n        _setupRole(SAFEGUARD_ADMIN_ROLE, _admin);\n        _setupRole(CREATOR_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Modifier to make a function callable just by a certain role.\n     */\n    modifier justByRole(bytes32 role) {\n        require(hasRole(role, _msgSender()), \"SafeGuard: sender requires permission\");\n        _;\n    }\n\n    /**\n     * @notice Sets the timelock address this safeGuard contract is gonna use\n     * @param _timelock The address of the timelock contract\n     */\n    function setTimelock(address _timelock) public justByRole(CREATOR_ROLE) {\n        require(address(timelock) == address(0), \"SafeGuard::setTimelock: Timelock address already defined\");\n        // set timelock address\n        timelock = ITimelock(_timelock);\n    }\n\n    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function queueTransactionWithDescription(address target, uint256 value, string memory signature, bytes memory data, uint256 eta, string memory description) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n        emit QueueTransactionWithDescription(txHash, target, value, signature, data, eta, description);\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public justByRole(CANCELER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _cancelTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint256 _value, string memory signature, bytes memory data, uint256 eta) public payable justByRole(EXECUTOR_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, _value, signature, data, eta));\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::executeTransaction: transaction should be queued\");\n        timelock.executeTransaction{value: _value, gas: gasleft()}(target, _value, signature, data, eta);\n    }\n\n    function _queueTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(!timelock.queuedTransactions(txHash), \"SafeGuard::queueTransaction: transaction already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function _cancelTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::cancelTransaction: transaction should be queued\");\n        timelock.cancelTransaction(target, value, signature, data, eta);\n    }\n}"
    },
    {
      "filename": "contracts/SafeGuard.sol",
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"./ITimelock.sol\";\nimport \"hardhat/console.sol\";\n\ncontract SafeGuard is AccessControlEnumerable {\n\n    // Request info event\n    event QueueTransactionWithDescription(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta, string description);\n\n    bytes32 public constant SAFEGUARD_ADMIN_ROLE = keccak256(\"SAFEGUARD_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELER_ROLE = keccak256(\"CANCELER_ROLE\");\n    bytes32 public constant CREATOR_ROLE = keccak256(\"CREATOR_ROLE\");\n\n    ///@dev The address of the Timelock\n    ITimelock public timelock;\n\n    /**\n     * @dev Initializes the contract with a given Timelock address and administrator address.\n     */\n    constructor (address _admin, bytes32[] memory roles, address[] memory rolesAssignees) {\n        require(roles.length == rolesAssignees.length, \"SafeGuard::constructor: roles assignment arity mismatch\");\n        // set roles administrator\n        _setRoleAdmin(SAFEGUARD_ADMIN_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CANCELER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CREATOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n\n        // assign roles \n        for (uint i = 0; i < roles.length; i++) {\n            _setupRole(roles[i], rolesAssignees[i]);\n        }\n\n        // set admin rol to an address\n        _setupRole(SAFEGUARD_ADMIN_ROLE, _admin);\n        _setupRole(CREATOR_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Modifier to make a function callable just by a certain role.\n     */\n    modifier justByRole(bytes32 role) {\n        require(hasRole(role, _msgSender()), \"SafeGuard: sender requires permission\");\n        _;\n    }\n\n    /**\n     * @notice Sets the timelock address this safeGuard contract is gonna use\n     * @param _timelock The address of the timelock contract\n     */\n    function setTimelock(address _timelock) public justByRole(CREATOR_ROLE) {\n        require(address(timelock) == address(0), \"SafeGuard::setTimelock: Timelock address already defined\");\n        // set timelock address\n        timelock = ITimelock(_timelock);\n    }\n\n    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function queueTransactionWithDescription(address target, uint256 value, string memory signature, bytes memory data, uint256 eta, string memory description) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n        emit QueueTransactionWithDescription(txHash, target, value, signature, data, eta, description);\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public justByRole(CANCELER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _cancelTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint256 _value, string memory signature, bytes memory data, uint256 eta) public payable justByRole(EXECUTOR_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, _value, signature, data, eta));\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::executeTransaction: transaction should be queued\");\n        timelock.executeTransaction{value: _value, gas: gasleft()}(target, _value, signature, data, eta);\n    }\n\n    function _queueTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(!timelock.queuedTransactions(txHash), \"SafeGuard::queueTransaction: transaction already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function _cancelTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::cancelTransaction: transaction should be queued\");\n        timelock.cancelTransaction(target, value, signature, data, eta);\n    }\n}"
    },
    {
      "filename": "contracts/SafeGuard.sol",
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"./ITimelock.sol\";\nimport \"hardhat/console.sol\";\n\ncontract SafeGuard is AccessControlEnumerable {\n\n    // Request info event\n    event QueueTransactionWithDescription(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta, string description);\n\n    bytes32 public constant SAFEGUARD_ADMIN_ROLE = keccak256(\"SAFEGUARD_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELER_ROLE = keccak256(\"CANCELER_ROLE\");\n    bytes32 public constant CREATOR_ROLE = keccak256(\"CREATOR_ROLE\");\n\n    ///@dev The address of the Timelock\n    ITimelock public timelock;\n\n    /**\n     * @dev Initializes the contract with a given Timelock address and administrator address.\n     */\n    constructor (address _admin, bytes32[] memory roles, address[] memory rolesAssignees) {\n        require(roles.length == rolesAssignees.length, \"SafeGuard::constructor: roles assignment arity mismatch\");\n        // set roles administrator\n        _setRoleAdmin(SAFEGUARD_ADMIN_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CANCELER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CREATOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n\n        // assign roles \n        for (uint i = 0; i < roles.length; i++) {\n            _setupRole(roles[i], rolesAssignees[i]);\n        }\n\n        // set admin rol to an address\n        _setupRole(SAFEGUARD_ADMIN_ROLE, _admin);\n        _setupRole(CREATOR_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Modifier to make a function callable just by a certain role.\n     */\n    modifier justByRole(bytes32 role) {\n        require(hasRole(role, _msgSender()), \"SafeGuard: sender requires permission\");\n        _;\n    }\n\n    /**\n     * @notice Sets the timelock address this safeGuard contract is gonna use\n     * @param _timelock The address of the timelock contract\n     */\n    function setTimelock(address _timelock) public justByRole(CREATOR_ROLE) {\n        require(address(timelock) == address(0), \"SafeGuard::setTimelock: Timelock address already defined\");\n        // set timelock address\n        timelock = ITimelock(_timelock);\n    }\n\n    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function queueTransactionWithDescription(address target, uint256 value, string memory signature, bytes memory data, uint256 eta, string memory description) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n        emit QueueTransactionWithDescription(txHash, target, value, signature, data, eta, description);\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public justByRole(CANCELER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _cancelTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint256 _value, string memory signature, bytes memory data, uint256 eta) public payable justByRole(EXECUTOR_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, _value, signature, data, eta));\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::executeTransaction: transaction should be queued\");\n        timelock.executeTransaction{value: _value, gas: gasleft()}(target, _value, signature, data, eta);\n    }\n\n    function _queueTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(!timelock.queuedTransactions(txHash), \"SafeGuard::queueTransaction: transaction already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function _cancelTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::cancelTransaction: transaction should be queued\");\n        timelock.cancelTransaction(target, value, signature, data, eta);\n    }\n}"
    }
  ]
}