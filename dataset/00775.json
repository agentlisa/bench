{
  "Title": "M-4: Malicious users could block liquidation or perform DOS",
  "Content": "# Issue M-4: Malicious users could block liquidation or perform DOS \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/22 \n\n## Found by \nbin2chen, xiaoming90\n## Summary\n\nThe current implementation uses a \"push\" approach where reward tokens are sent to the recipient during every update, which introduces additional attack surfaces that the attackers can exploit. An attacker could intentionally affect the outcome of the transfer to gain a certain advantage or carry out certain attack.\n\nThe worst-case scenario is that malicious users might exploit this trick to intentionally trigger a revert when someone attempts to liquidate their unhealthy accounts to block the liquidation, leaving the protocol with bad debts and potentially leading to insolvency if it accumulates.\n\n## Vulnerability Detail\n\nPer the [Audit Scope Documentation](https://docs.google.com/document/d/1-2iaTM8lBaurrfItOJRRveHnwKq1lEWGnewrEfXMzrI/edit) provided by the protocol team on the [contest page](https://audits.sherlock.xyz/contests/142), the reward tokens can be any arbitrary ERC20 tokens\n\n> We are extending this functionality to allow nTokens to be incentivized by a secondary reward token. On Arbitrum, this will be ARB as a result of the ARB STIP grant. In the future, this may be any arbitrary ERC20 token\n\nLine 231 of the `_claimRewards` function below might revert due to various issues such as:\n\n- tokens with blacklisting features such as USDC (users might intentionally get into the blacklist to achieve certain outcomes)\n- tokens with hook, which allow the target to revert the transaction intentionally\n- unexpected error in the token's contract\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/external/adapters/SecondaryRewarder.sol#L231\n\n```solidity\nFile: SecondaryRewarder.sol\n216:     function _claimRewards(address account, uint256 nTokenBalanceBefore, uint256 nTokenBalanceAfter) private { \n217:         uint256 rewardToClaim = _calculateRewardToClaim(account, nTokenBalanceBefore, accumulatedRewardPerNToken); \n218: \n219:         // Precision here is:\n220:         //  nTokenBalanceAfter (INTERNAL_TOKEN_PRECISION) \n221:         //  accumulatedRewardPerNToken (INCENTIVE_ACCUMULATION_PRECISION) \n222:         // DIVIDE BY\n223:         //  INTERNAL_TOKEN_PRECISION \n224:         //  => INCENTIVE_ACCUMULATION_PRECISION (1e18) \n225:         rewardDebtPerAccount[account] = nTokenBalanceAfter \n226:             .mul(accumulatedRewardPerNToken)\n227:             .div(uint256(Constants.INTERNAL_TOKEN_PRECISION))\n228:             .toUint128(); \n229: \n230:         if (0 < rewardToClaim) { \n231:             GenericToken.safeTransferOut(REWARD_TOKEN, account, rewardToClaim); \n232:             emit RewardTransfer(REWARD_TOKEN, account, rewardToClaim);\n233:         }\n234:     }\n```\n\nIf a revert occurs, the following functions are affected:\n\n```solidity\n_claimRewards -> claimRewardsDirect\n\n_claimRewards -> claimRewards -> Incentives.claimIncentives\n_claimRewards -> claimRewards -> Incentives.claimIncentives -> BalancerHandler._finalize\n_claimRewards -> claimRewards -> Incentives.claimIncentives -> BalancerHandler._finalize -> Used by many functions\n\n_claimRewards -> claimRewards -> Incentives.claimIncentives -> BalancerHandler.claimIncentivesManual\n_claimRewards -> claimRewards -> Incentives.claimIncentives -> BalancerHandler.claimIncentivesManual -> nTokenAction.nTokenClaimIncentives (External)\n_claimRewards -> claimRewards -> Incentives.claimIncentives -> BalancerHandler.claimIncentivesManual -> nTokenAction.nTokenClaimIncentives (External) -> claimNOTE (External)\n```\n\n## Impact\n\nMany of the core functionalities of the protocol will be affected by the revert. Specifically, the `BalancerHandler._finalize` has the most impact as this function is called by almost every critical functionality of the protocol, including deposit, withdrawal, and liquidation. \n\nThe worst-case scenario is that malicious users might exploit this trick to intentionally trigger a revert when someone attempts to liquidate their unhealthy accounts to block the liquidation, leaving the protocol with bad debts and potentially leading to insolvency if it accumulates.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/external/adapters/SecondaryRewarder.sol#L231\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe current implementation uses a \"push\" approach where reward tokens are sent to the recipient during every update, which introduces additional attack surfaces that the attackers can exploit.\n\nConsider adopting a pull method for users to claim their rewards instead so that the transfer of reward tokens is disconnected from the updating of reward balances.\n\n\n\n## Discussion\n\n**jeffywu**\n\nI believe this is a duplicate of another issue.\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { valid user can avoid liquidation}\n\n\n\n**jeffywu**\n\nAcknowledged this is a very minor risk in the case this prevents a liquidation. However, I think the fix here is to put a try / catch around the reward block and it results in a loss of rewards for the blacklisted account rather than changing the entire UX of the process.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "contracts-v3/contracts/external/adapters/SecondaryRewarder.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\n\nimport {GenericToken} from \"../../internal/balances/protocols/GenericToken.sol\";\nimport {IRewarder} from \"../../../interfaces/notional/IRewarder.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {FloatingPoint} from \"../../math/FloatingPoint.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\n\ncontract SecondaryRewarder is IRewarder {\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n\n    NotionalProxy public immutable NOTIONAL;\n    address public immutable override NTOKEN_ADDRESS;\n    address public immutable REWARD_TOKEN;\n    uint8 public immutable REWARD_TOKEN_DECIMALS;\n    uint16 public immutable override CURRENCY_ID;\n\n    /// @notice When a rewarder is detached, it converts to an airdrop contract using the\n    /// this merkleRoot that is set.\n    /// @dev Uses a single storage slot\n    bytes32 public merkleRoot;\n\n    /* Rest of storage variables are packed into 256 bits */\n    /// @notice When true user needs to call contract directly to claim any rewards left\n    bool public override detached;\n\n    /// @notice Marks the timestamp when incentives will end. Will always be less than block.timestamp\n    /// if detached is true.\n    uint32 public endTime;\n\n    /// @notice Last time the contract accumulated the reward\n    uint32 public override lastAccumulatedTime;\n\n    // The emission rate of REWARD_TOKEN in INTERNAL_TOKEN_PRECISION packed to uint56\n    uint56 private packedEmissionRatePerYear;\n\n    /// @notice Aggregate tokens accumulated per nToken at `lastAccumulateTime` \n    //  in INCENTIVE_ACCUMULATION_PRECISION\n    uint128 public override accumulatedRewardPerNToken;\n\n    /// @notice Reward debt per account stored in 18 decimals.\n    mapping(address => uint128) public rewardDebtPerAccount;\n\n    modifier onlyOwner() {\n        require(msg.sender == NOTIONAL.owner(), \"Only owner\");\n        _;\n    }\n\n    modifier onlyNotional() {\n        require(msg.sender == address(NOTIONAL), \"Only Notional\");\n        _;\n    }\n\n    constructor(\n        NotionalProxy notional,\n        uint16 currencyId,\n        IERC20 incentive_token,\n        uint128 _emissionRatePerYear, // in INTERNAL_TOKEN_PRECISION\n        uint32 _endTime\n    ) {\n        NOTIONAL = notional;\n        CURRENCY_ID = currencyId;\n        NTOKEN_ADDRESS = notional.nTokenAddress(currencyId);\n        REWARD_TOKEN = address(incentive_token);\n        REWARD_TOKEN_DECIMALS = IERC20(address(incentive_token)).decimals();\n\n        packedEmissionRatePerYear = FloatingPoint.packTo56Bits(_emissionRatePerYear);\n        lastAccumulatedTime = uint32(block.timestamp);\n        require(lastAccumulatedTime < _endTime, \"Invalid End Time\");\n        endTime = _endTime;\n    }\n\n    /// @notice The emission rate of REWARD_TOKEN in INTERNAL_TOKEN_PRECISION\n    function emissionRatePerYear() public view override returns(uint128) {\n        return uint128(FloatingPoint.unpackFromBits(packedEmissionRatePerYear));\n    }\n\n    /// @notice Get amount of reward account can claim at specified block time, only called before rewarder is detached\n    /// @param account address to get reward amount for\n    /// @param blockTime block time at which to get reward amount\n    function getAccountRewardClaim(address account, uint32 blockTime)\n        external\n        view\n        override\n        returns (uint256 rewardToClaim)\n    {\n        require(!detached, \"Detached\");\n        require(lastAccumulatedTime <= blockTime, \"Invalid block time\");\n\n        uint256 totalSupply = IERC20(NTOKEN_ADDRESS).totalSupply();\n        uint256 nTokenBalance = IERC20(NTOKEN_ADDRESS).balanceOf(account);\n\n        uint32 time = uint32(SafeInt256.min(blockTime, endTime));\n        uint128 rewardsPerNToken = _getAccumulatedRewardPerToken(time, totalSupply);\n        rewardToClaim = _calculateRewardToClaim(account, nTokenBalance, rewardsPerNToken);\n    }\n\n    /// @notice Get amount of reward still left for account to claim, only called after rewarder is detached\n    /// and merkle root is set\n    /// @param account address to get reward amount for\n    /// @param nTokenBalanceAtDetach nToken balance of account at time of detachment\n    /// @param proof merkle proof to prove account and nTokenBalanceAtDetach are in tree\n    function getAccountRewardClaim(address account, uint256 nTokenBalanceAtDetach, bytes32[] calldata proof)\n        external\n        view\n        override\n        returns (uint256 rewardToClaim)\n    {\n        require(detached && merkleRoot != bytes32(0), \"Not detached\");\n\n        _checkProof(account, nTokenBalanceAtDetach, proof);\n        // no need to accumulate, it was already accumulated when rewarder was detached\n        rewardToClaim = _calculateRewardToClaim(account, nTokenBalanceAtDetach, accumulatedRewardPerNToken);\n    }\n\n    /// @notice Set incentive emission rate and incentive period end time, called only in case emission\n    /// rate or incentive period changes since it is already set at deploy time, only can be called before\n    /// rewarder is detached\n    /// @param _emissionRatePerYear emission rate per year in INTERNAL_TOKEN_PRECISION\n    /// @param _endTime time in seconds when incentive period will end\n    function setIncentiveEmissionRate(uint128 _emissionRatePerYear, uint32 _endTime) external onlyOwner {\n        require(!detached, \"Detached\");\n        uint256 totalSupply = IERC20(NTOKEN_ADDRESS).totalSupply();\n\n        _accumulateRewardPerNToken(uint32(block.timestamp), totalSupply);\n\n        packedEmissionRatePerYear = FloatingPoint.packTo56Bits(_emissionRatePerYear);\n        // lastAccumulatedTime is at block.timestamp here, ensure that the end time is always\n        // further in the future.\n        require(lastAccumulatedTime < _endTime, \"Invalid End Time\");\n        endTime = _endTime;\n\n        emit RewardEmissionUpdate(FloatingPoint.unpackFromBits(packedEmissionRatePerYear), _endTime);\n    }\n\n    /// @notice Set merkle root, only called after rewarder is detached\n    /// @param _merkleRoot merkle root of the tree that contains accounts and nToken balances at detach time\n    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        require(_merkleRoot != bytes32(0), \"Invalid\");\n        merkleRoot = _merkleRoot;\n    }\n\n    /// @notice Allows owner to recover any ERC20 or ETH mistakenly sent to this contract\n    /// @param token address of the token to recover, in case of ETH pass address(0)\n    /// @param amount amount to recover\n    function recover(address token, uint256 amount) external onlyOwner {\n        if (Constants.ETH_ADDRESS == token) {\n            (bool status,) = msg.sender.call{value: amount}(\"\");\n            require(status);\n        } else {\n            IERC20(token).transfer(msg.sender, amount);\n        }\n    }\n\n    /// @dev Called from Notional system to detach rewarder when switching to a new rewarder or when incentive\n    /// period is over, after this merkle tree of user nToken balances at detach time should be generated\n    /// offline and merkle root uploaded to this contract\n    function detach() external override onlyNotional {\n        require(!detached, \"Already detached\");\n\n        // accumulate for the last time if needed\n        uint256 totalSupply = IERC20(NTOKEN_ADDRESS).totalSupply();\n        _accumulateRewardPerNToken(uint32(block.timestamp), totalSupply);\n\n        detached = true;\n        packedEmissionRatePerYear = 0;\n\n        if (block.timestamp < endTime) {\n            endTime = uint32(block.timestamp);\n        }\n\n        emit RewardEmissionUpdate(0, endTime);\n    }\n\n    /// @notice Allows claiming rewards after rewarder has been detached\n    /// @param account address to claim rewards for\n    /// @param nTokenBalanceAtDetach nToken balance of account at time of detachment\n    /// @param proof merkle proof to prove account and nTokenBalanceAtDetach are in tree\n    function claimRewardsDirect(address account, uint256 nTokenBalanceAtDetach, bytes32[] calldata proof)\n        external\n        override\n    {\n        require(detached, \"Not detached\");\n\n        _checkProof(account, nTokenBalanceAtDetach, proof);\n\n        _claimRewards(account, nTokenBalanceAtDetach, nTokenBalanceAtDetach);\n    }\n\n    /// @notice Allows claiming rewards but only from Notional system, called on each nToken balance change\n    /// @param account address to claim rewards for\n    /// @param currencyId id number of the currency\n    /// @param nTokenBalanceBefore account nToken balance before the change\n    /// @param nTokenBalanceAfter account nToken balance after the change\n    /// @param priorNTokenSupply total nToken supply before the change\n    function claimRewards(\n        address account,\n        uint16 currencyId,\n        uint256 nTokenBalanceBefore,\n        uint256 nTokenBalanceAfter,\n        uint256 priorNTokenSupply\n    ) external override onlyNotional {\n        require(!detached, \"Detached\");\n        require(currencyId == CURRENCY_ID, \"Wrong currency id\");\n\n        _accumulateRewardPerNToken(uint32(block.timestamp), priorNTokenSupply);\n        _claimRewards(account, nTokenBalanceBefore, nTokenBalanceAfter);\n    }\n\n    function _claimRewards(address account, uint256 nTokenBalanceBefore, uint256 nTokenBalanceAfter) private {\n        uint256 rewardToClaim = _calculateRewardToClaim(account, nTokenBalanceBefore, accumulatedRewardPerNToken);\n\n        // Precision here is:\n        //  nTokenBalanceAfter (INTERNAL_TOKEN_PRECISION)\n        //  accumulatedRewardPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\n        // DIVIDE BY\n        //  INTERNAL_TOKEN_PRECISION\n        //  => INCENTIVE_ACCUMULATION_PRECISION (1e18)\n        rewardDebtPerAccount[account] = nTokenBalanceAfter\n            .mul(accumulatedRewardPerNToken)\n            .div(uint256(Constants.INTERNAL_TOKEN_PRECISION))\n            .toUint128();\n\n        if (0 < rewardToClaim) {\n            GenericToken.safeTransferOut(REWARD_TOKEN, account, rewardToClaim);\n            emit RewardTransfer(REWARD_TOKEN, account, rewardToClaim);\n        }\n    }\n\n    function _getAccumulatedRewardPerToken(uint32 time, uint256 totalSupply) private view returns (uint128) {\n        uint256 additionalIncentiveAccumulatedPerNToken;\n        if (lastAccumulatedTime < time && 0 < totalSupply) {\n            // NOTE: no underflow, checked in if statement\n            uint256 timeSinceLastAccumulation = time - lastAccumulatedTime;\n            // Precision here is:\n            //  timeSinceLastAccumulation (SECONDS)\n            //  INCENTIVE_ACCUMULATION_PRECISION (1e18)\n            //  INTERNAL_TOKEN_PRECISION (1e8)\n            // DIVIDE BY\n            //  YEAR (SECONDS)\n            //  INTERNAL_TOKEN_PRECISION (1e8)\n            // => Precision = INCENTIVE_ACCUMULATION_PRECISION * INTERNAL_TOKEN_PRECISION / INTERNAL_TOKEN_PRECISION\n            // => 1e18\n            additionalIncentiveAccumulatedPerNToken = timeSinceLastAccumulation\n                .mul(Constants.INCENTIVE_ACCUMULATION_PRECISION)\n                .mul(emissionRatePerYear())\n                .div(Constants.YEAR)\n                .div(totalSupply);\n        }\n\n        return uint256(accumulatedRewardPerNToken).add(additionalIncentiveAccumulatedPerNToken).toUint128();\n    }\n\n    function _accumulateRewardPerNToken(uint32 blockTime, uint256 totalSupply) private {\n        // Ensure that end time is set to some value\n        require(0 < endTime);\n        uint32 time = uint32(SafeInt256.min(blockTime, endTime));\n\n        accumulatedRewardPerNToken = _getAccumulatedRewardPerToken(time, totalSupply);\n\n        lastAccumulatedTime = uint32(block.timestamp);\n    }\n\n    function _calculateRewardToClaim(address account, uint256 nTokenBalanceAtLastClaim, uint128 rewardsPerNToken)\n        private\n        view\n        returns (uint256)\n    {\n        // Precision here is:\n        //   nTokenBalanceAtLastClaim (INTERNAL_TOKEN_PRECISION)\n        //   mul rewardsPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\n        //   div INTERNAL_TOKEN_PRECISION\n        // => INCENTIVE_ACCUMULATION_PRECISION\n        // SUB rewardDebtPerAccount (INCENTIVE_ACCUMULATION_PRECISION)\n        //\n        // - mul REWARD_TOKEN_DECIMALS\n        // - div INCENTIVE_ACCUMULATION_PRECISION\n        // => REWARD_TOKEN_DECIMALS\n        return uint256(nTokenBalanceAtLastClaim)\n            .mul(rewardsPerNToken)\n            .div(uint256(Constants.INTERNAL_TOKEN_PRECISION))\n            .sub(rewardDebtPerAccount[account])\n            .mul(10 ** REWARD_TOKEN_DECIMALS)\n            .div(Constants.INCENTIVE_ACCUMULATION_PRECISION);\n    }\n\n    /// @notice Verify merkle proof, or revert if not in tree\n    function _checkProof(address account, uint256 balance, bytes32[] calldata proof) private view {\n        // Verify merkle proof, or revert if not in tree\n        bytes32 leaf = keccak256(abi.encodePacked(account, balance));\n        bool isValidLeaf = MerkleProof.verify(proof, merkleRoot, leaf);\n        require(isValidLeaf, \"NotInMerkle\");\n    }\n}"
    },
    {
      "filename": "contracts-v3/contracts/external/adapters/SecondaryRewarder.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\n\nimport {GenericToken} from \"../../internal/balances/protocols/GenericToken.sol\";\nimport {IRewarder} from \"../../../interfaces/notional/IRewarder.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {FloatingPoint} from \"../../math/FloatingPoint.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\n\ncontract SecondaryRewarder is IRewarder {\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n\n    NotionalProxy public immutable NOTIONAL;\n    address public immutable override NTOKEN_ADDRESS;\n    address public immutable REWARD_TOKEN;\n    uint8 public immutable REWARD_TOKEN_DECIMALS;\n    uint16 public immutable override CURRENCY_ID;\n\n    /// @notice When a rewarder is detached, it converts to an airdrop contract using the\n    /// this merkleRoot that is set.\n    /// @dev Uses a single storage slot\n    bytes32 public merkleRoot;\n\n    /* Rest of storage variables are packed into 256 bits */\n    /// @notice When true user needs to call contract directly to claim any rewards left\n    bool public override detached;\n\n    /// @notice Marks the timestamp when incentives will end. Will always be less than block.timestamp\n    /// if detached is true.\n    uint32 public endTime;\n\n    /// @notice Last time the contract accumulated the reward\n    uint32 public override lastAccumulatedTime;\n\n    // The emission rate of REWARD_TOKEN in INTERNAL_TOKEN_PRECISION packed to uint56\n    uint56 private packedEmissionRatePerYear;\n\n    /// @notice Aggregate tokens accumulated per nToken at `lastAccumulateTime` \n    //  in INCENTIVE_ACCUMULATION_PRECISION\n    uint128 public override accumulatedRewardPerNToken;\n\n    /// @notice Reward debt per account stored in 18 decimals.\n    mapping(address => uint128) public rewardDebtPerAccount;\n\n    modifier onlyOwner() {\n        require(msg.sender == NOTIONAL.owner(), \"Only owner\");\n        _;\n    }\n\n    modifier onlyNotional() {\n        require(msg.sender == address(NOTIONAL), \"Only Notional\");\n        _;\n    }\n\n    constructor(\n        NotionalProxy notional,\n        uint16 currencyId,\n        IERC20 incentive_token,\n        uint128 _emissionRatePerYear, // in INTERNAL_TOKEN_PRECISION\n        uint32 _endTime\n    ) {\n        NOTIONAL = notional;\n        CURRENCY_ID = currencyId;\n        NTOKEN_ADDRESS = notional.nTokenAddress(currencyId);\n        REWARD_TOKEN = address(incentive_token);\n        REWARD_TOKEN_DECIMALS = IERC20(address(incentive_token)).decimals();\n\n        packedEmissionRatePerYear = FloatingPoint.packTo56Bits(_emissionRatePerYear);\n        lastAccumulatedTime = uint32(block.timestamp);\n        require(lastAccumulatedTime < _endTime, \"Invalid End Time\");\n        endTime = _endTime;\n    }\n\n    /// @notice The emission rate of REWARD_TOKEN in INTERNAL_TOKEN_PRECISION\n    function emissionRatePerYear() public view override returns(uint128) {\n        return uint128(FloatingPoint.unpackFromBits(packedEmissionRatePerYear));\n    }\n\n    /// @notice Get amount of reward account can claim at specified block time, only called before rewarder is detached\n    /// @param account address to get reward amount for\n    /// @param blockTime block time at which to get reward amount\n    function getAccountRewardClaim(address account, uint32 blockTime)\n        external\n        view\n        override\n        returns (uint256 rewardToClaim)\n    {\n        require(!detached, \"Detached\");\n        require(lastAccumulatedTime <= blockTime, \"Invalid block time\");\n\n        uint256 totalSupply = IERC20(NTOKEN_ADDRESS).totalSupply();\n        uint256 nTokenBalance = IERC20(NTOKEN_ADDRESS).balanceOf(account);\n\n        uint32 time = uint32(SafeInt256.min(blockTime, endTime));\n        uint128 rewardsPerNToken = _getAccumulatedRewardPerToken(time, totalSupply);\n        rewardToClaim = _calculateRewardToClaim(account, nTokenBalance, rewardsPerNToken);\n    }\n\n    /// @notice Get amount of reward still left for account to claim, only called after rewarder is detached\n    /// and merkle root is set\n    /// @param account address to get reward amount for\n    /// @param nTokenBalanceAtDetach nToken balance of account at time of detachment\n    /// @param proof merkle proof to prove account and nTokenBalanceAtDetach are in tree\n    function getAccountRewardClaim(address account, uint256 nTokenBalanceAtDetach, bytes32[] calldata proof)\n        external\n        view\n        override\n        returns (uint256 rewardToClaim)\n    {\n        require(detached && merkleRoot != bytes32(0), \"Not detached\");\n\n        _checkProof(account, nTokenBalanceAtDetach, proof);\n        // no need to accumulate, it was already accumulated when rewarder was detached\n        rewardToClaim = _calculateRewardToClaim(account, nTokenBalanceAtDetach, accumulatedRewardPerNToken);\n    }\n\n    /// @notice Set incentive emission rate and incentive period end time, called only in case emission\n    /// rate or incentive period changes since it is already set at deploy time, only can be called before\n    /// rewarder is detached\n    /// @param _emissionRatePerYear emission rate per year in INTERNAL_TOKEN_PRECISION\n    /// @param _endTime time in seconds when incentive period will end\n    function setIncentiveEmissionRate(uint128 _emissionRatePerYear, uint32 _endTime) external onlyOwner {\n        require(!detached, \"Detached\");\n        uint256 totalSupply = IERC20(NTOKEN_ADDRESS).totalSupply();\n\n        _accumulateRewardPerNToken(uint32(block.timestamp), totalSupply);\n\n        packedEmissionRatePerYear = FloatingPoint.packTo56Bits(_emissionRatePerYear);\n        // lastAccumulatedTime is at block.timestamp here, ensure that the end time is always\n        // further in the future.\n        require(lastAccumulatedTime < _endTime, \"Invalid End Time\");\n        endTime = _endTime;\n\n        emit RewardEmissionUpdate(FloatingPoint.unpackFromBits(packedEmissionRatePerYear), _endTime);\n    }\n\n    /// @notice Set merkle root, only called after rewarder is detached\n    /// @param _merkleRoot merkle root of the tree that contains accounts and nToken balances at detach time\n    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        require(_merkleRoot != bytes32(0), \"Invalid\");\n        merkleRoot = _merkleRoot;\n    }\n\n    /// @notice Allows owner to recover any ERC20 or ETH mistakenly sent to this contract\n    /// @param token address of the token to recover, in case of ETH pass address(0)\n    /// @param amount amount to recover\n    function recover(address token, uint256 amount) external onlyOwner {\n        if (Constants.ETH_ADDRESS == token) {\n            (bool status,) = msg.sender.call{value: amount}(\"\");\n            require(status);\n        } else {\n            IERC20(token).transfer(msg.sender, amount);\n        }\n    }\n\n    /// @dev Called from Notional system to detach rewarder when switching to a new rewarder or when incentive\n    /// period is over, after this merkle tree of user nToken balances at detach time should be generated\n    /// offline and merkle root uploaded to this contract\n    function detach() external override onlyNotional {\n        require(!detached, \"Already detached\");\n\n        // accumulate for the last time if needed\n        uint256 totalSupply = IERC20(NTOKEN_ADDRESS).totalSupply();\n        _accumulateRewardPerNToken(uint32(block.timestamp), totalSupply);\n\n        detached = true;\n        packedEmissionRatePerYear = 0;\n\n        if (block.timestamp < endTime) {\n            endTime = uint32(block.timestamp);\n        }\n\n        emit RewardEmissionUpdate(0, endTime);\n    }\n\n    /// @notice Allows claiming rewards after rewarder has been detached\n    /// @param account address to claim rewards for\n    /// @param nTokenBalanceAtDetach nToken balance of account at time of detachment\n    /// @param proof merkle proof to prove account and nTokenBalanceAtDetach are in tree\n    function claimRewardsDirect(address account, uint256 nTokenBalanceAtDetach, bytes32[] calldata proof)\n        external\n        override\n    {\n        require(detached, \"Not detached\");\n\n        _checkProof(account, nTokenBalanceAtDetach, proof);\n\n        _claimRewards(account, nTokenBalanceAtDetach, nTokenBalanceAtDetach);\n    }\n\n    /// @notice Allows claiming rewards but only from Notional system, called on each nToken balance change\n    /// @param account address to claim rewards for\n    /// @param currencyId id number of the currency\n    /// @param nTokenBalanceBefore account nToken balance before the change\n    /// @param nTokenBalanceAfter account nToken balance after the change\n    /// @param priorNTokenSupply total nToken supply before the change\n    function claimRewards(\n        address account,\n        uint16 currencyId,\n        uint256 nTokenBalanceBefore,\n        uint256 nTokenBalanceAfter,\n        uint256 priorNTokenSupply\n    ) external override onlyNotional {\n        require(!detached, \"Detached\");\n        require(currencyId == CURRENCY_ID, \"Wrong currency id\");\n\n        _accumulateRewardPerNToken(uint32(block.timestamp), priorNTokenSupply);\n        _claimRewards(account, nTokenBalanceBefore, nTokenBalanceAfter);\n    }\n\n    function _claimRewards(address account, uint256 nTokenBalanceBefore, uint256 nTokenBalanceAfter) private {\n        uint256 rewardToClaim = _calculateRewardToClaim(account, nTokenBalanceBefore, accumulatedRewardPerNToken);\n\n        // Precision here is:\n        //  nTokenBalanceAfter (INTERNAL_TOKEN_PRECISION)\n        //  accumulatedRewardPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\n        // DIVIDE BY\n        //  INTERNAL_TOKEN_PRECISION\n        //  => INCENTIVE_ACCUMULATION_PRECISION (1e18)\n        rewardDebtPerAccount[account] = nTokenBalanceAfter\n            .mul(accumulatedRewardPerNToken)\n            .div(uint256(Constants.INTERNAL_TOKEN_PRECISION))\n            .toUint128();\n\n        if (0 < rewardToClaim) {\n            GenericToken.safeTransferOut(REWARD_TOKEN, account, rewardToClaim);\n            emit RewardTransfer(REWARD_TOKEN, account, rewardToClaim);\n        }\n    }\n\n    function _getAccumulatedRewardPerToken(uint32 time, uint256 totalSupply) private view returns (uint128) {\n        uint256 additionalIncentiveAccumulatedPerNToken;\n        if (lastAccumulatedTime < time && 0 < totalSupply) {\n            // NOTE: no underflow, checked in if statement\n            uint256 timeSinceLastAccumulation = time - lastAccumulatedTime;\n            // Precision here is:\n            //  timeSinceLastAccumulation (SECONDS)\n            //  INCENTIVE_ACCUMULATION_PRECISION (1e18)\n            //  INTERNAL_TOKEN_PRECISION (1e8)\n            // DIVIDE BY\n            //  YEAR (SECONDS)\n            //  INTERNAL_TOKEN_PRECISION (1e8)\n            // => Precision = INCENTIVE_ACCUMULATION_PRECISION * INTERNAL_TOKEN_PRECISION / INTERNAL_TOKEN_PRECISION\n            // => 1e18\n            additionalIncentiveAccumulatedPerNToken = timeSinceLastAccumulation\n                .mul(Constants.INCENTIVE_ACCUMULATION_PRECISION)\n                .mul(emissionRatePerYear())\n                .div(Constants.YEAR)\n                .div(totalSupply);\n        }\n\n        return uint256(accumulatedRewardPerNToken).add(additionalIncentiveAccumulatedPerNToken).toUint128();\n    }\n\n    function _accumulateRewardPerNToken(uint32 blockTime, uint256 totalSupply) private {\n        // Ensure that end time is set to some value\n        require(0 < endTime);\n        uint32 time = uint32(SafeInt256.min(blockTime, endTime));\n\n        accumulatedRewardPerNToken = _getAccumulatedRewardPerToken(time, totalSupply);\n\n        lastAccumulatedTime = uint32(block.timestamp);\n    }\n\n    function _calculateRewardToClaim(address account, uint256 nTokenBalanceAtLastClaim, uint128 rewardsPerNToken)\n        private\n        view\n        returns (uint256)\n    {\n        // Precision here is:\n        //   nTokenBalanceAtLastClaim (INTERNAL_TOKEN_PRECISION)\n        //   mul rewardsPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\n        //   div INTERNAL_TOKEN_PRECISION\n        // => INCENTIVE_ACCUMULATION_PRECISION\n        // SUB rewardDebtPerAccount (INCENTIVE_ACCUMULATION_PRECISION)\n        //\n        // - mul REWARD_TOKEN_DECIMALS\n        // - div INCENTIVE_ACCUMULATION_PRECISION\n        // => REWARD_TOKEN_DECIMALS\n        return uint256(nTokenBalanceAtLastClaim)\n            .mul(rewardsPerNToken)\n            .div(uint256(Constants.INTERNAL_TOKEN_PRECISION))\n            .sub(rewardDebtPerAccount[account])\n            .mul(10 ** REWARD_TOKEN_DECIMALS)\n            .div(Constants.INCENTIVE_ACCUMULATION_PRECISION);\n    }\n\n    /// @notice Verify merkle proof, or revert if not in tree\n    function _checkProof(address account, uint256 balance, bytes32[] calldata proof) private view {\n        // Verify merkle proof, or revert if not in tree\n        bytes32 leaf = keccak256(abi.encodePacked(account, balance));\n        bool isValidLeaf = MerkleProof.verify(proof, merkleRoot, leaf);\n        require(isValidLeaf, \"NotInMerkle\");\n    }\n}"
    }
  ]
}