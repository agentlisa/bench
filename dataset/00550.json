{
  "Title": "`NodeOperatorRegistry::updateOperatorControllingAddress` allows to override `_newOperatorAddress` if its address is already assigned to an operator ID",
  "Content": "**Description:** Current implementation does not check if the new assigned address has already been assigned to an operator ID. As a consequence, its current value can be over written in mapping `getOperatorIdForAddress`, and `getOperatorForOperatorId` will have 2 operator IDs pointing to the same operator.\n\nThe direct consequences of this are on `_getOperatorSafe` and `_getOperatorIdSafe`, which will only return data for the new assigned operator ID.\n\nTherefore:\n* `NodeOperatorRegistry::getOperatorsPendingValidatorDetails` won't be able to return old `_newOperatorAddress` associated validators details\n* `NodeOperatorRegistry::getOperatorsActiveValidatorDetails` won't be able to return old `_newOperatorAddress` associated active validators details\n* `enableOperator` won't be able to enable old operator record\n* **__`disableOperator` won't be able to disable old operator record__**.  This can affect function `usePubKeysForValidatorSetup` given that the protocol won't be able to disable already enabled public key to be used for validator setup given that there is no way to modify previous `getOperatorForOperatorId[_newOperatorAddress].enabled` storage and [force the function to revert](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/NodeOperatorRegistry.sol#L194-L196). Given that the only one allowed to call the function is the BOT by previously calling `DepositManager::setupValidators` the impact is limited.\n* `updateOperatorRewardAddress` won't be able to modify reward address from old operator record\n* `updateOperatorName` won't be able to modify name from old operator record\n\nThis issue has not been introduced in the new changes but is in the mainnet [code](https://github.com/SwellNetwork/v3-core-public/blob/master/contracts/lst/contracts/implementations/NodeOperatorRegistry.sol#L348-L364).\n\n**Proof Of Concept:**\nAdd the following test to `updateOperatorFields.test.ts`:\n```typescript\n    it(\"Should revert updating operator controlling address to existing address\", async () => {\n      // create another operator\n      await NodeOperatorRegistry_Deployer.addOperator(\n        \"OPERATOR_2\",\n        NewOperator.address,\n        NewOperator.address\n      );\n\n      // attempt to update first operator's controlling address to be\n      // the same as the newly created operator - should revert but doesn't\n      await NodeOperatorRegistry_Deployer.updateOperatorControllingAddress(\n        Operator.address,\n        NewOperator.address\n      );\n    });\n```\n\n**Recommended mitigation:**\nCheck that `_newOperatorAddress` is not already assigned to an operator (similar to `addOperator` which [already does this](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/NodeOperatorRegistry.sol#L300-L302), may wish to create a new private or public function for code reuse):\n```diff\n  function updateOperatorControllingAddress(\n    address _operatorAddress,\n    address _newOperatorAddress\n  )\n    external\n    override\n    checkRole(SwellLib.PLATFORM_ADMIN)\n    checkZeroAddress(_newOperatorAddress)\n  {\n\n    if (_operatorAddress == _newOperatorAddress) {\n        revert CannotSetOperatorControllingAddressToSameAddress();\n    }\n+   if(getOperatorIdForAddress[_newOperatorAddress] != 0){\n+       revert CannotUpdateOperatorControllingAddressToAlreadyAssignedAddress();\n+   }\n\n    uint128 operatorId = _getOperatorIdSafe(_operatorAddress);\n\n    getOperatorIdForAddress[_newOperatorAddress] = operatorId;\n    getOperatorForOperatorId[operatorId]\n      .controllingAddress = _newOperatorAddress;\n\n    delete getOperatorIdForAddress[_operatorAddress];\n  }\n```\n\n**Swell:** Fixed in commit [55c7d5f](https://github.com/SwellNetwork/v3-contracts-lst/commit/55c7d5fba6d55c68558dcd15de016927e07e38fd).\n\n**Cyfrin:**\nVerified.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/lst/contracts/implementations/NodeOperatorRegistry.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {EnumerableSetUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IAccessControlManager} from \"../interfaces/IAccessControlManager.sol\";\nimport {INodeOperatorRegistry} from \"../interfaces/INodeOperatorRegistry.sol\";\n\nimport {SwellLib} from \"../libraries/SwellLib.sol\";\nimport {EnumberableSetValidatorDetails} from \"../libraries/EnumberableSetValidatorDetails.sol\";\n\n/**\n * @title NodeOperatorRegistry\n * @author https://github.com/max-taylor\n * @notice This contract will hold all the node operators and any associated validator details. This contract will be used when fetching the next validators to setup and allows management of node operators.\n */\ncontract NodeOperatorRegistry is INodeOperatorRegistry, Initializable {\n  using SafeERC20 for IERC20;\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\n  using EnumberableSetValidatorDetails for EnumberableSetValidatorDetails.ValidatorDetailsSet;\n\n  IAccessControlManager public AccessControlManager;\n\n  // ** Operators **\n\n  // Incrementing count of node operators\n  uint128 public override numOperators;\n\n  // Using a mapping of operatorId's to operators to allow for cheap fetching when we need to iterate over the operators\n  mapping(uint128 => Operator) public getOperatorForOperatorId;\n\n  // Returns operatorId for the controlling address\n  mapping(address => uint128) public override getOperatorIdForAddress;\n\n  // ** Validator details **\n\n  // Maps the operatorId to their validator details, this set allows for cheap removal from the array when needed. This set contains all the validator details to an operator, the set is divided into active and pending validators based on the activeValidators count stored in the Operator struct. From index 0 -> activeValidators count are active and the remaining are pending.\n  mapping(uint128 => EnumberableSetValidatorDetails.ValidatorDetailsSet) operatorIdToValidatorDetails;\n\n  uint256 public override numPendingValidators;\n\n  // The active validator indexes are a bytes32 object containing 2 uint128's. They are encoded together to reduce storage costs. The first uint128 is the operator's ID and the second is the index of the key in their operatorIdToValidatorDetails array\n  EnumerableSetUpgradeable.Bytes32Set activeValidatorIndexes;\n\n  // Allows efficient access to an operator Id based on a validator public key\n  mapping(bytes => uint128) public override getOperatorIdForPubKey;\n\n  // The available HEX symbols, used in converting the public key in bytes to string\n  bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n  uint256 private constant SYMBOL_LENGTH = 16; // Because _SYMBOLS.length = 16\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  modifier checkRole(bytes32 role) {\n    AccessControlManager.checkRole(role, msg.sender);\n\n    _;\n  }\n\n  /**\n   * @dev Modifier to check for empty addresses\n   * @param _address The address to check\n   */\n  modifier checkZeroAddress(address _address) {\n    SwellLib._checkZeroAddress(_address);\n\n    _;\n  }\n\n  fallback() external {\n    revert SwellLib.InvalidMethodCall();\n  }\n\n  function initialize(\n    IAccessControlManager _accessControlManager\n  ) external initializer checkZeroAddress(address(_accessControlManager)) {\n    AccessControlManager = _accessControlManager;\n  }\n\n  // ************************************\n  // ***** External methods ******\n\n  function withdrawERC20(\n    IERC20 _token\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n    uint256 contractBalance = _token.balanceOf(address(this));\n    if (contractBalance == 0) {\n      revert SwellLib.NoTokensToWithdraw();\n    }\n\n    _token.safeTransfer(msg.sender, contractBalance);\n  }\n\n  function getNextValidatorDetails(\n    uint256 _numNewValidators\n  )\n    external\n    view\n    override\n    returns (\n      ValidatorDetails[] memory validatorDetails,\n      uint256 foundValidators\n    )\n  {\n    validatorDetails = new ValidatorDetails[](_numNewValidators);\n\n    uint256 cacheNumOperators = numOperators;\n\n    // Cache the amount of validator details operators have assigned in this method, this prevents accidentally only assigning from the operator with the least active validators\n    uint128[] memory operatorAssignedDetails = new uint128[](\n      cacheNumOperators + 1\n    );\n\n    uint128 smallestOperatorActiveKeys;\n\n    for (foundValidators; foundValidators < _numNewValidators; ) {\n      uint128 foundOperatorId;\n\n      // Iterate over each operator and find the operator with the least amount of active keys, starting from the first operator\n      // Not using an unchecked loop here because it will require a fair amount of logic for it to work with the continue statements\n      for (\n        uint128 operatorId = 1;\n        operatorId <= cacheNumOperators;\n        ++operatorId\n      ) {\n        // If the operator is disabled, skip\n        if (!getOperatorForOperatorId[operatorId].enabled) {\n          continue;\n        }\n\n        // The operator's active keys is the amount of active validator details + the validator details the operator has assigned in this method\n        uint128 operatorActiveKeys = getOperatorForOperatorId[operatorId]\n          .activeValidators + operatorAssignedDetails[operatorId];\n\n        if (\n          operatorIdToValidatorDetails[operatorId].length() ==\n          operatorActiveKeys\n        ) {\n          continue;\n        }\n\n        // Early find if the given operator has no active keys and hasn't had validator details selected yet\n        if (\n          operatorActiveKeys == 0 && operatorAssignedDetails[operatorId] == 0\n        ) {\n          foundOperatorId = operatorId;\n\n          smallestOperatorActiveKeys = 0;\n\n          break;\n        } else if (\n          foundOperatorId == 0 ||\n          smallestOperatorActiveKeys > operatorActiveKeys\n        ) {\n          // If no operator has been found yet set the smallest operator active keys to the current operator, or if the current operator has less keys than the smallest operator active keys, then we want to use this operator\n          smallestOperatorActiveKeys = operatorActiveKeys;\n\n          foundOperatorId = operatorId;\n        }\n      }\n\n      // If an operator was found in the loop\n      if (foundOperatorId != 0) {\n        // If there was an operator found, get an un-assigned public key and add it to the return array\n        validatorDetails[foundValidators] = operatorIdToValidatorDetails[\n          foundOperatorId\n        ].at(smallestOperatorActiveKeys);\n\n        operatorAssignedDetails[foundOperatorId] += 1;\n\n        foundOperatorId = 0;\n      } else {\n        // If no eligible operator's are found exit the loop and return what exists of the array\n        break;\n      }\n\n      unchecked {\n        ++foundValidators;\n      }\n    }\n  }\n\n  function usePubKeysForValidatorSetup(\n    bytes[] calldata _pubKeys\n  ) external override returns (ValidatorDetails[] memory validatorDetails) {\n    if (msg.sender != address(AccessControlManager.DepositManager())) {\n      revert InvalidPubKeySetupCaller();\n    }\n\n    uint256 pubKeyLength = _pubKeys.length;\n\n    validatorDetails = new ValidatorDetails[](pubKeyLength);\n\n    for (uint256 i; i < pubKeyLength; ) {\n      uint128 operatorId = _getOperatorIdForPubKeySafe(_pubKeys[i]);\n\n      if (!getOperatorForOperatorId[operatorId].enabled) {\n        revert CannotUseDisabledOperator();\n      }\n\n      uint128 nextKeyIndex = getOperatorForOperatorId[operatorId]\n        .activeValidators;\n\n      if (nextKeyIndex == operatorIdToValidatorDetails[operatorId].length()) {\n        revert OperatorOutOfPendingKeys();\n      }\n\n      ValidatorDetails\n        memory deletedValidatorDetails = operatorIdToValidatorDetails[\n          operatorId\n        ].at(nextKeyIndex);\n\n      if (keccak256(deletedValidatorDetails.pubKey) != keccak256(_pubKeys[i])) {\n        revert NextOperatorPubKeyMismatch(\n          deletedValidatorDetails.pubKey,\n          _pubKeys[i]\n        );\n      }\n\n      getOperatorForOperatorId[operatorId].activeValidators += 1;\n\n      validatorDetails[i] = deletedValidatorDetails;\n\n      // Encode the operatorId and the key together so we can just store the single value\n      bytes32 encoded = _encodeOperatorIdAndKeyIndex(operatorId, nextKeyIndex);\n\n      activeValidatorIndexes.add(encoded);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    numPendingValidators -= pubKeyLength;\n\n    emit PubKeysUsedForValidatorSetup(_pubKeys);\n\n    return validatorDetails;\n  }\n\n  // ** Operator management methods **\n\n  function addNewValidatorDetails(\n    ValidatorDetails[] calldata _validatorDetails\n  ) external override {\n    if (AccessControlManager.operatorMethodsPaused()) {\n      revert SwellLib.OperatorMethodsPaused();\n    }\n\n    uint256 validatorDetailsLength = _validatorDetails.length;\n\n    if (validatorDetailsLength == 0) {\n      revert InvalidArrayLengthOfZero();\n    }\n\n    uint128 operatorId = _getOperatorIdSafe(msg.sender);\n\n    if (!getOperatorForOperatorId[operatorId].enabled) {\n      revert CannotUseDisabledOperator();\n    }\n\n    // Enforcing the limit on validator details to uint128 here\n    // ! I was unable to figure out a way to test this condition, javascript cannot handle an array this size and the array size it can handle requires that the method be called 1000s of times\n    if (\n      operatorIdToValidatorDetails[operatorId].length() +\n        validatorDetailsLength >\n      type(uint128).max\n    ) {\n      revert AmountOfValidatorDetailsExceedsLimit();\n    }\n\n    for (uint128 i; i < validatorDetailsLength; ) {\n      // NOTE that no signature verification is conducted when validator details are added, this will instead be done via an off-chain service when new validators are getting setup\n      if (_validatorDetails[i].pubKey.length != 48) {\n        revert InvalidPubKeyLength();\n      }\n\n      if (_validatorDetails[i].signature.length != 96) {\n        revert InvalidSignatureLength();\n      }\n\n      if (getOperatorIdForPubKey[_validatorDetails[i].pubKey] != 0) {\n        revert CannotAddDuplicatePubKey(_validatorDetails[i].pubKey);\n      }\n\n      operatorIdToValidatorDetails[operatorId].add(_validatorDetails[i]);\n\n      getOperatorIdForPubKey[_validatorDetails[i].pubKey] = operatorId;\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    numPendingValidators += validatorDetailsLength;\n\n    emit OperatorAddedValidatorDetails(msg.sender, _validatorDetails);\n  }\n\n  // ** PLATFORM_ADMIN management methods **\n\n  function addOperator(\n    string calldata _name,\n    address _operatorAddress,\n    address _rewardAddress\n  )\n    external\n    override\n    checkRole(SwellLib.PLATFORM_ADMIN)\n    checkZeroAddress(_operatorAddress)\n    checkZeroAddress(_rewardAddress)\n  {\n    if (getOperatorIdForAddress[_operatorAddress] != 0) {\n      revert OperatorAlreadyExists(_operatorAddress);\n    }\n\n    // Increment numOperators before the assignment, so that the operatorIds start from 1\n    uint128 updatedNumOperators = ++numOperators;\n\n    getOperatorIdForAddress[_operatorAddress] = updatedNumOperators;\n    getOperatorForOperatorId[updatedNumOperators] = Operator(\n      true,\n      _rewardAddress,\n      _operatorAddress,\n      _name,\n      0\n    );\n\n    emit OperatorAdded(_operatorAddress, _rewardAddress);\n  }\n\n  function enableOperator(\n    address _operatorAddress\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n    Operator storage operator = _getOperatorSafe(_operatorAddress);\n\n    if (operator.enabled) {\n      revert OperatorAlreadyEnabled();\n    }\n\n    operator.enabled = true;\n\n    emit OperatorEnabled(_operatorAddress);\n  }\n\n  function disableOperator(\n    address _operatorAddress\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n    Operator storage operator = _getOperatorSafe(_operatorAddress);\n\n    if (!operator.enabled) {\n      revert OperatorAlreadyDisabled();\n    }\n\n    operator.enabled = false;\n\n    emit OperatorDisabled(_operatorAddress);\n  }\n\n  function updateOperatorControllingAddress(\n    address _operatorAddress,\n    address _newOperatorAddress\n  )\n    external\n    override\n    checkRole(SwellLib.PLATFORM_ADMIN)\n    checkZeroAddress(_newOperatorAddress)\n  {\n    if (_operatorAddress == _newOperatorAddress) {\n      revert CannotSetOperatorControllingAddressToSameAddress();\n    }\n\n    if (getOperatorIdForAddress[_newOperatorAddress] != 0) {\n      revert CannotUpdateOperatorControllingAddressToAlreadyAssignedAddress();\n    }\n\n    uint128 operatorId = _getOperatorIdSafe(_operatorAddress);\n\n    getOperatorIdForAddress[_newOperatorAddress] = operatorId;\n    getOperatorForOperatorId[operatorId]\n      .controllingAddress = _newOperatorAddress;\n\n    delete getOperatorIdForAddress[_operatorAddress];\n\n    emit OperatorControllingAddressUpdated(\n      _operatorAddress,\n      _newOperatorAddress\n    );\n  }\n\n  function updateOperatorRewardAddress(\n    address _operatorAddress,\n    address _newRewardAddress\n  )\n    external\n    override\n    checkRole(SwellLib.PLATFORM_ADMIN)\n    checkZeroAddress(_newRewardAddress)\n  {\n    Operator storage operator = _getOperatorSafe(_operatorAddress);\n\n    address oldRewardAddress = operator.rewardAddress;\n\n    operator.rewardAddress = _newRewardAddress;\n\n    emit OperatorRewardAddressUpdated(\n      _operatorAddress,\n      _newRewardAddress,\n      oldRewardAddress\n    );\n  }\n\n  function updateOperatorName(\n    address _operatorAddress,\n    string calldata _name\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n    Operator storage operator = _getOperatorSafe(_operatorAddress);\n\n    string memory oldName = operator.name;\n\n    operator.name = _name;\n\n    emit OperatorNameUpdated(_operatorAddress, _name, oldName);\n  }\n\n  function deletePendingValidators(\n    bytes[] calldata _pubKeys\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n    uint256 pubKeysLength = _pubKeys.length;\n\n    for (uint128 i; i < pubKeysLength; ) {\n      uint128 operatorId = _getOperatorIdForPubKeySafe(_pubKeys[i]);\n\n      uint128 operatorActiveValidators = getOperatorForOperatorId[operatorId]\n        .activeValidators;\n\n      bool removed = operatorIdToValidatorDetails[operatorId]\n        .removePendingDetails(_pubKeys[i], operatorActiveValidators);\n\n      if (!removed) {\n        revert MissingPendingValidatorDetails(_pubKeys[i]);\n      }\n\n      delete getOperatorIdForPubKey[_pubKeys[i]];\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    numPendingValidators -= pubKeysLength;\n\n    emit PendingPubKeysDeleted(_pubKeys);\n  }\n\n  function deleteActiveValidators(bytes[] calldata _pubKeys) external override {\n    if (\n      !AccessControlManager.hasRole(SwellLib.PLATFORM_ADMIN, msg.sender) &&\n      !AccessControlManager.hasRole(\n        SwellLib.DELETE_ACTIVE_VALIDATORS,\n        msg.sender\n      )\n    ) {\n      revert InvalidCallerToDeleteActiveValidators();\n    }\n\n    uint256 pubKeysLength = _pubKeys.length;\n\n    for (uint256 i; i < pubKeysLength; ) {\n      uint128 operatorId = _getOperatorIdForPubKeySafe(_pubKeys[i]);\n\n      uint128 operatorActiveValidators = getOperatorForOperatorId[operatorId]\n        .activeValidators;\n\n      if (operatorActiveValidators == 0) {\n        revert MissingActiveValidatorDetails(_pubKeys[i]);\n      }\n\n      // Recreate the encoded value so it can be deleted, for this we use the last active validator index they have\n      bytes32 encodedValue = _encodeOperatorIdAndKeyIndex(\n        operatorId,\n        operatorActiveValidators - 1\n      );\n\n      bool activeValidatorIndexRemoved = activeValidatorIndexes.remove(\n        encodedValue\n      );\n\n      bool operatorIdRemoved = operatorIdToValidatorDetails[operatorId]\n        .removeActiveDetails(_pubKeys[i], operatorActiveValidators);\n\n      if (!operatorIdRemoved || !activeValidatorIndexRemoved) {\n        revert MissingActiveValidatorDetails(_pubKeys[i]);\n      }\n\n      getOperatorForOperatorId[operatorId].activeValidators -= 1;\n\n      delete getOperatorIdForPubKey[_pubKeys[i]];\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    emit ActivePubKeysDeleted(_pubKeys);\n  }\n\n  // ***** PoR Methods *****\n\n  function getPoRAddressListLength() external view override returns (uint256) {\n    return activeValidatorIndexes.length();\n  }\n\n  /**\n   * @dev This method parses a pure bytes array into it's string equivalent. We must loop through the pubKey to safely convert each byte into its string equivalent, if we cast it directly it causes the response to be corrupted\n   * @param pubKey The pubKey to parse\n   * @return The string equivalent\n   */\n  function _parsePubKeyToString(\n    bytes memory pubKey\n  ) internal pure returns (string memory) {\n    // Create the bytes that will hold the converted string\n    // make sure that pubKey.length * 2 <= 2^256\n    uint256 pubKeyLength = pubKey.length;\n    bytes memory buffer = new bytes(pubKeyLength << 1);\n\n    uint256 index;\n    for (uint256 i; i < pubKeyLength; ) {\n      index = i << 1; // i * 2\n      buffer[index] = _SYMBOLS[uint8(pubKey[i]) >> 4]; // SYMBOL_LENGTH = 2^4\n      buffer[index + 1] = _SYMBOLS[uint8(pubKey[i]) % SYMBOL_LENGTH];\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    return string(abi.encodePacked(\"0x\", buffer));\n  }\n\n  function getPoRAddressList(\n    uint256 _startIndex,\n    uint256 _endIndex\n  ) external view override returns (string[] memory) {\n    uint256 activeValidatorLength = activeValidatorIndexes.length();\n\n    if (_endIndex < _startIndex || activeValidatorLength == 0) {\n      return new string[](0);\n    }\n\n    uint256 activeValidatorsEndIndex = activeValidatorLength - 1;\n\n    // If specifying a startIndex that is greater than the length, return an empty array as no items exist at this index\n    if (_startIndex > activeValidatorsEndIndex) {\n      return new string[](0);\n    }\n\n    // If the _endIndex is out of range, update it\n    if (_endIndex > activeValidatorsEndIndex) {\n      _endIndex = activeValidatorsEndIndex;\n    }\n\n    // Amount of addresses equal to the end - the start, adding 1 as we are inclusive of the item at the _endIndex\n    uint256 numAddresses = _endIndex - _startIndex + 1;\n\n    string[] memory addresses = new string[](numAddresses);\n\n    for (uint256 i; i < numAddresses; ) {\n      uint256 values = uint256(activeValidatorIndexes.at(i + _startIndex));\n\n      // Split the response to get the operatorId and keyIndex values\n      uint128 operatorId = uint128(values >> 128);\n      uint128 keyIndex = uint128(values);\n\n      bytes memory pubKey = operatorIdToValidatorDetails[operatorId]\n        .at(keyIndex)\n        .pubKey;\n\n      addresses[i] = _parsePubKeyToString(pubKey);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    return addresses;\n  }\n\n  // ************************************\n  // ***** Internal helpers *****\n\n  /**\n   * @dev This method safely returns an Operator struct from the provided _operatorAddress.\n   * @notice Throws if an operator cannot be found for the provided address.\n   * @param _operatorAddress The controlling address of the given operator\n   * @return operator The Operator struct\n   */\n  function _getOperatorSafe(\n    address _operatorAddress\n  ) internal view returns (Operator storage operator) {\n    uint128 operatorId = _getOperatorIdSafe(_operatorAddress);\n\n    operator = getOperatorForOperatorId[operatorId];\n  }\n\n  /**\n   * @dev This method safely returns the operatorId of the given _operatorAddress\n   * @notice Throws an error if the given _operatorAddress doesn't exist\n   * @param _operatorAddress The controlling address of the given operator\n   * @return operatorId The operator's ID\n   */\n  function _getOperatorIdSafe(\n    address _operatorAddress\n  ) internal view returns (uint128 operatorId) {\n    operatorId = getOperatorIdForAddress[_operatorAddress];\n\n    // The core reasoning behind adding +1 to operatorId's\n    if (operatorId == 0) {\n      revert NoOperatorFound(_operatorAddress);\n    }\n  }\n\n  /**\n   * @dev This method safely returns the operatorId of the given _pubKey\n   * @notice Throws if there is no found operatorId for the given _pubKey\n   * @param _pubKey The public key to find an operator with\n   * @return operatorId The operator ID that controls the given pubKey\n   */\n  function _getOperatorIdForPubKeySafe(\n    bytes calldata _pubKey\n  ) internal view returns (uint128 operatorId) {\n    operatorId = getOperatorIdForPubKey[_pubKey];\n\n    if (operatorId == 0) {\n      revert NoPubKeyFound(_pubKey);\n    }\n  }\n\n  /**\n   * @dev This method encodes the provided operatorId and nextKey into a single bytes32 variable. This is used in the activeValidatorIndexes array\n   * @param operatorId The operator id to encode\n   * @param nextKey The key index to encode\n   * @return The encoded bytes32 variable\n   */\n  function _encodeOperatorIdAndKeyIndex(\n    uint128 operatorId,\n    uint128 nextKey\n  ) internal pure returns (bytes32) {\n    return bytes32((uint256(operatorId) << 128) | (nextKey));\n  }\n\n  // ************************************\n  // ***** External view methods *****\n\n  function getOperator(\n    address _operatorAddress\n  )\n    external\n    view\n    override\n    returns (\n      Operator memory operator,\n      uint128 totalValidatorDetails,\n      uint128 operatorId\n    )\n  {\n    operatorId = _getOperatorIdSafe(_operatorAddress);\n    operator = getOperatorForOperatorId[operatorId];\n    // Safe downcast as the limit is enforced in the addNewValidatorDetails method\n    totalValidatorDetails = uint128(\n      operatorIdToValidatorDetails[operatorId].length()\n    );\n  }\n\n  function getOperatorsPendingValidatorDetails(\n    address _operatorAddress\n  )\n    external\n    view\n    override\n    returns (ValidatorDetails[] memory validatorDetails)\n  {\n    uint128 operatorId = _getOperatorIdSafe(_operatorAddress);\n\n    uint256 operatorsValidatorDetailsLength = operatorIdToValidatorDetails[\n      operatorId\n    ].length();\n\n    if (operatorsValidatorDetailsLength == 0) {\n      return validatorDetails;\n    }\n\n    validatorDetails = operatorIdToValidatorDetails[operatorId].range(\n      getOperatorForOperatorId[operatorId].activeValidators,\n      operatorsValidatorDetailsLength - 1\n    );\n  }\n\n  function getRewardDetailsForOperatorId(\n    uint128 _operatorId\n  )\n    external\n    view\n    override\n    returns (address rewardAddress, uint128 activeValidators)\n  {\n    activeValidators = getOperatorForOperatorId[_operatorId].activeValidators;\n    rewardAddress = getOperatorForOperatorId[_operatorId].rewardAddress;\n  }\n\n  function getOperatorsActiveValidatorDetails(\n    address _operatorAddress\n  )\n    external\n    view\n    override\n    returns (ValidatorDetails[] memory validatorDetails)\n  {\n    uint128 operatorId = _getOperatorIdSafe(_operatorAddress);\n\n    uint128 operatorsActiveValidators = getOperatorForOperatorId[operatorId]\n      .activeValidators;\n\n    if (operatorsActiveValidators == 0) {\n      return validatorDetails;\n    }\n\n    validatorDetails = operatorIdToValidatorDetails[operatorId].range(\n      0,\n      operatorsActiveValidators - 1\n    );\n  }\n}"
    }
  ]
}