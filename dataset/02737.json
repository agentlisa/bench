{
  "Title": "M-6: DnGmxJuniorVaultManager#_totalAssets current implementation doesn't properly maximize or minimize",
  "Content": "# Issue M-6: DnGmxJuniorVaultManager#_totalAssets current implementation doesn't properly maximize or minimize \n\nSource: https://github.com/sherlock-audit/2022-10-rage-trade-judging/issues/36 \n\n## Found by \n0x52\n\n## Summary\n\nThe maximize input to DnGmxJuniorVaultManager#_totalAssets indicates whether to either maximize or minimize the NAV. Internal logic of the function doesn't accurately reflect that because under some circumstances, maximize = true actually returns a lower value than maximize = false.\n\n## Vulnerability Detail\n\n        uint256 unhedgedGlp = (state.unhedgedGlpInUsdc + dnUsdcDepositedPos).mulDivDown(\n            PRICE_PRECISION,\n            _getGlpPrice(state, !maximize)\n        );\n\n        // calculate current borrow amounts\n        (uint256 currentBtc, uint256 currentEth) = _getCurrentBorrows(state);\n        uint256 totalCurrentBorrowValue = _getBorrowValue(state, currentBtc, currentEth);\n\n        // add negative part to current borrow value which will be subtracted at the end\n        // convert usdc amount into glp amount\n        uint256 borrowValueGlp = (totalCurrentBorrowValue + dnUsdcDepositedNeg).mulDivDown(\n            PRICE_PRECISION,\n            _getGlpPrice(state, !maximize)\n        );\n\n        // if we need to minimize then add additional slippage\n        if (!maximize) unhedgedGlp = unhedgedGlp.mulDivDown(MAX_BPS - state.slippageThresholdGmxBps, MAX_BPS);\n        if (!maximize) borrowValueGlp = borrowValueGlp.mulDivDown(MAX_BPS - state.slippageThresholdGmxBps, MAX_BPS);\n\nTo maximize the estimate for the NAV of the vault underlying debt should minimized and value of held assets should be maximized. Under the current settings there is a mix of both of those and the function doesn't consistently minimize or maximize. Consider when NAV is \"maxmized\". Under this scenario the value of when estimated the GlpPrice is minimized. This minimizes the value of both the borrowedGlp (debt) and of the unhedgedGlp (assets). The result is that the NAV is not maximized because the value of the assets are also minimized. In this scenario the GlpPrice should be maximized when calculating the assets and minimized when calculating the debt. The reverse should be true when minimizing the NAV. Slippage requirements are also applied incorrectly when adjusting borrowValueGlp. The current implementation implies that if the debt were to be paid back that the vault would repay their debt for less than expected. When paying back debt the slippage should imply paying more than expected rather than less, therefore the slippage should be added rather than subtracted.\n\n## Impact\n\nDnGmxJuniorVaultManager#_totalAssets doesn't accurately reflect NAV. Since this is used when determining critical parameters it may lead to inaccuracies.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-rage-trade/blob/main/dn-gmx-vaults/contracts/libraries/DnGmxJuniorVaultManager.sol#L1013-L1052\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo properly maximize the it should assume the best possible rate for exchanging it's assets. Likewise to minimize it should assume it's debt is a large as possible and this it encounters maximum possible slippage when repaying it's debt. I recommend the following changes:\n\n        uint256 unhedgedGlp = (state.unhedgedGlpInUsdc + dnUsdcDepositedPos).mulDivDown(\n            PRICE_PRECISION,\n    -       _getGlpPrice(state, !maximize)\n    +       _getGlpPrice(state, maximize)\n        );\n\n        // calculate current borrow amounts\n        (uint256 currentBtc, uint256 currentEth) = _getCurrentBorrows(state);\n        uint256 totalCurrentBorrowValue = _getBorrowValue(state, currentBtc, currentEth);\n\n        // add negative part to current borrow value which will be subtracted at the end\n        // convert usdc amount into glp amount\n        uint256 borrowValueGlp = (totalCurrentBorrowValue + dnUsdcDepositedNeg).mulDivDown(\n            PRICE_PRECISION,\n            _getGlpPrice(state, !maximize)\n        );\n\n        // if we need to minimize then add additional slippage\n        if (!maximize) unhedgedGlp = unhedgedGlp.mulDivDown(MAX_BPS - state.slippageThresholdGmxBps, MAX_BPS);\n    -   if (!maximize) borrowValueGlp = borrowValueGlp.mulDivDown(MAX_BPS - state.slippageThresholdGmxBps, MAX_BPS);\n    +   if (!maximize) borrowValueGlp = borrowValueGlp.mulDivDown(MAX_BPS + state.slippageThresholdGmxBps, MAX_BPS);\n\n## Discussion\n\n**0xDosa**\n\nDividing with minimum price would maximize the asset/borrow amount and vice versa. So the correct fix should be this. @0x00052 could you confirm?\n```    \n     uint256 unhedgedGlp = (state.unhedgedGlpInUsdc + dnUsdcDepositedPos).mulDivDown(\n        PRICE_PRECISION,\n       _getGlpPrice(state, !maximize)\n    );\n\n    // calculate current borrow amounts\n    (uint256 currentBtc, uint256 currentEth) = _getCurrentBorrows(state);\n    uint256 totalCurrentBorrowValue = _getBorrowValue(state, currentBtc, currentEth);\n\n    // add negative part to current borrow value which will be subtracted at the end\n    // convert usdc amount into glp amount\n    uint256 borrowValueGlp = (totalCurrentBorrowValue + dnUsdcDepositedNeg).mulDivDown(\n        PRICE_PRECISION,\n-       _getGlpPrice(state, !maximize)\n+       _getGlpPrice(state, maximize)\n\n    );\n\n    // if we need to minimize then add additional slippage\n    if (!maximize) unhedgedGlp = unhedgedGlp.mulDivDown(MAX_BPS - state.slippageThresholdGmxBps, MAX_BPS);\n-   if (!maximize) borrowValueGlp = borrowValueGlp.mulDivDown(MAX_BPS - state.slippageThresholdGmxBps, MAX_BPS);\n+   if (!maximize) borrowValueGlp = borrowValueGlp.mulDivDown(MAX_BPS + state.slippageThresholdGmxBps, MAX_BPS);\n```\n\n**0x00052**\n\nGood catch! You're right, I got that backwards. \n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/16",
  "Code": [
    {
      "filename": "dn-gmx-vaults/contracts/libraries/DnGmxJuniorVaultManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IVault } from '../interfaces/gmx/IVault.sol';\nimport { IGlpManager } from '../interfaces/gmx/IGlpManager.sol';\nimport { IRewardTracker } from '../interfaces/gmx/IRewardTracker.sol';\nimport { IRewardRouterV2 } from '../interfaces/gmx/IRewardRouterV2.sol';\n\nimport { IDebtToken } from '../interfaces/IDebtToken.sol';\nimport { IPool } from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport { IAToken } from '@aave/core-v3/contracts/interfaces/IAToken.sol';\nimport { IPriceOracle } from '@aave/core-v3/contracts/interfaces/IPriceOracle.sol';\nimport { DataTypes } from '@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol';\nimport { IPoolAddressesProvider } from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport { IRewardsController } from '@aave/periphery-v3/contracts/rewards/interfaces/IRewardsController.sol';\nimport { ReserveConfiguration } from '@aave/core-v3/contracts/protocol/libraries/configuration/ReserveConfiguration.sol';\n\nimport { IBalancerVault } from '../interfaces/balancer/IBalancerVault.sol';\n\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { IERC20Metadata } from '@openzeppelin/contracts/interfaces/IERC20Metadata.sol';\n\nimport { IDnGmxJuniorVault } from '../interfaces/IDnGmxJuniorVault.sol';\nimport { IDnGmxSeniorVault } from '../interfaces/IDnGmxSeniorVault.sol';\nimport { IDnGmxBatchingManager } from '../interfaces/IDnGmxBatchingManager.sol';\nimport { SafeCast } from '../libraries/SafeCast.sol';\nimport { FeeSplitStrategy } from '../libraries/FeeSplitStrategy.sol';\n\nimport { FixedPointMathLib } from '@rari-capital/solmate/src/utils/FixedPointMathLib.sol';\n\nimport { ISwapRouter } from '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';\n\n/**\n * @title Helper library for junior vault\n * @dev junior vault delegates calls to this library for logic\n * @author RageTrade\n */\n\nlibrary DnGmxJuniorVaultManager {\n    event RewardsHarvested(\n        uint256 wethHarvested,\n        uint256 esGmxStaked,\n        uint256 juniorVaultWeth,\n        uint256 seniorVaultWeth,\n        uint256 juniorVaultGlp,\n        uint256 seniorVaultAUsdc\n    );\n\n    event GlpSwapped(uint256 glpQuantity, uint256 usdcQuantity, bool fromGlpToUsdc);\n\n    event TokenSwapped(address indexed fromToken, address indexed toToken, uint256 fromQuantity, uint256 toQuantity);\n\n    using DnGmxJuniorVaultManager for State;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n    using FixedPointMathLib for uint256;\n    using SafeCast for uint256;\n\n    uint256 internal constant MAX_BPS = 10_000;\n\n    uint256 internal constant PRICE_PRECISION = 1e30;\n    uint256 internal constant VARIABLE_INTEREST_MODE = 2;\n\n    struct Tokens {\n        IERC20Metadata weth;\n        IERC20Metadata wbtc;\n        IERC20Metadata sGlp;\n        IERC20Metadata usdc;\n    }\n\n    // prettier-ignore\n    struct State {\n        // core protocol roles\n        address keeper;\n        address feeRecipient;\n\n        // accounting\n        // amount of usdc deposited by junior tranche into AAVE\n        int256 dnUsdcDeposited;\n        // amount of asset which is in usdc (due to borrow limits / availability issue some glp might remain unhedged)\n        uint256 unhedgedGlpInUsdc;\n        // health factor to be targetted on AAVE\n        uint256 targetHealthFactor;\n\n        // accumulators\n        // protocol fee taken from ETH rewards\n        uint256 protocolFee;\n        // protocol fee taken from esGMX rewards\n        uint256 protocolEsGmx;\n        // senior tranche part of eth rewards which is not converted to usdc\n        uint256 seniorVaultWethRewards;\n\n        // locks\n        // true if a flashloan has been initiated by the vault\n        bool hasFlashloaned;\n        // ensures that the rebalance can be run only after certain intervals\n        uint48 lastRebalanceTS;\n\n        // fees\n        // protocol fees charged on the eth and esGmx rewards\n        uint16 feeBps;\n        // fees on the withdrawn assets\n        uint16 withdrawFeeBps;\n\n        // thresholds\n        uint256 depositCap;\n\n        // slippage threshold on asset conversion into glp\n        uint16 slippageThresholdGmxBps; // bps\n        // slippage threshold on btc swap on uniswap\n        uint16 slippageThresholdSwapBtcBps; // bps\n        // slippage threshold on eth swap on uniswap\n        uint16 slippageThresholdSwapEthBps; // bps\n        // health factor treshold below which rebalance can be called\n        uint16 rebalanceHfThresholdBps; // bps\n        // time threshold beyond which on top of last rebalance, rebalance can be called\n        uint32 rebalanceTimeThreshold; // seconds between rebalance\n        // difference between current and optimal amounts beyond which rebalance can be called\n        uint16 rebalanceDeltaThresholdBps; // bps\n        // eth amount of weth rewards accrued beyond which they can be compounded\n        uint128 wethConversionThreshold; // eth amount\n\n        // usdc amount beyond which usdc can be converted to assets\n        uint128 usdcConversionThreshold; // usdc amount\n        // usdc value of token hedges below which hedges are not taken\n        uint128 hedgeUsdcAmountThreshold; // usdc amount\n\n        // usdc amount of btc hedge beyond which partial hedges are taken over multiple rebalances\n        uint128 partialBtcHedgeUsdcAmountThreshold; // usdc amount\n        // usdc amount of eth hedge beyond which partial hedges are taken over multiple rebalances\n        uint128 partialEthHedgeUsdcAmountThreshold; // usdc amount\n\n        // token addrs\n        IERC20 fsGlp;\n        IERC20Metadata glp;\n        IERC20Metadata usdc;\n        IERC20Metadata weth;\n        IERC20Metadata wbtc;\n\n        // aave protocol addrs\n        // lending pool for liqudity market\n        IPool pool;\n        // aave interest bearing usdc\n        IAToken aUsdc;\n        // variable-rate debt accruing btc\n        IDebtToken vWbtc;\n        // variable-rate debt accruing eth\n        IDebtToken vWeth;\n        // cannocial oracle used by aave\n        IPriceOracle oracle;\n        // rewards controller to claim any emissions (for future use)\n        IRewardsController aaveRewardsController;\n        // immutable address provider to obtain various addresses\n        IPoolAddressesProvider poolAddressProvider;\n\n        // gmx protocol addrs\n        // core gmx vault\n        IVault gmxVault;\n        // staked gmx\n        IRewardTracker sGmx;\n        // glp manager (for giving assets allowance and fetching AUM)\n        IGlpManager glpManager;\n        // rewardRouter to stake & unstake glp\n        IRewardRouterV2 rewardRouter;\n\n        // other external protocols\n        // uniswap swap router for token swaps\n        ISwapRouter swapRouter;\n        // balancer vault for flashloans\n        IBalancerVault balancerVault;\n\n        // core protocol addrs\n        // senior tranche address\n        IDnGmxSeniorVault dnGmxSeniorVault;\n        // batching manager address\n        IDnGmxBatchingManager batchingManager;\n\n        // gaps for extending struct (if required during upgrade)\n        uint256[50] __gaps;\n    }\n\n    /// @notice stakes the rewards from the staked Glp and claims WETH to buy glp\n    /// @notice also update protocolEsGmx fees which can be vested and claimed\n    /// @notice divides the fees between senior and junior tranches based on senior tranche util\n    /// @notice for junior tranche weth is deposited to batching manager which handles conversion to sGLP\n    /// @notice for senior tranche weth is converted into usdc and deposited on AAVE which increases the borrowed amount\n    function harvestFees(State storage state) public {\n        uint256 sGmxHarvested;\n        {\n            address esGmx = state.rewardRouter.esGmx();\n            IRewardTracker sGmx = IRewardTracker(state.rewardRouter.stakedGmxTracker());\n\n            // existing staked gmx balance\n            uint256 sGmxPrevBalance = sGmx.depositBalances(address(this), esGmx);\n\n            // handles claiming and staking of esGMX, staking of multiplier points and claim of WETH rewards on GMX\n            state.rewardRouter.handleRewards({\n                shouldClaimGmx: false,\n                shouldStakeGmx: false,\n                shouldClaimEsGmx: true,\n                shouldStakeEsGmx: true,\n                shouldStakeMultiplierPoints: true,\n                shouldClaimWeth: true,\n                shouldConvertWethToEth: false\n            });\n\n            // harvested staked gmx\n            sGmxHarvested = sGmx.depositBalances(address(this), esGmx) - sGmxPrevBalance;\n        }\n        // protocol esGMX fees\n        state.protocolEsGmx += sGmxHarvested.mulDivDown(state.feeBps, MAX_BPS);\n\n        // total weth harvested which is not compounded\n        // its possible that this is accumulated value over multiple rebalance if in all of those it was below threshold\n        uint256 wethHarvested = state.weth.balanceOf(address(this)) - state.protocolFee - state.seniorVaultWethRewards;\n\n        if (wethHarvested > state.wethConversionThreshold) {\n            // weth harvested > conversion threshold\n            uint256 protocolFeeHarvested = (wethHarvested * state.feeBps) / MAX_BPS;\n            // protocol fee incremented\n            state.protocolFee += protocolFeeHarvested;\n\n            // protocol fee to be kept in weth\n            // remaining amount needs to be compounded\n            uint256 wethToCompound = wethHarvested - protocolFeeHarvested;\n\n            // share of the wethToCompound that belongs to senior tranche\n            uint256 dnGmxSeniorVaultWethShare = state.dnGmxSeniorVault.getEthRewardsSplitRate().mulDivDown(\n                wethToCompound,\n                FeeSplitStrategy.RATE_PRECISION\n            );\n            // share of the wethToCompound that belongs to junior tranche\n            uint256 dnGmxWethShare = wethToCompound - dnGmxSeniorVaultWethShare;\n\n            // total senior tranche weth which is not compounded\n            uint256 _seniorVaultWethRewards = state.seniorVaultWethRewards + dnGmxSeniorVaultWethShare;\n\n            uint256 glpReceived;\n            {\n                // converts junior tranche share of weth into glp using batching manager\n                // we need to use batching manager since there is a cooldown period on sGLP\n                // if deposited directly for next 15mins withdrawals would fail\n                uint256 price = state.gmxVault.getMinPrice(address(state.weth));\n\n                uint256 usdgAmount = dnGmxWethShare.mulDivDown(\n                    price * (MAX_BPS - state.slippageThresholdGmxBps),\n                    PRICE_PRECISION * MAX_BPS\n                );\n\n                // deposits weth into batching manager which handles the conversion into glp\n                // can be taken back through batch execution\n                glpReceived = state.batchingManager.depositToken(address(state.weth), dnGmxWethShare, usdgAmount);\n            }\n\n            if (_seniorVaultWethRewards > state.wethConversionThreshold) {\n                // converts senior tranche share of weth into usdc and deposit into AAVE\n                // Deposit aave vault share to AAVE in usdc\n                uint256 minUsdcAmount = _getTokenPriceInUsdc(state, state.weth).mulDivDown(\n                    _seniorVaultWethRewards * (MAX_BPS - state.slippageThresholdSwapEthBps),\n                    MAX_BPS * PRICE_PRECISION\n                );\n                // swaps weth into usdc\n                (uint256 aaveUsdcAmount, ) = state._swapToken(\n                    address(state.weth),\n                    _seniorVaultWethRewards,\n                    minUsdcAmount\n                );\n\n                // supplies usdc into AAVE\n                state._executeSupply(address(state.usdc), aaveUsdcAmount);\n\n                // resets senior tranche rewards\n                state.seniorVaultWethRewards = 0;\n\n                emit RewardsHarvested(\n                    wethHarvested,\n                    sGmxHarvested,\n                    dnGmxWethShare,\n                    dnGmxSeniorVaultWethShare,\n                    glpReceived,\n                    aaveUsdcAmount\n                );\n            } else {\n                state.seniorVaultWethRewards = _seniorVaultWethRewards;\n                emit RewardsHarvested(\n                    wethHarvested,\n                    sGmxHarvested,\n                    dnGmxWethShare,\n                    dnGmxSeniorVaultWethShare,\n                    glpReceived,\n                    0\n                );\n            }\n        } else {\n            emit RewardsHarvested(wethHarvested, sGmxHarvested, 0, 0, 0, 0);\n        }\n    }\n\n    /* ##################################################################\n                            REBALANCE HELPERS\n    ################################################################## */\n\n    ///@notice rebalances pnl on AAVE againts the sGLP assets\n    ///@param state set of all state variables of vault\n    ///@param borrowValue value of the borrowed assests(ETH + BTC) from AAVE in USDC\n    function rebalanceProfit(State storage state, uint256 borrowValue) external {\n        return _rebalanceProfit(state, borrowValue);\n    }\n\n    ///@notice rebalances pnl on AAVE againts the sGLP assets\n    ///@dev converts assets into usdc and deposits to AAVE if profit on GMX and loss on AAVE\n    ///@dev withdraws usdc from aave and converts to GLP if loss on GMX and profits on AAVE\n    ///@param state set of all state variables of vault\n    ///@param borrowValue value of the borrowed assests(ETH + BTC) from AAVE in USDC\n    function _rebalanceProfit(State storage state, uint256 borrowValue) private {\n        int256 borrowVal = borrowValue.toInt256();\n\n        if (borrowVal > state.dnUsdcDeposited) {\n            // If glp goes up - there is profit on GMX and loss on AAVE\n            // So convert some glp to usdc and deposit to AAVE\n            state.dnUsdcDeposited += _convertAssetToAUsdc(state, uint256(borrowVal - state.dnUsdcDeposited)).toInt256();\n        } else if (borrowVal < state.dnUsdcDeposited) {\n            // If glp goes down - there is profit on AAVE and loss on GMX\n            // So withdraw some aave usdc and convert to glp\n            _convertAUsdcToAsset(state, uint256(state.dnUsdcDeposited - borrowVal));\n            state.dnUsdcDeposited = borrowVal;\n        }\n    }\n\n    ///@notice rebalances the assets borrowed from AAVE to hedge ETH and BTC underlying the assets\n    ///@param state set of all state variables of vault\n    ///@param optimalBtcBorrow optimal btc amount to hedge sGLP btc underlying completely\n    ///@param currentBtcBorrow current btc amount borrowed from AAVE\n    ///@param optimalEthBorrow optimal eth amount to hedge sGLP btc underlying completely\n    ///@param currentEthBorrow current eth amount borrowed from AAVE\n    function rebalanceBorrow(\n        State storage state,\n        uint256 optimalBtcBorrow,\n        uint256 currentBtcBorrow,\n        uint256 optimalEthBorrow,\n        uint256 currentEthBorrow\n    ) external {\n        return _rebalanceBorrow(state, optimalBtcBorrow, currentBtcBorrow, optimalEthBorrow, currentEthBorrow);\n    }\n\n    ///@notice rebalances the assets borrowed from AAVE to hedge ETH and BTC underlying the assets\n    ///@param state set of all state variables of vault\n    ///@param optimalBtcBorrow optimal btc amount to hedge sGLP btc underlying completely\n    ///@param currentBtcBorrow current btc amount borrowed from AAVE\n    ///@param optimalEthBorrow optimal eth amount to hedge sGLP btc underlying completely\n    ///@param currentEthBorrow current eth amount borrowed from AAVE\n    function _rebalanceBorrow(\n        State storage state,\n        uint256 optimalBtcBorrow,\n        uint256 currentBtcBorrow,\n        uint256 optimalEthBorrow,\n        uint256 currentEthBorrow\n    ) private {\n        address[] memory assets;\n        uint256[] memory amounts;\n\n        // calculate the token/usdc amount to be flashloaned from balancer\n        (uint256 btcTokenAmount, uint256 btcUsdcAmount, bool repayDebtBtc) = _flashloanAmounts(\n            state,\n            address(state.wbtc),\n            optimalBtcBorrow,\n            currentBtcBorrow\n        );\n        (uint256 ethTokenAmount, uint256 ethUsdcAmount, bool repayDebtEth) = _flashloanAmounts(\n            state,\n            address(state.weth),\n            optimalEthBorrow,\n            currentEthBorrow\n        );\n\n        // no swap needs to happen if the amount to hedge < threshold\n        if (btcUsdcAmount < state.hedgeUsdcAmountThreshold) {\n            btcTokenAmount = 0;\n            btcUsdcAmount = 0;\n        }\n        if (ethUsdcAmount < state.hedgeUsdcAmountThreshold) {\n            ethTokenAmount = 0;\n            ethUsdcAmount = 0;\n        }\n\n        // get asset amount basis increase/decrease of token amounts\n        uint256 btcAssetAmount = repayDebtBtc ? btcUsdcAmount : btcTokenAmount;\n        uint256 ethAssetAmount = repayDebtEth ? ethUsdcAmount : ethTokenAmount;\n\n        // If both eth and btc swap amounts are not beyond the threshold then no flashloan needs to be executed | case 1\n        if (btcAssetAmount == 0 && ethAssetAmount == 0) return;\n\n        if (repayDebtBtc && repayDebtEth) {\n            // case where both the token assets are USDC\n            // only one entry required which is combined asset amount for both tokens\n            assets = new address[](1);\n            amounts = new uint256[](1);\n\n            assets[0] = address(state.usdc);\n            amounts[0] = (btcAssetAmount + ethAssetAmount);\n        } else if (btcAssetAmount == 0 || ethAssetAmount == 0) {\n            // Exactly one would be true since case-1 excluded (both false) | case-2\n            // One token amount = 0 and other token amount > 0\n            // only one entry required for the non-zero amount token\n            assets = new address[](1);\n            amounts = new uint256[](1);\n\n            if (btcAssetAmount == 0) {\n                assets[0] = (repayDebtBtc ? address(state.usdc) : address(state.wbtc));\n                amounts[0] = btcAssetAmount;\n            } else {\n                assets[0] = (repayDebtEth ? address(state.usdc) : address(state.weth));\n                amounts[0] = ethAssetAmount;\n            }\n        } else {\n            // Both are true | case-3\n            assets = new address[](2);\n            amounts = new uint256[](2);\n\n            assets[0] = repayDebtBtc ? address(state.usdc) : address(state.wbtc);\n\n            assets[1] = repayDebtEth ? address(state.usdc) : address(state.weth);\n\n            // ensure that assets and amount tuples are in sorted order of addresses\n            // (required for balancer flashloans)\n            if (assets[0] > assets[1]) {\n                // if the order is descending\n                // switch the order for assets tupe\n                // assign amounts in opposite order\n                address tempAsset = assets[0];\n                assets[0] = assets[1];\n                assets[1] = tempAsset;\n\n                amounts[0] = ethAssetAmount;\n\n                amounts[1] = btcAssetAmount;\n            } else {\n                // if the order is ascending\n                // assign amount in same order\n                amounts[0] = btcAssetAmount;\n\n                amounts[1] = ethAssetAmount;\n            }\n        }\n        // execute the flashloan\n        _executeFlashloan(\n            state,\n            assets,\n            amounts,\n            btcTokenAmount,\n            btcUsdcAmount,\n            ethTokenAmount,\n            ethUsdcAmount,\n            repayDebtBtc,\n            repayDebtEth\n        );\n    }\n\n    ///@notice returns the optimal borrow amounts based on a swap threshold\n    ///@dev if the swap amount is less than threshold then that is returned\n    ///@dev if the swap amount is greater than threshold then threshold amount is returned\n    ///@param state set of all state variables of vault\n    ///@param token ETH / BTC token\n    ///@param optimalTokenBorrow optimal btc amount to hedge sGLP btc underlying completely\n    ///@param currentTokenBorrow current btc amount borrowed from AAVE\n    ///@return optimalPartialTokenBorrow optimal token hedge if threshold is breached\n    ///@return isPartialTokenHedge true if partial hedge needs to be executed for token\n    function _getOptimalPartialBorrows(\n        State storage state,\n        IERC20Metadata token,\n        uint256 optimalTokenBorrow,\n        uint256 currentTokenBorrow\n    ) internal view returns (uint256 optimalPartialTokenBorrow, bool isPartialTokenHedge) {\n        // checks if token hedge needs to be increased or decreased\n        bool isOptimalHigher = optimalTokenBorrow > currentTokenBorrow;\n        // difference = amount of swap to be done for complete hedge\n        uint256 diff = isOptimalHigher\n            ? optimalTokenBorrow - currentTokenBorrow\n            : currentTokenBorrow - optimalTokenBorrow;\n\n        // get the correct threshold basis the token\n        uint256 threshold = address(token) == address(state.wbtc)\n            ? state.partialBtcHedgeUsdcAmountThreshold\n            : state.partialEthHedgeUsdcAmountThreshold;\n\n        // convert usdc threshold into token amount threshold\n        uint256 tokenThreshold = threshold.mulDivDown(PRICE_PRECISION, _getTokenPriceInUsdc(state, token));\n\n        if (diff > tokenThreshold) {\n            // amount to swap > threshold\n            // swap only the threshold amount in this rebalance (partial hedge)\n            optimalPartialTokenBorrow = isOptimalHigher\n                ? currentTokenBorrow + tokenThreshold\n                : currentTokenBorrow - tokenThreshold;\n            isPartialTokenHedge = true;\n        } else {\n            // amount to swap < threshold\n            // swap the full amount in this rebalance (complete hedge)\n            optimalPartialTokenBorrow = optimalTokenBorrow;\n        }\n    }\n\n    ///@notice rebalances btc and eth hedges according to underlying glp token weights\n    ///@notice updates the borrowed amount from senior tranche basis the target health factor\n    ///@notice if the amount of swap for a token > theshold then a partial hedge is taken and remaining is taken separately\n    ///@notice if the amount of swap for a token < threshold complete hedge is taken\n    ///@notice in case there is not enough money in senior tranche then relevant amount of glp is converted into usdc\n    ///@dev to be called after settle profits only (since vaultMarketValue if after settlement of profits)\n    ///@param state set of all state variables of vault\n    ///@param currentBtcBorrow The amount of USDC collateral token deposited to LB Protocol\n    ///@param currentEthBorrow The market value of ETH/BTC part in sGLP\n    ///@param glpDeposited amount of glp deposited into the vault\n    ///@param isPartialAllowed true if partial hedge is allowed\n    ///@return isPartialHedge true if partial hedge is executed\n    function rebalanceHedge(\n        State storage state,\n        uint256 currentBtcBorrow,\n        uint256 currentEthBorrow,\n        uint256 glpDeposited,\n        bool isPartialAllowed\n    ) external returns (bool isPartialHedge) {\n        // optimal btc and eth borrows\n        // calculated basis the underlying token weights in glp\n        (uint256 optimalBtcBorrow, uint256 optimalEthBorrow) = _getOptimalBorrows(state, glpDeposited);\n\n        if (isPartialAllowed) {\n            // if partial hedges are allowed (i.e. rebalance call and not deposit/withdraw)\n            // check if swap amounts>threshold then basis that do a partial hedge\n            bool isPartialBtcHedge;\n            bool isPartialEthHedge;\n            // get optimal borrows basis hedge thresholds\n            (optimalBtcBorrow, isPartialBtcHedge) = _getOptimalPartialBorrows(\n                state,\n                state.wbtc,\n                optimalBtcBorrow,\n                currentBtcBorrow\n            );\n            (optimalEthBorrow, isPartialEthHedge) = _getOptimalPartialBorrows(\n                state,\n                state.weth,\n                optimalEthBorrow,\n                currentEthBorrow\n            );\n            // if some token is partially hedged then set that this rebalance is partial\n            // lastRebalanceTime not updated in this case so a rebalance can be called again\n            isPartialHedge = isPartialBtcHedge || isPartialEthHedge;\n        }\n\n        // calculate usdc value of optimal borrows\n        uint256 optimalBorrowValue = _getBorrowValue(state, optimalBtcBorrow, optimalEthBorrow);\n\n        // get liquidation threshold of usdc on AAVE\n        uint256 usdcLiquidationThreshold = _getLiquidationThreshold(state, address(state.usdc));\n\n        // Settle net change in market value and deposit/withdraw collateral tokens\n        // Vault market value is just the collateral value since profit has been settled\n        // AAVE target health factor = (usdc supply value * usdc liquidation threshold)/borrow value\n        // whatever tokens we borrow from AAVE (ETH/BTC) we sell for usdc and deposit that usdc into AAVE\n        // assuming 0 slippage borrow value of tokens = usdc deposit value (this leads to very small variation in hf)\n        // usdc supply value = usdc borrowed from senior tranche + borrow value\n        // replacing usdc supply value formula above in AAVE target health factor formula\n        // we can derive usdc amount to borrow from senior tranche i.e. targetDnGmxSeniorVaultAmount\n        uint256 targetDnGmxSeniorVaultAmount = (state.targetHealthFactor - usdcLiquidationThreshold).mulDivDown(\n            optimalBorrowValue,\n            usdcLiquidationThreshold\n        );\n\n        // current usdc borrowed from senior tranche\n        uint256 currentDnGmxSeniorVaultAmount = _getUsdcBorrowed(state);\n\n        if (targetDnGmxSeniorVaultAmount > currentDnGmxSeniorVaultAmount) {\n            // case where we need to borrow more usdc\n            // To get more usdc from senior tranche, so usdc is borrowed first and then hedge is updated on AAVE\n            {\n                uint256 amountToBorrow = targetDnGmxSeniorVaultAmount - currentDnGmxSeniorVaultAmount;\n                uint256 availableBorrow = state.dnGmxSeniorVault.availableBorrow(address(this));\n                if (amountToBorrow > availableBorrow) {\n                    // if amount to borrow > available borrow amount\n                    // we won't be able to hedge glp completely\n                    // convert some glp into usdc to keep the vault delta neutral\n                    // hedge the btc/eth of remaining amount\n                    uint256 optimalUncappedEthBorrow = optimalEthBorrow;\n\n                    // optimal btc and eth borrows basis the hedged part of glp\n                    (optimalBtcBorrow, optimalEthBorrow) = _getOptimalCappedBorrows(\n                        state,\n                        currentDnGmxSeniorVaultAmount + availableBorrow,\n                        usdcLiquidationThreshold\n                    );\n\n                    // rebalance the unhedged glp (increase/decrease basis the capped optimal token hedges)\n                    _rebalanceUnhedgedGlp(state, optimalUncappedEthBorrow, optimalEthBorrow);\n\n                    if (availableBorrow > 0) {\n                        // borrow whatever is available since required > available\n                        state.dnGmxSeniorVault.borrow(availableBorrow);\n                    }\n                } else {\n                    //No unhedged glp remaining so just pass same value in capped and uncapped (should convert back any ausdc back to sglp)\n                    _rebalanceUnhedgedGlp(state, optimalEthBorrow, optimalEthBorrow);\n\n                    // Take from LB Vault\n                    state.dnGmxSeniorVault.borrow(targetDnGmxSeniorVaultAmount - currentDnGmxSeniorVaultAmount);\n                }\n            }\n\n            // Rebalance Position\n            // Executes a flashloan from balancer and btc/eth borrow updates on AAVE\n            _rebalanceBorrow(state, optimalBtcBorrow, currentBtcBorrow, optimalEthBorrow, currentEthBorrow);\n        } else {\n            // Executes a flashloan from balancer and btc/eth borrow updates on AAVE\n            // To repay usdc to senior tranche so update the hedges on AAVE first\n            // then remove usdc to pay back to senior tranche\n            _rebalanceBorrow(state, optimalBtcBorrow, currentBtcBorrow, optimalEthBorrow, currentEthBorrow);\n            uint256 totalCurrentBorrowValue;\n            {\n                (uint256 currentBtc, uint256 currentEth) = _getCurrentBorrows(state);\n                totalCurrentBorrowValue = _getBorrowValue(state, currentBtc, currentEth);\n            }\n            _rebalanceProfit(state, totalCurrentBorrowValue);\n            // Deposit to LB Vault\n\n            state.dnGmxSeniorVault.repay(currentDnGmxSeniorVaultAmount - targetDnGmxSeniorVaultAmount);\n        }\n    }\n\n    ///@notice withdraws LP tokens from gauge, sells LP token for usdc\n    ///@param state set of all state variables of vault\n    ///@param usdcAmountDesired amount of USDC desired\n    ///@return usdcAmountOut usdc amount returned by gmx\n    function _convertAssetToAUsdc(State storage state, uint256 usdcAmountDesired)\n        internal\n        returns (uint256 usdcAmountOut)\n    {\n        ///@dev if usdcAmountDesired < 10, then there is precision issue in gmx contracts while redeeming for usdg\n\n        if (usdcAmountDesired < state.usdcConversionThreshold) return 0;\n        address _usdc = address(state.usdc);\n\n        // @dev using max price of usdc becausing buying usdc for glp\n        uint256 usdcPrice = state.gmxVault.getMaxPrice(_usdc);\n\n        // calculate the minimum required amount basis the set slippage param\n        // uses current usdc max price from GMX and adds slippage on top\n        uint256 minUsdcOut = usdcAmountDesired.mulDivDown(\n            usdcPrice * (MAX_BPS - state.slippageThresholdGmxBps),\n            PRICE_PRECISION * MAX_BPS\n        );\n\n        // calculate the amount of glp to be converted to get the desired usdc amount\n        uint256 glpAmountInput = usdcAmountDesired.mulDivDown(PRICE_PRECISION, _getGlpPrice(state, false));\n\n        usdcAmountOut = state.rewardRouter.unstakeAndRedeemGlp(_usdc, glpAmountInput, minUsdcOut, address(this));\n\n        emit GlpSwapped(glpAmountInput, usdcAmountOut, true);\n\n        _executeSupply(state, _usdc, usdcAmountOut);\n    }\n\n    ///@notice sells usdc for LP tokens and then stakes LP tokens\n    ///@param state set of all state variables of vault\n    ///@param amount amount of usdc\n    function _convertAUsdcToAsset(State storage state, uint256 amount) internal {\n        _executeWithdraw(state, address(state.usdc), amount, address(this));\n\n        uint256 price = state.gmxVault.getMinPrice(address(state.usdc));\n\n        // USDG has 18 decimals and usdc has 6 decimals => 18-6 = 12\n        uint256 usdgAmount = amount.mulDivDown(\n            price * (MAX_BPS - state.slippageThresholdGmxBps) * 1e12,\n            PRICE_PRECISION * MAX_BPS\n        );\n\n        // conversion of token into glp using batching manager\n        // batching manager handles the conversion due to the cooldown\n        // glp transferred to the vault on batch execution\n        uint256 glpReceived = state.batchingManager.depositToken(address(state.usdc), amount, usdgAmount);\n\n        emit GlpSwapped(glpReceived, amount, false);\n    }\n\n    ///@notice rebalances unhedged glp amount\n    ///@notice converts some glp into usdc if there is lesser amount of usdc to back the hedges than required\n    ///@notice converts some usdc into glp if some part of the unhedged glp can be hedged\n    ///@notice used when there is not enough usdc available in senior tranche\n    ///@param state set of all state variables of vault\n    ///@param uncappedTokenHedge token hedge if there was no asset cap\n    ///@param cappedTokenHedge token hedge if given there is limited about of assets available in senior tranche\n    function _rebalanceUnhedgedGlp(\n        State storage state,\n        uint256 uncappedTokenHedge,\n        uint256 cappedTokenHedge\n    ) private {\n        // part of glp assets to be kept unhedged\n        // calculated basis the uncapped amount (assumes unlimited borrow availability)\n        // and capped amount (basis available borrow)\n\n        // uncappedTokenHedge is required to hedge totalAssets\n        // cappedTokenHedge can be taken basis available borrow\n        // so basis what % if hedge cannot be taken, same % of glp is converted to usdc\n        uint256 unhedgedGlp = _totalAssets(state, false).mulDivDown(\n            uncappedTokenHedge - cappedTokenHedge,\n            uncapp"
    }
  ]
}