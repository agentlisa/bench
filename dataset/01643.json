{
  "Title": "M-1: possible precision loss in D3VaultLiquidation.finishLiquidation() function when calculating realDebt because of division before multiplication",
  "Content": "# Issue M-1: possible precision loss in D3VaultLiquidation.finishLiquidation() function when calculating realDebt because of division before multiplication \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/45 \n\n## Found by \n0xdice91, BugBusters, BugHunter101, Kalyan-Singh, MohammedRizwan, Oxhunter526, PRAISE, amaechieth, kutugu\n## Summary\nfinishLiquidation() divides before multiplying when calculating realDebt.\n\n## Vulnerability Detail\n```solidity \nuint256 realDebt = borrows.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n```\n\nThere will be precision loss when calculating the realDebt because solidity truncates values when dividing and dividing before multiplying causes precision loss.\n\nValues that suffered from precision loss will be updated here\n```solidity\n info.totalBorrows = info.totalBorrows - realDebt;\n```\n## Impact\nValues that suffered from precision loss will be updated here\n```solidity\n info.totalBorrows = info.totalBorrows - realDebt;\n```\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol#L144\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol#L147\n## Tool used\n\nManual Review\n\n## Recommendation\ndon't divide before multiplying \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"./D3VaultFunding.sol\";\n\ncontract D3VaultLiquidation is D3VaultFunding {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    function isPositiveNetWorthAsset(address pool, address token) internal view returns (bool) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        return balance >= borrows;\n    }\n\n    function getPositiveNetWorthAsset(address pool, address token) internal view returns (uint256) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        if (balance > borrows) {\n            return balance - borrows;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice public liquidate function, repay pool negative worth token and get collateral tokens with discount\n    /// @param pool pool address, must be in belowMM\n    /// @param collateral pool collateral, any positive worth token pool has\n    /// @param collateralAmount collateral amount liquidator claim\n    /// @param debt pool debt, any negative worth token pool has\n    /// @param debtToCover debt amount liquidator repay\n    function liquidate(\n        address pool,\n        address collateral,\n        uint256 collateralAmount,\n        address debt,\n        uint256 debtToCover\n    ) external nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(!checkBadDebtAfterAccrue(pool), Errors.HAS_BAD_DEBT);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        require(isPositiveNetWorthAsset(pool, collateral), Errors.INVALID_COLLATERAL_TOKEN);\n        require(!isPositiveNetWorthAsset(pool, debt), Errors.INVALID_DEBT_TOKEN);\n        require(getPositiveNetWorthAsset(pool, collateral) >= collateralAmount, Errors.COLLATERAL_AMOUNT_EXCEED);\n        \n        uint256 collateralTokenPrice = ID3Oracle(_ORACLE_).getPrice(collateral);\n        uint256 debtTokenPrice = ID3Oracle(_ORACLE_).getPrice(debt);\n        uint256 collateralAmountMax = debtToCover.mul(debtTokenPrice).div(collateralTokenPrice.mul(DISCOUNT));\n        require(collateralAmount <= collateralAmountMax, Errors.COLLATERAL_AMOUNT_EXCEED);\n\n        AssetInfo storage info = assetInfo[debt];\n        BorrowRecord storage record = info.borrowRecord[pool];\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n        require(debtToCover <= borrows, Errors.DEBT_TO_COVER_EXCEED);\n        IERC20(debt).transferFrom(msg.sender, address(this), debtToCover);\n\n        record.amount = borrows - debtToCover;\n        record.interestIndex = info.borrowIndex;\n        IERC20(collateral).transferFrom(pool, msg.sender, collateralAmount);\n        ID3MM(pool).updateReserveByVault(collateral);\n    }\n\n    // ---------- Liquidate by DODO team ----------\n    /// @notice if occuring bad debt, dodo team will start liquidation to balance debt\n    function startLiquidation(address pool) external onlyLiquidator nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        ID3MM(pool).startLiquidation();\n\n        uint256 totalAssetValue = getTotalAssetsValue(pool);\n        uint256 totalDebtValue = _getTotalDebtValue(pool);\n        require(totalAssetValue < totalDebtValue, Errors.NO_BAD_DEBT);\n\n        uint256 ratio = totalAssetValue.div(totalDebtValue);\n\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 debt = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex).mul(ratio);\n            liquidationTarget[pool][token] = debt;\n        }\n    }\n\n    function liquidateByDODO(\n        address pool,\n        LiquidationOrder calldata order,\n        bytes calldata routeData,\n        address router\n    ) external onlyLiquidator nonReentrant {\n        uint256 toTokenReserve = IERC20(order.toToken).balanceOf(address(this));\n        uint256 fromTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.fromToken), order.fromAmount);\n\n        // swap using Route\n        {\n            IERC20(order.fromToken).transferFrom(pool, router, order.fromAmount);\n            (bool success, bytes memory data) = router.call(routeData);\n            if (!success) {\n                assembly {\n                    revert(add(data, 32), mload(data))\n                }\n            }\n        }\n\n        // the transferred-in toToken USD value should not be less than 95% of the transferred-out fromToken\n        uint256 receivedToToken = IERC20(order.toToken).balanceOf(address(this)) - toTokenReserve;\n        uint256 toTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.toToken), receivedToToken);\n\n        require(toTokenValue.div(fromTokenValue) >= DISCOUNT, Errors.EXCEED_DISCOUNT);\n        IERC20(order.toToken).safeTransfer(pool, receivedToToken);\n        ID3MM(pool).updateReserveByVault(order.fromToken);\n        ID3MM(pool).updateReserveByVault(order.toToken);\n    }\n\n    function finishLiquidation(address pool) external onlyLiquidator nonReentrant {\n        require(ID3MM(pool).isInLiquidation(), Errors.NOT_IN_LIQUIDATION);\n        accrueInterests();\n\n        bool hasPositiveBalance;\n        bool hasNegativeBalance;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            uint256 balance = IERC20(token).balanceOf(pool);\n            uint256 debt = liquidationTarget[pool][token];\n            int256 difference = int256(balance) - int256(debt);\n            if (difference > 0) {\n                require(!hasNegativeBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasPositiveBalance = true;\n            } else if (difference < 0) {\n                require(!hasPositiveBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasNegativeBalance = true;\n                debt = balance; // if balance is less than target amount, just repay with balance\n            }\n\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 borrows = record.amount;\n            if (borrows == 0) continue;\n\n            // note: During liquidation process, the pool's debt will slightly increase due to the generated interests. \n            // The liquidation process will not repay the interests. Thus all dToken holders will share the loss equally.\n            uint256 realDebt = borrows.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n            IERC20(token).transferFrom(pool, address(this), debt);\n\n            info.totalBorrows = info.totalBorrows - realDebt;\n            record.amount = 0;\n        }\n\n        ID3MM(pool).finishLiquidation();\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"./D3VaultFunding.sol\";\n\ncontract D3VaultLiquidation is D3VaultFunding {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    function isPositiveNetWorthAsset(address pool, address token) internal view returns (bool) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        return balance >= borrows;\n    }\n\n    function getPositiveNetWorthAsset(address pool, address token) internal view returns (uint256) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        if (balance > borrows) {\n            return balance - borrows;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice public liquidate function, repay pool negative worth token and get collateral tokens with discount\n    /// @param pool pool address, must be in belowMM\n    /// @param collateral pool collateral, any positive worth token pool has\n    /// @param collateralAmount collateral amount liquidator claim\n    /// @param debt pool debt, any negative worth token pool has\n    /// @param debtToCover debt amount liquidator repay\n    function liquidate(\n        address pool,\n        address collateral,\n        uint256 collateralAmount,\n        address debt,\n        uint256 debtToCover\n    ) external nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(!checkBadDebtAfterAccrue(pool), Errors.HAS_BAD_DEBT);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        require(isPositiveNetWorthAsset(pool, collateral), Errors.INVALID_COLLATERAL_TOKEN);\n        require(!isPositiveNetWorthAsset(pool, debt), Errors.INVALID_DEBT_TOKEN);\n        require(getPositiveNetWorthAsset(pool, collateral) >= collateralAmount, Errors.COLLATERAL_AMOUNT_EXCEED);\n        \n        uint256 collateralTokenPrice = ID3Oracle(_ORACLE_).getPrice(collateral);\n        uint256 debtTokenPrice = ID3Oracle(_ORACLE_).getPrice(debt);\n        uint256 collateralAmountMax = debtToCover.mul(debtTokenPrice).div(collateralTokenPrice.mul(DISCOUNT));\n        require(collateralAmount <= collateralAmountMax, Errors.COLLATERAL_AMOUNT_EXCEED);\n\n        AssetInfo storage info = assetInfo[debt];\n        BorrowRecord storage record = info.borrowRecord[pool];\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n        require(debtToCover <= borrows, Errors.DEBT_TO_COVER_EXCEED);\n        IERC20(debt).transferFrom(msg.sender, address(this), debtToCover);\n\n        record.amount = borrows - debtToCover;\n        record.interestIndex = info.borrowIndex;\n        IERC20(collateral).transferFrom(pool, msg.sender, collateralAmount);\n        ID3MM(pool).updateReserveByVault(collateral);\n    }\n\n    // ---------- Liquidate by DODO team ----------\n    /// @notice if occuring bad debt, dodo team will start liquidation to balance debt\n    function startLiquidation(address pool) external onlyLiquidator nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        ID3MM(pool).startLiquidation();\n\n        uint256 totalAssetValue = getTotalAssetsValue(pool);\n        uint256 totalDebtValue = _getTotalDebtValue(pool);\n        require(totalAssetValue < totalDebtValue, Errors.NO_BAD_DEBT);\n\n        uint256 ratio = totalAssetValue.div(totalDebtValue);\n\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 debt = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex).mul(ratio);\n            liquidationTarget[pool][token] = debt;\n        }\n    }\n\n    function liquidateByDODO(\n        address pool,\n        LiquidationOrder calldata order,\n        bytes calldata routeData,\n        address router\n    ) external onlyLiquidator nonReentrant {\n        uint256 toTokenReserve = IERC20(order.toToken).balanceOf(address(this));\n        uint256 fromTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.fromToken), order.fromAmount);\n\n        // swap using Route\n        {\n            IERC20(order.fromToken).transferFrom(pool, router, order.fromAmount);\n            (bool success, bytes memory data) = router.call(routeData);\n            if (!success) {\n                assembly {\n                    revert(add(data, 32), mload(data))\n                }\n            }\n        }\n\n        // the transferred-in toToken USD value should not be less than 95% of the transferred-out fromToken\n        uint256 receivedToToken = IERC20(order.toToken).balanceOf(address(this)) - toTokenReserve;\n        uint256 toTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.toToken), receivedToToken);\n\n        require(toTokenValue.div(fromTokenValue) >= DISCOUNT, Errors.EXCEED_DISCOUNT);\n        IERC20(order.toToken).safeTransfer(pool, receivedToToken);\n        ID3MM(pool).updateReserveByVault(order.fromToken);\n        ID3MM(pool).updateReserveByVault(order.toToken);\n    }\n\n    function finishLiquidation(address pool) external onlyLiquidator nonReentrant {\n        require(ID3MM(pool).isInLiquidation(), Errors.NOT_IN_LIQUIDATION);\n        accrueInterests();\n\n        bool hasPositiveBalance;\n        bool hasNegativeBalance;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            uint256 balance = IERC20(token).balanceOf(pool);\n            uint256 debt = liquidationTarget[pool][token];\n            int256 difference = int256(balance) - int256(debt);\n            if (difference > 0) {\n                require(!hasNegativeBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasPositiveBalance = true;\n            } else if (difference < 0) {\n                require(!hasPositiveBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasNegativeBalance = true;\n                debt = balance; // if balance is less than target amount, just repay with balance\n            }\n\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 borrows = record.amount;\n            if (borrows == 0) continue;\n\n            // note: During liquidation process, the pool's debt will slightly increase due to the generated interests. \n            // The liquidation process will not repay the interests. Thus all dToken holders will share the loss equally.\n            uint256 realDebt = borrows.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n            IERC20(token).transferFrom(pool, address(this), debt);\n\n            info.totalBorrows = info.totalBorrows - realDebt;\n            record.amount = 0;\n        }\n\n        ID3MM(pool).finishLiquidation();\n    }\n}"
    }
  ]
}