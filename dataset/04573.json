{
  "Title": "Team can circumvent refund restriction",
  "Content": "The [`refund`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L201) function allows investors to ask for a refund if the minimum cap is not reached. Radical App International is given a share of tokens [at the beginning of the process](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L115) for which they should not be entitled to a refund. This is accounted for by [not allowing their address](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L203) to call `refund`. Since tokens are always transferable, they could easily circumvent this by transferring the tokens to another address and calling `refund` from it.\n\n\nConsider disallowing transfers until the crowdsale ends successfully, for example by using [OpenZeppelin’s `PausableToken`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/PausableToken.sol) or something similar. Not only will it fix this bug, but it’s also common practice.\n\n\nAlternatively, consider giving Radical App International its share of tokens at the successful finalization of the crowdsale.\n\n\n***Update:** Fixed with the alternative suggestion in the latest version.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Tokens/GMToken.sol",
      "content": "pragma solidity 0.4.17;\n\nimport 'contracts/Tokens/StandardToken.sol';\nimport 'contracts/Utils/SafeMath.sol';\n\n/// @title GMT Token - Main token sale contract\n/// @author Preethi Kasireddy - <preethi@preethireddy.com>\n\ncontract GMToken is StandardToken {\n\n    using SafeMath for uint256;\n\n    /*\n    *  Metadata\n    */\n    string public constant name = \"Global Messaging Token\";\n    string public constant symbol = \"GMT\";\n    uint256 public constant decimals = 18;\n\n    /*\n    *  Contract owner (Radical App International team)\n    */\n    address public owner;\n\n    /*\n    *  Hardware wallets\n    */\n    address public ethFundAddress;  // Address for ETH owned by Radical App International\n    address public gmtFundAddress;  // Address for GMT allocated to Radical App International\n\n    /*\n    *  List of registered participants\n    */\n    mapping (address => bool) public registered;\n\n    /*\n    *  Crowdsale parameters\n    */\n    Stages public stage;\n    uint256 public startBlock;  // Block number when sale period begins\n    uint256 public endBlock;  // Block number when sale period ends\n    uint256 public assignedSupply;  // Total GMT tokens currently assigned\n    uint256 public constant gmtFund = 500 * (10**6) * 10**decimals;  // 500M GMT reserved for development and user growth fund \n    uint256 public constant tokenExchangeRate = 4316;  // TODO: Units of GMT per ETH\n    uint256 public constant minCap = 100 * (10**6) * 10**decimals;  // 100M min cap to be sold during sale\n\n    /*\n    *  Events\n    */\n    event RefundSent(address indexed _to, uint256 _value);\n    event ClaimGMT(address indexed _to, uint256 _value);\n\n    enum Stages {\n        NotStarted,\n        InProgress,\n        Finalized,\n        Failed,\n        Stopped\n    }\n\n    modifier onlyBy(address _account){\n        require(msg.sender == _account);  \n        _;\n    }\n\n    function changeOwner(address _newOwner) onlyBy(owner) external {\n        owner = _newOwner;\n    }\n\n    modifier registeredUser() {\n        require(registered[msg.sender] == true);  \n        _;\n    }\n\n    modifier minCapReached() {\n        require(assignedSupply - gmtFund >= minCap);\n        _;\n    }\n\n    modifier respectTimeFrame() {\n        require((block.number >= startBlock) && (block.number < endBlock));\n        _;\n    }\n\n    modifier salePeriodCompleted() {\n        require(block.number >= endBlock);\n        _;\n    }\n\n    modifier atStage(Stages _stage) {\n        require(stage == _stage);\n        _;\n    }\n\n    /*\n    *  Constructor\n    */\n    function GMToken(\n        address _ethFundAddress,\n        address _gmtFundAddress,\n        uint256 _startBlock,\n        uint256 _endBlock) \n        public \n    {\n        require(_gmtFundAddress != 0x0);\n        require(_ethFundAddress != 0x0);\n\n        owner = msg.sender; // Creator of contract is owner\n        stage = Stages.NotStarted; \n        ethFundAddress = _ethFundAddress;\n        gmtFundAddress = _gmtFundAddress;\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n        totalSupply = 1000 * (10**6) * 10**decimals;  // 1B total GMT tokens\n        balances[gmtFundAddress] = gmtFund;  // Deposit Radical App International share into Multi-sig\n        assignedSupply = gmtFund;  // Set starting assigned supply to amount assigned for GMT fund\n        ClaimGMT(gmtFundAddress, gmtFund);  // Log Radical App International fund\n        // As per ERC20 spec, a token contract which creates new tokens SHOULD trigger a Transfer event with the _from address\n        // set to 0x0 when tokens are created (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md)\n        Transfer(0x0, gmtFundAddress, gmtFund);\n    }\n\n    /// @notice Start sale\n    /// @dev Only allowed to be called by the owner\n    function startSale() onlyBy(owner) external {\n        stage = Stages.InProgress;\n    }\n\n    /// @notice Stop sale in case of emergency (i.e. circuit breaker)\n    /// @dev Only allowed to be called by the owner\n    function stopSale() onlyBy(owner) external {\n        stage = Stages.Stopped;\n    }\n\n    /// @notice Set sale to failed state\n    /// @dev Only allowed to be called by the owner\n    function setFailedState() onlyBy(owner) external {\n        stage = Stages.Failed;\n    }\n\n    /// @notice Create `msg.value` ETH worth of GMT\n    /// @dev Only allowed to be called within the timeframe of the sale period\n    function claimTokens() respectTimeFrame registeredUser atStage(Stages.InProgress) payable external {\n        require(msg.value > 0);\n\n        // Check that we're not over totals\n        uint256 tokens = msg.value.mul(tokenExchangeRate); \n        uint256 checkedSupply = assignedSupply.add(tokens);\n\n        // Return money if we're over total token supply\n        require(checkedSupply <= totalSupply); \n\n        balances[msg.sender] += tokens;\n        assignedSupply = checkedSupply;\n        ClaimGMT(msg.sender, tokens);  // Logs token creation for UI purposes\n    }\n\n\n    /// @notice Updates registration status of an address for sale participation\n    /// @param target Address that will be registered or deregistered\n    /// @param isRegistered New registration status of address\n    function changeRegistrationStatus(address target, bool isRegistered) public onlyBy(owner) {\n        registered[target] = isRegistered;\n    }\n\n    /// @notice Updates registration status for multiple addresses for participation\n    /// @param targets Addresses that will be registered or deregistered\n    /// @param isRegistered New registration status of addresses\n    function changeRegistrationStatuses(address[] targets, bool isRegistered) public onlyBy(owner) {\n        for (uint i = 0; i < targets.length; i++) {\n            changeRegistrationStatus(targets[i], isRegistered);\n        }\n    }\n\n    /// @notice Ends the funding period and sends the ETH to Multi-sig wallet\n    /// @dev Only allowed to be called by the owner once sale period is over and the min cap is reached\n    function finalize() \n        onlyBy(owner) \n        atStage(Stages.InProgress) \n        minCapReached \n        salePeriodCompleted\n        external\n    {\n        stage = Stages.Finalized;\n\n        // In the case where not all 500M GMT allocated to crowdfund participants\n        // is sold, send the remaining unassigned supply to GMT fund address,\n        // which will then be used to fund the user growth pool.\n        if (assignedSupply < totalSupply) {\n            uint256 unassignedSupply = totalSupply.sub(assignedSupply);\n            balances[gmtFundAddress] += unassignedSupply;\n            assignedSupply = assignedSupply.add(unassignedSupply);\n        }\n\n        ethFundAddress.transfer(this.balance);\n    }\n\n    /// @notice Allows contributors to recover their ETH in the case of a failed token sale\n    /// @dev Only allowed to be called once sale period is over IF the min cap is not reached\n    /// @return bool True if refund successfully sent, false otherwise\n    function refund() registeredUser atStage(Stages.Failed) salePeriodCompleted external returns (bool) {\n        require(assignedSupply - gmtFund < minCap);  // No refunds if we reached min cap\n        require(msg.sender != gmtFundAddress);  // Radical App International not entitled to a refund\n\n        uint256 gmtVal = balances[msg.sender];\n        require(gmtVal > 0); // Prevent refund if sender GMT balance is 0\n\n        balances[msg.sender] -= gmtVal;\n        assignedSupply = assignedSupply.sub(gmtVal); // Adjust assigned supply to account for refunded amount\n        \n        uint256 ethVal = gmtVal.div(tokenExchangeRate); // Covert GMT to ETH\n\n        msg.sender.transfer(ethVal);\n        \n        RefundSent(msg.sender, ethVal);  // Log successful refund \n        \n        return true;\n    }\n\n    /*\n        NOTE: We explicitly do not define a fallback function, in order to prevent \n        receiving Ether for no reason. As noted in Solidity documentation, contracts \n        that receive Ether directly (without a function call, i.e. using send or transfer)\n        but do not define a fallback function throw an exception, sending back the Ether (this was different before Solidity v0.4.0).\n    */\n}"
    }
  ]
}