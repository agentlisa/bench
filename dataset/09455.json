{
  "Title": "[G-08] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
  "Content": "\n1.  File: contracts/TopNMarketCapIndex.sol (line [74](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/TopNMarketCapIndex.sol#L74))\n\n```solidity\n                revert(\"TopNMarketCapIndex: REWEIGH_FAILED\");\n```\n\n2.  File: contracts/TopNMarketCapReweightingLogic.sol (line [67](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/TopNMarketCapReweightingLogic.sol#L67))\n\n```solidity\n                require(IAccessControl(registry).hasRole(ASSET_ROLE, asset), \"TopNMarketCapIndex: INVALID_ASSET\");\n```\n\n3.  File: contracts/UniswapV2PathPriceOracle.sol (line [25](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PathPriceOracle.sol#L25))\n\n```solidity\n        require(_oracles.length == _path.length - 1, \"UniswapV2PathPriceOracle: ORACLES\");\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-04-phuture-finance-contest",
  "Code": [
    {
      "filename": "contracts/TopNMarketCapIndex.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"./interfaces/IIndexFactory.sol\";\nimport \"./interfaces/IReweightableIndex.sol\";\nimport \"./interfaces/ITopNMarketCapIndexReweightingLogic.sol\";\n\nimport \"./BaseIndex.sol\";\n\n/// @title Top N market capitalization index\n/// @notice Contains initialization and reweighting logic\n/// @dev This index reweighs according to the latest data from the TopNMarketCapCategories contract\ncontract TopNMarketCapIndex is IReweightableIndex, BaseIndex {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Orderer role\n    bytes32 internal constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n\n    /// @notice Number of assets used in the index\n    uint8 public topN;\n    /// @notice Category identifier used for the given index\n    uint public category;\n\n    /// @notice Latest category snapshot to track diff\n    uint private snapshot;\n\n    constructor() BaseIndex(msg.sender) {}\n\n    /// @notice Initializes index with provided set of parameters\n    /// @param _topN Number of assets used in the index\n    /// @param _category Category identifier used for the given index\n    /// @param _snapshot Initial snapshot from the category\n    /// @param _assets Assets list\n    /// @param _capitalizations List of corresponding assets capitalizations\n    /// @param _totalCapitalization Total capitalization of assets\n    function initialize(\n        uint8 _topN,\n        uint _category,\n        uint _snapshot,\n        address[] calldata _assets,\n        uint[] calldata _capitalizations,\n        uint _totalCapitalization\n    ) external {\n        require(msg.sender == factory, \"TopNMarketCapIndex: FORBIDDEN\");\n\n        uint8 _totalWeight;\n        for (uint i; i < _assets.length; ++i) {\n            uint _i = _assets.length - 1 - i;\n            address asset = _assets[_i];\n            uint8 weight = _i == 0\n                ? IndexLibrary.MAX_WEIGHT - _totalWeight\n                : uint8((_capitalizations[_i] * type(uint8).max) / _totalCapitalization);\n            weightOf[asset] = weight;\n            require(asset != address(0), \"TopNMarketCapIndex: ZERO\");\n            if (weight > 0) {\n                assets.add(asset);\n                _totalWeight += weight;\n                emit UpdateAnatomy(asset, weight);\n            }\n        }\n        snapshot = _snapshot;\n        category = _category;\n        topN = _topN;\n    }\n\n    /// @notice Reweighs index assets according to the latest market cap data for specified category\n    function reweight() external override onlyRole(ORDERER_ROLE) {\n        (bool success, bytes memory data) = IIndexFactory(factory).reweightingLogic().delegatecall(\n            abi.encodeWithSelector(ITopNMarketCapIndexReweightingLogic.reweight.selector, category, snapshot, topN)\n        );\n        if (!success) {\n            if (data.length == 0) {\n                revert(\"TopNMarketCapIndex: REWEIGH_FAILED\");\n            } else {\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n        snapshot = abi.decode(data, (uint));\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IReweightableIndex).interfaceId || super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/TopNMarketCapReweightingLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"./libraries/IndexLibrary.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IOrderer.sol\";\nimport \"./interfaces/IvTokenFactory.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\nimport \"./interfaces/ITopNMarketCapCategories.sol\";\nimport \"./interfaces/ITopNMarketCapIndexFactory.sol\";\nimport \"./interfaces/ITopNMarketCapIndexReweightingLogic.sol\";\n\nimport \"./IndexLayout.sol\";\n\n/// @title TopNMarketCapIndex reweighing logic\n/// @notice Contains reweighting logic\ncontract TopNMarketCapIndexReweightingLogic is IndexLayout, ITopNMarketCapIndexReweightingLogic, ERC165 {\n    using FullMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Asset role\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n\n    /// @inheritdoc ITopNMarketCapIndexReweightingLogic\n    function reweight(\n        uint _category,\n        uint _snapshotId,\n        uint _topN\n    ) external override returns (uint) {\n        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());\n        uint virtualEvaluationInBase;\n        for (uint i; i < assets.length(); ++i) {\n            uint priceAssetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));\n            uint availableAssets = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)))\n                .assetBalanceOf(address(this));\n            virtualEvaluationInBase += availableAssets.mulDiv(FixedPoint112.Q112, priceAssetPerBaseInUQ);\n        }\n        ITopNMarketCapCategories.DiffDetails memory diff = ITopNMarketCapCategories(\n            ITopNMarketCapIndexFactory(factory).marketCapCategories()\n        ).assetDiff(_category, _snapshotId, _topN);\n\n        IOrderer orderer = IOrderer(IIndexRegistry(registry).orderer());\n        uint orderId = orderer.placeOrder();\n\n        uint8 _totalWeight;\n        for (uint _i; _i < diff.assetCount; ++_i) {\n            uint i = diff.assetCount - 1 - _i;\n            address asset = diff.assets[i].asset;\n            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(asset));\n            if (diff.assets[i].isRemoved) {\n                {\n                    uint shares = vToken.balanceOf(address(this));\n                    if (shares > 0) {\n                        inactiveAssets.add(asset);\n                    }\n                    delete weightOf[asset];\n                    assets.remove(asset);\n                    emit UpdateAnatomy(asset, 0);\n                }\n            } else {\n                // diff guarantees that updated assets go before the removed assets\n                require(IAccessControl(registry).hasRole(ASSET_ROLE, asset), \"TopNMarketCapIndex: INVALID_ASSET\");\n                {\n                    uint8 weight;\n                    if (i == 0) {\n                        weight = IndexLibrary.MAX_WEIGHT - _totalWeight;\n                    } else {\n                        weight = uint8(\n                            (diff.assets[i].capitalizationInBase * type(uint8).max) / diff.totalCapitalizationInBase\n                        );\n                    }\n                    weightOf[asset] = weight;\n                    _totalWeight += weight;\n                    if (weight > 0) {\n                        assets.add(asset);\n                        inactiveAssets.remove(asset);\n                    } else {\n                        assets.remove(asset);\n                        inactiveAssets.add(asset);\n                    }\n                    emit UpdateAnatomy(asset, weight);\n                }\n                {\n                    uint amountInBase = (virtualEvaluationInBase * weightOf[asset]) / IndexLibrary.MAX_WEIGHT;\n                    uint amountInAsset = amountInBase.mulDiv(\n                        oracle.refreshedAssetPerBaseInUQ(asset),\n                        FixedPoint112.Q112\n                    );\n                    (uint newShares, uint oldShares) = vToken.shareChange(address(this), amountInAsset);\n                    if (newShares > oldShares) {\n                        orderer.addOrderDetails(orderId, asset, newShares - oldShares, IOrderer.OrderSide.Buy);\n                    } else if (oldShares > newShares) {\n                        orderer.addOrderDetails(orderId, asset, oldShares - newShares, IOrderer.OrderSide.Sell);\n                    }\n                }\n            }\n        }\n        address[] memory _inactiveAssets = inactiveAssets.values();\n        for (uint i; i < _inactiveAssets.length; ++i) {\n            uint shares = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(_inactiveAssets[i])).balanceOf(address(this));\n            if (shares > 0) {\n                orderer.addOrderDetails(orderId, _inactiveAssets[i], shares, IOrderer.OrderSide.Sell);\n            } else {\n                inactiveAssets.remove(_inactiveAssets[i]);\n            }\n        }\n        return diff.snapshotId;\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(ITopNMarketCapIndexReweightingLogic).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/UniswapV2PathPriceOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"./libraries/FullMath.sol\";\nimport \"./libraries/FixedPoint112.sol\";\n\nimport \"./interfaces/IUniswapV2PriceOracle.sol\";\nimport \"./interfaces/IUniswapV2PathPriceOracle.sol\";\n\n/// @title Uniswap path price oracle\n/// @notice Contains logic for price calculation of asset which doesn't have a pair with a base asset\ncontract UniswapV2PathPriceOracle is IUniswapV2PathPriceOracle, ERC165 {\n    using FullMath for uint;\n\n    /// @notice List of assets to compose exchange pairs, where first element is input asset\n    address[] private path;\n    /// @notice List of corresponding price oracles for provided path\n    address[] private oracles;\n\n    constructor(address[] memory _path, address[] memory _oracles) {\n        require(_path.length >= 2, \"UniswapV2PathPriceOracle: PATH\");\n        require(_oracles.length == _path.length - 1, \"UniswapV2PathPriceOracle: ORACLES\");\n\n        path = _path;\n        oracles = _oracles;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint currentAssetPerBaseInUQ) {\n        currentAssetPerBaseInUQ = FixedPoint112.Q112;\n        for (uint i = 0; i < path.length - 1; i++) {\n            address asset = path[i + 1];\n            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(\n                IUniswapV2PriceOracle(oracles[i]).refreshedAssetPerBaseInUQ(asset),\n                FixedPoint112.Q112\n            );\n            if (_asset == asset) {\n                break;\n            }\n        }\n    }\n\n    /// @inheritdoc IPriceOracle\n    function lastAssetPerBaseInUQ(address _asset) external view override returns (uint currentAssetPerBaseInUQ) {\n        currentAssetPerBaseInUQ = FixedPoint112.Q112;\n        for (uint i = 0; i < path.length - 1; i++) {\n            address asset = path[i + 1];\n            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(\n                IUniswapV2PriceOracle(oracles[i]).lastAssetPerBaseInUQ(asset),\n                FixedPoint112.Q112\n            );\n            if (_asset == asset) {\n                break;\n            }\n        }\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IUniswapV2PathPriceOracle).interfaceId ||\n            _interfaceId == type(IPriceOracle).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IUniswapV2PathPriceOracle\n    function anatomy() public view virtual override returns (address[] memory _path, address[] memory _oracles) {\n        _path = path;\n        _oracles = oracles;\n    }\n}"
    }
  ]
}