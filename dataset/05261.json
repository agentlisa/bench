{
  "Title": "[L-02] - `withdrawArbitrageProfits()` will revert when `depositedWETH <= PoolUtils.DUST`",
  "Content": "\n`withdrawArbitrageProfits()` will revert when attempting [to withdraw](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/DAO.sol#L304) less than the dust amount, [because of a check on the pool](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/pools/Pools.sol#L222).\n\nThis is called [in step 2 of the Upkeep](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/Upkeep.sol#L114).\n\n### Recommendation\n\nSafely return when the `depositedWETH` is less than the pools dust:\n\n```diff\n    // The arbitrage profits are deposited in the Pools contract as WETH and owned by the DAO.\n    uint256 depositedWETH = pools.depositedUserBalance(address(this), weth );\n-   if ( depositedWETH == 0 )\n+   if ( depositedWETH <= PoolUtils.DUST )\n        return 0;\n\n    pools.withdraw( weth, depositedWETH );\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/dao/DAO.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"../rewards/interfaces/IRewardsEmitter.sol\";\nimport \"../rewards/interfaces/IRewardsConfig.sol\";\nimport \"../stable/interfaces/IStableConfig.sol\";\nimport \"../stable/interfaces/ILiquidizer.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../interfaces/IAccessManager.sol\";\nimport \"./interfaces/ICalledContract.sol\";\nimport \"./interfaces/IProposals.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"../pools/PoolUtils.sol\";\nimport \"./Parameters.sol\";\nimport \"../Upkeep.sol\";\n\n\n// Allows users to propose and vote on various governance actions such as changing parameters, whitelisting/unwhitelisting tokens, sending tokens, calling other contracts, and updating the website.\n// It handles proposing ballots, tracking votes, enforcing voting requirements, and executing approved proposals.\ncontract DAO is IDAO, Parameters, ReentrancyGuard\n    {\n\tevent BallotFinalized(uint256 indexed ballotID, Vote winningVote);\n    event SetContract(string indexed ballotName, address indexed contractAddress);\n    event SetWebsiteURL(string newURL);\n    event WhitelistToken(IERC20 indexed token);\n    event UnwhitelistToken(IERC20 indexed token);\n    event GeoExclusionUpdated(string country, bool excluded, uint256 geoVersion);\n    event ArbitrageProfitsWithdrawn(address indexed upkeepContract, IERC20 indexed weth, uint256 withdrawnAmount);\n    event SaltSent(address indexed to, uint256 amount);\n    event ContractCalled(address indexed contractAddress, uint256 indexed intArg);\n    event TeamRewardsTransferred(uint256 teamAmount);\n\n    event POLFormed(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 amountA, uint256 amountB);\n    event POLProcessed(uint256 claimedSALT);\n    event POLWithdrawn(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 withdrawnA, uint256 withdrawnB);\n\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IUSDS;\n\n\tIPools immutable public pools;\n\tIProposals immutable public proposals;\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIStakingConfig immutable public stakingConfig;\n\tIRewardsConfig immutable public rewardsConfig;\n\tIStableConfig immutable public stableConfig;\n\tIDAOConfig immutable public daoConfig;\n\tIPriceAggregator immutable public priceAggregator;\n\tIRewardsEmitter immutable public liquidityRewardsEmitter;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\tILiquidizer immutable public liquidizer;\n\n\tISalt immutable public salt;\n    IUSDS immutable public usds;\n\tIERC20 immutable public dai;\n\n\n\t// The default IPFS URL for the website content (can be changed with a setWebsiteURL proposal)\n\tstring public websiteURL;\n\n\t// Countries that have been excluded from access to the DEX (used by AccessManager.sol)\n\t// Keys as ISO 3166 Alpha-2 Codes\n\tmapping(string=>bool) public excludedCountries;\n\n\n    constructor( IPools _pools, IProposals _proposals, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig, IRewardsConfig _rewardsConfig, IStableConfig _stableConfig, IDAOConfig _daoConfig, IPriceAggregator _priceAggregator, IRewardsEmitter _liquidityRewardsEmitter, ICollateralAndLiquidity _collateralAndLiquidity )\n\t\t{\n\t\tpools = _pools;\n\t\tproposals = _proposals;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\t\trewardsConfig = _rewardsConfig;\n\t\tstableConfig = _stableConfig;\n\t\tdaoConfig = _daoConfig;\n\t\tpriceAggregator = _priceAggregator;\n        liquidityRewardsEmitter = _liquidityRewardsEmitter;\n        collateralAndLiquidity = _collateralAndLiquidity;\n \t\tliquidizer = collateralAndLiquidity.liquidizer();\n\n        usds = exchangeConfig.usds();\n        salt = exchangeConfig.salt();\n        dai = exchangeConfig.dai();\n\n\t\t// Gas saving approves for eventually forming Protocol Owned Liquidity\n\t\tsalt.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tusds.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tdai.approve(address(collateralAndLiquidity), type(uint256).max);\n\n\t\t// Excluded by default: United States, Canada, United Kingdom, China, India, Pakistan, Russia, Afghanistan, Cuba, Iran, North Korea, Syria, Venezuela\n\t\t// Note that the DAO can remove any of these exclusions - or open up access completely to the exchange as it sees fit.\n\t\texcludedCountries[\"US\"] = true;\n\t\texcludedCountries[\"CA\"] = true;\n\t\texcludedCountries[\"GB\"] = true;\n\t\texcludedCountries[\"CN\"] = true;\n\t\texcludedCountries[\"IN\"] = true;\n\t\texcludedCountries[\"PK\"] = true;\n\t\texcludedCountries[\"RU\"] = true;\n\t\texcludedCountries[\"AF\"] = true;\n\t\texcludedCountries[\"CU\"] = true;\n\t\texcludedCountries[\"IR\"] = true;\n\t\texcludedCountries[\"KP\"] = true;\n\t\texcludedCountries[\"SY\"] = true;\n\t\texcludedCountries[\"VE\"] = true;\n        }\n\n\n\t// Finalize the vote for a parameter ballot (increase, decrease or no_change) for a given parameter\n\tfunction _finalizeParameterBallot( uint256 ballotID ) internal\n\t\t{\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tVote winningVote = proposals.winningParameterVote(ballotID);\n\n\t\tif ( winningVote == Vote.INCREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), true, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\t\telse if ( winningVote == Vote.DECREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), false, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\n\t\t// Finalize the ballot even if NO_CHANGE won\n\t\tproposals.markBallotAsFinalized(ballotID);\n\n\t\temit BallotFinalized(ballotID, winningVote);\n\t\t}\n\n\n\tfunction _executeSetContract( Ballot memory ballot ) internal\n\t\t{\n\t\tbytes32 nameHash = keccak256(bytes( ballot.ballotName ) );\n\n\t\tif ( nameHash == keccak256(bytes( \"setContract:priceFeed1_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 1, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed2_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 2, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed3_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 3, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:accessManager_confirm\" )) )\n\t\t\texchangeConfig.setAccessManager( IAccessManager(ballot.address1) );\n\n\t\temit SetContract(ballot.ballotName, ballot.address1);\n\t\t}\n\n\n\tfunction _executeSetWebsiteURL( Ballot memory ballot ) internal\n\t\t{\n\t\twebsiteURL = ballot.string1;\n\t\temit SetWebsiteURL(ballot.string1);\n\t\t}\n\n\n\tfunction _executeApproval( Ballot memory ballot ) internal\n\t\t{\n\t\tif ( ballot.ballotType == BallotType.UNWHITELIST_TOKEN )\n\t\t\t{\n\t\t\t// All tokens are paired with both WBTC and WETH so unwhitelist those pools\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\temit UnwhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.SEND_SALT )\n\t\t\t{\n\t\t\t// Make sure the contract has the SALT balance before trying to send it.\n\t\t\t// This should not happen but is here just in case - to prevent approved proposals from reverting on finalization.\n\t\t\tif ( exchangeConfig.salt().balanceOf(address(this)) >= ballot.number1 )\n\t\t\t\t{\n\t\t\t\tIERC20(exchangeConfig.salt()).safeTransfer( ballot.address1, ballot.number1 );\n\n\t\t\t\temit SaltSent(ballot.address1, ballot.number1);\n\t\t\t\t}\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.CALL_CONTRACT )\n\t\t\t{\n\t\t\tICalledContract(ballot.address1).callFromDAO( ballot.number1 );\n\n\t\t\temit ContractCalled(ballot.address1, ballot.number1);\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.INCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = false;\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, false, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.EXCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = true;\n\n\t\t\t// If the AccessManager doesn't implement excludedCountriesUpdated, this will revert and countries will not be able to be excluded until the AccessManager is working properly.\n\t\t\texchangeConfig.accessManager().excludedCountriesUpdated();\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, true, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\t// Once an initial setContract proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_CONTRACT )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_CONTRACT, ballot.address1, \"\", ballot.description );\n\n\t\t// Once an initial setWebsiteURL proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_WEBSITE_URL )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_WEBSITE_URL, address(0), ballot.string1, ballot.description );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_CONTRACT )\n\t\t\t_executeSetContract( ballot );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_WEBSITE_URL )\n\t\t\t_executeSetWebsiteURL( ballot );\n\t\t}\n\n\n\t// Finalize the vote for an approval ballot (yes or no) for a given proposal\n\tfunction _finalizeApprovalBallot( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\t\t\t_executeApproval( ballot );\n\t\t\t}\n\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize and execute a token whitelisting ballot.\n\t// If the proposal is currently the whitelisting proposal with the most yes votes then the token can be whitelisted.\n\t// Only the top voted whitelisting proposal can be finalized - as whitelisting requires bootstrapping rewards to be sent from the DAO.\n\t// If NO > YES than the proposal is removed immediately (quorum would already have been determined - in canFinalizeBallot as called from finalizeBallot).\n\tfunction _finalizeTokenWhitelisting( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\t// The ballot is approved. Any reversions below will allow the ballot to be attemped to be finalized later - as the ballot won't be finalized on reversion.\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\t\tuint256 bootstrappingRewards = daoConfig.bootstrappingRewards();\n\n\t\t\t// Make sure that the DAO contract holds the required amount of SALT for bootstrappingRewards.\n\t\t\t// Twice the bootstrapping rewards are needed (for both the token/WBTC and token/WETH pools)\n\t\t\tuint256 saltBalance = exchangeConfig.salt().balanceOf( address(this) );\n\t\t\trequire( saltBalance >= bootstrappingRewards * 2, \"Whitelisting is not currently possible due to insufficient bootstrapping rewards\" );\n\n\t\t\t// Fail to whitelist for now if this isn't the whitelisting proposal with the most votes - can try again later.\n\t\t\tuint256 bestWhitelistingBallotID = proposals.tokenWhitelistingBallotWithTheMostVotes();\n\t\t\trequire( bestWhitelistingBallotID == ballotID, \"Only the token whitelisting ballot with the most votes can be finalized\" );\n\n\t\t\t// All tokens are paired with both WBTC and WETH, so whitelist both pairings\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\tbytes32 pool1 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tbytes32 pool2 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\t// Send the initial bootstrappingRewards to promote initial liquidity on these two newly whitelisted pools\n\t\t\tAddedReward[] memory addedRewards = new AddedReward[](2);\n\t\t\taddedRewards[0] = AddedReward( pool1, bootstrappingRewards );\n\t\t\taddedRewards[1] = AddedReward( pool2, bootstrappingRewards );\n\n\t\t\texchangeConfig.salt().approve( address(liquidityRewardsEmitter), bootstrappingRewards * 2 );\n\t\t\tliquidityRewardsEmitter.addSALTRewards( addedRewards );\n\n\t\t\temit WhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\t// Mark the ballot as finalized (which will also remove it from the list of open token whitelisting proposals)\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize the vote on a specific ballot.\n\t// Can be called by anyone, but only actually finalizes the ballot if it can be finalized.\n\tfunction finalizeBallot( uint256 ballotID ) external nonReentrant\n\t\t{\n\t\t// Checks that ballot is live, and minimumEndTime and quorum have both been reached\n\t\trequire( proposals.canFinalizeBallot(ballotID), \"The ballot is not yet able to be finalized\" );\n\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tif ( ballot.ballotType == BallotType.PARAMETER )\n\t\t\t_finalizeParameterBallot(ballotID);\n\t\telse if ( ballot.ballotType == BallotType.WHITELIST_TOKEN )\n\t\t\t_finalizeTokenWhitelisting(ballotID);\n\t\telse\n\t\t\t_finalizeApprovalBallot(ballotID);\n\t\t}\n\n\n\t// Withdraw the WETH arbitrage profits deposited in the Pools contract and send them to the caller (the Upkeep contract).\n\tfunction withdrawArbitrageProfits( IERC20 weth ) external returns (uint256 withdrawnAmount)\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.withdrawArbitrageProfits is only callable from the Upkeep contract\" );\n\n\t\t// The arbitrage profits are deposited in the Pools contract as WETH and owned by the DAO.\n\t\tuint256 depositedWETH = pools.depositedUserBalance(address(this), weth );\n\t\tif ( depositedWETH == 0 )\n\t\t\treturn 0;\n\n\t\tpools.withdraw( weth, depositedWETH );\n\n\t\t// Check the WETH balance - in case any WETH was accidentally sent here previously\n\t\twithdrawnAmount = weth.balanceOf( address(this) );\n\t\tweth.safeTransfer( msg.sender, withdrawnAmount );\n\n\t\temit ArbitrageProfitsWithdrawn(msg.sender, weth, withdrawnAmount);\n\t\t}\n\n\n\t// Form SALT/USDS or USDS/DAI Protocol Owned Liquidity using the given amount of specified tokens.\n\t// Assumes that the tokens have already been transferred to this contract.\n\tfunction formPOL( IERC20 tokenA, IERC20 tokenB, uint256 amountA, uint256 amountB ) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.formPOL is only callable from the Upkeep contract\" );\n\n\t\t// Use zapping to form the liquidity so that all the specified tokens are used\n\t\tcollateralAndLiquidity.depositLiquidityAndIncreaseShare( tokenA, tokenB, amountA, amountB, 0, block.timestamp, true );\n\n\t\temit POLFormed(tokenA, tokenB, amountA, amountB);\n\t\t}\n\n\n\tfunction processRewardsFromPOL() external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.processRewardsFromPOL is only callable from the Upkeep contract\" );\n\n\t\t// The DAO owns SALT/USDS and USDS/DAI liquidity.\n\t\tbytes32[] memory poolIDs = new bytes32[](2);\n\t\tpoolIDs[0] = PoolUtils._poolID(salt, usds);\n\t\tpoolIDs[1] = PoolUtils._poolID(usds, dai);\n\n\t\tuint256 claimedSALT = collateralAndLiquidity.claimAllRewards(poolIDs);\n\t\tif ( claimedSALT == 0 )\n\t\t\treturn;\n\n\t\t// Send 10% of the rewards to the initial team\n\t\tuint256 amountToSendToTeam = claimedSALT / 10;\n\t\tsalt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), amountToSendToTeam );\n\t\temit TeamRewardsTransferred(amountToSendToTeam);\n\n\t\tuint256 remainingSALT = claimedSALT - amountToSendToTeam;\n\n\t\t// Burn a default 50% of the remaining SALT that was just claimed - the rest of the SALT stays in the DAO contract.\n\t\tuint256 saltToBurn = ( remainingSALT * daoConfig.percentPolRewardsBurned() ) / 100;\n\n\t\tsalt.safeTransfer( address(salt), saltToBurn );\n\t\tsalt.burnTokensInContract();\n\n\t\temit POLProcessed(claimedSALT);\n\t\t}\n\n\n\t// Withdraws the specified amount of the Protocol Owned Liquidity from the DAO and sends the underlying tokens to the Liquidizer to be burned as USDS as needed.\n\t// Called when the amount of recovered USDS from liquidating a user's WBTC/WETH collateral is insufficient to cover burning the USDS that they had borrowed.\n\t// Only callable from the Liquidizer contract.\n\tfunction withdrawPOL( IERC20 tokenA, IERC20 tokenB, uint256 percentToLiquidate ) external\n\t\t{\n\t\trequire(msg.sender == address(liquidizer), \"DAO.withdrawProtocolOwnedLiquidity is only callable from the Liquidizer contract\" );\n\n\t\tbytes32 poolID = PoolUtils._poolID(tokenA, tokenB);\n\t\tuint256 liquidityHeld = collateralAndLiquidity.userShareForPool( address(this), poolID );\n\t\tif ( liquidityHeld == 0 )\n\t\t\treturn;\n\n\t\tuint256 liquidityToWithdraw = (liquidityHeld * percentToLiquidate) / 100;\n\n\t\t// Withdraw the specified Protocol Owned Liquidity\n\t\t(uint256 reclaimedA, uint256 reclaimedB) = collateralAndLiquidity.withdrawLiquidityAndClaim(tokenA, tokenB, liquidityToWithdraw, 0, 0, block.timestamp );\n\n\t\t// Send the withdrawn tokens to the Liquidizer so that the tokens can be swapped to USDS and burned as needed.\n\t\ttokenA.safeTransfer( address(liquidizer), reclaimedA );\n\t\ttokenB.safeTransfer( address(liquidizer), reclaimedB );\n\n\t\temit POLWithdrawn(tokenA, tokenB, reclaimedA, reclaimedB);\n\t\t}\n\n\n\t// === VIEWS ===\n\n\tfunction countryIsExcluded( string calldata country ) external view returns (bool)\n\t\t{\n\t\treturn excludedCountries[country];\n\t\t}\n\t}"
    },
    {
      "filename": "src/Upkeep.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/finance/VestingWallet.sol\";\nimport \"./price_feed/interfaces/IPriceAggregator.sol\";\nimport \"./stable/interfaces/IStableConfig.sol\";\nimport \"./rewards/interfaces/IEmissions.sol\";\nimport \"./pools/interfaces/IPoolsConfig.sol\";\nimport \"./interfaces/IExchangeConfig.sol\";\nimport \"./dao/interfaces/IDAOConfig.sol\";\nimport \"./pools/interfaces/IPools.sol\";\nimport \"./dao/interfaces/IDAO.sol\";\n\n\n// Performs the following upkeep for each call to performUpkeep():\n// (Uses a maximum of 2.3 million gas with 100 whitelisted pools according to UpkeepGasUsage.t.sol)\n\n// 1. Swaps tokens previously sent to the Liquidizer contract for USDS and burns specified amounts of USDS.\n\n// 2. Withdraws existing WETH arbitrage profits from the Pools contract and rewards the caller of performUpkeep() with default 5% of the withdrawn amount.\n// 3. Converts a default 5% of the remaining WETH to USDS/DAI Protocol Owned Liquidity.\n// 4. Converts a default 20% of the remaining WETH to SALT/USDS Protocol Owned Liquidity.\n// 5. Converts remaining WETH to SALT and sends it to SaltRewards.\n\n// 6. Sends SALT Emissions to the SaltRewards contract.\n// 7. Distributes SALT from SaltRewards to the stakingRewardsEmitter and liquidityRewardsEmitter.\n// 8. Distributes SALT rewards from the stakingRewardsEmitter and liquidityRewardsEmitter.\n\n// 9. Collects SALT rewards from the DAO's Protocol Owned Liquidity (SALT/USDS from formed POL), sends 10% to the initial dev team and burns a default 50% of the remaining - the rest stays in the DAO.\n// 10. Sends SALT from the DAO vesting wallet to the DAO (linear distribution over 10 years).\n// 11. Sends SALT from the team vesting wallet to the team (linear distribution over 10 years).\n\n// WETH arbitrage profits are converted directly via depositSwapWithdraw - as performUpkeep is called often and the generated arbitrage profits should be manageable compared to the size of the reserves.\n// Additionally, simulations show that the impact from sandwich attacks on swap transactions (even without specifying slippage) is limited due to the atomic arbitrage process.\n// See PoolUtils.__placeInternalSwap and Sandwich.t.sol for more details.\n\ncontract Upkeep is IUpkeep, ReentrancyGuard\n    {\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IUSDS;\n\tusing SafeERC20 for IERC20;\n\n    event UpkeepError(string description, bytes error);\n\n\tIPools immutable public pools;\n\tIExchangeConfig  immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIDAOConfig immutable public daoConfig;\n\tIStableConfig immutable public stableConfig;\n\tIPriceAggregator immutable public priceAggregator;\n\tISaltRewards immutable public saltRewards;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\tIEmissions immutable public emissions;\n\tIDAO immutable public dao;\n\n\tIERC20  immutable public weth;\n\tISalt  immutable public salt;\n\tIUSDS  immutable public usds;\n\tIERC20  immutable public dai;\n\n\tuint256 public lastUpkeepTimeEmissions;\n\tuint256 public lastUpkeepTimeRewardsEmitters;\n\n\n    constructor( IPools _pools, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IDAOConfig _daoConfig, IStableConfig _stableConfig, IPriceAggregator _priceAggregator, ISaltRewards _saltRewards, ICollateralAndLiquidity _collateralAndLiquidity, IEmissions _emissions, IDAO _dao )\n\t\t{\n\t\tpools = _pools;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tdaoConfig = _daoConfig;\n\t\tstableConfig = _stableConfig;\n\t\tpriceAggregator = _priceAggregator;\n\t\tsaltRewards = _saltRewards;\n\t\tcollateralAndLiquidity = _collateralAndLiquidity;\n\t\temissions = _emissions;\n\t\tdao = _dao;\n\n\t\t// Cached for efficiency\n\t\tweth = _exchangeConfig.weth();\n\t\tsalt = _exchangeConfig.salt();\n\t\tusds = _exchangeConfig.usds();\n\t\tdai = _exchangeConfig.dai();\n\n\t\tlastUpkeepTimeEmissions = block.timestamp;\n\t\tlastUpkeepTimeRewardsEmitters = block.timestamp;\n\n\t\t// Approve for future WETH swaps.\n\t\t// This contract only has a temporary WETH balance within the performUpkeep() function itself.\n\t\tweth.approve( address(pools), type(uint256).max );\n\t\t}\n\n\n\tmodifier onlySameContract()\n\t\t{\n    \trequire(msg.sender == address(this), \"Only callable from within the same contract\");\n    \t_;\n\t\t}\n\n\n\t// Note - while the following steps are public so that they can be wrapped in a try/catch, they are all still only callable from this same contract.\n\n\t// 1. Swap tokens previously sent to the Liquidizer contract for USDS and burn specified amounts of USDS.\n\tfunction step1() public onlySameContract\n\t\t{\n\t\tcollateralAndLiquidity.liquidizer().performUpkeep();\n\t\t}\n\n\n\t// 2. Withdraw existing WETH arbitrage profits from the Pools contract and reward the caller of performUpkeep() with default 5% of the withdrawn amount.\n\tfunction step2(address receiver) public onlySameContract\n\t\t{\n\t\tuint256 withdrawnAmount = exchangeConfig.dao().withdrawArbitrageProfits(weth);\n\t\tif ( withdrawnAmount == 0 )\n\t\t\treturn;\n\n\t\t// Default 5% of the arbitrage profits for the caller of performUpkeep()\n\t\tuint256 rewardAmount = withdrawnAmount * daoConfig.upkeepRewardPercent() / 100;\n\n\t\t// Send the reward\n\t\tweth.safeTransfer(receiver, rewardAmount);\n\t\t}\n\n\n\t// Have the DAO form the specified Protocol Owned Liquidity with the given amount of WETH\n\tfunction _formPOL( IERC20 tokenA, IERC20 tokenB, uint256 amountWETH) internal\n\t\t{\n\t\tuint256 wethAmountPerToken = amountWETH >> 1;\n\n\t\t// Swap WETH for the specified tokens\n\t\tuint256 amountA = pools.depositSwapWithdraw( weth, tokenA, wethAmountPerToken, 0, block.timestamp );\n\t\tuint256 amountB = pools.depositSwapWithdraw( weth, tokenB, wethAmountPerToken, 0, block.timestamp );\n\n\t\t// Transfer the tokens to the DAO\n\t\ttokenA.safeTransfer( address(dao), amountA );\n\t\ttokenB.safeTransfer( address(dao), amountB );\n\n\t\t// Have the DAO form POL\n\t\tdao.formPOL(tokenA, tokenB, amountA, amountB);\n\t\t}\n\n\n\t// 3. Convert a default 5% of the remaining WETH to USDS/DAI Protocol Owned Liquidity.\n\tfunction step3() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// A default 5% of the remaining WETH will be swapped for USDS/DAI POL.\n\t\tuint256 amountOfWETH = wethBalance * stableConfig.percentArbitrageProfitsForStablePOL() / 100;\n\t\t_formPOL(usds, dai, amountOfWETH);\n\t\t}\n\n\n\t// 4. Convert a default 20% of the remaining WETH to SALT/USDS Protocol Owned Liquidity.\n\tfunction step4() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// A default 20% of the remaining WETH will be swapped for SALT/USDS POL.\n\t\tuint256 amountOfWETH = wethBalance * daoConfig.arbitrageProfitsPercentPOL() / 100;\n\t\t_formPOL(salt, usds, amountOfWETH);\n\t\t}\n\n\n\t// 5. Convert remaining WETH to SALT and sends it to SaltRewards.\n\tfunction step5() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// Convert remaining WETH to SALT and send it to SaltRewards\n\t\tuint256 amountSALT = pools.depositSwapWithdraw( weth, salt, wethBalance, 0, block.timestamp );\n\t\tsalt.safeTransfer(address(saltRewards), amountSALT);\n\t\t}\n\n\n\t// 6. Send SALT Emissions to the SaltRewards contract.\n\tfunction step6() public onlySameContract\n\t\t{\n\t\tuint256 timeSinceLastUpkeep = block.timestamp - lastUpkeepTimeEmissions;\n\t\temissions.performUpkeep(timeSinceLastUpkeep);\n\n\t\tlastUpkeepTimeEmissions = block.timestamp;\n\t\t}\n\n\n\t// 7. Distribute SALT from SaltRewards to the stakingRewardsEmitter and liquidityRewardsEmitter.\n\tfunction step7() public onlySameContract\n\t\t{\n\t\tuint256[] memory profitsForPools = pools.profitsForWhitelistedPools();\n\n\t\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\t\tsaltRewards.performUpkeep(poolIDs, profitsForPools );\n\t\tpools.clearProfitsForPools();\n\t\t}\n\n\n\t// 8. Distribute SALT rewards from the stakingRewardsEmitter and liquidityRewardsEmitter.\n\tfunction step8() public onlySameContract\n\t\t{\n\t\tuint256 timeSinceLastUpkeep = block.timestamp - lastUpkeepTimeRewardsEmitters;\n\n\t\tsaltRewards.stakingRewardsEmitter().performUpkeep(timeSinceLastUpkeep);\n\t\tsaltRewards.liquidityRewardsEmitter().performUpkeep(timeSinceLastUpkeep);\n\n\t\tlastUpkeepTimeRewardsEmitters = block.timestamp;\n\t\t}\n\n\n\t// 9. Collect SALT rewards from the DAO's Protocol Owned Liquidity (SALT/USDS from formed POL), send 10% to the initial dev team and burn a default 50% of the remaining - the rest stays in the DAO.\n\tfunction step9() public onlySameContract\n\t\t{\n\t\tdao.processRewardsFromPOL();\n\t\t}\n\n\n\t// 10. Send SALT from the DAO vesting wallet to the DAO (linear distribution over 10 years).\n\tfunction step10() public onlySameContract\n\t\t{\n\t\tVestingWallet(payable(exchangeConfig.daoVestingWallet())).release(address(salt));\n\t\t}\n\n\n\t// 11. Sends SALT from the team vesting wallet to the team (linear distribution over 10 years).\n\tfunction step11() public onlySameContract\n\t\t{\n\t\tuint256 releaseableAmount = VestingWallet(payable(exchangeConfig.teamVestingWallet())).releasable(address(salt));\n\n\t\t// teamVestingWallet actually sends the vested SALT to this contract - which will then need to be sent to the active teamWallet\n\t\tVestingWallet(payable(exchangeConfig.teamVestingWallet())).release(address(salt));\n\n\t\tsalt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), releaseableAmount );\n\t\t}\n\n\n\t// Perform the various steps of performUpkeep as outlined at the top of the contract.\n\t// Each step is wrapped in a try/catch to prevent reversions from cascading through the performUpkeep.\n\tfunction performUpkeep() public nonReentrant\n\t\t{\n\t\t// Perform the multiple steps of performUpkeep()\n \t\ttry this.step1() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 1\", error); }\n\n \t\ttry this.step2(msg.sender) {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 2\", error); }\n\n \t\ttry this.step3() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 3\", error); }\n\n \t\ttry this.step4() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 4\", error); }\n\n \t\ttry this.step5() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 5\", error); }\n\n \t\ttry this.step6() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 6\", error); }\n\n \t\ttry this.step7() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 7\", error); }\n\n \t\ttry this.step8() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 8\", error); }\n\n \t\ttry this.step9() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 9\", error); }\n\n \t\ttry this.step10() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 10\", error); }\n\n \t\ttry this.step11() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 11\", error); }\n\t\t}\n\n\n\t// ==== VIEWS ====\n\t// Returns the amount of WETH that will currently be rewarded for calling performUpkeep().\n\t// Useful for potential callers to know if calling the function will be profitable in comparison to current gas costs.\n\tfunction currentRewardsForCallingPerformUpkeep() public view returns (uint256)\n\t\t{\n\t\tuint256 daoWETH = pools.depositedUserBalance( address(dao), weth );\n\n\t\treturn daoWETH * daoConfig.upkeepRewardPercent() / 100;\n\t\t}\n\t}"
    }
  ]
}