{
  "Title": "[L-01] The first withdrawal for each vault from the vault reserve has no delay",
  "Content": "\n`_lastWithdrawal[vault]` will always be zero for new vaults, so the check is for `0 + minWithdrawalDelay` which will always be less than `block.timestamp`\n\n```solidity\nFile: backd/contracts/vault/VaultReserve.sol   #1\n\n102    function canWithdraw(address vault) public view returns (bool) {\n103        return block.timestamp >= _lastWithdrawal[vault] + minWithdrawalDelay;\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/VaultReserve.sol#L102-L103>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/vault/VaultReserve.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/IVaultReserve.sol\";\nimport \"../../libraries/Errors.sol\";\n\nimport \"../access/Authorization.sol\";\nimport \"../vault/Vault.sol\";\n\n/**\n * @notice Contract holding vault reserves\n * @dev ETH reserves are stored under address(0)\n */\ncontract VaultReserve is IVaultReserve, Authorization {\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant _INITIAL_WITHDRAWAL_DELAY = 3 days;\n\n    mapping(address => mapping(address => uint256)) private _balances;\n    mapping(address => uint256) private _lastWithdrawal;\n\n    uint256 public minWithdrawalDelay;\n\n    modifier onlyVault() {\n        require(_roleManager().hasRole(Roles.VAULT, msg.sender), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IRoleManager roleManager) Authorization(roleManager) {\n        minWithdrawalDelay = _INITIAL_WITHDRAWAL_DELAY;\n    }\n\n    /**\n     * @notice Deposit funds into vault reserve.\n     * @notice Only callable by a whitelisted vault.\n     * @param token Token to deposit.\n     * @param amount Amount to deposit.\n     * @return True if deposit was successful.\n     */\n    function deposit(address token, uint256 amount)\n        external\n        payable\n        override\n        onlyVault\n        returns (bool)\n    {\n        if (token == address(0)) {\n            require(msg.value == amount, Error.INVALID_AMOUNT);\n            _balances[msg.sender][token] += msg.value;\n            return true;\n        }\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBalance = IERC20(token).balanceOf(address(this));\n        uint256 received = newBalance - balance;\n        require(received >= amount, Error.INVALID_AMOUNT);\n        _balances[msg.sender][token] += received;\n        emit Deposit(msg.sender, token, amount);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw funds from vault reserve.\n     * @notice Only callable by a whitelisted vault.\n     * @param token Token to withdraw.\n     * @param amount Amount to withdraw.\n     * @return True if withdrawal was successful.\n     */\n    function withdraw(address token, uint256 amount) external override onlyVault returns (bool) {\n        require(canWithdraw(msg.sender), Error.RESERVE_ACCESS_EXCEEDED);\n        uint256 accountBalance = _balances[msg.sender][token];\n        require(accountBalance >= amount, Error.INSUFFICIENT_BALANCE);\n\n        _balances[msg.sender][token] -= amount;\n        _lastWithdrawal[msg.sender] = block.timestamp;\n\n        if (token == address(0)) {\n            payable(msg.sender).transfer(amount);\n        } else {\n            IERC20(token).safeTransfer(msg.sender, amount);\n        }\n        emit Withdraw(msg.sender, token, amount);\n        return true;\n    }\n\n    /**\n     * @notice Check token balance of a specific vault.\n     * @param vault Vault to check balance of.\n     * @param token Token to check balance in.\n     * @return Token balance of vault.\n     */\n    function getBalance(address vault, address token) public view override returns (uint256) {\n        return _balances[vault][token];\n    }\n\n    /**\n     * @notice returns true if the vault is allowed to withdraw from the reserve\n     */\n    function canWithdraw(address vault) public view returns (bool) {\n        return block.timestamp >= _lastWithdrawal[vault] + minWithdrawalDelay;\n    }\n}"
    }
  ]
}