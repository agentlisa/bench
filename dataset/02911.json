{
  "Title": "M-4: Stakers can have their funds locked for an extended period not related to the performance of their borrowers",
  "Content": "# Issue M-4: Stakers can have their funds locked for an extended period not related to the performance of their borrowers \n\nSource: https://github.com/sherlock-audit/2022-10-union-finance-judging/issues/114 \n\n## Found by \nhyh\n\n## Summary\n\nSome stakers will have their funds lent locked for an extended period of time as partial prepayments to vouch logic (i.e. what vouch to prepay if a borrower provided the funds) depends on vouch order in the borrower's `vouchers` array, while cancelVouch() breaks up the FIFO vouch order it initially was build on. \n\n## Vulnerability Detail\n\nWhile voucher array is initially ordered to favor the older lenders, i.e. in FIFO order, this initial order gets broken up over time as cancelVouch() places the very last lender (i.e. one who entered the latest) to the position of the removed one. This is a standard take on array element removal, which violates the redemption business logic in this case.\n\nAs a result stakers whose borrowers pay interest in full and do partial redemptions will have their funds locked with the lower priority in the prepayment queue just because some older vouch gets removed and a big vouch from the very end was moved before them.\n\nSay Mike the lender was `2nd` lender for Alice the borrower, who borrowed more funds from various stakers over time, say `5` in total, and have Bob the big lender placed `5th` on her vouchers array as he entered the last.\n\nNow Jade, Alice's `1st` lender, decided to remove the trust as she got payed back in full and the funds are needed elsewhere. `cancelVouch(Jade, Alice)` was called and Alice vouch array length is reduced to be `4`.\n\nBob gets placed `1st`, Mike is still `2nd`. Now suppose Mike lent Alice 1 year ago and it was `1k DAI`, while Bob lender yesterday and it was `10k DAI`. Now Alice prepayments will go towards Bob instead of Mike, who has his funds frozen until (and if) Bob's part be payed in full.\n\n## Impact\n\nNet impact is temporal funds freeze if Alice remains to be in good health, and permanent fund freeze if Alice stops paying before Mike's turn of the redemptions. I.e. the prepayment order can determine if Mike loan end up being paid or not. Bob has his situation improved on Mike's behalf, who has worsened perspectives of the overall repayment.\n\nThis funds freeze is conditional on cancelVouch() calls, but as it needs to be run with ordinary parameters (i.e. remove **any** old vouch) and it is a typical operation (it will be run from time to time by stakers as their `vouchees` array has limited size), while core UNION logic of lender to borrower correspondence is broken here, so setting the severity to be **high**.\n\n## Code Snippet\n\ncancelVouch() switches the vouch being removed with the last one: \n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L577-L591\n\n```solidity\n    function cancelVouch(address staker, address borrower) public onlyMember(msg.sender) whenNotPaused {\n        if (staker != msg.sender && borrower != msg.sender) revert AuthFailed();\n\n        Index memory voucherIndex = voucherIndexes[borrower][staker];\n        if (!voucherIndex.isSet) revert VoucherNotFound();\n\n        // Check that the locked amount for this vouch is 0\n        Vouch memory vouch = vouchers[borrower][voucherIndex.idx];\n        if (vouch.locked > 0) revert LockedStakeNonZero();\n\n        // Remove borrower from vouchers array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n        vouchers[borrower][voucherIndex.idx] = vouchers[borrower][vouchers[borrower].length - 1];\n        vouchers[borrower].pop();\n        delete voucherIndexes[borrower][staker];\n```\n\nThis logic is the classic take on array removal, but `vouchers[borrower]` array order is material, being used in updateLocked() assuming that array index is a good proxy for loan age, and adhering to the first in, first out logic:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L800-L841\n\n```solidity\n    function updateLocked(\n        address borrower,\n        uint96 amount,\n        bool lock\n    ) external onlyMarket {\n        uint96 remaining = amount;\n\n        for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n            Vouch storage vouch = vouchers[borrower][i];\n            uint96 innerAmount;\n\n            if (lock) {\n                // Look up the staker and determine how much unlock stake they\n                // have available for the borrower to borrow. If there is 0\n                // then continue to the next voucher in the array\n                uint96 stakerLocked = stakers[vouch.staker].locked;\n                uint96 stakerStakedAmount = stakers[vouch.staker].stakedAmount;\n                uint96 availableStake = stakerStakedAmount - stakerLocked;\n                uint96 lockAmount = _min(availableStake, vouch.trust - vouch.locked);\n                if (lockAmount == 0) continue;\n\n                // Calculate the amount to add to the lock then\n                // add the extra amount to lock to the stakers locked amount\n                // and also update the vouches locked amount and lastUpdated block\n                innerAmount = _min(remaining, lockAmount);\n                stakers[vouch.staker].locked = stakerLocked + innerAmount;\n                vouch.locked += innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            } else {\n                // Look up how much this vouch has locked. If it is 0 then\n                // continue to the next voucher. Then calculate the amount to\n                // unlock which is the min of the vouches lock and what is\n                // remaining to unlock\n                uint96 locked = vouch.locked;\n                if (locked == 0) continue;\n                innerAmount = _min(locked, remaining);\n\n                // Update the stored locked values and last updated block\n                stakers[vouch.staker].locked -= innerAmount;\n                vouch.locked -= innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            }\n```\n\nupdateLocked() is called when a borrower repays current debt interest in full:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/market/UToken.sol#L573-L619\n\n```solidity\n    function _repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 amount\n    ) internal {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n\n        uint256 interest = calculatingInterest(borrower);\n        uint256 borrowedAmount = borrowBalanceStoredInternal(borrower);\n        uint256 repayAmount = amount > borrowedAmount ? borrowedAmount : amount;\n        if (repayAmount == 0) revert AmountZero();\n\n        uint256 toReserveAmount;\n        uint256 toRedeemableAmount;\n\n        if (repayAmount >= interest) {\n        \t...\n\n            // Call update locked on the userManager to lock this borrowers stakers. This function\n            // will revert if the account does not have enough vouchers to cover the repay amount. ie\n            // the borrower is trying to repay more than is locked (owed)\n            IUserManager(userManager).updateLocked(borrower, uint96(repayAmount - interest), false);\n```\n\nWhich vouch to be updated by updateLocked(), i.e. where to allocate this new repayment if a borrower has many locked vouches, is material as it determines who gets the money back:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L432-L466\n\n```solidity\n    /**\n     *  @dev Get frozen coin age\n     *  @param  staker Address of staker\n     *  @param  pastBlocks Number of blocks past to calculate coin age from\n     *          coin age = min(block.number - lastUpdated, pastBlocks) * amount\n     */\n    function getFrozenInfo(address staker, uint256 pastBlocks)\n        public\n        view\n        returns (uint256 memberTotalFrozen, uint256 memberFrozenCoinAge)\n    {\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 voucheesLength = vouchees[staker].length;\n        // Loop through all of the stakers vouchees sum their total\n        // locked balance and sum their total memberFrozenCoinAge\n        for (uint256 i = 0; i < voucheesLength; i++) {\n            // Get the vouchee record and look up the borrowers voucher record\n            // to get the locked amount and lastUpdate block number\n            Vouchee memory vouchee = vouchees[staker][i];\n            Vouch memory vouch = vouchers[vouchee.borrower][vouchee.voucherIndex];\n\n            uint256 lastUpdated = vouch.lastUpdated;\n            uint256 diff = block.number - lastUpdated;\n\n            if (overdueBlocks < diff) {\n                uint96 locked = vouch.locked;\n                memberTotalFrozen += locked;\n                if (pastBlocks >= diff) {\n                    memberFrozenCoinAge += (locked * diff);\n                } else {\n                    memberFrozenCoinAge += (locked * pastBlocks);\n                }\n            }\n        }\n    }\n```\n\nThis can mean who gets the money faster or who gets the money at all, depending on the future behavior of the borrower.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nA simplest solution is to do it in a hard way and cycle through the whole array, for example:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L577-L591\n\n```solidity\n    function cancelVouch(address staker, address borrower) public onlyMember(msg.sender) whenNotPaused {\n        if (staker != msg.sender && borrower != msg.sender) revert AuthFailed();\n\n        Index memory voucherIndex = voucherIndexes[borrower][staker];\n        if (!voucherIndex.isSet) revert VoucherNotFound();\n\n        // Check that the locked amount for this vouch is 0\n        Vouch memory vouch = vouchers[borrower][voucherIndex.idx];\n        if (vouch.locked > 0) revert LockedStakeNonZero();\n\n        // Remove borrower from vouchers array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n+\t... // create new empty array\n+       for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n+           Vouch storage vouch = vouchers[borrower][i];\n+           ... // if `i <> voucherIndex.idx` and vouch has positive trust put it to the new array\n+\tfor (uint256 i = 0; i < vouchers[borrower].length; i++) {\n+           Vouch storage vouch = vouchers[borrower][i];\n+\t    ... // if `i <> voucherIndex.idx` and vouch has zero trust put it to the new array, keeping the old order among them this way\n+\t... // replace old `vouches` with new array\n-       vouchers[borrower][voucherIndex.idx] = vouchers[borrower][vouchers[borrower].length - 1];\n-       vouchers[borrower].pop();\n\n        delete voucherIndexes[borrower][staker];\n```\n\nIt can be feasible as `vouchers` length will not be big in the most cases, cancelVouch() isn't that frequent, and loan order is material for business logic to bear additional gas costs.\n\nAlso, this reorganisation of non-zero vouches first, zeros later eliminates the potential issue with stakers leaving vouchers with zero amounts just to keep the place in the redemption queue, which also doesn't adhere to FIFO logic.\n\n## Discussion\n\n**kingjacob**\n\nThis is as designed and a function of fifo. \n\n**dmitriia**\n\nThe issue is that `cancelVouch` as it is **breaks** FIFO.\n\nAs a result, the lenders can be compensated randomly, not according to FIFO.\n\n**kingjacob**\n\nIf cancel vouch changes the locked status of stakers of an outstanding borrow without a borrow or repay happening that would be very bad.\n\nBut if im understanding the report as borrower locks 1,2,3. Repays enough to unlock 1. 1 cancels. The order is now 3,2. That doesnt significantly change the risk for 2. The risk is still that the borrower you vouched doesnt repay. Theres maybe a marginal risk, But practically its hard to imagine this scenario occurring separate from a straight default or long repayment cycle. \n\nThat said strict FIFO would be preferred for ease of explanation but looping through changes the cost from 1 to n, with each n costing ~5000 gas per N. So its a tradeoff between this edgecase vs more people being able to afford to cancel bad or stale vouches. \n\n**dmitriia**\n\nYes, when the oldest vouch 1 is cancelled, the newest one 3 becomes the oldest, while the previous one, 2, keeps its place.\n\nThe implications of this isn't just a slight disturbing of the FIFO order, the resulting order can become fully random. This can be a material consideration for lenders and honest borrowers.\n\nSay Bob lends to Amelie through the system, while she is a big borrower with lots of connections, i.e. she is a vouchee for many vouchers, and use this trust a lot.\n\nNow Bob wants to have his money back and asks Amelie, who isn't insolvent and is able and willing to return the debt to Bob. But she can't as the system with repay the debts in nearly random order originated from the sequence of vouches cancellations and new vouches introductions.\n\nAs she can't return all debt to all the borrowers or any substantial part of them at this point, it is simply too much liquidity at once, this queue can't be cleared. Bob can't be repaid due to mere technical issue.\n\nThis means that the term of a loan cannot be deemed fixed even if both parties agree on it and do honour this agreement.\n\nBut rates do differ drastically depending on the term of a loan. This is the `yield curve` and it is steep most of the times. Current interest rate Union employs can be good for say 3 months loan, but insufficient for 3 years one.\n\nThis rate can't be just set higher as it is the matter of credit spread, the difference between this rate and risk-free rate for the *term* of a loan. Risk free rates for different terms are quite different, per risk free yield curve. \n\nFor example, if the rate is set to be high it will mean sufficient spread for longer terms, but overly big for shorter terms and honest borrowers will be reluctant to get loans, and vice versa.\n\nThat means keeping FIFO intact is crucial and very well justifies gas costs. Those can be kept lower via, for example, additional array `voucherOrder[borrower]` with historical order of the vouchers and accessing `vouchers` across the code not as `vouchers[borrower][i], i = 0, 1, ...`, but as `vouchers[borrower][voucherOrder[borrower][i]], i = 0, 1, ...`.\n\nThe code becomes:\n\n```solidity\n    function cancelVouch(address staker, address borrower) public onlyMember(msg.sender) whenNotPaused {\n        if (staker != msg.sender && borrower != msg.sender) revert AuthFailed();\n\n        Index memory voucherIndex = voucherIndexes[borrower][staker];\n        if (!voucherIndex.isSet) revert VoucherNotFound();\n\n        // Check that the locked amount for this vouch is 0\n        Vouch memory vouch = vouchers[borrower][voucherIndex.idx];\n        if (vouch.locked > 0) revert LockedStakeNonZero();\n\n+       bool memory reached;\n+       for (uint16 i = 0; i < voucherOrder[borrower].length - 1; i++) {\n+           if (!reached) {\n+               if (voucherOrder[borrower][i] == voucherIndex.idx) reached = true;\n+           }\n+           if (reached) voucherOrder[borrower][i] = voucherOrder[borrower][i + 1]\n+       }\n+       voucherOrder[borrower].pop();    \n\n        // Remove borrower from vouchers array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n        vouchers[borrower][voucherIndex.idx] = vouchers[borrower][vouchers[borrower].length - 1];\n        vouchers[borrower].pop();\n```\n\n`voucherOrder.push(vouchers[borrower].length)` needs to be done before pushing to `vouchers[borrower]` in updateTrust().\n\n**Evert0x**\n\nDowngrading to medium severity after discussions with senior, protocol and internally. \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/11",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/user/UserManager.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\nimport {IComptroller} from \"../interfaces/IComptroller.sol\";\nimport {IUnionToken} from \"../interfaces/IUnionToken.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\n/**\n * @title UserManager Contract\n * @dev Manages the Union members stake and vouches.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* -------------------------------------------------------------------\n      Types \n    ------------------------------------------------------------------- */\n\n    struct Vouch {\n        // staker recieveing the vouch\n        address staker;\n        // trust amount\n        uint96 trust;\n        // amount of stake locked by this vouch\n        uint96 locked;\n        // block number of last update\n        uint64 lastUpdated;\n    }\n\n    struct Staker {\n        bool isMember;\n        uint96 stakedAmount;\n        uint96 locked;\n    }\n\n    struct Index {\n        bool isSet;\n        uint128 idx;\n    }\n\n    struct Vouchee {\n        address borrower;\n        uint96 voucherIndex;\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Max amount that can be staked of the staking token\n     */\n    uint96 public maxStakeAmount;\n\n    /**\n     *  @dev The staking token that is staked in the comptroller\n     */\n    address public stakingToken;\n\n    /**\n     *  @dev Address of the UNION token contract\n     */\n    address public unionToken;\n\n    /**\n     *  @dev Address of the asset manager contract\n     */\n    address public assetManager;\n\n    /**\n     *  @dev uToken contract\n     */\n    IUToken public uToken;\n\n    /**\n     *  @dev Comptroller contract\n     */\n    IComptroller public comptroller;\n\n    /**\n     * @dev Number of vouches needed to become a member\n     */\n    uint256 public effectiveCount;\n\n    /**\n     *  @dev New member fee\n     */\n    uint256 public newMemberFee;\n\n    /**\n     *  @dev Total amount of staked staked token\n     */\n    uint256 public totalStaked;\n\n    /**\n     *  @dev Total amount of stake frozen\n     */\n    uint256 public totalFrozen;\n\n    /**\n     *  @dev Max blocks can be overdue for\n     */\n    uint256 public maxOverdueBlocks;\n\n    /**\n     * @dev Max voucher limit\n     */\n    uint256 public maxVouchers;\n\n    /**\n     *  @dev Union Stakers\n     */\n    mapping(address => Staker) public stakers;\n\n    /**\n     *  @dev Staker (borrower) mapped to recieved vouches (staker)\n     */\n    mapping(address => Vouch[]) public vouchers;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vouchers array\n     */\n    mapping(address => mapping(address => Index)) public voucherIndexes;\n\n    /**\n     *  @dev Staker (staker) mapped to vouches given (borrower)\n     */\n    mapping(address => Vouchee[]) public vouchees;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vochee array\n     */\n    mapping(address => mapping(address => Index)) public voucheeIndexes;\n\n    /**\n     * @dev Stakers frozen amounts\n     */\n    mapping(address => uint256) public memberFrozen;\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error AuthFailed();\n    error ErrorSelfVouching();\n    error TrustAmountLtLocked();\n    error NoExistingMember();\n    error NotEnoughStakers();\n    error StakeLimitReached();\n    error AssetManagerDepositFailed();\n    error AssetManagerWithdrawFailed();\n    error InsufficientBalance();\n    error LockedStakeNonZero();\n    error NotOverdue();\n    error ExceedsLocked();\n    error AmountZero();\n    error LockedRemaining();\n    error VoucherNotFound();\n    error VouchWhenOverdue();\n    error MaxVouchees();\n    error InvalidParams();\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Add new member event\n     *  @param member New member address\n     */\n    event LogAddMember(address member);\n\n    /**\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /**\n     *  @dev New member application event\n     *  @param account New member's voucher address\n     *  @param borrower New member address\n     */\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Cancel vouching for other member event\n     *  @param account New member's voucher address\n     *  @param borrower The address gets vouched for\n     */\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Stake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev Unstake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to unstake\n     */\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev DebtWriteOff event\n     *  @param staker The staker's address\n     *  @param borrower The borrower's address\n     *  @param amount The amount of write off\n     */\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    /**\n     *  @dev set utoken address\n     *  @param uToken new uToken address\n     */\n    event LogSetUToken(address uToken);\n\n    /**\n     *  @dev set new member fee\n     *  @param oldMemberFee old member fee\n     *  @param newMemberFee new member fee\n     */\n    event LogSetNewMemberFee(uint256 oldMemberFee, uint256 newMemberFee);\n\n    /**\n     *  @dev set max stake amount\n     *  @param oldMaxStakeAmount Old amount\n     *  @param newMaxStakeAmount New amount\n     */\n    event LogSetMaxStakeAmount(uint256 oldMaxStakeAmount, uint256 newMaxStakeAmount);\n\n    /**\n     *  @dev set max overdue blocks\n     *  @param oldMaxOverdueBlocks Old value\n     *  @param newMaxOverdueBlocks New value\n     */\n    event LogSetMaxOverdueBlocks(uint256 oldMaxOverdueBlocks, uint256 newMaxOverdueBlocks);\n\n    /**\n     *  @dev set effective count\n     *  @param oldEffectiveCount Old value\n     *  @param newEffectiveCount New value\n     */\n    event LogSetEffectiveCount(uint256 oldEffectiveCount, uint256 newEffectiveCount);\n\n    /**\n     * @dev Set max voucher\n     * @param maxVouchers new max voucher limit\n     */\n    event LogSetMaxVouchers(uint256 maxVouchers);\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address comptroller_,\n        address admin_,\n        uint256 maxOverdueBlocks_,\n        uint256 effectiveCount_,\n        uint256 maxVouchers_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1 ether;\n        maxStakeAmount = 10_000e18;\n        maxOverdueBlocks = maxOverdueBlocks_;\n        effectiveCount = effectiveCount_;\n        maxVouchers = maxVouchers_;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier onlyMember(address account) {\n        if (!checkIsMember(account)) revert AuthFailed();\n        _;\n    }\n\n    modifier onlyMarket() {\n        if (address(uToken) != msg.sender) revert AuthFailed();\n        _;\n    }\n\n    modifier onlyComptroller() {\n        if (address(comptroller) != msg.sender) revert AuthFailed();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Set the max amount that a user can stake\n     * Emits {LogSetMaxStakeAmount} event\n     * @param maxStakeAmount_ The max stake amount\n     */\n    function setMaxStakeAmount(uint96 maxStakeAmount_) external onlyAdmin {\n        uint96 oldMaxStakeAmount = maxStakeAmount;\n        maxStakeAmount = maxStakeAmount_;\n        emit LogSetMaxStakeAmount(uint256(oldMaxStakeAmount), uint256(maxStakeAmount));\n    }\n\n    /**\n     * @dev set the UToken contract address\n     * Emits {LogSetUToken} event\n     * @param uToken_ UToken contract address\n     */\n    function setUToken(address uToken_) external onlyAdmin {\n        uToken = IUToken(uToken_);\n        emit LogSetUToken(uToken_);\n    }\n\n    /**\n     * @dev set New Member fee\n     * @dev The amount of UNION an account must burn to become a member\n     * Emits {LogSetNewMemberFee} event\n     * @param amount New member fee amount\n     */\n    function setNewMemberFee(uint256 amount) external onlyAdmin {\n        uint256 oldMemberFee = newMemberFee;\n        newMemberFee = amount;\n        emit LogSetNewMemberFee(oldMemberFee, amount);\n    }\n\n    /**\n     * @dev set New max overdue blocks\n     * Emits {LogSetMaxOverdueBlocks} event\n     * @param _maxOverdueBlocks New maxOverdueBlocks value\n     */\n    function setMaxOverdueBlocks(uint256 _maxOverdueBlocks) external onlyAdmin {\n        uint256 oldMaxOverdueBlocks = maxOverdueBlocks;\n        maxOverdueBlocks = _maxOverdueBlocks;\n        emit LogSetMaxOverdueBlocks(oldMaxOverdueBlocks, _maxOverdueBlocks);\n    }\n\n    /**\n     * @dev set New effective count\n     * @dev this is the number of vouches an account needs in order\n     *      to register as a member\n     * Emits {LogSetEffectiveCount} event\n     * @param _effectiveCount New effectiveCount value\n     */\n    function setEffectiveCount(uint256 _effectiveCount) external onlyAdmin {\n        uint256 oldEffectiveCount = effectiveCount;\n        effectiveCount = _effectiveCount;\n        emit LogSetEffectiveCount(oldEffectiveCount, _effectiveCount);\n    }\n\n    function setMaxVouchers(uint256 _maxVouchers) external onlyAdmin {\n        maxVouchers = _maxVouchers;\n        emit LogSetMaxVouchers(_maxVouchers);\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     */\n    function checkIsMember(address account) public view returns (bool) {\n        return stakers[account].isMember;\n    }\n\n    /**\n     *  @dev  Get the member's available credit limit\n     *  @dev  IMPORTANT: This function can take up a tonne of gas as the vouchers[address] array\n     *        grows in size. the maxVoucher limit will ensure this function can always run within a\n     *        single block but it is intended only to be used as a view function called from a UI\n     *  @param borrower Member address\n     *  @return total Credit line amount\n     */\n    function getCreditLimit(address borrower) external view returns (uint256 total) {\n        for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n            Vouch memory vouch = vouchers[borrower][i];\n            Staker memory staker = stakers[vouch.staker];\n            total += _min(staker.stakedAmount - staker.locked, vouch.trust - vouch.locked);\n        }\n    }\n\n    /**\n     *  @dev  Get the count of vouchers\n     *        Vouchers are addresses that this borrower is recieving a vouch from.\n     *  @param borrower Address of borrower\n     */\n    function getVoucherCount(address borrower) external view returns (uint256) {\n        return vouchers[borrower].length;\n    }\n\n    /**\n     *  @dev  Get the count of vouchees\n     *        Voucheers are addresses that this staker is vouching for\n     *  @param staker Address of staker\n     */\n    function getVoucheeCount(address staker) external view returns (uint256) {\n        return vouchees[staker].length;\n    }\n\n    /**\n     *  @dev Get the user's deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) external view returns (uint256) {\n        return stakers[account].stakedAmount;\n    }\n\n    /**\n     *  @dev Get frozen coin age\n     *  @param  staker Address of staker\n     *  @param  pastBlocks Number of blocks past to calculate coin age from\n     *          coin age = min(block.number - lastUpdated, pastBlocks) * amount\n     */\n    function getFrozenInfo(address staker, uint256 pastBlocks)\n        public\n        view\n        returns (uint256 memberTotalFrozen, uint256 memberFrozenCoinAge)\n    {\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 voucheesLength = vouchees[staker].length;\n        // Loop through all of the stakers vouchees sum their total\n        // locked balance and sum their total memberFrozenCoinAge\n        for (uint256 i = 0; i < voucheesLength; i++) {\n            // Get the vouchee record and look up the borrowers voucher record\n            // to get the locked amount and lastUpdate block number\n            Vouchee memory vouchee = vouchees[staker][i];\n            Vouch memory vouch = vouchers[vouchee.borrower][vouchee.voucherIndex];\n\n            uint256 lastUpdated = vouch.lastUpdated;\n            uint256 diff = block.number - lastUpdated;\n\n            if (overdueBlocks < diff) {\n                uint96 locked = vouch.locked;\n                memberTotalFrozen += locked;\n                if (pastBlocks >= diff) {\n                    memberFrozenCoinAge += (locked * diff);\n                } else {\n                    memberFrozenCoinAge += (locked * pastBlocks);\n                }\n            }\n        }\n    }\n\n    /**\n     *  @dev Get Total locked stake\n     *  @param staker Staker address\n     */\n    function getTotalLockedStake(address staker) external view returns (uint256) {\n        return stakers[staker].locked;\n    }\n\n    /**\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     */\n    function getLockedStake(address staker, address borrower) external view returns (uint256) {\n        Index memory index = voucherIndexes[borrower][staker];\n        if (!index.isSet) return 0;\n        return vouchers[borrower][index.idx].locked;\n    }\n\n    /**\n     *  @dev Get vouching amount\n     *  @param _staker Staker address\n     *  @param borrower Borrower address\n     */\n    function getVouchingAmount(address _staker, address borrower) external view returns (uint256) {\n        Index memory index = voucherIndexes[borrower][_staker];\n        Staker memory staker = stakers[_staker];\n        if (!index.isSet) return 0;\n        uint96 trustAmount = vouchers[borrower][index.idx].trust;\n        return trustAmount < staker.stakedAmount ? trustAmount : staker.stakedAmount;\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Manually add union members and bypass all the requirements of `registerMember`\n     *  Only accepts calls from the admin\n     *  Emit {LogAddMember} event\n     *  @param account Member address\n     */\n    function addMember(address account) external onlyAdmin {\n        stakers[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /**\n     *  @dev  Update the trust amount for exisitng members.\n     *  @dev  Trust is the amount of the underlying token you would in theory be\n     *        happy to lend to another member. Vouch is derived from trust and stake.\n     *        Vouch is the minimum of trust and staked amount.\n     *  Emits {LogUpdateTrust} event\n     *  @param borrower Account address\n     *  @param trustAmount Trust amount\n     */\n    function updateTrust(address borrower, uint96 trustAmount) external onlyMember(msg.sender) whenNotPaused {\n        address staker = msg.sender;\n        if (borrower == staker) revert ErrorSelfVouching();\n        if (!checkIsMember(staker)) revert AuthFailed();\n\n        // Check if this staker is already vouching for this borrower\n        // If they are already vouching then update the existing vouch record\n        // If this is a new vouch then insert a new Vouch record\n        Index memory index = voucherIndexes[borrower][staker];\n        if (index.isSet) {\n            // Update existing record checking that the new trust amount is\n            // not less than the amount of stake currently locked by the borrower\n            Vouch storage vouch = vouchers[borrower][index.idx];\n            if (trustAmount < vouch.locked) revert TrustAmountLtLocked();\n            vouch.trust = trustAmount;\n        } else {\n            // If the member is overdue they cannot create new vouches they can\n            // only update existing vouches\n            if (uToken.checkIsOverdue(staker)) revert VouchWhenOverdue();\n\n            // This is a new vouch so we need to check that the\n            // member has not reached the max voucher limit\n            uint256 voucheesLength = vouchees[staker].length;\n            if (voucheesLength >= maxVouchers) revert MaxVouchees();\n\n            // Get the new index that this vouch is going to be inserted at\n            // Then update the voucher indexes for this borrower as well as\n            // Adding the Vouch the the vouchers array for this staker\n            uint256 voucherIndex = vouchers[borrower].length;\n            voucherIndexes[borrower][staker] = Index(true, uint128(voucherIndex));\n            vouchers[borrower].push(Vouch(staker, trustAmount, 0, 0));\n\n            // Add the voucherIndex of this new vouch to the vouchees array for this\n            // staker then update the voucheeIndexes with the voucheeIndex\n            uint256 voucheeIndex = voucheesLength;\n            vouchees[staker].push(Vouchee(borrower, uint96(voucherIndex)));\n            voucheeIndexes[borrower][staker] = Index(true, uint128(voucheeIndex));\n        }\n\n        emit LogUpdateTrust(staker, borrower, trustAmount);\n    }\n\n    /**\n     *  @dev Remove voucher for memeber\n     *  Can be called by either the borrower or the staker. It will remove the voucher from\n     *  the voucher array by replacing it with the last item of the array and reseting the array\n     *  size to -1 by poping off the last item\n     *  Only callable by a member when the contract is not paused\n     *  Emit {LogCancelVouch} event\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) public onlyMember(msg.sender) whenNotPaused {\n        if (staker != msg.sender && borrower != msg.sender) revert AuthFailed();\n\n        Index memory voucherIndex = voucherIndexes[borrower][staker];\n        if (!voucherIndex.isSet) revert VoucherNotFound();\n\n        // Check that the locked amount for this vouch is 0\n        Vouch memory vouch = vouchers[borrower][voucherIndex.idx];\n        if (vouch.locked > 0) revert LockedStakeNonZero();\n\n        // Remove borrower from vouchers array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n        vouchers[borrower][voucherIndex.idx] = vouchers[borrower][vouchers[borrower].length - 1];\n        vouchers[borrower].pop();\n        delete voucherIndexes[borrower][staker];\n\n        // Remove borrower from vouchee array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n        Index memory voucheeIndex = voucheeIndexes[borrower][staker];\n        vouchees[staker][voucheeIndex.idx] = vouchees[staker][vouchees[staker].length - 1];\n        vouchees[staker].pop();\n        delete voucheeIndexes[borrower][staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    /**\n     *  @notice Register a a member using a signed permit\n     *  @dev See registerMember\n     *  @param newMember New member address\n     *  @param value Amount approved by permit\n     *  @param deadline Timestamp for when the permit expires\n     *  @param v secp256k1 signature part\n     *  @param r secp256k1 signature part\n     *  @param s secp256k1 signature part\n     */\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /**\n     *  @notice Register a a member, and burn an application fees\n     *  @dev    In order to register as a member an address must be recieving x amount\n     *          of vouches greater than 0 from stakers. x is defined by `effectiveCount`\n     *          Emits {LogRegisterMember} event\n     *  @param newMember New member address\n     */\n    function registerMember(address newMember) public virtual whenNotPaused {\n        if (stakers[newMember].isMember) revert NoExistingMember();\n\n        uint256 count = 0;\n        uint256 vouchersLength = vouchers[newMember].length;\n\n        // Loop through all the vouchers to count how many active vouches there\n        // are that are greater than 0. Vouch is the min of stake and trust\n        for (uint256 i = 0; i < vouchersLength; i++) {\n            Vouch memory vouch = vouchers[newMember][i];\n            Staker memory staker = stakers[vouch.staker];\n            if (staker.stakedAmount > 0) count++;\n            if (count >= effectiveCount) break;\n        }\n\n        if (count < effectiveCount) revert NotEnoughStakers();\n\n        stakers[newMember].isMember = true;\n        IUnionToken(unionToken).burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    /**\n     *  @notice Stake staking tokens\n     *  @dev    Stake is used to underwrite loans and becomes locked if a\n     *          member a staker has vouched for borrows against it.\n     *          Stake also earns rewards from the comptroller\n     *  Emits a {LogStake} event.\n     *  @param amount Amount to stake\n     */\n    function stake(uint96 amount) public whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        Staker storage staker = stakers[msg.sender];\n\n        if (staker.stakedAmount + amount > maxStakeAmount) revert StakeLimitReached();\n\n        staker.stakedAmount += amount;\n        totalStaked += amount;\n\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        if (!IAssetManager(assetManager).deposit(stakingToken, amount)) revert AssetManagerDepositFailed();\n        emit LogStake(msg.sender, amount);\n    }\n\n    /**\n     *  @notice Unstake staking token\n     *  @dev    Tokens can only be unstaked if they are not locked. ie a\n     *          vouchee is not borrowing against them.\n     *  Emits {LogUnstake} event\n     *  @param amount Amount to unstake\n     */\n    function unstake(uint96 amount) external whenNotPaused nonReentrant {\n        Staker storage staker = stakers[msg.sender];\n\n        // Stakers can only unstaked stake balance that is unlocked. Stake balance\n        // becomes locked when it is used to underwrite a borrow.\n        if (staker.stakedAmount - staker.locked < amount) revert InsufficientBalance();\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        staker.stakedAmount -= amount;\n        totalStaked -= amount;\n\n        if (!IAssetManager(assetManager).withdraw(stakingToken, msg.sender, amount)) {\n            revert AssetManagerWithdrawFailed();\n        }\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    /**\n     *  @dev collect staker rewards from the comptroller\n     */\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n    }\n\n    /**\n     *  @notice Write off a borrowers debt\n     *  @dev    Used the stakers locked stake to write off the loan, transfering the\n     *          Stake to the AssetManager and adjusting balances in the AssetManager\n     *          and the UToken to repay the principal\n     *  @dev    Emits {LogDebtWriteOff} event\n     *  @param borrower address of borrower\n     *  @param amount amount to writeoff\n     */\n    function debtWriteOff(\n        address staker,\n        address borrower,\n        uint96 amount\n    ) external {\n        if (amount == 0) revert AmountZero();\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 lastRepay = uToken.getLastRepay(borrower);\n\n        // This function is only callable by the public if the loan is overdue by\n        // overdue blocks + maxOverdueBlocks. This stops the system being left with\n        // debt that is overdue indefinitely and no ability to do anything about it.\n        if (block.number <= lastRepay + overdueBlocks + maxOverdueBlocks) {\n            if (staker != msg.sender) revert AuthFailed();\n        }\n\n        Index memory index = voucherIndexes[borrower][staker];\n        if (!index.isSet) revert VoucherNotFound();\n        Vouch storage vouch = vouchers[borrower][index.idx];\n\n        if (amount > vouch.locked) revert ExceedsLocked();\n\n        // update staker staked amount\n        stakers[staker].stakedAmount -= amount;\n        stakers[staker].locked -= amount;\n        totalStaked -= amount;\n\n        // update vouch trust amount\n        vouch.trust -= amount;\n        vouch.locked -= amount;\n\n        // Update total frozen and member frozen. We don't want to move th\n        // burden of calling updateFrozenInfo into this function as it is quite\n        // gas intensive. Instead we just want to remove the amount that was\n        // frozen which is now being written off. However, it is possible that\n        // member frozen has not been updated prior to calling debtWriteOff and\n        // the amount being written off could be greater than the amount frozen.\n        // To avoid an underflow here we need to check this condition\n        uint256 stakerFrozen = memberFrozen[staker];\n        if (amount > stakerFrozen) {\n            // The amount being written off is more than the amount that has\n            // been previously frozen for this staker. Reset their frozen stake\n            // to zero and adjust totalFrozen\n            memberFrozen[staker] = 0;\n            totalFrozen -= stakerFrozen;\n        } else {\n            totalFrozen -= amount;\n            memberFrozen[staker] -= amount;\n        }\n\n        if (vouch.trust == 0) {\n            cancelVouch(staker, borrower);\n        }\n\n        // Notify the AssetManager and the UToken market of the debt write off\n        // so they can adjust their balances accordingly\n        IAssetManager(assetManager).debtWriteOff(stakingToken, uint256(amount));\n        uToken.debtWriteOff(borrower, uint256(amount));\n\n        comptroller.updateTotalStaked(stakingToken, totalStaked - totalFrozen);\n\n        emit LogDebtWriteOff(msg.sender, borrower, uint256(amount));\n    }\n\n    /**\n     *  @notice Borrowing from the market\n     *  @dev    Locks/Unlocks the borrowers stakers staked amounts in a first in\n     *          First out order. Meaning the members that vouched for this borrower\n     *          first will be the first members to get their stake locked or unlocked\n     *          following a borrow or repayment.\n     *  @param borrower The address of the borrower\n     *  @param amount Lock/Unlock amount\n     *  @param lock If the amount is being locked or unlocked\n     */\n    function updateLocked(\n        address borrower,\n        uint96 amount,\n        bool lock\n    ) external onlyMarket {\n        uint96 remaining = amount;\n\n        for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n            Vouch storage vouch = vouchers[borrower][i];\n            uint96 innerAmount;\n\n            if (lock) {\n                // Look up the staker and determine how much unlock stake they\n                // have available for the borrower to borrow. If there is 0\n                // then continue to the next voucher in the array\n                uint96 stakerLocked = stakers[vouch.staker].locked;\n                uint96 stakerStakedAmount = stakers[vouch.staker].stakedAmount;\n                uint96 availableStake = stakerStakedAmount - stakerLocked;\n                uint96 lockAmount = _min(availableStake, vouch.trust - vouch.locked);\n                if (lockAmount == 0) continue;\n\n                // Calculate the amount to add to the lock then\n                // add the extra amount to lock to the stakers locked amount\n                // and also update the vouches locked amount and lastUpdated block\n                innerAmount = _min(remaining, lockAmount);\n                stakers[vouch.staker].locked = stakerLocked + innerAmount;\n                vouch.locked += innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            } else {\n                // Look up how much this vouch has locked. If it is 0 then\n                // continue to the next voucher. Then calculate the amount to\n                // unlock which is the min of the vouches lock and what is\n                // remaining to unlock\n                uint96 locked = vouch.locked;\n                if (locked == 0) continue;\n                innerAmount = _min(locked, remaining);\n\n                // Update the stored locked values and last updated block\n                stakers[vouch.staker].locked -= innerAmount;\n                vouch.locked -= innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            }\n\n            remaining -= innerAmount;\n            // If there is no remaining amount to lock/unlock\n            // we can stop looping through vouchers\n            if (remaining <= 0) break;\n        }\n\n        // If we have looped through all the available vouchers for this\n        // borrower and we still have a remaining amount then we have to\n        // revert as there is not enough vouchers to lock/unlock\n        if (remaining > 0) revert LockedRemaining();\n    }\n\n    /**\n     * @dev Update the frozen info for a single staker\n     * @param staker Staker address\n     * @param pastBlocks The past blocks\n     * @return  memberTotalFrozen Total frozen amount for this staker\n     *          memberFrozenCoinAge Total frozen coin age for this staker\n     */\n    function _updateFrozen(address staker, uint256 pastBlocks) internal returns (uint256, uint256) {\n        (uint256 memberTotalFrozen, uint256 memberFrozenCoinAge) = getFrozenInfo(staker, pastBlocks);\n\n        uint256 memberFrozenBefore = memberFrozen[staker];\n        if (memberFrozenBefore != memberTotalFrozen) {\n            memberFrozen[staker] = memberTotalFrozen;\n            totalFrozen = totalFrozen - memberFrozenBefore + memberTotalFrozen;\n        }\n\n        return (memberTotalFrozen, memberFrozenCoinAge);\n    }\n\n    /**\n     * @dev Update the frozen info by the comptroller\n     * @param staker Staker address\n     * @param pastBlocks The past blocks\n     * @return  memberTotalFrozen Total frozen amount for this staker\n     *          memberFrozenCoinAge Total frozen coin age for this staker\n     */\n    function updateFrozenInfo(address staker, uint256 pastBlocks) external onlyComp"
    }
  ]
}