{
  "Title": "H-1: Users can exploit the batch minting feature to avoid paying minting fees for tokens",
  "Content": "# Issue H-1: Users can exploit the batch minting feature to avoid paying minting fees for tokens \n\nSource: https://github.com/sherlock-audit/2024-04-titles-judging/issues/264 \n\n## Found by \n0x486776, 0x73696d616f, 1337, 4rdiii, AgileJune, AlexCzm, ArsenLupin, BiasedMerc, Brenzee, CodeWasp, ComposableSecurity, Dots, Kalogerone, KupiaSec, Shaheen, Varun\\_05, ast3ros, bareli, blockchain555, cducrest-brainbot, cu5t0mPe0, durov, ff, fugazzi, funkornaut, gesha17, gladiator111, jennifer37, joicygiore, juan, kennedy1030, nisedo, sammy, techOptimizor, trachev, ubl4nk, valentin2304, xiaoming90, y4y\n## Summary\n\nUsers can exploit the batch minting feature to avoid paying minting fees for tokens, leading to a loss of fees for the creator and fee recipients.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/editions/Edition.sol#L304\n\n```solidity\nFile: Edition.sol\n304:     function mintBatch(\n305:         address[] calldata receivers_,\n306:         uint256 tokenId_,\n307:         uint256 amount_,\n308:         bytes calldata data_\n309:     ) external payable {\n310:         // wake-disable-next-line reentrancy\n311:         FEE_MANAGER.collectMintFee{value: msg.value}(\n312:             this, tokenId_, amount_, msg.sender, address(0), works[tokenId_].strategy\n313:         );\n314: \n315:         for (uint256 i = 0; i < receivers_.length; i++) {\n316:             _issue(receivers_[i], tokenId_, amount_, data_);\n317:         }\n318: \n319:         _refundExcess();\n320:     }\n```\n\nAssume that the total mint fee (protocol flat fee = 0.0006 ETH + minting fee = 0.0004) for each token is 0.001 ETH. Bob wants to mint 1000 tokens, and he has to pay a minting fee of 1 ETH.\n\nHowever, the issue is that Bob can mint 1000 tokens without paying the full mint fee of 1 ETH as shown in the step below:\n\n1. Bob calls the above `mintBatch` function with `receivers_` array set to `1000 x Bob address` and the `amount_` parameter set to `1`.\n\n2. Line 331 above will compute the mint fee that Bob needs to pay. In this case, the `amount_` is one (1), and the total mint fee will be equal to `1 X 0.001 ETH`.\n\n3. The for-loop at Line 315 above will loop 1000 times as the `receivers_.length` is 1000. Each loop will mint one token to Bob. \n4. At the end of the for loop, Bob will receive 1000 while only paying a minting fee of 0.001 ETH instead of 1 ETH.\n5. In other words, Bob only paid the minting fee for the first token and did not pay the minting fee for the rest of the 999 tokens.\n\n## Impact\n\nLoss of fees for the creator and fee recipients as minters can avoid paying the fee using the trick mentioned in this report.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/editions/Edition.sol#L304\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider the following change to ensure that the minting fee is computed based on the total number of tokens minted to all receivers.\n\n```diff\n    function mintBatch(\n        address[] calldata receivers_,\n        uint256 tokenId_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external payable {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n-            this, tokenId_, amount_, msg.sender, address(0), works[tokenId_].strategy\n+            this, tokenId_, amount_ * receivers_.length, msg.sender, address(0), works[tokenId_].strategy\n        );\n\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, amount_, data_);\n        }\n\n        _refundExcess();\n    }\n```\n\n\n\n## Discussion\n\n**pqseags**\n\nValid, will fix\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/326",
  "Code": [
    {
      "filename": "wallflower-contract-v2/src/editions/Edition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Initializable} from \"lib/solady/src/utils/Initializable.sol\";\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {Ownable} from \"lib/solady/src/auth/Ownable.sol\";\nimport {ERC2981} from \"lib/solady/src/tokens/ERC2981.sol\";\nimport {SafeTransferLib} from \"lib/solady/src/utils/SafeTransferLib.sol\";\n\nimport {ERC1155} from \"solady/tokens/ERC1155.sol\";\nimport {IEdition} from \"src/interfaces/IEdition.sol\";\nimport {FeeManager} from \"src/fees/FeeManager.sol\";\nimport {TitlesGraph} from \"src/graph/TitlesGraph.sol\";\nimport {Node, NodeType, Target, Strategy} from \"src/shared/Common.sol\";\n\nimport {\n    EDITION_MANAGER_ROLE,\n    EDITION_MINTER_ROLE,\n    EDITION_PUBLISHER_ROLE,\n    Metadata,\n    Node,\n    Strategy,\n    Comment,\n    FeeStrategyUpdated,\n    MaxSupplyReached,\n    Minted,\n    NotImplemented,\n    NotOpen,\n    Published,\n    TimeframeUpdated,\n    WorkTransferred\n} from \"src/shared/Common.sol\";\n\n/// @title Edition\n/// @notice An ERC1155 contract representing a collection of related works. Each work is represented by a token ID.\ncontract Edition is IEdition, ERC1155, ERC2981, Initializable, OwnableRoles {\n    using SafeTransferLib for address;\n\n    /// @notice An individual work within the Edition.\n    /// @param creator The creator of the work.\n    /// @param maxSupply The maximum number of mintable tokens for the work.\n    /// @param totalSupply The total number of minted tokens for the work.\n    /// @param opensAt The timestamp after which the work is mintable.\n    /// @param closesAt The timestamp after which the work is no longer mintable. If `0`, there is no closing time.\n    /// @param strategy The fee strategy for the work.\n    struct Work {\n        address creator;\n        uint256 maxSupply;\n        uint256 totalSupply;\n        uint64 opensAt;\n        uint64 closesAt;\n        Strategy strategy;\n    }\n\n    /// @notice The total number of works in the Edition. Also the ID of the latest work.\n    uint256 public totalWorks;\n\n    /// @notice The collection of works in the Edition.\n    mapping(uint256 => Work) public works;\n\n    /// @notice The metadata for the Edition and its works.\n    /// @dev The Edition key is 0, while the work keys are the token IDs.\n    mapping(uint256 => Metadata) public _metadata;\n\n    /// @notice The fee manager contract.\n    FeeManager public FEE_MANAGER;\n\n    /// @notice The TitlesGraph contract.\n    TitlesGraph public GRAPH;\n\n    /// @notice Initialize the Edition contract.\n    /// @param feeManager_ The fee manager contract.\n    /// @param graph_ The TitlesGraph contract.\n    /// @param owner_ The owner of the Edition contract.\n    /// @param controller_ The controller of the Edition contract.\n    /// @dev This function is called by the {EditionFactory} when creating a new Edition to set the fee manager and owner.\n    /// @dev The controller is granted the {EDITION_MANAGER_ROLE} to allow management of the Edition contract.\n    function initialize(\n        FeeManager feeManager_,\n        TitlesGraph graph_,\n        address owner_,\n        address controller_,\n        Metadata calldata metadata_\n    ) external initializer {\n        _initializeOwner(owner_);\n        FEE_MANAGER = feeManager_;\n        GRAPH = graph_;\n\n        _grantRoles(controller_, EDITION_MANAGER_ROLE);\n        _grantRoles(owner_, EDITION_PUBLISHER_ROLE);\n\n        _metadata[0] = metadata_;\n    }\n\n    /// @notice Create a new work in the Edition.\n    /// @param creator_ The creator of the work.\n    /// @param maxSupply_ The maximum number of mintable tokens for the work.\n    /// @param opensAt_ The timestamp after which the work is mintable.\n    /// @param closesAt_ The timestamp after which the work is no longer mintable.\n    /// @param attributions_ The attributions for the work.\n    /// @param strategy_ The fee strategy for the work.\n    /// @param metadata_ The metadata for the work.\n    function publish(\n        address creator_,\n        uint256 maxSupply_,\n        uint64 opensAt_,\n        uint64 closesAt_,\n        Node[] calldata attributions_,\n        Strategy calldata strategy_,\n        Metadata calldata metadata_\n    ) external override onlyRoles(EDITION_MANAGER_ROLE) returns (uint256 tokenId) {\n        tokenId = ++totalWorks;\n\n        _metadata[tokenId] = metadata_;\n        works[tokenId] = Work({\n            creator: creator_,\n            totalSupply: 0,\n            maxSupply: maxSupply_,\n            opensAt: opensAt_,\n            closesAt: closesAt_,\n            strategy: FEE_MANAGER.validateStrategy(strategy_)\n        });\n\n        Node memory _node = node(tokenId);\n        for (uint256 i = 0; i < attributions_.length; i++) {\n            // wake-disable-next-line reentrancy, unchecked-return-value\n            GRAPH.createEdge(_node, attributions_[i], attributions_[i].data);\n        }\n\n        emit Published(address(this), tokenId);\n    }\n\n    /// @notice Get the name of the Edition.\n    /// @return The name of the Edition.\n    function name() public view override returns (string memory) {\n        return _metadata[0].label;\n    }\n\n    /// @notice Get the name for a given Work.\n    /// @param tokenId The ID of the work.\n    /// @return The name of the work.\n    function name(uint256 tokenId) public view returns (string memory) {\n        return _metadata[tokenId].label;\n    }\n\n    /// @notice Get the owner of the Edition.\n    /// @return The owner of the Edition.\n    /// @dev The owner of the Edition contract has the right to manage roles.\n    function owner() public view override(IEdition, Ownable) returns (address) {\n        return super.owner();\n    }\n\n    function uri() public view returns (string memory) {\n        return _metadata[0].uri;\n    }\n\n    /// @notice Get the URI for the given token ID.\n    /// @param tokenId_ The ID of the token.\n    /// @return The URI for the token.\n    function uri(uint256 tokenId_)\n        public\n        view\n        virtual\n        override(IEdition, ERC1155)\n        returns (string memory)\n    {\n        return _metadata[tokenId_].uri;\n    }\n\n    /// @notice Get the creator of the Edition. Alias for {owner}.\n    /// @return The creator of the Edition.\n    function creator() public view override returns (address) {\n        return owner();\n    }\n\n    /// @notice Get the creator of the given work.\n    /// @param tokenId The ID of the work.\n    /// @return The creator of the work.\n    function creator(uint256 tokenId) public view override returns (address) {\n        return works[tokenId].creator;\n    }\n\n    /// @notice Get the {Node} for the collection.\n    /// @return The node for the edition.\n    function node() public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.COLLECTION_ERC1155,\n            creator: Target({target: owner(), chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: \"\"\n        });\n    }\n\n    /// @notice Get the {Node} for the given work.\n    /// @param tokenId The token ID of the work.\n    /// @return The node for the work.\n    function node(uint256 tokenId) public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.TOKEN_ERC1155,\n            creator: Target({target: works[tokenId].creator, chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: abi.encode(tokenId)\n        });\n    }\n\n    /// @notice Get the mint fee for one token for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The mint fee for the token.\n    function mintFee(uint256 tokenId_) public view returns (uint256) {\n        return mintFee(tokenId_, 1);\n    }\n\n    /// @notice Get the mint fee for an `amount` of tokens for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @param amount_ The amount of tokens to mint.\n    /// @return The mint fee for the tokens.\n    function mintFee(uint256 tokenId_, uint256 amount_) public view returns (uint256) {\n        if (tokenId_ == 0 || tokenId_ > totalWorks) return 0;\n        return FEE_MANAGER.getMintFee(works[tokenId_].strategy, amount_).amount;\n    }\n\n    /// @notice Mint a new token for the given work.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mint(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_\n    ) external payable override {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, works[tokenId_].strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a new token for the given work with a public comment.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    /// @param comment_ The public comment associated with the mint. Emitted as an event.\n    /// @dev This function is used to mint a token with a public comment, allowing the mint to be associated with a message which will be emitted as an event.\n    function mintWithComment(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_,\n        string calldata comment_\n    ) external payable {\n        Strategy memory strategy = works[tokenId_].strategy;\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n\n        emit Comment(address(this), tokenId_, to_, comment_);\n    }\n\n    /// @notice Mint multiple tokens for the given works.\n    /// @param to_ The address to mint the tokens to.\n    /// @param tokenIds_ The IDs of the works to mint.\n    /// @param amounts_ The amounts of each work to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address to_,\n        uint256[] calldata tokenIds_,\n        uint256[] calldata amounts_,\n        bytes calldata data_\n    ) external payable {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            Work storage work = works[tokenIds_[i]];\n\n            // wake-disable-next-line reentrancy\n            FEE_MANAGER.collectMintFee{value: msg.value}(\n                this, tokenIds_[i], amounts_[i], msg.sender, address(0), work.strategy\n            );\n\n            _checkTime(work.opensAt, work.closesAt);\n            _updateSupply(work, amounts_[i]);\n        }\n\n        _batchMint(to_, tokenIds_, amounts_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a token to a set of receivers for the given work.\n    /// @param receivers_ The addresses to mint the tokens to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address[] calldata receivers_,\n        uint256 tokenId_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external payable {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, address(0), works[tokenId_].strategy\n        );\n\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, amount_, data_);\n        }\n\n        _refundExcess();\n    }\n\n    /// @notice Mint a token from the given work to a set of receivers.\n    /// @param receivers_ The addresses to mint the tokens to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    /// @dev This function is used to mint one token for each receiver of a given work, bypassing mint fees. It is intended for promotional purposes.\n    function promoMint(address[] calldata receivers_, uint256 tokenId_, bytes calldata data_)\n        external\n        onlyOwnerOrRoles(EDITION_MANAGER_ROLE | EDITION_MINTER_ROLE)\n    {\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, 1, data_);\n        }\n    }\n\n    /// @notice Get the metadata for the given ID.\n    /// @param id_ The ID of the work, or `0` for the Edition.\n    /// @return The metadata for the ID.\n    function metadata(uint256 id_) external view returns (Metadata memory) {\n        return _metadata[id_];\n    }\n\n    /// @notice Get the maximum supply for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The maximum supply for the work.\n    function maxSupply(uint256 tokenId_) external view override returns (uint256) {\n        return works[tokenId_].maxSupply;\n    }\n\n    /// @notice Get the total supply for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The total supply for the work.\n    function totalSupply(uint256 tokenId_) external view override returns (uint256) {\n        return works[tokenId_].totalSupply;\n    }\n\n    /// @notice Get the fee strategy for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The fee strategy for the work.\n    function feeStrategy(uint256 tokenId_) external view override returns (Strategy memory) {\n        return works[tokenId_].strategy;\n    }\n\n    /// @notice Set the fee strategy for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @param strategy_ The fee strategy for the work.\n    /// @dev This function only updates the strategy locally and will NOT change the fee route.\n    function setFeeStrategy(uint256 tokenId_, Strategy calldata strategy_) external {\n        if (msg.sender != works[tokenId_].creator) revert Unauthorized();\n        works[tokenId_].strategy = FEE_MANAGER.validateStrategy(strategy_);\n    }\n\n    /// @notice Set the metadata for a given ID.\n    /// @param id_ The ID of the work, or `0` for the Edition\n    /// @param metadata_ The new metadata.\n    function setMetadata(uint256 id_, Metadata calldata metadata_) external {\n        // Only the owner can update the Edition metadata\n        if (id_ == 0 && msg.sender != owner()) revert Unauthorized();\n\n        // Only the creator can update the work metadata\n        if (id_ > 0 && msg.sender != works[id_].creator) revert Unauthorized();\n\n        _metadata[id_] = metadata_;\n    }\n\n    /// @notice Set the ERC2981 royalty target for the given work.\n    /// @param tokenId The ID of the work.\n    /// @param target The address to receive royalties.\n    function setRoyaltyTarget(uint256 tokenId, address target)\n        external\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _setTokenRoyalty(tokenId, target, works[tokenId].strategy.royaltyBps);\n    }\n\n    /// @notice Sets the open and close times for the given work.\n    /// @param tokenId The ID of the work.\n    /// @param opensAt The timestamp after which the work is mintable.\n    /// @param closesAt The timestamp after which the work is no longer mintable.\n    /// @dev Only the creator of the work can call this function.\n    function setTimeframe(uint256 tokenId, uint64 opensAt, uint64 closesAt) external {\n        Work storage work = works[tokenId];\n        if (msg.sender != work.creator) revert Unauthorized();\n\n        // Update the open and close times for the work\n        work.opensAt = opensAt;\n        work.closesAt = closesAt;\n\n        emit TimeframeUpdated(address(this), tokenId, opensAt, closesAt);\n    }\n\n    function transferWork(address to_, uint256 tokenId_) external {\n        Work storage work = works[tokenId_];\n        if (msg.sender != work.creator) revert Unauthorized();\n\n        // Transfer the work to the new creator\n        work.creator = to_;\n\n        emit WorkTransferred(address(this), tokenId_, to_);\n    }\n\n    /// @inheritdoc OwnableRoles\n    function grantRoles(address user_, uint256 roles_)\n        public\n        payable\n        override\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _grantRoles(user_, roles_);\n    }\n\n    /// @inheritdoc OwnableRoles\n    function revokeRoles(address user_, uint256 roles_)\n        public\n        payable\n        override\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _removeRoles(user_, roles_);\n    }\n\n    /// @notice Grant the publisher role to the given address, allowing it to publish new works within the Edition.\n    /// @param publisher_ The address to grant the role to.\n    /// @dev This function is used by the owner or manager to grant the {EDITION_PUBLISHER_ROLE} to an address, allowing it to publish new works within the Edition.\n    function grantPublisherRole(address publisher_)\n        external\n        onlyRolesOrOwner(EDITION_MANAGER_ROLE)\n    {\n        _grantRoles(publisher_, EDITION_PUBLISHER_ROLE);\n    }\n\n    /// @notice Revoke the publisher role from the given address, preventing it from publishing new works. Does not affect existing works.\n    /// @param publisher_ The address to revoke the role from.\n    /// @dev This function is used by the owner or manager to revoke the {EDITION_PUBLISHER_ROLE} from an address, preventing it from publishing new works within the Edition.\n    function revokePublisherRole(address publisher_)\n        external\n        onlyRolesOrOwner(EDITION_MANAGER_ROLE)\n    {\n        _removeRoles(publisher_, EDITION_PUBLISHER_ROLE);\n    }\n\n    /// @notice Check if the contract supports the given interface.\n    /// @param interfaceId The interface ID to check.\n    /// @return True if the contract supports the interface, false otherwise.\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(IEdition, ERC1155, ERC2981)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /// @notice Issue tokens for the given work.\n    /// @param to_ The address to issue the tokens to.\n    /// @param tokenId_ The ID of the work to issue.\n    /// @param amount_ The amount of tokens to issue.\n    /// @param data_ The data associated with the issuance. Reserved for future use.\n    /// @dev This function is used by the {mint} and {mintBatch} functions to mint tokens and reverts if the new total supply would exceed the maximum supply.\n    function _issue(address to_, uint256 tokenId_, uint256 amount_, bytes calldata data_)\n        internal\n    {\n        Work storage work = works[tokenId_];\n        _checkTime(work.opensAt, work.closesAt);\n        _updateSupply(work, amount_);\n        _mint(to_, tokenId_, amount_, data_);\n        emit Minted(address(this), tokenId_, to_, amount_, data_);\n    }\n\n    /// @notice Update the total supply for the given work.\n    /// @param work The work to update.\n    /// @param amount_ The amount to add to the total supply.\n    /// @dev This function increments the total supply for a given work and reverts if the new total exceeds the maximum supply.\n    function _updateSupply(Work storage work, uint256 amount_) internal {\n        if ((work.totalSupply += amount_) > work.maxSupply) {\n            revert MaxSupplyReached();\n        }\n    }\n\n    /// @notice Checks that the current block time falls within the given range.\n    /// @param start_ The timestamp after which the work is mintable.\n    /// @param end_ The timestamp after which the work is no longer mintable.\n    /// @dev This function is used to check that the current block time falls within the given range and reverts if not.\n    function _checkTime(uint64 start_, uint64 end_) internal view {\n        if (block.timestamp < start_ || (end_ != 0 && block.timestamp > end_)) {\n            revert NotOpen(start_, end_);\n        }\n    }\n\n    /// @notice Refund any excess ETH sent to the contract.\n    /// @dev This function is called after minting tokens to refund any ETH left in the contract after all fees have been collected.\n    function _refundExcess() internal {\n        if (msg.value > 0 && address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n}"
    },
    {
      "filename": "wallflower-contract-v2/src/editions/Edition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Initializable} from \"lib/solady/src/utils/Initializable.sol\";\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {Ownable} from \"lib/solady/src/auth/Ownable.sol\";\nimport {ERC2981} from \"lib/solady/src/tokens/ERC2981.sol\";\nimport {SafeTransferLib} from \"lib/solady/src/utils/SafeTransferLib.sol\";\n\nimport {ERC1155} from \"solady/tokens/ERC1155.sol\";\nimport {IEdition} from \"src/interfaces/IEdition.sol\";\nimport {FeeManager} from \"src/fees/FeeManager.sol\";\nimport {TitlesGraph} from \"src/graph/TitlesGraph.sol\";\nimport {Node, NodeType, Target, Strategy} from \"src/shared/Common.sol\";\n\nimport {\n    EDITION_MANAGER_ROLE,\n    EDITION_MINTER_ROLE,\n    EDITION_PUBLISHER_ROLE,\n    Metadata,\n    Node,\n    Strategy,\n    Comment,\n    FeeStrategyUpdated,\n    MaxSupplyReached,\n    Minted,\n    NotImplemented,\n    NotOpen,\n    Published,\n    TimeframeUpdated,\n    WorkTransferred\n} from \"src/shared/Common.sol\";\n\n/// @title Edition\n/// @notice An ERC1155 contract representing a collection of related works. Each work is represented by a token ID.\ncontract Edition is IEdition, ERC1155, ERC2981, Initializable, OwnableRoles {\n    using SafeTransferLib for address;\n\n    /// @notice An individual work within the Edition.\n    /// @param creator The creator of the work.\n    /// @param maxSupply The maximum number of mintable tokens for the work.\n    /// @param totalSupply The total number of minted tokens for the work.\n    /// @param opensAt The timestamp after which the work is mintable.\n    /// @param closesAt The timestamp after which the work is no longer mintable. If `0`, there is no closing time.\n    /// @param strategy The fee strategy for the work.\n    struct Work {\n        address creator;\n        uint256 maxSupply;\n        uint256 totalSupply;\n        uint64 opensAt;\n        uint64 closesAt;\n        Strategy strategy;\n    }\n\n    /// @notice The total number of works in the Edition. Also the ID of the latest work.\n    uint256 public totalWorks;\n\n    /// @notice The collection of works in the Edition.\n    mapping(uint256 => Work) public works;\n\n    /// @notice The metadata for the Edition and its works.\n    /// @dev The Edition key is 0, while the work keys are the token IDs.\n    mapping(uint256 => Metadata) public _metadata;\n\n    /// @notice The fee manager contract.\n    FeeManager public FEE_MANAGER;\n\n    /// @notice The TitlesGraph contract.\n    TitlesGraph public GRAPH;\n\n    /// @notice Initialize the Edition contract.\n    /// @param feeManager_ The fee manager contract.\n    /// @param graph_ The TitlesGraph contract.\n    /// @param owner_ The owner of the Edition contract.\n    /// @param controller_ The controller of the Edition contract.\n    /// @dev This function is called by the {EditionFactory} when creating a new Edition to set the fee manager and owner.\n    /// @dev The controller is granted the {EDITION_MANAGER_ROLE} to allow management of the Edition contract.\n    function initialize(\n        FeeManager feeManager_,\n        TitlesGraph graph_,\n        address owner_,\n        address controller_,\n        Metadata calldata metadata_\n    ) external initializer {\n        _initializeOwner(owner_);\n        FEE_MANAGER = feeManager_;\n        GRAPH = graph_;\n\n        _grantRoles(controller_, EDITION_MANAGER_ROLE);\n        _grantRoles(owner_, EDITION_PUBLISHER_ROLE);\n\n        _metadata[0] = metadata_;\n    }\n\n    /// @notice Create a new work in the Edition.\n    /// @param creator_ The creator of the work.\n    /// @param maxSupply_ The maximum number of mintable tokens for the work.\n    /// @param opensAt_ The timestamp after which the work is mintable.\n    /// @param closesAt_ The timestamp after which the work is no longer mintable.\n    /// @param attributions_ The attributions for the work.\n    /// @param strategy_ The fee strategy for the work.\n    /// @param metadata_ The metadata for the work.\n    function publish(\n        address creator_,\n        uint256 maxSupply_,\n        uint64 opensAt_,\n        uint64 closesAt_,\n        Node[] calldata attributions_,\n        Strategy calldata strategy_,\n        Metadata calldata metadata_\n    ) external override onlyRoles(EDITION_MANAGER_ROLE) returns (uint256 tokenId) {\n        tokenId = ++totalWorks;\n\n        _metadata[tokenId] = metadata_;\n        works[tokenId] = Work({\n            creator: creator_,\n            totalSupply: 0,\n            maxSupply: maxSupply_,\n            opensAt: opensAt_,\n            closesAt: closesAt_,\n            strategy: FEE_MANAGER.validateStrategy(strategy_)\n        });\n\n        Node memory _node = node(tokenId);\n        for (uint256 i = 0; i < attributions_.length; i++) {\n            // wake-disable-next-line reentrancy, unchecked-return-value\n            GRAPH.createEdge(_node, attributions_[i], attributions_[i].data);\n        }\n\n        emit Published(address(this), tokenId);\n    }\n\n    /// @notice Get the name of the Edition.\n    /// @return The name of the Edition.\n    function name() public view override returns (string memory) {\n        return _metadata[0].label;\n    }\n\n    /// @notice Get the name for a given Work.\n    /// @param tokenId The ID of the work.\n    /// @return The name of the work.\n    function name(uint256 tokenId) public view returns (string memory) {\n        return _metadata[tokenId].label;\n    }\n\n    /// @notice Get the owner of the Edition.\n    /// @return The owner of the Edition.\n    /// @dev The owner of the Edition contract has the right to manage roles.\n    function owner() public view override(IEdition, Ownable) returns (address) {\n        return super.owner();\n    }\n\n    function uri() public view returns (string memory) {\n        return _metadata[0].uri;\n    }\n\n    /// @notice Get the URI for the given token ID.\n    /// @param tokenId_ The ID of the token.\n    /// @return The URI for the token.\n    function uri(uint256 tokenId_)\n        public\n        view\n        virtual\n        override(IEdition, ERC1155)\n        returns (string memory)\n    {\n        return _metadata[tokenId_].uri;\n    }\n\n    /// @notice Get the creator of the Edition. Alias for {owner}.\n    /// @return The creator of the Edition.\n    function creator() public view override returns (address) {\n        return owner();\n    }\n\n    /// @notice Get the creator of the given work.\n    /// @param tokenId The ID of the work.\n    /// @return The creator of the work.\n    function creator(uint256 tokenId) public view override returns (address) {\n        return works[tokenId].creator;\n    }\n\n    /// @notice Get the {Node} for the collection.\n    /// @return The node for the edition.\n    function node() public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.COLLECTION_ERC1155,\n            creator: Target({target: owner(), chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: \"\"\n        });\n    }\n\n    /// @notice Get the {Node} for the given work.\n    /// @param tokenId The token ID of the work.\n    /// @return The node for the work.\n    function node(uint256 tokenId) public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.TOKEN_ERC1155,\n            creator: Target({target: works[tokenId].creator, chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: abi.encode(tokenId)\n        });\n    }\n\n    /// @notice Get the mint fee for one token for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The mint fee for the token.\n    function mintFee(uint256 tokenId_) public view returns (uint256) {\n        return mintFee(tokenId_, 1);\n    }\n\n    /// @notice Get the mint fee for an `amount` of tokens for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @param amount_ The amount of tokens to mint.\n    /// @return The mint fee for the tokens.\n    function mintFee(uint256 tokenId_, uint256 amount_) public view returns (uint256) {\n        if (tokenId_ == 0 || tokenId_ > totalWorks) return 0;\n        return FEE_MANAGER.getMintFee(works[tokenId_].strategy, amount_).amount;\n    }\n\n    /// @notice Mint a new token for the given work.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mint(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_\n    ) external payable override {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, works[tokenId_].strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a new token for the given work with a public comment.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    /// @param comment_ The public comment associated with the mint. Emitted as an event.\n    /// @dev This function is used to mint a token with a public comment, allowing the mint to be associated with a message which will be emitted as an event.\n    function mintWithComment(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_,\n        string calldata comment_\n    ) external payable {\n        Strategy memory strategy = works[tokenId_].strategy;\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n\n        emit Comment(address(this), tokenId_, to_, comment_);\n    }\n\n    /// @notice Mint multiple tokens for the given works.\n    /// @param to_ The address to mint the tokens to.\n    /// @param tokenIds_ The IDs of the works to mint.\n    /// @param amounts_ The amounts of each work to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address to_,\n        uint256[] calldata tokenIds_,\n        uint256[] calldata amounts_,\n        bytes calldata data_\n    ) external payable {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            Work storage work = works[tokenIds_[i]];\n\n            // wake-disable-next-line reentrancy\n            FEE_MANAGER.collectMintFee{value: msg.value}(\n                this, tokenIds_[i], amounts_[i], msg.sender, address(0), work.strategy\n            );\n\n            _checkTime(work.opensAt, work.closesAt);\n            _updateSupply(work, amounts_[i]);\n        }\n\n        _batchMint(to_, tokenIds_, amounts_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a token to a set of receivers for the given work.\n    /// @param receivers_ The addresses to mint the tokens to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address[] calldata receivers_,\n        uint256 tokenId_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external payable {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, address(0), works[tokenId_].strategy\n        );\n\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, amount_, data_);\n        }\n\n        _refundExcess();\n    }\n\n    /// @notice Mint a token from the giv"
    }
  ]
}