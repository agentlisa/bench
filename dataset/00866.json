{
  "Title": "M-2: LockPositionService::increaseLockTime Incorrect Calculation Extends Lock Duration Beyond Intended Period",
  "Content": "# Issue M-2: LockPositionService::increaseLockTime Incorrect Calculation Extends Lock Duration Beyond Intended Period \n\nSource: https://github.com/sherlock-audit/2023-11-convergence-judging/issues/136 \n\n## Found by \nbughuntoor, cergyk, jah, rvierdiiev\n## Summary\n`LockPositionService::increaseLockTime` uses `block.timestamp` for locking tokens, resulting in potential over-extension of the lock period. Specifically, if a user locks tokens near the end of a cycle, the lock duration might extend an additional week more than intended. For instance, locking for one cycle at the end of cycle N could result in an unlock time at the end of cycle N+2, instead of at the start of cycle N+2.\n\nThis means that all the while specifying that their $CVG should be locked for the next cycle, the $CVG stays locked for two cycles.\n\n## Vulnerability Detail\nThe function `increaseLockTime` inaccurately calculates the lock duration by using `block.timestamp`, thus not aligned to the starts of cycles. This discrepancy leads to a longer-than-expected lock period, especially when a lock is initiated near the end of a cycle. This misalignment means that users are unintentionally extending their lock period and affecting their asset management strategies.\n\n### Scenario:\n- Alice decides to lock her tokens for one cycle near the end of cycle N.\n- The lock duration calculation extends the lock to the end of cycle N+2, rather than starting the unlock process at the start of cycle N+2.\n- Alice's tokens are locked for an additional week beyond her expectation.\n\n## Impact\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/LockingPositionService.sol#L421\n\n## Tool used\nUsers may have their $CVG locked for a week more than expected\n\n## Recommendation\nAlign the locking mechanism to multiples of a week and use `(block.timestamp % WEEK) + lockDuration` for the lock time calculation. This adjustment ensures that the lock duration is consistent with user expectations and cycle durations.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/126",
  "Code": [
    {
      "filename": "sherlock-cvg/contracts/Locking/LockingPositionService.sol",
      "content": "// SPDX-License-Identifier: MIT\n/**\n _____\n/  __ \\\n| /  \\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\n| |    / _ \\| '_ \\ \\ / / _ \\ '__/ _` |/ _ \\ '_ \\ / __/ _ \\\n| \\__/\\ (_) | | | \\ V /  __/ | | (_| |  __/ | | | (_|  __/\n \\____/\\___/|_| |_|\\_/ \\___|_|  \\__, |\\___|_| |_|\\___\\___|\n                                 __/ |\n                                |___/\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ICvgControlTower.sol\";\n\n/**\n * @title Cvg-Finance - LockingPositionService\n * @notice Allows to lock CVG, gives yield and governance power.\n * @dev  When a position is minted, the amount can be split  between 2 different type of CVG :\n *       veCVG : used for voting power ( associated  with MgCVG meta-governance voting power )\n *       | ysCVG : used for treasury shares( allow the user to claim a part of the treasury at each TDE ( treasury distribution event ) )\n *       | the amount  of ys/Ve the user will receive for each CVG locked  is proportional with the duration of the lock.\n */\ncontract LockingPositionService is Ownable2StepUpgradeable {\n    struct LockingPosition {\n        uint96 startCycle;\n        uint96 lastEndCycle;\n        /** @dev  Percentage of the NFT dedicated to ysCvg. */\n        uint64 ysPercentage;\n        /** @dev  Number of CVG Locked. */\n        uint256 totalCvgLocked;\n        /** @dev  Meta Governance CVG amount. */\n        uint256 mgCvgAmount;\n    }\n\n    struct TokenView {\n        uint256 tokenId;\n        uint128 startCycle;\n        uint128 endCycle;\n        uint256 cvgLocked;\n        uint256 ysActual;\n        uint256 ysTotal;\n        uint256 veCvgActual;\n        uint256 mgCvg;\n        uint256 ysPercentage;\n    }\n\n    struct TrackingBalance {\n        uint256 ysToAdd;\n        uint256 ysToSub;\n    }\n\n    struct LockingExtension {\n        uint128 cycleId;\n        uint128 endCycle;\n        uint256 cvgLocked;\n        uint256 mgCvgAdded;\n    }\n\n    event MintLockingPosition(uint256 tokenId, LockingPosition lockingPosition, LockingExtension lockingExtension);\n    event IncreaseLockAmount(uint256 tokenId, LockingPosition lockingPosition, LockingExtension lockingExtension);\n    event IncreaseLockTime(uint256 tokenId, LockingPosition lockingPosition, uint256 oldEndCycle);\n    event IncreaseLockTimeAndAmount(\n        uint256 tokenId,\n        LockingPosition lockingPosition,\n        LockingExtension lockingExtension,\n        uint256 oldEndCycle\n    );\n    event UpdateTotalSupplies(uint256 newYsSupply, uint256 veCvgSupply, uint256 cycle);\n    event LockingPositionBurn(uint256 tokenId);\n\n    /** @dev Maximum locking time in cycle(weeks)  */\n    uint256 public constant MAX_LOCK = 96;\n    /** @dev TDE duration in weeks  */\n    uint256 public constant TDE_DURATION = 12;\n    uint256 public constant MAX_PERCENTAGE = 100;\n    /** @dev pourcentage can only used as multiple of this value */\n    uint256 public constant RANGE_PERCENTAGE = 10;\n\n    /** @dev Convergence ControlTower. */\n    ICvgControlTower public cvgControlTower;\n    /** @dev Convergence CVG. */\n    ICvg public cvg;\n\n    /** @dev Total supply of ysCvg. */\n    uint256 public totalSupplyYsCvg;\n\n    /** @dev  Keeps global data of a LockingPosition. */\n    mapping(uint256 => LockingPosition) public lockingPositions;\n\n    /** @dev Keep track of the ySCvg supply changes for each cycle, so we can compute the totalSupply of ysCvg at each cycle. */\n    mapping(uint256 => TrackingBalance) public totalSuppliesTracking;\n\n    /** @dev Keep track of the ysCvg supply at each cycle. */\n    mapping(uint256 => uint256) public totalSupplyYsCvgHistories;\n\n    /** @dev Keep track of the update of locking positions. */\n    mapping(uint256 => LockingExtension[]) public lockExtensions;\n\n    /** @dev Address => contract is whitelisted to perform locks. */\n    mapping(address => bool) public isContractLocker;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the contract with the ConvergenceControlTower address, set the cvgToken address, transfer ownership to the initializer.\n     * @param _cvgControlTower ConvergenceControlTower address.\n     */\n    function initialize(ICvgControlTower _cvgControlTower) external initializer {\n        cvgControlTower = _cvgControlTower;\n        _transferOwnership(msg.sender);\n        ICvg _cvg = _cvgControlTower.cvgToken();\n        require(address(_cvg) != address(0), \"CVG_ZERO\");\n        cvg = _cvg;\n    }\n\n    /**\n     * @dev  Some methods that are called by wallet ,\n     * can also be called by cvgUtilities meta functionalities\n     * this modifier allow to check both case.\n     * it also check that the token is not time locked.\n     */\n    modifier checkCompliance(uint256 tokenId, address operator) {\n        _checkCompliance(tokenId, operator);\n        _;\n    }\n\n    /**\n     * @dev Some methods that are called by wallet ,\n     * can also be called by cvgUtilities meta functionalities\n     * this modifier allow to check both case.\n     */\n    modifier onlyWalletOrWhiteListedContract() {\n        _onlyWalletOrWhiteListedContract();\n        _;\n    }\n\n    /**\n     * @notice Check the owner of the token  taking into consideration the operator and the msg.sender.\n     * @dev  For the swap and bond function, the caller is the cvgUtilities contract, in which case the token property is checked with the operator, otherwise the sender msg.sender is used.\n     * @param _tokenId ID of the token.\n     * @param _operator address of the operator.\n     */\n    function _checkTokenOwnerShip(uint256 _tokenId, address _operator) internal view {\n        address tokenOwner = cvgControlTower.lockingPositionManager().ownerOf(_tokenId);\n        if (msg.sender == cvgControlTower.cvgUtilities()) {\n            require(_operator == tokenOwner, \"TOKEN_NOT_OWNED\");\n        } else {\n            require(msg.sender == tokenOwner, \"TOKEN_NOT_OWNED\");\n        }\n    }\n\n    /**\n     *  @notice Check if the token is compliant to be manipulated\n     *   this function is used on  methods that can be called by the wallet or the cvgUtilities contract\n     *   the check of ownership is done in both case , it also check that the token is not time locked\n     *   Time lock is a feature that protects a potential buyer of a token from a malicious front run from the seller.\n     *  @param tokenId ID of the token.\n     *  @param operator address of the operator.\n     */\n    function _checkCompliance(uint256 tokenId, address operator) internal view {\n        (address ownerOf, uint256 unlockTimestamp) = cvgControlTower.lockingPositionManager().getComplianceInfo(\n            tokenId\n        );\n        if (msg.sender == cvgControlTower.cvgUtilities()) {\n            require(operator == ownerOf, \"TOKEN_NOT_OWNED\");\n        } else {\n            require(msg.sender == ownerOf, \"TOKEN_NOT_OWNED\");\n        }\n        require(unlockTimestamp < block.timestamp, \"TOKEN_TIMELOCKED\");\n    }\n\n    /**\n     * @notice Check if the caller is a wallet or a whitelisted contract.\n     */\n    function _onlyWalletOrWhiteListedContract() internal view {\n        require(\n            // solhint-disable-next-line avoid-tx-origin\n            msg.sender == tx.origin || isContractLocker[msg.sender],\n            \"NOT_CONTRACT_OR_WL\"\n        );\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            INFO\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    struct LockingInfo {\n        uint256 tokenId;\n        uint256 cvgLocked;\n        uint256 lockEnd;\n        uint256 ysPercentage;\n        uint256 mgCvg;\n    }\n\n    /**\n     *   @notice Get position information for a given tokenId, used by the CVG display of the token.\n     *   @param tokenId is the token ID of the position.\n     */\n    function lockingInfo(uint256 tokenId) external view returns (LockingInfo memory) {\n        uint256 _cvgCycle = cvgControlTower.cvgCycle();\n        uint256 tokenLastEndCycle = lockingPositions[tokenId].lastEndCycle;\n\n        return\n            LockingInfo({\n                tokenId: tokenId,\n                cvgLocked: lockingPositions[tokenId].totalCvgLocked,\n                lockEnd: tokenLastEndCycle,\n                ysPercentage: lockingPositions[tokenId].ysPercentage,\n                mgCvg: _cvgCycle > tokenLastEndCycle ? 0 : lockingPositions[tokenId].mgCvgAmount\n            });\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        PUBLIC FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n     * @notice Mint a locking position (ERC721) for the user.\n     * @dev Lock can't be greater than the Maximum locking time / The end of the lock must finish on a TDE event cycle |  The percentage of ys determines the repartition in veCVG,mgCVG/YsCVG.\n     * @param lockDuration is the duration in cycle(week) of the lock.\n     * @param amount is the amount of cvg to lock in the position.\n     * @param ysPercentage percentage of lock dedicated to treasury shares (ysCVG).\n     * @param receiver address of the receiver of the locking position.\n     * @param isAddToManagedTokens add the created token in managed tokens(voting power)  directly.\n     */\n    function mintPosition(\n        uint96 lockDuration,\n        uint256 amount,\n        uint64 ysPercentage,\n        address receiver,\n        bool isAddToManagedTokens\n    ) external onlyWalletOrWhiteListedContract {\n        require(amount > 0, \"LTE\");\n        /** @dev Percentage cannot be over 100%. */\n        require(ysPercentage <= MAX_PERCENTAGE, \"YS_%_OVER_100\");\n        /** @dev Only percentage with multiple of 10 are possible to use. */\n        require(ysPercentage % RANGE_PERCENTAGE == 0, \"YS_%_10_MULTIPLE\");\n        /** @dev Lock cannot be longer than MAX_LOCK. */\n        require(lockDuration <= MAX_LOCK, \"MAX_LOCK_96_CYCLES\");\n\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n\n        /** @dev Retrieve actual staking cycle. */\n        uint96 actualCycle = uint96(_cvgControlTower.cvgCycle());\n        uint96 endLockCycle = actualCycle + lockDuration;\n        /** @dev End of lock must finish on TDE. */\n        require(endLockCycle % TDE_DURATION == 0, \"END_MUST_BE_TDE_MULTIPLE\");\n\n        ILockingPositionManager _lockingPositionManager = _cvgControlTower.lockingPositionManager();\n\n        /// @dev get the nextId on the LockingPosition manager\n        uint256 tokenId = _lockingPositionManager.nextId();\n\n        uint256 _mgCvgCreated;\n        /** @dev Update checkpoints for YsCvg TotalSupply and Supply by NFT. */\n        if (ysPercentage != 0) {\n            _ysCvgCheckpoint(lockDuration, (amount * ysPercentage) / MAX_PERCENTAGE, actualCycle, endLockCycle);\n        }\n\n        /** @dev Create voting power through Curve contract, link voting power to the  token (NFT). */\n        if (ysPercentage != MAX_PERCENTAGE) {\n            uint256 amountVote = amount * (MAX_PERCENTAGE - ysPercentage);\n\n            /** @dev Timestamp of the end of locking. */\n            _cvgControlTower.votingPowerEscrow().create_lock(\n                tokenId,\n                amountVote / MAX_PERCENTAGE,\n                block.timestamp + (lockDuration + 1) * 7 days\n            );\n            /// @dev compute the amount of mgCvg\n            _mgCvgCreated = (amountVote * lockDuration) / (MAX_LOCK * MAX_PERCENTAGE);\n\n            /// @dev Automatically add the veCVG and mgCVG in the balance taken from Snapshot.\n            if (isAddToManagedTokens) {\n                _cvgControlTower.lockingPositionDelegate().addTokenAtMint(tokenId, receiver);\n            }\n        }\n\n        LockingPosition memory lockingPosition = LockingPosition({\n            startCycle: actualCycle,\n            lastEndCycle: endLockCycle,\n            totalCvgLocked: amount,\n            mgCvgAmount: _mgCvgCreated,\n            ysPercentage: ysPercentage\n        });\n\n        /** @dev Associate this Locking position on the tokenId. */\n        lockingPositions[tokenId] = lockingPosition;\n\n        LockingExtension memory lockingExtension = LockingExtension({\n            cycleId: actualCycle,\n            endCycle: endLockCycle,\n            cvgLocked: amount,\n            mgCvgAdded: _mgCvgCreated\n        });\n\n        /** @dev Add a lock extension with the initial params of the token minted. */\n        lockExtensions[tokenId].push(lockingExtension);\n\n        /** @dev Transfer CVG from user wallet to here. */\n        cvg.transferFrom(msg.sender, address(this), amount);\n\n        /** @dev Mint the ERC721 representing the user position. */\n        _lockingPositionManager.mint(receiver);\n\n        emit MintLockingPosition(tokenId, lockingPosition, lockingExtension);\n    }\n\n    /**\n     * @notice Increase the amount of CVG token in the locking position proportionally from the actual cycle to the end of lock.\n     * @dev CheckCompliance is not used in this function, as an increase in the amount cannot be detrimental to a potential buyer.\n     * @param tokenId is the token ID of the position to extend\n     * @param amount  of cvg to add to the position\n     * @param operator address of token owner (used when call from cvgUtilities)\n     */\n    function increaseLockAmount(\n        uint256 tokenId,\n        uint256 amount,\n        address operator\n    ) external onlyWalletOrWhiteListedContract {\n        require(amount > 0, \"LTE\");\n        _checkTokenOwnerShip(tokenId, operator);\n\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        LockingPosition memory lockingPosition = lockingPositions[tokenId];\n\n        /** @dev Retrieve actual staking cycle. */\n        uint128 actualCycle = _cvgControlTower.cvgCycle();\n\n        /** @dev Impossible to increase the lock in amount after the end of the lock. */\n        require(lockingPosition.lastEndCycle > actualCycle, \"LOCK_OVER\");\n\n        /** @dev YsCvg TotalSupply Part, access only if some % has been given to ys on the NFT. */\n        if (lockingPosition.ysPercentage != 0) {\n            _ysCvgCheckpoint(\n                lockingPosition.lastEndCycle - actualCycle,\n                (amount * lockingPosition.ysPercentage) / MAX_PERCENTAGE,\n                actualCycle,\n                lockingPosition.lastEndCycle\n            );\n        }\n\n        uint256 _newVotingPower;\n        /** @dev Update voting power through Curve contract, link voting power to the nft tokenId. */\n        if (lockingPosition.ysPercentage != MAX_PERCENTAGE) {\n            uint256 amountVote = amount * (MAX_PERCENTAGE - lockingPosition.ysPercentage);\n            _cvgControlTower.votingPowerEscrow().increase_amount(tokenId, amountVote / MAX_PERCENTAGE);\n            _newVotingPower = (amountVote * (lockingPosition.lastEndCycle - actualCycle)) / (MAX_LOCK * MAX_PERCENTAGE);\n            lockingPositions[tokenId].mgCvgAmount += _newVotingPower;\n        }\n\n        /** @dev Update cvgLocked balance. */\n        lockingPositions[tokenId].totalCvgLocked += amount;\n\n        LockingExtension memory lockingExtension = LockingExtension({\n            cycleId: actualCycle,\n            endCycle: lockingPosition.lastEndCycle,\n            cvgLocked: amount,\n            mgCvgAdded: _newVotingPower\n        });\n\n        /** @dev Add a lock extension linked to the Amount Extension. */\n        lockExtensions[tokenId].push(lockingExtension);\n\n        /** @dev Transfer CVG from user wallet to here. */\n        cvg.transferFrom(msg.sender, address(this), amount);\n\n        emit IncreaseLockAmount(tokenId, lockingPosition, lockingExtension);\n    }\n\n    /**\n     * @notice Increase the time of the lock\n     *         Increasing the locking time will not increase the amount of ysCvg & mgCvg\n     *         The amounts will be just extended on the new duration.\n     * @dev The token must not be time locked  , as an increase in time can be detrimental to a potential buyer.\n     * @param tokenId is the token ID of the position\n     * @param durationAdd is the number of cycle to add to the position lockingTime\n     */\n    function increaseLockTime(\n        uint256 tokenId,\n        uint256 durationAdd\n    ) external checkCompliance(tokenId, address(0)) onlyWalletOrWhiteListedContract {\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        /** @dev Retrieve actual staking cycle. */\n        uint128 actualCycle = _cvgControlTower.cvgCycle();\n\n        LockingPosition storage lockingPosition = lockingPositions[tokenId];\n        uint256 oldEndCycle = lockingPosition.lastEndCycle + 1;\n        uint256 newEndCycle = oldEndCycle + durationAdd;\n\n        /** @dev Not possible extend a lock in duration after it's expiration. */\n        require(oldEndCycle > actualCycle, \"LOCK_TIME_OVER\");\n\n        /** @dev Not possible to have an active lock longer than the MAX_LOCK. */\n        require(newEndCycle - actualCycle - 1 <= MAX_LOCK, \"MAX_LOCK_96_CYCLES\");\n\n        /** @dev As the oldEnd cycle is a xTDE_DURATION. */\n        /** @dev We just need to verify that the time we add is a xTDE_DURATION to ensure new lock is ending on a xTDE_DURATION. */\n        require(durationAdd % TDE_DURATION == 0, \"NEW_END_MUST_BE_TDE_MULTIPLE\");\n\n        /** @dev YsCvg TotalSupply Part, access only if some % has been given to ys on the NFT. */\n        if (lockingPosition.ysPercentage != 0) {\n            /** @dev Retrieve the balance registered at the cycle where the ysBalance is supposed to drop. */\n            uint256 _ysToReport = balanceOfYsCvgAt(tokenId, oldEndCycle - 1);\n            /** @dev Add this value to the tracking on the oldEndCycle. */\n            totalSuppliesTracking[oldEndCycle].ysToAdd += _ysToReport;\n            /** @dev Report this value in the newEndCycle in the Sub part. */\n            totalSuppliesTracking[newEndCycle].ysToSub += _ysToReport;\n        }\n\n        /** @dev Vote part, access here only if some % has been given to ve/mg on the NFT. */\n        if (lockingPosition.ysPercentage != MAX_PERCENTAGE) {\n            /** @dev Increase Locking time to a new timestamp, computed with the cycle. */\n            _cvgControlTower.votingPowerEscrow().increase_unlock_time(\n                tokenId,\n                block.timestamp + ((newEndCycle - actualCycle) * 7 days)\n            );\n        }\n\n        /** @dev Update the new end cycle on the locking position. */\n        lockingPosition.lastEndCycle = uint96(newEndCycle - 1);\n\n        emit IncreaseLockTime(tokenId, lockingPosition, oldEndCycle - 1);\n    }\n\n    /**\n     * @notice Increase first the time THEN the amount in the position proportionally from the actual cycle to the end of lock.\n     * @dev The token must not be time locked, as an increase in the time can be detrimental to a potential buyer.\n     * @param tokenId is the token ID of the position\n     * @param durationAdd is the number of cycle to add to the position lockingTime\n     * @param amount  of cvg to add to the position\n     * @param operator address of token owner (used when call from cvgUtilities)\n     */\n    function increaseLockTimeAndAmount(\n        uint256 tokenId,\n        uint256 durationAdd,\n        uint256 amount,\n        address operator\n    ) external checkCompliance(tokenId, operator) onlyWalletOrWhiteListedContract {\n        require(amount > 0, \"LTE\");\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        /** @dev Retrieve actual staking cycle. */\n        uint128 actualCycle = _cvgControlTower.cvgCycle();\n\n        LockingPosition storage lockingPosition = lockingPositions[tokenId];\n        uint256 oldEndCycle = lockingPosition.lastEndCycle + 1;\n        /** @dev Calculating the new end cycle. */\n        uint256 newEndCycle = oldEndCycle + durationAdd;\n        /** @dev Check  the new end cycle. */\n        require(oldEndCycle > actualCycle, \"LOCK_OVER\");\n        require(newEndCycle - actualCycle - 1 <= MAX_LOCK, \"MAX_LOCK_96_CYCLES\");\n        require(durationAdd % TDE_DURATION == 0, \"END_MUST_BE_TDE_MULTIPLE\");\n\n        if (lockingPosition.ysPercentage != 0) {\n            /** @dev Taking in account the change of YsCvg TotalSupply update. */\n            uint256 _ysToReport = balanceOfYsCvgAt(tokenId, oldEndCycle - 1);\n            totalSuppliesTracking[oldEndCycle].ysToAdd += _ysToReport;\n            totalSuppliesTracking[newEndCycle].ysToSub += _ysToReport;\n\n            _ysCvgCheckpoint(\n                newEndCycle - actualCycle - 1,\n                (amount * lockingPosition.ysPercentage) / MAX_PERCENTAGE,\n                actualCycle,\n                newEndCycle - 1\n            );\n        }\n\n        uint256 _newVotingPower;\n\n        if (lockingPosition.ysPercentage != MAX_PERCENTAGE) {\n            /** @dev Update voting power through veCVG contract, link voting power to the nft tokenId. */\n            uint256 amountVote = amount * (MAX_PERCENTAGE - lockingPosition.ysPercentage);\n            _newVotingPower = (amountVote * (newEndCycle - actualCycle - 1)) / (MAX_LOCK * MAX_PERCENTAGE);\n            lockingPosition.mgCvgAmount += _newVotingPower;\n\n            _cvgControlTower.votingPowerEscrow().increase_unlock_time_and_amount(\n                tokenId,\n                block.timestamp + ((newEndCycle - actualCycle) * 7 days),\n                amountVote / MAX_PERCENTAGE\n            );\n        }\n\n        /** @dev Update the new end cycle on the locking position. */\n        lockingPosition.lastEndCycle = uint96(newEndCycle - 1);\n        lockingPosition.totalCvgLocked += amount;\n\n        LockingExtension memory _lockingExtension = LockingExtension({\n            cycleId: actualCycle,\n            endCycle: uint128(newEndCycle - 1),\n            cvgLocked: amount,\n            mgCvgAdded: _newVotingPower\n        });\n        /** @dev Keep track of the update on the lock , including mgCvg part. */\n        lockExtensions[tokenId].push(_lockingExtension);\n\n        /** @dev Transfer CVG */\n        cvg.transferFrom(msg.sender, address(this), amount);\n\n        emit IncreaseLockTimeAndAmount(tokenId, lockingPosition, _lockingExtension, oldEndCycle - 1);\n    }\n\n    /**\n     * @notice Unlock CVG tokens under the NFT Locking Position : Burn the NFT, Transfer back the CVG to the user.  Rewards from YsDistributor must be claimed before or they will be lost.    * @dev The locking time must be over\n     * @param tokenId to burn\n     */\n    function burnPosition(uint256 tokenId) external {\n        _checkTokenOwnerShip(tokenId, address(0));\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        uint256 lastEndCycle = lockingPositions[tokenId].lastEndCycle;\n        uint256 ysPercentage = lockingPositions[tokenId].ysPercentage;\n        uint256 totalCvgLocked = lockingPositions[tokenId].totalCvgLocked;\n\n        require(_cvgControlTower.cvgCycle() > lastEndCycle, \"LOCKED\");\n\n        /** @dev  if the position contains veCvg , we must remove it from the voting escrow */\n        if (ysPercentage != MAX_PERCENTAGE) {\n            _cvgControlTower.votingPowerEscrow().withdraw(tokenId);\n        }\n\n        /** @dev Burn the NFT representing the position. */\n        _cvgControlTower.lockingPositionManager().burn(tokenId);\n\n        /** @dev Transfer CVG back to the user. */\n        cvg.transfer(msg.sender, totalCvgLocked);\n\n        emit LockingPositionBurn(tokenId);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                    ONLY CONTROL TOWER\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n     * @notice Compute the new Ys total supply  by adding and subtracting checkpoints formerly created on mint & increaseLock by the _YsCvgCheckpoint().\n     * @dev  Only callable by ControlTower ( DAO ).\n     */\n    function updateYsTotalSupply() external {\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n\n        require(msg.sender == address(_cvgControlTower), \"NOT_CONTROL_TOWER\");\n        uint256 actualCycle = _cvgControlTower.cvgCycle();\n\n        uint256 totalSupplyYsCvgBeforeUpdate = totalSupplyYsCvg;\n\n        /** @dev Register the last totalSupply for the past cycle. */\n        totalSupplyYsCvgHistories[actualCycle - 1] = totalSupplyYsCvgBeforeUpdate;\n\n        /** @dev Update ysCVG  total supply with checkpoints for the actual cycle */\n        totalSupplyYsCvg =\n            totalSupplyYsCvgBeforeUpdate +\n            totalSuppliesTracking[actualCycle].ysToAdd -\n            totalSuppliesTracking[actualCycle].ysToSub;\n\n        emit UpdateTotalSupplies(\n            totalSupplyYsCvgBeforeUpdate,\n            _cvgControlTower.votingPowerEscrow().total_supply(),\n            actualCycle - 1\n        );\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                    INTERNAL FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n     *  @notice Compute the new Ys by adding and subtracting\n     *   checkpoints formerly created on mint & increaseLock by the _YsCvgCheckpoint().\n     *  @dev  Only callable by ControlTower ( DAO ).\n     *  @param lockDuration is the duration in cycle(week) of the lock\n     *  @param cvgLockAmount is the amount of cvg to lock in the position\n     *  @param actualCycle is the actual cycle of the cvg\n     *  @param endLockCycle is the end cycle of the lock\n     */\n    function _ysCvgCheckpoint(\n        uint256 lockDuration,\n        uint256 cvgLockAmount,\n        uint256 actualCycle,\n        uint256 endLockCycle\n    ) internal {\n        /** @dev Compute the amount of ysCVG on this Locking Position proportionally with the ratio of lockDuration and MAX LOCK duration. */\n        uint256 ysTotalAmount = (lockDuration * cvgLockAmount) / MAX_LOCK;\n        uint256 realStartCycle = actualCycle + 1;\n        uint256 realEndCycle = endLockCycle + 1;\n        /** @dev If the lock is not made on a TDE cycle,   we need to compute the ratio of ysCVG  for the current partial TDE */\n        if (actualCycle % TDE_DURATION != 0) {\n            /** @dev Get the cycle id of next TDE to be taken into account for this LockingPosition. */\n            uint256 nextTdeCycle = (actualCycle / TDE_DURATION + 1) * TDE_DURATION + 1;\n            /** @dev Represent the amount of ysCvg to be taken into account on the next TDE of this LockingPosition. */\n            uint256 ysNextTdeAmount = ((nextTdeCycle - realStartCycle) * ysTotalAmount) / TDE_DURATION;\n\n            totalSuppliesTracking[realStartCycle].ysToAdd += ysNextTdeAmount;\n\n            /** @dev When a lock is greater than a TDE_DURATION */\n            if (lockDuration >= TDE_DURATION) {\n                /** @dev we add the calculations for the next full TDE */\n                totalSuppliesTracking[nextTdeCycle].ysToAdd += ysTotalAmount - ysNextTdeAmount;\n                totalSuppliesTracking[realEndCycle].ysToSub += ysTotalAmount;\n            }\n            /** @dev If the lock less than TDE_DURATION. */\n            else {\n                /** @dev We simply remove the amount from the supply calculation at the end of the TDE */\n                totalSuppliesTracking[realEndCycle].ysToSub += ysNextTdeAmount;\n            }\n        }\n        /** @dev If the lock is performed on a TDE cycle  */\n        else {\n            totalSuppliesTracking[realStartCycle].ysToAdd += ysTotalAmount;\n            totalSuppliesTracking[realEndCycle].ysToSub += ysTotalAmount;\n        }\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        VIEW FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n     *   @notice Returns the information needed to display the lock position display svg.\n     *   @param _tokenId id of the token\n     */\n    function tokenInfos(uint256 _tokenId) external view returns (TokenView memory) {\n        LockingPosition memory _lockingPosition = lockingPositions[_tokenId];\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n\n        uint256 _cvgCycle = _cvgControlTower.cvgCycle();\n\n        return\n            TokenView({\n                tokenId: _tokenId,\n                cvgLocked: _lockingPosition.totalCvgLocked,\n                startCycle: _lockingPosition.startCycle,\n                endCycle: _lockingPosition.lastEndCycle,\n                veCvgActual: _cvgControlTower.votingPowerEscrow().balanceOf(_tokenId),\n                ysTotal: balanceOfYsCvgAt(_tokenId, _lockingPosition.lastEndCycle),\n                ysActual: balanceOfYsCvgAt(_tokenId, _cvgCycle),\n                mgCvg: _cvgCycle > _lockingPosition.lastEndCycle ? 0 : _lockingPosition.mgCvgAmount,\n                ysPercentage: _lockingPosition.ysPercentage\n            });\n    }\n\n    /**\n     * @notice Fetch the balance of veCVG (gauge voting power)  for a specified tokenId.\n     * @param _tokenId id of the token\n     */\n    function balanceOfVeCvg(uint256 _tokenId) public view returns (uint256) {\n        return cvgControlTower.votingPowerEscrow().balanceOf(_tokenId);\n    }\n\n    /**\n     * @notice Fetch the balance of ysCVG (treasury share)  for a specified tokenId and at a specified cycle, can be in the future.\n     * @param _tokenId id of the token\n     * @param _cycleId id of the cycle\n     */\n    function balanceOfYsCvgAt(uint256 _tokenId, uint256 _cycleId) public view returns (uint256) {\n        require(_cycleId != 0, \"NOT_EXISTING_CYCLE\");\n\n        LockingPosition memory _lockingPosition = lockingPositions[_tokenId];\n        LockingExtension[] memory _extensions = lockExtensions[_tokenId];\n        uint256 _ysCvgBalance;\n\n        /** @dev If the requested cycle is before or after the lock , there is no balance. */\n        if (_lockingPosition.startCycle >= _cycleId || _cycleId > _lockingPosition.lastEndCycle) {\n            return 0;\n        }\n        /** @dev We go through the extensions to compute the balance of ysCvg at the cycleId */\n        for (uint256 i; i < _extensions.length; ) {\n            /** @dev Don't take into account the extensions if in the future. */\n            if (_extensions[i].cycleId < _cycleId) {\n                LockingExtension memory _extension = _extensions[i];\n                uint256 _firstTdeCycle = TDE_DURATION * (_extension.cycleId / TDE_DURATION + 1);\n                uint256 _ysTotal = (((_extension.endCycle - _extension.cycleId) *\n                    _extension.cvgLocked *\n                    _lockingPosition.ysPercentage) / MAX_PERCENTAGE) / MAX_LOCK;\n                uint256 _ysPartial = ((_firstTdeCycle - _extension.cycleId) * _ysTotal) / TDE_DURATION;\n                /** @dev For locks that last less than 1 TDE. */\n                if (_extension.endCycle - _extension.cycleId <= TDE_DURATION) {\n                    _ysCvgBalance += _ysPartial;\n                } else {\n                    _ysCvgBalance += _cycleId <= _firstTdeCycle ? _ysPartial : _ysTotal;\n                }\n            }\n            ++i;\n        }\n        return _ysCvgBalance;\n    }\n\n    /**\n     * @notice  Fetch the balance of mgCVG (meta-governance voting power ) for a specified tokenId and at a specified cycle, this can be in the future.\n     */\n    function balanceOfMgCvgAt(uint256 _tokenId, uint256 _cycleId) public view returns (uint256) {\n        require(_cycleId != 0, \"NOT_EXISTING_CYCLE\");\n\n        LockingPosition memory _lockingPosition = lockingPositions[_tokenId];\n        LockingExtension[] memory _extensions = lockExtensions[_tokenId];\n        uint256 _mgCvgBalance;\n\n        /** @dev If the requested cycle is before or after the lock , there is no balance. */\n        if (_lockingPosition.startCycle > _cycleId || _cycleId > _lockingPosition.lastEndCycle) {\n            return 0;\n        }\n        /** @dev We go through the extensions to compute the balance of mgCvg at the cycleId */\n        for (uint256 i; i < _extensions.length; ) {\n            LockingExtension memory _extension = _extensions[i];\n            if (_extension.cycleId <= _cycleId) {\n                _mgCvgBalance += _extension.mgCvgAdded;\n            }\n            ++i;\n        }\n\n        return _mgCvgBalance;\n    }\n\n    /**\n     * @notice Fetch the balance of mgCVG (meta-governance voting power ) for a specified tokenId.\n     * @param _tokenId id of the token\n     */\n    function balanceOfMgCvg(uint256 _tokenId) public view returns (uint256) {\n        return balanceOfMgCvgAt(_tokenId, cvgControlTower.cvgCycle());\n    }\n\n    /**\n     *   @notice Fetch the voting power (in veCvg) for a specified address, used in the Cvg Governance proposal strategy.\n     *   @param _user is the address that we want to fetch voting power from\n     */\n    function veCvgVotingPowerPerAddress(address _user) external view returns (uint256) {\n        uint256 _totalVotingPower;\n\n        ILockingPositionDelegate _lockingPositionDelegate = cvgControlTower.lockingPositionDelega"
    }
  ]
}