{
  "Title": "Spoofed initial deposits in `SexPartners.sol` and `LpDepositor.sol`",
  "Content": "##### Description\nThe **initial** deposit of NFT is vulnerable to a spoofing attack.\nThe attacker can directly call `onERC721Received` and supply NFT id that was not actually transferred/not owned by the attacker. It may cause a contract malfunction, including contract unusability or incorrect calculation of the rewards. A contract malfunction cannot be fixed without a contract replacement.\n\nPlease note, this attack can only affect a contract at the initial stage, before the initial deposit was made. Spoofing attempts for any deposits except the initial deposit will be reverted or will not change the state of the contract. Thus a contract at the production stage (after the initial deposit) is not vulnerable anymore.\n\n\nLocation of the affected code:\n- https://github.com/solidex-fantom/solidex/blob/8b420ed8bed4b714695d51de2a0f82e38a72e1b2/contracts/SexPartners.sol#L95\n- https://github.com/solidex-fantom/solidex/blob/8b420ed8bed4b714695d51de2a0f82e38a72e1b2/contracts/LpDepositor.sol#L351\n##### Recommendation\nAlthough an attack can be easily detected and mitigated by redeploying of the contracts, we recommend to add explicit checks for the known attack vector.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/SexPartners.sol",
      "content": "pragma solidity 0.8.11;\n\nimport \"./dependencies/Ownable.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/solidly/IVotingEscrow.sol\";\nimport \"./interfaces/solidly/IBaseV1Minter.sol\";\nimport \"./interfaces/solidex/ISolidexToken.sol\";\n\n\ncontract SexPartners is Ownable {\n\n    IVotingEscrow public immutable votingEscrow;\n    IBaseV1Minter public immutable solidMinter;\n\n    IERC20 public SOLIDsex;\n    ISolidexToken public SEX;\n    uint256 public tokenID;\n\n    // current number of early SEX partners\n    uint256 public partnerCount;\n    // timestamp after which new SEX partners receive a reduced\n    // amount of SEX in perpetuity (1 day prior to SOLID emissions starting)\n    uint256 public earlyPartnerDeadline;\n    // timestamp after which new SEX partners are no longer accepted\n    uint256 public finalPartnerDeadline;\n\n    // number of tokens that have been minted via this contract\n    uint256 public totalMinted;\n    // total % of the total supply that this contract is entitled to mint\n    uint256 public totalMintPct;\n\n    struct UserWeight {\n        uint256 tranche;\n        uint256 weight;\n        uint256 claimed;\n    }\n\n    struct Tranche {\n        uint256 minted;\n        uint256 weight;\n        uint256 mintPct;\n    }\n\n    // partners, vests\n    Tranche[2] public trancheData;\n\n    mapping (address => UserWeight) public userData;\n    mapping (address => bool) public isEarlyPartner;\n\n    // maximum number of SEX partners\n    uint256 public constant MAX_PARTNER_COUNT = 15;\n\n    constructor(\n        IVotingEscrow _votingEscrow,\n        IBaseV1Minter _minter,\n        address[] memory _receivers,\n        uint256[] memory _weights\n    ) {\n        votingEscrow = _votingEscrow;\n        solidMinter = _minter;\n\n        uint256 totalWeight;\n        require(_receivers.length == _weights.length);\n        for (uint i = 0; i < _receivers.length; i++) {\n            totalWeight += _weights[i];\n            // set claimed to 1 to avoid initial claim requirement for vestees calling `claim`\n            userData[_receivers[i]] = UserWeight({tranche: 1, weight: _weights[i], claimed: 1});\n        }\n\n        trancheData[1].weight = totalWeight;\n        trancheData[1].mintPct = 20;\n        totalMintPct = 20;\n    }\n\n    function setAddresses(IERC20 _solidsex, ISolidexToken _sex) external onlyOwner {\n        SOLIDsex = _solidsex;\n        SEX = _sex;\n\n        renounceOwnership();\n    }\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenID,\n        bytes calldata\n    ) external returns (bytes4) {\n        UserWeight storage u = userData[_operator];\n        require(u.tranche == 0, \"Conflict of interest!\");\n        require(u.weight == 0, \"Already a partner\");\n        require(partnerCount < MAX_PARTNER_COUNT, \"No more SEX partners allowed!\");\n        (uint256 amount,) = votingEscrow.locked(_tokenID);\n\n        if (tokenID == 0) {\n            // when receiving the first NFT, track the tokenID and set the partnership deadlines\n            tokenID = _tokenID;\n            earlyPartnerDeadline = solidMinter.active_period() + 86400 * 6;\n            finalPartnerDeadline = earlyPartnerDeadline + 86400 * 14;\n            isEarlyPartner[_operator] = true;\n\n        } else if (block.timestamp < earlyPartnerDeadline) {\n            // subsequent NFTs received before the early deadline are merged with the first\n            votingEscrow.merge(_tokenID, tokenID);\n            isEarlyPartner[_operator] = true;\n\n        } else if (block.timestamp < finalPartnerDeadline) {\n            require(_tokenID < 26, \"Only early protocol NFTs are eligible\");\n            require(address(SOLIDsex) != address(0), \"Addresses not set\");\n\n            // NFTs received after the early deadline are immediately converted to SOLIDsex\n            votingEscrow.safeTransferFrom(address(this), address(SOLIDsex), _tokenID);\n            SOLIDsex.transfer(_operator, amount);\n\n            // SEX advance has a 50% immediate penalty and a linear decay to zero over 2 weeks\n            amount = amount / 2 * (finalPartnerDeadline - block.timestamp) / (86400 * 14);\n            uint256 advance = amount / 10;\n            SEX.mint(_operator, advance);\n            u.claimed = advance;\n            trancheData[0].minted += advance;\n            totalMinted += advance;\n\n        } else revert(\"SEX in perpetuity no longer available\");\n\n        u.weight += amount;\n        trancheData[0].weight += amount;\n        partnerCount += 1;\n\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n\n    function earlyPartnerPct() public view returns (uint256) {\n        if (partnerCount < 11) return 10;\n        return partnerCount;\n    }\n\n    function claimable(address account) external view returns (uint256) {\n        if (block.timestamp <= finalPartnerDeadline) return 0;\n        UserWeight storage u = userData[account];\n        Tranche memory t = trancheData[u.tranche];\n\n        uint256 _totalMintPct = totalMintPct;\n        if (trancheData[0].mintPct == 0) {\n            _totalMintPct += earlyPartnerPct();\n            if (u.tranche == 0) t.mintPct = earlyPartnerPct();\n        }\n\n        uint256 supply = SEX.totalSupply() - totalMinted;\n        uint256 mintable = (supply * 100 / (100 - _totalMintPct) - supply) * t.mintPct / _totalMintPct;\n        if (mintable < t.minted) mintable = t.minted;\n\n        uint256 totalClaimable = mintable * u.weight / t.weight;\n        if (totalClaimable < u.claimed) return 0;\n        return totalClaimable - u.claimed;\n\n    }\n\n    function claim() external returns (uint256) {\n        UserWeight storage u = userData[msg.sender];\n        Tranche storage t = trancheData[u.tranche];\n\n        require(u.weight > 0, \"Not a SEX partner\");\n        require(u.claimed > 0, \"Must make initial claim first\");\n        require(block.timestamp > finalPartnerDeadline, \"Cannot claim yet\");\n\n        if (trancheData[0].mintPct == 0) {\n            trancheData[0].mintPct = earlyPartnerPct();\n            totalMintPct += trancheData[0].mintPct;\n        }\n\n        // mint new SEX based on supply that was minted via regular emissions\n        uint256 supply = SEX.totalSupply() - totalMinted;\n        uint256 mintable = (supply * 100 / (100 - totalMintPct) - supply) * t.mintPct / totalMintPct;\n        if (mintable > t.minted) {\n            uint256 amount = mintable - t.minted;\n            SEX.mint(address(this), amount);\n            t.minted = mintable;\n            totalMinted += amount;\n        }\n\n        uint256 totalClaimable = t.minted * u.weight / t.weight;\n        if (totalClaimable > u.claimed) {\n            uint256 amount = totalClaimable - u.claimed;\n            SEX.transfer(msg.sender, amount);\n            u.claimed = totalClaimable;\n            return amount;\n        }\n        return 0;\n\n    }\n\n    function earlyPartnerClaim() external returns (uint256) {\n        require(block.timestamp > earlyPartnerDeadline, \"Cannot claim yet\");\n        require(owner == address(0), \"Addresses not set\");\n        UserWeight storage u = userData[msg.sender];\n        require(u.tranche == 0 && u.weight > 0, \"Not a SEX partner\");\n        require(u.claimed == 0, \"SEX advance already claimed\");\n        Tranche storage t = trancheData[0];\n\n        if (votingEscrow.ownerOf(tokenID) == address(this)) {\n            // transfer the NFT to mint early partner SOLIDsex\n            votingEscrow.safeTransferFrom(address(this), address(SOLIDsex), tokenID);\n        }\n\n        // transfer owed SOLIDsex\n        uint256 amount = u.weight;\n        SOLIDsex.transfer(msg.sender, amount);\n\n        // mint SEX advance\n        amount /= 10;\n        u.claimed = amount;\n        t.minted += amount;\n        totalMinted += amount;\n        SEX.mint(msg.sender, amount);\n\n        return amount;\n    }\n\n}"
    },
    {
      "filename": "contracts/LpDepositor.sol",
      "content": "pragma solidity 0.8.11;\n\nimport \"./dependencies/Ownable.sol\";\nimport \"./dependencies/SafeERC20.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/solidly/IBaseV1Voter.sol\";\nimport \"./interfaces/solidly/IGauge.sol\";\nimport \"./interfaces/solidly/IBribe.sol\";\nimport \"./interfaces/solidly/IVotingEscrow.sol\";\nimport \"./interfaces/solidex/IFeeDistributor.sol\";\nimport \"./interfaces/solidex/ISolidexToken.sol\";\nimport \"./interfaces/solidex/ILpDepositToken.sol\";\nimport \"./interfaces/solidex/IVeDepositor.sol\";\n\n\ncontract LpDepositor is Ownable {\n\n    using SafeERC20 for IERC20;\n\n    // solidly contracts\n    IERC20 public immutable SOLID;\n    IVotingEscrow public immutable votingEscrow;\n    IBaseV1Voter public immutable solidlyVoter;\n\n    // solidex contracts\n    ISolidexToken public SEX;\n    IVeDepositor public SOLIDsex;\n    IFeeDistributor public feeDistributor;\n    address public stakingRewards;\n    address public tokenWhitelister;\n    address public depositTokenImplementation;\n\n    uint256 public tokenID;\n\n    struct Amounts {\n        uint256 solid;\n        uint256 sex;\n    }\n\n    // pool -> gauge\n    mapping(address => address) public gaugeForPool;\n    // pool -> bribe\n    mapping(address => address) public bribeForPool;\n    // pool -> solidex deposit token\n    mapping(address => address) public tokenForPool;\n    // user -> pool -> deposit amount\n    mapping(address => mapping(address => uint256)) public userBalances;\n    // pool -> total deposit amount\n    mapping(address => uint256) public totalBalances;\n    // pool -> integrals\n    mapping(address => Amounts) public rewardIntegral;\n    // user -> pool -> integrals\n    mapping(address => mapping(address => Amounts)) public rewardIntegralFor;\n    // user -> pool -> claimable\n    mapping(address => mapping(address => Amounts)) claimable;\n\n    // internal accounting to track SOLID fees for SOLIDsex stakers and SEX lockers\n    uint256 unclaimedSolidBonus;\n\n    event RewardAdded(address indexed rewardsToken, uint256 reward);\n    event Deposited(address indexed user, address indexed pool, uint256 amount);\n    event Withdrawn(address indexed user, address indexed pool, uint256 amount);\n    event RewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);\n    event TransferDeposit(address indexed pool, address indexed from, address indexed to, uint256 amount);\n\n    constructor(\n        IERC20 _solid,\n        IVotingEscrow _votingEscrow,\n        IBaseV1Voter _solidlyVoter\n\n    ) {\n        SOLID = _solid;\n        votingEscrow = _votingEscrow;\n        solidlyVoter = _solidlyVoter;\n    }\n\n    function setAddresses(\n        ISolidexToken _sex,\n        IVeDepositor _solidsex,\n        address _solidexVoter,\n        IFeeDistributor _feeDistributor,\n        address _stakingRewards,\n        address _tokenWhitelister,\n        address _depositToken\n    ) external onlyOwner {\n        SEX = _sex;\n        SOLIDsex = _solidsex;\n        feeDistributor = _feeDistributor;\n        stakingRewards = _stakingRewards;\n        tokenWhitelister = _tokenWhitelister;\n        depositTokenImplementation = _depositToken;\n\n        SOLID.approve(address(_solidsex), type(uint256).max);\n        _solidsex.approve(address(_feeDistributor), type(uint256).max);\n        votingEscrow.setApprovalForAll(_solidexVoter, true);\n        votingEscrow.setApprovalForAll(address(_solidsex), true);\n\n        renounceOwnership();\n    }\n\n    /**\n        @dev Ensure SOLID, SEX and SOLIDsex are whitelisted\n     */\n    function whitelistProtocolTokens() external {\n        require(tokenID != 0, \"No initial NFT deposit\");\n        if (!solidlyVoter.isWhitelisted(address(SOLID))) {\n            solidlyVoter.whitelist(address(SOLID), tokenID);\n        }\n        if (!solidlyVoter.isWhitelisted(address(SOLIDsex))) {\n            solidlyVoter.whitelist(address(SOLIDsex), tokenID);\n        }\n        if (!solidlyVoter.isWhitelisted(address(SEX))) {\n            solidlyVoter.whitelist(address(SEX), tokenID);\n        }\n    }\n\n    /**\n        @notice Get pending SOLID and SEX rewards earned by `account`\n        @param account Account to query pending rewards for\n        @param pools List of pool addresses to query rewards for\n        @return pending Array of tuples of (SOLID rewards, SEX rewards) for each item in `pool`\n     */\n    function pendingRewards(\n        address account,\n        address[] calldata pools\n    )\n        external\n        view\n        returns (Amounts[] memory pending)\n    {\n        pending = new Amounts[](pools.length);\n        for (uint256 i = 0; i < pools.length; i++) {\n            address pool = pools[i];\n            pending[i] = claimable[account][pool];\n            uint256 balance = userBalances[account][pool];\n            if (balance == 0) continue;\n\n            Amounts memory integral = rewardIntegral[pool];\n            uint256 total = totalBalances[pool];\n            if (total > 0) {\n                uint256 delta = IGauge(gaugeForPool[pool]).earned(address(SOLID), address(this));\n                delta -= delta * 15 / 100;\n                integral.solid += 1e18 * delta / total;\n                integral.sex += 1e18 * (delta * 10000 / 42069) / total;\n            }\n\n            Amounts storage integralFor = rewardIntegralFor[account][pool];\n            if (integralFor.solid < integral.solid) {\n                pending[i].solid += balance * (integral.solid - integralFor.solid) / 1e18;\n                pending[i].sex += balance * (integral.sex - integralFor.sex) / 1e18;\n            }\n        }\n        return pending;\n    }\n\n    /**\n        @notice Deposit Solidly LP tokens into a gauge via this contract\n        @dev Each deposit is also represented via a new ERC20, the address\n             is available by querying `tokenForPool(pool)`\n        @param pool Address of the pool token to deposit\n        @param amount Quantity of tokens to deposit\n     */\n    function deposit(address pool, uint256 amount) external {\n        require(tokenID != 0, \"Must lock SOLID first\");\n        require(amount > 0, \"Cannot deposit zero\");\n\n        address gauge = gaugeForPool[pool];\n        uint256 total = totalBalances[pool];\n        uint256 balance = userBalances[msg.sender][pool];\n\n        if (gauge == address(0)) {\n            gauge = solidlyVoter.gauges(pool);\n            if (gauge == address(0)) {\n                gauge = solidlyVoter.createGauge(pool);\n            }\n            gaugeForPool[pool] = gauge;\n            bribeForPool[pool] = solidlyVoter.bribes(gauge);\n            tokenForPool[pool] = _deployDepositToken(pool);\n            IERC20(pool).approve(gauge, type(uint256).max);\n        } else {\n            _updateIntegrals(msg.sender, pool, gauge, balance, total);\n        }\n\n        IERC20(pool).transferFrom(msg.sender, address(this), amount);\n        IGauge(gauge).deposit(amount, tokenID);\n\n        userBalances[msg.sender][pool] = balance + amount;\n        totalBalances[pool] = total + amount;\n        IDepositToken(tokenForPool[pool]).mint(msg.sender, amount);\n        emit Deposited(msg.sender, pool, amount);\n    }\n\n    /**\n        @notice Withdraw Solidly LP tokens\n        @param pool Address of the pool token to withdraw\n        @param amount Quantity of tokens to withdraw\n     */\n    function withdraw(address pool, uint256 amount) external {\n        address gauge = gaugeForPool[pool];\n        uint256 total = totalBalances[pool];\n        uint256 balance = userBalances[msg.sender][pool];\n\n        require(gauge != address(0), \"Unknown pool\");\n        require(amount > 0, \"Cannot withdraw zero\");\n        require(balance >= amount, \"Insufficient deposit\");\n\n        _updateIntegrals(msg.sender, pool, gauge, balance, total);\n\n        userBalances[msg.sender][pool] = balance - amount;\n        totalBalances[pool] = total - amount;\n\n        IDepositToken(tokenForPool[pool]).burn(msg.sender, amount);\n        IGauge(gauge).withdraw(amount);\n        IERC20(pool).transfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, pool, amount);\n    }\n\n    /**\n        @notice Claim SOLID and SEX rewards earned from depositing LP tokens\n        @dev An additional 5% of SEX is also minted for `StakingRewards`\n        @param pools List of pools to claim for\n     */\n    function getReward(address[] calldata pools) external {\n        Amounts memory claims;\n        for (uint256 i = 0; i < pools.length; i++) {\n            address pool = pools[i];\n            address gauge = gaugeForPool[pool];\n            uint256 total = totalBalances[pool];\n            uint256 balance = userBalances[msg.sender][pool];\n            _updateIntegrals(msg.sender, pool, gauge, balance, total);\n            claims.solid += claimable[msg.sender][pool].solid;\n            claims.sex += claimable[msg.sender][pool].sex;\n            delete claimable[msg.sender][pool];\n        }\n        if (claims.solid > 0) {\n            SOLID.transfer(msg.sender, claims.solid);\n            emit RewardPaid(msg.sender, address(SOLID), claims.solid);\n        }\n        if (claims.sex > 0) {\n            SEX.mint(msg.sender, claims.sex);\n            emit RewardPaid(msg.sender, address(SEX), claims.sex);\n            // mint an extra 5% for SOLIDsex stakers\n            SEX.mint(address(stakingRewards), claims.sex * 100 / 95 - claims.sex);\n            emit RewardPaid(address(stakingRewards), address(SEX), claims.sex * 100 / 95 - claims.sex);\n        }\n    }\n\n    /**\n        @notice Claim incentive tokens from gauge and/or bribe contracts\n                and transfer them to `FeeDistributor`\n        @dev This method is unguarded, anyone can claim any reward at any time.\n             Claimed tokens are streamed to SEX lockers starting at the beginning\n             of the following epoch week.\n        @param pool Address of the pool token to claim for\n        @param gaugeRewards List of incentive tokens to claim for in the pool's gauge\n        @param bribeRewards List of incentive tokens to claim for in the pool's bribe contract\n     */\n    function claimLockerRewards(\n        address pool,\n        address[] calldata gaugeRewards,\n        address[] calldata bribeRewards\n    ) external {\n        // claim pending gauge rewards for this pool to update `unclaimedSolidBonus`\n        address gauge = gaugeForPool[pool];\n        require(gauge != address(0), \"Unknown pool\");\n        _updateIntegrals(address(0), pool, gauge, 0, totalBalances[pool]);\n\n        address distributor = address(feeDistributor);\n        uint256 amount;\n\n        // fetch gauge rewards and push to the fee distributor\n        if (gaugeRewards.length > 0) {\n            IGauge(gauge).getReward(address(this), gaugeRewards);\n            for (uint i = 0; i < gaugeRewards.length; i++) {\n                IERC20 reward = IERC20(gaugeRewards[i]);\n                require(reward != SOLID, \"!SOLID as gauge reward\");\n                amount = IERC20(reward).balanceOf(address(this));\n                if (amount == 0) continue;\n                if (reward.allowance(address(this), distributor) == 0) {\n                    reward.safeApprove(distributor, type(uint256).max);\n                }\n                IFeeDistributor(distributor).depositFee(address(reward), amount);\n            }\n        }\n\n        // fetch bribe rewards and push to the fee distributor\n        if (bribeRewards.length > 0) {\n            uint256 solidBalance = SOLID.balanceOf(address(this));\n            IBribe(bribeForPool[pool]).getReward(tokenID, bribeRewards);\n            for (uint i = 0; i < bribeRewards.length; i++) {\n                IERC20 reward = IERC20(bribeRewards[i]);\n                if (reward == SOLID) {\n                    // when SOLID is received as a bribe, add it to the balance\n                    // that will be converted to SOLIDsex prior to distribution\n                    uint256 newBalance = SOLID.balanceOf(address(this));\n                    unclaimedSolidBonus += newBalance - solidBalance;\n                    solidBalance = newBalance;\n                    continue;\n                }\n                amount = reward.balanceOf(address(this));\n                if (amount == 0) continue;\n                if (reward.allowance(address(this), distributor) == 0) {\n                    reward.safeApprove(distributor, type(uint256).max);\n                }\n                IFeeDistributor(distributor).depositFee(address(reward), amount);\n            }\n        }\n\n        amount = unclaimedSolidBonus;\n        if (amount > 0) {\n            // lock 5% of earned SOLID and distribute SOLIDsex to SEX lockers\n            uint256 lockAmount = amount / 3;\n            SOLIDsex.depositTokens(lockAmount);\n            IFeeDistributor(distributor).depositFee(address(SOLIDsex), lockAmount);\n\n            // distribute 10% of earned SOLID to SOLIDsex stakers\n            amount -= lockAmount;\n            SOLID.transfer(address(stakingRewards), amount);\n            unclaimedSolidBonus = 0;\n        }\n    }\n\n    // External guarded functions - only callable by other protocol contracts ** //\n\n    function transferDeposit(address pool, address from, address to, uint256 amount) external returns (bool) {\n        require(msg.sender == tokenForPool[pool], \"Unauthorized caller\");\n        require(amount > 0, \"Cannot transfer zero\");\n\n        address gauge = gaugeForPool[pool];\n        uint256 total = totalBalances[pool];\n\n        uint256 balance = userBalances[from][pool];\n        require(balance >= amount, \"Insufficient balance\");\n        _updateIntegrals(from, pool, gauge, balance, total);\n        userBalances[from][pool] = balance - amount;\n\n        balance = userBalances[to][pool];\n        _updateIntegrals(to, pool, gauge, balance, total - amount);\n        userBalances[to][pool] = balance + amount;\n        emit TransferDeposit(pool, from, to, amount);\n        return true;\n    }\n\n    function whitelist(address token) external returns (bool) {\n        require(msg.sender == tokenWhitelister, \"Only whitelister\");\n        require(votingEscrow.balanceOfNFT(tokenID) > solidlyVoter.listing_fee(), \"Not enough veSOLID\");\n        solidlyVoter.whitelist(token, tokenID);\n        return true;\n    }\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenID,\n        bytes calldata\n    )external returns (bytes4) {\n        // VeDepositor transfers the NFT to this contract so this callback is required\n        require(_operator == address(SOLIDsex));\n\n        if (tokenID == 0) {\n            tokenID = _tokenID;\n        }\n\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n\n    // ** Internal functions ** //\n\n    function _deployDepositToken(address pool) internal returns (address token) {\n        // taken from https://solidity-by-example.org/app/minimal-proxy/\n        bytes20 targetBytes = bytes20(depositTokenImplementation);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            token := create(0, clone, 0x37)\n        }\n        IDepositToken(token).initialize(pool);\n        return token;\n    }\n\n    function _updateIntegrals(\n        address user,\n        address pool,\n        address gauge,\n        uint256 balance,\n        uint256 total\n    ) internal {\n        Amounts memory integral = rewardIntegral[pool];\n        if (total > 0) {\n            uint256 delta = SOLID.balanceOf(address(this));\n            address[] memory rewards = new address[](1);\n            rewards[0] = address(SOLID);\n            IGauge(gauge).getReward(address(this), rewards);\n            delta = SOLID.balanceOf(address(this)) - delta;\n            if (delta > 0) {\n                uint256 fee = delta * 15 / 100;\n                delta -= fee;\n                unclaimedSolidBonus += fee;\n\n                integral.solid += 1e18 * delta / total;\n                integral.sex += 1e18 * (delta * 10000 / 42069) / total;\n                rewardIntegral[pool] = integral;\n            }\n        }\n        if (user != address(0)) {\n            Amounts memory integralFor = rewardIntegralFor[user][pool];\n            if (integralFor.solid < integral.solid) {\n                Amounts storage claims = claimable[user][pool];\n                claims.solid += balance * (integral.solid - integralFor.solid) / 1e18;\n                claims.sex += balance * (integral.sex - integralFor.sex) / 1e18;\n                rewardIntegralFor[user][pool] = integral;\n            }\n        }\n    }\n\n}"
    }
  ]
}