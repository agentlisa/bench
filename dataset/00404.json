{
  "Title": "M-12: Loss of funds for trader because whitelisted maker can't be liquidated",
  "Content": "# Issue M-12: Loss of funds for trader because whitelisted maker can't be liquidated \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/140 \n\n## Found by \n0xumarkhatab, ge6a, santipu\\_\n## Summary\n\nIn the current implementation, a whitelisted maker cannot be liquidated, thus it can accumulate losses even after the available margin is exhausted. This leads to losses for the traders because they won't be able to close their profitable positions due to a revert on _checkMarginRequirement.\n\n## Vulnerability Detail\n\nScenario:\n\n1) A trader opens a long position against a whitelisted maker.\n2) After some time, the price increases significantly. At this point, there are more long positions open than short positions, so this maker incurs large losses. The margin is not sufficient to cover them. However, the maker cannot be liquidated and continues to accumulate losses.\n3) The trader decides to close their position and withdraw their profit. However, this cannot happen because the _closePositionFor function calls _checkMarginRequirement for the maker. vault.getFreeCollateralForTrade is < 0, leading to a revert. The trader cannot close their position. The only solution is for LPs to deposit additional collateral to cover the losses, but it doesn't make sense to deposit funds to cover losses.\n4) The price decreases, and the trader loses their profit. Due to fees or a sudden price drop, the trader may also lose part of the margin.\n\nIn the described circumstances, the trader takes the risk by opening a position, but there is no way to close it and withdraw the profit. Thus, instead of gaining from the winning position, they incur losses.\n\n<details>\n<summary>POC</summary>\n\n```solidity\n\n    function testNotEnoughBalancePnlPool() public \n    {\n        _deposit(marketId, taker1, 10000e6);\n\n        vm.prank(taker1);\n        clearingHouse.openPosition(\n            IClearingHouse.OpenPositionParams({\n                marketId: marketId,\n                maker: address(maker),\n                isBaseToQuote: false,\n                isExactInput: false,\n                amount: 1000 ether,\n                oppositeAmountBound: 100000 ether,\n                deadline: block.timestamp,\n                makerData: \"\"\n            })\n        );\n\n        console.log(\"Pnl pool balance: %d\", vault.getPnlPoolBalance(marketId));\n\n        maker.setBaseToQuotePrice(111e18);\n        maker2.setBaseToQuotePrice(111e18);\n        _mockPythPrice(111, 0);\n\n        console.log(\"getFreeCollateralForTrade:\");\n        console.logInt(vault.getFreeCollateralForTrade(marketId, address(maker), 111e18, MarginRequirementType.MAINTENANCE));\n\n        vm.prank(taker1);\n        //this will revert with NotEnoughFreeCollateral error\n        clearingHouse.closePosition(\n            IClearingHouse.ClosePositionParams({\n                marketId: marketId,\n                maker: address(maker),\n                oppositeAmountBound: 1000 ether,\n                deadline: block.timestamp,\n                makerData: \"\"\n            })\n        );\n    }\n```\n\n</details>\n\n## Impact\n\nLoss of funds for the trader + broken core functionality because of inability to close a position.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/src/clearingHouse/ClearingHouse.sol#L267-L356\n\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/src/clearingHouse/ClearingHouse.sol#L488-L524\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe best solution is to implement liquidation for whitelisted maker. If not possible, you can mitigate the issue with larger margin requirement for whitelisted makers.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  the natsepc says that liquidating whitelisted maker is not allwoed, so i will considered this a know issue\n\n\n\n**vinta**\n\nAgree with takarez that this is a known issue.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> According to the Sherlock docs, the Sherlock rules for valid issues have more weight than the code comments:\n> \n> > Hierarchy of truth: Contest README > Sherlock rules for valid issues > protocol documentation (including code comments) > protocol answers on the contest public Discord channel.\n> While considering the validity of an issue in case of any conflict the sources of truth are prioritized in the above order.\n> \n> Given that this issue is not mentioned in the contest README and clearly demonstrates that it will cause a loss of funds, I think it should be considered a valid issue, as well as its duplicates. \n\nYou've deleted an escalation for this issue.\n\n**IllIllI000**\n\n@santipu03 nowhere does it say that there's a guarantee that the makers will provide liquidity 100% of the time, and in any market, if there's no liquidity at the price you want, that's a you problem, not a security issue. There are expected to be other market participants who can provide liquidity for closing positions, and even if bad debt does occur, the system allows for and tracks it. Just looking at the code, not just the comments, it [expects](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/clearingHouse/ClearingHouse.sol#L166-L168) that whitelisted makers can't be liquidated, so it's not clear that anything in the design is being violated. I agree that the hierarchy is a bit confusing and I would like it to be updated and clarified, but if this escalation can be closed on facts not relating specifically to the ambiguities in the hierarchy, I think we may not get such an update.\n\n**santipu03**\n\n@IllIllI000 Now that I have checked better the 3 duplicated issues, only my issue (#65) describes the full and valid impact: **Whitelisted makers that cannot be liquidated will generate bad debt on the protocol**, creating a loss for all users. \n\nYou're right that the intended design is to not liquidate whitelisted makers, but that will create bad debt on the protocol, and therefore cause a loss of funds. The Sherlock docs state that design decisions are not valid issues if they don't imply any loss of funds, but this issue will imply a loss of funds and therefore should be valid. \n\nI will remove my escalation here and I will escalate my issue (#65). \n\n**gstoyanovbg**\n\nEscalate\n\nThe previous escalation was removed because the Watson decided that theirs issue is not duplicate of this one. This is why i escalate it again.\n\n> Hierarchy of truth: Contest README > Sherlock rules for valid issues > protocol documentation (including code comments) > protocol answers on the contest public Discord channel.\nWhile considering the validity of an issue in case of any conflict the sources of truth are prioritized in the above order.\n\nThe hierarchy of truth clearly states that contest's README has more weight than code comments. This issue is not part of the known issues section of the README so it is not known issue in the context of the contest.\n\nI believe it is a valid issue.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> The previous escalation was removed because the Watson decided that theirs issue is not duplicate of this one. This is why i escalate it again.\n> \n> > Hierarchy of truth: Contest README > Sherlock rules for valid issues > protocol documentation (including code comments) > protocol answers on the contest public Discord channel.\n> While considering the validity of an issue in case of any conflict the sources of truth are prioritized in the above order.\n> \n> The hierarchy of truth clearly states that contest's README has more weight than code comments. This issue is not part of the known issues section of the README so it is not known issue in the context of the contest.\n> \n> I believe it is a valid issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nAgree with @IllIllI000 comments [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/140#issuecomment-2039482116), I believe it is a known issue within code comments that whitelisted maker cannot be liquidated\n\n**WangSecurity**\n\nAgree with LSW and the Lead Judge. The hierarchy of truth can be applied when there is conflicting information between the code and the rules, but the code and documentation can be used to define the intended design and known issues of the protocol. We understand that it's a bit confusing, but hope for your understanding. Therefore, I agree it's an intended design and a known issue.\n\nPlanning to reject the escalation and leave the issue as it is.\n\n**Evert0x**\n\nResult:\nInvalid\nHas Duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [gstoyanovbg](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/140/#issuecomment-2041339059): rejected\n\n**gstoyanovbg**\n\n> Agree with LSW and the Lead Judge. The hierarchy of truth can be applied when there is conflicting information between the code and the rules, but the code and documentation can be used to define the intended design and known issues of the protocol. We understand that it's a bit confusing, but hope for your understanding. Therefore, I agree it's an intended design and a known issue.\n> \n> Planning to reject the escalation and leave the issue as it is.\n\nFrom Watson's point view there is no way to know when this rule should be applied and when shouldn't. Everyone interpreted it differently.\n\n> // We don't allow liquidating whitelisted makers for now until we implement safety mechanism\n        // For spot-hedged base maker, it needs to implement rebalance once it got liquidated\n\nNowhere is stated that this cause other issues neither in the comment or in the known issues section. Moreover this line from the rules :\n\n> Hierarchy of truth: Contest README > Sherlock rules for valid issues > protocol documentation (including code comments) > protocol answers on the contest public Discord channel.\nWhile considering the validity of an issue in case of any conflict the sources of truth are prioritized in the above order.\n\nunambiguously say that the README has more weight than \"protocol documentation (including code comments)\". In your comment you say that \n\n> The hierarchy of truth can be applied when there is conflicting information between the code and the rules\n\nbut this is not true according to the above rule which states that the conflict may be between ALL sources of truth : \n\n> While considering the validity of an issue in case of any conflict **the sources of truth are prioritized in the above order**.\n\nSo i don't understand the decision - from my point of view i am penalized with worsen ratio because follow the rules and interpret them in the way they are written.\n\n**santipu03**\n\n@gstoyanovbg I totally agree with you, I think in this contest the judges suddenly have decided to make decisions against the current hierarchy of truth. I've got a couple of issues that have been rejected that also should be valid based on the **current** hierarchy, damaging my issues ratio and escalations ratio. \n\n@WangSecurity @Evert0x \nIf you have decided now that the hierarchy of truth must be changed, that's totally fair. However, these new changes should be applied to contests still not finished, not to a contest that has already finished like this one. I think it's greatly unfair that these changes haven't been announced anywhere and now some Watsons are suffering its consequences.\n\nI don't mean anything here in a bad way, I honestly think Sherlock always has been characterized by its transparent and fair judging, so that's why now I'm surprised by these sudden changes in the rules. I would like to kindly ask the judges to reconsider some decisions that have been made during these last days to issues regarding \"_known issues_\" vaguely described by a few code comments. Thanks.\n\n**IllIllI000**\n\n@santipu03 and @gstoyanovbg while I agree that the hierarchy is unclear, it was discussed here: https://github.com/sherlock-audit/2024-03-vvv-vesting-staking-judging/issues/148#issuecomment-2045743718 and I believe the current judge is interpreting things in a similar way\n\n**santipu03**\n\n> @santipu03 and @gstoyanovbg while I agree that the hierarchy is unclear, it was discussed here: https://github.com/sherlock-audit/2024-03-vvv-vesting-staking-judging/issues/148#issuecomment-2045743718 and I believe the current judge is interpreting things in a similar way\n\nI think there's a fundamental difference between the referenced discussion and the scenario we have here. Even if we consider that the code comments describe this scenario as a known issue, which I don't agree btw, we still have conflicting information between the code comments and the Sherlock rules. \n\nSimply put, I think there is a conflict because the rules are saying this issue should be a MEDIUM (because it causes a loss of funds), and the code comments are _saying_ that this issue should be INVALID (known issue). To me, this is conflicting information and the Sherlock rules should have priority over the code comments, as the hierarchy states.\nCC. @WangSecurity and @Evert0x.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/clearingHouse/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { LibPosition } from \"../vault/LibPosition.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { IMarginProfile, MarginRequirementType } from \"../vault/IMarginProfile.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IMaker } from \"../maker/IMaker.sol\";\nimport { AuthorizationUpgradeable } from \"../authorization/AuthorizationUpgradeable.sol\";\nimport { IClearingHouse } from \"./IClearingHouse.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { PositionChangedReason } from \"../vault/PositionChangedReason.sol\";\nimport { LibLiquidation, MaintenanceMarginProfile, LiquidationResult } from \"./LibLiquidation.sol\";\n\ncontract ClearingHouse is\n    IClearingHouse,\n    AuthorizationUpgradeable,\n    AddressResolverUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20Metadata;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n    using LibFormatter for uint256;\n    using LibAddressResolver for IAddressManager;\n    using LibLiquidation for MaintenanceMarginProfile;\n\n    //\n    // STRUCT\n    //\n\n    struct OpenPositionResult {\n        int256 base;\n        int256 quote;\n        bool isTakerReducing;\n        bool isMakerReducing;\n    }\n\n    struct EmitLiquidatedEventParams {\n        uint256 marketId;\n        address liquidator;\n        address trader;\n        int256 positionSizeDelta;\n        int256 positionNotionalDelta;\n        uint256 price;\n        uint256 penalty;\n        uint256 liquidationFeeToLiquidator;\n        uint256 liquidationFeeToProtocol;\n    }\n\n    struct CheckMarginRequirementParams {\n        IVault vault;\n        uint256 marketId;\n        address trader;\n        uint256 price;\n        bool isReducing;\n    }\n\n    //\n    // MODIFIER\n    //\n    modifier nonZero(uint256 amount) {\n        if (amount == 0) revert LibError.ZeroAmount();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager) external initializer {\n        __AddressResolver_init(addressManager);\n        __Authorization_init();\n        __ReentrancyGuard_init();\n    }\n\n    /// @inheritdoc IClearingHouse\n    function openPosition(OpenPositionParams calldata params) external returns (int256, int256) {\n        return _openPositionFor(_sender(), params);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function openPositionFor(OpenPositionForParams calldata params) external returns (int256, int256) {\n        _checkIsSenderAuthorizedBy(params.taker);\n        _chargeRelayFee(params.taker, params.takerRelayFee, params.maker, params.makerRelayFee);\n        return\n            _openPositionFor(\n                params.taker,\n                IClearingHouse.OpenPositionParams({\n                    marketId: params.marketId,\n                    maker: params.maker,\n                    isBaseToQuote: params.isBaseToQuote,\n                    isExactInput: params.isExactInput,\n                    amount: params.amount,\n                    oppositeAmountBound: params.oppositeAmountBound,\n                    deadline: params.deadline,\n                    makerData: params.makerData\n                })\n            );\n    }\n\n    /// @inheritdoc IClearingHouse\n    function quoteOpenPosition(OpenPositionParams calldata params) external returns (int256, int256) {\n        address taker = _sender();\n        uint256 price = _getPrice(params.marketId);\n\n        IVault vault = _getVault();\n        OpenPositionResult memory result = _openPosition(vault, taker, params, PositionChangedReason.Trade);\n\n        // Only check maker's margin is sufficient for filling order\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: params.marketId,\n                trader: params.maker,\n                price: price,\n                isReducing: result.isMakerReducing\n            })\n        );\n\n        revert LibError.QuoteResult(result.base, result.quote);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function closePosition(ClosePositionParams calldata params) external returns (int256, int256) {\n        return _closePositionFor(_sender(), params);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function closePositionFor(ClosePositionForParams calldata params) external returns (int256, int256) {\n        _checkIsSenderAuthorizedBy(params.taker);\n        _chargeRelayFee(params.taker, params.takerRelayFee, params.maker, params.makerRelayFee);\n        return\n            _closePositionFor(\n                params.taker,\n                IClearingHouse.ClosePositionParams({\n                    marketId: params.marketId,\n                    maker: params.maker,\n                    oppositeAmountBound: params.oppositeAmountBound,\n                    deadline: params.deadline,\n                    makerData: params.makerData\n                })\n            );\n    }\n\n    /// @inheritdoc IClearingHouse\n    function liquidate(\n        LiquidatePositionParams calldata params\n    ) external nonZero(params.positionSize) returns (int256, int256) {\n        // We don't allow liquidating whitelisted makers for now until we implement safety mechanism\n        // For spot-hedged base maker, it needs to implement rebalance once it got liquidated\n        if (_isWhitelistedMaker(params.marketId, params.trader)) {\n            revert LibError.CannotLiquidateWhitelistedMaker();\n        }\n\n        // calculate how much size can be liquidated, and how much open notional will be reduced correspondingly\n        address liquidator = _sender();\n        MaintenanceMarginProfile memory mmProfile = _getMaintenanceMarginProfile(\n            params.marketId,\n            params.trader,\n            _getPrice(params.marketId)\n        );\n        LiquidationResult memory result = mmProfile.getLiquidationResult(params.positionSize);\n        if (result.liquidatedPositionSizeDelta == 0) revert LibError.NotLiquidatable(params.marketId, params.trader);\n\n        // settle to vault, pay out liquidation fee to liquidator and protocol\n        IVault vault = _getVault();\n        int256 liquidatorPositionSizeBefore = vault.getPositionSize(params.marketId, liquidator);\n        vault.settlePosition(\n            IVault.SettlePositionParams({\n                marketId: params.marketId,\n                taker: params.trader,\n                maker: liquidator,\n                takerPositionSize: result.liquidatedPositionSizeDelta,\n                takerOpenNotional: result.liquidatedPositionNotionalDelta,\n                reason: PositionChangedReason.Liquidate\n            })\n        );\n        vault.transferMargin(params.marketId, params.trader, liquidator, result.feeToLiquidator);\n        vault.transferMargin(params.marketId, params.trader, address(this), result.feeToProtocol);\n\n        // always check margin in the end\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: params.marketId,\n                trader: liquidator,\n                price: mmProfile.price,\n                isReducing: LibPosition.isReduceOnly(\n                    liquidatorPositionSizeBefore,\n                    vault.getPositionSize(params.marketId, liquidator)\n                )\n            })\n        );\n        _emitLiquidatedEvent(\n            EmitLiquidatedEventParams({\n                marketId: params.marketId,\n                liquidator: liquidator,\n                trader: params.trader,\n                positionSizeDelta: result.liquidatedPositionSizeDelta,\n                positionNotionalDelta: result.liquidatedPositionNotionalDelta,\n                price: mmProfile.price,\n                penalty: result.penalty,\n                liquidationFeeToLiquidator: result.feeToLiquidator,\n                liquidationFeeToProtocol: result.feeToProtocol\n            })\n        );\n        return (result.liquidatedPositionSizeDelta, result.liquidatedPositionNotionalDelta);\n    }\n\n    /// @dev in the beginning it only open for orderGateway & orderGatewayV2 to be authorized\n    /// @inheritdoc AuthorizationUpgradeable\n    function setAuthorization(address authorized, bool isAuthorized_) public override {\n        IAddressManager addressManager = getAddressManager();\n        if (\n            isAuthorized_ &&\n            authorized != address(addressManager.getOrderGateway()) &&\n            authorized != address(addressManager.getOrderGatewayV2())\n        ) {\n            revert LibError.NotWhitelistedAuthorization();\n        }\n        super.setAuthorization(authorized, isAuthorized_);\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    /// @dev in order to throw decode error instead of panic, it must be in external call (or contract creation)\n    /// @inheritdoc IClearingHouse\n    function decodeMakerOrder(bytes calldata encoded) external pure returns (MakerOrder memory) {\n        return abi.decode(encoded, (MakerOrder));\n    }\n\n    /// @inheritdoc IClearingHouse\n    function isLiquidatable(uint256 marketId, address trader, uint256 price) external view returns (bool) {\n        return _getLiquidatablePositionSize(marketId, trader, price) != 0;\n    }\n\n    /// @inheritdoc IClearingHouse\n    function getLiquidatablePositionSize(\n        uint256 marketId,\n        address trader,\n        uint256 price\n    ) external view returns (int256) {\n        return _getLiquidatablePositionSize(marketId, trader, price);\n    }\n\n    //\n    // INTERNAL NON-VIEW\n    //\n\n    function _openPosition(\n        IVault vault,\n        address taker,\n        OpenPositionParams memory params,\n        PositionChangedReason reason\n    ) internal nonZero(params.amount) returns (OpenPositionResult memory) {\n        if (block.timestamp > params.deadline) revert LibError.DeadlineExceeded();\n\n        // the amount maker is going to filled. could be base or quote based on taker's isExactInput & isBaseToQuote\n        // currently only open whitelisted maker for callback. other maker must conforms the MakerOrder to quote price\n        uint256 oppositeAmount;\n        bytes memory callbackData;\n        bool hasMakerCallback = _isWhitelistedMaker(params.marketId, params.maker);\n        if (hasMakerCallback) {\n            if (!IMaker(params.maker).isValidSender(msg.sender)) revert LibError.InvalidSender(msg.sender);\n            (oppositeAmount, callbackData) = IMaker(params.maker).fillOrder(\n                params.isBaseToQuote,\n                params.isExactInput,\n                params.amount,\n                params.makerData\n            );\n        } else {\n            // Note that params.maker here could be arbitrary account, so we do allow arbitrary account\n            // to set arbitrary price when fillOrder.\n            // However, we also check margin requirements with oracle price for both taker and maker after openPosition\n            // FIXME: this is not enough, see OrderGatewayV2SettleOrderIntTest.test_SettleOrder_AtExtremePrice()\n            _checkIsSenderAuthorizedBy(params.maker);\n            try this.decodeMakerOrder(params.makerData) returns (MakerOrder memory makerOrder) {\n                oppositeAmount = makerOrder.amount;\n            } catch (bytes memory) {\n                revert LibError.InvalidMakerData();\n            }\n            if (oppositeAmount == 0) revert LibError.InvalidMakerData();\n        }\n\n        // cache position size before mutation in order to detect whether it's reducing position.\n        // caller has more flexibility to react - eg. give it lower margin requirement if it's reducing\n        // NOTE: we assume IMaker.fillOrder() won't change any position state\n        int256 takerPositionSizeBefore = vault.getPositionSize(params.marketId, taker);\n        int256 makerPositionSizeBefore = vault.getPositionSize(params.marketId, params.maker);\n        OpenPositionResult memory result;\n        if (params.isExactInput) {\n            _checkExactInputSlippage(oppositeAmount, params.oppositeAmountBound);\n            if (params.isBaseToQuote) {\n                // exactInput(base) to quote, B2Q base- quote+\n                result.base = -params.amount.toInt256();\n                result.quote = oppositeAmount.toInt256();\n            } else {\n                // exactInput(quote) to base, Q2B base+ quote-\n                result.base = oppositeAmount.toInt256();\n                result.quote = -params.amount.toInt256();\n            }\n        } else {\n            _checkExactOutputSlippage(oppositeAmount, params.oppositeAmountBound);\n            if (params.isBaseToQuote) {\n                // base to exactOutput(quote), B2Q base- quote+\n                result.base = -oppositeAmount.toInt256();\n                result.quote = params.amount.toInt256();\n            } else {\n                // quote to exactOutput(base), Q2B base+ quote-\n                result.base = params.amount.toInt256();\n                result.quote = -oppositeAmount.toInt256();\n            }\n        }\n        _checkPriceBand(params.marketId, result.quote.abs().divWad(result.base.abs()));\n\n        result.isTakerReducing = LibPosition.isReduceOnly(\n            takerPositionSizeBefore,\n            takerPositionSizeBefore + result.base\n        );\n        result.isMakerReducing = LibPosition.isReduceOnly(\n            makerPositionSizeBefore,\n            makerPositionSizeBefore - result.base\n        );\n        vault.settlePosition(\n            IVault.SettlePositionParams({\n                marketId: params.marketId,\n                taker: taker,\n                maker: params.maker,\n                takerPositionSize: result.base,\n                takerOpenNotional: result.quote,\n                reason: reason\n            })\n        );\n\n        if (hasMakerCallback) {\n            IMaker(params.maker).fillOrderCallback(callbackData);\n        }\n        return result;\n    }\n\n    function _openPositionFor(address taker, OpenPositionParams memory params) internal returns (int256, int256) {\n        uint256 marketId = params.marketId;\n        uint256 price = _getPrice(marketId);\n\n        IVault vault = _getVault();\n        OpenPositionResult memory result = _openPosition(vault, taker, params, PositionChangedReason.Trade);\n\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: marketId,\n                trader: taker,\n                price: price,\n                isReducing: result.isTakerReducing\n            })\n        );\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: marketId,\n                trader: params.maker,\n                price: price,\n                isReducing: result.isMakerReducing\n            })\n        );\n\n        return (result.base, result.quote);\n    }\n\n    function _closePositionFor(address taker, ClosePositionParams memory params) internal returns (int256, int256) {\n        uint256 marketId = params.marketId;\n        uint256 price = _getPrice(marketId);\n        IVault vault = _getVault();\n        int256 positionSize = vault.getPositionSize(marketId, taker);\n        bool isBaseToQuote = positionSize > 0;\n        OpenPositionParams memory openPositionParams = OpenPositionParams({\n            marketId: marketId,\n            maker: params.maker,\n            isBaseToQuote: isBaseToQuote,\n            isExactInput: isBaseToQuote,\n            amount: positionSize.abs(),\n            oppositeAmountBound: params.oppositeAmountBound,\n            deadline: params.deadline,\n            makerData: params.makerData\n        });\n        OpenPositionResult memory result = _openPosition(vault, taker, openPositionParams, PositionChangedReason.Trade);\n\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: marketId,\n                trader: taker,\n                price: price,\n                isReducing: result.isTakerReducing\n            })\n        );\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: marketId,\n                trader: params.maker,\n                price: price,\n                isReducing: result.isMakerReducing\n            })\n        );\n\n        return (result.base, result.quote);\n    }\n\n    /// @dev caller must ensure sender is already authorized by taker. we won't check sender's auth here because relay\n    /// fee only comes from open/closePositionFor which already checked taker's auth\n    function _chargeRelayFee(address taker, uint256 takerRelayFee, address maker, uint256 makerRelayFee) internal {\n        IVault vault = _getVault();\n        if (takerRelayFee > 0) {\n            _checkRelayFee(taker, takerRelayFee);\n            vault.transferFund(taker, msg.sender, takerRelayFee);\n        }\n        if (makerRelayFee > 0) {\n            _checkIsSenderAuthorizedBy(maker);\n            _checkRelayFee(maker, makerRelayFee);\n            vault.transferFund(maker, msg.sender, makerRelayFee);\n        }\n    }\n\n    /// @dev extract to a function for mitigating stack too deep error\n    function _emitLiquidatedEvent(EmitLiquidatedEventParams memory params) internal {\n        emit Liquidated(\n            params.marketId,\n            params.liquidator,\n            params.trader,\n            params.positionSizeDelta,\n            params.positionNotionalDelta,\n            params.price,\n            params.penalty,\n            params.liquidationFeeToLiquidator,\n            params.liquidationFeeToProtocol\n        );\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n\n    /// @notice trade price must be within the price band, which is the oracle price +/- priceBandRatio\n    function _checkPriceBand(uint256 marketId, uint256 tradePrice) internal view {\n        IAddressManager addressManager = getAddressManager();\n        Config config = addressManager.getConfig();\n        uint256 priceBandRatio = config.getPriceBandRatio(marketId);\n        if (priceBandRatio == 0) {\n            return;\n        }\n        bytes32 priceFeedId = config.getPriceFeedId(marketId);\n        (uint256 oraclePrice, ) = addressManager.getPythOracleAdapter().getPrice(priceFeedId);\n        uint256 upperPrice = oraclePrice.mulWad(WAD + priceBandRatio);\n        uint256 lowerPrice = oraclePrice.mulWad(WAD - priceBandRatio);\n        if (upperPrice < tradePrice || tradePrice < lowerPrice) {\n            revert LibError.PriceOutOfBound(tradePrice, lowerPrice, upperPrice);\n        }\n    }\n\n    function _checkIsSenderAuthorizedBy(address onBehalf) internal view {\n        if (!isAuthorized(onBehalf, msg.sender)) revert LibError.AuthorizerNotAllow(onBehalf, msg.sender);\n    }\n\n    function _checkRelayFee(address trader, uint256 relayFee) internal view {\n        Config config = getAddressManager().getConfig();\n        uint256 maxRelayFee = config.getMaxRelayFee();\n        if (relayFee > maxRelayFee) revert LibError.ExcessiveRelayFee(trader, msg.sender, relayFee, maxRelayFee);\n    }\n\n    function _checkMarginRequirement(CheckMarginRequirementParams memory params) internal view {\n        // When increasing position:\n        //   tradableCollateral(imRatio) must >= 0\n        // When reducing position:\n        //   tradableCollateral(mmRatio) must >= 0\n        // When closing position:\n        //   tradableCollateral(*) must >= 0 (*: it doesn't matter what ratio we put in because there are no positions remaining after close)\n        IVault vault = params.vault;\n        uint256 marketId = params.marketId;\n        address trader = params.trader;\n        uint256 price = params.price;\n        if (params.isReducing) {\n            // Reducing, Closing positions can share the same logic for now.\n            int256 freeCollateralForReducingPosition = vault.getFreeCollateralForTrade(\n                marketId,\n                trader,\n                price,\n                MarginRequirementType.MAINTENANCE\n            );\n            if (freeCollateralForReducingPosition < 0) {\n                revert LibError.NotEnoughFreeCollateral(marketId, trader);\n            }\n            return;\n        }\n\n        // is NOT reducing\n        // Note that freeCollateralForOpen = tradableCollateral(imRatio)\n        int256 freeCollateralForIncreasingPosition = vault.getFreeCollateralForTrade(\n            marketId,\n            trader,\n            price,\n            MarginRequirementType.INITIAL\n        );\n        if (freeCollateralForIncreasingPosition < 0) {\n            revert LibError.NotEnoughFreeCollateral(marketId, trader);\n        }\n    }\n\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    function _getPrice(uint256 marketId) internal view returns (uint256) {\n        IAddressManager addressManager = getAddressManager();\n        (uint256 price, ) = addressManager.getPythOracleAdapter().getPrice(\n            addressManager.getConfig().getPriceFeedId(marketId)\n        );\n        return price;\n    }\n\n    function _isWhitelistedMaker(uint256 marketId, address trader) internal view returns (bool) {\n        return getAddressManager().getConfig().isWhitelistedMaker(marketId, trader);\n    }\n\n    function _getLiquidatablePositionSize(\n        uint256 marketId,\n        address trader,\n        uint256 price\n    ) internal view returns (int256) {\n        MaintenanceMarginProfile memory mmProfile = _getMaintenanceMarginProfile(marketId, trader, price);\n        return mmProfile.getLiquidatablePositionSize();\n    }\n\n    function _getMaintenanceMarginProfile(\n        uint256 marketId,\n        address trader,\n        uint256 price\n    ) internal view returns (MaintenanceMarginProfile memory) {\n        IAddressManager addressManager = getAddressManager();\n        IVault vault = addressManager.getVault();\n        int256 positionSize = vault.getPositionSize(marketId, trader);\n        int256 openNotional = vault.getOpenNotional(marketId, trader);\n        int256 maintenanceMarginRequirement = vault\n            .getMarginRequirement(marketId, trader, MarginRequirementType.MAINTENANCE)\n            .toInt256();\n        int256 accountValue = vault.getAccountValue(marketId, trader, price);\n\n        Config config = addressManager.getConfig();\n        uint256 liquidationFeeRatio = config.getLiquidationFeeRatio(marketId);\n        uint256 liquidationPenaltyRatio = config.getLiquidationPenaltyRatio(marketId);\n        return\n            MaintenanceMarginProfile({\n                price: price,\n                positionSize: positionSize,\n                openNotional: openNotional,\n                maintenanceMarginRequirement: maintenanceMarginRequirement,\n                accountValue: accountValue,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationPenaltyRatio: liquidationPenaltyRatio\n            });\n    }\n\n    //\n    // INTERNAL PURE\n    //\n    function _checkExactInputSlippage(uint256 actual, uint256 target) internal pure {\n        // want more output as possible, so we set a lower bound of output\n        if (actual < target) {\n            revert LibError.InsufficientOutputAmount(actual, target);\n        }\n    }\n\n    function _checkExactOutputSlippage(uint256 actual, uint256 target) internal pure {\n        // want less input as possible, so we set a upper bound of input\n        if (actual > target) {\n            revert LibError.ExcessiveInputAmount(actual, target);\n        }\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/clearingHouse/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { LibPosition } from \"../vault/LibPosition.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { IMarginProfile, MarginRequirementType } from \"../vault/IMarginProfile.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IMaker } from \"../maker/IMaker.sol\";\nimport { AuthorizationUpgradeable } from \"../authorization/AuthorizationUpgradeable.sol\";\nimport { IClearingHouse } from \"./IClearingHouse.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { PositionChangedReason } from \"../vault/PositionChangedReason.sol\";\nimport { LibLiquidation, MaintenanceMarginProfile, LiquidationResult } from \"./LibLiquidation.sol\";\n\ncontract ClearingHouse is\n    IClearingHouse,\n    AuthorizationUpgradeable,\n    AddressResolverUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20Metadata;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n    using LibFormatter for uint256;\n    using LibAddressResolver for IAddressManager;\n    using LibLiquidation for MaintenanceMarginProfile;\n\n    //\n    // STRUCT\n    //\n\n    struct OpenPositionResult {\n        int256 base;\n        int256 quote;\n        bool isTakerReducing;\n        bool isMakerReducing;\n    }\n\n    struct EmitLiquidatedEventParams {\n        uint256 marketId;\n        address liquidator;\n        address trader;\n        int256 positionSizeDelta;\n        int256 positionNotionalDelta;\n        uint256 price;\n        uint256 penalty;\n        uint256 liquidationFeeToLiquidator;\n        uint256 liquidationFeeToProtocol;\n    }\n\n    struct CheckMarginRequirementParams {\n        IVault vault;\n        uint256 marketId;\n        address trader;\n        uint256 price;\n        bool isReducing;\n    }\n\n    //\n    // MODIFIER\n    //\n    modifier nonZero(uint256 amount) {\n        if (amount == 0) revert LibError.ZeroAmount();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager) external initializer {\n        __AddressResolver_init(addressManager);\n        __Authorization_init();\n        __ReentrancyGuard_init();\n    }\n\n    /// @inheritdoc IClearingHouse\n    function openPosition(OpenPositionParams calldata params) external returns (int256, int256) {\n        return _openPositionFor(_sender(), params);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function openPositionFor(OpenPositionForParams calldata params) external returns (int256, int256) {\n        _checkIsSenderAuthorizedBy(params.taker);\n        _chargeRelayFee(params.taker, params.takerRelayFee, params.maker, params.makerRelayFee);\n        return\n            _openPositionFor(\n                params.taker,\n                IClearingHouse.OpenPositionParams({\n                    marketId: params.marketId,\n                    maker: params.maker,\n                    isBaseToQuote: params.isBaseToQuote,\n                    isExactInput: params.isExactInput,\n                    amount: params.amount,\n                    oppositeAmountBound: params.oppositeAmountBound,\n                    deadline: params.deadline,\n                    makerData: params.makerData\n                })\n            );\n    }\n\n    /// @inheritdoc IClearingHouse\n    function quoteOpenPosition(OpenPositionParams calldata params) external returns (int256, int256) {\n        address taker = _sender();\n        uint256 price = _getPrice(params.marketId);\n\n        IVault vault = _getVault();\n        OpenPositionResult memory result = _openPosition(vault, taker, params, PositionChangedReason.Trade);\n\n        // Only check maker's margin is sufficient for filling order\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: params.marketId,\n                trader: params.maker,\n                price: price,\n                isReducing: result.isMakerReducing\n            })\n        );\n\n        revert LibError.QuoteResult(result.base, result.quote);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function closePosition(ClosePositionParams calldata params) external returns (int256, int256) {\n        return _closePositionFor(_sender(), params);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function closePositionFor(ClosePositionForParams calldata params) external returns (int256, int256) {\n        _checkIsSenderAuthorizedBy(params.taker);\n        _chargeRelayFee(params.taker, params.takerRelayFee, params.maker, params.makerRelayFee);\n        return\n            _closePositionFor(\n                params.taker,\n                IClearingHouse.ClosePositionParams({\n                    marketId: params.marketId,\n                    maker: params.maker,\n                    oppositeAmountBound: params.oppositeAmountBound,\n                    deadline: params.deadline,\n                    makerData: params.makerData\n                })\n            );\n    }\n\n    /// @inheritdoc IClearingHouse\n    function liquidate(\n        LiquidatePositionParams calldata params\n    ) external nonZero(params.positionSize) returns (int256, int256) {\n        // We don't allow liquidating whitelisted makers for now until we implement safety mechanism\n        // For spot-hedged base maker, it needs to implement rebalance once it got liquidated\n        if (_isWhitelistedMaker(params.marketId, params.trader)) {\n            revert LibError.CannotLiquidateWhitelistedMaker();\n        }\n\n        // calculate how much size can be liquidated, and how much open notional will be reduced correspondingly\n        address liquidator = _sender();\n        MaintenanceMarginProfile memory mmProfile = _getMaintenanceMarginProfile(\n            params.marketId,\n            params.trader,\n            _getPrice(params.marketId)\n        );\n        LiquidationResult memory result = mmProfile.getLiquidationResult(params.positionSize);\n        if (result.liquidatedPositionSizeDelta == 0) revert LibError.NotLiquidatable(params.marketId, params.trader);\n\n        // settle to vault, pay out liquidation fee to liquidator and protocol\n        IVault vault = _getVault();\n        int256 liquidatorPositionSizeBefore = vault.getPositionSize(params.marketId, liquidator);\n        vault.settlePosition(\n            IVault.SettlePositionParams({\n                marketId: params.marketId,\n                taker: params.trader,\n                maker: liquidator,\n                takerPositionSize: result.liquidatedPositionSizeDelta,\n                takerOpenNotional: result.liquidatedPositionNotionalDelta,\n                reason: PositionChangedReason.Liquidate\n            })\n        );\n        vault.transferMargin(params.marketId, params.trader, liquidator, result.feeToLiquidator);\n        vault.transferMargin(params.marketId, params.trader, address(this), result.feeToProtocol);\n\n        // always check margin in the end\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: params.marketId,\n                trader: liquidator,\n                price: mmProfile.price,\n                isReducing: LibPosition.isReduceOn"
    }
  ]
}