{
  "Title": "registerFunctionSelector Can Be Front-Run and DoS'ed",
  "Content": "The [`registerFunctionSelector` function](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol#L171) is used to register system function selectors for the `World` context. This unique `bytes4 worldFunctionSelector` is based on the user-provided `namespaceString`, `nameString`, and `systemFunctionSignature`. In the `fallback` function of the `World` contract, the `worldFunctionSelector` is taken as a look-up table value to forward the call to the right system and function. This mechanism exists in parallel to the [`call`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L346) and [`callFrom`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L361) functions that allow the user to specify the system to address through a function parameter.\n\n\nThe problem is that function selectors are only four bytes, so collisions (technically, second-preimages) can be realistically generated. This is particularly true if the `worldFunctionSelector` is known ahead of time (e.g., in the context of DAO voting). If a `worldFunctionSelector` is already taken, [subsequent registrations will revert](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol#L191-L193). This allows a malicious actor to brute-force a `worldFunctionSelector` that is identical to that of the victim and front-run the transaction. Hence, the legitimate victim transaction would fail.\n\n\nFurther, the `worldFunctionSignature` is constructed by concatenating the namespace, name, and system function signature with underscores. If the function name contains underscores itself, a selector collision can be trivially constructed. For example, the `worldFunctionSignature` of `MyNS_MySystem_do_things()` can be broken down into:\n\n\n\n\n| actor | namespace | name | function signature |\n| --- | --- | --- | --- |\n| victim | `MyNS` | `MySystem` | `do_things()` |\n| attacker | `MyNS_MySystem` | `do` | `things()` |\n\n\nThe impact of this attack is Denial of Service with the intention of griefing. The victim would have to re-write their code, redeploy it, and try to register it again. Alternatively, they will be unable to use this selector mapping feature.\n\n\nAnother collision that may occur is between registered `worldFunctionSignature`s and any of the external/public functions in the `World` contract. Since the external/public function is prioritized over the fallback function, the intended system call could lead to two problems:\n\n\n* The call reverts due to a parameter decoding mismatch or access control check.\n* The call succeeds and performs an unexpected action.\n\n\nConsider changing the world function selector delimiter from an underscore to a character that is invalid for function names (e.g., a colon). Also, consider registering the `World`'s functions so that they can't be registered for the fallback function mechanism. However, the front-running issue will persist without a larger redesign. Hence, consider reducing the attack surface and code complexity by removing this feature entirely, or possibly restricting it to the root namespace and enforcing the usage of the [`call`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L346) and [`callFrom`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/World.sol#L361) functions that address systems specifically.\n\n\n***Update:** Resolved in [pull request #2160](https://github.com/latticexyz/mud/pull/2160#pullrequestreview-1837290896), [pull request #2169](https://github.com/latticexyz/mud/pull/2169), and [pull request #2182](https://github.com/latticexyz/mud/pull/2182). The Lattice Labs team stated:*\n\n\n\n> *The fixes address the potential conflicts between function selectors of different namespaces. It does not address the possibility of front-running namespace/function selector registration which we've decided to punt on for now and later address with an optional module. This module will allow \"committing\" to a hashed namespace and then \"revealing/registering\" the namespace in a second step. Since C-01 is fixed, this is not a security issue anymore but just a potential griefing vector.*\n> \n> \n> *We have also decided to punt on addressing the possibility of brute-force calculating a conflicting function selector - since the value space is only 4 bytes it seems impossible to prevent this - but the feature is too useful to remove it altogether. The only issue this could lead to is a griefing attack if a function selector is known long enough before it is registered. This seems like a relatively small issue compared to the value custom function selectors provide in the vast majority of situations.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { Hook, HookLib } from \"@latticexyz/store/src/Hook.sol\";\nimport { ResourceId, ResourceIdInstance } from \"@latticexyz/store/src/ResourceId.sol\";\nimport { ResourceIds } from \"@latticexyz/store/src/codegen/tables/ResourceIds.sol\";\n\nimport { System } from \"../../../System.sol\";\nimport { WorldContextConsumer, WORLD_CONTEXT_CONSUMER_INTERFACE_ID } from \"../../../WorldContext.sol\";\nimport { WorldResourceIdLib, WorldResourceIdInstance } from \"../../../WorldResourceId.sol\";\nimport { SystemCall } from \"../../../SystemCall.sol\";\nimport { ROOT_NAMESPACE_ID, ROOT_NAME } from \"../../../constants.sol\";\nimport { RESOURCE_NAMESPACE, RESOURCE_SYSTEM } from \"../../../worldResourceTypes.sol\";\nimport { AccessControl } from \"../../../AccessControl.sol\";\nimport { Delegation } from \"../../../Delegation.sol\";\nimport { requireInterface } from \"../../../requireInterface.sol\";\nimport { NamespaceOwner } from \"../../../codegen/tables/NamespaceOwner.sol\";\nimport { ResourceAccess } from \"../../../codegen/tables/ResourceAccess.sol\";\nimport { UserDelegationControl } from \"../../../codegen/tables/UserDelegationControl.sol\";\nimport { NamespaceDelegationControl } from \"../../../codegen/tables/NamespaceDelegationControl.sol\";\nimport { ISystemHook, SYSTEM_HOOK_INTERFACE_ID } from \"../../../ISystemHook.sol\";\nimport { IWorldErrors } from \"../../../IWorldErrors.sol\";\nimport { IDelegationControl, DELEGATION_CONTROL_INTERFACE_ID } from \"../../../IDelegationControl.sol\";\n\nimport { SystemHooks, SystemHooksTableId } from \"../../../codegen/tables/SystemHooks.sol\";\nimport { SystemRegistry } from \"../../../codegen/tables/SystemRegistry.sol\";\nimport { Systems } from \"../../../codegen/tables/Systems.sol\";\nimport { FunctionSelectors } from \"../../../codegen/tables/FunctionSelectors.sol\";\nimport { FunctionSignatures } from \"../../../codegen/tables/FunctionSignatures.sol\";\n\n/**\n * @title WorldRegistrationSystem\n * @dev This contract provides functions related to registering resources other than tables in the World.\n */\ncontract WorldRegistrationSystem is System, IWorldErrors {\n  using ResourceIdInstance for ResourceId;\n  using WorldResourceIdInstance for ResourceId;\n\n  /**\n   * @notice Registers a new namespace\n   * @dev Creates a new namespace resource with the given ID\n   * @param namespaceId The unique identifier for the new namespace\n   */\n  function registerNamespace(ResourceId namespaceId) public virtual {\n    // Require the provided namespace ID to have type RESOURCE_NAMESPACE\n    if (namespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, namespaceId, namespaceId.toString());\n    }\n\n    // Require namespace to not exist yet\n    if (ResourceIds._getExists(namespaceId)) {\n      revert World_ResourceAlreadyExists(namespaceId, namespaceId.toString());\n    }\n\n    // Register namespace resource ID\n    ResourceIds._setExists(namespaceId, true);\n\n    // Register caller as the namespace owner\n    NamespaceOwner._set(namespaceId, _msgSender());\n\n    // Give caller access to the new namespace\n    ResourceAccess._set(namespaceId, _msgSender(), true);\n  }\n\n  /**\n   * @notice Registers a new system hook\n   * @dev Adds a new hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being registered\n   * @param enabledHooksBitmap Bitmap indicating which hooks are enabled\n   */\n  function registerSystemHook(ResourceId systemId, ISystemHook hookAddress, uint8 enabledHooksBitmap) public virtual {\n    // Require the provided address to implement the ISystemHook interface\n    requireInterface(address(hookAddress), SYSTEM_HOOK_INTERFACE_ID);\n\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Register the hook\n    SystemHooks.push(systemId, Hook.unwrap(HookLib.encode(address(hookAddress), enabledHooksBitmap)));\n  }\n\n  /**\n   * @notice Unregisters a system hook\n   * @dev Removes a hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being unregistered\n   */\n  function unregisterSystemHook(ResourceId systemId, ISystemHook hookAddress) public virtual {\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Remove the hook from the list of hooks for this system in the system hooks table\n    HookLib.filterListByAddress(SystemHooksTableId, systemId, address(hookAddress));\n  }\n\n  /**\n   * @notice Registers a system\n   * @dev Registers or upgrades a system at the given ID\n   * If the namespace doesn't exist yet, it is registered.\n   * The system is granted access to its namespace, so it can write to any\n   * table in the same namespace.\n   * If publicAccess is true, no access control check is performed for calling the system.\n   * This function doesn't check whether a system already exists at the given selector,\n   * making it possible to upgrade systems.\n   * @param systemId The unique identifier for the system\n   * @param system The system being registered\n   * @param publicAccess Flag indicating if access control check is bypassed\n   */\n  function registerSystem(ResourceId systemId, WorldContextConsumer system, bool publicAccess) public virtual {\n    // Require the provided system ID to have type RESOURCE_SYSTEM\n    if (systemId.getType() != RESOURCE_SYSTEM) {\n      revert World_InvalidResourceType(RESOURCE_SYSTEM, systemId, systemId.toString());\n    }\n\n    // Require the provided address to implement the WorldContextConsumer interface\n    requireInterface(address(system), WORLD_CONTEXT_CONSUMER_INTERFACE_ID);\n\n    // Require the name to not be the namespace's root name\n    if (systemId.getName() == ROOT_NAME) revert World_InvalidResourceId(systemId, systemId.toString());\n\n    // Require this system to not be registered at a different system ID yet\n    ResourceId existingSystemId = SystemRegistry._get(address(system));\n    if (\n      ResourceId.unwrap(existingSystemId) != 0 && ResourceId.unwrap(existingSystemId) != ResourceId.unwrap(systemId)\n    ) {\n      revert World_SystemAlreadyExists(address(system));\n    }\n\n    // If the namespace doesn't exist yet, register it\n    ResourceId namespaceId = systemId.getNamespaceId();\n    if (!ResourceIds._getExists(namespaceId)) {\n      registerNamespace(namespaceId);\n    } else {\n      // otherwise require caller to own the namespace\n      AccessControl.requireOwner(namespaceId, _msgSender());\n    }\n\n    // Check if a system already exists at this system ID\n    address existingSystem = Systems._getSystem(systemId);\n\n    // If there is an existing system with this system ID, remove it\n    if (existingSystem != address(0)) {\n      // Remove the existing system from the system registry\n      SystemRegistry._deleteRecord(existingSystem);\n\n      // Remove the existing system's access to its namespace\n      ResourceAccess._deleteRecord(namespaceId, existingSystem);\n    } else {\n      // Otherwise, this is a new system, so register its resource ID\n      ResourceIds._setExists(systemId, true);\n    }\n\n    // Systems = mapping from system ID to system address and public access flag\n    Systems._set(systemId, address(system), publicAccess);\n\n    // SystemRegistry = mapping from system address to system ID\n    SystemRegistry._set(address(system), systemId);\n\n    // Grant the system access to its namespace\n    ResourceAccess._set(namespaceId, address(system), true);\n  }\n\n  /**\n   * @notice Registers a new World function selector\n   * @dev Creates a mapping between a World function and its associated system function\n   * @param systemId The system ID\n   * @param systemFunctionSignature The signature of the system function\n   * @return worldFunctionSelector The selector of the World function\n   */\n  function registerFunctionSelector(\n    ResourceId systemId,\n    string memory systemFunctionSignature\n  ) public returns (bytes4 worldFunctionSelector) {\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Compute global function selector\n    string memory namespaceString = WorldResourceIdLib.toTrimmedString(systemId.getNamespace());\n    string memory nameString = WorldResourceIdLib.toTrimmedString(systemId.getName());\n    bytes memory worldFunctionSignature = abi.encodePacked(\n      namespaceString,\n      \"_\",\n      nameString,\n      \"_\",\n      systemFunctionSignature\n    );\n    worldFunctionSelector = bytes4(keccak256(worldFunctionSignature));\n\n    // Require the function selector to be globally unique\n    ResourceId existingSystemId = FunctionSelectors._getSystemId(worldFunctionSelector);\n\n    if (ResourceId.unwrap(existingSystemId) != 0) revert World_FunctionSelectorAlreadyExists(worldFunctionSelector);\n\n    // Register the function selector\n    bytes4 systemFunctionSelector = bytes4(keccak256(bytes(systemFunctionSignature)));\n    FunctionSelectors._set(worldFunctionSelector, systemId, systemFunctionSelector);\n\n    // Register the function signature for offchain use\n    FunctionSignatures._set(worldFunctionSelector, string(worldFunctionSignature));\n  }\n\n  /**\n   * @notice Registers a root World function selector\n   * @dev Creates a mapping for a root World function without namespace or name prefix\n   * @param systemId The system ID\n   * @param worldFunctionSignature The signature of the World function\n   * @param systemFunctionSelector The selector of the system function\n   * @return worldFunctionSelector The selector of the World function\n   */\n  function registerRootFunctionSelector(\n    ResourceId systemId,\n    string memory worldFunctionSignature,\n    bytes4 systemFunctionSelector\n  ) public returns (bytes4 worldFunctionSelector) {\n    // Require the caller to own the root namespace\n    AccessControl.requireOwner(ROOT_NAMESPACE_ID, _msgSender());\n\n    // Compute the function selector from the provided signature\n    worldFunctionSelector = bytes4(keccak256(bytes(worldFunctionSignature)));\n\n    // Require the function selector to be globally unique\n    ResourceId existingSystemId = FunctionSelectors._getSystemId(worldFunctionSelector);\n\n    if (ResourceId.unwrap(existingSystemId) != 0) revert World_FunctionSelectorAlreadyExists(worldFunctionSelector);\n\n    // Register the function selector\n    FunctionSelectors._set(worldFunctionSelector, systemId, systemFunctionSelector);\n\n    // Register the function signature for offchain use\n    FunctionSignatures._set(worldFunctionSelector, worldFunctionSignature);\n  }\n\n  /**\n   * @notice Registers a delegation for the caller\n   * @dev Creates a new delegation from the caller to the specified delegatee\n   * @param delegatee The address of the delegatee\n   * @param delegationControlId The ID controlling the delegation\n   * @param initCallData The initialization data for the delegation\n   */\n  function registerDelegation(address delegatee, ResourceId delegationControlId, bytes memory initCallData) public {\n    // Store the delegation control contract address\n    UserDelegationControl._set({\n      delegator: _msgSender(),\n      delegatee: delegatee,\n      delegationControlId: delegationControlId\n    });\n\n    // If the delegation is limited...\n    if (Delegation.isLimited(delegationControlId) && initCallData.length > 0) {\n      // Require the delegationControl contract to implement the IDelegationControl interface\n      (address delegationControl, ) = Systems._get(delegationControlId);\n      requireInterface(delegationControl, DELEGATION_CONTROL_INTERFACE_ID);\n\n      // Call the delegation control contract's init function\n      SystemCall.callWithHooksOrRevert({\n        caller: _msgSender(),\n        systemId: delegationControlId,\n        callData: initCallData,\n        value: 0\n      });\n    }\n  }\n\n  /**\n   * @notice Registers a delegation for a namespace\n   * @dev Sets up a new delegation control for a specific namespace\n   * @param namespaceId The ID of the namespace\n   * @param delegationControlId The ID controlling the delegation\n   * @param initCallData The initialization data for the delegation\n   */\n  function registerNamespaceDelegation(\n    ResourceId namespaceId,\n    ResourceId delegationControlId,\n    bytes memory initCallData\n  ) public {\n    // Require the namespaceId to be a valid namespace ID\n    if (namespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, namespaceId, namespaceId.toString());\n    }\n\n    // Require the delegation to not be unlimited\n    if (!Delegation.isLimited(delegationControlId)) {\n      revert World_UnlimitedDelegationNotAllowed();\n    }\n\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(namespaceId, _msgSender());\n\n    // Require the delegationControl contract to implement the IDelegationControl interface\n    (address delegationControl, ) = Systems._get(delegationControlId);\n    requireInterface(delegationControl, DELEGATION_CONTROL_INTERFACE_ID);\n\n    // Register the delegation control\n    NamespaceDelegationControl._set(namespaceId, delegationControlId);\n\n    // Call the delegation control contract's init function\n    if (initCallData.length > 0) {\n      SystemCall.callWithHooksOrRevert({\n        caller: _msgSender(),\n        systemId: delegationControlId,\n        callData: initCallData,\n        value: 0\n      });\n    }\n  }\n}"
    },
    {
      "filename": "packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { Hook, HookLib } from \"@latticexyz/store/src/Hook.sol\";\nimport { ResourceId, ResourceIdInstance } from \"@latticexyz/store/src/ResourceId.sol\";\nimport { ResourceIds } from \"@latticexyz/store/src/codegen/tables/ResourceIds.sol\";\n\nimport { System } from \"../../../System.sol\";\nimport { WorldContextConsumer, WORLD_CONTEXT_CONSUMER_INTERFACE_ID } from \"../../../WorldContext.sol\";\nimport { WorldResourceIdLib, WorldResourceIdInstance } from \"../../../WorldResourceId.sol\";\nimport { SystemCall } from \"../../../SystemCall.sol\";\nimport { ROOT_NAMESPACE_ID, ROOT_NAME } from \"../../../constants.sol\";\nimport { RESOURCE_NAMESPACE, RESOURCE_SYSTEM } from \"../../../worldResourceTypes.sol\";\nimport { AccessControl } from \"../../../AccessControl.sol\";\nimport { Delegation } from \"../../../Delegation.sol\";\nimport { requireInterface } from \"../../../requireInterface.sol\";\nimport { NamespaceOwner } from \"../../../codegen/tables/NamespaceOwner.sol\";\nimport { ResourceAccess } from \"../../../codegen/tables/ResourceAccess.sol\";\nimport { UserDelegationControl } from \"../../../codegen/tables/UserDelegationControl.sol\";\nimport { NamespaceDelegationControl } from \"../../../codegen/tables/NamespaceDelegationControl.sol\";\nimport { ISystemHook, SYSTEM_HOOK_INTERFACE_ID } from \"../../../ISystemHook.sol\";\nimport { IWorldErrors } from \"../../../IWorldErrors.sol\";\nimport { IDelegationControl, DELEGATION_CONTROL_INTERFACE_ID } from \"../../../IDelegationControl.sol\";\n\nimport { SystemHooks, SystemHooksTableId } from \"../../../codegen/tables/SystemHooks.sol\";\nimport { SystemRegistry } from \"../../../codegen/tables/SystemRegistry.sol\";\nimport { Systems } from \"../../../codegen/tables/Systems.sol\";\nimport { FunctionSelectors } from \"../../../codegen/tables/FunctionSelectors.sol\";\nimport { FunctionSignatures } from \"../../../codegen/tables/FunctionSignatures.sol\";\n\n/**\n * @title WorldRegistrationSystem\n * @dev This contract provides functions related to registering resources other than tables in the World.\n */\ncontract WorldRegistrationSystem is System, IWorldErrors {\n  using ResourceIdInstance for ResourceId;\n  using WorldResourceIdInstance for ResourceId;\n\n  /**\n   * @notice Registers a new namespace\n   * @dev Creates a new namespace resource with the given ID\n   * @param namespaceId The unique identifier for the new namespace\n   */\n  function registerNamespace(ResourceId namespaceId) public virtual {\n    // Require the provided namespace ID to have type RESOURCE_NAMESPACE\n    if (namespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, namespaceId, namespaceId.toString());\n    }\n\n    // Require namespace to not exist yet\n    if (ResourceIds._getExists(namespaceId)) {\n      revert World_ResourceAlreadyExists(namespaceId, namespaceId.toString());\n    }\n\n    // Register namespace resource ID\n    ResourceIds._setExists(namespaceId, true);\n\n    // Register caller as the namespace owner\n    NamespaceOwner._set(namespaceId, _msgSender());\n\n    // Give caller access to the new namespace\n    ResourceAccess._set(namespaceId, _msgSender(), true);\n  }\n\n  /**\n   * @notice Registers a new system hook\n   * @dev Adds a new hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being registered\n   * @param enabledHooksBitmap Bitmap indicating which hooks are enabled\n   */\n  function registerSystemHook(ResourceId systemId, ISystemHook hookAddress, uint8 enabledHooksBitmap) public virtual {\n    // Require the provided address to implement the ISystemHook interface\n    requireInterface(address(hookAddress), SYSTEM_HOOK_INTERFACE_ID);\n\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Register the hook\n    SystemHooks.push(systemId, Hook.unwrap(HookLib.encode(address(hookAddress), enabledHooksBitmap)));\n  }\n\n  /**\n   * @notice Unregisters a system hook\n   * @dev Removes a hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being unregistered\n   */\n  function unregisterSystemHook(ResourceId systemId, ISystemHook hookAddress) public virtual {\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Remove the hook from the list of hooks for this system in the system hooks table\n    HookLib.filterListByAddress(SystemHooksTableId, systemId, address(hookAddress));\n  }\n\n  /**\n   * @notice Registers a system\n   * @dev Registers or upgrades a system at the given ID\n   * If the namespace doesn't exist yet, it is registered.\n   * The system is granted access to its namespace, so it can write to any\n   * table in the same namespace.\n   * If publicAccess is true, no access control check is performed for calling the system.\n   * This function doesn't check whether a system already exists at the given selector,\n   * making it possible to upgrade systems.\n   * @param systemId The unique identifier for the system\n   * @param system The system being registered\n   * @param publicAccess Flag indicating if access control check is bypassed\n   */\n  function registerSystem(ResourceId systemId, WorldContextConsumer system, bool publicAccess) public virtual {\n    // Require the provided system ID to have type RESOURCE_SYSTEM\n    if (systemId.getType() != RESOURCE_SYSTEM) {\n      revert World_InvalidResourceType(RESOURCE_SYSTEM, systemId, systemId.toString());\n    }\n\n    // Require the provided address to implement the WorldContextConsumer interface\n    requireInterface(address(system), WORLD_CONTEXT_CONSUMER_INTERFACE_ID);\n\n    // Require the name to not be the namespace's root name\n    if (systemId.getName() == ROOT_NAME) revert World_InvalidResourceId(systemId, systemId.toString());\n\n    // Require this system to not be registered at a different system ID yet\n    ResourceId existingSystemId = SystemRegistry._get(address(system));\n    if (\n      ResourceId.unwrap(existingSystemId) != 0 && ResourceId.unwrap(existingSystemId) != ResourceId.unwrap(systemId)\n    ) {\n      revert World_SystemAlreadyExists(address(system));\n    }\n\n    // If the namespace doesn't exist yet, register it\n    ResourceId namespaceId = systemId.getNamespaceId();\n    if (!ResourceIds._getExists(namespaceId)) {\n      registerNamespace(namespaceId);\n    } else {\n      // otherwise require caller to own the namespace\n      AccessControl.requireOwner(namespaceId, _msgSender());\n    }\n\n    // Check if a system already exists at this system ID\n    address existingSystem = Systems._getSystem(systemId);\n\n    // If there is an existing system with this system ID, remove it\n    if (existingSystem != address(0)) {\n      // Remove the existing system from the system registry\n      SystemRegistry._deleteRecord(existingSystem);\n\n      // Remove the existing system's access to its namespace\n      ResourceAccess._deleteRecord(namespaceId, existingSystem);\n    } else {\n      // Otherwise, this is a new system, so register its resource ID\n      ResourceIds._setExists(systemId, true);\n    }\n\n    // Systems = mapping from system ID to system address and public access flag\n    Systems._set(systemId, address(system), publicAccess);\n\n    // SystemRegistry = mapping from system address to system ID\n    SystemRegistry._set(address(system), systemId);\n\n    // Grant the system access to its namespace\n    ResourceAccess._set(namespaceId, address(system), true);\n  }\n\n  /**\n   * @notice Registers a new World function selector\n   * @dev Creates a mapping between a World function and its associated system function\n   * @param systemId The system ID\n   * @param systemFunctionSignature The signature of the system function\n   * @return worldFunctionSelector The selector of the World function\n   */\n  function registerFunctionSelector(\n    ResourceId systemId,\n    string memory systemFunctionSignature\n  ) public returns (bytes4 worldFunctionSelector) {\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Compute global function selector\n    string memory namespaceString = WorldResourceIdLib.toTrimmedString(systemId.getNamespace());\n    string memory nameString = WorldResourceIdLib.toTrimmedString(systemId.getName());\n    bytes memory worldFunctionSignature = abi.encodePacked(\n      namespaceString,\n      \"_\",\n      nameString,\n      \"_\",\n      systemFunctionSignature\n    );\n    worldFunctionSelector = bytes4(keccak256(worldFunctionSignature));\n\n    // Require the function selector to be globally unique\n    ResourceId existingSystemId = FunctionSelectors._getSystemId(worldFunctionSelector);\n\n    if (ResourceId.unwrap(existingSystemId) != 0) revert World_FunctionSelectorAlreadyExists(worldFunctionSelector);\n\n    // Register the function selector\n    bytes4 systemFunctionSelector = bytes4(keccak256(bytes(systemFunctionSignature)));\n    FunctionSelectors._set(worldFunctionSelector, systemId, systemFunctionSelector);\n\n    // Register the function signature for offchain use\n    FunctionSignatures._set(worldFunctionSelector, string(worldFunctionSignature));\n  }\n\n  /**\n   * @notice Registers a root World function selector\n   * @dev Creates a mapping for a root World function without namespace or name prefix\n   * @param systemId The system ID\n   * @param worldFunctionSignature The signature of the World function\n   * @param systemFunctionSelector The selector of the system function\n   * @return worldFunctionSelector The selector of the World function\n   */\n  function registerRootFunctionSelector(\n    ResourceId systemId,\n    string memory worldFunctionSignature,\n    bytes4 systemFunctionSelector\n  ) public returns (bytes4 worldFunctionSelector) {\n    // Require the caller to own the root namespace\n    AccessControl.requireOwner(ROOT_NAMESPACE_ID, _msgSender());\n\n    // Compute the function selector from the provided signature\n    worldFunctionSelector = bytes4(keccak256(bytes(worldFunctionSignature)));\n\n    // Require the function selector to be globally unique\n    ResourceId existingSystemId = FunctionSelectors._getSystemId(worldFunctionSelector);\n\n    if (ResourceId.unwrap(existingSystemId) != 0) revert World_FunctionSelectorAlreadyExists(worldFunctionSelector);\n\n    // Register the function selector\n    FunctionSelectors._set(worldFunctionSelector, systemId, systemFunctionSelector);\n\n    // Register the function signature for offchain use\n    FunctionSignatures._set(worldFunctionSelector, worldFunctionSignature);\n  }\n\n  /**\n   * @notice Registers a delegation for the caller\n   * @dev Creates a new delegation from the caller to the specified delegatee\n   * @param delegatee The address of the delegatee\n   * @param delegationControlId The ID controlling the delegation\n   * @param initCallData The initialization data for the delegation\n   */\n  function registerDelegation(address delegatee, ResourceId delegationControlId, bytes memory initCallData) public {\n    // Store the delegation control contract address\n    UserDelegationControl._set({\n      delegator: _msgSender(),\n      delegatee: delegatee,\n      delegationControlId: delegationControlId\n    });\n\n    // If the delegation is limited...\n    if (Delegation.isLimited(delegationControlId) && initCallData.length > 0) {\n      // Require the delegationControl contract to implement the IDelegationControl interface\n      (address delegationControl, ) = Systems._get(delegationControlId);\n      requireInterface(delegationControl, DELEGATION_CONTROL_INTERFACE_ID);\n\n      // Call the delegation control contract's init function\n      SystemCall.callWithHooksOrRevert({\n        caller: _msgSender(),\n        systemId: delegationControlId,\n        callData: initCallData,\n        value: 0\n      });\n    }\n  }\n\n  /**\n   * @notice Registers a delegation for a namespace\n   * @dev Sets up a new delegation control for a specific namespace\n   * @param namespaceId The ID of the namespace\n   * @param delegationControlId The ID controlling the delegation\n   * @param initCallData The initialization data for the delegation\n   */\n  function registerNamespaceDelegation(\n    ResourceId namespaceId,\n    ResourceId delegationControlId,\n    bytes memory initCallData\n  ) public {\n    // Require the namespaceId to be a valid namespace ID\n    if (namespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, namespaceId, namespaceId.toString());\n    }\n\n    // Require the delegation to not be unlimited\n    if (!Delegation.isLimited(delegationControlId)) {\n      revert World_UnlimitedDelegationNotAllowed();\n    }\n\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(namespaceId, _msgSender());\n\n    // Require the delegationControl contract to implement the IDelegationControl interface\n    (address delegationControl, ) = Systems._get(delegationControlId);\n    requireInterface(delegationControl, DELEGATION_CONTROL_INTERFACE_ID);\n\n    // Register the delegation control\n    NamespaceDelegationControl._set(namespaceId, delegationControlId);\n\n    // Call the delegation control contract's init function\n    if (initCallData.length > 0) {\n      SystemCall.callWithHooksOrRevert({\n        caller: _msgSender(),\n        systemId: delegationControlId,\n        callData: initCallData,\n        value: 0\n      });\n    }\n  }\n}"
    },
    {
      "filename": "packages/world/src/World.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { StoreData } from \"@latticexyz/store/src/StoreData.sol\";\nimport { IStore } from \"@latticexyz/store/src/IStore.sol\";\nimport { StoreCore } from \"@latticexyz/store/src/StoreCore.sol\";\nimport { Bytes } from \"@latticexyz/store/src/Bytes.sol\";\nimport { Schema } from \"@latticexyz/store/src/Schema.sol\";\nimport { PackedCounter } from \"@latticexyz/store/src/PackedCounter.sol\";\nimport { FieldLayout } from \"@latticexyz/store/src/FieldLayout.sol\";\n\nimport { WORLD_VERSION } from \"./version.sol\";\nimport { System } from \"./System.sol\";\nimport { ResourceId, WorldResourceIdInstance } from \"./WorldResourceId.sol\";\nimport { ROOT_NAMESPACE_ID, ROOT_NAMESPACE, ROOT_NAME } from \"./constants.sol\";\nimport { AccessControl } from \"./AccessControl.sol\";\nimport { SystemCall } from \"./SystemCall.sol\";\nimport { WorldContextProviderLib } from \"./WorldContext.sol\";\nimport { revertWithBytes } from \"./revertWithBytes.sol\";\nimport { Delegation } from \"./Delegation.sol\";\nimport { requireInterface } from \"./requireInterface.sol\";\n\nimport { NamespaceOwner } from \"./codegen/tables/NamespaceOwner.sol\";\nimport { InstalledModules } from \"./codegen/tables/InstalledModules.sol\";\nimport { UserDelegationControl } from \"./codegen/tables/UserDelegationControl.sol\";\nimport { NamespaceDelegationControl } from \"./codegen/tables/NamespaceDelegationControl.sol\";\n\nimport { IModule, MODULE_INTERFACE_ID } from \"./IModule.sol\";\nimport { IWorldKernel } from \"./IWorldKernel.sol\";\nimport { IDelegationControl } from \"./IDelegationControl.sol\";\n\nimport { Systems } from \"./codegen/tables/Systems.sol\";\nimport { SystemHooks } from \"./codegen/tables/SystemHooks.sol\";\nimport { FunctionSelectors } from \"./codegen/tables/FunctionSelectors.sol\";\nimport { Balances } from \"./codegen/tables/Balances.sol\";\nimport { CORE_MODULE_NAME } from \"./modules/core/constants.sol\";\n\n/**\n * @title World Contract\n * @dev This contract is the core \"World\" contract containing various methods for\n * data manipulation, system calls, and dynamic function selector handling.\n */\ncontract World is StoreData, IWorldKernel {\n  using WorldResourceIdInstance for ResourceId;\n\n  /// @notice Address of the contract's creator.\n  address public immutable creator;\n\n  /// @return The current version of the world contract.\n  function worldVersion() public pure returns (bytes32) {\n    return WORLD_VERSION;\n  }\n\n  /// @dev Event emitted when the World contract is created.\n  constructor() {\n    creator = msg.sender;\n    emit HelloWorld(WORLD_VERSION);\n  }\n\n  /**\n   * @dev Prevents the World contract from calling itself.\n   */\n  modifier requireNoCallback() {\n    if (msg.sender == address(this)) {\n      revert World_CallbackNotAllowed(msg.sig);\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes the World by installing the core module.\n   * @param coreModule The core module to initialize the World with.\n   * @dev Only the initial creator can initialize. This can be done only once.\n   */\n  function initialize(IModule coreModule) public requireNoCallback {\n    // Only the initial creator of the World can initialize it\n    if (msg.sender != creator) {\n      revert World_AccessDenied(ROOT_NAMESPACE_ID.toString(), msg.sender);\n    }\n\n    // The World can only be initialized once\n    if (InstalledModules._get(CORE_MODULE_NAME, keccak256(\"\")) != address(0)) {\n      revert World_AlreadyInitialized();\n    }\n\n    // Initialize the World by installing the core module\n    _installRootModule(coreModule, new bytes(0));\n  }\n\n  /**\n   * @notice Installs a given root module in the World.\n   * @param module The module to be installed.\n   * @param args Arguments for module installation.\n   * @dev The caller must own the root namespace.\n   */\n  function installRootModule(IModule module, bytes memory args) public requireNoCallback {\n    AccessControl.requireOwner(ROOT_NAMESPACE_ID, msg.sender);\n    _installRootModule(module, args);\n  }\n\n  /**\n   * @dev Internal function to install a root module.\n   * @param module The module to be installed.\n   * @param args Arguments for module installation.\n   */\n  function _installRootModule(IModule module, bytes memory args) internal {\n    // Require the provided address to implement the IModule interface\n    requireInterface(address(module), MODULE_INTERFACE_ID);\n\n    WorldContextProviderLib.delegatecallWithContextOrRevert({\n      msgSender: msg.sender,\n      msgValue: 0,\n      target: address(module),\n      callData: abi.encodeCall(IModule.installRoot, (args))\n    });\n\n    // Register the module in the InstalledModules table\n    InstalledModules._set(module.getName(), keccak256(args), address(module));\n  }\n\n  /************************************************************************\n   *\n   *    WORLD STORE METHODS\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Writes a record in the table identified by `tableId`.\n   * @param tableId The unique identifier for the table.\n   * @param keyTuple Array of keys identifying the record.\n   * @param staticData Static data (fixed length fields) of the record.\n   * @param encodedLengths Encoded lengths of data.\n   * @param dynamicData Dynamic data (variable length fields) of the record.\n   * @dev Requires the caller to have access to the table's namespace or name (encoded in the tableId).\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] calldata keyTuple,\n    bytes calldata staticData,\n    PackedCounter encodedLengths,\n    bytes calldata dynamicData\n  ) public virtual requireNoCallback {\n    // Require access to the namespace or name\n    AccessControl.requireAccess(tableId, msg.sender);\n\n    // Set the record\n    StoreCore.setRecor"
    }
  ]
}