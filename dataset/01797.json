{
  "Title": "Key functions do not have return values",
  "Content": "##### Description\n\nMany key functions do not have return values but they imply different behavior in case of non-revert.\n\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/Controller.vy#L586\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/Controller.vy#L600\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/Controller.vy#L671\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/Controller.vy#L685\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/Controller.vy#L700\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/Controller.vy#L731\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/Controller.vy#L795\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/Controller.vy#L1054\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/Controller.vy#L1069\n\nIt can add more complexity on integration with other smart contracts.\n\n##### Recommendation\n\nWe recommend returning key values that can explain the results of call executions.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Controller.vy",
      "content": "# @version 0.3.7\n\ninterface LLAMMA:\n    def A() -> uint256: view\n    def get_p() -> uint256: view\n    def get_base_price() -> uint256: view\n    def active_band() -> int256: view\n    def active_band_with_skip() -> int256: view\n    def p_oracle_up(n: int256) -> uint256: view\n    def p_oracle_down(n: int256) -> uint256: view\n    def deposit_range(user: address, amount: uint256, n1: int256, n2: int256): nonpayable\n    def read_user_tick_numbers(_for: address) -> int256[2]: view\n    def get_sum_xy(user: address) -> uint256[2]: view\n    def withdraw(user: address, frac: uint256) -> uint256[2]: nonpayable\n    def get_x_down(user: address) -> uint256: view\n    def get_rate_mul() -> uint256: view\n    def set_rate(rate: uint256) -> uint256: nonpayable\n    def set_fee(fee: uint256): nonpayable\n    def set_admin_fee(fee: uint256): nonpayable\n    def price_oracle() -> uint256: view\n    def can_skip_bands(n_end: int256) -> bool: view\n    def set_price_oracle(price_oracle: PriceOracle): nonpayable\n    def admin_fees_x() -> uint256: view\n    def admin_fees_y() -> uint256: view\n    def reset_admin_fees(): nonpayable\n    def has_liquidity(user: address) -> bool: view\n    def bands_x(n: int256) -> uint256: view\n    def bands_y(n: int256) -> uint256: view\n    def set_callback(user: address): nonpayable\n\ninterface ERC20:\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\n    def decimals() -> uint256: view\n    def approve(_spender: address, _value: uint256) -> bool: nonpayable\n\ninterface WETH:\n    def deposit(): payable\n    def withdraw(_amount: uint256): nonpayable\n\ninterface MonetaryPolicy:\n    def rate_write() -> uint256: nonpayable\n\ninterface Factory:\n    def stablecoin() -> address: view\n    def admin() -> address: view\n    def fee_receiver() -> address: view\n    def WETH() -> address: view\n\ninterface PriceOracle:\n    def price() -> uint256: view\n    def price_w() -> uint256: nonpayable\n\n\nevent UserState:\n    user: indexed(address)\n    collateral: uint256\n    debt: uint256\n    n1: int256\n    n2: int256\n    liquidation_discount: uint256\n\nevent Borrow:\n    user: indexed(address)\n    collateral_increase: uint256\n    loan_increase: uint256\n\nevent Repay:\n    user: indexed(address)\n    collateral_decrease: uint256\n    loan_decrease: uint256\n\nevent RemoveCollateral:\n    user: indexed(address)\n    collateral_decrease: uint256\n\nevent Liquidate:\n    liquidator: indexed(address)\n    user: indexed(address)\n    collateral_received: uint256\n    stablecoin_received: uint256\n    debt: uint256\n\nevent SetMonetaryPolicy:\n    monetary_policy: address\n\nevent SetBorrowingDiscounts:\n    loan_discount: uint256\n    liquidation_discount: uint256\n\nevent CollectFees:\n    amount: uint256\n    new_supply: uint256\n\n\nstruct Loan:\n    initial_debt: uint256\n    rate_mul: uint256\n\nstruct Position:\n    user: address\n    x: uint256\n    y: uint256\n    debt: uint256\n    health: int256\n\nstruct CallbackData:\n    active_band: int256\n    stablecoins: uint256\n    collateral: uint256\n\n\nFACTORY: immutable(Factory)\nSTABLECOIN: immutable(ERC20)\nMAX_LOAN_DISCOUNT: constant(uint256) = 5 * 10**17\nMIN_LIQUIDATION_DISCOUNT: constant(uint256) = 10**16 # Start liquidating when threshold reached\nMAX_TICKS: constant(int256) = 50\nMAX_TICKS_UINT: constant(uint256) = 50\nMIN_TICKS: constant(int256) = 5\nMAX_SKIP_TICKS: constant(uint256) = 1024\nMAX_P_BASE_BANDS: constant(int256) = 5\n\nMAX_RATE: constant(uint256) = 43959106799  # 400% APY\n\nloan: HashMap[address, Loan]\nliquidation_discounts: public(HashMap[address, uint256])\n_total_debt: Loan\n\nloans: public(address[10**20])  # Enumerate existing loans\nloan_ix: public(HashMap[address, uint256])  # Position of the loan in the list\nn_loans: public(uint256)  # Number of nonzero loans\n\nminted: public(uint256)\nredeemed: public(uint256)\n\nmonetary_policy: public(MonetaryPolicy)\nliquidation_discount: public(uint256)\nloan_discount: public(uint256)\n\nCOLLATERAL_TOKEN: immutable(ERC20)\nCOLLATERAL_PRECISION: immutable(uint256)\n\nAMM: immutable(LLAMMA)\nA: immutable(uint256)\nAminus1: immutable(uint256)\nLOG2_A_RATIO: immutable(int256)  # log(A / (A - 1))\nSQRT_BAND_RATIO: immutable(uint256)\n\nMAX_ADMIN_FEE: constant(uint256) = 10**18  # 100%\nMAX_FEE: constant(uint256) = 10**17  # 10%\n\nUSE_ETH: immutable(bool)\n\n\n@external\ndef __init__(\n        collateral_token: address,\n        monetary_policy: address,\n        loan_discount: uint256,\n        liquidation_discount: uint256,\n        amm: address):\n    \"\"\"\n    @notice Controller constructor deployed by the factory from blueprint\n    @param collateral_token Token to use for collateral\n    @param monetary_policy Address of monetary policy\n    @param loan_discount Discount of the maximum loan size compare to get_x_down() value\n    @param liquidation_discount Discount of the maximum loan size compare to\n           get_x_down() for \"bad liquidation\" purposes\n    @param amm AMM address (Already deployed from blueprint)\n    \"\"\"\n    FACTORY = Factory(msg.sender)\n    stablecoin: ERC20 = ERC20(Factory(msg.sender).stablecoin())\n    STABLECOIN = stablecoin\n    assert stablecoin.decimals() == 18\n\n    self.monetary_policy = MonetaryPolicy(monetary_policy)\n\n    self.liquidation_discount = liquidation_discount\n    self.loan_discount = loan_discount\n    self._total_debt.rate_mul = 10**18\n\n    AMM = LLAMMA(amm)\n    _A: uint256 = LLAMMA(amm).A()\n    A = _A\n    Aminus1 = _A - 1\n    LOG2_A_RATIO = self.log2(_A * 10**18 / unsafe_sub(_A, 1))\n\n    COLLATERAL_TOKEN = ERC20(collateral_token)\n    COLLATERAL_PRECISION = pow_mod256(10, 18 - ERC20(collateral_token).decimals())\n\n    SQRT_BAND_RATIO = isqrt(unsafe_div(10**36 * _A, unsafe_sub(_A, 1)))\n\n    stablecoin.approve(msg.sender, max_value(uint256))\n\n    if Factory(msg.sender).WETH() == collateral_token:\n        USE_ETH = True\n\n\n@payable\n@external\ndef __default__():\n    if msg.value > 0:\n        assert USE_ETH\n\n\n@internal\n@pure\ndef log2(_x: uint256) -> int256:\n    \"\"\"\n    @notice int(1e18 * log2(_x / 1e18))\n    \"\"\"\n    # adapted from: https://medium.com/coinmonks/9aef8515136e\n    # and vyper log implementation\n    # Might use more optimal solmate's log\n    inverse: bool = _x < 10**18\n    res: uint256 = 0\n    x: uint256 = _x\n    if inverse:\n        x = 10**36 / x\n    t: uint256 = 2**7\n    for i in range(8):\n        p: uint256 = pow_mod256(2, t)\n        if x >= unsafe_mul(p, 10**18):\n            x = unsafe_div(x, p)\n            res = unsafe_add(unsafe_mul(t, 10**18), res)\n        t = unsafe_div(t, 2)\n    d: uint256 = 10**18\n    for i in range(34):  # 10 decimals: math.log(10**10, 2) == 33.2. Need more?\n        if (x >= 2 * 10**18):\n            res = unsafe_add(res, d)\n            x = unsafe_div(x, 2)\n        x = unsafe_div(unsafe_mul(x, x), 10**18)\n        d = unsafe_div(d, 2)\n    if inverse:\n        return -convert(res, int256)\n    else:\n        return convert(res, int256)\n\n\n@external\n@view\ndef factory() -> Factory:\n    \"\"\"\n    @notice Address of the factory\n    \"\"\"\n    return FACTORY\n\n\n@external\n@view\ndef amm() -> LLAMMA:\n    \"\"\"\n    @notice Address of the AMM\n    \"\"\"\n    return AMM\n\n\n@external\n@view\ndef collateral_token() -> ERC20:\n    \"\"\"\n    @notice Address of the collateral token\n    \"\"\"\n    return COLLATERAL_TOKEN\n\n\n@internal\ndef _rate_mul_w() -> uint256:\n    \"\"\"\n    @notice Getter for rate_mul (the one which is 1.0+) from the AMM\n    \"\"\"\n    rate: uint256 = min(self.monetary_policy.rate_write(), MAX_RATE)\n    return AMM.set_rate(rate)\n\n\n@internal\ndef _debt(user: address) -> (uint256, uint256):\n    \"\"\"\n    @notice Get the value of debt and rate_mul and update the rate_mul counter\n    @param user User address\n    @return (debt, rate_mul)\n    \"\"\"\n    rate_mul: uint256 = self._rate_mul_w()\n    loan: Loan = self.loan[user]\n    if loan.initial_debt == 0:\n        return (0, rate_mul)\n    else:\n        return (loan.initial_debt * rate_mul / loan.rate_mul, rate_mul)\n\n\n@internal\n@view\ndef _debt_ro(user: address) -> uint256:\n    \"\"\"\n    @notice Get the value of debt without changing the state\n    @param user User address\n    @return Value of debt\n    \"\"\"\n    rate_mul: uint256 = AMM.get_rate_mul()\n    loan: Loan = self.loan[user]\n    if loan.initial_debt == 0:\n        return 0\n    else:\n        return loan.initial_debt * rate_mul / loan.rate_mul\n\n\n@external\n@view\n@nonreentrant('lock')\ndef debt(user: address) -> uint256:\n    \"\"\"\n    @notice Get the value of debt without changing the state\n    @param user User address\n    @return Value of debt\n    \"\"\"\n    return self._debt_ro(user)\n\n\n@external\n@view\n@nonreentrant('lock')\ndef loan_exists(user: address) -> bool:\n    \"\"\"\n    @notice Check whether there is a loan of `user` in existence\n    \"\"\"\n    return self.loan[user].initial_debt > 0\n\n\n# No decorator because used in monetary policy\n@external\n@view\ndef total_debt() -> uint256:\n    \"\"\"\n    @notice Total debt of this controller\n    \"\"\"\n    rate_mul: uint256 = AMM.get_rate_mul()\n    loan: Loan = self._total_debt\n    return loan.initial_debt * rate_mul / loan.rate_mul\n\n\n@internal\n@view\ndef get_y_effective(collateral: uint256, N: uint256, discount: uint256) -> uint256:\n    \"\"\"\n    @notice Intermediary method which calculates y_effective defined as x_effective / p_base,\n            however discounted by loan_discount.\n            x_effective is an amount which can be obtained from collateral when liquidating\n    @param collateral Amount of collateral to get the value for\n    @param N Number of bands the deposit is made into\n    @param discount Loan discount at 1e18 base (e.g. 1e18 == 100%)\n    @return y_effective\n    \"\"\"\n    # x_effective = sum_{i=0..N-1}(y / N * p(n_{n1+i})) =\n    # = y / N * p_oracle_up(n1) * sqrt((A - 1) / A) * sum_{0..N-1}(((A-1) / A)**k)\n    # === d_y_effective * p_oracle_up(n1) * sum(...) === y_effective * p_oracle_up(n1)\n    # d_y_effective = y / N / sqrt(A / (A - 1))\n    d_y_effective: uint256 = collateral * unsafe_sub(10**18, discount) / (SQRT_BAND_RATIO * N)\n    y_effective: uint256 = d_y_effective\n    for i in range(1, MAX_TICKS_UINT):\n        if i == N:\n            break\n        d_y_effective = unsafe_div(d_y_effective * Aminus1, A)\n        y_effective = unsafe_add(y_effective, d_y_effective)\n    return y_effective\n\n\n@internal\n@view\ndef _calculate_debt_n1(collateral: uint256, debt: uint256, N: uint256) -> int256:\n    \"\"\"\n    @notice Calculate the upper band number for the deposit to sit in to support\n            the given debt. Reverts if requested debt is too high.\n    @param collateral Amount of collateral (at its native precision)\n    @param debt Amount of requested debt\n    @param N Number of bands to deposit into\n    @return Upper band n1 (n1 <= n2) to deposit into. Signed integer\n    \"\"\"\n    assert debt > 0, \"No loan\"\n    n0: int256 = AMM.active_band()\n    p_base: uint256 = AMM.p_oracle_up(n0)\n\n    # x_effective = y / N * p_oracle_up(n1) * sqrt((A - 1) / A) * sum_{0..N-1}(((A-1) / A)**k)\n    # === d_y_effective * p_oracle_up(n1) * sum(...) === y_effective * p_oracle_up(n1)\n    # d_y_effective = y / N / sqrt(A / (A - 1))\n    y_effective: uint256 = self.get_y_effective(collateral * COLLATERAL_PRECISION, N, self.loan_discount)\n    # p_oracle_up(n1) = base_price * ((A - 1) / A)**n1\n\n    # We borrow up until min band touches p_oracle,\n    # or it touches non-empty bands which cannot be skipped.\n    # We calculate required n1 for given (collateral, debt),\n    # and if n1 corresponds to price_oracle being too high, or unreachable band\n    # - we revert.\n\n    # n1 is band number based on adiabatic trading, e.g. when p_oracle ~ p\n    y_effective = y_effective * p_base / (debt + 1)  # Now it's a ratio\n\n    # n1 = floor(log2(y_effective) / self.logAratio)\n    # EVM semantics is not doing floor unlike Python, so we do this\n    assert y_effective > 0, \"Amount too low\"\n    n1: int256 = self.log2(y_effective)  # <- switch to faster ln() XXX?\n    if n1 < 0:\n        n1 -= LOG2_A_RATIO - 1  # This is to deal with vyper's rounding of negative numbers\n    n1 /= LOG2_A_RATIO\n\n    n1 = min(n1, 1024 - convert(N, int256)) + n0\n    if n1 <= n0:\n        assert AMM.can_skip_bands(n1 - 1), \"Debt too high\"\n\n    # Let's not rely on active_band corresponding to price_oracle:\n    # this will be not correct if we are in the area of empty bands\n    assert AMM.p_oracle_up(n1) < AMM.price_oracle(), \"Debt too high\"\n\n    return n1\n\n\n@internal\n@view\ndef max_p_base() -> uint256:\n    \"\"\"\n    @notice Calculate max base price including skipping bands\n    \"\"\"\n    p_oracle: uint256 = AMM.price_oracle()\n    # Should be correct unless price changes suddenly by MAX_P_BASE_BANDS+ bands\n    n1: int256 = unsafe_div(self.log2(AMM.get_base_price() * 10**18 / p_oracle), LOG2_A_RATIO) + MAX_P_BASE_BANDS\n    p_base: uint256 = AMM.p_oracle_up(n1)\n    n_min: int256 = AMM.active_band_with_skip()\n\n    for i in range(MAX_SKIP_TICKS + 1):\n        n1 -= 1\n        if n1 <= n_min:\n            break\n        p_base_prev: uint256 = p_base\n        p_base = unsafe_div(p_base * A, Aminus1)\n        if p_base > p_oracle:\n            return p_base_prev\n\n    return p_base\n\n\n@external\n@view\n@nonreentrant('lock')\ndef max_borrowable(collateral: uint256, N: uint256) -> uint256:\n    \"\"\"\n    @notice Calculation of maximum which can be borrowed (details in comments)\n    @param collateral Collateral amount against which to borrow\n    @param N number of bands to have the deposit into\n    @return Maximum amount of stablecoin to borrow\n    \"\"\"\n    # Calculation of maximum which can be borrowed.\n    # It corresponds to a minimum between the amount corresponding to price_oracle\n    # and the one given by the min reachable band.\n    #\n    # Given by p_oracle (perhaps needs to be multiplied by (A - 1) / A to account for mid-band effects)\n    # x_max ~= y_effective * p_oracle\n    #\n    # Given by band number:\n    # if n1 is the lowest empty band in the AMM\n    # xmax ~= y_effective * amm.p_oracle_up(n1)\n    #\n    # When n1 -= 1:\n    # p_oracle_up *= A / (A - 1)\n\n    y_effective: uint256 = self.get_y_effective(collateral * COLLATERAL_PRECISION, N, self.loan_discount)\n\n    x: uint256 = unsafe_sub(max(unsafe_div(y_effective * self.max_p_base(), 10**18), 1), 1)\n    return unsafe_div(x * (10**18 - 10**14), 10**18)  # Make it a bit smaller\n\n\n@external\n@view\n@nonreentrant('lock')\ndef min_collateral(debt: uint256, N: uint256) -> uint256:\n    \"\"\"\n    @notice Minimal amount of collateral required to support debt\n    @param debt The debt to support\n    @param N Number of bands to deposit into\n    @return Minimal collateral required\n    \"\"\"\n    # Add N**2 to account for precision loss in multiple bands, e.g. N * 1 / (y/N) = N**2 / y\n    return unsafe_div(unsafe_div(debt * 10**18 / self.max_p_base() * 10**18 / self.get_y_effective(10**18, N, self.loan_discount) + N**2, COLLATERAL_PRECISION) * 10**18, 10**18 - 10**14)\n\n\n@external\n@view\n@nonreentrant('lock')\ndef calculate_debt_n1(collateral: uint256, debt: uint256, N: uint256) -> int256:\n    \"\"\"\n    @notice Calculate the upper band number for the deposit to sit in to support\n            the given debt. Reverts if requested debt is too high.\n    @param collateral Amount of collateral (at its native precision)\n    @param debt Amount of requested debt\n    @param N Number of bands to deposit into\n    @return Upper band n1 (n1 <= n2) to deposit into. Signed integer\n    \"\"\"\n    return self._calculate_debt_n1(collateral, debt, N)\n\n\n@internal\ndef _deposit_collateral(amount: uint256, mvalue: uint256):\n    \"\"\"\n    Deposits raw ETH, WETH or both at the same time\n    \"\"\"\n    if not USE_ETH:\n        assert mvalue == 0  # dev: Not accepting ETH\n    diff: uint256 = amount - mvalue  # dev: Incorrect ETH amount\n    if mvalue > 0:\n        WETH(COLLATERAL_TOKEN.address).deposit(value=mvalue)\n        assert COLLATERAL_TOKEN.transfer(AMM.address, mvalue)\n    if diff > 0:\n        assert COLLATERAL_TOKEN.transferFrom(msg.sender, AMM.address, diff, default_return_value=True)\n\n\n@internal\ndef _withdraw_collateral(_for: address, amount: uint256, use_eth: bool):\n    if use_eth and USE_ETH:\n        assert COLLATERAL_TOKEN.transferFrom(AMM.address, self, amount)\n        WETH(COLLATERAL_TOKEN.address).withdraw(amount)\n        raw_call(_for, b\"\", value=amount)\n    else:\n        assert COLLATERAL_TOKEN.transferFrom(AMM.address, _for, amount, default_return_value=True)\n\n\n@internal\ndef execute_callback(callbacker: address, callback_sig: bytes32,\n                     user: address, stablecoins: uint256, collateral: uint256, debt: uint256,\n                     callback_args: DynArray[uint256, 5]) -> CallbackData:\n    data: CallbackData = empty(CallbackData)\n    data.active_band = AMM.active_band()\n    band_x: uint256 = AMM.bands_x(data.active_band)\n    band_y: uint256 = AMM.bands_y(data.active_band)\n\n    # Callback\n    response: Bytes[64] = raw_call(\n        callbacker,\n        concat(slice(callback_sig, 0, 4), _abi_encode(user, stablecoins, collateral, debt, callback_args)),\n        max_outsize=64\n    )\n    data.stablecoins = convert(slice(response, 0, 32), uint256)\n    data.collateral = convert(slice(response, 32, 32), uint256)\n\n    # Checks after callback\n    assert data.active_band == AMM.active_band()\n    assert band_x == AMM.bands_x(data.active_band)\n    assert band_y == AMM.bands_y(data.active_band)\n\n    return data\n\n@internal\ndef _create_loan(mvalue: uint256, collateral: uint256, debt: uint256, N: uint256, transfer_coins: bool):\n    assert self.loan[msg.sender].initial_debt == 0, \"Loan already created\"\n    assert N > MIN_TICKS-1, \"Need more ticks\"\n    assert N < MAX_TICKS+1, \"Need less ticks\"\n\n    n1: int256 = self._calculate_debt_n1(collateral, debt, N)\n    n2: int256 = n1 + convert(N - 1, int256)\n\n    rate_mul: uint256 = self._rate_mul_w()\n    self.loan[msg.sender] = Loan({initial_debt: debt, rate_mul: rate_mul})\n    liquidation_discount: uint256 = self.liquidation_discount\n    self.liquidation_discounts[msg.sender] = liquidation_discount\n\n    n_loans: uint256 = self.n_loans\n    self.loans[n_loans] = msg.sender\n    self.loan_ix[msg.sender] = n_loans\n    self.n_loans = unsafe_add(n_loans, 1)\n\n    total_debt: uint256 = self._total_debt.initial_debt * rate_mul / self._total_debt.rate_mul + debt\n    self._total_debt.initial_debt = total_debt\n    self._total_debt.rate_mul = rate_mul\n\n    AMM.deposit_range(msg.sender, collateral, n1, n2)\n    self.minted += debt\n\n    if transfer_coins:\n        self._deposit_collateral(collateral, mvalue)\n        STABLECOIN.transfer(msg.sender, debt)\n\n    log UserState(msg.sender, collateral, debt, n1, n2, liquidation_discount)\n    log Borrow(msg.sender, collateral, debt)\n\n\n@payable\n@external\n@nonreentrant('lock')\ndef create_loan(collateral: uint256, debt: uint256, N: uint256):\n    \"\"\"\n    @notice Create loan\n    @param collateral Amount of collateral to use\n    @param debt Stablecoin debt to take\n    @param N Number of bands to deposit into (to do autoliquidation-deliquidation),\n           can be from MIN_TICKS to MAX_TICKS\n    \"\"\"\n    self._create_loan(msg.value, collateral, debt, N, True)\n\n\n@payable\n@external\n@nonreentrant('lock')\ndef create_loan_extended(collateral: uint256, debt: uint256, N: uint256, callbacker: address, callback_sig: bytes32, callback_args: DynArray[uint256,5]):\n    \"\"\"\n    @notice Create loan but pass stablecoin to a callback first so that it can build leverage\n    @param collateral Amount of collateral to use\n    @param debt Stablecoin debt to take\n    @param N Number of bands to deposit into (to do autoliquidation-deliquidation),\n           can be from MIN_TICKS to MAX_TICKS\n    @param callbacker Address of the callback contract\n    @param callback_sig method_id of the method which is called in the callbacker\n    @param callback_args Extra arguments for the callback (up to 5) such as min_amount etc\n    \"\"\"\n    # Before callback\n    STABLECOIN.transfer(callbacker, debt)\n\n    # Callback\n    # If there is any unused debt, callbacker can send it to the user\n    more_collateral: uint256 = self.execute_callback(\n        callbacker, callback_sig, msg.sender, 0, collateral, debt, callback_args).collateral\n\n    # After callback\n    self._deposit_collateral(collateral, msg.value)\n    assert COLLATERAL_TOKEN.transferFrom(callbacker, AMM.address, more_collateral, default_return_value=True)\n    self._create_loan(0, collateral + more_collateral, debt, N, False)\n\n\n@internal\ndef _add_collateral_borrow(d_collateral: uint256, d_debt: uint256, _for: address, remove_collateral: bool):\n    \"\"\"\n    @notice Internal method to borrow and add or remove collateral\n    @param d_collateral Amount of collateral to add\n    @param d_debt Amount of debt increase\n    @param _for Address to transfer tokens to\n    @param remove_collateral Remove collateral instead of adding\n    \"\"\"\n    debt: uint256 = 0\n    rate_mul: uint256 = 0\n    debt, rate_mul = self._debt(_for)\n    assert debt > 0, \"Loan doesn't exist\"\n    debt += d_debt\n    ns: int256[2] = AMM.read_user_tick_numbers(_for)\n    size: uint256 = convert(ns[1] - ns[0] + 1, uint256)\n\n    xy: uint256[2] = AMM.withdraw(_for, 10**18)\n    assert xy[0] == 0, \"Already in underwater mode\"\n    if remove_collateral:\n        xy[1] -= d_collateral\n    else:\n        xy[1] += d_collateral\n    n1: int256 = self._calculate_debt_n1(xy[1], debt, size)\n    n2: int256 = n1 + ns[1] - ns[0]\n\n    AMM.deposit_range(_for, xy[1], n1, n2)\n    self.loan[_for] = Loan({initial_debt: debt, rate_mul: rate_mul})\n    liquidation_discount: uint256 = self.liquidation_discount\n    self.liquidation_discounts[_for] = liquidation_discount\n\n    if d_debt != 0:\n        total_debt: uint256 = self._total_debt.initial_debt * rate_mul / self._total_debt.rate_mul + d_debt\n        self._total_debt.initial_debt = total_debt\n        self._total_debt.rate_mul = rate_mul\n\n    if remove_collateral:\n        log RemoveCollateral(_for, d_collateral)\n    else:\n        log Borrow(_for, d_collateral, d_debt)\n    log UserState(_for, xy[1], debt, n1, n2, liquidation_discount)\n\n\n@payable\n@external\n@nonreentrant('lock')\ndef add_collateral(collateral: uint256, _for: address = msg.sender):\n    \"\"\"\n    @notice Add extra collateral to avoid bad liqidations\n    @param collateral Amount of collateral to add\n    @param _for Address to add collateral for\n    \"\"\"\n    if collateral == 0:\n        return\n    self._add_collateral_borrow(collateral, 0, _for, False)\n    self._deposit_collateral(collateral, msg.value)\n\n\n@external\n@nonreentrant('lock')\ndef remove_collateral(collateral: uint256, use_eth: bool = True):\n    \"\"\"\n    @notice Remove some collateral without repaying the debt\n    @param collateral Amount of collateral to remove\n    @param use_eth Use wrapping/unwrapping if collateral is ETH\n    \"\"\"\n    if collateral == 0:\n        return\n    self._add_collateral_borrow(collateral, 0, msg.sender, True)\n    self._withdraw_collateral(msg.sender, collateral, use_eth)\n\n\n@payable\n@external\n@nonreentrant('lock')\ndef borrow_more(collateral: uint256, debt: uint256):\n    \"\"\"\n    @notice Borrow more stablecoins while adding more collateral (not necessary)\n    @param collateral Amount of collateral to add\n    @param debt Amount of stablecoin debt to take\n    \"\"\"\n    if debt == 0:\n        return\n    self._add_collateral_borrow(collateral, debt, msg.sender, False)\n    if collateral != 0:\n        self._deposit_collateral(collateral, msg.value)\n    STABLECOIN.transfer(msg.sender, debt)\n    self.minted += debt\n\n\n@internal\ndef _remove_from_list(_for: address):\n    last_loan_ix: uint256 = self.n_loans - 1\n    loan_ix: uint256 = self.loan_ix[_for]\n    assert self.loans[loan_ix] == _for  # dev: should never fail but safety first\n    self.loan_ix[_for] = 0\n    if loan_ix < last_loan_ix:  # Need to replace\n        last_loan: address = self.loans[last_loan_ix]\n        self.loans[loan_ix] = last_loan\n        self.loan_ix[last_loan] = loan_ix\n    self.n_loans = last_loan_ix\n\n\n@payable\n@external\n@nonreentrant('lock')\ndef repay(_d_debt: uint256, _for: address = msg.sender, use_eth: bool = True):\n    \"\"\"\n    @notice Repay debt (partially or fully)\n    @param _d_debt The amount of debt to repay. If higher than the current debt - will do full repayment\n    @param _for The user to repay the debt for\n    @param use_eth Use wrapping/unwrapping if collateral is ETH\n    \"\"\"\n    if _d_debt == 0:\n        return\n    # Or repay all for MAX_UINT256\n    # Withdraw if debt become 0\n    debt: uint256 = 0\n    rate_mul: uint256 = 0\n    debt, rate_mul = self._debt(_for)\n    assert debt > 0, \"Loan doesn't exist\"\n    d_debt: uint256 = min(debt, _d_debt)\n    debt -= d_debt\n\n    if debt == 0:\n        # Allow to withdraw all assets even when underwater\n        xy: uint256[2] = AMM.withdraw(_for, 10**18)\n        if xy[0] > 0:\n            # Only allow full repayment when underwater for the sender to do\n            assert _for == msg.sender\n            STABLECOIN.transferFrom(AMM.address, _for, xy[0])\n        if xy[1] > 0:\n            self._withdraw_collateral(_for, xy[1], use_eth)\n        log UserState(_for, 0, 0, 0, 0, 0)\n        log Repay(_for, xy[1], d_debt)\n        self._remove_from_list(_for)\n\n    else:\n        active_band: int256 = AMM.active_band_with_skip()\n        ns: int256[2] = AMM.read_user_tick_numbers(_for)\n        size: uint256 = convert(ns[1] - ns[0] + 1, uint256)\n\n\n        if ns[0] > active_band:\n            # Not in liquidation - can move bands\n            xy: uint256[2] = AMM.withdraw(_for, 10**18)\n            n1: int256 = self._calculate_debt_n1(xy[1], debt, size)\n            n2: int256 = n1 + ns[1] - ns[0]\n            AMM.deposit_range(_for, xy[1], n1, n2)\n            liquidation_discount: uint256 = self.liquidation_discount\n            self.liquidation_discounts[_for] = liquidation_discount\n            log UserState(_for, xy[1], debt, n1, n2, liquidation_discount)\n            log Repay(_for, 0, d_debt)\n        else:\n            # Underwater - cannot move band but can avoid a bad liquidation\n            log UserState(_for, max_value(uint256), debt, ns[0], ns[1], self.liquidation_discounts[_for])\n            log Repay(_for, 0, d_debt)\n\n    # If we withdrew already - will burn less!\n    STABLECOIN.transferFrom(msg.sender, self, d_debt)  # fail: insufficient funds\n    self.redeemed += d_debt\n\n    self.loan[_for] = Loan({initial_debt: debt, rate_mul: rate_mul})\n    total_debt: uint256 = self._total_debt.initial_debt * rate_mul / self._total_debt.rate_mul\n    self._total_debt.initial_debt = max(total_debt, d_debt) - d_debt\n    self._total_debt.rate_mul = rate_mul\n\n\n@external\n@nonreentrant('lock')\ndef repay_extended(callbacker: address, callback_sig: bytes32, callback_args: DynArray[uint256,5]):\n    \"\"\"\n    @notice Repay loan but get a stablecoin for that from callback (to deleverage)\n    @param callbacker Address of the callback contract\n    @param callback_sig method_id of the method which is called in the callbacker\n    @param callback_args Extra arguments for the callback (up to 5) such as min_amount etc\n    \"\"\"\n    # Before callback\n    ns: int256[2] = AMM.read_user_tick_numbers(msg.sender)\n    xy: uint256[2] = AMM.withdraw(msg.sender, 10**18)\n    debt: uint256 = 0\n    rate_mul: uint256 = 0\n    debt, rate_mul = self._debt(msg.sender)\n    COLLATERAL_TOKEN.transferFrom(AMM.address, callbacker, xy[1], default_return_value=True)\n\n    cb: CallbackData = self.execute_callback(\n        callbacker, callback_sig, msg.sender, xy[0], xy[1], debt, callback_args)\n\n    # After callback\n    total_stablecoins: uint256 = cb.stablecoins + xy[0]\n    assert total_stablecoins > 0  # dev: no coins to repay\n\n    # d_debt: uint256 = min(debt, total_stablecoins)\n\n    d_debt: uint256 = 0\n\n    # If we have more stablecoins than the debt - full repayment and closing the position\n    if total_stablecoins >= debt:\n        d_debt = debt\n        debt = 0\n        self._remove_from_list(msg.sender)\n\n        # Transfer debt to self, everything else to sender\n        if cb.stablecoins > 0:\n            STABLECOIN.transferFrom(callbacker, self, cb.stablecoins)\n        if xy[0] > 0:\n            STABLECOIN.transferFrom(AMM.address, self, xy[0])\n        if total_stablecoins > d_debt:\n            STABLECOIN.transfer(msg.sender, unsafe_sub(total_stablecoins, d_debt))\n        if cb.collateral > 0:\n            assert COLLATERAL_TOKEN.transferFrom(callbacker, msg.sender, cb.collateral, default_return_value=True)\n\n        log UserState(msg.sender, 0, 0, 0, 0, 0)\n\n    # Else - partial repayment -> deleverage, but only if we are not underwater\n    else:\n        size: uint256 = convert(ns[1] - ns[0] + 1, uint256)\n        assert ns[0] > cb.active_band\n        d_debt = cb.stablecoins  # cb.stablecoins <= total_stablecoins < debt\n        debt = unsafe_sub(debt, cb.stablecoins)\n\n        # Not in liquidation - can move bands\n        n1: int256 = self._calculate_debt_n1(cb.collateral, debt, size)\n        n2: int256 = n1 + ns[1] - ns[0]\n        AMM.deposit_range(msg.sender, cb.collateral, n1, n2)\n        liquidation_discount: uint256 = self.liquidation_discount\n        self.liquidation_discounts[msg.sender] = liquidation_discount\n\n        assert COLLATERAL_TOKEN.transferFrom(callbacker, AMM.address, cb.collateral, default_return_value=True)\n        # Stablecoin is all spent to repay debt -> all goes to self\n        STABLECOIN.transferFrom(callbacker, self, cb.stablecoins)\n        # We are above active band, so xy[0] is 0 anyway\n\n        log UserState(msg.sender, cb.collateral, debt, n1, n2, liquidation_discount)\n        xy[1] = 0\n\n    # Common calls which we will do regardless of whether it's a full repay or not\n    log Repay(msg.sender, xy[1], d_debt)\n    self.redeemed += d_debt\n    self.loan[msg.sender] = Loan({initial_debt: debt, rate_mul: rate_mul})\n    total_debt: uint256 = self._total_debt.initial_debt * rate_mul / self._total_debt.rate_mul\n    self._total_debt.initial_debt = unsafe_sub(max(total_debt, d_debt), d_debt)\n    self._total_debt.rate_mul = rate_mul\n\n\n@internal\n@view\ndef _health(user: address, debt: uint256, full: bool, liquidation_discount: uint256) -> int256:\n    \"\"\"\n    @notice Returns position health normalized to 1e18 for the user.\n            Liquidation starts when < 0, however devaluation of collateral doesn't cause liquidation\n    @param user User address to calculate health for\n    @param debt The amount of debt to calculate health for\n    @param full Whether to take into account the price difference above the highest user's band\n    @param liquidation_discount Liquidation discount to use (can be 0)\n    @return Health: > 0 = good.\n    \"\"\"\n    assert debt > 0, \"Loan doesn't exist\"\n    health: int256 = 10**18\n    if liquidation_discount > 0:\n        health -= convert(liquidation_discount, int256)\n    health = unsafe_div(convert(AMM.get_x_down(user), int256) * health, convert(debt, int256)) - 10**18\n\n    if full:\n        ns: int256[2] = AMM.read_user_tick_numbers(user) # ns[1] > ns[0]\n        if ns[0] > AMM.active_band():  # We are not in liquidation mode\n            p: uint256 = AMM.price_oracle()\n            p_up: uint256 = AMM.p_oracle_up(ns[0])\n            if p > p_up:\n                health += convert(unsafe_div((p - p_up) * AMM.get_sum_xy(user)[1] * COLLATERAL_PRECISION, debt), int256)\n\n    return health\n\n\n@external\n@view\n@nonreentrant('lock')\ndef health_calculator(user: address, d_collateral: int256, d_debt: int256, full: bool, N: uint256 = 0) -> int256:\n    \"\"\"\n    @notice Health predictor in case user changes the debt or collateral\n    @param user Address of the user\n    @param d_collateral Change in collateral amount (signed)\n    @param d_debt Change in debt amount (signed)\n    @param full Whether it's a 'full' health or not\n    @param N Number of bands in case loan doesn't yet exist\n    @return Signed health value\n    \"\"\"\n    xy: uint256[2] = AMM.get_sum_xy(user)\n    xy[1] *= COLLATERAL_PRECISION\n    ns: int256[2] = AMM.read_user_tick_numbers(user)\n    debt: int256 = convert(self._debt_ro(user), int256)\n    n: uint256 = N\n    ld: int256 = 0\n    if debt != 0:\n        ld = convert(self.liquidation_discounts[user], int256)\n        n = convert(ns[1] - ns[0] + 1, uint256)\n    else:\n        ld = convert(self.liquidation_discount, int256)\n        ns[0] = max_value(int256)  # This will trigger a \"re-deposit\"\n\n    n1: int256 = 0\n    collateral: int256 = 0\n    x_eff: int256 = 0\n    debt += d_debt\n    assert debt > 0, \"Non-positive debt\"\n\n    active_band: int256 = AMM.active_band_with_skip()\n\n    if ns[0] > active_band and (d_collateral != 0 or d_debt != 0):  # re-deposit\n        collateral = convert(xy[1], int256) + d_collateral\n        n1 = self._calculate_debt_n1(convert(collateral, uint256), convert(debt, uint256), n)\n\n    else:\n        n1 = ns[0]\n        x_eff = convert(AMM.get_x_down(user) * 10**18, in"
    }
  ]
}