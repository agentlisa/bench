{
  "Title": "H-2: Pool amount adjustments for collateral decreases aren't undone if swaps are successful",
  "Content": "# Issue H-2: Pool amount adjustments for collateral decreases aren't undone if swaps are successful \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/235 \n\n## Found by \nIllIllI, bin2chen, stent\n## Summary\n\nPool amount adjustments, which are added to storage as a temporary accounting tracking mechanism, aren't undone if swaps are successful\n\n\n## Vulnerability Detail\n\n`swapProfitToCollateralToken()` uses `Keys.poolAmountAdjustmentKey()` to temporarily store an adjustment to the pool amount, and undoes the adjustment at the end of the function, after the try-catch block. However, the function bypasses the end of the function in the succeess case, because it returns early, and therefore doesn't undo the adjustment.\n\n\n## Impact\n\nThe value is looked up and used in `getNextPoolAmountsParams()` for swap orders that occur afterwards. The adjusted amount will be included until someone does another swap of the profit to a collateral token, at which point it will have the new value (and not be reset unless there is an exception). The adjustment ends up being used in the calculation of swap impact, so all subsequent swaps will be priced incorrectly, giving some users discounts they don't deserve, and others a penalty that they don't deserve, when doing swaps.\n\n\n## Code Snippet\n\nAdjustment is added to storage, but isn't undone if `swapHandler.swap()` is successful:\n```solidity\n// File: gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol : DecreasePositionCollateralUtils.swapProfitToCollateralToken()   #1\n\n452                // adjust the pool amount by the poolAmountDelta so that the price impact of the swap will be\n453                // more accurately calculated\n454 @>             params.contracts.dataStore.setInt(Keys.poolAmountAdjustmentKey(params.market.marketToken, pnlToken), poolAmountDelta);\n455    \n456                try params.contracts.swapHandler.swap(\n457                    SwapUtils.SwapParams(\n...\n470                    )\n471                ) returns (address /* tokenOut */, uint256 swapOutputAmount) {\n472 @>                 return (true, swapOutputAmount);\n473                } catch Error(string memory reason) {\n474                    emit SwapUtils.SwapReverted(reason, \"\");\n475                } catch (bytes memory reasonBytes) {\n476                    (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n477                    emit SwapUtils.SwapReverted(reason, reasonBytes);\n478                }\n479    \n480 @>             params.contracts.dataStore.setInt(Keys.poolAmountAdjustmentKey(params.market.marketToken, pnlToken), 0);\n481            }\n482    \n483            return (false, 0);\n484:       }\n```\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol#L452-L484\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nUndo the adjustment before returning\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Precision.sol\";\nimport \"../error/ErrorUtils.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/PositionPricingUtils.sol\";\n\nimport \"./Position.sol\";\nimport \"./PositionEventUtils.sol\";\nimport \"./PositionStoreUtils.sol\";\nimport \"./PositionUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\n\nimport \"../swap/SwapUtils.sol\";\n\n// @title DecreasePositionCollateralUtils\n// @dev Library for functions to help with the calculations when decreasing a position\nlibrary DecreasePositionCollateralUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    struct ProcessCollateralCache {\n        int256 adjustedPositionPnlUsd;\n        uint256 adjustedPriceImpactDiffUsd;\n        uint256 adjustedPriceImpactDiffAmount;\n        uint256 pnlDiffAmount;\n    }\n\n    // @dev handle the collateral changes of the position\n    // @param params PositionUtils.UpdatePositionParams\n    // @param cache DecreasePositionCache\n    // @return (PositionUtils.DecreasePositionCollateralValues, PositionPricingUtils.PositionFees)\n    function processCollateral(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCache memory cache\n    ) external returns (\n        PositionUtils.DecreasePositionCollateralValues memory,\n        PositionPricingUtils.PositionFees memory\n    ) {\n        ProcessCollateralCache memory collateralCache;\n        PositionUtils.DecreasePositionCollateralValues memory values;\n        values.remainingCollateralAmount = cache.initialCollateralAmount.toInt256();\n\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(params.order.initialCollateralToken(), params.market, cache.prices);\n\n        (values.executionPrice, values.priceImpactAmount, values.priceImpactDiffUsd) = getExecutionPrice(params, cache.prices, params.order.sizeDeltaUsd());\n\n        (values.positionPnlUsd, values.sizeDeltaInTokens) = PositionUtils.getPositionPnlUsd(\n            params.contracts.dataStore,\n            params.market,\n            cache.prices,\n            params.position,\n            values.executionPrice,\n            params.order.sizeDeltaUsd()\n        );\n\n        collateralCache.adjustedPositionPnlUsd = values.positionPnlUsd;\n        collateralCache.adjustedPriceImpactDiffUsd = values.priceImpactDiffUsd;\n\n        if (values.positionPnlUsd > 0 && values.priceImpactDiffUsd > 0) {\n            if (values.positionPnlUsd > values.priceImpactDiffUsd.toInt256()) {\n                collateralCache.adjustedPositionPnlUsd = values.positionPnlUsd - values.priceImpactDiffUsd.toInt256();\n                collateralCache.adjustedPriceImpactDiffUsd = 0;\n            } else {\n                collateralCache.adjustedPositionPnlUsd = 0;\n                collateralCache.adjustedPriceImpactDiffUsd = values.priceImpactDiffUsd - values.positionPnlUsd.toUint256();\n            }\n        }\n\n        collateralCache.adjustedPriceImpactDiffAmount = collateralCache.adjustedPriceImpactDiffUsd / collateralTokenPrice.max;\n\n        if (collateralCache.adjustedPriceImpactDiffUsd > 0 && params.order.initialCollateralDeltaAmount() > 0) {\n            uint256 initialCollateralDeltaAmount = params.order.initialCollateralDeltaAmount();\n\n            if (collateralCache.adjustedPriceImpactDiffAmount > params.order.initialCollateralDeltaAmount()) {\n                params.order.setInitialCollateralDeltaAmount(0);\n            } else {\n                params.order.setInitialCollateralDeltaAmount(params.order.initialCollateralDeltaAmount() - collateralCache.adjustedPriceImpactDiffAmount);\n            }\n\n            OrderEventUtils.emitOrderCollateralDeltaAmountAutoUpdated(\n                params.contracts.eventEmitter,\n                params.orderKey,\n                initialCollateralDeltaAmount,\n                params.order.initialCollateralDeltaAmount()\n            );\n        }\n\n        values.remainingCollateralAmount -= params.order.initialCollateralDeltaAmount().toInt256();\n        values.output.outputToken = params.position.collateralToken();\n        values.output.outputAmount = params.order.initialCollateralDeltaAmount();\n        values.output.secondaryOutputToken = cache.pnlToken;\n\n        if (collateralCache.adjustedPositionPnlUsd < 0) {\n            // position realizes a loss\n            // deduct collateral from user, transfer it to the pool\n            values.pnlTokenForPool = params.position.collateralToken();\n            values.pnlAmountForPool = -values.positionPnlUsd / collateralTokenPrice.min.toInt256();\n            values.remainingCollateralAmount -= values.pnlAmountForPool;\n        } else {\n            // position realizes a profit\n            // deduct the pnl from the pool\n            values.pnlTokenForPool = cache.pnlToken;\n            values.pnlAmountForPool = -values.positionPnlUsd / cache.pnlTokenPrice.max.toInt256();\n            values.pnlAmountForUser = collateralCache.adjustedPositionPnlUsd.toUint256() / cache.pnlTokenPrice.max;\n\n            // if the price impact was capped send the difference to a holding area\n            collateralCache.pnlDiffAmount = (-values.pnlAmountForPool - values.pnlAmountForUser.toInt256()).toUint256();\n            if (collateralCache.pnlDiffAmount > 0) {\n                MarketUtils.incrementClaimableCollateralAmount(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.market.marketToken,\n                    cache.pnlToken,\n                    params.order.receiver(),\n                    collateralCache.pnlDiffAmount\n                );\n            }\n\n            // swap profit to the collateral token here so that the profit can be used\n            // to pay for the totalNetCostAmount from the fees\n            (bool wasSwapped, uint256 swapOutputAmount) = swapProfitToCollateralToken(\n                params,\n                cache.pnlToken,\n                values.pnlAmountForUser,\n                values.pnlAmountForPool\n            );\n\n            if (wasSwapped) {\n                values.output.outputAmount += swapOutputAmount;\n            } else {\n                if (params.position.collateralToken() == cache.pnlToken) {\n                    values.output.outputAmount += values.pnlAmountForUser;\n                } else {\n                    // store the pnlAmountForUser separately as it differs from the collateralToken\n                    values.output.secondaryOutputAmount = values.pnlAmountForUser;\n                }\n            }\n        }\n\n        PositionPricingUtils.GetPositionFeesParams memory getPositionFeesParams = PositionPricingUtils.GetPositionFeesParams(\n            params.contracts.dataStore,\n            params.contracts.referralStorage,\n            params.position,\n            collateralTokenPrice,\n            params.market.longToken,\n            params.market.shortToken,\n            params.order.sizeDeltaUsd(),\n            params.order.uiFeeReceiver()\n        );\n\n        PositionPricingUtils.PositionFees memory fees = PositionPricingUtils.getPositionFees(\n            getPositionFeesParams\n        );\n\n        // if there is a positive outputAmount, use the outputAmount to pay for fees and price impact\n        // the values.output.outputToken should be the same as the position.collateralToken at this point\n        if (values.output.outputToken == params.position.collateralToken() && values.output.outputAmount > 0) {\n            if (values.output.outputAmount > fees.totalNetCostAmount) {\n                values.output.outputAmount -= fees.totalNetCostAmount;\n                fees.collateralCostAmount = 0;\n            } else {\n                fees.collateralCostAmount -= values.output.outputAmount;\n                values.output.outputAmount = 0;\n            }\n        }\n\n        // deduct remaining fees from the position's collateral\n        values.remainingCollateralAmount -= fees.collateralCostAmount.toInt256();\n\n        // if there is insufficient collateral remaining then prioritize using the collateral to pay\n        // funding fees, the rest of the collateral is sent to the pool\n        // paying of closing fees should be safe to skip\n        // any difference in the paying of borrowing fees should be accounted for\n        // from the transfer of collateral to the pool and by the update of the\n        // pending borrowing fees\n        // any difference in pending negative PnL should similarly be accounted for\n        // through the transfer fo collateral to the pool and by the update of the\n        // pending pnl\n        // paying of price impact should also be safe to skip, it would be the same as\n        // closing the position with zero price impact, just that if there were any collateral that could\n        // partially pay for negative price impact, it would be sent to the pool instead\n        if (BaseOrderUtils.isLiquidationOrder(params.order.orderType()) && values.remainingCollateralAmount < 0) {\n            PositionEventUtils.emitPositionFeesInfo(\n                params.contracts.eventEmitter,\n                params.orderKey,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                params.order.sizeDeltaUsd(),\n                false,\n                fees\n            );\n\n            PositionEventUtils.emitLiquidationInfo(\n                params.contracts.eventEmitter,\n                params.orderKey,\n                params.position.collateralAmount(),\n                values.positionPnlUsd,\n                values.remainingCollateralAmount\n            );\n\n            return getLiquidationValues(params, values, fees);\n        }\n\n        if (values.remainingCollateralAmount < 0) {\n            revert Errors.InsufficientCollateral(values.remainingCollateralAmount);\n        }\n\n        // if there is a positive impact, the impact pool amount should be reduced\n        // if there is a negative impact, the impact pool amount should be increased\n        MarketUtils.applyDeltaToPositionImpactPool(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            -values.priceImpactAmount\n        );\n\n        // if the price impact was capped, deduct the difference from the collateral\n        // and send it to a holding area\n        if (collateralCache.adjustedPriceImpactDiffAmount > 0) {\n            if (values.remainingCollateralAmount.toUint256() < collateralCache.adjustedPriceImpactDiffAmount) {\n                collateralCache.adjustedPriceImpactDiffAmount = values.remainingCollateralAmount.toUint256();\n            }\n\n            values.remainingCollateralAmount -= collateralCache.adjustedPriceImpactDiffAmount.toInt256();\n\n            // the order.receiver is meant to allow the output of an order to be\n            // received by an address that is different from the position.account\n            // address\n            // for claimable collateral, the funds are still credited to the owner\n            // of the position indicated by order.account\n            MarketUtils.incrementClaimableCollateralAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                params.order.account(),\n                collateralCache.adjustedPriceImpactDiffAmount\n            );\n        }\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            fees.feeReceiverAmount,\n            Keys.POSITION_FEE\n        );\n\n        FeeUtils.incrementClaimableUiFeeAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.order.uiFeeReceiver(),\n            params.market.marketToken,\n            params.position.collateralToken(),\n            fees.ui.uiFeeAmount,\n            Keys.UI_POSITION_FEE\n        );\n\n        return (values, fees);\n    }\n\n    function getExecutionPrice(\n        PositionUtils.UpdatePositionParams memory params,\n        MarketUtils.MarketPrices memory prices,\n        uint256 sizeDeltaUsd\n    ) internal view returns (uint256, int256, uint256) {\n        int256 priceImpactUsd = PositionPricingUtils.getPriceImpactUsd(\n            PositionPricingUtils.GetPriceImpactUsdParams(\n                params.contracts.dataStore,\n                params.market,\n                -sizeDeltaUsd.toInt256(),\n                params.order.isLong()\n            )\n        );\n\n        priceImpactUsd = MarketUtils.getCappedPositionImpactUsd(\n            params.contracts.dataStore,\n            params.market.marketToken,\n            prices.indexTokenPrice,\n            priceImpactUsd,\n            sizeDeltaUsd\n        );\n\n        uint256 priceImpactDiffUsd;\n        if (priceImpactUsd < 0) {\n            uint256 maxPriceImpactFactor = MarketUtils.getMaxPositionImpactFactor(\n                params.contracts.dataStore,\n                params.market.marketToken,\n                false\n            );\n\n            // convert the max price impact to the min negative value\n            int256 minPriceImpactUsd = -Precision.applyFactor(sizeDeltaUsd, maxPriceImpactFactor).toInt256();\n\n            if (priceImpactUsd < minPriceImpactUsd) {\n                priceImpactDiffUsd = (minPriceImpactUsd - priceImpactUsd).toUint256();\n                priceImpactUsd = minPriceImpactUsd;\n            }\n        }\n\n        uint256 executionPrice = BaseOrderUtils.getExecutionPrice(\n            params.contracts.oracle.getCustomPrice(params.market.indexToken),\n            sizeDeltaUsd,\n            priceImpactUsd,\n            params.order.acceptablePrice(),\n            params.position.isLong(),\n            false\n        );\n\n        int256 priceImpactAmount = PositionPricingUtils.getPriceImpactAmount(\n            sizeDeltaUsd,\n            executionPrice,\n            prices.indexTokenPrice,\n            params.position.isLong(),\n            false\n        );\n\n        return (executionPrice, priceImpactAmount, priceImpactDiffUsd);\n    }\n\n    // for simplicity all fee values are set to zero in case there is insufficient\n    // collateral to cover all fees\n    function getLiquidationValues(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCollateralValues memory values,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal returns (\n        PositionUtils.DecreasePositionCollateralValues memory,\n        PositionPricingUtils.PositionFees memory\n    ) {\n        if (fees.funding.fundingFeeAmount > params.position.collateralAmount()) {\n            values.pnlAmountForPool = 0;\n            // the case where this is insufficient collateral to pay funding fees\n            // should be rare, and the difference should be small\n            // in case it happens, the pool should be topped up with the required amount using\n            // an insurance fund or similar mechanism\n            PositionEventUtils.emitInsufficientFundingFeePayment(\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                fees.funding.fundingFeeAmount,\n                params.position.collateralAmount()\n            );\n        } else {\n            values.pnlTokenForPool = params.position.collateralToken();\n            values.pnlAmountForPool = (params.position.collateralAmount() - fees.funding.fundingFeeAmount).toInt256();\n        }\n\n        PositionUtils.DecreasePositionCollateralValues memory _values = PositionUtils.DecreasePositionCollateralValues(\n            values.pnlTokenForPool, // pnlTokenForPool\n            values.executionPrice, // executionPrice\n            0, // remainingCollateralAmount\n            values.positionPnlUsd, // positionPnlUsd\n            values.pnlAmountForPool, // pnlAmountForPool\n            0, // pnlAmountForUser\n            values.sizeDeltaInTokens, // sizeDeltaInTokens\n            values.priceImpactAmount, // priceImpactAmount\n            0, // priceImpactDiffUsd\n            0, // priceImpactDiffAmount\n            PositionUtils.DecreasePositionCollateralValuesOutput(\n                address(0),\n                0,\n                address(0),\n                0\n            )\n        );\n\n        PositionPricingUtils.PositionFees memory _fees;\n\n        // allow the accumulated funding fees to still be claimable\n        _fees.funding.claimableLongTokenAmount = fees.funding.claimableLongTokenAmount;\n        _fees.funding.claimableShortTokenAmount = fees.funding.claimableShortTokenAmount;\n\n        return (_values, _fees);\n    }\n\n    // swap the withdrawn collateral from collateralToken to pnlToken if needed\n    function swapWithdrawnCollateralToPnlToken(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCollateralValues memory values\n    ) external returns (PositionUtils.DecreasePositionCollateralValues memory) {\n        if (params.order.decreasePositionSwapType() == Order.DecreasePositionSwapType.SwapCollateralTokenToPnlToken) {\n            Market.Props[] memory swapPathMarkets = new Market.Props[](1);\n            swapPathMarkets[0] = params.market;\n\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(params.market.marketToken)),\n                    params.orderKey,\n                    params.position.collateralToken(), // tokenIn\n                    values.output.outputAmount, // amountIn\n                    swapPathMarkets, // markets\n                    0, // minOutputAmount\n                    params.market.marketToken, // receiver\n                    params.order.uiFeeReceiver(), // uiFeeReceiver\n                    false // shouldUnwrapNativeToken\n                )\n            ) returns (address tokenOut, uint256 swapOutputAmount) {\n                if (tokenOut != values.output.secondaryOutputToken) {\n                    revert Errors.InvalidOutputToken(tokenOut, values.output.secondaryOutputToken);\n                }\n                // combine the values into outputToken and outputAmount\n                values.output.outputToken = tokenOut;\n                values.output.outputAmount = values.output.secondaryOutputAmount + swapOutputAmount;\n                values.output.secondaryOutputAmount = 0;\n            } catch Error(string memory reason) {\n                emit SwapUtils.SwapReverted(reason, \"\");\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                emit SwapUtils.SwapReverted(reason, reasonBytes);\n            }\n        }\n\n        return values;\n    }\n\n    // swap the realized profit from the pnlToken to the collateralToken if needed\n    function swapProfitToCollateralToken(\n        PositionUtils.UpdatePositionParams memory params,\n        address pnlToken,\n        uint256 profitAmount,\n        int256 poolAmountDelta\n    ) internal returns (bool, uint256) {\n        if (params.order.decreasePositionSwapType() == Order.DecreasePositionSwapType.SwapPnlTokenToCollateralToken) {\n            Market.Props[] memory swapPathMarkets = new Market.Props[](1);\n            swapPathMarkets[0] = params.market;\n\n            // adjust the pool amount by the poolAmountDelta so that the price impact of the swap will be\n            // more accurately calculated\n            params.contracts.dataStore.setInt(Keys.poolAmountAdjustmentKey(params.market.marketToken, pnlToken), poolAmountDelta);\n\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(params.market.marketToken)),\n                    params.orderKey,\n                    pnlToken, // tokenIn\n                    profitAmount, // amountIn\n                    swapPathMarkets, // markets\n                    0, // minOutputAmount\n                    params.market.marketToken, // receiver\n                    params.order.uiFeeReceiver(), // uiFeeReceiver\n                    false // shouldUnwrapNativeToken\n                )\n            ) returns (address /* tokenOut */, uint256 swapOutputAmount) {\n                return (true, swapOutputAmount);\n            } catch Error(string memory reason) {\n                emit SwapUtils.SwapReverted(reason, \"\");\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                emit SwapUtils.SwapReverted(reason, reasonBytes);\n            }\n\n            params.contracts.dataStore.setInt(Keys.poolAmountAdjustmentKey(params.market.marketToken, pnlToken), 0);\n        }\n\n        return (false, 0);\n    }\n}"
    }
  ]
}