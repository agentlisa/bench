{
  "Title": "[M-04] `USDMPegRecovery.sol#provide()` Improper design/implementation make it often unable to add liquidity to the `usdm3crv` pool",
  "Content": "_Submitted by WatchPug_\n\n[USDMPegRecovery.sol#L73-L82](https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/USDMPegRecovery.sol#L73-L82)<br>\n\n```solidity\nfunction provide(uint256 _minimumLP) external onlyGuardian {\n    require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n    // truncate amounts under step\n    uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;\n    // match usdm : pool3 = 1 : 1\n    uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n    usdm.approve(address(usdm3crv), addingLiquidity);\n    pool3.approve(address(usdm3crv), addingLiquidity);\n    usdm3crv.add_liquidity(amounts, _minimumLP);\n}\n```\n\nIn the current implementation of `USDMPegRecovery.sol#provide()`, `addingLiquidity` is calculated solely based on `usdm` balance (truncate at a step of 250k), and it always uses the same amount of 3pool tokens to add_liquidity with.\n\nBased on other functions of the contract, the balance of `usdm` can usually be more than the `pool3` balance, in that case, `usdm3crv.add_liquidity()` will fail.\n\n### Impact\n\nWhen the balance of `pool3` is less than `usdm` (which is can be a common scenario), funds cannot be added to the curve pool.\n\nFor example:\n\nWhen the contract got 5M of USDM and 4.2M of `pool3` tokens, it won't be possible to call `provide()` and add liquidity to the `usdm3crv` pool, as there are not enough pool3 tokens to match the 5M of USDM yet.\n\nWe expect it to add liquidity with 4M of USDM and 4M of pool3 tokens in that case.\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```solidity\nfunction provide(uint256 _minimumLP) external onlyGuardian {\n    require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n    uint256 tokenBalance = Math.min(usdm.balanceOf(address(this), pool3.balanceOf(address(this));\n    // truncate amounts under step\n    uint256 addingLiquidity = (tokenBalance / step) * step;\n    // match usdm : pool3 = 1 : 1\n    uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n    usdm.approve(address(usdm3crv), addingLiquidity);\n    pool3.approve(address(usdm3crv), addingLiquidity);\n    usdm3crv.add_liquidity(amounts, _minimumLP);\n}\n```\n\n**[ryuheimat (Concur) confirmed](https://github.com/code-423n4/2022-02-concur-findings/issues/191)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/191#issuecomment-1088106517):**\n > I agree with the finding, ultimately liquidity addition won't be at a 1:1 rate and the code won't adapt to that situation causing reverts.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-concur-finance-contest",
  "Code": [
    {
      "filename": "contracts/USDMPegRecovery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ICurveMetaPool } from \"./external/CurveInterfaces.sol\";\n\ncontract USDMPegRecovery is Ownable {\n\n    using SafeERC20 for IERC20; \n\n    IERC20 public immutable usdm;\n\n    IERC20 public immutable pool3;\n\n    ICurveMetaPool public immutable usdm3crv;\n\n    address public immutable kpiOracle;\n\n    uint256 public step;\n\n    uint256 public startLiquidity;\n\n    struct Liquidity {\n        uint128 usdm;\n        uint128 pool3;\n    }\n\n    event Deposit(address indexed depositor, Liquidity deposits);\n\n    event Withdraw(address indexed withdrawer, Liquidity withdrawals);\n\n    Liquidity public totalLiquidity;\n\n    mapping(address => Liquidity) public userLiquidity;\n\n    mapping(address => bool) public isGuardian;\n\n    bool public unlockable;\n\n    modifier onlyGuardian() {\n        require(isGuardian[msg.sender], \"!guardian\");\n        _;\n    }\n\n    constructor(\n        uint256 _startLiquidity,\n        address _kpiOracle\n    ) Ownable() {\n        startLiquidity = _startLiquidity;\n        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);\n        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);\n        step = 250000e18;\n        kpiOracle = _kpiOracle;\n    }\n\n    function addGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = true;\n    }\n\n    function removeGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = false;\n    }\n\n    function enableUnlock() external {\n        require(msg.sender == kpiOracle, \"!oracle\");\n        unlockable = true;\n    }\n\n    function provide(uint256 _minimumLP) external onlyGuardian {\n        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n        // truncate amounts under step\n        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;\n        // match usdm : pool3 = 1 : 1\n        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n        usdm.approve(address(usdm3crv), addingLiquidity);\n        pool3.approve(address(usdm3crv), addingLiquidity);\n        usdm3crv.add_liquidity(amounts, _minimumLP);\n    }\n\n    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {\n        uint256 removingLiquidity = _steps * step;\n        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];\n        usdm3crv.remove_liquidity(_burningLPs, amounts);\n    }\n\n    function deposit(Liquidity calldata _deposits) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_deposits.usdm > 0) {\n            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));\n            total.usdm += _deposits.usdm;\n            user.usdm += _deposits.usdm;\n        }\n\n        if(_deposits.pool3 > 0) {\n            require(totalLiquidity.usdm > 4000000e18, \"usdm low\");\n            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));\n            total.pool3 += _deposits.pool3;\n            user.pool3 += _deposits.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Deposit(msg.sender, _deposits);\n    }\n\n    function withdraw(Liquidity calldata _withdrawal) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_withdrawal.usdm > 0) {\n            require(unlockable, \"!unlock usdm\");\n            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));\n            total.usdm -= _withdrawal.usdm;\n            user.usdm -= _withdrawal.usdm;\n        }\n\n        if(_withdrawal.pool3 > 0) {\n            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));\n            total.pool3 -= _withdrawal.pool3;\n            user.pool3 -= _withdrawal.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Withdraw(msg.sender, _withdrawal);\n    }\n}"
    }
  ]
}