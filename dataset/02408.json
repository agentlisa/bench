{
  "Title": "H-1: Too few `ICHI` v2 farming reward tokens transferred to the user due to incorrect decimal precision",
  "Content": "# Issue H-1: Too few `ICHI` v2 farming reward tokens transferred to the user due to incorrect decimal precision \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/319 \n\n## Found by \nberndartmueller, 0x52\n\n## Summary\n\nThe `burn` function in the `WIchiFarm` contract transfers too few `ICHI` **v2** farming reward tokens to the caller due to using 9 decimals instead of 18 decimals for the `ICHI` **v2** token.\n\n## Vulnerability Detail\n\nClosing an ICHI vault spell farming position burns the wrapped ICHI vault LP tokens (`WIchiFarm` ERC-1155 tokens). Farming rewards are harvested from the ICHI farm ([see contract on Etherscan](https://etherscan.io/address/0x275dfe03bc036257cd0a713ee819dbd4529739c8)) and received as `ICHI` **v1** tokens.\n\nThe `ICHI` **v1** ERC-20 token uses **9 decimals** ([see token on Etherscan](https://etherscan.io/token/0x903bEF1736CDdf2A537176cf3C64579C3867A881)), whereas the `ICHI` **v2** ERC-20 token uses **18 decimals** ([see token on Etherscan](https://etherscan.io/token/0x111111517e4929D3dcbdfa7CCe55d30d4B6BC4d6)).\n\nThose received `ICHI` **v1** tokens are then converted to **v2** tokens in line 134.\n\nTo calculate the user's share of eligible `ICHI` **v2** reward tokens, the reward per share accumulator `stIchiPerShare` at the time of minting the `WIchiFarm` token and the current `enIchiPerShare` accumulator is used.\n\nHowever, those accumulator values are in **9 decimals** precision (please see the `ichiFarmV2.harvest` function for proof that `pool.accIchiPerShare` uses 9 decimals, otherwise the `ICHI` token transfer would fail due to inflated `_pendingIchi`). Given that `amount` is in **18 decimals**, the calculation of `stIchi` and `enIchi` in lines 143 and 144 will result in a value with **9 decimals** precision.\n\nAs previously mentioned, the `ICHI` **v2** token uses **18 decimals**. Therefore, too few `ICHI` **v2** tokens are transferred.\n\n## Impact\n\nUsers will receive substantially fewer `ICHI` v2 farming reward tokens than expected.\n\n## Code Snippet\n\n[wrapper/WIchiFarm.sol#L143-L144](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/wrapper/WIchiFarm.sol#L143-L144)\n\n```solidity\n116: function burn(uint256 id, uint256 amount)\n117:     external\n118:     nonReentrant\n119:     returns (uint256)\n120: {\n121:     if (amount == type(uint256).max) {\n122:         amount = balanceOf(msg.sender, id);\n123:     }\n124:     (uint256 pid, uint256 stIchiPerShare) = decodeId(id);\n125:     _burn(msg.sender, id, amount);\n126:\n127:     uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n128:     ichiFarm.harvest(pid, address(this));\n129:     ichiFarm.withdraw(pid, amount, address(this));\n130:\n131:     // Convert Legacy ICHI to ICHI v2\n132:     if (ichiRewards > 0) {\n133:         ICHIv1.safeApprove(address(ICHI), ichiRewards);\n134:         ICHI.convertToV2(ichiRewards);\n135:     }\n136:\n137:     // Transfer LP Tokens\n138:     address lpToken = ichiFarm.lpToken(pid);\n139:     IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n140:\n141:     // Transfer Reward Tokens\n142:     (uint256 enIchiPerShare, , ) = ichiFarm.poolInfo(pid);\n143:     uint256 stIchi = (stIchiPerShare * amount).divCeil(1e18);\n144:     uint256 enIchi = (enIchiPerShare * amount) / 1e18; // @audit-info `enIchi` and `stIchi` are in 9 decimal precision\n145:\n146:     if (enIchi > stIchi) {\n147:         ICHI.safeTransfer(msg.sender, enIchi - stIchi);\n148:     }\n149:     return pid;\n150: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider changing the denominator in lines 143 and 144 from `1e18` to `1e9` to use the required `18` decimals for the `ICHI` v2 token.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/wrapper/WIchiFarm.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\";\nimport \"../libraries/BBMath.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/ichi/IIchiV2.sol\";\nimport \"../interfaces/ichi/IIchiFarm.sol\";\n\ncontract WIchiFarm is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    IERC20Wrapper,\n    IWIchiFarm\n{\n    using BBMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IIchiV2;\n\n    IERC20Upgradeable public ICHIv1;\n    IIchiV2 public ICHI;\n    IIchiFarm public ichiFarm;\n\n    function initialize(\n        address _ichi,\n        address _ichiv1,\n        address _ichiFarm\n    ) external initializer {\n        __ERC1155_init(\"WIchiFarm\");\n        ICHI = IIchiV2(_ichi);\n        ICHIv1 = IERC20Upgradeable(_ichiv1);\n        ichiFarm = IIchiFarm(_ichiFarm);\n    }\n\n    /// @dev Encode pid, ichiPerShare to ERC1155 token id\n    /// @param pid Pool id (16-bit)\n    /// @param ichiPerShare Ichi amount per share, multiplied by 1e18 (240-bit)\n    function encodeId(uint256 pid, uint256 ichiPerShare)\n        public\n        pure\n        returns (uint256 id)\n    {\n        if (pid >= (1 << 16)) revert BAD_PID(pid);\n        if (ichiPerShare >= (1 << 240))\n            revert BAD_REWARD_PER_SHARE(ichiPerShare);\n        return (pid << 240) | ichiPerShare;\n    }\n\n    /// @dev Decode ERC1155 token id to pid, ichiPerShare\n    /// @param id Token id\n    function decodeId(uint256 id)\n        public\n        pure\n        returns (uint256 pid, uint256 ichiPerShare)\n    {\n        pid = id >> 240; // First 16 bits\n        ichiPerShare = id & ((1 << 240) - 1); // Last 240 bits\n    }\n\n    /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.\n    /// @param id Token id\n    function getUnderlyingToken(uint256 id)\n        external\n        view\n        override\n        returns (address)\n    {\n        (uint256 pid, ) = decodeId(id);\n        return ichiFarm.lpToken(pid);\n    }\n\n    /// @dev Mint ERC1155 token for the given pool id.\n    /// @param pid Pool id\n    /// @param amount Token amount to wrap\n    /// @return The token id that got minted.\n    function mint(uint256 pid, uint256 amount)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        address lpToken = ichiFarm.lpToken(pid);\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        if (\n            IERC20Upgradeable(lpToken).allowance(\n                address(this),\n                address(ichiFarm)\n            ) != type(uint256).max\n        ) {\n            // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n            IERC20Upgradeable(lpToken).safeApprove(\n                address(ichiFarm),\n                type(uint256).max\n            );\n        }\n        ichiFarm.deposit(pid, amount, address(this));\n        (uint256 ichiPerShare, , ) = ichiFarm.poolInfo(pid);\n        uint256 id = encodeId(pid, ichiPerShare);\n        _mint(msg.sender, id, amount, \"\");\n        return id;\n    }\n\n    /// @dev Burn ERC1155 token to redeem LP ERC20 token back plus ICHI rewards.\n    /// @param id Token id\n    /// @param amount Token amount to burn\n    /// @return The pool id that that you will receive LP token back.\n    function burn(uint256 id, uint256 amount)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, uint256 stIchiPerShare) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n        ichiFarm.harvest(pid, address(this));\n        ichiFarm.withdraw(pid, amount, address(this));\n\n        // Convert Legacy ICHI to ICHI v2\n        if (ichiRewards > 0) {\n            ICHIv1.safeApprove(address(ICHI), ichiRewards);\n            ICHI.convertToV2(ichiRewards);\n        }\n\n        // Transfer LP Tokens\n        address lpToken = ichiFarm.lpToken(pid);\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (uint256 enIchiPerShare, , ) = ichiFarm.poolInfo(pid);\n        uint256 stIchi = (stIchiPerShare * amount).divCeil(1e18);\n        uint256 enIchi = (enIchiPerShare * amount) / 1e18;\n\n        if (enIchi > stIchi) {\n            ICHI.safeTransfer(msg.sender, enIchi - stIchi);\n        }\n        return pid;\n    }\n}"
    }
  ]
}