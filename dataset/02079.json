{
  "Title": "H-13: Accounting breaks if end market appears multiple times in swap path",
  "Content": "# Issue H-13: Accounting breaks if end market appears multiple times in swap path \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/132 \n\n## Found by \nIllIllI\n\n## Summary\n\nIf a swap path goes through a market that also is the final destination market, share accounting breaks\n\n\n## Vulnerability Detail\n\nWhen doing a swap, every market in the provided array of markets has `_swap()` called, with the input token amount currently residing in the market address of the market, which converts the token to the output token. When the next market isn't the final destination market, the output token is transferred to the next market in the array, to be processed on the next iteration, and the pool's balance of input/output tokens is updated ([`applyDeltaToPoolAmount()`](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/swap/SwapUtils.sol#L250-L266)). If the market is the final destination market, no transfer is done, but the balance is still updated (to account for tokens being taken out as either a swap order, or a swap into a position's collateral token). \n\nIf a user does an increase order with a swap path where the final destination market appears multiple times in the swap path, markets that appear in the array, after the extra destination market, will have updated their accounting of received tokens, without actually receiving tokens.\n\n\n## Impact\n\nToken accounting will be broken, because the destination market will have extra tokens that its tracking of its own pool amounts doesn't know about (and can't be updated to know about), and subsequent markets in the chain will have fewer tokens than their pool amount accounting believes it does.\n\nAn attacker, if they're willing to incur the expense of swap fees, can perform swaps back and forth through the same market multiple times (to minimize swap impact fees), and cause a pool to have zero collateral tokens remaining, meaning LP market tokens are unable to withdraw their funds because token transfers will revert, and nobody will be able to exit their positions for the affected markets, since no collateral tokens will be available. There also will be an undercollateralization, because the reserves calculation will be wrong.\n\nEven through normal use, if a user does this, they'll be able to get their funds, since LPs are providing swap liquidity, but when it comes time to wind down the market, the last to withdraw will not be able to get their funds.\n\n\n## Code Snippet\n\nTokens aren't transferred to the next market if the next market is the destination market of the swap:\n```solidity\n// File: gmx-synthetics/contracts/swap/SwapUtils.sol : SwapUtils._swap()   #1\n\n240            // the amountOut value includes the positive price impact amount\n241 @>         if (_params.receiver != _params.market.marketToken) {\n242                MarketToken(payable(_params.market.marketToken)).transferOut(\n243                    cache.tokenOut,\n244                    _params.receiver,\n245                    cache.amountOut,\n246                    _params.shouldUnwrapNativeToken\n247                );\n248:           }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/swap/SwapUtils.sol#L240-L248\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nThe `for`-loop calling `_swap()` already knows when it's processing the [last swap](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/swap/SwapUtils.sol#L130), so set a boolean for this fact, and pass that variable into `_swap()`, and check the variable rather than using the current check\n\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/pull/101\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/swap/SwapUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../token/TokenUtils.sol\";\nimport \"../fee/FeeUtils.sol\";\n\n/**\n * @title SwapUtils\n * @dev Library for swap functions\n */\nlibrary SwapUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    /**\n     * @param dataStore The contract that provides access to data stored on-chain.\n     * @param eventEmitter The contract that emits events.\n     * @param oracle The contract that provides access to price data from oracles.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param swapPathMarkets An array of market properties, specifying the markets in which the swap should be executed.\n     * @param minOutputAmount The minimum amount of tokens that should be received as part of the swap.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct SwapParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        Oracle oracle;\n        Bank bank;\n        address tokenIn;\n        uint256 amountIn;\n        Market.Props[] swapPathMarkets;\n        uint256 minOutputAmount;\n        address receiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param market The market in which the swap should be executed.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct _SwapParams {\n        Market.Props market;\n        address tokenIn;\n        uint256 amountIn;\n        address receiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param tokenOut The address of the token that is being received as part of the swap.\n     * @param tokenInPrice The price of the token that is being swapped.\n     * @param tokenOutPrice The price of the token that is being received as part of the swap.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param amountOut The amount of the token that is being received as part of the swap.\n     * @param poolAmountOut The total amount of the token that is being received by all users in the swap pool.\n     */\n    struct SwapCache {\n        address tokenOut;\n        Price.Props tokenInPrice;\n        Price.Props tokenOutPrice;\n        uint256 amountIn;\n        uint256 amountOut;\n        uint256 poolAmountOut;\n    }\n\n    event SwapReverted(string reason, bytes reasonBytes);\n\n    error InvalidTokenIn(address tokenIn, address market);\n    error InsufficientSwapOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\n\n    /**\n     * @dev Swaps a given amount of a given token for another token based on a\n     * specified swap path.\n     * @param params The parameters for the swap.\n     * @return A tuple containing the address of the token that was received as\n     * part of the swap and the amount of the received token.\n     */\n    function swap(SwapParams memory params) external returns (address, uint256) {\n        if (params.swapPathMarkets.length == 0) {\n            if (address(params.bank) != params.receiver) {\n                params.bank.transferOut(\n                    params.tokenIn,\n                    params.receiver,\n                    params.amountIn,\n                    params.shouldUnwrapNativeToken\n                );\n            }\n            return (params.tokenIn, params.amountIn);\n        }\n\n        if (address(params.bank) != params.swapPathMarkets[0].marketToken) {\n            params.bank.transferOut(\n                params.tokenIn,\n                params.swapPathMarkets[0].marketToken,\n                params.amountIn,\n                false\n            );\n        }\n\n        address tokenOut = params.tokenIn;\n        uint256 outputAmount = params.amountIn;\n\n        for (uint256 i = 0; i < params.swapPathMarkets.length; i++) {\n            Market.Props memory market = params.swapPathMarkets[i];\n            uint256 nextIndex = i + 1;\n            address receiver;\n            if (nextIndex < params.swapPathMarkets.length) {\n                receiver = params.swapPathMarkets[nextIndex].marketToken;\n            } else {\n                receiver = params.receiver;\n            }\n\n            _SwapParams memory _params = _SwapParams(\n                market,\n                tokenOut,\n                outputAmount,\n                receiver,\n                i == params.swapPathMarkets.length - 1 ? params.shouldUnwrapNativeToken : false // only convert ETH on the last swap if needed\n            );\n\n            (tokenOut, outputAmount) = _swap(params, _params);\n        }\n\n        if (outputAmount < params.minOutputAmount) {\n            revert InsufficientSwapOutputAmount(outputAmount, params.minOutputAmount);\n        }\n\n        return (tokenOut, outputAmount);\n    }\n\n    /**\n     * Performs a swap on a single market.\n     *\n     * @param params  The parameters for the swap.\n     * @param _params The parameters for the swap on this specific market.\n     * @return The token and amount that was swapped.\n     */\n    function _swap(SwapParams memory params, _SwapParams memory _params) internal returns (address, uint256) {\n        SwapCache memory cache;\n\n        if (_params.tokenIn != _params.market.longToken && _params.tokenIn != _params.market.shortToken) {\n            revert InvalidTokenIn(_params.tokenIn, _params.market.marketToken);\n        }\n\n        cache.tokenOut = MarketUtils.getOppositeToken(_params.tokenIn, _params.market);\n        cache.tokenInPrice = params.oracle.getLatestPrice(_params.tokenIn);\n        cache.tokenOutPrice = params.oracle.getLatestPrice(cache.tokenOut);\n\n        SwapPricingUtils.SwapFees memory fees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.amountIn\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            fees.feeReceiverAmount,\n            Keys.SWAP_FEE\n        );\n\n        int256 priceImpactUsd = SwapPricingUtils.getPriceImpactUsd(\n            SwapPricingUtils.GetPriceImpactUsdParams(\n                params.dataStore,\n                _params.market.marketToken,\n                _params.tokenIn,\n                cache.tokenOut,\n                cache.tokenInPrice.midPrice(),\n                cache.tokenOutPrice.midPrice(),\n                (fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256(),\n                -(fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256()\n            )\n        );\n\n        if (priceImpactUsd > 0) {\n            // when there is a positive price impact factor, additional tokens from the swap impact pool\n            // are withdrawn for the user\n            // for example, if 50,000 USDC is swapped out and there is a positive price impact\n            // an additional 100 USDC may be sent to the user\n            // the swap impact pool is decreased by the used amount\n\n            cache.amountIn = fees.amountAfterFees;\n            // round amountOut down\n            cache.amountOut = cache.amountIn * cache.tokenInPrice.min / cache.tokenOutPrice.max;\n            cache.poolAmountOut = cache.amountOut;\n\n            int256 positiveImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                cache.tokenOut,\n                cache.tokenOutPrice,\n                priceImpactUsd\n            );\n\n            cache.amountOut += positiveImpactAmount.toUint256();\n        } else {\n            // when there is a negative price impact factor,\n            // less of the input amount is sent to the pool\n            // for example, if 10 ETH is swapped in and there is a negative price impact\n            // only 9.995 ETH may be swapped in\n            // the remaining 0.005 ETH will be stored in the swap impact pool\n\n            int256 negativeImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                _params.tokenIn,\n                cache.tokenInPrice,\n                priceImpactUsd\n            );\n\n            cache.amountIn = fees.amountAfterFees - (-negativeImpactAmount).toUint256();\n            cache.amountOut = cache.amountIn * cache.tokenInPrice.min / cache.tokenOutPrice.max;\n            cache.poolAmountOut = cache.amountOut;\n        }\n\n        // the amountOut value includes the positive price impact amount\n        if (_params.receiver != _params.market.marketToken) {\n            MarketToken(payable(_params.market.marketToken)).transferOut(\n                cache.tokenOut,\n                _params.receiver,\n                cache.amountOut,\n                _params.shouldUnwrapNativeToken\n            );\n        }\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            (cache.amountIn + fees.feeAmountForPool).toInt256()\n        );\n\n        // the poolAmountOut excludes the positive price impact amount\n        // as that is deducted from the swap impact pool instead\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            cache.tokenOut,\n            -cache.poolAmountOut.toInt256()\n        );\n\n        MarketUtils.MarketPrices memory prices = MarketUtils.MarketPrices(\n            params.oracle.getLatestPrice(_params.market.indexToken),\n            _params.tokenIn == _params.market.longToken ? cache.tokenInPrice : cache.tokenOutPrice,\n            _params.tokenIn == _params.market.shortToken ? cache.tokenInPrice : cache.tokenOutPrice\n        );\n\n        MarketUtils.validatePoolAmount(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.tokenIn\n        );\n\n        MarketUtils.validateReserve(\n            params.dataStore,\n            _params.market,\n            prices,\n            cache.tokenOut == _params.market.longToken\n        );\n\n        MarketUtils.validateMaxPnl(\n            params.dataStore,\n            _params.market,\n            prices,\n            Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS\n        );\n\n        SwapPricingUtils.emitSwapInfo(\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.receiver,\n            _params.tokenIn,\n            cache.tokenOut,\n            cache.tokenInPrice.min,\n            cache.tokenOutPrice.max,\n            _params.amountIn,\n            cache.amountIn,\n            cache.amountOut,\n            priceImpactUsd\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            \"swap\",\n            fees\n        );\n\n        return (cache.tokenOut, cache.amountOut);\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/swap/SwapUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../token/TokenUtils.sol\";\nimport \"../fee/FeeUtils.sol\";\n\n/**\n * @title SwapUtils\n * @dev Library for swap functions\n */\nlibrary SwapUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    /**\n     * @param dataStore The contract that provides access to data stored on-chain.\n     * @param eventEmitter The contract that emits events.\n     * @param oracle The contract that provides access to price data from oracles.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param swapPathMarkets An array of market properties, specifying the markets in which the swap should be executed.\n     * @param minOutputAmount The minimum amount of tokens that should be received as part of the swap.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct SwapParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        Oracle oracle;\n        Bank bank;\n        address tokenIn;\n        uint256 amountIn;\n        Market.Props[] swapPathMarkets;\n        uint256 minOutputAmount;\n        address receiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param market The market in which the swap should be executed.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct _SwapParams {\n        Market.Props market;\n        address tokenIn;\n        uint256 amountIn;\n        address receiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param tokenOut The address of the token that is being received as part of the swap.\n     * @param tokenInPrice The price of the token that is being swapped.\n     * @param tokenOutPrice The price of the token that is being received as part of the swap.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param amountOut The amount of the token that is being received as part of the swap.\n     * @param poolAmountOut The total amount of the token that is being received by all users in the swap pool.\n     */\n    struct SwapCache {\n        address tokenOut;\n        Price.Props tokenInPrice;\n        Price.Props tokenOutPrice;\n        uint256 amountIn;\n        uint256 amountOut;\n        uint256 poolAmountOut;\n    }\n\n    event SwapReverted(string reason, bytes reasonBytes);\n\n    error InvalidTokenIn(address tokenIn, address market);\n    error InsufficientSwapOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\n\n    /**\n     * @dev Swaps a given amount of a given token for another token based on a\n     * specified swap path.\n     * @param params The parameters for the swap.\n     * @return A tuple containing the address of the token that was received as\n     * part of the swap and the amount of the received token.\n     */\n    function swap(SwapParams memory params) external returns (address, uint256) {\n        if (params.swapPathMarkets.length == 0) {\n            if (address(params.bank) != params.receiver) {\n                params.bank.transferOut(\n                    params.tokenIn,\n                    params.receiver,\n                    params.amountIn,\n                    params.shouldUnwrapNativeToken\n                );\n            }\n            return (params.tokenIn, params.amountIn);\n        }\n\n        if (address(params.bank) != params.swapPathMarkets[0].marketToken) {\n            params.bank.transferOut(\n                params.tokenIn,\n                params.swapPathMarkets[0].marketToken,\n                params.amountIn,\n                false\n            );\n        }\n\n        address tokenOut = params.tokenIn;\n        uint256 outputAmount = params.amountIn;\n\n        for (uint256 i = 0; i < params.swapPathMarkets.length; i++) {\n            Market.Props memory market = params.swapPathMarkets[i];\n            uint256 nextIndex = i + 1;\n            address receiver;\n            if (nextIndex < params.swapPathMarkets.length) {\n                receiver = params.swapPathMarkets[nextIndex].marketToken;\n            } else {\n                receiver = params.receiver;\n            }\n\n            _SwapParams memory _params = _SwapParams(\n                market,\n                tokenOut,\n                outputAmount,\n                receiver,\n                i == params.swapPathMarkets.length - 1 ? params.shouldUnwrapNativeToken : false // only convert ETH on the last swap if needed\n            );\n\n            (tokenOut, outputAmount) = _swap(params, _params);\n        }\n\n        if (outputAmount < params.minOutputAmount) {\n            revert InsufficientSwapOutputAmount(outputAmount, params.minOutputAmount);\n        }\n\n        return (tokenOut, outputAmount);\n    }\n\n    /**\n     * Performs a swap on a single market.\n     *\n     * @param params  The parameters for the swap.\n     * @param _params The parameters for the swap on this specific market.\n     * @return The token and amount that was swapped.\n     */\n    function _swap(SwapParams memory params, _SwapParams memory _params) internal returns (address, uint256) {\n        SwapCache memory cache;\n\n        if (_params.tokenIn != _params.market.longToken && _params.tokenIn != _params.market.shortToken) {\n            revert InvalidTokenIn(_params.tokenIn, _params.market.marketToken);\n        }\n\n        cache.tokenOut = MarketUtils.getOppositeToken(_params.tokenIn, _params.market);\n        cache.tokenInPrice = params.oracle.getLatestPrice(_params.tokenIn);\n        cache.tokenOutPrice = params.oracle.getLatestPrice(cache.tokenOut);\n\n        SwapPricingUtils.SwapFees memory fees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.amountIn\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            fees.feeReceiverAmount,\n            Keys.SWAP_FEE\n        );\n\n        int256 priceImpactUsd = SwapPricingUtils.getPriceImpactUsd(\n            SwapPricingUtils.GetPriceImpactUsdParams(\n                params.dataStore,\n                _params.market.marketToken,\n                _params.tokenIn,\n                cache.tokenOut,\n                cache.tokenInPrice.midPrice(),\n                cache.tokenOutPrice.midPrice(),\n                (fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256(),\n                -(fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256()\n            )\n        );\n\n        if (priceImpactUsd > 0) {\n            // when there is a positive price impact factor, additional tokens from the swap impact pool\n            // are withdrawn for the user\n            // for example, if 50,000 USDC is swapped out and there is a positive price impact\n            // an additional 100 USDC may be sent to the user\n            // the swap impact pool is decreased by the used amount\n\n            cache.amountIn = fees.amountAfterFees;\n            // round amountOut down\n            cache.amountOut = cache.amountIn * cache.tokenInPrice.min / cache.tokenOutPrice.max;\n            cache.poolAmountOut = cache.amountOut;\n\n            int256 positiveImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                cache.tokenOut,\n                cache.tokenOutPrice,\n                priceImpactUsd\n            );\n\n            cache.amountOut += positiveImpactAmount.toUint256();\n        } else {\n            // when there is a negative price impact factor,\n            // less of the input amount is sent to the pool\n            // for example, if 10 ETH is swapped in and there is a negative price impact\n            // only 9.995 ETH may be swapped in\n            // the remaining 0.005 ETH will be stored in the swap impact pool\n\n            int256 negativeImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                _params.tokenIn,\n                cache.tokenInPrice,\n                priceImpactUsd\n            );\n\n            cache.amountIn = fees.amountAfterFees - (-negativeImpactAmount).toUint256();\n            cache.amountOut = cache.amountIn * cache.tokenInPrice.min / cache.tokenOutPrice.max;\n            cache.poolAmountOut = cache.amountOut;\n        }\n\n        // the amountOut value includes the positive price impact amount\n        if (_params.receiver != _params.market.marketToken) {\n            MarketToken(payable(_params.market.marketToken)).transferOut(\n                cache.tokenOut,\n                _params.receiver,\n                cache.amountOut,\n                _params.shouldUnwrapNativeToken\n            );\n        }\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            (cache.amountIn + fees.feeAmountForPool).toInt256()\n        );\n\n        // the poolAmountOut excludes the positive price impact amount\n        // as that is deducted from the swap impact pool instead\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            cache.tokenOut,\n            -cache.poolAmountOut.toInt256()\n        );\n\n        MarketUtils.MarketPrices memory prices = MarketUtils.MarketPrices(\n            params.oracle.getLatestPrice(_params.market.indexToken),\n            _params.tokenIn == _params.market.longToken ? cache.tokenInPrice : cache.tokenOutPrice,\n            _params.tokenIn == _params.market.shortToken ? cache.tokenInPrice : cache.tokenOutPrice\n        );\n\n        MarketUtils.validatePoolAmount(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.tokenIn\n        );\n\n        MarketUtils.validateReserve(\n            params.dataStore,\n            _params.market,\n            prices,\n            cache.tokenOut == _params.market.longToken\n        );\n\n        MarketUtils.validateMaxPnl(\n            params.dataStore,\n            _params.market,\n            prices,\n            Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS\n        );\n\n        SwapPricingUtils.emitSwapInfo(\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.receiver,\n            _params.tokenIn,\n            cache.tokenOut,\n            cache.tokenInPrice.min,\n            cache.tokenOutPrice.max,\n            _params.amountIn,\n            cache.amountIn,\n            cache.amountOut,\n            priceImpactUsd\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            \"swap\",\n            fees\n        );\n\n        return (cache.tokenOut, cache.amountOut);\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/swap/SwapUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../token/TokenUtils.sol\";\nimport \"../fee/FeeUtils.sol\";\n\n/**\n * @title SwapUtils\n * @dev Library for swap functions\n */\nlibrary SwapUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    /**\n     * @param dataStore The contract that provides access to data stored on-chain.\n     * @param eventEmitter The contract that emits events.\n     * @param oracle The contract that provides access to price data from oracles.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param swapPathMarkets An array of market properties, specifying the markets in which the swap should be executed.\n     * @param minOutputAmount The minimum amount of tokens that should be received as part of the swap.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct SwapParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        Oracle oracle;\n        Bank bank;\n        address tokenIn;\n        uint256 amountIn;\n        Market.Props[] swapPathMarkets;\n        uint256 minOutputAmount;\n        address receiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param market The market in which the swap should be executed.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct _SwapParams {\n        Market.Props market;\n        address tokenIn;\n        uint256 amountIn;\n        address receiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param tokenOut The address of the token that is being received as part of the swap.\n     * @param tokenInPrice The price of the token that is being swapped.\n     * @param tokenOutPrice The price of the token that is being received as part of the swap.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param amountOut The amount of the token that is being received as part of the swap.\n     * @param poolAmountOut The total amount of the token that is being received by all users in the swap pool.\n     */\n    struct SwapCache {\n        address tokenOut;\n        Price.Props tokenInPrice;\n        Price.Props tokenOutPrice;\n        uint256 amountIn;\n        uint256 amountOut;\n        uint256 poolAmountOut;\n    }\n\n    event SwapReverted(string reason, bytes reasonBytes);\n\n    error InvalidTokenIn(address tokenIn, address market);\n    error InsufficientSwapOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\n\n    /**\n     * @dev Swaps a given amount of a given token for another token based on a\n     * specified swap path.\n     * @param params The parameters for the swap.\n     * @return A tuple containing the address of the token that was received as\n     * part of the swap and the amount of the received token.\n     */\n    function swap(SwapParams memory params) external returns (address, uint256) {\n        if (params.swapPathMarkets.length == 0) {\n            if (address(params.bank) != params.receiver) {\n                params.bank.transferOut(\n                    params.tokenIn,\n                    params.receiver,\n                    params.amountIn,\n                    params.shouldUnwrapNativeToken\n                );\n            }\n            return (params.tokenIn, params.amountIn);\n        }\n\n        if (address(params.bank) != params.swapPathMarkets[0].marketToken) {\n            params.bank.transferOut(\n                params.tokenIn,\n                params.swapPathMarkets[0].marketToken,\n                params.amountIn,\n                false\n            );\n        }\n\n        address tokenOut = params.tokenIn;\n        uint256 outputAmount = params.amountIn;\n\n        for (uint256 i = 0; i < params.swapPathMarkets.length; i++) {\n            Market.Props memory market = params.swapPathMarkets[i];\n            uint256 nextIndex = i + 1;\n            address receiver;\n            if (nextIndex < params.swapPathMarkets.length) {\n                receiver = params.swapPathMarkets[nextIndex].marketToken;\n            } else {\n                receiver = params.receiver;\n            }\n\n            _SwapParams memory _params = _SwapParams(\n                market,\n                tokenOut,\n                outputAmount,\n                receiver,\n                i == params.swapPathMarkets.length - 1 ? params.shouldUnwrapNativeToken : false // only convert ETH on the last swap if needed\n            );\n\n            (tokenOut, outputAmount) = _swap(params, _params);\n        }\n\n        if (outputAmount < params.minOutputAmount) {\n            revert InsufficientSwapOutputAmount(outputAmount, params.minOutputAmount);\n        }\n\n        return (tokenOut, outputAmount);\n    }\n\n    /**\n     * Performs a swap on a single market.\n     *\n     * @param params  The parameters for the swap.\n     * @param _params The parameters for the swap on this specific market.\n     * @return The token and amount that was swapped.\n     */\n    function _swap(SwapParams memory params, _SwapParams memory _params) internal returns (address, uint256) {\n        SwapCache memory cache;\n\n        if (_params.tokenIn != _params.market.longToken && _params.tokenIn != _params.market.shortToken) {\n            revert InvalidTokenIn(_params.tokenIn, _params.market.marketToken);\n        }\n\n        cache.tokenOut = MarketUtils.getOppositeToken(_params.tokenIn, _params.market);\n        cache.tokenInPrice = params.oracle.getLatestPrice(_params.tokenIn);\n        cache.tokenOutPrice = params.oracle.getLatestPrice(cache.tokenOut);\n\n        SwapPricingUtils.SwapFees memory fees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.amountIn\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            fees.feeReceiverAmount,\n            Keys.SWAP_FEE\n        );\n\n        int256 priceImpactUsd = SwapPricingUtils.getPriceImpactUsd(\n            SwapPricingUtils.GetPriceImpactUsdParams(\n                params.dataStore,\n                _params.market.marketToken,\n                _params.tokenIn,\n                cache.tokenOut,\n                cache.tokenInPrice.midPrice(),\n                cache.tokenOutPrice.midPrice(),\n                (fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256(),\n                -(fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256()\n            )\n        );\n\n        if (priceImpactUsd > 0) {\n            // when there is a positive price impact factor, additional tokens from the swap impact pool\n            // are withdrawn for the user\n            // for example, if 50,000 USDC is swapped out and there is a positive price impact\n            // an additional 100 USDC may be sent to the user\n            // the swap impact pool is decreased by the used amount\n\n            cache.amountIn = fees.amountAfterFees;\n            // round amountOut down\n            cache.amountOut = cache.amountIn * cache.tokenInPrice.min / cache.tokenOutPrice.max;\n            cache.poolAmountOut = cache.amountOut;\n\n            int256 positiveImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                cache.tokenO"
    }
  ]
}