{
  "Title": "3S-LENFT-N06 Throughout codebase: some events could be emitted",
  "Content": "#### Description\n- In InterestRate.sol, when [adding ](https://github.com/leNFT/contracts/blob/9b1ae95f97ec5d2423c022179642714cee470a68/contracts/protocol/Lending/InterestRate.sol#L32-L39) or [removing ](https://github.com/leNFT/contracts/blob/9b1ae95f97ec5d2423c022179642714cee470a68/contracts/protocol/Lending/InterestRate.sol#L43-L48)a token no event is emitted publicizing this change.\n- When creating a pool [here](https://github.com/leNFT/contracts/blob/9b1ae95f97ec5d2423c022179642714cee470a68/contracts/protocol/Lending/LendingMarket.sol#LL258C1-L259C1), more information could be given in the event.\n\n\n#### Recommendation\n- Emit \"TokenAdded\" and \"TokenRemoved\" events when adding or removing a token.\n- Also emit the underlying asset of the pool in the `CreateLendingPool` event",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/Lending/InterestRate.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ConfigTypes} from \"../../libraries/types/ConfigTypes.sol\";\nimport {PercentageMath} from \"../../libraries/utils/PercentageMath.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title InterestRate\n/// @author leNFT\n/// @notice A contract for calculating the borrow rate based on the utilization rate\n/// @dev This contract implements the IInterestRate interface\n/// @dev The borrow rate is calculated based on a utilization rate between 0 and 100%\n/// @dev The optimal utilization rate is the target utilization rate where the borrow rate is equal to the base rate plus the low slope\n/// @dev Above the optimal utilization rate, the borrow rate is linearly increased based on the high slope\n/// @dev Below the optimal utilization rate, the borrow rate is linearly increased based on the low slope\n/// @dev Utilization rate is defined as the ratio of total debt to total liquidity in the system\n/// @dev The calculation of the utilization rate is done by the internal _calculateUtilizationRate function\ncontract InterestRate is IInterestRate, Ownable {\n    mapping(address => bool) private _isSupported;\n    mapping(address => ConfigTypes.InterestRateConfig)\n        private _interestRateConfigs;\n\n    modifier onlySupported(address token) {\n        _requireOnlySupported(token);\n        _;\n    }\n\n    /// @notice Sets the interest rate parameters for a token\n    /// @param token The address of the token\n    /// @param interestRateConfig The interest rate parameters\n    function addToken(\n        address token,\n        ConfigTypes.InterestRateConfig memory interestRateConfig\n    ) external onlyOwner {\n        require(_isSupported[token] == false, \"IR:AT:TOKEN_ALREADY_SUPPORTED\");\n        _isSupported[token] = true;\n        _interestRateConfigs[token] = interestRateConfig;\n    }\n\n    /// @notice Removes support for a token\n    /// @param token The address of the token\n    function removeToken(\n        address token\n    ) external onlySupported(token) onlyOwner {\n        delete _isSupported[token];\n        delete _interestRateConfigs[token];\n    }\n\n    /// @notice Gets whether a token is supported\n    /// @param token The address of the token\n    /// @return Whether the token is supported\n    function isTokenSupported(address token) external view returns (bool) {\n        return _isSupported[token];\n    }\n\n    /// @notice Gets the interest rate parameters for a token\n    /// @param token The address of the token\n    /// @return The interest rate parameters\n    function getInterestRateConfig(\n        address token\n    )\n        external\n        view\n        onlySupported(token)\n        returns (ConfigTypes.InterestRateConfig memory)\n    {\n        return _interestRateConfigs[token];\n    }\n\n    /// @notice Sets the interest rate parameters for a token\n    /// @param token The address of the token\n    /// @param interestRateConfig The interest rate parameters\n    function setInterestRateConfig(\n        address token,\n        ConfigTypes.InterestRateConfig memory interestRateConfig\n    ) external onlySupported(token) onlyOwner {\n        _interestRateConfigs[token] = interestRateConfig;\n    }\n\n    /// @notice Calculates the borrow rate based on the utilization rate\n    /// @param token The address of the token\n    /// @param assets The total assets\n    /// @param debt The total debt\n    /// @return The borrow rate\n    function calculateBorrowRate(\n        address token,\n        uint256 assets,\n        uint256 debt\n    ) external view override onlySupported(token) returns (uint256) {\n        uint256 utilizationRate = _calculateUtilizationRate(assets, debt);\n\n        if (\n            utilizationRate < _interestRateConfigs[token].optimalUtilizationRate\n        ) {\n            return\n                _interestRateConfigs[token].baseBorrowRate +\n                PercentageMath.percentMul(\n                    utilizationRate,\n                    _interestRateConfigs[token].lowSlope\n                );\n        } else {\n            return\n                getOptimalBorrowRate(token) +\n                PercentageMath.percentMul(\n                    utilizationRate -\n                        _interestRateConfigs[token].optimalUtilizationRate,\n                    _interestRateConfigs[token].highSlope\n                );\n        }\n    }\n\n    /// @notice Gets the optimal borrow rate\n    /// @param token The address of the token\n    /// @return The optimal borrow rate\n    function getOptimalBorrowRate(\n        address token\n    ) public view onlySupported(token) returns (uint256) {\n        return\n            PercentageMath.percentMul(\n                _interestRateConfigs[token].optimalUtilizationRate,\n                _interestRateConfigs[token].lowSlope\n            ) + _interestRateConfigs[token].baseBorrowRate;\n    }\n\n    /// @notice Calculates the utilization rate based on the assets and debt\n    /// @param assets The total assets\n    /// @param debt The total debt\n    /// @return The utilization rate\n    function calculateUtilizationRate(\n        address token,\n        uint256 assets,\n        uint256 debt\n    ) external view override onlySupported(token) returns (uint256) {\n        return _calculateUtilizationRate(assets, debt);\n    }\n\n    /// @notice Internal function to calculate the utilization rate based on the assets and debt\n    /// @param assets The total assets\n    /// @param debt The total debt\n    function _calculateUtilizationRate(\n        uint256 assets,\n        uint256 debt\n    ) internal pure returns (uint256) {\n        if ((assets + debt) == 0) {\n            return 0;\n        } else {\n            return (PercentageMath.PERCENTAGE_FACTOR * debt) / (assets + debt);\n        }\n    }\n\n    function _requireOnlySupported(address token) internal view {\n        require(_isSupported[token], \"IR:TOKEN_NOT_SUPPORTED\");\n    }\n}"
    },
    {
      "filename": "contracts/protocol/Lending/LendingMarket.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {ILendingMarket} from \"../../interfaces/ILendingMarket.sol\";\nimport {IInterestRate} from \"../../interfaces/IInterestRate.sol\";\nimport {ITokenOracle} from \"../../interfaces/ITokenOracle.sol\";\nimport {LiquidationLogic} from \"../../libraries/logic/LiquidationLogic.sol\";\nimport {BorrowLogic} from \"../../libraries/logic/BorrowLogic.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\nimport {ConfigTypes} from \"../../libraries/types/ConfigTypes.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IAddressProvider} from \"../../interfaces/IAddressProvider.sol\";\nimport {ILoanCenter} from \"../../interfaces/ILoanCenter.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC4626Upgradeable} from \"@openzeppelin/contracts-upgradeable/interfaces/IERC4626Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {ERC165CheckerUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {Trustus} from \"../Trustus/Trustus.sol\";\nimport {LendingPool} from \"./LendingPool.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/// @title LendingMarket Contract\n/// @author leNFT\n/// @notice This contract is the entrypoint for the leNFT lending protocol\n/// @dev Call these contract functions to interact with the lending part of the protocol\ncontract LendingMarket is\n    ILendingMarket,\n    OwnableUpgradeable,\n    ERC721HolderUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using ERC165CheckerUpgradeable for address;\n\n    // collection + asset = pool\n    mapping(address => mapping(address => address)) private _pools;\n\n    // Number of pools per asset\n    mapping(address => uint256) private _poolsCount;\n\n    // The TVL safeguard for the lending pools\n    uint256 private _tvlSafeguard;\n\n    IAddressProvider private _addressProvider;\n    ConfigTypes.LendingPoolConfig private _defaultLendingPoolConfig;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the LendingMarket contract\n    /// @param addressProvider Address of the addresses provider contract\n    /// @param tvlSafeguard The TVL safeguard for the lending pools\n    /// @param defaultLendingPoolConfig The default lending pool configuration\n    function initialize(\n        IAddressProvider addressProvider,\n        uint256 tvlSafeguard,\n        ConfigTypes.LendingPoolConfig calldata defaultLendingPoolConfig\n    ) external initializer {\n        __Ownable_init();\n        __ERC721Holder_init();\n        __ReentrancyGuard_init();\n        _addressProvider = addressProvider;\n        _tvlSafeguard = tvlSafeguard;\n        _defaultLendingPoolConfig = defaultLendingPoolConfig;\n    }\n\n    /// @notice Borrow an asset from a lending pool using an NFT as collateral\n    /// @dev NFT approval needs to be given to the LoanCenter contract\n    /// @param onBehalfOf The address of the user who will receive the borrowed tokens\n    /// @param asset The address of the asset to be borrowed\n    /// @param amount Amount of the asset to be borrowed\n    /// @param nftAddress Address of the NFT collateral\n    /// @param nftTokenIds Token id of the NFT collateral\n    /// @param genesisNFTId Token id of the genesis NFT to be used for LTV boost\n    /// @param request ID of the collateral price request sent by the trusted server\n    /// @param packet Signed collateral price request sent by the trusted server\n    function borrow(\n        address onBehalfOf,\n        address asset,\n        uint256 amount,\n        address nftAddress,\n        uint256[] memory nftTokenIds,\n        uint256 genesisNFTId,\n        bytes32 request,\n        Trustus.TrustusPacket calldata packet\n    ) external override nonReentrant {\n        BorrowLogic.borrow(\n            _addressProvider,\n            _pools[nftAddress][asset],\n            DataTypes.BorrowParams({\n                caller: msg.sender,\n                onBehalfOf: onBehalfOf,\n                asset: asset,\n                amount: amount,\n                nftAddress: nftAddress,\n                nftTokenIds: nftTokenIds,\n                genesisNFTId: genesisNFTId,\n                request: request,\n                packet: packet\n            })\n        );\n\n        emit Borrow(onBehalfOf, asset, nftAddress, nftTokenIds, amount);\n    }\n\n    /// @notice Repay an an active loan\n    /// @param loanId The ID of the loan to be paid\n    /// @param amount Amount to be repaid\n    function repay(\n        uint256 loanId,\n        uint256 amount\n    ) external override nonReentrant {\n        BorrowLogic.repay(\n            _addressProvider,\n            DataTypes.RepayParams({\n                caller: msg.sender,\n                loanId: loanId,\n                amount: amount\n            })\n        );\n\n        emit Repay(msg.sender, loanId);\n    }\n\n    /// @notice Liquidate an active loan\n    /// @dev Needs to approve WETH transfers from Market address\n    /// @param loanId The ID of the loan to be paid\n    /// @param bid The amount to bid on the collateral\n    /// @param request ID of the collateral price request sent by the trusted server\n    /// @param packet Signed collateral price request sent by the trusted server\n    function createLiquidationAuction(\n        address onBehalfOf,\n        uint256 loanId,\n        uint256 bid,\n        bytes32 request,\n        Trustus.TrustusPacket calldata packet\n    ) external override nonReentrant {\n        LiquidationLogic.createLiquidationAuction(\n            _addressProvider,\n            DataTypes.CreateAuctionParams({\n                caller: msg.sender,\n                onBehalfOf: onBehalfOf,\n                loanId: loanId,\n                bid: bid,\n                request: request,\n                packet: packet\n            })\n        );\n\n        emit CreateLiquidationAuction(onBehalfOf, loanId, bid);\n    }\n\n    /// @notice Bid on a liquidation auction\n    /// @dev Needs to approve WETH transfers from Market address\n    /// @param loanId The ID of the loan to be paid\n    /// @param bid The bid amount\n    function bidLiquidationAuction(\n        address onBehalfOf,\n        uint256 loanId,\n        uint256 bid\n    ) external override nonReentrant {\n        LiquidationLogic.bidLiquidationAuction(\n            _addressProvider,\n            DataTypes.BidAuctionParams({\n                caller: msg.sender,\n                onBehalfOf: onBehalfOf,\n                loanId: loanId,\n                bid: bid\n            })\n        );\n\n        emit BidLiquidationAuction(onBehalfOf, loanId, bid);\n    }\n\n    /// @notice Claim the collateral of a liquidated loan\n    /// @param loanId The ID of the loan to be claimmed\n    function claimLiquidation(uint256 loanId) external override nonReentrant {\n        LiquidationLogic.claimLiquidation(\n            _addressProvider,\n            DataTypes.ClaimLiquidationParams({loanId: loanId})\n        );\n        emit ClaimLiquidation(msg.sender, loanId);\n    }\n\n    /// @notice Set the lending pool address for a certain collection and asset\n    /// @param collection The collection using this lending vault\n    /// @param asset The address of the asset the lending vault controls\n    /// @param lendingPool The address of the lending pool\n    function _setLendingPool(\n        address collection,\n        address asset,\n        address lendingPool\n    ) internal {\n        _pools[collection][asset] = lendingPool;\n\n        emit SetLendingPool(collection, asset, lendingPool);\n    }\n\n    /// @notice Create a new lending vault for a certain collection\n    /// @param collection The collection using this lending pool\n    /// @param asset The address of the asset the lending pool controls\n    /// @return The address of the new lending pool\n    function createLendingPool(\n        address collection,\n        address asset\n    ) external returns (address) {\n        require(\n            collection.supportsInterface(type(IERC721Upgradeable).interfaceId),\n            \"LM:CLP:COLLECTION_NOT_NFT\"\n        );\n        require(\n            ITokenOracle(_addressProvider.getTokenOracle()).isTokenSupported(\n                asset\n            ),\n            \"LM:CLP:ASSET_NOT_SUPPORTED_TO\"\n        );\n        require(\n            IInterestRate(_addressProvider.getInterestRate()).isTokenSupported(\n                asset\n            ),\n            \"LM:CLP:ASSET_NOT_SUPPORTED_IR\"\n        );\n        require(\n            _pools[collection][asset] == address(0),\n            \"LM:CLP:LENDING_POOL_EXISTS\"\n        );\n        ILendingPool newLendingPool = new LendingPool(\n            _addressProvider,\n            owner(),\n            asset,\n            string.concat(\n                \"leNFT \",\n                IERC20MetadataUpgradeable(asset).symbol(),\n                \" Lending #\",\n                Strings.toString(_poolsCount[asset])\n            ),\n            string.concat(\n                \"leL\",\n                IERC20MetadataUpgradeable(asset).symbol(),\n                \"-\",\n                Strings.toString(_poolsCount[asset])\n            ),\n            _defaultLendingPoolConfig\n        );\n\n        // Approve lending pool use of market balance (to receive funds from claimed liquidations)\n        IERC20Upgradeable(asset).approve(address(newLendingPool), 2 ** 256 - 1);\n\n        _setLendingPool(collection, asset, address(newLendingPool));\n        _poolsCount[asset] += 1;\n\n        emit CreateLendingPool(address(newLendingPool));\n\n        return address(newLendingPool);\n    }\n\n    /// @notice Get the Lending Pool address responsible to a certain asset\n    /// @param collection The collection supported by the Lending Pool\n    /// @param asset The asset supported by the Lending Pool\n    /// @return The address of the Lending Pool\n    function getLendingPool(\n        address collection,\n        address asset\n    ) external view override returns (address) {\n        return _pools[collection][asset];\n    }\n\n    /// @notice Sets the lending pool addresses for a given collection, asset, and lending pool\n    /// @dev To be used when migrating an asset's lending pool\n    /// @param collection The collection address\n    /// @param asset The asset address\n    /// @param pool The lending pool address\n    function setLendingPool(\n        address collection,\n        address asset,\n        address pool\n    ) external onlyOwner {\n        require(\n            pool.supportsInterface(type(ILendingPool).interfaceId) ||\n                pool == address(0),\n            \"LM:SLP:NOT_POOL\"\n        );\n\n        // If setting the pool to an existing pool, make sure it's the asset is the expected one\n        if (pool != address(0)) {\n            require(\n                IERC4626Upgradeable(pool).asset() == asset,\n                \"LM:SLP:ASSET_MISMATCH\"\n            );\n        }\n        _setLendingPool(collection, asset, pool);\n    }\n\n    /// @notice Sets the default pool configuration\n    /// @param poolConfig The new pool configuration\n    function setDefaultPoolConfig(\n        ConfigTypes.LendingPoolConfig memory poolConfig\n    ) external onlyOwner {\n        _defaultLendingPoolConfig = poolConfig;\n    }\n\n    /// @notice Returns the default pool configuration\n    /// @return The default pool configuration\n    function getDefaultPoolConfig()\n        external\n        view\n        returns (ConfigTypes.LendingPoolConfig memory)\n    {\n        return _defaultLendingPoolConfig;\n    }\n\n    /// @notice Sets the TVL safeguard value\n    /// @param tvlSafeguard The new TVL safeguard value\n    function setTVLSafeguard(uint256 tvlSafeguard) external onlyOwner {\n        _tvlSafeguard = tvlSafeguard;\n    }\n\n    /// @notice Returns the current TVL safeguard value\n    /// @return The current TVL safeguard value\n    function getTVLSafeguard() external view returns (uint256) {\n        return _tvlSafeguard;\n    }\n}"
    }
  ]
}