{
  "Title": "[H-33] `BaseV2Minter` DAO reward shares are calculated wrong",
  "Content": "\nIn `BaseV2Minter`, when calculating the DAO shares out of the weekly emissions, the current implementation wrongly takes into consideration the extra `bHERMES` growth tokens (to the locked); thus, is allocating a larger value than intended. This also has an indirect effect on the increasing protocol inflation if `HERMES` [needs to be minted in order to reach the required token amount](https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L138-L141).\n\n### Issue details\n\nToken DAO shares (`share` variable) is calculated in `BaseV2Minter::updatePeriod` as such:\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L133-L137>\n\n```Solidity\n    uint256 _growth = calculateGrowth(newWeeklyEmission);\n    uint256 _required = _growth + newWeeklyEmission;\n    /// @dev share of newWeeklyEmission emissions sent to DAO.\n    uint256 share = (_required * daoShare) / base;\n    _required += share;\n```\n\nWe actually do see that the original developer intention (confirmed by the sponsor) was that the share value to be calculated is relative to `newWeeklyEmission`, not to (`_required = newWeeklyEmission + _growth`).\n\n```Solidity\n    /// @dev share of newWeeklyEmission emissions sent to DAO.\n```\n\nAlso, it is [documented that DAO shares should be calculated as part of weekly emissions](https://v2-docs.maiadao.io/protocols/Hermes/overview/tokenomics/emissions#dao-emissions):\n\n> Up to 30% of weekly emissions can be allocated to the DAO.\n\n### Proof of Concept\n\nDAO shares value is not calculated relative to `newWeeklyEmission`.\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L134-L136>\n\n### Recommended Mitigation Steps\n\nChange the implementation to reflect intention.\n\n```diff\ndiff --git a/src/hermes/minters/BaseV2Minter.sol b/src/hermes/minters/BaseV2Minter.sol\nindex 7d7f013..217a028 100644\n--- a/src/hermes/minters/BaseV2Minter.sol\n+++ b/src/hermes/minters/BaseV2Minter.sol\n@@ -133,7 +133,7 @@ contract BaseV2Minter is Ownable, IBaseV2Minter {\n             uint256 _growth = calculateGrowth(newWeeklyEmission);\n             uint256 _required = _growth + newWeeklyEmission;\n             /// @dev share of newWeeklyEmission emissions sent to DAO.\n-            uint256 share = (_required * daoShare) / base;\n+            uint256 share = (newWeeklyEmission * daoShare) / base;\n             _required += share;\n             uint256 _balanceOf = underlying.balanceOf(address(this));\n             if (_balanceOf < _required) {\n\n```\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/104#issuecomment-1631529080)**\n\n**[alexxander (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/104#issuecomment-1653408447):**\n > Even though the share is bigger than what it is supposed to be, the extra funds are given to the DAO. There is no clear High impact here, please consider Medium severity.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/104#issuecomment-1653438430):**\n > Assuming the bug goes unnoticed for some period of time, which is fair, this would cause inflation and decrease value for holders. Therefore, high is justified.\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/104#issuecomment-1709946302):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/104-737).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/hermes/minters/BaseV2Minter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {HERMES} from \"@hermes/tokens/HERMES.sol\";\n\nimport {FlywheelGaugeRewards} from \"@rewards/rewards/FlywheelGaugeRewards.sol\";\n\nimport {IBaseV2Minter} from \"../interfaces/IBaseV2Minter.sol\";\n\n/// @title Base V2 Minter - Mints HERMES tokens for the B(3,3) system\ncontract BaseV2Minter is Ownable, IBaseV2Minter {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                         MINTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev allows minting once per week (reset every Thursday 00:00 UTC)\n    uint256 internal constant week = 86400 * 7;\n    /// @dev 2% per week target emission\n    uint256 internal constant base = 1000;\n\n    uint256 internal constant max_tail_emission = 100;\n    uint256 internal constant max_dao_share = 300;\n\n    /// @inheritdoc IBaseV2Minter\n    address public immutable override underlying;\n    /// @inheritdoc IBaseV2Minter\n    ERC4626 public immutable override vault;\n\n    /// @inheritdoc IBaseV2Minter\n    FlywheelGaugeRewards public override flywheelGaugeRewards;\n    /// @inheritdoc IBaseV2Minter\n    address public override dao;\n\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override daoShare = 100;\n    uint256 public override tailEmission = 20;\n    /// @inheritdoc IBaseV2Minter\n\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override weekly;\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override activePeriod;\n\n    address internal initializer;\n\n    constructor(\n        address _vault, // the B(3,3) system that will be locked into\n        address _dao,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        initializer = msg.sender;\n        dao = _dao;\n        underlying = address(ERC4626(_vault).asset());\n        vault = ERC4626(_vault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         FALLBACK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    fallback() external {\n        updatePeriod();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function initialize(FlywheelGaugeRewards _flywheelGaugeRewards) external {\n        if (initializer != msg.sender) revert NotInitializer();\n        flywheelGaugeRewards = _flywheelGaugeRewards;\n        initializer = address(0);\n        activePeriod = (block.timestamp / week) * week;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setDao(address _dao) external onlyOwner {\n        /// @dev DAO can be set to address(0) to disable DAO rewards.\n        dao = _dao;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setDaoShare(uint256 _daoShare) external onlyOwner {\n        if (_daoShare > max_dao_share) revert DaoShareTooHigh();\n        daoShare = _daoShare;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setTailEmission(uint256 _tail_emission) external onlyOwner {\n        if (_tail_emission > max_tail_emission) revert TailEmissionTooHigh();\n        tailEmission = _tail_emission;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         EMISSION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function circulatingSupply() public view returns (uint256) {\n        return HERMES(underlying).totalSupply() - vault.totalAssets();\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function weeklyEmission() public view returns (uint256) {\n        return (circulatingSupply() * tailEmission) / base;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function calculateGrowth(uint256 _minted) public view returns (uint256) {\n        return (vault.totalAssets() * _minted) / HERMES(underlying).totalSupply();\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function updatePeriod() public returns (uint256) {\n        uint256 _period = activePeriod;\n        // only trigger if new week\n        if (block.timestamp >= _period + week && initializer == address(0)) {\n            _period = (block.timestamp / week) * week;\n            activePeriod = _period;\n            uint256 newWeeklyEmission = weeklyEmission();\n            weekly += newWeeklyEmission;\n            uint256 _circulatingSupply = circulatingSupply();\n\n            uint256 _growth = calculateGrowth(newWeeklyEmission);\n            uint256 _required = _growth + newWeeklyEmission;\n            /// @dev share of newWeeklyEmission emissions sent to DAO.\n            uint256 share = (_required * daoShare) / base;\n            _required += share;\n            uint256 _balanceOf = underlying.balanceOf(address(this));\n            if (_balanceOf < _required) {\n                HERMES(underlying).mint(address(this), _required - _balanceOf);\n            }\n\n            underlying.safeTransfer(address(vault), _growth);\n\n            if (dao != address(0)) underlying.safeTransfer(dao, share);\n\n            emit Mint(msg.sender, newWeeklyEmission, _circulatingSupply, _growth, share);\n\n            /// @dev queue rewards for the cycle, anyone can call if fails\n            ///      queueRewardsForCycle will call this function but won't enter\n            ///      here because activePeriod was updated\n            try flywheelGaugeRewards.queueRewardsForCycle() {} catch {}\n        }\n        return _period;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         REWARDS STREAM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function getRewards() external returns (uint256 totalQueuedForCycle) {\n        if (address(flywheelGaugeRewards) != msg.sender) revert NotFlywheelGaugeRewards();\n        totalQueuedForCycle = weekly;\n        weekly = 0;\n        underlying.safeTransfer(msg.sender, totalQueuedForCycle);\n    }\n}"
    },
    {
      "filename": "src/hermes/minters/BaseV2Minter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {HERMES} from \"@hermes/tokens/HERMES.sol\";\n\nimport {FlywheelGaugeRewards} from \"@rewards/rewards/FlywheelGaugeRewards.sol\";\n\nimport {IBaseV2Minter} from \"../interfaces/IBaseV2Minter.sol\";\n\n/// @title Base V2 Minter - Mints HERMES tokens for the B(3,3) system\ncontract BaseV2Minter is Ownable, IBaseV2Minter {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                         MINTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev allows minting once per week (reset every Thursday 00:00 UTC)\n    uint256 internal constant week = 86400 * 7;\n    /// @dev 2% per week target emission\n    uint256 internal constant base = 1000;\n\n    uint256 internal constant max_tail_emission = 100;\n    uint256 internal constant max_dao_share = 300;\n\n    /// @inheritdoc IBaseV2Minter\n    address public immutable override underlying;\n    /// @inheritdoc IBaseV2Minter\n    ERC4626 public immutable override vault;\n\n    /// @inheritdoc IBaseV2Minter\n    FlywheelGaugeRewards public override flywheelGaugeRewards;\n    /// @inheritdoc IBaseV2Minter\n    address public override dao;\n\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override daoShare = 100;\n    uint256 public override tailEmission = 20;\n    /// @inheritdoc IBaseV2Minter\n\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override weekly;\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override activePeriod;\n\n    address internal initializer;\n\n    constructor(\n        address _vault, // the B(3,3) system that will be locked into\n        address _dao,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        initializer = msg.sender;\n        dao = _dao;\n        underlying = address(ERC4626(_vault).asset());\n        vault = ERC4626(_vault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         FALLBACK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    fallback() external {\n        updatePeriod();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function initialize(FlywheelGaugeRewards _flywheelGaugeRewards) external {\n        if (initializer != msg.sender) revert NotInitializer();\n        flywheelGaugeRewards = _flywheelGaugeRewards;\n        initializer = address(0);\n        activePeriod = (block.timestamp / week) * week;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setDao(address _dao) external onlyOwner {\n        /// @dev DAO can be set to address(0) to disable DAO rewards.\n        dao = _dao;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setDaoShare(uint256 _daoShare) external onlyOwner {\n        if (_daoShare > max_dao_share) revert DaoShareTooHigh();\n        daoShare = _daoShare;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setTailEmission(uint256 _tail_emission) external onlyOwner {\n        if (_tail_emission > max_tail_emission) revert TailEmissionTooHigh();\n        tailEmission = _tail_emission;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         EMISSION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function circulatingSupply() public view returns (uint256) {\n        return HERMES(underlying).totalSupply() - vault.totalAssets();\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function weeklyEmission() public view returns (uint256) {\n        return (circulatingSupply() * tailEmission) / base;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function calculateGrowth(uint256 _minted) public view returns (uint256) {\n        return (vault.totalAssets() * _minted) / HERMES(underlying).totalSupply();\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function updatePeriod() public returns (uint256) {\n        uint256 _period = activePeriod;\n        // only trigger if new week\n        if (block.timestamp >= _period + week && initializer == address(0)) {\n            _period = (block.timestamp / week) * week;\n            activePeriod = _period;\n            uint256 newWeeklyEmission = weeklyEmission();\n            weekly += newWeeklyEmission;\n            uint256 _circulatingSupply = circulatingSupply();\n\n            uint256 _growth = calculateGrowth(newWeeklyEmission);\n            uint256 _required = _growth + newWeeklyEmission;\n            /// @dev share of newWeeklyEmission emissions sent to DAO.\n            uint256 share = (_required * daoShare) / base;\n            _required += share;\n            uint256 _balanceOf = underlying.balanceOf(address(this));\n            if (_balanceOf < _required) {\n                HERMES(underlying).mint(address(this), _required - _balanceOf);\n            }\n\n            underlying.safeTransfer(address(vault), _growth);\n\n            if (dao != address(0)) underlying.safeTransfer(dao, share);\n\n            emit Mint(msg.sender, newWeeklyEmission, _circulatingSupply, _growth, share);\n\n            /// @dev queue rewards for the cycle, anyone can call if fails\n            ///      queueRewardsForCycle will call this function but won't enter\n            ///      here because activePeriod was updated\n            try flywheelGaugeRewards.queueRewardsForCycle() {} catch {}\n        }\n        return _period;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         REWARDS STREAM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function getRewards() external returns (uint256 totalQueuedForCycle) {\n        if (address(flywheelGaugeRewards) != msg.sender) revert NotFlywheelGaugeRewards();\n        totalQueuedForCycle = weekly;\n        weekly = 0;\n        underlying.safeTransfer(msg.sender, totalQueuedForCycle);\n    }\n}"
    },
    {
      "filename": "src/hermes/minters/BaseV2Minter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {HERMES} from \"@hermes/tokens/HERMES.sol\";\n\nimport {FlywheelGaugeRewards} from \"@rewards/rewards/FlywheelGaugeRewards.sol\";\n\nimport {IBaseV2Minter} from \"../interfaces/IBaseV2Minter.sol\";\n\n/// @title Base V2 Minter - Mints HERMES tokens for the B(3,3) system\ncontract BaseV2Minter is Ownable, IBaseV2Minter {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                         MINTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev allows minting once per week (reset every Thursday 00:00 UTC)\n    uint256 internal constant week = 86400 * 7;\n    /// @dev 2% per week target emission\n    uint256 internal constant base = 1000;\n\n    uint256 internal constant max_tail_emission = 100;\n    uint256 internal constant max_dao_share = 300;\n\n    /// @inheritdoc IBaseV2Minter\n    address public immutable override underlying;\n    /// @inheritdoc IBaseV2Minter\n    ERC4626 public immutable override vault;\n\n    /// @inheritdoc IBaseV2Minter\n    FlywheelGaugeRewards public override flywheelGaugeRewards;\n    /// @inheritdoc IBaseV2Minter\n    address public override dao;\n\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override daoShare = 100;\n    uint256 public override tailEmission = 20;\n    /// @inheritdoc IBaseV2Minter\n\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override weekly;\n    /// @inheritdoc IBaseV2Minter\n    uint256 public override activePeriod;\n\n    address internal initializer;\n\n    constructor(\n        address _vault, // the B(3,3) system that will be locked into\n        address _dao,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        initializer = msg.sender;\n        dao = _dao;\n        underlying = address(ERC4626(_vault).asset());\n        vault = ERC4626(_vault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         FALLBACK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    fallback() external {\n        updatePeriod();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function initialize(FlywheelGaugeRewards _flywheelGaugeRewards) external {\n        if (initializer != msg.sender) revert NotInitializer();\n        flywheelGaugeRewards = _flywheelGaugeRewards;\n        initializer = address(0);\n        activePeriod = (block.timestamp / week) * week;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setDao(address _dao) external onlyOwner {\n        /// @dev DAO can be set to address(0) to disable DAO rewards.\n        dao = _dao;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setDaoShare(uint256 _daoShare) external onlyOwner {\n        if (_daoShare > max_dao_share) revert DaoShareTooHigh();\n        daoShare = _daoShare;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function setTailEmission(uint256 _tail_emission) external onlyOwner {\n        if (_tail_emission > max_tail_emission) revert TailEmissionTooHigh();\n        tailEmission = _tail_emission;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         EMISSION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function circulatingSupply() public view returns (uint256) {\n        return HERMES(underlying).totalSupply() - vault.totalAssets();\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function weeklyEmission() public view returns (uint256) {\n        return (circulatingSupply() * tailEmission) / base;\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function calculateGrowth(uint256 _minted) public view returns (uint256) {\n        return (vault.totalAssets() * _minted) / HERMES(underlying).totalSupply();\n    }\n\n    /// @inheritdoc IBaseV2Minter\n    function updatePeriod() public returns (uint256) {\n        uint256 _period = activePeriod;\n        // only trigger if new week\n        if (block.timestamp >= _period + week && initializer == address(0)) {\n            _period = (block.timestamp / week) * week;\n            activePeriod = _period;\n            uint256 newWeeklyEmission = weeklyEmission();\n            weekly += newWeeklyEmission;\n            uint256 _circulatingSupply = circulatingSupply();\n\n            uint256 _growth = calculateGrowth(newWeeklyEmission);\n            uint256 _required = _growth + newWeeklyEmission;\n            /// @dev share of newWeeklyEmission emissions sent to DAO.\n            uint256 share = (_required * daoShare) / base;\n            _required += share;\n            uint256 _balanceOf = underlying.balanceOf(address(this));\n            if (_balanceOf < _required) {\n                HERMES(underlying).mint(address(this), _required - _balanceOf);\n            }\n\n            underlying.safeTransfer(address(vault), _growth);\n\n            if (dao != address(0)) underlying.safeTransfer(dao, share);\n\n            emit Mint(msg.sender, newWeeklyEmission, _circulatingSupply, _growth, share);\n\n            /// @dev queue rewards for the cycle, anyone can call if fails\n            ///      queueRewardsForCycle will call this function but won't enter\n            ///      here because activePeriod was updated\n            try flywheelGaugeRewards.queueRewardsForCycle() {} catch {}\n        }\n        return _period;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         REWARDS STREAM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2Minter\n    function getRewards() external returns (uint256 totalQueuedForCycle) {\n        if (address(flywheelGaugeRewards) != msg.sender) revert NotFlywheelGaugeRewards();\n        totalQueuedForCycle = weekly;\n        weekly = 0;\n        underlying.safeTransfer(msg.sender, totalQueuedForCycle);\n    }\n}"
    }
  ]
}