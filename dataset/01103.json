{
  "Title": "Unnecessary fee structuring",
  "Content": "During the collateral swap [the flash loan fee is first subtracted from the flash loan amount](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/libraries/LibCollateralSwap.sol#L56) which is then deposited into Comet. This is to ensure that the protocol has enough to pay the flash loan fee. But the swap process itself also relies on the user to pick a large enough amount to withdraw so as to cover the flash loan amount with a token swap. Since the contract checks for the required amount to be repaid, removing the fee first only adds to the complexity of the calculation with which the user has to decide the withdrawal amount. This could be a difficult task given the process involves unpredictable market exchange rate and slippage caused by available liquidity between the two swapping collaterals.\n\n\nConsider removing the fee deduction to use the full flash loan for the Comet collateral deposit. Further consider offering helper functions to assist with the calculation of the appropriate final collateral amount.\n\n\n***Update**: Acknowledged, not resolved. The Wido team stated:*\n\n\n\n> *We have an off-chain SDK to assist with the calculation.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/compound/libraries/LibCollateralSwap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IComet} from \"../interfaces/IComet.sol\";\n\nlibrary LibCollateralSwap {\n    using SafeMath for uint256;\n\n    error WidoRouterFailed();\n\n    struct Collateral {\n        address addr;\n        uint256 amount;\n    }\n\n    struct Signatures {\n        Signature allow;\n        Signature revoke;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct WidoSwap {\n        address router;\n        address tokenManager;\n        bytes callData;\n    }\n\n    /// @dev Performs all the steps to swap collaterals on the Comet contract\n    function performCollateralSwap(\n        address borrowedAsset,\n        uint256 borrowedAmount,\n        uint256 fee,\n        bytes memory data\n    ) external {\n        // decode payload\n        (\n        address user,\n        IComet comet,\n        Collateral memory existingCollateral,\n        Signatures memory signatures,\n        WidoSwap memory swapDetails\n        ) = abi.decode(\n            data,\n            (address, IComet, Collateral, Signatures, WidoSwap)\n        );\n\n        // supply new collateral on behalf of user\n        _supplyTo(comet, user, borrowedAsset, borrowedAmount.sub(fee));\n\n        // withdraw existing collateral\n        _withdrawFrom(comet, user, existingCollateral, signatures);\n\n        // execute swap\n        _swap(existingCollateral, swapDetails);\n\n        // check amount of surplus collateral\n        uint256 surplusAmount = IERC20(borrowedAsset).balanceOf(address(this)) - borrowedAmount - fee;\n\n        // if positive slippage, supply extra to user\n        if (surplusAmount > 0) {\n            _supplyTo(comet, user, borrowedAsset, surplusAmount);\n        }\n    }\n\n    /// @dev Performs the swap of the collateral on the WidoRouter\n    function _swap(\n        Collateral memory collateral,\n        WidoSwap memory swap\n    ) internal {\n        // approve WidoTokenManager initial collateral to make the swap\n        IERC20(collateral.addr).approve(\n            swap.tokenManager,\n            collateral.amount\n        );\n\n        // execute swap\n        (bool success, bytes memory result) = swap.router.call(swap.callData);\n\n        if (!success) {\n            if (result.length < 68) revert WidoRouterFailed();\n            assembly {\n                result := add(result, 0x04)\n            }\n            revert(abi.decode(result, (string)));\n        }\n    }\n\n    /// @dev Supplies collateral on behalf of user\n    function _supplyTo(\n        IComet comet,\n        address user,\n        address asset,\n        uint256 amount\n    ) internal {\n        IERC20(asset).approve(address(comet), amount);\n        comet.supplyTo(user, asset, amount);\n    }\n\n    /// @dev This function withdraws the collateral from the user.\n    ///  It requires two consecutive EIP712 signatures to allow and revoke\n    ///  permissions to and from this contract.\n    function _withdrawFrom(\n        IComet comet,\n        address user,\n        Collateral memory collateral,\n        Signatures memory sigs\n    ) internal {\n        // get current nonce\n        uint256 nonce = comet.userNonce(user);\n        // allow the contract\n        _allowBySig(comet, user, true, nonce, sigs.allow);\n        // withdraw assets\n        comet.withdrawFrom(user, address(this), collateral.addr, collateral.amount);\n        // increment nonce\n        unchecked { nonce++; }\n        // revoke permission\n        _allowBySig(comet, user, false, nonce, sigs.revoke);\n    }\n\n    /// @dev Executes a single `allowBySig` operation on the Comet contract\n    function _allowBySig(\n        IComet comet,\n        address user,\n        bool allowed,\n        uint256 nonce,\n        Signature memory sig\n    ) internal {\n        comet.allowBySig(\n            user,\n            address(this),\n            allowed,\n            nonce,\n            10e9,\n            sig.v,\n            sig.r,\n            sig.s\n        );\n    }\n\n}"
    }
  ]
}