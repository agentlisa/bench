{
  "Title": "[M-02] DEPOSITOR_ROLE can be granted by the deployer of `BribeVault` and transfer briber's approved ERC20 tokens to `bribeVault` by specifying any `bribeIdentifier` and `rewardIdentifier`",
  "Content": "_Submitted by cccz_\n\nIn the depositBribeERC20() function of the TokemakBribe contract, the briber can specify a proposal, and then call the depositBribeERC20 function of the bribeVault contract to deposit the reward.\n\n        function depositBribeERC20(\n            address proposal,\n            address token,\n            uint256 amount\n        ) external {\n            uint256 currentRound = _round;\n            require(\n                proposalDeadlines[proposal] > block.timestamp,\n                \"Proposal deadline has passed\"\n            );\n            require(token != address(0), \"Invalid token\");\n            require(amount > 0, \"Bribe amount must be greater than 0\");\n\n            bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n                proposal,\n                currentRound,\n                token\n            );\n            bytes32 rewardIdentifier = generateRewardIdentifier(\n                currentRound,\n                token\n            );\n\n            IBribeVault(bribeVault).depositBribeERC20(\n                bribeIdentifier,\n                rewardIdentifier,\n                token,\n                amount,\n                msg.sender\n            );\n\nBut in the depositBribeERC20 function of the bribeVault contract, the address with DEPOSITOR_ROLE can transfer the briber's approved ERC20 tokens to bribeVault by specifying any bribeIdentifier and rewardIdentifier via safeTransferFrom.\n\n        function depositBribeERC20(\n            bytes32 bribeIdentifier,\n            bytes32 rewardIdentifier,\n            address token,\n            uint256 amount,\n            address briber\n        ) external onlyRole(DEPOSITOR_ROLE) {\n            require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n            require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n            require(token != address(0), \"Invalid token\");\n            require(amount > 0, \"Amount must be greater than 0\");\n            require(briber != address(0), \"Invalid briber\");\n\n            Bribe storage b = bribes[bribeIdentifier];\n            address currentToken = b.token;\n            require(\n                // If bribers want to bribe with a different token they need a new identifier\n                currentToken == address(0) || currentToken == token,\n                \"Cannot change token\"\n            );\n\n            // Since this method is called by a depositor contract, we must transfer from the account\n            // that called the depositor contract - amount must be approved beforehand\n            IERC20(token).safeTransferFrom(briber, address(this), amount);\n\nDEPOSITOR_ROLE can be granted by the deployer of BribeVault.\n\n```\n\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n```\n\n### Proof of Concept\n\n[BribeVault.sol#L164-L205](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164-L205)\n\n### Recommended Mitigation Steps\n\nThe depositBribeERC20 function of the TokemakBribe contract needs to first transfer the briber's tokens to the TokemakBribe contract, and then transfer the tokens to the bribeVault contract in the depositBribeERC20 function of the bribeVault contract. Make sure the first parameter of safeTransferFrom is msg.sender.\n\nTokemakBribe.depositBribeERC20()\n\n        function depositBribeERC20(\n            address proposal,\n            address token,\n            uint256 amount\n        ) external {\n            uint256 currentRound = _round;\n            require(\n                proposalDeadlines[proposal] > block.timestamp,\n                \"Proposal deadline has passed\"\n            );\n            require(token != address(0), \"Invalid token\");\n            require(amount > 0, \"Bribe amount must be greater than 0\");\n\n            bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n                proposal,\n                currentRound,\n                token\n            );\n            bytes32 rewardIdentifier = generateRewardIdentifier(\n                currentRound,\n                token\n            );\n    +       IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n            IBribeVault(bribeVault).depositBribeERC20(\n                bribeIdentifier,\n                rewardIdentifier,\n                token,\n                amount,\n                msg.sender\n            );\n\nbribeVault.depositBribeERC20()\n\n```\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n-       IERC20(token).safeTransferFrom(briber, address(this), amount);\n+\tIERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n```\n\n**[kphed (Redacted Cartel) disputed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/1#issuecomment-1040452376):**\n > This isn't a concern since the \"depositor\" role can only be granted by admin (protocol multisig) - depositors will only be bribe contracts that we've written and deployed.\n>\n> In the future, we may grant the depositor role to contracts that are written and deployed by 3rd parties, but they would all be thoroughly vetted in some manner and need to conform to the BribeVault's interface. \n>\n> Thanks again for participating in our contest cccz, looking forward to more feedback/suggestions/comments.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/1#issuecomment-1059778323):**\n > While this may not be a concern for the sponsor, the smart contract is supposed to be given allowance, this allowance can then be used by the `DEPOSITOR_ROLE` to perform a transfer.\n> \n> The smart can then allow the `DEFAULT_ADMIN_ROLE` to withdraw the funds.\n> \n> Ultimately the ability to deposit being permissioned and it's ability to pull unlimited funds is a strong admin privilege, which I'd recommend the sponsor to remove.\n> \n> A similar deposit flow with less strict permissions can be found in most Yield Farming Vaults, see Badger Vaults for example: [Badger-Finance/Vault.sol#L671](https://github.com/Badger-Finance/badger-sett-1.5/blob/86a586cf30b806dc1ab7ea090f002e06a59d0706/contracts/Vault.sol#L671).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-redacted-cartel-contest",
  "Code": [
    {
      "filename": "contracts/BribeVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}"
    },
    {
      "filename": "contracts/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/SettAccessControl.sol\";\n\nimport {IVault} from \"../interfaces/badger/IVault.sol\";\nimport {IStrategy} from \"../interfaces/badger/IStrategy.sol\";\nimport {IERC20Detailed} from \"../interfaces/erc20/IERC20Detailed.sol\";\nimport {BadgerGuestListAPI} from \"../interfaces/yearn/BadgerGuestlistApi.sol\";\n\n/*\n    Source: https://github.com/iearn-finance/yearn-protocol/blob/develop/contracts/vaults/yVault.sol\n    \n    Changelog:\n\n    V1.1\n    * Strategist no longer has special function calling permissions\n    * Version function added to contract\n    * All write functions, with the exception of transfer, are pausable\n    * Keeper or governance can pause\n    * Only governance can unpause\n\n    V1.2\n    * Transfer functions are now pausable along with all other non-permissioned write functions\n    * All permissioned write functions, with the exception of pause() & unpause(), are pausable as well\n\n    V1.3\n    * Add guest list functionality\n    * All deposits can be optionally gated by external guestList approval logic on set guestList contract\n\n    V1.4\n    * Add depositFor() to deposit on the half of other users. That user will then be blockLocked.\n\n    V1.5\n    * Removed Controller\n        - Removed harvest from vault (only on strategy)\n    * Params added to track autocompounded rewards (lifeTimeEarned, lastHarvestedAt, lastHarvestAmount, assetsAtLastHarvest)\n      this would work in sync with autoCompoundRatio to help us track harvests better.\n    * Fees\n        - Strategy would report the autocompounded harvest amount to the vault\n        - Calculation performanceFeeGovernance, performanceFeeStrategist, withdrawalFee, managementFee moved to the vault.\n        - Vault mints shares for performanceFees and managementFee to the respective recipient (treasury, strategist)\n        - withdrawal fees is transferred to the rewards address set\n    * Permission:\n        - Strategist can now set performance, withdrawal and management fees\n        - Governance will determine maxPerformanceFee, maxWithdrawalFee, maxManagementFee that can be set to prevent rug of funds.\n    * Strategy would take the actors from the vault it is connected to\n    * All governance related fees goes to treasury\n*/\n\ncontract Vault is ERC20Upgradeable, SettAccessControl, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using SafeMathUpgradeable for uint256;\n\n    uint256 constant ONE_ETH = 1e18;\n\n    /// ===== Storage Variables ====\n\n    IERC20Upgradeable public token; // Token used for deposits\n    BadgerGuestListAPI public guestList; // guestlist when vault is in experiment/ guarded state\n\n    bool public pausedDeposit; // false by default Allows to only block deposits, use pause for the normal pause state\n\n    address public strategy; // address of the strategy connected to the vault\n    address public guardian; // guardian of vault and strategy\n    address public treasury; // set by governance ... any fees go there\n\n    address public badgerTree; // Address we send tokens too via reportAdditionalTokens\n\n    /// @dev name and symbol prefixes for lpcomponent token of vault\n    string internal constant _defaultNamePrefix = \"Badger Sett \";\n    string internal constant _symbolSymbolPrefix = \"b\";\n\n    /// Params to track autocompounded rewards\n    uint256 public lifeTimeEarned; // keeps track of total earnings\n    uint256 public lastHarvestedAt; // timestamp of the last harvest\n    uint256 public lastHarvestAmount; // amount harvested during last harvest\n    uint256 public assetsAtLastHarvest; // assets for which the harvest took place.\n\n    mapping (address => uint256) public additionalTokensEarned;\n    mapping (address => uint256) public lastAdditionalTokenAmount;\n\n    /// Fees ///\n    /// @notice all fees will be in bps\n    uint256 public performanceFeeGovernance; // Perf fee sent to `treasury`\n    uint256 public performanceFeeStrategist; // Perf fee sent to `strategist`\n    uint256 public withdrawalFee; // fee issued to `treasury` on withdrawal \n    uint256 public managementFee; // fee issued to `treasury` on report (typically on harvest, but only if strat is autocompounding)\n\n    uint256 public maxPerformanceFee; // maximum allowed performance fees\n    uint256 public maxWithdrawalFee; // maximum allowed withdrawal fees\n    uint256 public maxManagementFee; // maximum allowed management fees\n\n    uint256 public toEarnBps; // NOTE: in BPS, minimum amount of token to deposit into strategy when earn is called\n\n    /// ===== Constants ====\n\n    uint256 public constant MAX_BPS = 10_000;\n    uint256 public constant SECS_PER_YEAR = 31_556_952; // 365.2425 days\n\n    uint256 public constant WITHDRAWAL_FEE_HARD_CAP = 200; // Never higher than 2%\n    uint256 public constant PERFORMANCE_FEE_HARD_CAP = 3_000; // Never higher than 30% // 30% maximum performance fee // We usually do 20, so this is insanely high already\n    uint256 public constant MANAGEMENT_FEE_HARD_CAP = 200; // Never higher than 2%\n\n    /// ===== Events ====\n\n    // Emitted when a token is sent to the badgerTree for emissions\n    event TreeDistribution(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    // Emitted during a report, when there has been an increase in pricePerFullShare (ppfs)\n    event Harvested(address indexed token, uint256 amount, uint256 indexed blockNumber, uint256 timestamp);\n\n    event SetTreasury(address indexed newTreasury);\n    event SetStrategy(address indexed newStrategy);\n    event SetToEarnBps(uint256 newEarnToBps);\n    event SetMaxWithdrawalFee(uint256 newMaxWithdrawalFee);\n    event SetMaxPerformanceFee(uint256 newMaxPerformanceFee);\n    event SetMaxManagementFee(uint256 newMaxManagementFee);\n    event SetGuardian(address indexed newGuardian);\n    event SetGuestList(address indexed newGuestList);\n    event SetWithdrawalFee(uint256 newWithdrawalFee);\n    event SetPerformanceFeeStrategist(uint256 newPerformanceFeeStrategist);\n    event SetPerformanceFeeGovernance(uint256 newPerformanceFeeGovernance);\n    event SetManagementFee(uint256 newManagementFee);\n\n    event PauseDeposits(address indexed pausedBy);\n    event UnpauseDeposits(address indexed pausedBy);\n\n    /// @notice Initializes the Sett. Can only be called once, ideally when the contract is deployed.\n    /// @param _token Address of the token that can be deposited into the sett.\n    /// @param _governance Address authorized as governance.\n    /// @param _keeper Address authorized as keeper.\n    /// @param _guardian Address authorized as guardian.\n    /// @param _treasury Address to distribute governance fees/rewards to.\n    /// @param _strategist Address authorized as strategist.\n    /// @param _badgerTree Address of badgerTree used for emissions.\n    /// @param _name Specify a custom sett name. Leave empty for default value.\n    /// @param _symbol Specify a custom sett symbol. Leave empty for default value.\n    /// @param _feeConfig Values for the 4 different types of fees charges by the sett\n    ///         [performanceFeeGovernance, performanceFeeStrategist, withdrawToVault, managementFee]\n    ///         Each fee should be less than the constant hard-caps defined above. \n    function initialize(\n        address _token,\n        address _governance,\n        address _keeper,\n        address _guardian,\n        address _treasury,\n        address _strategist,\n        address _badgerTree,\n        string memory _name,\n        string memory _symbol,\n        uint256[4] memory _feeConfig\n    ) public initializer whenNotPaused {\n        require(_token != address(0)); // dev: _token address should not be zero\n        require(_governance != address(0)); // dev: _governance address should not be zero\n        require(_keeper != address(0)); // dev: _keeper address should not be zero\n        require(_guardian != address(0)); // dev: _guardian address should not be zero\n        require(_treasury != address(0)); // dev: _treasury address should not be zero\n        require(_strategist != address(0)); // dev: _strategist address should not be zero\n        require(_badgerTree != address(0)); // dev: _badgerTree address should not be zero\n\n        // Check for fees being reasonable (see below for interpretation)\n        require(_feeConfig[0] <= PERFORMANCE_FEE_HARD_CAP, \"performanceFeeGovernance too high\");\n        require(_feeConfig[1] <= PERFORMANCE_FEE_HARD_CAP, \"performanceFeeStrategist too high\");\n        require(_feeConfig[2] <= WITHDRAWAL_FEE_HARD_CAP, \"withdrawalFee too high\");\n        require(_feeConfig[3] <= MANAGEMENT_FEE_HARD_CAP, \"managementFee too high\");\n\n        string memory name;\n        string memory symbol;\n\n\n        // If they are non empty string we'll use the custom names\n        // Else just add the default prefix\n        IERC20Detailed namedToken = IERC20Detailed(_token);\n\n        if(keccak256(abi.encodePacked(_name)) != keccak256(\"\")) {\n            name = _name;\n        } else {\n            name = string(abi.encodePacked(_defaultNamePrefix, namedToken.name()));\n        }\n\n        if (keccak256(abi.encodePacked(_symbol)) != keccak256(\"\")) {\n            symbol = _symbol;\n        } else {\n            symbol = string(abi.encodePacked(_symbolSymbolPrefix, namedToken.symbol()));\n        }\n\n        // Initializing the lpcomponent token\n        __ERC20_init(name, symbol);\n        // Initialize the other contracts\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        token = IERC20Upgradeable(_token);\n        governance = _governance;\n        treasury = _treasury;\n        strategist = _strategist;\n        keeper = _keeper;\n        guardian = _guardian;\n        badgerTree = _badgerTree;\n\n        lastHarvestedAt = block.timestamp; // setting initial value to the time when the vault was deployed\n\n        performanceFeeGovernance = _feeConfig[0];\n        performanceFeeStrategist = _feeConfig[1];\n        withdrawalFee = _feeConfig[2];\n        managementFee = _feeConfig[3];\n        maxPerformanceFee = PERFORMANCE_FEE_HARD_CAP; // 30% max performance fee\n        maxWithdrawalFee = WITHDRAWAL_FEE_HARD_CAP; // 2% maximum withdrawal fee\n        maxManagementFee = MANAGEMENT_FEE_HARD_CAP; // 2% maximum management fee\n\n        toEarnBps = 9_500; // initial value of toEarnBps // 95% is invested to the strategy, 5% for cheap withdrawals\n    }\n\n    /// ===== Modifiers ====\n\n    /// @notice Checks whether a call is from guardian or governance. \n    function _onlyAuthorizedPausers() internal view {\n        require(msg.sender == guardian || msg.sender == governance, \"onlyPausers\");\n    }\n\n    /// @notice Checks whether a call is from the strategy.\n    function _onlyStrategy() internal view {\n        require(msg.sender == strategy, \"onlyStrategy\");\n    }\n\n    /// ===== View Functions =====\n    \n    /// @notice Used to track the deployed version of the contract.\n    /// @return Current version of the contract.\n    function version() external pure returns (string memory) {\n        return \"1.5\";\n    }\n\n    /// @notice Gives the price for a single Sett share.\n    /// @dev Sett starts with a price per share of 1.\n    /// @return Value of a single share.\n    function getPricePerFullShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return ONE_ETH;\n        }\n        return balance().mul(ONE_ETH).div(totalSupply());\n    }\n\n    /// @notice Gives the total balance of the underlying token within the sett and strategy system.\n    /// @return Balance of token handled by the sett.\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this)).add(IStrategy(strategy).balanceOf());\n    }\n\n    /// @notice Defines how much of the Setts' underlying is available for strategy to borrow.\n    /// @return Amount of tokens that the sett can provide to the strategy.\n    function available() public view returns (uint256) {\n        return token.balanceOf(address(this)).mul(toEarnBps).div(MAX_BPS);\n    }\n\n    /// ===== Public Actions =====\n\n    /// @notice Deposits `_amount` tokens, issuing shares. \n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true. \n    /// @dev See `_depositFor` for details on how deposit is implemented. \n    /// @param _amount Quantity of tokens to deposit. \n    function deposit(uint256 _amount) external whenNotPaused {\n        _depositWithAuthorization(_amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares. \n    ///         Checks the guestlist to verify that the calling account is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true. \n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _amount Quantity of tokens to deposit. \n    /// @param proof Merkle proof to validate in the guestlist.\n    function deposit(uint256 _amount, bytes32[] memory proof) external whenNotPaused {\n        _depositWithAuthorization(_amount, proof);\n    }\n\n    /// @notice Deposits all tokens, issuing shares. \n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true. \n    /// @dev See `_depositFor` for details on how deposit is implemented. \n    function depositAll() external whenNotPaused {\n        _depositWithAuthorization(token.balanceOf(msg.sender), new bytes32[](0));\n    }\n\n    /// @notice Deposits all tokens, issuing shares. \n    ///         Checks the guestlist to verify that the calling is authorized to make a full deposit.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true. \n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function depositAll(bytes32[] memory proof) external whenNotPaused {\n        _depositWithAuthorization(token.balanceOf(msg.sender), proof);\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`. \n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true. \n    /// @dev See `_depositFor` for details on how deposit is implemented. \n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit. \n    function depositFor(address _recipient, uint256 _amount) external whenNotPaused {\n        _depositForWithAuthorization(_recipient, _amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`. \n    ///         Checks the guestlist to verify that `recipient` is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true. \n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit. \n    function depositFor(\n        address _recipient,\n        uint256 _amount,\n        bytes32[] memory proof\n    ) external whenNotPaused {\n        _depositForWithAuthorization(_recipient, _amount, proof);\n    }\n\n    /// @notice Redeems `_shares` for an appropriate amount of tokens.\n    ///         Note that withdrawals are not processed when the Sett is paused. \n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    /// @param _shares Quantity of shares to redeem. \n    function withdraw(uint256 _shares) external whenNotPaused {\n        _withdraw(_shares);\n    }\n\n    /// @notice Redeems all shares, issuing an appropriate amount of tokens. \n    ///         Note that withdrawals are not processed when the Sett is paused. \n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    function withdrawAll() external whenNotPaused {\n        _withdraw(balanceOf(msg.sender));\n    }\n\n    /// ===== Permissioned Actions: Strategy =====\n\n    /// @notice Used by the strategy to report a harvest to the sett.\n    ///         Issues shares for the strategist and treasury based on the performance fees and harvested amount. \n    ///         Issues shares for the treasury based on the management fee and the time elapsed since last harvest. \n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This implicitly trusts that the strategy reports the correct amount.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _harvestedAmount Amount of underlying token harvested by the strategy.\n    function reportHarvest(\n        uint256 _harvestedAmount\n    ) external nonReentrant {\n        _onlyStrategy();\n\n        uint256 harvestTime = block.timestamp;\n        uint256 assetsAtHarvest = balance().sub(_harvestedAmount); // Must be less than or equal or revert\n\n        _handleFees(_harvestedAmount, harvestTime);\n\n        // Updated lastHarvestAmount\n        lastHarvestAmount = _harvestedAmount;\n\n        // if we withdrawAll\n        // we will have some yield left\n        // having 0 for assets will inflate APY\n        // Instead, have the last harvest report with the previous assets\n        // And if you end up harvesting again, that report will have both 0s\n        if (assetsAtHarvest != 0) {\n            assetsAtLastHarvest = assetsAtHarvest;\n        } else if (_harvestedAmount == 0) {\n            // If zero\n            assetsAtLastHarvest = 0;\n        }\n\n        lifeTimeEarned = lifeTimeEarned.add(_harvestedAmount);\n        // Update time either way\n        lastHarvestedAt = harvestTime;\n\n        emit Harvested(address(token), _harvestedAmount, block.number, block.timestamp);\n    }\n\n    /// @notice Used by the strategy to report harvest of additional tokens to the sett.\n    ///         Charges performance fees on the additional tokens and transfers fees to treasury and strategist. \n    ///         The remaining amount is sent to badgerTree for emissions.\n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This function is called after the strategy sends the additional tokens to the sett.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _token Address of additional token harvested by the strategy.\n    function reportAdditionalToken(address _token) external nonReentrant {\n        _onlyStrategy();\n        require(address(token) != _token, \"No want\");\n        uint256 tokenBalance = IERC20Upgradeable(_token).balanceOf(address(this));\n\n        additionalTokensEarned[_token] = additionalTokensEarned[_token].add(tokenBalance);\n        lastAdditionalTokenAmount[_token] = tokenBalance;\n\n        // We may have more, but we still report only what the strat sent\n        uint256 governanceRewardsFee = _calculateFee(tokenBalance, performanceFeeGovernance);\n        uint256 strategistRewardsFee = _calculateFee(tokenBalance, performanceFeeStrategist);\n\n        IERC20Upgradeable(_token).safeTransfer(treasury, governanceRewardsFee);\n        IERC20Upgradeable(_token).safeTransfer(strategist, strategistRewardsFee);\n\n        // Send rest to tree\n        uint256 newBalance = IERC20Upgradeable(_token).balanceOf(address(this));\n        IERC20Upgradeable(_token).safeTransfer(badgerTree, newBalance);\n        emit TreeDistrib"
    }
  ]
}