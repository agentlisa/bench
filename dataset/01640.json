{
  "Title": "H-5: When a D3MM pool repays all of the borrowed funds to vault using `D3Funding.sol repayAll`, an attacker can steal double the amount of those funds from vault",
  "Content": "# Issue H-5: When a D3MM pool repays all of the borrowed funds to vault using `D3Funding.sol repayAll`, an attacker can steal double the amount of those funds from vault \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/217 \n\n## Found by \n0x4db5362c, 0xG0P1, 0xkaden, HALITUS, Proxy, Sulpiride, dirk\\_y, osmanozdemir1, seeques, skyge\n## Summary\n\nWhen a D3MM pool repays all of the borrowed funds to vault using [D3Funding.sol repayAll](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L40-L46), an attacker can steal double the amount of those funds from vault. This is because the balance of vault is not updated correctly in [D3VaultFunding.sol _poolRepayAll](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L117-L133).\n\n`amount` should be added in `info.balance` instead of being subtracted.\n\n```solidity\n    function _poolRepayAll(address pool, address token) internal {\n        .\n        .\n        info.totalBorrows = info.totalBorrows - amount;\n        info.balance = info.balance - amount; // amount should be added here\n        .\n        .\n    }\n```\n\n## Vulnerability Detail\nA `D3MM pool` can repay all of the borrowed funds from vault using the function [D3Funding.sol repayAll](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol#L40-L46) which further calls [D3VaultFunding.sol poolRepayAll](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L113) and eventually [D3VaultFunding.sol _poolRepayAll](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L117-L133).\n\n```solidity\n    function repayAll(address token) external onlyOwner nonReentrant poolOngoing {\n        ID3Vault(state._D3_VAULT_).poolRepayAll(token);\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n    }\n```\n\nThe vault keeps a record of borrowed funds and its current token balance.\n\n`_poolRepayAll()` is supposed to:\n1. Decrease the borrowed funds by the repaid amount\n2. Increase the token balance by the same amount #vulnerability\n3. Transfer the borrowed funds from pool to vault\n\nHowever, `_poolRepayAll()` is decreasing the token balance instead.\n\n```solidity\n    function _poolRepayAll(address pool, address token) internal {\n        .\n        .\n        .\n        .\n\n        info.totalBorrows = info.totalBorrows - amount;\n        info.balance = info.balance - amount; // amount should be added here\n\n        IERC20(token).safeTransferFrom(pool, address(this), amount);\n\n        emit PoolRepay(pool, token, amount, interests);\n    }\n```\nLet's say a vault has 100,000 USDC\nA pool borrows 20,000 USDC from vault\n\nWhen the pool calls `poolRepayAll()`, the asset info in vault will change as follows:\n\n1. `totalBorrows => 20,000 - 20,000 => 0` // info.totalBorrows - amount\n2. `balance => 100,000 - 20,000 => 80,000` // info.balance - amount\n3. `tokens owned by vault => 100,000 + 20,000 => 120,000 USDC` // 20,000 USDC is transferred from pool to vault (repayment)\n4. The difference of recorded balance (80,000) and actual balance (120,000) is `40,000 USDC` \n\n**An attacker waits for the `poolRepayAll()` function call by a pool.**\n\nWhen `poolRepayAll()` is executed, the attacker calls [D3VaultFunding.sol userDeposit()](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L29), which deposits 40,000 USDC in vault on behalf of the attacker.\n\nAfter this, the attacker withdraws the deposited amount using [D3VaultFunding.sol userWithdraw()](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L51) and thus gains 40,000 USDC.\n\n```solidity\n    function userDeposit(address user, address token) external nonReentrant allowedToken(token) {\n        .\n        .\n        .\n        AssetInfo storage info = assetInfo[token];\n        uint256 realBalance = IERC20(token).balanceOf(address(this)); // check tokens owned by vault\n        uint256 amount = realBalance - info.balance; // amount = 120000-80000\n        .\n        .\n        .\n        IDToken(info.dToken).mint(user, dTokenAmount);\n        info.balance = realBalance;\n\n        emit UserDeposit(user, token, amount);\n    }\n```\n\n## Impact\n\nLoss of funds from vault. \nThe loss will be equal to 2x amount of borrowed tokens that a D3MM pool repays using [D3VaultFunding.sol poolRepayAll]()\n\n## Code Snippet\n\n[D3VaultFunding.sol _poolRepayAll()](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L129)\n\n```solidity\n    function _poolRepayAll(address pool, address token) internal {\n        .\n        .\n        info.totalBorrows = info.totalBorrows - amount;\n        info.balance = info.balance - amount; // vulnerability: amount should be added here\n\n        IERC20(token).safeTransferFrom(pool, address(this), amount);\n\n        emit PoolRepay(pool, token, amount, interests);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIn [D3VaultFunding.sol _poolRepayAll](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L129), do the following changes:\n\nCurrent code:\n`info.balance = info.balance - amount;`\n\nNew (replace '-' with '+'):\n`info.balance = info.balance + amount;`\n\n\n\n## Discussion\n\n**traceurl**\n\nFixed in this PR: https://github.com/DODOEX/new-dodo-v3/pull/26\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"../intf/ID3Vault.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"./D3Storage.sol\";\n\n/// @notice pool funding model, manage pool borrow/repay and maker deposi/withdraw\ncontract D3Funding is D3Storage {\n    using SafeERC20 for IERC20;\n\n    /// @notice borrow tokens from vault\n    function borrow(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolBorrow function\n        ID3Vault(state._D3_VAULT_).poolBorrow(token, amount);\n        // approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n    }\n\n    /// @notice repay vault with certain amount of borrowed assets \n    function repay(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolRepay\n        ID3Vault(state._D3_VAULT_).poolRepay(token, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n    }\n\n    /// @notice repay vault all debt of this token\n    function repayAll(address token) external onlyOwner nonReentrant poolOngoing {\n        ID3Vault(state._D3_VAULT_).poolRepayAll(token);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n\n    }\n\n    /// @notice used through liquidation\n    function updateReserveByVault(address token) external onlyVault {\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        _updateReserve(token);\n    }\n\n    /// @notice maker deposit, anyone could deposit but only maker could withdraw\n    function makerDeposit(address token) external nonReentrant poolOngoing {\n        require(ID3Oracle(state._ORACLE_).isFeasible(token), Errors.TOKEN_NOT_FEASIBLE);\n        // transfer in from proxies\n        uint256 tokenInAmount = IERC20(token).balanceOf(address(this)) - state.balances[token];\n        _updateReserve(token);\n        // if token in tokenlist, approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(_checkTokenInTokenlist(token) && allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        require(checkSafe(), Errors.NOT_SAFE);\n\n        emit MakerDeposit(token, tokenInAmount);\n    }\n\n    function makerWithdraw(address to, address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        IERC20(token).safeTransfer(to, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n\n        emit MakerWithdraw(to, token, amount);\n    }\n\n    // below IM: not safe!\n    function checkSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkSafe(address(this));\n    }\n\n    // check when borrowing asset\n    function checkBorrowSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkBorrowSafe(address(this));\n    }\n\n    // blow MM: dangerous!\n    function checkCanBeLiquidated() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkCanBeLiquidated(address(this));\n    }\n\n    function startLiquidation() external onlyVault {\n        isInLiquidation = true;\n    }\n\n    function finishLiquidation() external onlyVault {\n        isInLiquidation = false;\n    }\n\n    function _updateReserve(address token) internal {\n        state.balances[token] = IERC20(token).balanceOf(address(this));\n    }\n\n    function _checkTokenInTokenlist(address token) internal view returns(bool){\n        return ID3Vault(state._D3_VAULT_).tokens(token); \n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Funding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"../intf/ID3Vault.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"./D3Storage.sol\";\n\n/// @notice pool funding model, manage pool borrow/repay and maker deposi/withdraw\ncontract D3Funding is D3Storage {\n    using SafeERC20 for IERC20;\n\n    /// @notice borrow tokens from vault\n    function borrow(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolBorrow function\n        ID3Vault(state._D3_VAULT_).poolBorrow(token, amount);\n        // approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n    }\n\n    /// @notice repay vault with certain amount of borrowed assets \n    function repay(address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        // call vault's poolRepay\n        ID3Vault(state._D3_VAULT_).poolRepay(token, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n    }\n\n    /// @notice repay vault all debt of this token\n    function repayAll(address token) external onlyOwner nonReentrant poolOngoing {\n        ID3Vault(state._D3_VAULT_).poolRepayAll(token);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n\n    }\n\n    /// @notice used through liquidation\n    function updateReserveByVault(address token) external onlyVault {\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        _updateReserve(token);\n    }\n\n    /// @notice maker deposit, anyone could deposit but only maker could withdraw\n    function makerDeposit(address token) external nonReentrant poolOngoing {\n        require(ID3Oracle(state._ORACLE_).isFeasible(token), Errors.TOKEN_NOT_FEASIBLE);\n        // transfer in from proxies\n        uint256 tokenInAmount = IERC20(token).balanceOf(address(this)) - state.balances[token];\n        _updateReserve(token);\n        // if token in tokenlist, approve max, ensure vault could force liquidate\n        uint256 allowance = IERC20(token).allowance(state._D3_VAULT_, address(this));\n        if(_checkTokenInTokenlist(token) && allowance < type(uint256).max) {\n            IERC20(token).approve(state._D3_VAULT_, type(uint256).max);\n        }\n        require(checkSafe(), Errors.NOT_SAFE);\n\n        emit MakerDeposit(token, tokenInAmount);\n    }\n\n    function makerWithdraw(address to, address token, uint256 amount) external onlyOwner nonReentrant poolOngoing {\n        IERC20(token).safeTransfer(to, amount);\n\n        _updateReserve(token);\n        require(checkSafe(), Errors.NOT_SAFE);\n        require(checkBorrowSafe(), Errors.NOT_BORROW_SAFE);\n\n        emit MakerWithdraw(to, token, amount);\n    }\n\n    // below IM: not safe!\n    function checkSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkSafe(address(this));\n    }\n\n    // check when borrowing asset\n    function checkBorrowSafe() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkBorrowSafe(address(this));\n    }\n\n    // blow MM: dangerous!\n    function checkCanBeLiquidated() public view returns (bool) {\n        return ID3Vault(state._D3_VAULT_).checkCanBeLiquidated(address(this));\n    }\n\n    function startLiquidation() external onlyVault {\n        isInLiquidation = true;\n    }\n\n    function finishLiquidation() external onlyVault {\n        isInLiquidation = false;\n    }\n\n    function _updateReserve(address token) internal {\n        state.balances[token] = IERC20(token).balanceOf(address(this));\n    }\n\n    function _checkTokenInTokenlist(address token) internal view returns(bool){\n        return ID3Vault(state._D3_VAULT_).tokens(token); \n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport \"./D3VaultStorage.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"../intf/ID3UserQuota.sol\";\nimport \"../intf/ID3PoolQuota.sol\";\nimport \"../intf/ID3MM.sol\";\nimport \"../intf/IDToken.sol\";\nimport \"../intf/ID3RateManager.sol\";\n\n/// @title D3VaultFunding\n/// @notice This contract defines the fund management of D3Vault.\n/// @notice Users (LP) deposit funds into vault to earn interests; D3Pools borrows funds from vault to make market.\n/// @notice Part of the borrow interests will become the reserve fund.\n/// @notice The borrow interest rate is dynamicly changing with fund utilization ratio, and is caculated by D3RateManager.\n/// @notice The fund utilization ratio is defined as U = borrows / (cash + borrows - reserves)\n/// @notice Users who deposit funds into vault will receive certain amounts of corresponding dToken. The amount is calculated by the exchange rate.\n/// @notice The exchange rate between dToken and underlying token is defined as exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply\n/// @notice As time passes, totalBorrows will increase, so does the dToken exchangeRate. That's how users earn interests with dToken.\ncontract D3VaultFunding is D3VaultStorage {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    // ---------- LP user Fund ----------\n\n    /// @notice user should transfer token to vault before call this function\n    function userDeposit(address user, address token) external nonReentrant allowedToken(token) {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        uint256 realBalance = IERC20(token).balanceOf(address(this));\n        uint256 amount = realBalance  - info.balance;\n        require(ID3UserQuota(_USER_QUOTA_).checkQuota(user, token, amount), Errors.EXCEED_QUOTA);\n        uint256 exchangeRate = _getExchangeRate(token);\n        uint256 totalDToken = IDToken(info.dToken).totalSupply();\n        require(totalDToken.mul(exchangeRate) + amount <= info.maxDepositAmount, Errors.EXCEED_MAX_DEPOSIT_AMOUNT);\n        uint256 dTokenAmount = amount.div(exchangeRate);\n\n        IDToken(info.dToken).mint(user, dTokenAmount);\n        info.balance = realBalance;\n\n        emit UserDeposit(user, token, amount);\n    }\n\n    /// @param to who receive tokens\n    /// @param user who pay dTokens\n    /// @param token original token address\n    /// @param dTokenAmount dtoken the token record amount\n    function userWithdraw(address to, address user, address token, uint256 dTokenAmount) external nonReentrant allowedToken(token) returns(uint256 amount) {\n        accrueInterest(token);\n        AssetInfo storage info = assetInfo[token];\n        require(dTokenAmount <= IDToken(info.dToken).balanceOf(msg.sender), Errors.DTOKEN_BALANCE_NOT_ENOUGH);\n\n        amount = dTokenAmount.mul(_getExchangeRate(token));\n        IDToken(info.dToken).burn(msg.sender, dTokenAmount);\n        IERC20(token).safeTransfer(to, amount);\n        info.balance = info.balance - amount;\n\n        // used for calculate user withdraw amount\n        // this function could be called from d3Proxy, so we need \"user\" param\n        // In the meantime, some users may hope to use this function directly,\n        // to prevent these users fill \"user\" param with wrong addresses,\n        // we use \"msg.sender\" param to check.\n        emit UserWithdraw(msg.sender, user, token, amount);\n    }\n\n    // ---------- Pool Fund ----------\n    function poolBorrow(address token, uint256 amount) external nonReentrant allowedToken(token) onlyPool {\n        uint256 quota = ID3PoolQuota(_POOL_QUOTA_).getPoolQuota(msg.sender, token);\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[msg.sender];\n        uint256 oldInterestIndex = record.interestIndex;\n        uint256 currentInterestIndex = info.borrowIndex;\n        if (oldInterestIndex == 0) oldInterestIndex = 1e18;\n        uint256 usedQuota = record.amount.div(oldInterestIndex).mul(currentInterestIndex);\n        require(amount + usedQuota <= quota, Errors.EXCEED_QUOTA);\n        require(amount <= info.balance, Errors.AMOUNT_EXCEED_VAULT_BALANCE);\n\n        uint256 interests = usedQuota - record.amount;\n\n        record.amount = usedQuota + amount;\n        record.interestIndex = currentInterestIndex;\n        info.totalBorrows = info.totalBorrows + amount;\n        info.balance = info.balance - amount; \n        IERC20(token).safeTransfer(msg.sender, amount);\n\n        emit PoolBorrow(msg.sender, token, amount, interests);\n    }\n\n    function poolRepay(address token, uint256 amount) external nonReentrant allowedToken(token) onlyPool {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[msg.sender];\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n        require(amount <= borrows, Errors.AMOUNT_EXCEED);\n\n        uint256 interests = borrows - record.amount;\n\n        record.amount = borrows - amount;\n        record.interestIndex = info.borrowIndex;\n        info.totalBorrows = info.totalBorrows - amount;\n        info.balance = info.balance + amount;\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit PoolRepay(msg.sender, token, amount, interests);\n    }\n\n    function poolRepayAll(address token) external nonReentrant allowedToken(token) onlyPool {\n        _poolRepayAll(msg.sender, token);\n    }\n\n    function _poolRepayAll(address pool, address token) internal {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[pool];\n        uint256 amount = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n\n        uint256 interests = amount;\n\n        record.amount = 0;\n        record.interestIndex = info.borrowIndex;\n        info.totalBorrows = info.totalBorrows - amount;\n        info.balance = info.balance - amount;\n        IERC20(token).safeTransferFrom(pool, address(this), amount);\n\n        emit PoolRepay(pool, token, amount, interests);\n    }\n\n    // ---------- Interest ----------\n\n    /// @notice Accrue interest for a token\n    /// @notice Step1: get time past\n    /// @notice Step2: get borrow rate\n    /// @notice Step3: calculate compound interest rate during the past time\n    /// @notice Step4: calculate increased borrows, reserves\n    /// @notice Step5: update borrows, reserves, accrual time, borrowIndex\n    /// @notice borrowIndex is the accrual interest rate\n    function _accrueInterestForRead(address token) internal view returns(uint256 totalBorrowsNew, uint256 totalReservesNew, uint256 borrowIndexNew, uint256 accrualTime) {\n        AssetInfo storage info = assetInfo[token];\n\n        uint256 currentTime = block.timestamp;\n        uint256 deltaTime = currentTime - info.accrualTime;\n        if (deltaTime == 0) return(info.totalBorrows, info.totalReserves, info.borrowIndex, currentTime);\n\n        uint256 borrowsPrior = info.totalBorrows;\n        uint256 reservesPrior = info.totalReserves;\n        uint256 borrowIndexPrior = info.borrowIndex;\n\n        uint256 borrowRate = ID3RateManager(_RATE_MANAGER_).getBorrowRate(token, getUtilizationRatio(token));\n        uint256 borrowRatePerSecond = borrowRate / SECONDS_PER_YEAR;\n        uint256 compoundInterestRate = getCompoundInterestRate(borrowRatePerSecond, deltaTime);\n        totalBorrowsNew = borrowsPrior.mul(compoundInterestRate);\n        totalReservesNew = reservesPrior + (totalBorrowsNew - borrowsPrior).mul(info.reserveFactor);\n        borrowIndexNew = borrowIndexPrior.mul(compoundInterestRate);\n\n        accrualTime = currentTime;\n    }\n\n    /// @notice Accrue interest for a token, change storage\n    function accrueInterest(address token) public {\n        (assetInfo[token].totalBorrows, assetInfo[token].totalReserves, assetInfo[token].borrowIndex, assetInfo[token].accrualTime) =\n        _accrueInterestForRead(token);\n    }\n\n    function accrueInterests() public {\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            accrueInterest(token);\n        }\n    }\n\n    /// @dev r: interest rate per second (decimals 18)\n    /// @dev t: total time in seconds\n    /// @dev (1+r)^t = 1 + rt + t*(t-1)*r^2/2! + t*(t-1)*(t-2)*r^3/3! + ... + t*(t-1)...*(t-n+1)*r^n/n!\n    function getCompoundInterestRate(uint256 r, uint256 t) public pure returns (uint256) {\n        if (t < 1) {\n            return 1e18;\n        } else if (t < 2) {\n            return 1e18 + r * t;\n        } else {\n            return 1e18 + r * t + r.powFloor(2) * t * (t - 1) / 2;\n        }\n    }\n\n    // ----------- View ----------\n\n    function getPoolLeftQuota(address pool, address token) public view returns(uint256 leftQuota) {\n        uint256 quota = ID3PoolQuota(_POOL_QUOTA_).getPoolQuota(pool, token);\n        uint256 oldInterestIndex = assetInfo[token].borrowRecord[pool].interestIndex;\n        ( , ,uint256 currentInterestIndex, ) = _accrueInterestForRead(token);\n        if (oldInterestIndex == 0) oldInterestIndex = 1e18;\n        uint256 usedQuota = assetInfo[token].borrowRecord[pool].amount.div(oldInterestIndex).mul(currentInterestIndex);\n        leftQuota = quota > usedQuota ? quota - usedQuota : 0;\n    }\n\n    /// @notice U = borrows / (cash + borrows - reserves)\n    function getUtilizationRatio(address token) public view returns (uint256) {\n        uint256 borrows = getTotalBorrows(token);\n        uint256 cash = getCash(token);\n        uint256 reserves = getReservesInVault(token);\n        if (borrows == 0) return 0;\n        return borrows.div(cash + borrows - reserves);\n    }\n\n    function getBorrowRate(address token) public view returns (uint256 rate) {\n        rate = ID3RateManager(_RATE_MANAGER_).getBorrowRate(token, getUtilizationRatio(token));\n    }\n\n    function getCash(address token) public view returns (uint256) {\n        return assetInfo[token].balance;\n    }\n\n    function getTotalBorrows(address token) public view returns (uint256) {\n        return assetInfo[token].totalBorrows;\n    }\n\n    function getReservesInVault(address token) public view returns (uint256) {\n        AssetInfo storage info = assetInfo[token];\n        return info.totalReserves - info.withdrawnReserves;\n    }\n\n    /// @notice exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply\n    /// @notice Make sure accrueInterests or accrueInterest(token) is called before\n    function _getExchangeRate(address token) internal view returns (uint256) {\n        AssetInfo storage info = assetInfo[token];\n        uint256 cash = getCash(token);\n        uint256 dTokenSupply = IERC20(info.dToken).totalSupply();\n        if (dTokenSupply == 0) { return 1e18; }\n        return (cash + info.totalBorrows - (info.totalReserves - info.withdrawnReserves)).div(dTokenSupply);\n    } \n\n    /// @notice Make sure accrueInterests or accrueInterest(token) is called before\n    function _getBalanceAndBorrows(address pool, address token) internal view returns (uint256, uint256) {\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[pool];\n\n        uint256 balance = ID3MM(pool).getTokenReserve(token);\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n\n        return (balance, borrows);\n    }\n\n    /// @notice Make sure accrueInterests() is called before calling this function\n    function _getTotalDebtValue(address pool) internal view returns (uint256 totalDebt) {\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            BorrowRecord memory record = info.borrowRecord[pool];\n            uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            totalDebt += borrows.mul(price);\n        }\n    }\n\n    function getTotalAssetsValue(address pool) public view returns (uint256 totalValue) {\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            totalValue += DecimalMath.mul(ID3MM(pool).getTokenReserve(token), price);\n        }\n    }\n\n    /// @notice Make sure accrueInterests() is called before\n    /// @notice net = balance - borrowed\n    /// @notice collateral = sum(min(positive net, maxCollateralAmount）* weight * price)\n    /// @notice debt = sum(negative net * weight * price)\n    /// @notice collateralRatio = collateral / debt\n    function _getCollateralRatio(address pool) internal view returns (uint256) {\n        uint256 collateral = 0;\n        uint256 debt = 0;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n\n            (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            if (balance >= borrows) {\n                collateral += min(balance - borrows, info.maxCollateralAmount).mul(info.collateralWeight).mul(price);\n            } else {\n                debt += (borrows - balance).mul(info.debtWeight).mul(price);\n            }\n        }\n        return _ratioDiv(collateral, debt);\n    }\n\n    function checkSafe(address pool) public view returns (bool) {\n        return getCollateralRatio(pool) >  1e18 + IM;\n    }\n\n    function checkBorrowSafe(address pool) public view returns (bool) {\n        return getCollateralRatioBorrow(pool) > IM;\n    }\n\n    function checkCanBeLiquidated(address pool) public view returns (bool) {\n        return getCollateralRatio(pool) < 1e18 + MM;\n    }\n\n    function checkCanBeLiquidatedAfterAccrue(address pool) public view returns (bool) {\n        return _getCollateralRatio(pool) < 1e18 + MM;\n    }\n\n    function checkBadDebt(address pool) public view returns (bool) {\n        return getCollateralRatio(pool) < 1e18;\n    }\n\n    function checkBadDebtAfterAccrue(address pool) public view returns (bool) {\n        return _getCollateralRatio(pool) < 1e18;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n    function _ratioDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 && b == 0) {\n            return 1e18;\n        } else if (a == 0 && b != 0) {\n            return 0;\n        } else if (a != 0 && b == 0) {\n            return type(uint256).max;\n        } else {\n            return a.div(b);\n        }\n    }\n\n    // ======================= Read Only =======================\n\n    function getExchangeRate(address token) public view returns(uint256 exchangeRate) {\n        (uint256 totalBorrows, uint256 totalReserves, ,) = _accrueInterestForRead(token);\n        uint256 cash = getCash(token);\n        uint256 dTokenSupply = IERC20(assetInfo[token].dToken).totalSupply();\n        if (dTokenSupply == 0) { return 1e18; }\n        exchangeRate = (cash + totalBorrows - (totalReserves - assetInfo[token].withdrawnReserves)).div(dTokenSupply);\n    }\n\n    function getLatestBorrowIndex(address token) public view returns (uint256 borrowIndex) {\n        AssetInfo storage info = assetInfo[token];\n        uint256 deltaTime = block.timestamp - info.accrualTime;\n        uint256 borrowRate = getBorrowRate(token);\n        uint256 borrowRatePerSecond = borrowRate / SECONDS_PER_YEAR;\n        uint256 compoundInterestRate = getCompoundInterestRate(borrowRatePerSecond, deltaTime);\n        borrowIndex = info.borrowIndex.mul(compoundInterestRate);\n    }\n\n    function getPoolBorrowAmount(address pool, address token) public view returns (uint256 amount) {\n        BorrowRecord storage record = assetInfo[token].borrowRecord[pool];\n        uint256 borrowIndex = getLatestBorrowIndex(token);\n        amount = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(borrowIndex);\n    }\n\n    function getTotalDebtValue(address pool) external view returns (uint256 totalDebt) {\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            uint256 borrowAmount = getPoolBorrowAmount(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            totalDebt += borrowAmount.mul(price);\n        }\n    }\n\n    function getBalanceAndBorrows(address pool, address token) public view returns (uint256, uint256) {\n        uint256 balance = ID3MM(pool).getTokenReserve(token);\n        uint256 borrows = getPoolBorrowAmount(pool, token);\n        return (balance, borrows);\n    }\n\n    function getCollateralRatio(address pool) public view returns (uint256) {\n        uint256 collateral = 0;\n        uint256 debt = 0;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n\n            (uint256 balance, uint256 borrows) = getBalanceAndBorrows(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            \n            if (balance >= borrows) {\n                collateral += min(balance - borrows, info.maxCollateralAmount).mul(info.collateralWeight).mul(price);\n            } else {\n                debt += (borrows - balance).mul(info.debtWeight).mul(price);\n            }\n        }\n        return _ratioDiv(collateral, debt);\n    }\n    \n    /// @notice collateralRatioBorrow = ∑[min(maxCollateralAmount，balance - borrows）] / ∑borrows\n    function getCollateralRatioBorrow(address pool) public view returns (uint256) {\n        uint256 balanceSumPositive = 0;\n        uint256 balanceSumNegative = 0;\n        uint256 borrowedSum = 0;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n\n            (uint256 balance, uint256 borrows) = getBalanceAndBorrows(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n\n            if (balance >= borrows) {\n                balanceSumPositive += min(balance - borrows, assetInfo[token].maxCollateralAmount).mul(price);\n            } else {\n                balanceSumNegative += (borrows - balance).mul(price);\n            }\n\n            borrowedSum += borrows.mul(price);\n        }\n        \n        uint256 balanceSum = balanceSumPositive < balanceSumNegative ? 0 : balanceSumPositive - balanceSumNegative;\n        return _ratioDiv(balanceSum, borrowedSum);\n    }\n\n    function getCumulativeBorrowRate(address pool, address token) external view returns (uint256 cumulativeRate, uint256 currentAmount) {\n        BorrowRecord storage record = assetInfo[token].borrowRecord[pool];\n        uint256 borrowIndex = getLatestBorrowIndex(token);\n        cumulativeRate = borrowIndex.div(record.interestIndex == 0 ? 1e18 : record.interestIndex);\n        currentAmount = record.amount;\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport \"./D3VaultStorage.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"../intf/ID3UserQuota.sol\";\nimport \"../intf/ID3PoolQuota.sol\";\nimport \"../intf/ID3MM.sol\";\nimport \"../intf/IDToken.sol\";\nimport \"../intf/ID3RateManager.sol\";\n\n/// @title D3VaultFunding\n/// @notice This contract defines the fund management of D3Vault.\n/// @notice Users (LP) deposit funds into vault to earn interests; D3Pools borrows funds from vault to make market.\n/// @notice Part of the borrow interests will become the reserve fund.\n/// @notice The borrow interest rate is dynamicly changing with fund utilization ratio, and is caculated by D3RateManager.\n/// @notice The fund utilization ratio is defined as U = borrows / (cash + borrows - reserves)\n/// @notice Users who deposit funds into vault will receive certain amounts of corresponding dToken. The amount is calculated by the exchange rate.\n/// @notice The exchange rate between dToken and underlying token is defined as exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply\n/// @notice As time passes, totalBorrows will increase, so does the dToken exchangeRate. That's how users earn interests with dToken.\ncontract D3VaultFunding is D3VaultStorage {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    // ---------- LP user Fund ----------\n\n    /// @notice user should transfer token to vault before call this function\n    function userDeposit(address user, address token) external nonReentrant allowedToken(token) {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        uint256 realBalance = IERC20(token).balanceOf(address(this));\n        uint256 amount = realBalance  - info.balance;\n        require(ID3UserQuota(_USER_QUOTA_).checkQuota(user, token, amount), Errors.EXCEED_QUOTA);\n        uint256 exchangeRate = _getExchangeRate(token);\n        uint256 totalDToken = IDToken(info.dToken).totalSupply();\n        require(totalDToken.mul(exchangeRate) + amount <= info.maxDepositAmount, Errors.EXCEED_MAX_DEPOSIT_AMOUNT);\n        uint256 dTokenAmount = amount.div(exchangeRate);\n\n        IDToken(info.dToken).mint(user, dTokenAmount);\n        info.balance = realBalance;\n\n        emit UserDeposit(user, token, amount);\n    }\n\n    /// @param to who receive tokens\n    /// @param user who pay dTokens\n    /// @param token original token address\n    /// @param dTokenAmount dtoken the token record amount\n    function userWithdraw(address to, address user, address token, uint256 dTokenAmount) external nonReentrant allowedToken(token) returns(uint256 amount) {\n        accrueInterest(token);\n        AssetInfo storage info = assetInfo[token];\n        require(dTokenAmount <= IDToken(info.dToken).balanceOf(msg.sender), Errors.DTOKEN_BALANCE_NOT_ENOUGH);\n\n        amount = dTokenAmount.mul(_getExchangeRate(token));\n        IDToken(info.dToken).burn(msg.sender, dTokenAmount);\n        IERC20(token).safeTransfer(to, amount);\n        info.balance = info.balance - amount;\n\n        // used for calculate user withdraw amount\n        // this function could be called from d3Proxy, so we need \"user\" param\n        // In the meantime, some users may hope to use this function directly,\n        // to prevent these users fill \"user\" param with wrong addresses,\n        // we use \"msg.sender\" param to check.\n        emit UserWithdraw(msg.sender, user, token, amount);\n    }\n\n    // ---------- Pool Fund ----------\n    function poolBorrow(address token, uint256 amount) external nonReentrant allowedToken(token) onlyPool {\n        uint256 quota = ID3PoolQuota(_POOL_QUOTA_).getPoolQuota(msg.sender, token);\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[msg.sender];\n        uint256 oldInterestIndex = record.interestIndex;\n        uint256 currentInterestIndex = info.borrowIndex;\n        if (oldInterestIndex == 0) oldInterestIndex = 1e18;\n        uint256 usedQuota = record.amount.div(oldInterestIndex).mul(currentInterestIndex);\n        require(amount + usedQuota <= quota, Errors.EXCEED_QUOTA);\n        require(amount <= info.balance, Errors.AMOUNT_EXCEED_VAULT_BALANCE);\n\n        uint256 interests = usedQuota - record.amount;\n\n        record.amount = usedQuota + amount;\n        record.interestIndex = currentInterestIndex;\n        info.totalBorrows = info.totalBorrows + amount;\n        info.balance = info.balance - amount; \n        IERC20(token).safeTransfer(msg.sender, amount);\n\n        emit PoolBorrow(msg.sender, token, amount, interests);\n    }\n\n    function poolRepa"
    }
  ]
}