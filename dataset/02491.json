{
  "Title": "M-15: Interest rate for pool is bounded wrongly",
  "Content": "# Issue M-15: Interest rate for pool is bounded wrongly \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/96 \n\n## Found by \nyixxas\n\n## Summary\nIt is documented that pools can be created for tokens with interest rate between 1-10%.\n\n> Pool creators: create pool by providing a fungible token for quote and collateral and an interest rate between 1-10%\n\nHowever, due to a wrong implementation, pools can only be created between 2-9%.\n\n## Vulnerability Detail\nIn PoolDeployer.sol contract we have `MIN_RATE = 0.01 * 1e18` and `MAX_RATE = 0.1 * 1e18`. This indicates the 1% and 10% value in which we should allow interest rate to be set. \n\nHowever, in our `canDeploy` modifier, it causes a revert when the following condition is true.\n\n> `if (MIN_RATE >= interestRate_ || interestRate_ >= MAX_RATE)         revert IPoolFactory.PoolInterestRateInvalid()`\n\nA more than or equal sign is used to do the comparison, and reverts. This means that we can only set interest rate in the range of 2-9%, which I believe is not intended.\n\n## Impact\nInterest rate is bounded wrongly, limiting pools from being deployed with the intended range.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/PoolDeployer.sol#L13-L14\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/PoolDeployer.sol#L38-L43\n\n## Tool used\n\nManual Review\n\n## Recommendation\nChange to a strict comparison instead when doing the comparison.\n\n```diff\n- if (MIN_RATE >= interestRate_ || interestRate_ >= MAX_RATE)         revert IPoolFactory.PoolInterestRateInvalid();\n+ if (MIN_RATE > interestRate_ || interestRate_ > MAX_RATE)         revert IPoolFactory.PoolInterestRateInvalid();\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/base/PoolDeployer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { IPoolFactory } from '../interfaces/pool/IPoolFactory.sol';\n\n/**\n *  @title  Pool Deployer base contract\n *  @notice Base contract for Pool Deployer, contains logic used by both ERC20 and ERC721 Pool Factories.\n */\nabstract contract PoolDeployer {\n\n    uint256 public constant MIN_RATE = 0.01 * 1e18;\n    uint256 public constant MAX_RATE = 0.1  * 1e18;\n\n    address public ajna; // Ajna token contract address on a network.\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev SubsetHash => CollateralAddress => QuoteAddress => Pool Address\n    // slither-disable-next-line uninitialized-state\n    mapping(bytes32 => mapping(address => mapping(address => address))) public deployedPools;\n\n    /// @notice List of all deployed pools. Separate list is maintained for each factory.\n    // slither-disable-next-line uninitialized-state\n    address[] public deployedPoolsList;\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    /**\n     * @notice Ensures that pools are deployed according to specifications.\n     * @dev    Used by both ERC20, and ERC721 pool factory types.\n     */\n    modifier canDeploy(bytes32 subsetHash_, address collateral_, address quote_, uint256 interestRate_) {\n        if (collateral_ == address(0) || quote_ == address(0))              revert IPoolFactory.DeployWithZeroAddress();\n        if (deployedPools[subsetHash_][collateral_][quote_] != address(0)) revert IPoolFactory.PoolAlreadyExists();\n        if (MIN_RATE >= interestRate_ || interestRate_ >= MAX_RATE)         revert IPoolFactory.PoolInterestRateInvalid();\n        _;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     * @notice Returns the list of all deployed pools.\n     * @dev    This function is used by integrations to access deployed pools.\n     * @dev    Each factory implementation maintains its own list of deployed pools.\n     * @return address[] memory List of all deployed pools.\n     */\n    function getDeployedPoolsList() external view returns (address[] memory) {\n        return deployedPoolsList;\n    }\n\n    /**\n     * @notice Returns the number of deployed pools that have been deployed by a factory.\n     * @return uint256 length of deployedPoolsList array.\n     */\n    function getNumberOfDeployedPools() external view returns (uint256) {\n        return deployedPoolsList.length;\n    }\n\n}"
    },
    {
      "filename": "contracts/src/base/PoolDeployer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { IPoolFactory } from '../interfaces/pool/IPoolFactory.sol';\n\n/**\n *  @title  Pool Deployer base contract\n *  @notice Base contract for Pool Deployer, contains logic used by both ERC20 and ERC721 Pool Factories.\n */\nabstract contract PoolDeployer {\n\n    uint256 public constant MIN_RATE = 0.01 * 1e18;\n    uint256 public constant MAX_RATE = 0.1  * 1e18;\n\n    address public ajna; // Ajna token contract address on a network.\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev SubsetHash => CollateralAddress => QuoteAddress => Pool Address\n    // slither-disable-next-line uninitialized-state\n    mapping(bytes32 => mapping(address => mapping(address => address))) public deployedPools;\n\n    /// @notice List of all deployed pools. Separate list is maintained for each factory.\n    // slither-disable-next-line uninitialized-state\n    address[] public deployedPoolsList;\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    /**\n     * @notice Ensures that pools are deployed according to specifications.\n     * @dev    Used by both ERC20, and ERC721 pool factory types.\n     */\n    modifier canDeploy(bytes32 subsetHash_, address collateral_, address quote_, uint256 interestRate_) {\n        if (collateral_ == address(0) || quote_ == address(0))              revert IPoolFactory.DeployWithZeroAddress();\n        if (deployedPools[subsetHash_][collateral_][quote_] != address(0)) revert IPoolFactory.PoolAlreadyExists();\n        if (MIN_RATE >= interestRate_ || interestRate_ >= MAX_RATE)         revert IPoolFactory.PoolInterestRateInvalid();\n        _;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     * @notice Returns the list of all deployed pools.\n     * @dev    This function is used by integrations to access deployed pools.\n     * @dev    Each factory implementation maintains its own list of deployed pools.\n     * @return address[] memory List of all deployed pools.\n     */\n    function getDeployedPoolsList() external view returns (address[] memory) {\n        return deployedPoolsList;\n    }\n\n    /**\n     * @notice Returns the number of deployed pools that have been deployed by a factory.\n     * @return uint256 length of deployedPoolsList array.\n     */\n    function getNumberOfDeployedPools() external view returns (uint256) {\n        return deployedPoolsList.length;\n    }\n\n}"
    }
  ]
}