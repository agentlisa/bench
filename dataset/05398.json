{
  "Title": "[M-02] Dangerous use of deadline parameter",
  "Content": "\n<https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/LiquidityPosition.sol#L144> \n\n<https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/LiquidityPosition.sol#L197> \n\n<https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/LiquidityPosition.sol#L260>\n\nThe protocol is using `block.timestamp` as the deadline argument while interacting with the Uniswap NFT Position Manager, which completely defeats the purpose of using a deadline.\n\n### Impact\n\nActions in the Uniswap NonfungiblePositionManager contract are protected by a `deadline` parameter to limit the execution of pending transactions. Functions that modify the liquidity of the pool check this parameter against the current block timestamp in order to discard expired actions.\n\nThese interactions with the Uniswap position are present in the LiquidityPosition library. The functions `mint()`, `increaseLiquidity()` and `decreaseLiquidity()` call their corresponding functions in the Uniswap Position Manager, providing `block.timestamp` as the argument for the `deadline` parameter:\n\n<https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/LiquidityPosition.sol#L131-L146>\n\n```solidity\n131:         // mint the position\n132:         (tokenId, liquidity, amount0Minted, amount1Minted) = Base.UNI_POSITION_MANAGER.mint(\n133:             INonfungiblePositionManager.MintParams({\n134:                 token0: params.token0,\n135:                 token1: params.token1,\n136:                 fee: params.fee,\n137:                 tickLower: params.tickLower,\n138:                 tickUpper: params.tickUpper,\n139:                 amount0Desired: params.amount0ToMint,\n140:                 amount1Desired: params.amount1ToMint,\n141:                 amount0Min: params.amount0Min,\n142:                 amount1Min: params.amount1Min,\n143:                 recipient: address(this),\n144:                 deadline: block.timestamp\n145:             })\n146:         );\n```\n\n<https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/LiquidityPosition.sol#L189-L199>\n\n```solidity\n189:         // increase liquidity via position manager\n190:         (liquidity, amount0Added, amount1Added) = Base.UNI_POSITION_MANAGER.increaseLiquidity(\n191:             INonfungiblePositionManager.IncreaseLiquidityParams({\n192:                 tokenId: tokenId,\n193:                 amount0Desired: amount0,\n194:                 amount1Desired: amount1,\n195:                 amount0Min: 0,\n196:                 amount1Min: 0,\n197:                 deadline: block.timestamp\n198:             })\n199:         );\n```\n\n<https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/LiquidityPosition.sol#L254-L262>\n\n```solidity\n254:         (amount0, amount1) = Base.UNI_POSITION_MANAGER.decreaseLiquidity(\n255:             INonfungiblePositionManager.DecreaseLiquidityParams({\n256:                 tokenId: tokenId,\n257:                 liquidity: liquidity,\n258:                 amount0Min: 0,\n259:                 amount1Min: 0,\n260:                 deadline: block.timestamp\n261:             })\n262:         );\n```\n\nUsing `block.timestamp` as the deadline is effectively a no-operation that has no effect nor protection. Since `block.timestamp` will take the timestamp value when the transaction gets mined, the check will end up comparing `block.timestamp` against the same value, i.e. `block.timestamp <= block.timestamp` (see <https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/base/PeripheryValidation.sol#L7>).\n\nFailure to provide a proper deadline value enables pending transactions to be maliciously executed at a later point. Transactions that provide an insufficient amount of gas such that they are not mined within a reasonable amount of time, can be picked by malicious actors or MEV bots and executed later in detriment of the submitter.\n\nSee [this issue](https://github.com/code-423n4/2022-12-backed-findings/issues/64) for an excellent reference on the topic (the author runs a MEV bot).\n\n### Recommendation\n\nAdd a deadline parameter to each of the functions that are used to manage the liquidity position, `ParticlePositionManager.mint()`, `ParticlePositionManager.increaseLiquidity()` and `ParticlePositionManager.decreaseLiquidity()`. Forward this parameter to the corresponding underlying calls to the Uniswap NonfungiblePositionManager contract.\n\n**[wukong-particle (Particle) confirmed and commented](https://github.com/code-423n4/2023-12-particle-findings/issues/59#issuecomment-1868223319):**\n > Good practice to learn! Will add a proper in the input timestamp.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-particle",
  "Code": [
    {
      "filename": "contracts/libraries/LiquidityPosition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport {INonfungiblePositionManager} from \"../interfaces/INonfungiblePositionManager.sol\";\nimport {DataStruct} from \"./Structs.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {Base} from \"./Base.sol\";\n\n/// @title Liquidity Position\n/// @notice Represents a liquidity position's underlying owner and fee tokens accrued from lending\nlibrary LiquidityPosition {\n    struct Info {\n        address owner;\n        uint32 renewalCutoffTime; ///@dev loans before this time can't be renewed\n        uint128 token0Owed;\n        uint128 token1Owed;\n    }\n\n    event SupplyLiquidity(uint256 tokenId, address lp, uint128 liquidity);\n    event IncreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event DecreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event CollectLiquidity(address lp, address token0, address token1, uint256 amount0, uint256 amount1);\n\n    /*=============================================================\n                               Info Logic\n    ==============================================================*/\n\n    /**\n     * @notice Getter for a liquidity position's renewal cutoff time\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return renewalCutoffTime renewal cutoff time for all previous loans\n     */\n    function getRenewalCutoffTime(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal view returns (uint32 renewalCutoffTime) {\n        renewalCutoffTime = self[tokenId].renewalCutoffTime;\n    }\n\n    /**\n     * @notice Getter for a liquidity position's tokens currently owed to owner\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return token0Owed The amount of token0 owed to the owner\n     * @return token1Owed The amount of token1 owed to the owner\n     */\n    function getTokensOwed(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal view returns (uint128 token0Owed, uint128 token1Owed) {\n        Info memory info = self[tokenId];\n        token0Owed = info.token0Owed;\n        token1Owed = info.token1Owed;\n    }\n\n    /*=============================================================\n                            Tokens Owed Logic\n    ==============================================================*/\n\n    /**\n     * @notice Update a liquidity positon's owed tokens\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @param token0Owed The amount of token0 owed to the owner to be added\n     * @param token1Owed The amount of token1 owed to the owner to be added\n     */\n    function addTokensOwed(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint128 token0Owed,\n        uint128 token1Owed\n    ) internal {\n        Info storage info = self[tokenId];\n        info.token0Owed += token0Owed;\n        info.token1Owed += token1Owed;\n    }\n\n    /**\n     * @notice Reset a liquidity positon's owed tokens to 0\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     */\n    function resetTokensOwed(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        Info storage info = self[tokenId];\n        info.token0Owed = 0;\n        info.token1Owed = 0;\n    }\n\n    /*=============================================================\n                           Renewal Time Logic\n    ==============================================================*/\n\n    /**\n     * @notice Update a liquidity positon's renewal cutoff time\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     */\n    function updateRenewalCutoffTime(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        Info storage info = self[tokenId];\n        info.renewalCutoffTime = uint32(block.timestamp);\n    }\n\n    /*=============================================================\n                               Mint Logic\n    ==============================================================*/\n\n    /**\n     * @notice Supply liquidity to mint position NFT to the contract\n     * @param self The mapping containing all liquidity positions\n     * @param params mint parameters containing token pairs, fee, tick info and amount to mint\n     * @return tokenId newly minted tokenId\n     * @return liquidity amount of liquidity minted\n     * @return amount0Minted amount of token 0 minted\n     * @return amount1Minted amount of token 1 minted\n     */\n\n    function mint(\n        mapping(uint256 => Info) storage self,\n        DataStruct.MintParams calldata params\n    ) internal returns (uint256 tokenId, uint128 liquidity, uint256 amount0Minted, uint256 amount1Minted) {\n        // transfer in the tokens\n        TransferHelper.safeTransferFrom(params.token0, msg.sender, address(this), params.amount0ToMint);\n        TransferHelper.safeTransferFrom(params.token1, msg.sender, address(this), params.amount1ToMint);\n\n        // approve position manager to spend the tokens\n        TransferHelper.safeApprove(params.token0, Base.UNI_POSITION_MANAGER_ADDR, params.amount0ToMint);\n        TransferHelper.safeApprove(params.token1, Base.UNI_POSITION_MANAGER_ADDR, params.amount1ToMint);\n\n        // mint the position\n        (tokenId, liquidity, amount0Minted, amount1Minted) = Base.UNI_POSITION_MANAGER.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: params.token0,\n                token1: params.token1,\n                fee: params.fee,\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                amount0Desired: params.amount0ToMint,\n                amount1Desired: params.amount1ToMint,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        // create the LP position\n        self[tokenId] = LiquidityPosition.Info({owner: msg.sender, renewalCutoffTime: 0, token0Owed: 0, token1Owed: 0});\n\n        // reset the approval\n        TransferHelper.safeApprove(params.token0, Base.UNI_POSITION_MANAGER_ADDR, 0);\n        TransferHelper.safeApprove(params.token1, Base.UNI_POSITION_MANAGER_ADDR, 0);\n\n        // refund if necessary\n        Base.refund(msg.sender, params.token0, params.amount0ToMint, amount0Minted);\n        Base.refund(msg.sender, params.token1, params.amount1ToMint, amount1Minted);\n\n        emit SupplyLiquidity(tokenId, msg.sender, liquidity);\n    }\n\n    /*=============================================================\n                        Increase Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Increase liquidity to a liquidity position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param token0 The address of token0\n     * @param token1 The address of token1\n     * @param tokenId The token id of the liquidity position NFT\n     * @param amount0 The amount of token0 to add to the liquidity position\n     * @param amount1 The amount of token1 to add to the liquidity position\n     * @return liquidity The amount of liquidity added\n     * @return amount0Added The amount of token0 added\n     * @return amount1Added The amount of token1 added\n     */\n    function increaseLiquidity(\n        address token0,\n        address token1,\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        // approve spending for uniswap's position manager\n        TransferHelper.safeApprove(token0, Base.UNI_POSITION_MANAGER_ADDR, amount0);\n        TransferHelper.safeApprove(token1, Base.UNI_POSITION_MANAGER_ADDR, amount1);\n\n        // increase liquidity via position manager\n        (liquidity, amount0Added, amount1Added) = Base.UNI_POSITION_MANAGER.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: tokenId,\n                amount0Desired: amount0,\n                amount1Desired: amount1,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        // reset approval\n        TransferHelper.safeApprove(token0, Base.UNI_POSITION_MANAGER_ADDR, 0);\n        TransferHelper.safeApprove(token1, Base.UNI_POSITION_MANAGER_ADDR, 0);\n    }\n\n    /**\n     * @notice Increase liquidity of a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param amount0 amount to add for token 0\n     * @param amount1 amount to add for token 1\n     * @return liquidity amount of liquidity added\n     * @return amount0Added amount of token 0 added\n     * @return amount1Added amount of token 1 added\n     */\n    function increaseLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n\n        // get token0 and token1 from the position NFT\n        (, , address token0, address token1, , , , , , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n\n        // transfer in liquidity to add\n        TransferHelper.safeTransferFrom(token0, msg.sender, address(this), amount0);\n        TransferHelper.safeTransferFrom(token1, msg.sender, address(this), amount1);\n\n        // add liquidity\n        (liquidity, amount0Added, amount1Added) = increaseLiquidity(token0, token1, tokenId, amount0, amount1);\n\n        // refund if necessary\n        Base.refund(msg.sender, token0, amount0, amount0Added);\n        Base.refund(msg.sender, token1, amount1, amount1Added);\n\n        emit IncreaseLiquidity(tokenId, liquidity);\n    }\n\n    /*=============================================================\n                        Decrease Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Decrease liquidity from an existing position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount to decrease\n     * @return amount0 amount decreased for token0\n     * @return amount1 amount decreased for token1\n     */\n    function decreaseLiquidity(uint256 tokenId, uint128 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.UNI_POSITION_MANAGER.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n    }\n\n    /**\n     * @notice Decrease liquidity from a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount of liquidity to add\n     * @return amount0Decreased amount of token 0 decreased\n     * @return amount1Decreased amount of token 1 decreased\n     */\n    function decreaseLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint128 liquidity\n    ) internal returns (uint256 amount0Decreased, uint256 amount1Decreased) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        (amount0Decreased, amount1Decreased) = decreaseLiquidity(tokenId, liquidity);\n        emit DecreaseLiquidity(tokenId, liquidity);\n    }\n\n    /*=============================================================\n                        Collect Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Collect fees from a position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param amount0Max maximum amount of token0 to collect\n     * @param amount1Max maximum amount of token1 to collect\n     * @param recipient the address to collect the liquidity\n     * @return amount0 amount collected for token0\n     * @return amount1 amount collected for token1\n     */\n    function collectLiquidity(\n        uint256 tokenId,\n        uint128 amount0Max,\n        uint128 amount1Max,\n        address recipient\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.UNI_POSITION_MANAGER.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: recipient,\n                amount0Max: amount0Max,\n                amount1Max: amount1Max\n            })\n        );\n    }\n\n    /**\n     * @notice Collect fees from a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @return amount0Collected amount of fees collected in token 0\n     * @return amount1Collected amount of fees collected in token 1\n     */\n    function collectLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal returns (uint256 amount0Collected, uint256 amount1Collected) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        (amount0Collected, amount1Collected) = LiquidityPosition.collectLiquidity(\n            tokenId,\n            type(uint128).max,\n            type(uint128).max,\n            msg.sender\n        );\n        (uint128 token0Owed, uint128 token1Owed) = getTokensOwed(self, tokenId);\n        resetTokensOwed(self, tokenId);\n        (, , address token0, address token1, , , , , , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n        if (token0Owed > 0) {\n            amount0Collected += token0Owed;\n            TransferHelper.safeTransfer(token0, msg.sender, token0Owed);\n        }\n        if (token1Owed > 0) {\n            amount1Collected += token1Owed;\n            TransferHelper.safeTransfer(token1, msg.sender, token1Owed);\n        }\n\n        emit CollectLiquidity(msg.sender, token0, token1, amount0Collected, amount1Collected);\n    }\n\n    /*=============================================================\n                         Reclaim Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice LP reclaims borrowed liquidity from being renewed\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     */\n    function reclaimLiquidity(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        updateRenewalCutoffTime(self, tokenId);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LiquidityPosition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport {INonfungiblePositionManager} from \"../interfaces/INonfungiblePositionManager.sol\";\nimport {DataStruct} from \"./Structs.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {Base} from \"./Base.sol\";\n\n/// @title Liquidity Position\n/// @notice Represents a liquidity position's underlying owner and fee tokens accrued from lending\nlibrary LiquidityPosition {\n    struct Info {\n        address owner;\n        uint32 renewalCutoffTime; ///@dev loans before this time can't be renewed\n        uint128 token0Owed;\n        uint128 token1Owed;\n    }\n\n    event SupplyLiquidity(uint256 tokenId, address lp, uint128 liquidity);\n    event IncreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event DecreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event CollectLiquidity(address lp, address token0, address token1, uint256 amount0, uint256 amount1);\n\n    /*=============================================================\n                               Info Logic\n    ==============================================================*/\n\n    /**\n     * @notice Getter for a liquidity position's renewal cutoff time\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return renewalCutoffTime renewal cutoff time for all previous loans\n     */\n    function getRenewalCutoffTime(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal view returns (uint32 renewalCutoffTime) {\n        renewalCutoffTime = self[tokenId].renewalCutoffTime;\n    }\n\n    /**\n     * @notice Getter for a liquidity position's tokens currently owed to owner\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return token0Owed The amount of token0 owed to the owner\n     * @return token1Owed The amount of token1 owed to the owner\n     */\n    function getTokensOwed(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal view returns (uint128 token0Owed, uint128 token1Owed) {\n        Info memory info = self[tokenId];\n        token0Owed = info.token0Owed;\n        token1Owed = info.token1Owed;\n    }\n\n    /*=============================================================\n                            Tokens Owed Logic\n    ==============================================================*/\n\n    /**\n     * @notice Update a liquidity positon's owed tokens\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @param token0Owed The amount of token0 owed to the owner to be added\n     * @param token1Owed The amount of token1 owed to the owner to be added\n     */\n    function addTokensOwed(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint128 token0Owed,\n        uint128 token1Owed\n    ) internal {\n        Info storage info = self[tokenId];\n        info.token0Owed += token0Owed;\n        info.token1Owed += token1Owed;\n    }\n\n    /**\n     * @notice Reset a liquidity positon's owed tokens to 0\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     */\n    function resetTokensOwed(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        Info storage info = self[tokenId];\n        info.token0Owed = 0;\n        info.token1Owed = 0;\n    }\n\n    /*=============================================================\n                           Renewal Time Logic\n    ==============================================================*/\n\n    /**\n     * @notice Update a liquidity positon's renewal cutoff time\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     */\n    function updateRenewalCutoffTime(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        Info storage info = self[tokenId];\n        info.renewalCutoffTime = uint32(block.timestamp);\n    }\n\n    /*=============================================================\n                               Mint Logic\n    ==============================================================*/\n\n    /**\n     * @notice Supply liquidity to mint position NFT to the contract\n     * @param self The mapping containing all liquidity positions\n     * @param params mint parameters containing token pairs, fee, tick info and amount to mint\n     * @return tokenId newly minted tokenId\n     * @return liquidity amount of liquidity minted\n     * @return amount0Minted amount of token 0 minted\n     * @return amount1Minted amount of token 1 minted\n     */\n\n    function mint(\n        mapping(uint256 => Info) storage self,\n        DataStruct.MintParams calldata params\n    ) internal returns (uint256 tokenId, uint128 liquidity, uint256 amount0Minted, uint256 amount1Minted) {\n        // transfer in the tokens\n        TransferHelper.safeTransferFrom(params.token0, msg.sender, address(this), params.amount0ToMint);\n        TransferHelper.safeTransferFrom(params.token1, msg.sender, address(this), params.amount1ToMint);\n\n        // approve position manager to spend the tokens\n        TransferHelper.safeApprove(params.token0, Base.UNI_POSITION_MANAGER_ADDR, params.amount0ToMint);\n        TransferHelper.safeApprove(params.token1, Base.UNI_POSITION_MANAGER_ADDR, params.amount1ToMint);\n\n        // mint the position\n        (tokenId, liquidity, amount0Minted, amount1Minted) = Base.UNI_POSITION_MANAGER.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: params.token0,\n                token1: params.token1,\n                fee: params.fee,\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                amount0Desired: params.amount0ToMint,\n                amount1Desired: params.amount1ToMint,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        // create the LP position\n        self[tokenId] = LiquidityPosition.Info({owner: msg.sender, renewalCutoffTime: 0, token0Owed: 0, token1Owed: 0});\n\n        // reset the approval\n        TransferHelper.safeApprove(params.token0, Base.UNI_POSITION_MANAGER_ADDR, 0);\n        TransferHelper.safeApprove(params.token1, Base.UNI_POSITION_MANAGER_ADDR, 0);\n\n        // refund if necessary\n        Base.refund(msg.sender, params.token0, params.amount0ToMint, amount0Minted);\n        Base.refund(msg.sender, params.token1, params.amount1ToMint, amount1Minted);\n\n        emit SupplyLiquidity(tokenId, msg.sender, liquidity);\n    }\n\n    /*=============================================================\n                        Increase Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Increase liquidity to a liquidity position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param token0 The address of token0\n     * @param token1 The address of token1\n     * @param tokenId The token id of the liquidity position NFT\n     * @param amount0 The amount of token0 to add to the liquidity position\n     * @param amount1 The amount of token1 to add to the liquidity position\n     * @return liquidity The amount of liquidity added\n     * @return amount0Added The amount of token0 added\n     * @return amount1Added The amount of token1 added\n     */\n    function increaseLiquidity(\n        address token0,\n        address token1,\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        // approve spending for uniswap's position manager\n        TransferHelper.safeApprove(token0, Base.UNI_POSITION_MANAGER_ADDR, amount0);\n        TransferHelper.safeApprove(token1, Base.UNI_POSITION_MANAGER_ADDR, amount1);\n\n        // increase liquidity via position manager\n        (liquidity, amount0Added, amount1Added) = Base.UNI_POSITION_MANAGER.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: tokenId,\n                amount0Desired: amount0,\n                amount1Desired: amount1,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        // reset approval\n        TransferHelper.safeApprove(token0, Base.UNI_POSITION_MANAGER_ADDR, 0);\n        TransferHelper.safeApprove(token1, Base.UNI_POSITION_MANAGER_ADDR, 0);\n    }\n\n    /**\n     * @notice Increase liquidity of a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param amount0 amount to add for token 0\n     * @param amount1 amount to add for token 1\n     * @return liquidity amount of liquidity added\n     * @return amount0Added amount of token 0 added\n     * @return amount1Added amount of token 1 added\n     */\n    function increaseLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n\n        // get token0 and token1 from the position NFT\n        (, , address token0, address token1, , , , , , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n\n        // transfer in liquidity to add\n        TransferHelper.safeTransferFrom(token0, msg.sender, address(this), amount0);\n        TransferHelper.safeTransferFrom(token1, msg.sender, address(this), amount1);\n\n        // add liquidity\n        (liquidity, amount0Added, amount1Added) = increaseLiquidity(token0, token1, tokenId, amount0, amount1);\n\n        // refund if necessary\n        Base.refund(msg.sender, token0, amount0, amount0Added);\n        Base.refund(msg.sender, token1, amount1, amount1Added);\n\n        emit IncreaseLiquidity(tokenId, liquidity);\n    }\n\n    /*=============================================================\n                        Decrease Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Decrease liquidity from an existing position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount to decrease\n     * @return amount0 amount decreased for token0\n     * @return amount1 amount decreased for token1\n     */\n    function decreaseLiquidity(uint256 tokenId, uint128 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.UNI_POSITION_MANAGER.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n    }\n\n    /**\n     * @notice Decrease liquidity from a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount of liquidity to add\n     * @return amount0Decreased amount of token 0 decreased\n     * @return amount1Decreased amount of token 1 decreased\n     */\n    function decreaseLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint128 liquidity\n    ) internal returns (uint256 amount0Decreased, uint256 amount1Decreased) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        (amount0Decreased, amount1Decreased) = decreaseLiquidity(tokenId, liquidity);\n        emit DecreaseLiquidity(tokenId, liquidity);\n    }\n\n    /*=============================================================\n                        Collect Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Collect fees from a position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param amount0Max maximum amount of token0 to collect\n     * @param amount1Max maximum amount of token1 to collect\n     * @param recipient the address to collect the liquidity\n     * @return amount0 amount collected for token0\n     * @return amount1 amount collected for token1\n     */\n    function collectLiquidity(\n        uint256 tokenId,\n        uint128 amount0Max,\n        uint128 amount1Max,\n        address recipient\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.UNI_POSITION_MANAGER.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: recipient,\n                amount0Max: amount0Max,\n                amount1Max: amount1Max\n            })\n        );\n    }\n\n    /**\n     * @notice Collect fees from a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @return amount0Collected amount of fees collected in token 0\n     * @return amount1Collected amount of fees collected in token 1\n     */\n    function collectLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal returns (uint256 amount0Collected, uint256 amount1Collected) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        (amount0Collected, amount1Collected) = LiquidityPosition.collectLiquidity(\n            tokenId,\n            type(uint128).max,\n            type(uint128).max,\n            msg.sender\n        );\n        (uint128 token0Owed, uint128 token1Owed) = getTokensOwed(self, tokenId);\n        resetTokensOwed(self, tokenId);\n        (, , address token0, address token1, , , , , , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n        if (token0Owed > 0) {\n            amount0Collected += token0Owed;\n            TransferHelper.safeTransfer(token0, msg.sender, token0Owed);\n        }\n        if (token1Owed > 0) {\n            amount1Collected += token1Owed;\n            TransferHelper.safeTransfer(token1, msg.sender, token1Owed);\n        }\n\n        emit CollectLiquidity(msg.sender, token0, token1, amount0Collected, amount1Collected);\n    }\n\n    /*=============================================================\n                         Reclaim Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice LP reclaims borrowed liquidity from being renewed\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     */\n    function reclaimLiquidity(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        updateRenewalCutoffTime(self, tokenId);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LiquidityPosition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport {INonfungiblePositionManager} from \"../interfaces/INonfungiblePositionManager.sol\";\nimport {DataStruct} from \"./Structs.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {Base} from \"./Base.sol\";\n\n/// @title Liquidity Position\n/// @notice Represents a liquidity position's underlying owner and fee tokens accrued from lending\nlibrary LiquidityPosition {\n    struct Info {\n        address owner;\n        uint32 renewalCutoffTime; ///@dev loans before this time can't be renewed\n        uint128 token0Owed;\n        uint128 token1Owed;\n    }\n\n    event SupplyLiquidity(uint256 tokenId, address lp, uint128 liquidity);\n    event IncreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event DecreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event CollectLiquidity(address lp, address token0, address token1, uint256 amount0, uint256 amount1);\n\n    /*=============================================================\n                               Info Logic\n    ==============================================================*/\n\n    /**\n     * @notice Getter for a liquidity position's renewal cutoff time\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return renewalCutoffTime renewal cutoff time for all previous loans\n     */\n    function getRenewalCutoffTime(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal view returns (uint32 renewalCutoffTime) {\n        renewalCutoffTime = self[tokenId].renewalCutoffTime;\n    }\n\n    /**\n     * @notice Getter for a liquidity position's tokens currently owed to owner\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return token0Owed The amou"
    }
  ]
}