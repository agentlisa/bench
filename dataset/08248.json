{
  "Title": "[1] contracts/mixins/collections/CollectionRoyalties.sol",
  "Content": "\nOn line [80](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/collections/CollectionRoyalties.sol#L80), `supportsInterface` can be rewritten to avoid the `if/esle` branching:\n\n```solidity\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool interfaceSupported) {\n\treturn (\n\t\tinterfaceId == type(IRoyaltyInfo).interfaceId ||\n\t\tinterfaceId == type(ITokenCreator).interfaceId ||\n\t\tinterfaceId == type(IGetRoyalties).interfaceId ||\n\t\tinterfaceId == type(IGetFees).interfaceId ||\n\t\tsuper.supportsInterface(interfaceId)\n\t);\n}\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-08-foundation",
  "Code": [
    {
      "filename": "contracts/mixins/collections/CollectionRoyalties.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\nimport \"../../interfaces/IGetFees.sol\";\nimport \"../../interfaces/IGetRoyalties.sol\";\nimport \"../../interfaces/IRoyaltyInfo.sol\";\nimport \"../../interfaces/ITokenCreator.sol\";\n\nimport \"../shared/Constants.sol\";\n\n/**\n * @title Defines various royalty APIs for broad marketplace support.\n */\nabstract contract CollectionRoyalties is IGetRoyalties, IGetFees, IRoyaltyInfo, ITokenCreator, ERC165Upgradeable {\n  /**\n   * @inheritdoc IGetFees\n   */\n  function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory recipients) {\n    recipients = new address payable[](1);\n    recipients[0] = getTokenCreatorPaymentAddress(tokenId);\n  }\n\n  /**\n   * @inheritdoc IGetFees\n   * @dev The tokenId param is ignored since all NFTs return the same value.\n   */\n  function getFeeBps(\n    uint256 /* tokenId */\n  ) external pure returns (uint256[] memory royaltiesInBasisPoints) {\n    royaltiesInBasisPoints = new uint256[](1);\n    royaltiesInBasisPoints[0] = ROYALTY_IN_BASIS_POINTS;\n  }\n\n  /**\n   * @inheritdoc IGetRoyalties\n   */\n  function getRoyalties(uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory royaltiesInBasisPoints)\n  {\n    recipients = new address payable[](1);\n    recipients[0] = getTokenCreatorPaymentAddress(tokenId);\n    royaltiesInBasisPoints = new uint256[](1);\n    royaltiesInBasisPoints[0] = ROYALTY_IN_BASIS_POINTS;\n  }\n\n  /**\n   * @notice The address to pay the creator proceeds/royalties for the collection.\n   * @param tokenId The ID of the NFT to get the creator payment address for.\n   * @return creatorPaymentAddress The address to which royalties should be paid.\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    virtual\n    returns (address payable creatorPaymentAddress);\n\n  /**\n   * @inheritdoc IRoyaltyInfo\n   */\n  function royaltyInfo(uint256 tokenId, uint256 salePrice)\n    external\n    view\n    returns (address receiver, uint256 royaltyAmount)\n  {\n    receiver = getTokenCreatorPaymentAddress(tokenId);\n    unchecked {\n      royaltyAmount = salePrice / ROYALTY_RATIO;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   * @dev Checks the supported royalty interfaces.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool interfaceSupported) {\n    if (\n      interfaceId == type(IRoyaltyInfo).interfaceId ||\n      interfaceId == type(ITokenCreator).interfaceId ||\n      interfaceId == type(IGetRoyalties).interfaceId ||\n      interfaceId == type(IGetFees).interfaceId\n    ) {\n      interfaceSupported = true;\n    } else {\n      interfaceSupported = super.supportsInterface(interfaceId);\n    }\n  }\n}"
    }
  ]
}