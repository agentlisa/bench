{
  "Title": "M-10: `AssetManager.rebalance()` will revert when the balance of `tokenAddress` in the money market is 0.",
  "Content": "# Issue M-10: `AssetManager.rebalance()` will revert when the balance of `tokenAddress` in the money market is 0. \n\nSource: https://github.com/sherlock-audit/2022-10-union-finance-judging/issues/75 \n\n## Found by \nhansfriese, ctf\\_sec\n\n## Summary\n`AssetManager.rebalance()` will revert when the balance of `tokenAddress` in the money market is 0.\n\n## Vulnerability Detail\n[AssetManager.rebalance()](https://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/asset/AssetManager.sol#L497) tries to withdraw tokens from each money market for rebalancing [here](https://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/asset/AssetManager.sol#L510-L518).\n\n```solidity\n    // Loop through each money market and withdraw all the tokens\n    for (uint256 i = 0; i < moneyMarketsLength; i++) {\n        IMoneyMarketAdapter moneyMarket = moneyMarkets[i];\n        if (!moneyMarket.supportsToken(tokenAddress)) continue;\n        moneyMarket.withdrawAll(tokenAddress, address(this));\n\n        supportedMoneyMarkets[supportedMoneyMarketsSize] = moneyMarket;\n        supportedMoneyMarketsSize++;\n    }\n```\n\nWhen the balance of the `tokenAddress` is 0, we don't need to call `moneyMarket.withdrawAll()` but it still tries to call.\n\nBut this will revert because Aave V3 doesn't allow to withdraw 0 amount [here](https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/logic/ValidationLogic.sol#L87-L92).\n\n```solidity\n  function validateWithdraw(\n    DataTypes.ReserveCache memory reserveCache,\n    uint256 amount,\n    uint256 userBalance\n  ) internal pure {\n    require(amount != 0, Errors.INVALID_AMOUNT);\n```\n\nSo `AssetManager.rebalance()` will revert if one money market has zero balance of `tokenAddress`.\n\n## Impact\nThe money markets can't be rebalanced if there is no balance in at least one market.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/asset/AssetManager.sol#L514\n\n## Tool used\nManual Review\n\n## Recommendation\nI think we can modify [AaveV3Adapter.withdrawAll()](https://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/asset/AaveV3Adapter.sol#L226) to work only when the balance is positive.\n\n```solidity\n    function withdrawAll(address tokenAddress, address recipient)\n        external\n        override\n        onlyAssetManager\n        checkTokenSupported(tokenAddress)\n    {\n        address aTokenAddress = tokenToAToken[tokenAddress];\n        IERC20Upgradeable aToken = IERC20Upgradeable(aTokenAddress);\n        uint256 balance = aToken.balanceOf(address(this));\n\n        if (balance > 0) {\n            lendingPool.withdraw(tokenAddress, type(uint256).max, recipient);\n        }\n    }\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/11",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/asset/AssetManager.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {Controller} from \"../Controller.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IMarketRegistry} from \"../interfaces/IMarketRegistry.sol\";\nimport {IMoneyMarketAdapter} from \"../interfaces/IMoneyMarketAdapter.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/**\n *  @title AssetManager\n *  @author Union\n *  @dev  Manage the token assets deposited by components and admins, and invest\n *        tokens to the integrated underlying lending protocols.\n */\ncontract AssetManager is Controller, ReentrancyGuardUpgradeable, IAssetManager {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Address of market registry\n     */\n    address public marketRegistry;\n\n    /**\n     * @dev Withdraw Seuqence\n     * @dev Priority sequence of money market indices for processing withdraws\n     */\n    uint256[] public withdrawSeq;\n\n    /**\n     * @dev Record admin or userManager balance\n     * @dev Maps user to token to balance\n     */\n    mapping(address => mapping(address => uint256)) public balances;\n\n    /**\n     * @dev Total balance of a token\n     * @dev Maps token to balance (deposited)\n     */\n    mapping(address => uint256) public totalPrincipal;\n\n    /**\n     * @dev Supported markets\n     * @dev Mapping of tokens to boolean (isSupported)\n     */\n    mapping(address => bool) public supportedMarkets;\n\n    /**\n     * @dev Money Market Adapters\n     */\n    IMoneyMarketAdapter[] public moneyMarkets;\n\n    /**\n     * @dev Supported tokens\n     */\n    address[] public supportedTokensList;\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Emit when making a deposit\n     *  @param token Depositing token address\n     *  @param account Account address\n     *  @param amount Deposit amount, in wei\n     */\n    event LogDeposit(address indexed token, address indexed account, uint256 amount);\n    /**\n     *  @dev Emit when withdrawing from AssetManager\n     *  @param token Depositing token address\n     *  @param account Account address\n     *  @param amount Withdraw amount, in wei\n     *  @param remaining The amount cannot be withdrawn\n     */\n    event LogWithdraw(address indexed token, address indexed account, uint256 amount, uint256 remaining);\n    /**\n     *  @dev Emit when rebalancing among the integrated money markets\n     *  @param tokenAddress The address of the token to be rebalanced\n     *  @param percentages Array of the percentages of the tokens to deposit to the money markets\n     */\n    event LogRebalance(address tokenAddress, uint256[] percentages);\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error UnsupportedToken();\n    error AuthFailed();\n    error NotParity();\n    error AmountZero();\n    error InsufficientBalance();\n    error TokenExists();\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __AssetManager_init(address _marketRegistry) external initializer {\n        Controller.__Controller_init(msg.sender);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        marketRegistry = _marketRegistry;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier checkMarketSupported(address token) {\n        if (!isMarketSupported(token)) revert UnsupportedToken();\n        _;\n    }\n\n    modifier onlyAuth(address token) {\n        if (!(_isUToken(msg.sender, token) || _isUserManager(msg.sender, token))) revert AuthFailed();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    function setMarketRegistry(address _marketRegistry) external onlyAdmin {\n        marketRegistry = _marketRegistry;\n    }\n\n    /**\n     *  @dev Set withdraw sequence\n     *  @param newSeq priority sequence of money market indices to be used while withdrawing\n     */\n    function setWithdrawSequence(uint256[] calldata newSeq) external override onlyAdmin {\n        if (newSeq.length != withdrawSeq.length) revert NotParity();\n        withdrawSeq = newSeq;\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Get the balance of asset manager, plus the total amount of tokens deposited to all the underlying lending protocols\n     *  @param tokenAddress ERC20 token address\n     *  @return Pool balance\n     */\n    function getPoolBalance(address tokenAddress) public view override returns (uint256) {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);\n        uint256 balance = poolToken.balanceOf(address(this));\n        if (isMarketSupported(tokenAddress)) {\n            return totalSupplyView(tokenAddress) + balance;\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     *  @dev Returns the amount of the lending pool balance minus the amount of total staked.\n     *  @param tokenAddress ERC20 token address\n     *  @return loanAmount Amount can be borrowed\n     */\n    function getLoanableAmount(address tokenAddress) public view override returns (uint256) {\n        uint256 poolBalance = getPoolBalance(tokenAddress);\n        return poolBalance > totalPrincipal[tokenAddress] ? poolBalance - totalPrincipal[tokenAddress] : 0;\n    }\n\n    /**\n     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols without side effects.\n     *  @param tokenAddress ERC20 token address\n     *  @return tokenSupply Total market balance\n     */\n    function totalSupply(address tokenAddress) external override returns (uint256) {\n        uint256 tokenSupply = 0;\n        if (isMarketSupported(tokenAddress)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            for (uint256 i = 0; i < moneyMarketsLength; i++) {\n                if (moneyMarkets[i].supportsToken(tokenAddress)) {\n                    tokenSupply += moneyMarkets[i].getSupply(tokenAddress);\n                }\n            }\n        }\n        return tokenSupply;\n    }\n\n    /**\n     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols, but without side effects. Safe to call anytime, but may not get the most updated number for the current block. Call totalSupply() for that purpose.\n     *  @param tokenAddress ERC20 token address\n     *  @return tokenSupply Total market balance\n     */\n    function totalSupplyView(address tokenAddress) public view override returns (uint256) {\n        uint256 tokenSupply = 0;\n        if (isMarketSupported(tokenAddress)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            for (uint256 i = 0; i < moneyMarketsLength; i++) {\n                if (moneyMarkets[i].supportsToken(tokenAddress)) {\n                    tokenSupply += moneyMarkets[i].getSupplyView(tokenAddress);\n                }\n            }\n        }\n        return tokenSupply;\n    }\n\n    /**\n     *  @dev Check if there is an underlying protocol available for the given ERC20 token.\n     *  @param tokenAddress ERC20 token address\n     *  @return Whether is supported\n     */\n    function isMarketSupported(address tokenAddress) public view override returns (bool) {\n        return supportedMarkets[tokenAddress];\n    }\n\n    /**\n     *  @dev Get the number of supported underlying protocols.\n     *  @return MoneyMarkets length\n     */\n    function moneyMarketsCount() external view override returns (uint256) {\n        return moneyMarkets.length;\n    }\n\n    /**\n     *  @dev Get the count of supported tokens\n     *  @return Number of supported tokens\n     */\n    function supportedTokensCount() external view override returns (uint256) {\n        return supportedTokensList.length;\n    }\n\n    /**\n     *  @dev Get the supported lending protocol\n     *  @param tokenAddress ERC20 token address\n     *  @param marketId MoneyMarkets array index\n     *  @return rate tokenSupply, rate(compound is supplyRatePerBlock 1e18, aave is supplyRatePerYear 1e27)\n     */\n    function getMoneyMarket(address tokenAddress, uint256 marketId)\n        external\n        view\n        override\n        returns (uint256 rate, uint256 tokenSupply)\n    {\n        rate = moneyMarkets[marketId].getRate(tokenAddress);\n        tokenSupply += moneyMarkets[marketId].getSupplyView(tokenAddress);\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev  Deposit tokens to AssetManager, and those tokens will be passed along to\n     *        adapters to deposit to integrated asset protocols if any is available.\n     *  @param token ERC20 token address\n     *  @param amount ERC20 token address\n     *  @return Deposited amount\n     */\n    function deposit(address token, uint256 amount)\n        external\n        override\n        whenNotPaused\n        onlyAuth(token)\n        nonReentrant\n        returns (bool)\n    {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(token);\n        if (amount == 0) revert AmountZero();\n\n        if (!_isUToken(msg.sender, token)) {\n            balances[msg.sender][token] += amount;\n            totalPrincipal[token] += amount;\n        }\n\n        bool remaining = true;\n        if (isMarketSupported(token)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            // assumption: markets are arranged in order of decreasing liquidity\n            // iterate markets till floors are filled\n            // floors define minimum amount to maintain confidence in liquidity\n            for (uint256 i = 0; i < moneyMarketsLength && remaining; i++) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[i];\n\n                if (!moneyMarket.supportsToken(token)) continue;\n                if (moneyMarket.floorMap(token) <= moneyMarket.getSupply(token)) continue;\n\n                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);\n                moneyMarket.deposit(token);\n                remaining = false;\n            }\n\n            // assumption: less liquid markets provide more yield\n            // iterate markets in reverse to optimize for yield\n            // do this only if floors are filled i.e. min liquidity satisfied\n            // deposit in the market where ceiling is not being exceeded\n            for (uint256 j = moneyMarketsLength; j > 0 && remaining; j--) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[j - 1];\n                if (!moneyMarket.supportsToken(token)) continue;\n\n                uint256 supply = moneyMarket.getSupply(token);\n                uint256 ceiling = moneyMarket.ceilingMap(token);\n                if (supply + amount > ceiling) continue;\n\n                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);\n                moneyMarket.deposit(token);\n                remaining = false;\n            }\n        }\n\n        if (remaining) {\n            poolToken.safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        emit LogDeposit(token, msg.sender, amount);\n\n        return true;\n    }\n\n    /**\n     *  @dev Withdraw from AssetManager\n     *  @param token ERC20 token address\n     *  @param account User address\n     *  @param amount ERC20 token address\n     *  @return Withdraw amount\n     */\n    function withdraw(\n        address token,\n        address account,\n        uint256 amount\n    ) external override whenNotPaused nonReentrant onlyAuth(token) returns (bool) {\n        if (!_checkSenderBalance(msg.sender, token, amount)) revert InsufficientBalance();\n\n        uint256 remaining = amount;\n\n        // If there are tokens in Asset Manager then transfer them on priority\n        uint256 selfBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (selfBalance > 0) {\n            uint256 withdrawAmount = selfBalance < remaining ? selfBalance : remaining;\n            remaining -= withdrawAmount;\n            IERC20Upgradeable(token).safeTransfer(account, withdrawAmount);\n        }\n\n        if (isMarketSupported(token)) {\n            uint256 withdrawSeqLength = withdrawSeq.length;\n            // iterate markets according to defined sequence and withdraw\n            for (uint256 i = 0; i < withdrawSeqLength && remaining > 0; i++) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[withdrawSeq[i]];\n                if (!moneyMarket.supportsToken(token)) continue;\n\n                uint256 supply = moneyMarket.getSupply(token);\n                if (supply == 0) continue;\n\n                uint256 withdrawAmount = supply < remaining ? supply : remaining;\n                remaining -= withdrawAmount;\n                moneyMarket.withdraw(token, account, withdrawAmount);\n            }\n        }\n\n        if (!_isUToken(msg.sender, token)) {\n            balances[msg.sender][token] = balances[msg.sender][token] - amount + remaining;\n            totalPrincipal[token] = totalPrincipal[token] - amount + remaining;\n        }\n\n        emit LogWithdraw(token, account, amount, remaining);\n\n        return true;\n    }\n\n    /**\n     * @dev Write of Debt\n     */\n    function debtWriteOff(address token, uint256 amount) external override {\n        if (balances[msg.sender][token] < amount) revert InsufficientBalance();\n        balances[msg.sender][token] -= amount;\n        totalPrincipal[token] -= amount;\n    }\n\n    /**\n     *  @dev Add a new ERC20 token to support in AssetManager\n     *  @param tokenAddress ERC20 token address\n     */\n    function addToken(address tokenAddress) external override onlyAdmin {\n        if (supportedMarkets[tokenAddress]) revert TokenExists();\n        supportedTokensList.push(tokenAddress);\n        supportedMarkets[tokenAddress] = true;\n\n        approveAllMarketsMax(tokenAddress);\n    }\n\n    /**\n     *  @dev Remove a ERC20 token to support in AssetManager\n     *  @param tokenAddress ERC20 token address\n     */\n    function removeToken(address tokenAddress) external override onlyAdmin {\n        bool isExist = false;\n        uint256 index;\n        uint256 supportedTokensLength = supportedTokensList.length;\n\n        for (uint256 i = 0; i < supportedTokensLength; i++) {\n            if (tokenAddress == address(supportedTokensList[i])) {\n                isExist = true;\n                index = i;\n                break;\n            }\n        }\n\n        if (isExist) {\n            supportedTokensList[index] = supportedTokensList[supportedTokensLength - 1];\n            supportedTokensList.pop();\n            supportedMarkets[tokenAddress] = false;\n        }\n    }\n\n    /**\n     *  @dev Add a new adapter for the underlying lending protocol\n     *  @param adapterAddress adapter address\n     */\n    function addAdapter(address adapterAddress) external override onlyAdmin {\n        bool isExist = false;\n        uint256 moneyMarketsLength = moneyMarkets.length;\n\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            if (adapterAddress == address(moneyMarkets[i])) isExist = true;\n        }\n\n        if (!isExist) {\n            moneyMarkets.push(IMoneyMarketAdapter(adapterAddress));\n            withdrawSeq.push(moneyMarkets.length - 1);\n        }\n\n        approveAllTokensMax(adapterAddress);\n    }\n\n    /**\n     *  @dev Remove a adapter for the underlying lending protocol\n     *  @param adapterAddress adapter address\n     */\n    function removeAdapter(address adapterAddress) external override onlyAdmin {\n        bool isExist = false;\n        uint256 index;\n        uint256 moneyMarketsLength = moneyMarkets.length;\n\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            if (adapterAddress == address(moneyMarkets[i])) {\n                isExist = true;\n                index = i;\n                break;\n            }\n        }\n\n        if (isExist) {\n            moneyMarkets[index] = moneyMarkets[moneyMarketsLength - 1];\n            moneyMarkets.pop();\n        }\n    }\n\n    /**\n     *  @dev For a give token set allowance for all integrated money markets\n     *  @param tokenAddress ERC20 token address\n     */\n    function approveAllMarketsMax(address tokenAddress) public override onlyAdmin {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);\n        uint256 moneyMarketsLength = moneyMarkets.length;\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            poolToken.safeApprove(address(moneyMarkets[i]), 0);\n            poolToken.safeApprove(address(moneyMarkets[i]), type(uint256).max);\n        }\n    }\n\n    /**\n     *  @dev For a give moeny market set allowance for all underlying tokens\n     *  @param adapterAddress Address of adaptor for money market\n     */\n    function approveAllTokensMax(address adapterAddress) public override onlyAdmin {\n        uint256 supportedTokensLength = supportedTokensList.length;\n        for (uint256 i = 0; i < supportedTokensLength; i++) {\n            IERC20Upgradeable poolToken = IERC20Upgradeable(supportedTokensList[i]);\n            poolToken.safeApprove(adapterAddress, 0);\n            poolToken.safeApprove(adapterAddress, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Take all the supply of `tokenAddress` and redistribute it according to `percentages`.\n     *\n     * Rejects if the token is not supported.\n     *\n     * @param tokenAddress Address of the token that is going to be rebalanced\n     * @param percentages A list of percentages, expressed as units in 10000, indicating how to deposit the tokens in\n     * each underlying money market. The length of this array is one less than the amount of money markets: the last\n     * money market will receive the remaining tokens. For example, if there are 3 money markets, and you want to\n     * rebalance so that the first one has 10.5% of the tokens, the second one 55%, and the third one 34.5%, this param\n     * will be [1050, 5500].\n     */\n    function rebalance(address tokenAddress, uint256[] calldata percentages)\n        external\n        override\n        onlyAdmin\n        checkMarketSupported(tokenAddress)\n    {\n        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n        uint256 moneyMarketsLength = moneyMarkets.length;\n        uint256 percentagesLength = percentages.length;\n\n        IMoneyMarketAdapter[] memory supportedMoneyMarkets = new IMoneyMarketAdapter[](moneyMarketsLength);\n        uint256 supportedMoneyMarketsSize;\n\n        // Loop through each money market and withdraw all the tokens\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            IMoneyMarketAdapter moneyMarket = moneyMarkets[i];\n            if (!moneyMarket.supportsToken(tokenAddress)) continue;\n            moneyMarket.withdrawAll(tokenAddress, address(this));\n\n            supportedMoneyMarkets[supportedMoneyMarketsSize] = moneyMarket;\n            supportedMoneyMarketsSize++;\n        }\n\n        if (percentagesLength + 1 != supportedMoneyMarketsSize) revert NotParity();\n\n        uint256 tokenSupply = token.balanceOf(address(this));\n\n        for (uint256 i = 0; i < percentagesLength; i++) {\n            IMoneyMarketAdapter moneyMarket = supportedMoneyMarkets[i];\n            uint256 amountToDeposit = (tokenSupply * percentages[i]) / 10000;\n            if (amountToDeposit == 0) continue;\n            token.safeTransfer(address(moneyMarket), amountToDeposit);\n            moneyMarket.deposit(tokenAddress);\n        }\n\n        uint256 remainingTokens = token.balanceOf(address(this));\n\n        IMoneyMarketAdapter lastMoneyMarket = supportedMoneyMarkets[supportedMoneyMarketsSize - 1];\n        if (remainingTokens > 0) {\n            token.safeTransfer(address(lastMoneyMarket), remainingTokens);\n            lastMoneyMarket.deposit(tokenAddress);\n        }\n\n        emit LogRebalance(tokenAddress, percentages);\n    }\n\n    /* -------------------------------------------------------------------\n      Internal Functions \n    ------------------------------------------------------------------- */\n\n    function _checkSenderBalance(\n        address sender,\n        address tokenAddress,\n        uint256 amount\n    ) private view returns (bool) {\n        if (_isUToken(sender, tokenAddress)) {\n            // For all the lending markets, which have no deposits, return the tokens from the pool\n            return getLoanableAmount(tokenAddress) >= amount;\n        }\n\n        return balances[sender][tokenAddress] >= amount;\n    }\n\n    function _isUToken(address sender, address token) private view returns (bool) {\n        return IMarketRegistry(marketRegistry).uTokens(token) == sender;\n    }\n\n    function _isUserManager(address sender, address token) private view returns (bool) {\n        return IMarketRegistry(marketRegistry).userManagers(token) == sender;\n    }\n}"
    },
    {
      "filename": "contracts/protocol/libraries/logic/ValidationLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {Address} from '../../../dependencies/openzeppelin/contracts/Address.sol';\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {IReserveInterestRateStrategy} from '../../../interfaces/IReserveInterestRateStrategy.sol';\nimport {IStableDebtToken} from '../../../interfaces/IStableDebtToken.sol';\nimport {IScaledBalanceToken} from '../../../interfaces/IScaledBalanceToken.sol';\nimport {IPriceOracleGetter} from '../../../interfaces/IPriceOracleGetter.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {IPriceOracleSentinel} from '../../../interfaces/IPriceOracleSentinel.sol';\nimport {IPoolAddressesProvider} from '../../../interfaces/IPoolAddressesProvider.sol';\nimport {IAccessControl} from '../../../dependencies/openzeppelin/contracts/IAccessControl.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {GenericLogic} from './GenericLogic.sol';\nimport {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {IncentivizedERC20} from '../../tokenization/base/IncentivizedERC20.sol';\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeCast for uint256;\n  using GPv2SafeERC20 for IERC20;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using Address for address;\n\n  // Factor to apply to \"only-variable-debt\" liquidity rate to get threshold for rebalancing, expressed in bps\n  // A value of 0.9e4 results in 90%\n  uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 0.9e4;\n\n  // Minimum health factor allowed under any circumstance\n  // A value of 0.95e18 results in 0.95\n  uint256 public constant MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 0.95e18;\n\n  /**\n   * @dev Minimum health factor to consider a user position healthy\n   * A value of 1e18 results in 1\n   */\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18;\n\n  /**\n   * @dev Role identifier for the role allowed to supply isolated reserves as collateral\n   */\n  bytes32 public constant ISOLATED_COLLATERAL_SUPPLIER_ROLE =\n    keccak256('ISOLATED_COLLATERAL_SUPPLIER');\n\n  /**\n   * @notice Validates a supply action.\n   * @param reserveCache The cached data of the reserve\n   * @param amount The amount to be supplied\n   */\n  function validateSupply(\n    DataTypes.ReserveCache memory reserveCache,\n    DataTypes.ReserveData storage reserve,\n    uint256 amount\n  ) internal view {\n    require(amount != 0, Errors.INVALID_AMOUNT);\n\n    (bool isActive, bool isFrozen, , , bool isPaused) = reserveCache\n      .reserveConfiguration\n      .getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n    require(!isFrozen, Errors.RESERVE_FROZEN);\n\n    uint256 supplyCap = reserveCache.reserveConfiguration.getSupplyCap();\n    require(\n      supplyCap == 0 ||\n        ((IAToken(reserveCache.aTokenAddress).scaledTotalSupply() +\n          uint256(reserve.accruedToTreasury)).rayMul(reserveCache.nextLiquidityIndex) + amount) <=\n        supplyCap * (10 ** reserveCache.reserveConfiguration.getDecimals()),\n      Errors.SUPPLY_CAP_EXCEEDED\n    );\n  }\n\n  /**\n   * @notice Validates a withdraw action.\n   * @param reserveCache The cached data of the reserve\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   */\n  function validateWithdraw(\n    DataTypes.ReserveCache memory reserveCache,\n    uint256 amount,\n    uint256 userBalance\n  ) internal pure {\n    require(amount != 0, Errors.INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 currentLtv;\n    uint256 collateralNeededInBaseCurrency;\n    uint256 userCollateralInBaseCurrency;\n    uint256 userDebtInBaseCurrency;\n    uint256 availableLiquidity;\n    uint256 healthFactor;\n    uint256 totalDebt;\n    uint256 totalSupplyVariableDebt;\n    uint256 reserveDecimals;\n    uint256 borrowCap;\n    uint256 amountInBaseCurrency;\n    uint256 assetUnit;\n    address eModePriceSource;\n    address siloedBorrowingAddress;\n    bool isActive;\n    bool isFrozen;\n    bool isPaused;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n    bool siloedBorrowingEnabled;\n  }\n\n  /**\n   * @notice Validates a borrow action.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param params Additional params needed for the validation\n   */\n  function validateBorrow(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.ValidateBorrowParams memory params\n  ) internal view {\n    require(params.amount != 0, Errors.INVALID_AMOUNT);\n\n    ValidateBorrowLocalVars memory vars;\n\n    (\n      vars.isActive,\n      vars.isFrozen,\n      vars.borrowingEnabled,\n      vars.stableRateBorrowingEnabled,\n      vars.isPaused\n    ) = params.reserveCache.reserveConfiguration.getFlags();\n\n    require(vars.isActive, Errors.RESERVE_INACTIVE);\n    require(!vars.isPaused, Errors.RESERVE_PAUSED);\n    require(!vars.isFrozen, Errors.RESERVE_FROZEN);\n    require(vars.borrowingEnabled, Errors.BORROWING_NOT_ENABLED);\n\n    require(\n      params.priceOracleSentinel == address(0) ||\n        IPriceOracleSentinel(params.priceOracleSentinel).isBorrowAllowed(),\n      Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n    );\n\n    //validate interest rate mode\n    require(\n      params.interestRateMode == DataTypes.InterestRateMode.VARIABLE ||\n        params.interestRateMode == DataTypes.InterestRateMode.STABLE,\n      Errors.INVALID_INTEREST_RATE_MODE_SELECTED\n    );\n\n    vars.reserveDecimals = params.reserveCache.reserveConfiguration.getDecimals();\n    vars.borrowCap = params.reserveCache.reserveConfiguration.getBorrowCap();\n    unchecked {\n      vars.assetUnit = 10 ** vars.reserveDecimals;\n    }\n\n    if (vars.borrowCap != 0) {\n      vars.totalSupplyVariableDebt = params.reserveCache.currScaledVariableDebt.rayMul(\n        params.reserveCache.nextVariableBorrowIndex\n      );\n\n      vars.totalDebt =\n        params.reserveCache.currTotalStableDebt +\n        vars.totalSupplyVariableDebt +\n        params.amount;\n\n      unchecked {\n        require(vars.totalDebt <= vars.borrowCap * vars.assetUnit, Errors.BORROW_CAP_EXCEEDED);\n      }\n    }\n\n    if (params.isolationModeActive) {\n      // check that the asset being borrowed is borrowable in isolation mode AND\n      // the total exposure is no bigger than the collateral debt ceiling\n      require(\n        params.reserveCache.reserveConfiguration.getBorrowableInIsolation(),\n        Errors.ASSET_NOT_BORROWABLE_IN_ISOLATION\n      );\n\n      require(\n        reservesData[params.isolationModeCollateralAddress].isolationModeTotalDebt +\n          (params.amount /\n            10 ** (vars.reserveDecimals - ReserveConfiguration.DEBT_CEILING_DECIMALS))\n            .toUint128() <=\n          params.isolationModeDebtCeiling,\n        Errors.DEBT_CEILING_EXCEEDED\n      );\n    }\n\n    if (params.userEModeCategory != 0) {\n      require(\n        params.reserveCache.reserveConfiguration.getEModeCategory() == params.userEModeCategory,\n        Errors.INCONSISTENT_EMODE_CATEGORY\n      );\n      vars.eModePriceSource = eModeCategories[params.userEModeCategory].priceSource;\n    }\n\n    (\n      vars.userCollateralInBaseCurrency,\n      vars.userDebtInBaseCurrency,\n      vars.currentLtv,\n      ,\n      vars.healthFactor,\n\n    ) = GenericLogic.calculateUserAccountData(\n      reservesData,\n      reservesList,\n      eModeCategories,\n      DataTypes.CalculateUserAccountDataParams({\n        userConfig: params.userConfig,\n        reservesCount: params.reservesCount,\n        user: params.userAddress,\n        oracle: params.oracle,\n        userEModeCategory: params.userEModeCategory\n      })\n    );\n\n    require(vars.userCollateralInBaseCurrency != 0, Errors.COLLATERAL_BALANCE_IS_ZERO);\n    require(vars.currentLtv != 0, Errors.LTV_VALIDATION_FAILED);\n\n    require(\n      vars.healthFactor > HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    vars.amountInBaseCurrency =\n      IPriceOracleGetter(params.oracle).getAssetPrice(\n        vars.eModePriceSource != address(0) ? vars.eModePriceSource : params.asset\n      ) *\n      params.amount;\n    unchecked {\n      vars.amountInBaseCurrency /= vars.assetUnit;\n    }\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    vars.collateralNeededInBaseCurrency = (vars.userDebtInBaseCurrency + vars.amountInBaseCurrency)\n      .percentDiv(vars.currentLtv); //LTV is calculated in percentage\n\n    require(\n      vars.collateralNeededInBaseCurrency <= vars.userCollateralInBaseCurrency,\n      Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW\n    );\n\n    /**\n     * Following conditions need to be met if the user is borrowing at a stable rate:\n     * 1. Reserve must be enabled for stable rate borrowing\n     * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\n     *    they are borrowing, to prevent abuses.\n     * 3. Users will be able to borrow only a portion of the total available liquidity\n     */\n\n    if (params.interestRateMode == DataTypes.InterestRateMode.STABLE) {\n      //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\n\n      require(vars.stableRateBorrowingEnabled, Errors.STABLE_BORROWING_NOT_ENABLED);\n\n      require(\n        !params.userConfig.isUsingAsCollateral(reservesData[params.asset].id) ||\n          params.reserveCache.reserveConfiguration.getLtv() == 0 ||\n          params.amoun"
    }
  ]
}