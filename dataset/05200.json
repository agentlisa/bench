{
  "Title": "[M-09] Missing hook call will lead to incorrect oracle results",
  "Content": "\nThe HydraDx protocol includes an oracle. This oracle generates prices, based upon the information it receives from its sources (of which Omnipool is one). The Omnipool provides information to the oracle through the `on_liquidity_changed` and `on_trade` hooks. Whenever a trade happens or the liquidity in one of the pools changes the corresponding hooks need to be called with the updated values.\n\nThe Omnipool contract also includes the `remove_token()` function. This function can only be called by the authority and can be only called on an asset which is FROZEN and where all the liquidity shares are owned by the protocol.\n\n```rust\nensure!(asset_state.tradable == Tradability::FROZEN, Error::<T>::AssetNotFrozen);\nensure!(\n\tasset_state.shares == asset_state.protocol_shares,\n\tError::<T>::SharesRemaining\n);\n```\n\nWhen the function gets called it transfers all remaining liquidity to the beneficiary and removes the token. This is a change in liquidity in the Omnipool. The functionality in terms of liquidity change is similar to the `withdraw_protocol_liquidity()` where the protocol also withdraws liquidity in the form of `protocol_shares` from the pool. When looking at the `withdraw_protocol_liquidity()` function, one can see that it calls the `on_liquidity_changed` hook at the end, so that the oracle receives the information about the liquidity change.\n\n```rust\nT::OmnipoolHooks::on_liquidity_changed(origin, info)?;\n```\n\nUnfortunately, the  `remove_token()` function does not call this hook, keeping the oracle in an outdated state. As the token is removed later on, the oracle will calculate based on liquidity that does not exist anymore in the Omnipool.\n\n### Impact\n\nThe issue results in the oracle receiving incorrect information and calculating new prices, based on an outdated state of the Omnipool.\n\n### Proof of Concept\n\nThe issue can be viewed when looking at the code of `remove_token()` where one can see that no call to the hook happens:\n\n```rust\n#[pallet::call_index(12)]\n#[pallet::weight(<T as Config>::WeightInfo::remove_token())]\n#[transactional]\npub fn remove_token(origin: OriginFor<T>, asset_id: T::AssetId, beneficiary: T::AccountId) -> DispatchResult {\n\tT::AuthorityOrigin::ensure_origin(origin)?;\n\tlet asset_state = Self::load_asset_state(asset_id)?;\n\n\t// Allow only if no shares are owned by LPs and the asset is frozen.\n\tensure!(asset_state.tradable == Tradability::FROZEN, Error::<T>::AssetNotFrozen);\n\tensure!(\n\t\tasset_state.shares == asset_state.protocol_shares,\n\t\tError::<T>::SharesRemaining\n\t);\n\t// Imbalance update\n\tlet imbalance = <HubAssetImbalance<T>>::get();\n\tlet hub_asset_liquidity = Self::get_hub_asset_balance_of_protocol_account();\n\tlet delta_imbalance = hydra_dx_math::omnipool::calculate_delta_imbalance(\n\t\tasset_state.hub_reserve,\n\t\tI129 {\n\t\t\tvalue: imbalance.value,\n\t\t\tnegative: imbalance.negative,\n\t\t},\n\t\thub_asset_liquidity,\n\t)\n\t.ok_or(ArithmeticError::Overflow)?;\n\tSelf::update_imbalance(BalanceUpdate::Increase(delta_imbalance))?;\n\n\tT::Currency::withdraw(T::HubAssetId::get(), &Self::protocol_account(), asset_state.hub_reserve)?;\n\tT::Currency::transfer(asset_id, &Self::protocol_account(), &beneficiary, asset_state.reserve)?;\n\t<Assets<T>>::remove(asset_id);\n\tSelf::deposit_event(Event::TokenRemoved {\n\t\tasset_id,\n\t\tamount: asset_state.reserve,\n\t\thub_withdrawn: asset_state.hub_reserve,\n\t});\n\tOk(())\n}\n```\n\n### Recommended Mitigation Steps\n\nThe issue can be mitigated by forwarding the updated asset state to the oracle by calling the `on_liquidity_changed` hook.\n\n### Assessed type\n\nOracle\n\n**[enthusiastmartin (HydraDX) disputed and commented via duplicate issue #141](https://github.com/code-423n4/2024-02-hydradx-findings/issues/141#issuecomment-1980993667):**\n> The calls is not needed in mentioned functions. `sacrifice_position` does not change any liquidity and `remove_token` just removes token.\n\n**[J4X (warden) commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/51#issuecomment-1993119034):**\n > @Lambda - This issue has been deemed as invalid due to a comment by the sponsor on Issue [#141](https://github.com/code-423n4/2024-02-hydradx-findings/issues/141). Issue #141 describes that in the functions `sacrifice_position()` and `remove_token()`, a hook call to `on_liquidity_changed` is missing. The sponsor has disputed this with the claim that in none of those functions, the liquidity gets changed, which is true for `sacrifice_position()` but not for `remove_token()`. In `sacrifice_position()`, the sacrificed positions' ownership is transferred to the protocol but the liquidity does not change. \n> \n> The same is not the case for the `remove_token()` function. As one can see in the following [code snippet](https://github.com/code-423n4/2024-02-hydradx/blob/main/HydraDX-node/pallets/omnipool/src/lib.rs#L1566), the function transfers out all liquidity that is owned by protocol shares to a beneficiary, changing the liquidity in the pool:\n> \n> ```rust\n> T::Currency::transfer(asset_id, &Self::protocol_account(), &beneficiary, asset_state.reserve)?;\n> ```\n> \n> The function documentation also [mentions](https://github.com/code-423n4/2024-02-hydradx/blob/main/HydraDX-node/pallets/omnipool/src/lib.rs#L1533C6-L1533C101) the liquidity change. \n> \n> So contrary to the comment of the sponsor, not only does the token get removed but also the liquidity changes, as the protocol-owned liquidity is sent to the beneficiary. This should result in a call to the hook so that the circuit breaker and the oracle get accordingly updated (and trigger at the right values). This could for example lead to an issue if we have a maximum liquidity change per block of 100 tokens chosen in our circuit breaker and a token gets removed with 90 tokens of protocol liquidity being withdrawn. A later call withdrawing 20 liquidity would incorrectly pass as the earlier withdrawn liquidity is not accounted for due to the missing hook call. This would undermine the security measure of the circuit breaker as the limits are not correctly enforced. Additionally, due to the missing liquidity update, the oracle will be outdated too.\n> \n> I would like to mention that my issue is the only issue that fully and correctly documents the problem, as Issue #141 is reporting an invalid additional issue and also recommends an incorrect mitigation of increasing the liquidityInBlock in `sacrifice_position()`.\n\n**[Lambda (judge) commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/51#issuecomment-1999261871):**\n > Thanks for your comment. After looking at it again, `remove_token` indeed changes the liquidity like `add_token` does. While `add_token` calls `on_liquidity_changed`, `remove_token` does not, which can lead to inconsistencies.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-hydradx",
  "Code": [
    {
      "filename": "HydraDX-node/pallets/omnipool/src/lib.rs",
      "content": "// Copyright (C) 2020-2022  Intergalactic, Limited (GIB).\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # Omnipool pallet\n//!\n//! Omnipool implementation\n//!\n//! ## Overview\n//!\n//! Omnipool is type of AMM where all assets are pooled together into one single pool.\n//!\n//! Each asset is internally paired with so called Hub Asset ( LRNA ). When a liquidity is provided, corresponding\n//! amount of hub asset is minted. When a liquidity is removed, corresponding amount of hub asset is burned.\n//!\n//! Liquidity provider can provide any asset of their choice to the Omnipool and in return\n//! they will receive pool shares for this single asset.\n//!\n//! The position is represented as a NFT token which stores the amount of shares distributed\n//! and the price of the asset at the time of provision.\n//!\n//! For traders this means that they can benefit from non-fragmented liquidity.\n//! They can send any token to the pool using the swap mechanism\n//! and in return they will receive the token of their choice in the appropriate quantity.\n//!\n//! Omnipool is implemented with concrete Balance type: u128.\n//!\n//! ### Imbalance mechanism\n//! The Imbalance mechanism is designed to stabilize the value of LRNA. By design it is a weak and passive mechanism,\n//! and is specifically meant to deal with one cause of LRNA volatility: LRNA being sold back to the pool.\n//!\n//! Imbalance is always negative, internally represented by a special type `SimpleImbalance` which uses unsigned integer and boolean flag.\n//! This was done initially because of the intention that in future imbalance can also become positive.\n//!\n//! ### Omnipool Hooks\n//!\n//! Omnipool pallet supports multiple hooks which are triggerred on certain operations:\n//! - on_liquidity_changed - called when liquidity is added or removed from the pool\n//! - on_trade - called when trade is executed\n//! - on_trade_fee - called after successful trade with fee amount that can be taken out of the pool if needed.\n//!\n//! This is currently used to update on-chain oracle and in the circuit breaker.\n//!\n//! ## Terminology\n//!\n//! * **LP:**  liquidity provider\n//! * **Position:**  a moment when LP added liquidity to the pool. It stores amount,shares and price at the time\n//!  of provision\n//! * **Hub Asset:** dedicated 'hub' token for trade executions (LRNA)\n//! * **Native Asset:** governance token\n//! * **Imbalance:** Tracking of hub asset imbalance.\n//!\n//! ## Assumptions\n//!\n//! Below are assumptions that must be held when using this pallet.\n//!\n//! * Initial liquidity of new token being added to Omnipool must be transferred manually to pool account prior to calling add_token.\n//! * All tokens added to the pool must be first registered in Asset Registry.\n//!\n//! ## Interface\n//!\n//! ### Dispatchable Functions\n//!\n//! * `add_token` - Adds token to the pool. Initial liquidity must be transffered to pool account prior to calling add_token.\n//! * `add_liquidity` - Adds liquidity of selected asset to the pool. Mints corresponding position NFT.\n//! * `remove_liquidity` - Removes liquidity of selected position from the pool. Partial withdrawals are allowed.\n//! * `sell` - Trades an asset in for asset out by selling given amount of asset in.\n//! * `buy` - Trades an asset in for asset out by buying given amount of asset out.\n//! * `set_asset_tradable_state` - Updates asset's tradable state with new flags. This allows/forbids asset operation such SELL,BUY,ADD or  REMOVE liquidtityy.\n//! * `refund_refused_asset` - Refunds the initial liquidity amount sent to pool account prior to add_token if the token has been refused to be added.\n//! * `sacrifice_position` - Destroys a position and position's shares become protocol's shares.\n//! * `withdraw_protocol_liquidity` - Withdraws protocol's liquidity from the pool. Used to withdraw liquidity from sacrificed position.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse frame_support::pallet_prelude::{DispatchResult, Get};\nuse frame_support::require_transactional;\nuse frame_support::PalletId;\nuse frame_support::{ensure, transactional};\nuse sp_runtime::traits::{AccountIdConversion, AtLeast32BitUnsigned, One};\nuse sp_runtime::traits::{CheckedAdd, CheckedSub, Zero};\nuse sp_std::ops::{Add, Sub};\nuse sp_std::prelude::*;\n\nuse frame_support::traits::tokens::nonfungibles::{Create, Inspect, Mutate};\nuse hydra_dx_math::omnipool::types::{AssetStateChange, BalanceUpdate, I129};\nuse hydradx_traits::Registry;\nuse orml_traits::{GetByKey, MultiCurrency};\nuse scale_info::TypeInfo;\nuse sp_runtime::{ArithmeticError, DispatchError, FixedPointNumber, FixedU128, Permill};\n\n#[cfg(test)]\nmod tests;\n\npub mod provider;\npub mod router_execution;\npub mod traits;\npub mod types;\npub mod weights;\n\nuse crate::traits::{AssetInfo, OmnipoolHooks};\nuse crate::types::{AssetReserveState, AssetState, Balance, Position, SimpleImbalance, Tradability};\npub use pallet::*;\npub use weights::WeightInfo;\n\n/// NFT class id type of provided nft implementation\npub type NFTCollectionIdOf<T> =\n\t<<T as Config>::NFTHandler as Inspect<<T as frame_system::Config>::AccountId>>::CollectionId;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse crate::traits::{AssetInfo, ExternalPriceProvider, OmnipoolHooks, ShouldAllow};\n\tuse crate::types::{Position, Price, Tradability};\n\tuse codec::HasCompact;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_support::traits::DefensiveOption;\n\tuse frame_system::pallet_prelude::*;\n\tuse hydra_dx_math::ema::EmaPrice;\n\tuse hydra_dx_math::omnipool::types::{BalanceUpdate, I129};\n\tuse orml_traits::GetByKey;\n\tuse sp_runtime::ArithmeticError;\n\n\t#[pallet::pallet]\n\tpub struct Pallet<T>(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// The overarching event type.\n\t\ttype RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\n\t\t/// Asset type.\n\t\ttype AssetId: Member\n\t\t\t+ Parameter\n\t\t\t+ Default\n\t\t\t+ Copy\n\t\t\t+ HasCompact\n\t\t\t+ MaybeSerializeDeserialize\n\t\t\t+ MaxEncodedLen\n\t\t\t+ TypeInfo;\n\n\t\t/// Multi currency mechanism\n\t\ttype Currency: MultiCurrency<Self::AccountId, CurrencyId = Self::AssetId, Balance = Balance>;\n\n\t\t/// Origin that can add token, refund refused asset and withdraw protocol liquidity.\n\t\ttype AuthorityOrigin: EnsureOrigin<Self::RuntimeOrigin>;\n\n\t\t/// Origin that can change asset's tradability and weight.\n\t\ttype TechnicalOrigin: EnsureOrigin<Self::RuntimeOrigin>;\n\n\t\t/// Asset Registry mechanism - used to check if asset is correctly registered in asset registry\n\t\ttype AssetRegistry: Registry<Self::AssetId, Vec<u8>, Balance, DispatchError>;\n\n\t\t/// Native Asset ID\n\t\t#[pallet::constant]\n\t\ttype HdxAssetId: Get<Self::AssetId>;\n\n\t\t/// Hub Asset ID\n\t\t#[pallet::constant]\n\t\ttype HubAssetId: Get<Self::AssetId>;\n\n\t\t/// Dynamic fee support - returns (Asset Fee, Protocol Fee) for given asset\n\t\ttype Fee: GetByKey<Self::AssetId, (Permill, Permill)>;\n\n\t\t/// Minimum withdrawal fee\n\t\t#[pallet::constant]\n\t\ttype MinWithdrawalFee: Get<Permill>;\n\n\t\t/// Minimum trading limit\n\t\t#[pallet::constant]\n\t\ttype MinimumTradingLimit: Get<Balance>;\n\n\t\t/// Minimum pool liquidity which can be added\n\t\t#[pallet::constant]\n\t\ttype MinimumPoolLiquidity: Get<Balance>;\n\n\t\t/// Max fraction of asset reserve to sell in single transaction\n\t\t#[pallet::constant]\n\t\ttype MaxInRatio: Get<u128>;\n\n\t\t/// Max fraction of asset reserve to buy in single transaction\n\t\t#[pallet::constant]\n\t\ttype MaxOutRatio: Get<u128>;\n\n\t\t/// Position identifier type\n\t\ttype PositionItemId: Member + Parameter + Default + Copy + HasCompact + AtLeast32BitUnsigned + MaxEncodedLen;\n\n\t\t/// Collection id type\n\t\ttype CollectionId: TypeInfo + MaxEncodedLen;\n\n\t\t/// Non fungible class id\n\t\t#[pallet::constant]\n\t\ttype NFTCollectionId: Get<NFTCollectionIdOf<Self>>;\n\n\t\t/// Non fungible handling - mint,burn, check owner\n\t\ttype NFTHandler: Mutate<Self::AccountId>\n\t\t\t+ Create<Self::AccountId>\n\t\t\t+ Inspect<Self::AccountId, ItemId = Self::PositionItemId, CollectionId = Self::CollectionId>;\n\n\t\t/// Weight information for extrinsics in this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\t/// Hooks are actions executed on add_liquidity, sell or buy.\n\t\ttype OmnipoolHooks: OmnipoolHooks<\n\t\t\tSelf::RuntimeOrigin,\n\t\t\tSelf::AccountId,\n\t\t\tSelf::AssetId,\n\t\t\tBalance,\n\t\t\tError = DispatchError,\n\t\t>;\n\n\t\t/// Safety mechanism when adding and removing liquidity. Determines how much price can change between spot price and oracle price.\n\t\ttype PriceBarrier: ShouldAllow<Self::AccountId, Self::AssetId, EmaPrice>;\n\n\t\t/// Oracle price provider. Provides price for given asset. Used in remove liquidity to support calculation of dynamic withdrawal fee.\n\t\ttype ExternalPriceOracle: ExternalPriceProvider<Self::AssetId, EmaPrice, Error = DispatchError>;\n\t}\n\n\t#[pallet::storage]\n\t/// State of an asset in the omnipool\n\t#[pallet::getter(fn assets)]\n\tpub(super) type Assets<T: Config> = StorageMap<_, Blake2_128Concat, T::AssetId, AssetState<Balance>>;\n\n\t#[pallet::storage]\n\t/// Imbalance of hub asset\n\t#[pallet::getter(fn current_imbalance)]\n\tpub(super) type HubAssetImbalance<T: Config> = StorageValue<_, SimpleImbalance<Balance>, ValueQuery>;\n\n\t// LRNA is only allowed to be sold\n\t#[pallet::type_value]\n\tpub fn DefaultHubAssetTradability() -> Tradability {\n\t\tTradability::SELL\n\t}\n\n\t#[pallet::storage]\n\t/// Tradable state of hub asset.\n\tpub(super) type HubAssetTradability<T: Config> =\n\t\tStorageValue<_, Tradability, ValueQuery, DefaultHubAssetTradability>;\n\n\t#[pallet::storage]\n\t/// LP positions. Maps NFT instance id to corresponding position\n\t#[pallet::getter(fn positions)]\n\tpub(super) type Positions<T: Config> =\n\t\tStorageMap<_, Blake2_128Concat, T::PositionItemId, Position<Balance, T::AssetId>>;\n\n\t#[pallet::storage]\n\t#[pallet::getter(fn next_position_id)]\n\t/// Position ids sequencer\n\tpub(super) type NextPositionId<T: Config> = StorageValue<_, T::PositionItemId, ValueQuery>;\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(crate) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\t/// An asset was added to Omnipool\n\t\tTokenAdded {\n\t\t\tasset_id: T::AssetId,\n\t\t\tinitial_amount: Balance,\n\t\t\tinitial_price: Price,\n\t\t},\n\t\t/// An asset was removed from Omnipool\n\t\tTokenRemoved {\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\thub_withdrawn: Balance,\n\t\t},\n\t\t/// Liquidity of an asset was added to Omnipool.\n\t\tLiquidityAdded {\n\t\t\twho: T::AccountId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tposition_id: T::PositionItemId,\n\t\t},\n\t\t/// Liquidity of an asset was removed from Omnipool.\n\t\tLiquidityRemoved {\n\t\t\twho: T::AccountId,\n\t\t\tposition_id: T::PositionItemId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tshares_removed: Balance,\n\t\t\tfee: FixedU128,\n\t\t},\n\t\t/// PRotocol Liquidity was removed from Omnipool.\n\t\tProtocolLiquidityRemoved {\n\t\t\twho: T::AccountId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\thub_amount: Balance,\n\t\t\tshares_removed: Balance,\n\t\t},\n\t\t/// Sell trade executed.\n\t\tSellExecuted {\n\t\t\twho: T::AccountId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tamount_out: Balance,\n\t\t\thub_amount_in: Balance,\n\t\t\thub_amount_out: Balance,\n\t\t\tasset_fee_amount: Balance,\n\t\t\tprotocol_fee_amount: Balance,\n\t\t},\n\t\t/// Buy trade executed.\n\t\tBuyExecuted {\n\t\t\twho: T::AccountId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tamount_out: Balance,\n\t\t\thub_amount_in: Balance,\n\t\t\thub_amount_out: Balance,\n\t\t\tasset_fee_amount: Balance,\n\t\t\tprotocol_fee_amount: Balance,\n\t\t},\n\t\t/// LP Position was created and NFT instance minted.\n\t\tPositionCreated {\n\t\t\tposition_id: T::PositionItemId,\n\t\t\towner: T::AccountId,\n\t\t\tasset: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tshares: Balance,\n\t\t\tprice: Price,\n\t\t},\n\t\t/// LP Position was destroyed and NFT instance burned.\n\t\tPositionDestroyed {\n\t\t\tposition_id: T::PositionItemId,\n\t\t\towner: T::AccountId,\n\t\t},\n\t\t/// LP Position was updated.\n\t\tPositionUpdated {\n\t\t\tposition_id: T::PositionItemId,\n\t\t\towner: T::AccountId,\n\t\t\tasset: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tshares: Balance,\n\t\t\tprice: Price,\n\t\t},\n\t\t/// Asset's tradable state has been updated.\n\t\tTradableStateUpdated { asset_id: T::AssetId, state: Tradability },\n\n\t\t/// Amount has been refunded for asset which has not been accepted to add to omnipool.\n\t\tAssetRefunded {\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\trecipient: T::AccountId,\n\t\t},\n\n\t\t/// Asset's weight cap has been updated.\n\t\tAssetWeightCapUpdated { asset_id: T::AssetId, cap: Permill },\n\t}\n\n\t#[pallet::error]\n\t#[cfg_attr(test, derive(PartialEq, Eq))]\n\tpub enum Error<T> {\n\t\t/// Balance too low\n\t\tInsufficientBalance,\n\t\t/// Asset is already in omnipool\n\t\tAssetAlreadyAdded,\n\t\t/// Asset is not in omnipool\n\t\tAssetNotFound,\n\t\t/// Failed to add token to Omnipool due to insufficient initial liquidity.\n\t\tMissingBalance,\n\t\t/// Invalid initial asset price.\n\t\tInvalidInitialAssetPrice,\n\t\t/// Slippage protection - minimum limit has not been reached.\n\t\tBuyLimitNotReached,\n\t\t/// Slippage protection - maximum limit has been exceeded.\n\t\tSellLimitExceeded,\n\t\t/// Position has not been found.\n\t\tPositionNotFound,\n\t\t/// Insufficient shares in position\n\t\tInsufficientShares,\n\t\t/// Asset is not allowed to be traded.\n\t\tNotAllowed,\n\t\t/// Signed account is not owner of position instance.\n\t\tForbidden,\n\t\t/// Asset weight cap has been exceeded.\n\t\tAssetWeightCapExceeded,\n\t\t/// Asset is not registered in asset registry\n\t\tAssetNotRegistered,\n\t\t/// Provided liquidity is below minimum allowed limit\n\t\tInsufficientLiquidity,\n\t\t/// Traded amount is below minimum allowed limit\n\t\tInsufficientTradingAmount,\n\t\t/// Sell or buy with same asset ids is not allowed.\n\t\tSameAssetTradeNotAllowed,\n\t\t/// LRNA update after trade results in positive value.\n\t\tHubAssetUpdateError,\n\t\t/// Imbalance results in positive value.\n\t\tPositiveImbalance,\n\t\t/// Amount of shares provided cannot be 0.\n\t\tInvalidSharesAmount,\n\t\t/// Hub asset is only allowed to be sold.\n\t\tInvalidHubAssetTradableState,\n\t\t/// Asset is not allowed to be refunded.\n\t\tAssetRefundNotAllowed,\n\t\t/// Max fraction of asset to buy has been exceeded.\n\t\tMaxOutRatioExceeded,\n\t\t/// Max fraction of asset to sell has been exceeded.\n\t\tMaxInRatioExceeded,\n\t\t/// Max allowed price difference has been exceeded.\n\t\tPriceDifferenceTooHigh,\n\t\t/// Invalid oracle price - division by zero.\n\t\tInvalidOraclePrice,\n\t\t/// Failed to calculate withdrawal fee.\n\t\tInvalidWithdrawalFee,\n\t\t/// More than allowed amount of fee has been transferred.\n\t\tFeeOverdraft,\n\t\t/// Token cannot be removed from Omnipool due to shares still owned by other users.\n\t\tSharesRemaining,\n\t\t/// Token cannot be removed from Omnipool because asset is not frozen.\n\t\tAssetNotFrozen,\n\t\t/// Calculated amount out from sell trade is zero.\n\t\tZeroAmountOut,\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t/// Add new token to omnipool in quantity `amount` at price `initial_price`\n\t\t///\n\t\t/// Initial liquidity must be transferred to pool's account for this new token manually prior to calling `add_token`.\n\t\t///\n\t\t/// Initial liquidity is pool's account balance of the token.\n\t\t///\n\t\t/// Position NFT token is minted for `position_owner`.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `asset`: The identifier of the new asset added to the pool. Must be registered in Asset registry\n\t\t/// - `initial_price`: Initial price\n\t\t/// - `position_owner`: account id for which share are distributed in form on NFT\n\t\t/// - `weight_cap`: asset weight cap\n\t\t///\n\t\t/// Emits `TokenAdded` event when successful.\n\t\t///\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::add_token().saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()))]\n\t\t#[transactional]\n\t\tpub fn add_token(\n\t\t\torigin: OriginFor<T>,\n\t\t\tasset: T::AssetId,\n\t\t\tinitial_price: Price,\n\t\t\tweight_cap: Permill,\n\t\t\tposition_owner: T::AccountId,\n\t\t) -> DispatchResult {\n\t\t\tT::AuthorityOrigin::ensure_origin(origin.clone())?;\n\n\t\t\tensure!(!Assets::<T>::contains_key(asset), Error::<T>::AssetAlreadyAdded);\n\n\t\t\tensure!(T::AssetRegistry::exists(asset), Error::<T>::AssetNotRegistered);\n\n\t\t\tensure!(initial_price > FixedU128::zero(), Error::<T>::InvalidInitialAssetPrice);\n\n\t\t\t// ensure collection is created, we can simply ignore the error if it was already created.\n\t\t\tlet _ = T::NFTHandler::create_collection(\n\t\t\t\t&T::NFTCollectionId::get(),\n\t\t\t\t&Self::protocol_account(),\n\t\t\t\t&Self::protocol_account(),\n\t\t\t);\n\n\t\t\tlet amount = T::Currency::free_balance(asset, &Self::protocol_account());\n\n\t\t\tensure!(\n\t\t\t\tamount >= T::MinimumPoolLiquidity::get() && amount > 0,\n\t\t\t\tError::<T>::MissingBalance\n\t\t\t);\n\n\t\t\tlet hub_reserve = initial_price.checked_mul_int(amount).ok_or(ArithmeticError::Overflow)?;\n\n\t\t\t// Initial state of asset\n\t\t\tlet state = AssetState::<Balance> {\n\t\t\t\thub_reserve,\n\t\t\t\tshares: amount,\n\t\t\t\tprotocol_shares: Balance::zero(),\n\t\t\t\tcap: FixedU128::from(weight_cap).into_inner(),\n\t\t\t\ttradable: Tradability::default(),\n\t\t\t};\n\n\t\t\tlet lp_position = Position::<Balance, T::AssetId> {\n\t\t\t\tasset_id: asset,\n\t\t\t\tamount,\n\t\t\t\tshares: amount,\n\t\t\t\tprice: (initial_price.into_inner(), FixedU128::DIV),\n\t\t\t};\n\n\t\t\tlet instance_id = Self::create_and_mint_position_instance(&position_owner)?;\n\n\t\t\t<Positions<T>>::insert(instance_id, lp_position);\n\n\t\t\tSelf::deposit_event(Event::PositionCreated {\n\t\t\t\tposition_id: instance_id,\n\t\t\t\towner: position_owner,\n\t\t\t\tasset,\n\t\t\t\tamount,\n\t\t\t\tshares: amount,\n\t\t\t\tprice: initial_price,\n\t\t\t});\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\t\t\tlet current_hub_asset_liquidity =\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());\n\n\t\t\tlet delta_imbalance = hydra_dx_math::omnipool::calculate_delta_imbalance(\n\t\t\t\thub_reserve,\n\t\t\t\tI129 {\n\t\t\t\t\tvalue: current_imbalance.value,\n\t\t\t\t\tnegative: current_imbalance.negative,\n\t\t\t\t},\n\t\t\t\tcurrent_hub_asset_liquidity,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tSelf::update_imbalance(BalanceUpdate::Decrease(delta_imbalance))?;\n\n\t\t\tlet delta_hub_reserve = BalanceUpdate::Increase(hub_reserve);\n\t\t\tSelf::update_hub_asset_liquidity(&delta_hub_reserve)?;\n\n\t\t\tlet reserve = T::Currency::free_balance(asset, &Self::protocol_account());\n\n\t\t\tlet reserve_state: AssetReserveState<_> = (state.clone(), reserve).into();\n\t\t\tlet changes = AssetStateChange {\n\t\t\t\tdelta_hub_reserve,\n\t\t\t\tdelta_reserve: BalanceUpdate::Increase(reserve),\n\t\t\t\tdelta_shares: BalanceUpdate::Increase(amount),\n\t\t\t\tdelta_protocol_shares: BalanceUpdate::Increase(Balance::zero()),\n\t\t\t};\n\t\t\tT::OmnipoolHooks::on_liquidity_changed(\n\t\t\t\torigin,\n\t\t\t\tAssetInfo::new(asset, &AssetReserveState::default(), &reserve_state, &changes, false),\n\t\t\t)?;\n\n\t\t\t<Assets<T>>::insert(asset, state);\n\n\t\t\tSelf::deposit_event(Event::TokenAdded {\n\t\t\t\tasset_id: asset,\n\t\t\t\tinitial_amount: amount,\n\t\t\t\tinitial_price,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Add liquidity of asset `asset` in quantity `amount` to Omnipool\n\t\t///\n\t\t/// `add_liquidity` adds specified asset amount to Omnipool and in exchange gives the origin\n\t\t/// corresponding shares amount in form of NFT at current price.\n\t\t///\n\t\t/// Asset's tradable state must contain ADD_LIQUIDITY flag, otherwise `NotAllowed` error is returned.\n\t\t///\n\t\t/// NFT is minted using NTFHandler which implements non-fungibles traits from frame_support.\n\t\t///\n\t\t/// Asset weight cap must be respected, otherwise `AssetWeightExceeded` error is returned.\n\t\t/// Asset weight is ratio between new HubAsset reserve and total reserve of Hub asset in Omnipool.\n\t\t///\n\t\t/// Add liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `asset`: The identifier of the new asset added to the pool. Must be already in the pool\n\t\t/// - `amount`: Amount of asset added to omnipool\n\t\t///\n\t\t/// Emits `LiquidityAdded` event when successful.\n\t\t///\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::add_liquidity()\n\t\t\t.saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()\n\t\t\t.saturating_add(T::ExternalPriceOracle::get_price_weight()))\n\t\t)]\n\t\t#[transactional]\n\t\tpub fn add_liquidity(origin: OriginFor<T>, asset: T::AssetId, amount: Balance) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin.clone())?;\n\n\t\t\tensure!(\n\t\t\t\tamount >= T::MinimumPoolLiquidity::get(),\n\t\t\t\tError::<T>::InsufficientLiquidity\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tT::Currency::ensure_can_withdraw(asset, &who, amount).is_ok(),\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\n\t\t\tlet asset_state = Self::load_asset_state(asset)?;\n\n\t\t\tensure!(\n\t\t\t\tasset_state.tradable.contains(Tradability::ADD_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tT::PriceBarrier::ensure_price(\n\t\t\t\t&who,\n\t\t\t\tT::HubAssetId::get(),\n\t\t\t\tasset,\n\t\t\t\tEmaPrice::new(asset_state.hub_reserve, asset_state.reserve),\n\t\t\t)\n\t\t\t.map_err(|_| Error::<T>::PriceDifferenceTooHigh)?;\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\t\t\tlet current_hub_asset_liquidity =\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());\n\n\t\t\t//\n\t\t\t// Calculate add liquidity state changes\n\t\t\t//\n\t\t\tlet state_changes = hydra_dx_math::omnipool::calculate_add_liquidity_state_changes(\n\t\t\t\t&(&asset_state).into(),\n\t\t\t\tamount,\n\t\t\t\tI129 {\n\t\t\t\t\tvalue: current_imbalance.value,\n\t\t\t\t\tnegative: current_imbalance.negative,\n\t\t\t\t},\n\t\t\t\tcurrent_hub_asset_liquidity,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tlet new_asset_state = asset_state\n\t\t\t\t.clone()\n\t\t\t\t.delta_update(&state_changes.asset)\n\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tlet hub_reserve_ratio = FixedU128::checked_from_rational(\n\t\t\t\tnew_asset_state.hub_reserve,\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account())\n\t\t\t\t\t.checked_add(*state_changes.asset.delta_hub_reserve)\n\t\t\t\t\t.ok_or(ArithmeticError::Overflow)?,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::DivisionByZero)?;\n\n\t\t\tensure!(\n\t\t\t\thub_reserve_ratio <= new_asset_state.weight_cap(),\n\t\t\t\tError::<T>::AssetWeightCapExceeded\n\t\t\t);\n\n\t\t\t// Create LP position with given shares\n\t\t\tlet lp_position = Position::<Balance, T::AssetId> {\n\t\t\t\tasset_id: asset,\n\t\t\t\tamount,\n\t\t\t\tshares: *state_changes.asset.delta_shares,\n\t\t\t\t// Note: position needs price after asset state is updated.\n\t\t\t\tprice: (new_asset_state.hub_reserve, new_asset_state.reserve),\n\t\t\t};\n\n\t\t\tlet instance_id = Self::create_and_mint_position_instance(&who)?;\n\n\t\t\t<Positions<T>>::insert(instance_id, lp_position);\n\n\t\t\tSelf::deposit_event(Event::PositionCreated {\n\t\t\t\tposition_id: instance_id,\n\t\t\t\towner: who.clone(),\n\t\t\t\tasset,\n\t\t\t\tamount,\n\t\t\t\tshares: *state_changes.asset.delta_shares,\n\t\t\t\tprice: new_asset_state.price().ok_or(ArithmeticError::DivisionByZero)?,\n\t\t\t});\n\n\t\t\tT::Currency::transfer(\n\t\t\t\tasset,\n\t\t\t\t&who,\n\t\t\t\t&Self::protocol_account(),\n\t\t\t\t*state_changes.asset.delta_reserve,\n\t\t\t)?;\n\n\t\t\tdebug_assert_eq!(*state_changes.asset.delta_reserve, amount);\n\n\t\t\t// Callback hook info\n\t\t\tlet info: AssetInfo<T::AssetId, Balance> =\n\t\t\t\tAssetInfo::new(asset, &asset_state, &new_asset_state, &state_changes.asset, false);\n\n\t\t\tSelf::update_imbalance(state_changes.delta_imbalance)?;\n\n\t\t\tSelf::update_hub_asset_liquidity(&state_changes.asset.delta_hub_reserve)?;\n\n\t\t\tSelf::set_asset_state(asset, new_asset_state);\n\n\t\t\tSelf::deposit_event(Event::LiquidityAdded {\n\t\t\t\twho,\n\t\t\t\tasset_id: asset,\n\t\t\t\tamount,\n\t\t\t\tposition_id: instance_id,\n\t\t\t});\n\n\t\t\tT::OmnipoolHooks::on_liquidity_changed(origin, info)?;\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Remove liquidity of asset `asset` in quantity `amount` from Omnipool\n\t\t///\n\t\t/// `remove_liquidity` removes specified shares amount from given PositionId (NFT instance).\n\t\t///\n\t\t/// Asset's tradable state must contain REMOVE_LIQUIDITY flag, otherwise `NotAllowed` error is returned.\n\t\t///\n\t\t/// if all shares from given position are removed, position is destroyed and NFT is burned.\n\t\t///\n\t\t/// Remove liquidity fails if price difference between spot price and oracle price is higher than allowed by `PriceBarrier`.\n\t\t///\n\t\t/// Dynamic withdrawal fee is applied if withdrawal is not safe. It is calculated using spot price and external price oracle.\n\t\t/// Withdrawal is considered safe when trading is disabled.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `position_id`: The identifier of position which liquidity is removed from.\n\t\t/// - `amount`: Amount of shares removed from omnipool\n\t\t///\n\t\t/// Emits `LiquidityRemoved` event when successful.\n\t\t///\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::remove_liquidity().saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight()))]\n\t\t#[transactional]\n\t\tpub fn remove_liquidity(\n\t\t\torigin: OriginFor<T>,\n\t\t\tposition_id: T::PositionItemId,\n\t\t\tamount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin.clone())?;\n\n\t\t\tensure!(amount > Balance::zero(), Error::<T>::InvalidSharesAmount);\n\n\t\t\tensure!(\n\t\t\t\tT::NFTHandler::owner(&T::NFTCollectionId::get(), &position_id) == Some(who.clone()),\n\t\t\t\tError::<T>::Forbidden\n\t\t\t);\n\n\t\t\tlet position = Positions::<T>::get(position_id).ok_or(Error::<T>::PositionNotFound)?;\n\n\t\t\tensure!(position.shares >= amount, Error::<T>::InsufficientShares);\n\n\t\t\tlet asset_id = position.asset_id;\n\n\t\t\tlet asset_state = Self::load_asset_state(asset_id)?;\n\n\t\t\tensure!(\n\t\t\t\tasset_state.tradable.contains(Tradability::REMOVE_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tlet safe_withdrawal = asset_state.tradable.is_safe_withdrawal();\n\t\t\t// Skip price check if safe withdrawal - trading disabled.\n\t\t\tif !safe_withdrawal {\n\t\t\t\tT::PriceBarrier::ensure_price(\n\t\t\t\t\t&who,\n\t\t\t\t\tT::HubAssetId::get(),\n\t\t\t\t\tasset_id,\n\t\t\t\t\tEmaPrice::new(asset_state.hub_reserve, asset_state.reserve),\n\t\t\t\t)\n\t\t\t\t.map_err(|_| Error::<T>::PriceDifferenceTooHigh)?;\n\t\t\t}\n\t\t\tlet ext_asset_price = T::ExternalPriceOracle::get_price(T::HubAssetId::get(), asset_id)?;\n\n\t\t\tif ext_asset_price.is_zero() {\n\t\t\t\treturn Err(Error::<T>::InvalidOraclePrice.into());\n\t\t\t}\n\t\t\tlet withdrawal_fee = hydra_dx_math::omnipool::calculate_withdrawal_fee(\n\t\t\t\tasset_state.price().ok_or(ArithmeticError::DivisionByZero)?,\n\t\t\t\tFixedU128::checked_from_rational(ext_asset_price.n, ext_asset_price.d)\n\t\t\t\t\t.defensive_ok_or(Error::<T>::InvalidOraclePrice)?,\n\t\t\t\tT::MinWithdrawalFee::get(),\n\t\t\t);\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\t\t\tlet current_hub_asset_liquidity =\n\t\t\t\tT::Currency::free_balance(T::HubAssetId::get(), &Self::protocol_account());\n\n\t\t\t//\n\t\t\t// calculate state changes of remove liquidity\n\t\t\t//\n\t\t\tlet state_changes = hydra_dx_math::omnipool::calculate_remove_liquidity_state_changes(\n\t\t\t\t&(&asset_state).into(),\n\t\t\t\tamount,\n\t\t\t\t&(&position).into(),\n\t\t\t\tI129 {\n\t\t\t\t\tvalue: current_imbalance.value,\n\t\t\t\t\tnegative: current_imbalance.negative,\n\t\t\t\t},\n\t\t\t\tcurrent_hub_asset_liquidity,\n\t\t\t\twithdrawal_fee,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tlet new_asset_state = asset_state\n\t\t\t\t.clone()\n\t\t\t\t.delta_update(&state_changes.asset)\n\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\t// Update position state\n\t\t\tlet updated_position = position\n\t\t\t\t.delta_update(\n\t\t\t\t\t&state_changes.delta_position_reserve,\n\t\t\t\t\t&state_changes.delta_position_shares,\n\t\t\t\t)\n\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tT::Currency::transfer(\n\t\t\t\tasset_id,\n\t\t\t\t&Self::protocol_account(),\n\t\t\t\t&who,\n\t\t\t\t*state_changes.asset.delta_reserve,\n\t\t\t)?;\n\n\t\t\tSelf::update_imbalance(state_changes.delta_imbalance)?;\n\n\t\t\t// burn only difference between delta hub and lp hub amount.\n\t\t\tSelf::update_hub_asset_liquidity(\n\t\t\t\t&state_changes\n\t\t\t\t\t.asset\n\t\t\t\t\t.delta_hub_reserve\n\t\t\t\t\t.merge(BalanceUpdate::Increase(state_changes.lp_hub_amount))\n\t\t\t\t\t.ok_or(ArithmeticError::Overflow)?,\n\t\t\t)?;\n\n\t\t\t// LP receives some hub asset\n\t\t\tSelf::process_hub_amount(state_changes.lp_hub_amount, &who)?;\n\n\t\t\tif updated_position.shares == Balance::zero() {\n\t\t\t\t// All liquidity removed, remove position and burn NFT instance\n\n\t\t\t\t<Positions<T>>::remove(position_id);\n\t\t\t\tT::NFTHandler::burn(&T::NFTCollectionId::get(), &position_id, Some(&who))?;\n\n\t\t\t\tSelf::deposit_event(Event::PositionDestroyed {\n\t\t\t\t\tposition_id,\n\t\t\t\t\towner: who.clone(),\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tSelf::deposit_event(Event::PositionUpdated {\n\t\t\t\t\tposition_id,\n\t\t\t\t\towner: who.clone(),\n\t\t\t\t\tasset: asset_id,\n\t\t\t\t\tamount: updated_position.amount,\n\t\t\t\t\tshares: updated_position.shares,\n\t\t\t\t\tprice: updated_position\n\t\t\t\t\t\t.price_from_rational()\n\t\t\t\t\t\t.ok_or(ArithmeticError::DivisionByZero)?,\n\t\t\t\t});\n\n\t\t\t\t<Positions<T>>::insert(position_id, updated_position);\n\t\t\t}\n\n\t\t\t// Callback hook info\n\t\t\tlet info: AssetInfo<T::AssetId, Balance> = AssetInfo::new(\n\t\t\t\tasset_id,\n\t\t\t\t&asset_state,\n\t\t\t\t&new_asset_state,\n\t\t\t\t&state_changes.asset,\n\t\t\t\tsafe_withdrawal,\n\t\t\t);\n\n\t\t\tSelf::set_asset_state(asset_id, new_asset_state);\n\n\t\t\tSelf::deposit_event(Event::LiquidityRemoved {\n\t\t\t\twho,\n\t\t\t\tposition_id,\n\t\t\t\tasset_id,\n\t\t\t\tshares_removed: amount,\n\t\t\t\tfee: withdrawal_fee,\n\t\t\t});\n\n\t\t\tT::OmnipoolHooks::on_liquidity_changed(origin, info)?;\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Sacrifice LP position in favor of pool.\n\t\t///\n\t\t/// A position is destroyed and liquidity owned by LP becomes pool owned liquidity.\n\t\t///\n\t\t/// Only owner of position can perform this action.\n\t\t///\n\t\t/// Emits `PositionDestroyed`.\n\t\t#[pallet::call_index(4)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::sacrifice_position())]\n\t\t#[transactional]\n\t\tpub fn sacrifice_position(origin: OriginFor<T>, position_id: T::PositionItemId) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tlet position = Positions::<T>::get(position_id).ok_or(Error::<T>::PositionNotFound)?;\n\n\t\t\tensure!(\n\t\t\t\tT::NFTHandler::owner(&T::NFTCollectionId::get(), &position_id) == Some(who.clone()),\n\t\t\t\tError::<T>::Forbidden\n\t\t\t);\n\n\t\t\tAssets::<T>::try_mutate(position.asset_id, |maybe_asset| -> DispatchResult {\n\t\t\t\tlet asset_state = maybe_asset.as_mut().ok_or(Error::<T>::AssetNotFound)?;\n\n\t\t\t\tasset_state.protocol_shares = asset_state\n\t\t\t\t\t.protocol_shares\n\t\t\t\t\t.checked_add(position.shares)\n\t\t\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\t\tOk(())\n\t\t\t})?;\n\n\t\t\t// Destroy position and burn NFT\n\t\t\t<Positions<T>>::remove(position_id);\n\t\t\tT::NFTHandler::burn(&T::NFTCollectionId::get(), &position_id, Some(&who))?;\n\n\t\t\tSelf::deposit_event(Event::PositionDestroyed {\n\t\t\t\tposition_id,\n\t\t\t\towner: who,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Execute a swap of `asset_in` for `asset_out`.\n\t\t///\n\t\t/// Price is determined by the Omnipool.\n\t\t///\n\t\t/// Hub asset is traded separately.\n\t\t///\n\t\t/// Asset's tradable states must contain SELL flag for asset_in and BUY flag for asset_out, otherwise `NotAllowed` error is returned.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `asset_in`: ID of asset sold to the pool\n\t\t/// - `asset_out`: ID of asset bought from the pool\n\t\t/// - `amount`: Amount of asset sold\n\t\t/// - `min_buy_amount`: Minimum amount required to receive\n\t\t///\n\t\t/// Emits `SellExecuted` event when successful.\n\t\t///\n\t\t#[pallet::call_index(5)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::sell()\n\t\t\t.saturating_add(T::OmnipoolHooks::on_trade_weight())\n\t\t\t.saturating_add(T::OmnipoolHooks::on_liquidity_changed_weight())\n\t\t)]\n\t\t#[transactional]\n\t\tpub fn sell(\n\t\t\torigin: OriginFor<T>,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tmin_buy_amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin.clone())?;\n\n\t\t\tensure!(asset_in != asset_out, Error::<T>::SameAssetTradeNotAllowed);\n\n\t\t\tensure!(\n\t\t\t\tamount >= T::MinimumTradingLimit::get(),\n\t\t\t\tError::<T>::InsufficientTradingAmount\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tT::Currency::ensure_can_withdraw(asset_in, &who, amount).is_ok(),\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\n\t\t\t// Special handling when one of the asset is Hub Asset\n\t\t\t// Math is simplified and asset_in is actually part of asset_out state in this case\n\t\t\tif asset_in == T::HubAssetId::get() {\n\t\t\t\treturn Self::sell_hub_asset(origin, &who, asset_out, amount, min_buy_amount);\n\t\t\t}\n\n\t\t\tif asset_out == T::HubAssetId::get() {\n\t\t\t\treturn Self::sell_asset_for_hub_asset(&who, asset_in, amount, min_buy_amount);\n\t\t\t}\n\n\t\t\tlet asset_in_state = Self::load_asset_state(asset_in)?;\n\t\t\tlet asset_out_state = Self::load_asset_state(asset_out)?;\n\n\t\t\tensure!(\n\t\t\t\tSelf::allow_assets(&asset_in_state, &asset_out_state),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tamount\n\t\t\t\t\t<= asset_in_state\n\t\t\t\t\t\t.reserve\n\t\t\t\t\t\t.checked_div(T::MaxInRatio::get())\n\t\t\t\t\t\t.ok_or(ArithmeticError::DivisionByZero)?, // Note: this can only fail if MaxInRatio is zero.\n\t\t\t\tError::<T>::MaxInRatioExceeded\n\t\t\t);\n\n\t\t\tlet current_imbalance = <HubAssetImbalance<T>>::get();\n\n\t\t\tlet (asset_fee, _) = T::Fee::get(&asset_out);\n\t\t\tlet (_, protocol_fee) = T::"
    }
  ]
}