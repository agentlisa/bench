{
  "Title": "`AMM.exchange()` has no deadline",
  "Content": "##### Description\n\nThe `AMM.exchange()` and `AMM.exchange_dy()` functions have slippage checks for output tokens; however, they do not have a deadline check for the transaction:\n\n```\ndef exchange(i, j, in_amount, min_amount, _for)\n...\ndef exchange_dy(i, j, out_amount, max_amount, _for)\n```\n\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/AMM.vy#L1284-L1312\n\nA realistic scenario is possible where, due to high gas prices, an `exchange()` transaction will remain in the mempool for a significant amount of time, and the prices in the AMM may change significantly. This would allow MEV-bots to steal the user's positive slippage (unrealized profit).\n\n##### Recommendation\n\nIt is recommended to add a `deadline` parameter in exchange functions.\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/AMM.vy",
      "content": "# @version 0.3.7\n\n# Glossary of variables and terms\n# =======================\n# * ticks, bands - price ranges where liquidity is deposited\n# * x - coin which is being borrowed, typically stablecoin\n# * y - collateral coin (for example, wETH)\n# * A - amplification, the measure of how concentrated the tick is\n# * rate - interest rate\n# * rate_mul - rate multiplier, 1 + integral(rate * dt)\n# * active_band - current band. Other bands are either in one or other coin, but not both\n# * min_band - bands below this are definitely empty\n# * max_band - bands above this are definitely empty\n# * bands_x[n], bands_y[n] - amounts of coin x or y deposited in band n\n# * user_shares[user,n] / total_shares[n] - fraction of n'th band owned by a user\n# * p_oracle - external oracle price (can be from another AMM)\n# * p (as in get_p) - current price of AMM. It depends not only on the balances (x,y) in the band and active_band, but\n# also on p_oracle\n# * p_current_up, p_current_down - the value of p at constant p_oracle when y=0 or x=0 respectively for the band n\n# * p_oracle_up, p_oracle_down - edges of the band when p=p_oracle (steady state), happen when x=0 or y=0 respectively,\n# for band n.\n# * Grid of bands is set for p_oracle values such as:\n#   * p_oracle_up(n) = base_price * ((A - 1) / A)**n\n#   * p_oracle_down(n) = p_oracle_up(n) * (A - 1) / A = p_oracle_up(n+1)\n# * p_current_up and p_oracle_up change in opposite directions with n\n# * When intereste is accrued - all the grid moves by change of base_price\n#\n# Bonding curve reads as:\n# (f + x) * (g + y) = Inv = p_oracle * A**2 * y0**2\n# =======================\n\ninterface ERC20:\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\n    def approve(_spender: address, _value: uint256) -> bool: nonpayable\n\ninterface PriceOracle:\n    def price() -> uint256: view\n    def price_w() -> uint256: nonpayable\n\ninterface LMGauge:\n    def callback_collateral_shares(n: int256, collateral_per_share: DynArray[uint256, MAX_TICKS_UINT]): nonpayable\n    def callback_user_shares(user: address, n: int256, user_shares: DynArray[uint256, MAX_TICKS_UINT]): nonpayable\n\n\nevent TokenExchange:\n    buyer: indexed(address)\n    sold_id: uint256\n    tokens_sold: uint256\n    bought_id: uint256\n    tokens_bought: uint256\n\nevent Deposit:\n    provider: indexed(address)\n    amount: uint256\n    n1: int256\n    n2: int256\n\nevent Withdraw:\n    provider: indexed(address)\n    amount_borrowed: uint256\n    amount_collateral: uint256\n\nevent SetRate:\n    rate: uint256\n    rate_mul: uint256\n    time: uint256\n\nevent SetFee:\n    fee: uint256\n\nevent SetAdminFee:\n    fee: uint256\n\nevent SetPriceOracle:\n    price_oracle: address\n\n\nMAX_TICKS: constant(int256) = 50\nMAX_TICKS_UINT: constant(uint256) = 50\nMAX_SKIP_TICKS: constant(int256) = 1024\n\n\nstruct UserTicks:\n    ns: int256  # packs n1 and n2, each is int128\n    ticks: uint256[MAX_TICKS/2]  # Share fractions packed 2 per slot\n\nstruct DetailedTrade:\n    in_amount: uint256\n    out_amount: uint256\n    n1: int256\n    n2: int256\n    ticks_in: DynArray[uint256, MAX_TICKS_UINT]\n    last_tick_j: uint256\n    admin_fee: uint256\n\n\nBORROWED_TOKEN: immutable(ERC20)    # x\nBORROWED_PRECISION: immutable(uint256)\nCOLLATERAL_TOKEN: immutable(ERC20)  # y\nCOLLATERAL_PRECISION: immutable(uint256)\nBASE_PRICE: immutable(uint256)\nadmin: public(address)\n\nA: public(immutable(uint256))\nAminus1: immutable(uint256)\nA2: immutable(uint256)\nAminus12: immutable(uint256)\nSQRT_BAND_RATIO: immutable(uint256)  # sqrt(A / (A - 1))\nLOG_A_RATIO: immutable(int256)  # ln(A / (A - 1))\nMAX_ORACLE_DN_POW: immutable(uint256)  # (A / (A - 1)) ** 50\n\nfee: public(uint256)\nadmin_fee: public(uint256)\nrate: public(uint256)\nrate_time: uint256\nrate_mul: uint256\nactive_band: public(int256)\nmin_band: public(int256)\nmax_band: public(int256)\n\nadmin_fees_x: public(uint256)\nadmin_fees_y: public(uint256)\n\nprice_oracle_contract: public(PriceOracle)\nold_p_o: uint256\nold_dfee: uint256\nprev_p_o_time: uint256\nPREV_P_O_DELAY: constant(uint256) = 2 * 60  # s = 2 min\nMAX_P_O_CHG: constant(uint256) = 12500 * 10**14  # <= 2**(1/3) - max relative change to have fee < 50%\n\nbands_x: public(HashMap[int256, uint256])\nbands_y: public(HashMap[int256, uint256])\n\ntotal_shares: HashMap[int256, uint256]\nuser_shares: HashMap[address, UserTicks]\n\nliquidity_mining_callback: public(LMGauge)\n\n\n@external\ndef __init__(\n        _borrowed_token: address,\n        _borrowed_precision: uint256,\n        _collateral_token: address,\n        _collateral_precision: uint256,\n        _A: uint256,\n        _sqrt_band_ratio: uint256,\n        _log_A_ratio: int256,\n        _base_price: uint256,\n        fee: uint256,\n        admin_fee: uint256,\n        _price_oracle_contract: address,\n    ):\n    \"\"\"\n    @notice LLAMMA constructor\n    @param _borrowed_token Token which is being borrowed\n    @param _collateral_token Token used as collateral\n    @param _collateral_precision Precision of collateral: we pass it because we want the blueprint to fit into bytecode\n    @param _A \"Amplification coefficient\" which also defines density of liquidity and band size. Relative band size is 1/_A\n    @param _sqrt_band_ratio Precomputed int(sqrt(A / (A - 1)) * 1e18)\n    @param _log_A_ratio Precomputed int(ln(A / (A - 1)) * 1e18)\n    @param _base_price Typically the initial crypto price at which AMM is deployed. Will correspond to band 0\n    @param fee Relative fee of the AMM: int(fee * 1e18)\n    @param admin_fee Admin fee: how much of fee goes to admin. 50% === int(0.5 * 1e18)\n    @param _price_oracle_contract External price oracle which has price() and price_w() methods\n           which both return current price of collateral multiplied by 1e18\n    \"\"\"\n    BORROWED_TOKEN = ERC20(_borrowed_token)\n    BORROWED_PRECISION = _borrowed_precision\n    COLLATERAL_TOKEN = ERC20(_collateral_token)\n    COLLATERAL_PRECISION = _collateral_precision\n    A = _A\n    BASE_PRICE = _base_price\n\n    Aminus1 = unsafe_sub(A, 1)\n    A2 = pow_mod256(A, 2)\n    Aminus12 = pow_mod256(unsafe_sub(A, 1), 2)\n\n    self.fee = fee\n    self.admin_fee = admin_fee\n    self.price_oracle_contract = PriceOracle(_price_oracle_contract)\n    self.prev_p_o_time = block.timestamp\n    self.old_p_o = self.price_oracle_contract.price()\n\n    self.rate_mul = 10**18\n\n    # sqrt(A / (A - 1)) - needs to be pre-calculated externally\n    SQRT_BAND_RATIO = _sqrt_band_ratio\n    # log(A / (A - 1)) - needs to be pre-calculated externally\n    LOG_A_RATIO = _log_A_ratio\n\n    # (A / (A - 1)) ** 50\n    MAX_ORACLE_DN_POW = unsafe_div(pow_mod256(unsafe_div(A**25 * 10**18, pow_mod256(Aminus1, 25)), 2), 10**18)\n\n\n@internal\ndef approve_max(token: ERC20, _admin: address):\n    \"\"\"\n    Approve max in a separate function because it uses less bytespace than\n    calling directly, and gas doesn't matter in set_admin\n    \"\"\"\n    assert token.approve(_admin, max_value(uint256), default_return_value=True)\n\n\n@external\ndef set_admin(_admin: address):\n    \"\"\"\n    @notice Set admin of the AMM. Typically it's a controller (unless it's tests)\n    @param _admin Admin address\n    \"\"\"\n    assert self.admin == empty(address)\n    self.admin = _admin\n    self.approve_max(BORROWED_TOKEN, _admin)\n    self.approve_max(COLLATERAL_TOKEN, _admin)\n\n\n@internal\n@pure\ndef sqrt_int(_x: uint256) -> uint256:\n    \"\"\"\n    @notice Wrapping isqrt builtin because otherwise it will be repeated every time instead of calling\n    @param _x Square root's input in \"normal\" units, e.g. sqrt_int(1) == 1\n    \"\"\"\n    return isqrt(_x)\n\n\n@external\n@pure\ndef coins(i: uint256) -> address:\n    return [BORROWED_TOKEN.address, COLLATERAL_TOKEN.address][i]\n\n\n@internal\n@view\ndef limit_p_o(p: uint256) -> uint256[2]:\n    p_new: uint256 = p\n    dt: uint256 = unsafe_sub(PREV_P_O_DELAY, min(PREV_P_O_DELAY, block.timestamp - self.prev_p_o_time))\n    ratio: uint256 = 0\n\n    # ratio = 1 - (p_o_min / p_o_max)**3\n\n    if dt > 0:\n        old_p_o: uint256 = self.old_p_o\n        old_ratio: uint256 = self.old_dfee\n        # ratio = p_o_min / p_o_max\n        if p > old_p_o:\n            ratio = unsafe_div(old_p_o * 10**18, p)\n            if ratio < 10**36 / MAX_P_O_CHG:\n                p_new = unsafe_div(old_p_o * MAX_P_O_CHG, 10**18)\n                ratio = 10**36 / MAX_P_O_CHG\n        else:\n            ratio = unsafe_div(p * 10**18, old_p_o)\n            if ratio < 10**36 / MAX_P_O_CHG:\n                p_new = unsafe_div(old_p_o * 10**18, MAX_P_O_CHG)\n                ratio = 10**36 / MAX_P_O_CHG\n\n        # ratio is guaranteed to be less than 1e18\n        # Also guaranteed to be limited, therefore can have all ops unsafe\n        ratio = unsafe_div(\n            unsafe_mul(\n                unsafe_sub(unsafe_add(10**18, old_ratio), unsafe_div(pow_mod256(ratio, 3), 10**36)),  # (f' + (1 - r**3))\n                dt),                                                                                  # * dt / T\n            PREV_P_O_DELAY)\n\n    return [p_new, ratio]\n\n\n@internal\n@view\ndef _price_oracle_ro() -> uint256[2]:\n    return self.limit_p_o(self.price_oracle_contract.price())\n\n\n@internal\ndef _price_oracle_w() -> uint256[2]:\n    p: uint256[2] = self.limit_p_o(self.price_oracle_contract.price_w())\n    self.prev_p_o_time = block.timestamp\n    self.old_p_o = p[0]\n    self.old_dfee = p[1]\n    return p\n\n\n@external\n@view\ndef price_oracle() -> uint256:\n    \"\"\"\n    @notice Value returned by the external price oracle contract\n    \"\"\"\n    return self._price_oracle_ro()[0]\n\n\n@external\n@view\ndef dynamic_fee() -> uint256:\n    \"\"\"\n    @notice Dynamic fee which accounts for price_oracle shifts\n    \"\"\"\n    return max(self.fee, self._price_oracle_ro()[1])\n\n\n@internal\n@view\ndef _rate_mul() -> uint256:\n    \"\"\"\n    @notice Rate multiplier which is 1.0 + integral(rate, dt)\n    @return Rate multiplier in units where 1.0 == 1e18\n    \"\"\"\n    return self.rate_mul + self.rate * (block.timestamp - self.rate_time)\n\n\n@external\n@view\ndef get_rate_mul() -> uint256:\n    \"\"\"\n    @notice Rate multiplier which is 1.0 + integral(rate, dt)\n    @return Rate multiplier in units where 1.0 == 1e18\n    \"\"\"\n    return self._rate_mul()\n\n\n@internal\n@view\ndef _base_price() -> uint256:\n    \"\"\"\n    @notice Price which corresponds to band 0.\n            Base price grows with time to account for interest rate (which is 0 by default)\n    \"\"\"\n    return unsafe_div(BASE_PRICE * self._rate_mul(), 10**18)\n\n\n@external\n@view\ndef get_base_price() -> uint256:\n    \"\"\"\n    @notice Price which corresponds to band 0.\n            Base price grows with time to account for interest rate (which is 0 by default)\n    \"\"\"\n    return self._base_price()\n\n\n@internal\n@view\ndef _p_oracle_up(n: int256) -> uint256:\n    \"\"\"\n    @notice Upper oracle price for the band to have liquidity when p = p_oracle\n    @param n Band number (can be negative)\n    @return Price at 1e18 base\n    \"\"\"\n    # p_oracle_up(n) = p_base * ((A - 1) / A) ** n\n    # p_oracle_down(n) = p_base * ((A - 1) / A) ** (n + 1) = p_oracle_up(n+1)\n    # return unsafe_div(self._base_price() * self.exp_int(-n * LOG_A_RATIO), 10**18)\n\n    power: int256 = -n * LOG_A_RATIO\n\n    # ((A - 1) / A) ** n = exp(-n * A / (A - 1)) = exp(-n * LOG_A_RATIO)\n    ## Exp implementation based on solmate's\n    assert power > -42139678854452767551\n    assert power < 135305999368893231589\n\n    x: int256 = unsafe_div(unsafe_mul(power, 2**96), 10**18)\n\n    k: int256 = unsafe_div(\n        unsafe_add(\n            unsafe_div(unsafe_mul(x, 2**96), 54916777467707473351141471128),\n            2**95),\n        2**96)\n    x = unsafe_sub(x, unsafe_mul(k, 54916777467707473351141471128))\n\n    y: int256 = unsafe_add(x, 1346386616545796478920950773328)\n    y = unsafe_add(unsafe_div(unsafe_mul(y, x), 2**96), 57155421227552351082224309758442)\n    p: int256 = unsafe_sub(unsafe_add(y, x), 94201549194550492254356042504812)\n    p = unsafe_add(unsafe_div(unsafe_mul(p, y), 2**96), 28719021644029726153956944680412240)\n    p = unsafe_add(unsafe_mul(p, x), (4385272521454847904659076985693276 * 2**96))\n\n    q: int256 = x - 2855989394907223263936484059900\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 50020603652535783019961831881945)\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 533845033583426703283633433725380)\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 3604857256930695427073651918091429)\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 14423608567350463180887372962807573)\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 26449188498355588339934803723976023)\n\n    exp_result: uint256 = shift(\n        unsafe_mul(convert(unsafe_div(p, q), uint256), 3822833074963236453042738258902158003155416615667),\n        unsafe_sub(k, 195))\n    ## End exp\n    return unsafe_div(self._base_price() * exp_result, 10**18)\n\n\n@internal\n@view\ndef _p_current_band(n: int256) -> uint256:\n    \"\"\"\n    @notice Lowest possible price of the band at current oracle price\n    @param n Band number (can be negative)\n    @return Price at 1e18 base\n    \"\"\"\n    # k = (self.A - 1) / self.A  # equal to (p_down / p_up)\n    # p_base = self.p_base * k ** n = p_oracle_up(n)\n    p_base: uint256 = self._p_oracle_up(n)\n\n    # return self.p_oracle**3 / p_base**2\n    p_oracle: uint256 = self._price_oracle_ro()[0]\n    return unsafe_div(p_oracle**2 / p_base * p_oracle, p_base)\n\n\n@external\n@view\ndef p_current_up(n: int256) -> uint256:\n    \"\"\"\n    @notice Highest possible price of the band at current oracle price\n    @param n Band number (can be negative)\n    @return Price at 1e18 base\n    \"\"\"\n    return self._p_current_band(n + 1)\n\n\n@external\n@view\ndef p_current_down(n: int256) -> uint256:\n    \"\"\"\n    @notice Lowest possible price of the band at current oracle price\n    @param n Band number (can be negative)\n    @return Price at 1e18 base\n    \"\"\"\n    return self._p_current_band(n)\n\n\n@external\n@view\ndef p_oracle_up(n: int256) -> uint256:\n    \"\"\"\n    @notice Highest oracle price for the band to have liquidity when p = p_oracle\n    @param n Band number (can be negative)\n    @return Price at 1e18 base\n    \"\"\"\n    return self._p_oracle_up(n)\n\n\n@external\n@view\ndef p_oracle_down(n: int256) -> uint256:\n    \"\"\"\n    @notice Lowest oracle price for the band to have liquidity when p = p_oracle\n    @param n Band number (can be negative)\n    @return Price at 1e18 base\n    \"\"\"\n    return self._p_oracle_up(n + 1)\n\n\n@internal\n@view\ndef _get_y0(x: uint256, y: uint256, p_o: uint256, p_o_up: uint256) -> uint256:\n    \"\"\"\n    @notice Calculate y0 for the invariant based on current liquidity in band.\n            The value of y0 has a meaning of amount of collateral when band has no stablecoin\n            but current price is equal to both oracle price and upper band price.\n    @param x Amount of stablecoin in band\n    @param y Amount of collateral in band\n    @param p_o External oracle price\n    @param p_o_up Upper boundary of the band\n    @return y0\n    \"\"\"\n    assert p_o != 0\n    # solve:\n    # p_o * A * y0**2 - y0 * (p_oracle_up/p_o * (A-1) * x + p_o**2/p_oracle_up * A * y) - xy = 0\n    b: uint256 = 0\n    # p_o_up * unsafe_sub(A, 1) * x / p_o + A * p_o**2 / p_o_up * y / 10**18\n    if x != 0:\n        b = unsafe_div(p_o_up * Aminus1 * x, p_o)\n    if y != 0:\n        b += unsafe_div(A * p_o**2 / p_o_up * y, 10**18)\n    if x > 0 and y > 0:\n        D: uint256 = b**2 + unsafe_div(((4 * A) * p_o) * y, 10**18) * x\n        return unsafe_div((b + self.sqrt_int(D)) * 10**18, unsafe_mul(2 * A, p_o))\n    else:\n        return unsafe_div(b * 10**18, A * p_o)\n\n\n@internal\n@view\ndef _get_p(n: int256, x: uint256, y: uint256) -> uint256:\n    \"\"\"\n    @notice Get current AMM price in band\n    @param n Band number\n    @param x Amount of stablecoin in band\n    @param y Amount of collateral in band\n    @return Current price at 1e18 base\n    \"\"\"\n    p_o_up: uint256 = self._p_oracle_up(n)\n    p_o: uint256 = self._price_oracle_ro()[0]\n\n    # Special cases\n    if x == 0:\n        if y == 0:  # x and y are 0\n            # Return mid-band\n            return unsafe_div((unsafe_div(p_o**2 / p_o_up * p_o, p_o_up) * A), Aminus1)\n        # if x == 0: # Lowest point of this band -> p_current_down\n        return unsafe_div(p_o**2 / p_o_up * p_o, p_o_up)\n    if y == 0: # Highest point of this band -> p_current_up\n        p_o_up = unsafe_div(p_o_up * Aminus1, A)  # now this is _actually_ p_o_down\n        return unsafe_div(p_o**2 / p_o_up * p_o, p_o_up)\n\n    y0: uint256 = self._get_y0(x, y, p_o, p_o_up)\n    # ^ that call also checks that p_o != 0\n\n    # (f(y0) + x) / (g(y0) + y)\n    f: uint256 = A * y0 * p_o / p_o_up * p_o\n    g: uint256 = unsafe_div(Aminus1 * y0 * p_o_up, p_o)\n    return (f + x * 10**18) / (g + y)\n\n\n@external\n@view\n@nonreentrant('lock')\ndef get_p() -> uint256:\n    \"\"\"\n    @notice Get current AMM price in active_band\n    @return Current price at 1e18 base\n    \"\"\"\n    n: int256 = self.active_band\n    return self._get_p(n, self.bands_x[n], self.bands_y[n])\n\n\n@internal\n@view\ndef _read_user_tick_numbers(user: address) -> int256[2]:\n    \"\"\"\n    @notice Unpacks and reads user tick numbers\n    @param user User address\n    @return Lowest and highest band the user deposited into\n    \"\"\"\n    ns: int256 = self.user_shares[user].ns\n    n2: int256 = unsafe_div(ns, 2**128)\n    n1: int256 = ns % 2**128\n    if n1 >= 2**127:\n        n1 = unsafe_sub(n1, 2**128)\n        n2 = unsafe_add(n2, 1)\n    return [n1, n2]\n\n\n@external\n@view\n@nonreentrant('lock')\ndef read_user_tick_numbers(user: address) -> int256[2]:\n    \"\"\"\n    @notice Unpacks and reads user tick numbers\n    @param user User address\n    @return Lowest and highest band the user deposited into\n    \"\"\"\n    return self._read_user_tick_numbers(user)\n\n\n@internal\n@view\ndef _read_user_ticks(user: address, ns: int256[2]) -> DynArray[uint256, MAX_TICKS_UINT]:\n    \"\"\"\n    @notice Unpacks and reads user ticks (shares) for all the ticks user deposited into\n    @param user User address\n    @param size Number of ticks the user deposited into\n    @return Array of shares the user has\n    \"\"\"\n    ticks: DynArray[uint256, MAX_TICKS_UINT] = []\n    size: uint256 = convert(ns[1] - ns[0] + 1, uint256)\n    for i in range(MAX_TICKS / 2):\n        if len(ticks) == size:\n            break\n        tick: uint256 = self.user_shares[user].ticks[i]\n        ticks.append(tick & (2**128 - 1))\n        if len(ticks) == size:\n            break\n        ticks.append(shift(tick, -128))\n    return ticks\n\n\n@external\n@view\n@nonreentrant('lock')\ndef can_skip_bands(n_end: int256) -> bool:\n    \"\"\"\n    @notice Check that we have no liquidity between active_band and `n_end`\n    \"\"\"\n    n: int256 = self.active_band\n    for i in range(MAX_SKIP_TICKS):\n        if n_end > n:\n            if self.bands_y[n] != 0:\n                return False\n            n = unsafe_add(n, 1)\n        else:\n            if self.bands_x[n] != 0:\n                return False\n            n = unsafe_sub(n, 1)\n        if n == n_end:  # not including n_end\n            break\n    return True\n    # Actually skipping bands:\n    # * change self.active_band to the new n\n    # * change self.p_base_mul\n    # to do n2-n1 times (if n2 > n1):\n    # out.base_mul = unsafe_div(out.base_mul * Aminus1, A)\n\n\n@external\n@view\n@nonreentrant('lock')\ndef active_band_with_skip() -> int256:\n    n: int256 = self.active_band\n    for i in range(MAX_SKIP_TICKS):\n        if self.bands_x[n] != 0:\n            break\n        n -= 1\n    return n\n\n\n@external\n@view\n@nonreentrant('lock')\ndef has_liquidity(user: address) -> bool:\n    \"\"\"\n    @notice Check if `user` has any liquidity in the AMM\n    \"\"\"\n    return self.user_shares[user].ticks[0] != 0\n\n\n@internal\ndef save_user_shares(user: address, user_shares: DynArray[uint256, MAX_TICKS_UINT]):\n    ptr: uint256 = 0\n    for j in range(MAX_TICKS_UINT / 2):\n        if ptr >= len(user_shares):\n            break\n        tick: uint256 = user_shares[ptr]\n        ptr = unsafe_add(ptr, 1)\n        if len(user_shares) != ptr:\n            tick = tick | shift(user_shares[ptr], 128)\n        ptr = unsafe_add(ptr, 1)\n        self.user_shares[user].ticks[j] = tick\n\n\n@external\n@nonreentrant('lock')\ndef deposit_range(user: address, amount: uint256, n1: int256, n2: int256):\n    \"\"\"\n    @notice Deposit for a user in a range of bands. Only admin contract (Controller) can do it\n    @param user User address\n    @param amount Amount of collateral to deposit\n    @param n1 Lower band in the deposit range\n    @param n2 Upper band in the deposit range\n    \"\"\"\n    assert msg.sender == self.admin\n\n    user_shares: DynArray[uint256, MAX_TICKS_UINT] = []\n    collateral_shares: DynArray[uint256, MAX_TICKS_UINT] = []\n\n    n0: int256 = self.active_band\n\n    # We assume that n1,n2 area already sorted (and they are in Controller)\n    assert n2 < 2**127\n    assert n1 > -2**127\n\n    lm: LMGauge = self.liquidity_mining_callback\n\n    # Autoskip bands if we can\n    for i in range(MAX_SKIP_TICKS + 1):\n        if n1 > n0:\n            if i != 0:\n                self.active_band = n0\n            break\n        assert self.bands_x[n0] == 0 and i < MAX_SKIP_TICKS, \"Deposit below current band\"\n        n0 -= 1\n\n    n_bands: uint256 = unsafe_add(convert(unsafe_sub(n2, n1), uint256), 1)\n    assert n_bands <= MAX_TICKS_UINT\n\n    y_per_band: uint256 = unsafe_div(amount * COLLATERAL_PRECISION, n_bands)\n    assert y_per_band > 100, \"Amount too low\"\n\n    assert self.user_shares[user].ticks[0] == 0  # dev: User must have no liquidity\n    self.user_shares[user].ns = unsafe_add(n1, unsafe_mul(n2, 2**128))\n\n    for i in range(MAX_TICKS):\n        band: int256 = unsafe_add(n1, i)\n        if band > n2:\n            break\n\n        assert self.bands_x[band] == 0, \"Band not empty\"\n        y: uint256 = y_per_band\n        if i == 0:\n            y = amount * COLLATERAL_PRECISION - y * unsafe_sub(n_bands, 1)\n\n        total_y: uint256 = self.bands_y[band]\n\n        # Total / user share\n        s: uint256 = self.total_shares[band]\n        ds: uint256 = y\n        if s == 0:\n            assert y < 2**128\n        else:\n            ds = s * y / total_y\n            assert ds > 0, \"Amount too low\"\n        user_shares.append(ds)\n        s += ds\n        self.total_shares[band] = s\n\n        total_y += y\n        self.bands_y[band] = total_y\n\n        if lm.address != empty(address):\n            # If initial s == 0 - s becomes equal to y which is > 100 => nonzero\n            collateral_shares.append(total_y * 10**18 / s)\n\n    self.min_band = min(self.min_band, n1)\n    self.max_band = max(self.max_band, n2)\n\n    self.save_user_shares(user, user_shares)\n\n    self.rate_mul = self._rate_mul()\n    self.rate_time = block.timestamp\n\n    log Deposit(user, amount, n1, n2)\n\n    if lm.address != empty(address):\n        lm.callback_collateral_shares(n1, collateral_shares)\n        lm.callback_user_shares(user, n1, user_shares)\n\n\n@external\n@nonreentrant('lock')\ndef withdraw(user: address, frac: uint256) -> uint256[2]:\n    \"\"\"\n    @notice Withdraw all liquidity for the user. Only admin contract can do it\n    @param user User who owns liquidity\n    @param frac Fraction to withdraw (1e18 being 100%)\n    @return Amount of [stablecoins, collateral] withdrawn\n    \"\"\"\n    assert msg.sender == self.admin\n    assert frac <= 10**18\n\n    lm: LMGauge = self.liquidity_mining_callback\n\n    ns: int256[2] = self._read_user_tick_numbers(user)\n    n: int256 = ns[0]\n    user_shares: DynArray[uint256, MAX_TICKS_UINT] = self._read_user_ticks(user, ns)\n    assert user_shares[0] > 0, \"No deposits\"\n\n    total_x: uint256 = 0\n    total_y: uint256 = 0\n    min_band: int256 = self.min_band\n    old_min_band: int256 = min_band\n    max_band: int256 = self.max_band\n    old_max_band: int256 = max_band\n\n    for i in range(MAX_TICKS):\n        x: uint256 = self.bands_x[n]\n        y: uint256 = self.bands_y[n]\n        ds: uint256 = unsafe_div(frac * user_shares[i], 10**18)  # Can ONLY zero out when frac == 10**18\n        user_shares[i] = unsafe_sub(user_shares[i], ds)\n        s: uint256 = self.total_shares[n]\n        dx: uint256 = x * ds / s\n        dy: uint256 = unsafe_div(y * ds, s)\n\n        self.total_shares[n] = s - ds\n        x -= dx\n        y -= dy\n        if n == min_band:\n            if x == 0:\n                if y == 0:\n                    min_band += 1\n        if x > 0 or y > 0:\n            max_band = n\n        self.bands_x[n] = x\n        self.bands_y[n] = y\n        total_x += dx\n        total_y += dy\n\n        if n == ns[1]:\n            break\n        else:\n            n = unsafe_add(n, 1)\n\n    # Empty the ticks\n    if frac == 10**18:\n        self.user_shares[user].ticks[0] = 0\n    else:\n        self.save_user_shares(user, user_shares)\n\n    if old_min_band != min_band:\n        self.min_band = min_band\n    if old_max_band <= ns[1]:\n        self.max_band = max_band\n\n    total_x = unsafe_div(total_x, BORROWED_PRECISION)\n    total_y = unsafe_div(total_y, COLLATERAL_PRECISION)\n    log Withdraw(user, total_x, total_y)\n\n    self.rate_mul = self._rate_mul()\n    self.rate_time = block.timestamp\n\n    if lm.address != empty(address):\n        lm.callback_collateral_shares(0, [])  # collateral/shares ratio is unchanged\n        lm.callback_user_shares(user, ns[0], user_shares)\n\n    return [total_x, total_y]\n\n\n@internal\n@view\ndef calc_swap_out(pump: bool, in_amount: uint256, p_o: uint256[2], in_precision: uint256, out_precision: uint256) -> DetailedTrade:\n    \"\"\"\n    @notice Calculate the amount which can be obtained as a result of exchange.\n            If couldn't exchange all - will also update the amount which was actually used.\n            Also returns other parameters related to state after swap.\n            This function is core to the AMM functionality.\n    @param pump Indicates whether the trade buys or sells collateral\n    @param in_amount Amount of token going in\n    @param p_o Current oracle price and ratio (p_o, (r**3 - 1) / (r**3 + 1))\n    @return Amounts spent and given out, initial and final bands of the AMM, new\n            amounts of coins in bands in the AMM, as well as admin fee charged,\n            all in one data structure\n    \"\"\"\n    # pump = True: borrowable (USD) in, collateral (ETH) out; going up\n    # pump = False: collateral (ETH) in, borrowable (USD) out; going down\n    min_band: int256 = self.min_band\n    max_band: int256 = self.max_band\n    out: DetailedTrade = empty(DetailedTrade)\n    out.n2 = self.active_band\n    p_o_up: uint256 = self._p_oracle_up(out.n2)\n    x: uint256 = self.bands_x[out.n2]\n    y: uint256 = self.bands_y[out.n2]\n\n    in_amount_left: uint256 = in_amount\n    antifee: uint256 = unsafe_div(\n        (10**18)**2,\n        unsafe_sub(10**18, max(self.fee, p_o[1]))\n    )\n    admin_fee: uint256 = self.admin_fee\n    j: uint256 = MAX_TICKS_UINT\n\n    for i in range(MAX_TICKS + MAX_SKIP_TICKS):\n        y0: uint256 = 0\n        f: uint256 = 0\n        g: uint256 = 0\n        Inv: uint256 = 0\n\n        if x > 0 or y > 0:\n            if j == MAX_TICKS_UINT:\n                out.n1 = out.n2\n                j = 0\n            y0 = self._get_y0(x, y, p_o[0], p_o_up)  # <- also checks p_o\n            f = unsafe_div(A * y0 * p_o[0] / p_o_up * p_o[0], 10**18)\n            g = unsafe_div(Aminus1 * y0 * p_o_up, p_o[0])\n            Inv = (f + x) * (g + y)\n\n        if j != MAX_TICKS_UINT:\n            # Initialize\n            _tick: uint256 = y\n            if pump:\n                _tick = x\n            out.ticks_in.append(_tick)\n\n        # Need this to break if price is too far\n        p_ratio: uint256 = unsafe_div(p_o_up * 10**18, p_o[0])\n\n        if pump:\n            if y != 0:\n                if g != 0:\n                    x_dest: uint256 = (unsafe_div(Inv, g) - f) - x\n                    dx: uint256 = unsafe_div(x_dest * antifee, 10**18)\n                    if dx >= in_amount_left:\n                        # This is the last band\n                        x_dest = unsafe_div(in_amount_left * 10**18, antifee)  # LESS than in_amount_left\n                        out.last_tick_j = min(Inv / (f + (x + x_dest)) - g + 1, y)  # Should be always >= 0\n                        x_dest = unsafe_div(unsafe_sub(in_amount_left, x_dest) * admin_fee, 10**18)  # abs admin fee now\n                        x += in_amount_left  # x is precise after this\n                        # Round down the output\n                        out.out_amount += y - out.last_tick_j\n                        out.ticks_in[j] = x - x_dest\n                        out.in_amount = in_amount\n                        out.admin_fee = unsafe_add(out.admin_fee, x_dest)\n                        break\n\n                    else:\n                        # We go into the next band\n                        dx = max(dx, 1)  # Prevents from leaving dust in the band\n                        x_dest = unsafe_div(unsafe_sub(dx, x_dest) * admin_fee, 10**18)  # abs admin fee now\n                        in_amount_left -= dx\n                        out.ticks_in[j] = x + dx - x_dest\n                        out.in_amount += dx\n                        out.out_amount += y\n                        out.admin_fee = unsafe_add(out.admin_fee, x_dest)\n\n            if i != MAX_TICKS + MAX_SKIP_TICKS - 1:\n                if out.n2 == max_band:\n                    break\n                if j == MAX_TICKS_UINT - 1:\n                    break\n                if p_ratio < 10**36 / MAX_ORACLE_DN_POW:\n                    # Don't allow to be away by more than ~50 ticks\n                    break\n                out.n2 += 1\n                p_o_up = unsafe_div(p_o_up * Aminus1, A)\n                x = 0\n                y = self.bands_y[out.n2]\n\n        else:  # dump\n            if x != 0:\n                if f != 0:\n                    y_dest: uint256 = (unsafe_div(Inv, f) - g) - y\n                    dy: uint256 = unsafe_div(y_dest * antifee, 10**18)\n                    if dy >= in_amount_left:\n                        # This is the last band\n                        y_dest = unsafe_div(in_amount_left * 10**18, antifee)\n                        out.last_tick_j = min(Inv / (g + (y + y_dest)) - f + 1, x)\n                        y_dest = unsafe_div(unsafe_sub(in_amount_left, y_dest) * admin_fee, 10**18)  # abs admin fee now\n                        y += in_amount_left\n                        out.out_amount += x - out.last_tick_j\n                        out.ticks_in[j] = y - y_dest\n                        out.in_amount = in_amount\n                        out.admin_fee = unsafe_add(out.admin_fee, y_dest)\n                        break\n\n                    else:\n                        # We go into the next band\n                        dy = max(dy, 1)  # Prevents from leaving dust in the band\n                        y_dest = unsafe_div(unsafe_sub(dy, y_dest) * admin_fee, 10**18)  # abs admin fee now\n                        in_amount_left -= dy\n                        out.ticks_in[j] = y + dy - y_dest\n                        out.in_amount += dy\n                        out.out_amount += x\n                        out.admin_fee = unsafe_add(out.admin_fee, y_dest)\n\n            if i != MAX_TICKS + MAX_SKIP_TICKS - 1:\n                if out.n2 == min_band:\n                    break\n                if j == MAX_TICKS_UINT - 1:\n                    break\n                if p_ratio > MAX_ORACLE_DN_POW:\n                    # Don't allow to be away by more than ~50 ticks\n                    break\n                out.n2 -= 1\n                p_o_up = unsafe_div(p_o_up * A, Aminus1)\n                x = self.bands_x[out.n2]\n                y = 0\n\n        if j != MAX_TICKS_UINT:\n            j = unsafe_add(j, 1)\n\n    # Round up what goes in and down what goes out\n    # ceil(in_amount_used/BORROWED_PRECISION) * BORROWED_PRECISION\n    out.in_amount = unsafe_mul(unsafe_div(unsafe_add(out.in_amount, unsafe_sub(in_precision, 1)), in_precision), in_precision)\n    out.out_amount = unsafe_mul(unsafe_div(out.out_amount, out_precision), out_precision)\n\n    return out\n\n\n@internal\n@view\ndef _get_dxdy(i: uint256, j: uint256, amount: uint256, is_in: bool) -> DetailedTrade:\n    \"\"\"\n    @notice Method to use to calculate out amount and spent in amount\n    @param i Input coin index\n    @param j Output coin index\n    @param amount Amount of input coin to swap\n    @param is_in Whether IN our OUT amount is known\n    @return DetailedTrade with all swap results\n    \"\"\"\n    # i = 0: borrowable (USD) in, collateral (ETH) out; going up\n    # i = 1: collateral (ETH) in, borrowable (USD) out; going down\n    assert (i == 0 and j == 1) or (i == 1 and j == 0), \"Wrong index\"\n    out: DetailedTrade = empty(DetailedTrade)\n    if amount == 0:\n        return out\n    in_precision: uint256 = COLLATERAL_PRECISION\n    out_precision: uint256 = BORROWED_PRECISION\n    if i == 0:\n        in_precision = BORROWED_PRECISION\n        out_precision = COLLATERAL_PRECISION\n    p_o: uint256[2] = self._pri"
    }
  ]
}