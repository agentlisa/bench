{
  "Title": "[S-01] `ChainlinkCompositeOracle::getDerivedPriceThreeOracles` is very specialized",
  "Content": "\nhttps://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Oracles/ChainlinkCompositeOracle.sol#L157-L159\n```solidity\nFile: Oracles/ChainlinkCompositeOracle.sol\n\n157:        return\n158:            ((firstPrice * secondPrice * thirdPrice) / scalingFactor)\n159:                .toUint256();\n```\n\nHere the three prices for the oracles are multiplied together. This requires a setup of prices like this:\nFirst one is stated to be `ETH`/`USD`\n\nso there would have to be oracles:\n\n`ETH`/`USD`, `A`/`ETH`, `B`/`A` to get the price `B`/`USD`\n\nThis is very limited which chainlink prices support \"chaining\" like this, the one used in integration test seems to one of the few:\n\n`ETH`/`USD`, `stETH`/`ETH`, `wstETH`/`stETH` on Arbitrum.\n\n### Recommendations\nConsider adding the ability to either multiply or divide by the last one, as that would give greater flexibility in which feeds can be used.\n\n## Refactoring (4)\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-moonwell",
  "Code": [
    {
      "filename": "src/core/Oracles/ChainlinkCompositeOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {AggregatorV3Interface} from \"@protocol/core/Oracles/AggregatorV3Interface.sol\";\n\n/// @notice contract to combine multiple chainlink oracle prices together\n/// allows combination of either 2 or 3 chainlink oracles\ncontract ChainlinkCompositeOracle {\n    using SafeCast for *;\n\n    /// @notice reference to a base price feed chainlink oracle\n    /// in case of steth or cbeth this would be eth/usd\n    address public immutable base;\n\n    /// @notice reference to the first multiplier. in the case of wsteth or cbeth\n    /// this is then eth/steth or eth/cbeth\n    address public immutable multiplier;\n\n    /// @notice reference to the second multiplier contract\n    /// this should be the wsteth/eth conversion contract\n    address public immutable secondMultiplier;\n\n    /// @notice scaling factor applied to price, always 18 decimals to avoid additional\n    /// logic in the chainlink oracle contract\n    /// @dev this is also used for backwards compatability in the ChainlinkOracle.sol contract\n    /// and makes that contract think this composite oracle is talking directly to chainlink\n    uint8 public constant decimals = 18;\n\n    /// @notice construct the contract\n    /// @param baseAddress The base oracle address\n    /// @param multiplierAddress The multiplier oracle address\n    /// @param secondMultiplierAddress The second multiplier oracle address\n    constructor(\n        address baseAddress,\n        address multiplierAddress,\n        address secondMultiplierAddress\n    ) {\n        base = baseAddress;\n        multiplier = multiplierAddress;\n        secondMultiplier = secondMultiplierAddress;\n    }\n\n    /// @notice Get the latest price of a base/quote pair\n    /// interface for compatabililty with getChainlinkPrice function in ChainlinkOracle.sol\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80, /// roundId always 0, value unused in ChainlinkOracle.sol\n            int256, /// the composite price\n            uint256, /// startedAt always 0, value unused in ChainlinkOracle.sol\n            uint256, /// always block.timestamp\n            uint80 /// answeredInRound always 0, value unused in ChainlinkOracle.sol\n        )\n    {\n        if (secondMultiplier == address(0)) {\n            /// if there is only one multiplier, just use that\n            return (\n                0,\n                /// fetch uint256, then cast back to int256, this cast to uint256 is a sanity check\n                /// that chainlink did not return a negative value\n                getDerivedPrice(base, multiplier, decimals).toInt256(),\n                0,\n                block.timestamp, /// return current block timestamp\n                0\n            );\n        }\n\n        /// if there is a second multiplier apply it\n        return (\n            0, /// unused\n            getDerivedPriceThreeOracles(\n                base,\n                multiplier,\n                secondMultiplier,\n                decimals\n            ).toInt256(),\n            0, /// unused\n            block.timestamp, /// return current block timestamp\n            0 /// unused\n        );\n    }\n\n    /// @notice Get the derived price of a base/quote pair with price data\n    /// @param basePrice The price of the base token\n    /// @param priceMultiplier The price of the quote token\n    /// @param scalingFactor The expected decimals of the derived price scaled up by 10 ** decimals\n    function calculatePrice(\n        int256 basePrice,\n        int256 priceMultiplier,\n        int256 scalingFactor\n    ) public pure returns (uint256) {\n        return ((basePrice * priceMultiplier) / scalingFactor).toUint256();\n    }\n\n    /// @notice Get the derived price of a base/quote pair\n    /// @param baseAddress The base oracle address\n    /// @param multiplierAddress The multiplier oracle address\n    /// @param expectedDecimals The expected decimals of the derived price\n    /// @dev always returns positive, otherwise reverts as comptroller only accepts positive oracle values\n    function getDerivedPrice(\n        address baseAddress,\n        address multiplierAddress,\n        uint8 expectedDecimals\n    ) public view returns (uint256) {\n        require(\n            expectedDecimals > uint8(0) && expectedDecimals <= uint8(18),\n            \"CLCOracle: Invalid expected decimals\"\n        );\n\n        int256 scalingFactor = int256(10 ** uint256(expectedDecimals)); /// calculate expected decimals for end quote\n\n        int256 basePrice = getPriceAndScale(baseAddress, expectedDecimals);\n        int256 quotePrice = getPriceAndScale(\n            multiplierAddress,\n            expectedDecimals\n        );\n\n        /// both quote and base price should be scaled up to 18 decimals by now if expectedDecimals is 18\n        return calculatePrice(basePrice, quotePrice, scalingFactor);\n    }\n\n    //// fetch ETH price, multiply by stETH-ETH exchange rate,\n    /// then multiply by wstETH-stETH exchange rate\n    /// @param usdBaseAddress The base oracle address that gets the base asset price\n    /// @param multiplierAddress The multiplier oracle address that gets the multiplier asset price\n    /// @param secondMultiplierAddress The second oracle address that gets the second asset price\n    /// @param expectedDecimals The amount of decimals the price should have\n    /// @return the derived price from all three oracles. Multiply the base price by the multiplier\n    /// price, then multiply by the second multiplier price\n    function getDerivedPriceThreeOracles(\n        address usdBaseAddress,\n        address multiplierAddress,\n        address secondMultiplierAddress,\n        uint8 expectedDecimals\n    ) public view returns (uint256) {\n        require(\n            expectedDecimals > uint8(0) && expectedDecimals <= uint8(18),\n            \"CLCOracle: Invalid expected decimals\"\n        );\n\n        /// should never overflow as should return 1e36\n        int256 scalingFactor = int256(10 ** uint256(expectedDecimals * 2)); /// calculate expected decimals for end quote\n\n        int256 firstPrice = getPriceAndScale(usdBaseAddress, expectedDecimals);\n        int256 secondPrice = getPriceAndScale(\n            multiplierAddress,\n            expectedDecimals\n        );\n        int256 thirdPrice = getPriceAndScale(\n            secondMultiplierAddress,\n            expectedDecimals\n        );\n\n        return\n            ((firstPrice * secondPrice * thirdPrice) / scalingFactor)\n                .toUint256();\n    }\n\n    /// @notice Get the price of a base/quote pair\n    /// and then scale up to the expected decimals amount\n    /// @param oracleAddress The oracle address\n    /// @param expectedDecimals The amount of decimals the price should have\n    function getPriceAndScale(\n        address oracleAddress,\n        uint8 expectedDecimals\n    ) public view returns (int256) {\n        (int256 price, uint8 actualDecimals) = getPriceAndDecimals(\n            oracleAddress\n        );\n        return scalePrice(price, actualDecimals, expectedDecimals);\n    }\n\n    /// @notice helper function to retrieve price from chainlink\n    /// @param oracleAddress The address of the chainlink oracle\n    /// returns the price and then the decimals of the given asset\n    /// reverts if price is 0 or if the oracle data is invalid\n    function getPriceAndDecimals(\n        address oracleAddress\n    ) public view returns (int256, uint8) {\n        (\n            uint80 roundId,\n            int256 price,\n            ,\n            ,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(oracleAddress).latestRoundData();\n        bool valid = price > 0 && answeredInRound == roundId;\n        require(valid, \"CLCOracle: Oracle data is invalid\");\n        uint8 oracleDecimals = AggregatorV3Interface(oracleAddress).decimals();\n\n        return (price, oracleDecimals); /// price always gt 0 at this point\n    }\n\n    /// @notice scale price up or down to the desired amount of decimals\n    /// @param price The price to scale\n    /// @param priceDecimals The amount of decimals the price has\n    /// @param expectedDecimals The amount of decimals the price should have\n    /// @return the scaled price\n    function scalePrice(\n        int256 price,\n        uint8 priceDecimals,\n        uint8 expectedDecimals\n    ) public pure returns (int256) {\n        if (priceDecimals < expectedDecimals) {\n            return\n                price * (10 ** uint256(expectedDecimals - priceDecimals)).toInt256();\n        } else if (priceDecimals > expectedDecimals) {\n            return\n                price / (10 ** uint256(priceDecimals - expectedDecimals)).toInt256();\n        }\n\n        /// if priceDecimals == expectedDecimals, return price without any changes\n\n        return price;\n    }\n}"
    }
  ]
}