{
  "Title": "[M-04] FurnaceP1.setRatio will work incorrectly after call when frozen",
  "Content": "\n`FurnaceP1.setRatio` will not update `lastPayout` when called in frozen state, which means that after component will be unfrozen, melting will be incorrect.\n\n### Proof of Concept\n\n`melt` function should burn some amount of tokens from `lastPayoutBal`. It depends of `lastPayout` and `ratio` variables. The more time has passed, the more tokens will be burnt.\n\nWhen `setRatio` function is called, then `melt` function [is tried to be executed](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Furnace.sol#L86), because new ratio is provided and it should not be used for previous time ranges.\nIn case if everything is ok, then `lastPayout` and `lastPayoutBal` will be updated, so it's safe to update `ratio` now.\nBut it's possible that `melt` function will revert in case if `notFrozen` modifier is not passed. As result `lastPayout` and `lastPayoutBal` will not be updated, but ratio will be. Because of that, when `Furnace` will be unfrozen, then melting rate can be much more, then it should be, because `lastPayout` wasn't updated.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nIn case of `catch` case, you can update `lastPayout` and `lastPayoutBal`.\n\n**[tbrent (Reserve) confirmed](https://github.com/code-423n4/2023-06-reserve-findings/issues/29#issuecomment-1620802303)**\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Update payout variables if melt fails during `setRatio`.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/885\n\n**Status:** Mitigation error. Full details in report from [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/37) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-reserve",
  "Code": [
    {
      "filename": "contracts/p1/Furnace.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"../libraries/Fixed.sol\";\nimport \"../interfaces/IFurnace.sol\";\nimport \"./mixins/Component.sol\";\n\n/**\n * @title FurnaceP1\n * @notice A helper to melt RTokens continuously and permisionlessly.\n */\ncontract FurnaceP1 is ComponentP1, IFurnace {\n    using FixLib for uint192;\n\n    uint192 public constant MAX_RATIO = FIX_ONE; // {1} 100%\n    uint48 public constant PERIOD = ONE_BLOCK; // {s} 12 seconds; 1 block on PoS Ethereum\n\n    IRToken private rToken;\n\n    // === Governance params ===\n    uint192 public ratio; // {1} What fraction of balance to melt each period\n\n    // === Cached ===\n    uint48 public lastPayout; // {seconds} The last time we did a payout\n    uint256 public lastPayoutBal; // {qRTok} The balance of RToken at the last payout\n\n    // ==== Invariants ====\n    // ratio <= MAX_RATIO = 1e18\n    // lastPayout was the timestamp of the end of the last period we paid out\n    //   (or, if no periods have been paid out, the timestamp init() was called)\n    // lastPayoutBal was rtoken.balanceOf(this) after the last period we paid out\n    //   (or, if no periods have been paid out, that balance when init() was called)\n\n    function init(IMain main_, uint192 ratio_) external initializer {\n        __Component_init(main_);\n        rToken = main_.rToken();\n        setRatio(ratio_);\n        lastPayout = uint48(block.timestamp);\n        lastPayoutBal = rToken.balanceOf(address(this));\n    }\n\n    // [furnace-payout-formula]:\n    //   The process we're modelling is:\n    //     N = number of whole periods since lastPayout\n    //     bal_0 = rToken.balanceOf(this)\n    //     payout_{i+1} = bal_i * ratio\n    //     bal_{i+1} = bal_i - payout_{i+1}\n    //     payoutAmount = sum{payout_i for i in [1...N]}\n    //   thus:\n    //     bal_N = bal_0 - payout\n    //     bal_{i+1} = bal_i - bal_i * ratio = bal_i * (1-ratio)\n    //     bal_N = bal_0 * (1-ratio)**N\n    //   and so:\n    //     payoutAmount = bal_N - bal_0 = bal_0 * (1 - (1-ratio)**N)\n\n    /// Performs any melting that has vested since last call.\n    /// @custom:refresher\n    // let numPeriods = number of whole periods that have passed since `lastPayout`\n    //     payoutAmount = RToken.balanceOf(this) * (1 - (1-ratio)**N) from [furnace-payout-formula]\n    // effects:\n    //   lastPayout' = lastPayout + numPeriods * PERIOD (end of last pay period)\n    //   lastPayoutBal' = rToken.balanceOf'(this) (balance now == at end of pay leriod)\n    // actions:\n    //   rToken.melt(payoutAmount), paying payoutAmount to RToken holders\n\n    function melt() external notFrozen {\n        if (uint48(block.timestamp) < uint64(lastPayout) + PERIOD) return;\n\n        // # of whole periods that have passed since lastPayout\n        uint48 numPeriods = uint48((block.timestamp) - lastPayout) / PERIOD;\n\n        // Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.\n        uint192 payoutRatio = FIX_ONE.minus(FIX_ONE.minus(ratio).powu(numPeriods));\n\n        uint256 amount = payoutRatio.mulu_toUint(lastPayoutBal);\n\n        lastPayout += numPeriods * PERIOD;\n        lastPayoutBal = rToken.balanceOf(address(this)) - amount;\n        if (amount > 0) rToken.melt(amount);\n    }\n\n    /// Ratio setting\n    /// @custom:governance\n    function setRatio(uint192 ratio_) public governance {\n        // solhint-disable-next-line no-empty-blocks\n        if (lastPayout > 0) try this.melt() {} catch {}\n        require(ratio_ <= MAX_RATIO, \"invalid ratio\");\n        // The ratio can safely be set to 0 to turn off payouts, though it is not recommended\n        emit RatioSet(ratio, ratio_);\n        ratio = ratio_;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}"
    }
  ]
}