{
  "Title": "[L01] Frozen function can be bypassed",
  "Content": "The [`Election` contract](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/governance/Election.sol) inherits from the [`Freezable` contract](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/common/Freezable.sol) the functionality to freeze certain parts of the code.\n\n\nWhen the `Election` contract is frozen through the [`Freezer` contract](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/common/Freezer.sol), the [`electValidatorSigners` function](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/governance/Election.sol#L929) cannot be called.\n\n\nNevertheless, as the `electValidatorSigners` function is only a wrapper for the [`electNValidatorSigners` function](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/governance/Election.sol#L939) and, because `electNValidatorSigners` is also a externally accessed function without any kind of restrictions whatsoever, a caller could just bypass the `frozen` state by calling the `electNValidatorSigners` without any restriction.\n\n\nAlthough these two functions do not change storage variables, consider either freezing both functions at the same time or documenting the decision of only freezing the wrapper function.\n\n\n***Update**: Fixed on [pull request 4910](https://github.com/celo-org/celo-monorepo/pull/4910/files). The `Election` contract no longer inherits the freezable functionalities from the `Freezable` contract, and the `onlyWhenNotFrozen` modifier was removed from the `electValidatorSigners` function.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/governance/Election.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IElection.sol\";\nimport \"./interfaces/IValidators.sol\";\nimport \"../common/CalledByVm.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Freezable.sol\";\nimport \"../common/linkedlists/AddressSortedLinkedList.sol\";\nimport \"../common/UsingPrecompiles.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/Heap.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Election is\n  IElection,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry,\n  UsingPrecompiles,\n  Freezable,\n  CalledByVm\n{\n  using AddressSortedLinkedList for SortedLinkedList.List;\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  // 1e20 ensures that units can be represented as precisely as possible to avoid rounding errors\n  // when translating to votes, without risking integer overflow.\n  // A maximum of 1,000,000,000 cGLD (1e27) yields a maximum of 1e47 units, whose product is at\n  // most 1e74, which is less than 2^256.\n  uint256 private constant UNIT_PRECISION_FACTOR = 100000000000000000000;\n\n  struct PendingVote {\n    // The value of the vote, in gold.\n    uint256 value;\n    // The epoch at which the vote was cast.\n    uint256 epoch;\n  }\n\n  struct GroupPendingVotes {\n    // The total number of pending votes that have been cast for this group.\n    uint256 total;\n    // Pending votes cast per voter.\n    mapping(address => PendingVote) byAccount;\n  }\n\n  // Pending votes are those for which no following elections have been held.\n  // These votes have yet to contribute to the election of validators and thus do not accrue\n  // rewards.\n  struct PendingVotes {\n    // The total number of pending votes cast across all groups.\n    uint256 total;\n    mapping(address => GroupPendingVotes) forGroup;\n  }\n\n  struct GroupActiveVotes {\n    // The total number of active votes that have been cast for this group.\n    uint256 total;\n    // The total number of active votes by a voter is equal to the number of active vote units for\n    // that voter times the total number of active votes divided by the total number of active\n    // vote units.\n    uint256 totalUnits;\n    mapping(address => uint256) unitsByAccount;\n  }\n\n  // Active votes are those for which at least one following election has been held.\n  // These votes have contributed to the election of validators and thus accrue rewards.\n  struct ActiveVotes {\n    // The total number of active votes cast across all groups.\n    uint256 total;\n    mapping(address => GroupActiveVotes) forGroup;\n  }\n\n  struct TotalVotes {\n    // A list of eligible ValidatorGroups sorted by total (pending+active) votes.\n    // Note that this list will omit ineligible ValidatorGroups, including those that may have > 0\n    // total votes.\n    SortedLinkedList.List eligible;\n  }\n\n  struct Votes {\n    PendingVotes pending;\n    ActiveVotes active;\n    TotalVotes total;\n    // Maps an account to the list of groups it's voting for.\n    mapping(address => address[]) groupsVotedFor;\n  }\n\n  struct ElectableValidators {\n    uint256 min;\n    uint256 max;\n  }\n\n  Votes private votes;\n  // Governs the minimum and maximum number of validators that can be elected.\n  ElectableValidators public electableValidators;\n  // Governs how many validator groups a single account can vote for.\n  uint256 public maxNumGroupsVotedFor;\n  // Groups must receive at least this fraction of the total votes in order to be considered in\n  // elections.\n  FixidityLib.Fraction public electabilityThreshold;\n\n  event ElectableValidatorsSet(uint256 min, uint256 max);\n  event MaxNumGroupsVotedForSet(uint256 maxNumGroupsVotedFor);\n  event ElectabilityThresholdSet(uint256 electabilityThreshold);\n  event ValidatorGroupMarkedEligible(address indexed group);\n  event ValidatorGroupMarkedIneligible(address indexed group);\n  event ValidatorGroupVoteCast(address indexed account, address indexed group, uint256 value);\n  event ValidatorGroupVoteActivated(\n    address indexed account,\n    address indexed group,\n    uint256 value,\n    uint256 units\n  );\n  event ValidatorGroupPendingVoteRevoked(\n    address indexed account,\n    address indexed group,\n    uint256 value\n  );\n  event ValidatorGroupActiveVoteRevoked(\n    address indexed account,\n    address indexed group,\n    uint256 value,\n    uint256 units\n  );\n  event EpochRewardsDistributedToVoters(address indexed group, uint256 value);\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 1, 0);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param minElectableValidators The minimum number of validators that can be elected.\n   * @param _maxNumGroupsVotedFor The maximum number of groups that an account can vote for at once.\n   * @param _electabilityThreshold The minimum ratio of votes a group needs before its members can\n   *   be elected.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 minElectableValidators,\n    uint256 maxElectableValidators,\n    uint256 _maxNumGroupsVotedFor,\n    uint256 _electabilityThreshold\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setElectableValidators(minElectableValidators, maxElectableValidators);\n    setMaxNumGroupsVotedFor(_maxNumGroupsVotedFor);\n    setElectabilityThreshold(_electabilityThreshold);\n  }\n\n  /**\n   * @notice Updates the minimum and maximum number of validators that can be elected.\n   * @param min The minimum number of validators that can be elected.\n   * @param max The maximum number of validators that can be elected.\n   * @return True upon success.\n   */\n  function setElectableValidators(uint256 min, uint256 max) public onlyOwner returns (bool) {\n    require(0 < min, \"Minimum electable validators cannot be zero\");\n    require(min <= max, \"Maximum electable validators cannot be smaller than minimum\");\n    require(\n      min != electableValidators.min || max != electableValidators.max,\n      \"Electable validators not changed\"\n    );\n    electableValidators = ElectableValidators(min, max);\n    emit ElectableValidatorsSet(min, max);\n    return true;\n  }\n\n  /**\n   * @notice Returns the minimum and maximum number of validators that can be elected.\n   * @return The minimum and maximum number of validators that can be elected.\n   */\n  function getElectableValidators() external view returns (uint256, uint256) {\n    return (electableValidators.min, electableValidators.max);\n  }\n\n  /**\n   * @notice Updates the maximum number of groups an account can be voting for at once.\n   * @param _maxNumGroupsVotedFor The maximum number of groups an account can vote for.\n   * @return True upon success.\n   */\n  function setMaxNumGroupsVotedFor(uint256 _maxNumGroupsVotedFor) public onlyOwner returns (bool) {\n    require(_maxNumGroupsVotedFor != maxNumGroupsVotedFor, \"Max groups voted for not changed\");\n    maxNumGroupsVotedFor = _maxNumGroupsVotedFor;\n    emit MaxNumGroupsVotedForSet(_maxNumGroupsVotedFor);\n    return true;\n  }\n\n  /**\n   * @notice Sets the electability threshold.\n   * @param threshold Electability threshold as unwrapped Fraction.\n   * @return True upon success.\n   */\n  function setElectabilityThreshold(uint256 threshold) public onlyOwner returns (bool) {\n    electabilityThreshold = FixidityLib.wrap(threshold);\n    require(\n      electabilityThreshold.lt(FixidityLib.fixed1()),\n      \"Electability threshold must be lower than 100%\"\n    );\n    emit ElectabilityThresholdSet(threshold);\n    return true;\n  }\n\n  /**\n   * @notice Gets the election threshold.\n   * @return Threshold value as unwrapped fraction.\n   */\n  function getElectabilityThreshold() external view returns (uint256) {\n    return electabilityThreshold.unwrap();\n  }\n\n  /**\n   * @notice Increments the number of total and pending votes for `group`.\n   * @param group The validator group to vote for.\n   * @param value The amount of gold to use to vote.\n   * @param lesser The group receiving fewer votes than `group`, or 0 if `group` has the\n   *   fewest votes of any validator group.\n   * @param greater The group receiving more votes than `group`, or 0 if `group` has the\n   *   most votes of any validator group.\n   * @return True upon success.\n   * @dev Fails if `group` is empty or not a validator group.\n   */\n  function vote(address group, uint256 value, address lesser, address greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    require(votes.total.eligible.contains(group), \"Group not eligible\");\n    require(0 < value, \"Vote value cannot be zero\");\n    require(canReceiveVotes(group, value), \"Group cannot receive votes\");\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n\n    // Add group to the groups voted for by the account.\n    bool alreadyVotedForGroup = false;\n    address[] storage groups = votes.groupsVotedFor[account];\n    for (uint256 i = 0; i < groups.length; i = i.add(1)) {\n      alreadyVotedForGroup = alreadyVotedForGroup || groups[i] == group;\n    }\n    if (!alreadyVotedForGroup) {\n      require(groups.length < maxNumGroupsVotedFor, \"Voted for too many groups\");\n      groups.push(group);\n    }\n\n    incrementPendingVotes(group, account, value);\n    incrementTotalVotes(group, value, lesser, greater);\n    getLockedGold().decrementNonvotingAccountBalance(account, value);\n    emit ValidatorGroupVoteCast(account, group, value);\n    return true;\n  }\n\n  /**\n   * @notice Converts `account`'s pending votes for `group` to active votes.\n   * @param group The validator group to vote for.\n   * @return True upon success.\n   * @dev Pending votes cannot be activated until an election has been held.\n   */\n  function activate(address group) external nonReentrant returns (bool) {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    PendingVote storage pendingVote = votes.pending.forGroup[group].byAccount[account];\n    require(pendingVote.epoch < getEpochNumber(), \"Pending vote epoch not passed\");\n    uint256 value = pendingVote.value;\n    require(value > 0, \"Vote value cannot be zero\");\n    decrementPendingVotes(group, account, value);\n    uint256 units = incrementActiveVotes(group, account, value);\n    emit ValidatorGroupVoteActivated(account, group, value, units);\n    return true;\n  }\n\n  /**\n   * @notice Returns whether or not an account's votes for the specified group can be activated.\n   * @param account The account with pending votes.\n   * @param group The validator group that `account` has pending votes for.\n   * @return Whether or not `account` has activatable votes for `group`.\n   * @dev Pending votes cannot be activated until an election has been held.\n   */\n  function hasActivatablePendingVotes(address account, address group) external view returns (bool) {\n    PendingVote storage pendingVote = votes.pending.forGroup[group].byAccount[account];\n    return pendingVote.epoch < getEpochNumber() && pendingVote.value > 0;\n  }\n\n  /**\n   * @notice Revokes `value` pending votes for `group`\n   * @param group The validator group to revoke votes from.\n   * @param value The number of votes to revoke.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *   or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *   or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @return True upon success.\n   * @dev Fails if the account has not voted on a validator group.\n   */\n  function revokePending(\n    address group,\n    uint256 value,\n    address lesser,\n    address greater,\n    uint256 index\n  ) external nonReentrant returns (bool) {\n    require(group != address(0), \"Group address zero\");\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    require(0 < value, \"Vote value cannot be zero\");\n    require(\n      value <= getPendingVotesForGroupByAccount(group, account),\n      \"Vote value larger than pending votes\"\n    );\n    decrementPendingVotes(group, account, value);\n    decrementTotalVotes(group, value, lesser, greater);\n    getLockedGold().incrementNonvotingAccountBalance(account, value);\n    if (getTotalVotesForGroupByAccount(group, account) == 0) {\n      deleteElement(votes.groupsVotedFor[account], group, index);\n    }\n    emit ValidatorGroupPendingVoteRevoked(account, group, value);\n    return true;\n  }\n\n  /**\n   * @notice Revokes all active votes for `group`\n   * @param group The validator group to revoke votes from.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *   or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *   or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @return True upon success.\n   * @dev Fails if the account has not voted on a validator group.\n   */\n  function revokeAllActive(address group, address lesser, address greater, uint256 index)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 value = getActiveVotesForGroupByAccount(group, account);\n    return _revokeActive(group, value, lesser, greater, index);\n  }\n\n  /**\n   * @notice Revokes `value` active votes for `group`\n   * @param group The validator group to revoke votes from.\n   * @param value The number of votes to revoke.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *   or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *   or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @return True upon success.\n   * @dev Fails if the account has not voted on a validator group.\n   */\n  function revokeActive(\n    address group,\n    uint256 value,\n    address lesser,\n    address greater,\n    uint256 index\n  ) external nonReentrant returns (bool) {\n    return _revokeActive(group, value, lesser, greater, index);\n  }\n\n  function _revokeActive(\n    address group,\n    uint256 value,\n    address lesser,\n    address greater,\n    uint256 index\n  ) internal returns (bool) {\n    // TODO(asa): Dedup with revokePending.\n    require(group != address(0), \"Group address zero\");\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    require(0 < value, \"Vote value cannot be zero\");\n    require(\n      value <= getActiveVotesForGroupByAccount(group, account),\n      \"Vote value larger than active votes\"\n    );\n    uint256 units = decrementActiveVotes(group, account, value);\n    decrementTotalVotes(group, value, lesser, greater);\n    getLockedGold().incrementNonvotingAccountBalance(account, value);\n    if (getTotalVotesForGroupByAccount(group, account) == 0) {\n      deleteElement(votes.groupsVotedFor[account], group, index);\n    }\n    emit ValidatorGroupActiveVoteRevoked(account, group, value, units);\n    return true;\n  }\n\n  /**\n   * @notice Decrements `value` pending or active votes for `group` from `account`.\n   *         First revokes all pending votes and then, if `value` votes haven't\n   *         been revoked yet, revokes additional active votes.\n   *         Fundamentally calls `revokePending` and `revokeActive` but only resorts groups once.\n   * @param account The account whose votes to `group` should be decremented.\n   * @param group The validator group to decrement votes from.\n   * @param maxValue The maxinum number of votes to decrement and revoke.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *               or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *                or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @return uint256 Number of votes successfully decremented and revoked, with a max of `value`.\n   */\n  function _decrementVotes(\n    address account,\n    address group,\n    uint256 maxValue,\n    address lesser,\n    address greater,\n    uint256 index\n  ) internal returns (uint256) {\n    uint256 remainingValue = maxValue;\n    uint256 pendingVotes = getPendingVotesForGroupByAccount(group, account);\n    if (pendingVotes > 0) {\n      uint256 decrementValue = Math.min(remainingValue, pendingVotes);\n      decrementPendingVotes(group, account, decrementValue);\n      emit ValidatorGroupPendingVoteRevoked(account, group, decrementValue);\n      remainingValue = remainingValue.sub(decrementValue);\n    }\n    uint256 activeVotes = getActiveVotesForGroupByAccount(group, account);\n    if (activeVotes > 0 && remainingValue > 0) {\n      uint256 decrementValue = Math.min(remainingValue, activeVotes);\n      uint256 units = decrementActiveVotes(group, account, decrementValue);\n      emit ValidatorGroupActiveVoteRevoked(account, group, decrementValue, units);\n      remainingValue = remainingValue.sub(decrementValue);\n    }\n    uint256 decrementedValue = maxValue.sub(remainingValue);\n    if (decrementedValue > 0) {\n      decrementTotalVotes(group, decrementedValue, lesser, greater);\n      if (getTotalVotesForGroupByAccount(group, account) == 0) {\n        deleteElement(votes.groupsVotedFor[account], group, index);\n      }\n    }\n    return decrementedValue;\n  }\n\n  /**\n   * @notice Returns the total number of votes cast by an account.\n   * @param account The address of the account.\n   * @return The total number of votes cast by an account.\n   */\n  function getTotalVotesByAccount(address account) external view returns (uint256) {\n    uint256 total = 0;\n    address[] memory groups = votes.groupsVotedFor[account];\n    for (uint256 i = 0; i < groups.length; i = i.add(1)) {\n      total = total.add(getTotalVotesForGroupByAccount(groups[i], account));\n    }\n    return total;\n  }\n\n  /**\n   * @notice Returns the pending votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @return The pending votes for `group` made by `account`.\n   */\n  function getPendingVotesForGroupByAccount(address group, address account)\n    public\n    view\n    returns (uint256)\n  {\n    return votes.pending.forGroup[group].byAccount[account].value;\n  }\n\n  /**\n   * @notice Returns the active votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @return The active votes for `group` made by `account`.\n   */\n  function getActiveVotesForGroupByAccount(address group, address account)\n    public\n    view\n    returns (uint256)\n  {\n    return unitsToVotes(group, votes.active.forGroup[group].unitsByAccount[account]);\n  }\n\n  /**\n   * @notice Returns the total votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @return The total votes for `group` made by `account`.\n   */\n  function getTotalVotesForGroupByAccount(address group, address account)\n    public\n    view\n    returns (uint256)\n  {\n    uint256 pending = getPendingVotesForGroupByAccount(group, account);\n    uint256 active = getActiveVotesForGroupByAccount(group, account);\n    return pending.add(active);\n  }\n\n  /**\n   * @notice Returns the active vote units for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @return The active vote units for `group` made by `account`.\n   */\n  function getActiveVoteUnitsForGroupByAccount(address group, address account)\n    external\n    view\n    returns (uint256)\n  {\n    return votes.active.forGroup[group].unitsByAccount[account];\n  }\n\n  /**\n   * @notice Returns the total active vote units made for `group`.\n   * @param group The address of the validator group.\n   * @return The total active vote units made for `group`.\n   */\n  function getActiveVoteUnitsForGroup(address group) external view returns (uint256) {\n    return votes.active.forGroup[group].totalUnits;\n  }\n\n  /**\n   * @notice Returns the total votes made for `group`.\n   * @param group The address of the validator group.\n   * @return The total votes made for `group`.\n   */\n  function getTotalVotesForGroup(address group) public view returns (uint256) {\n    return votes.pending.forGroup[group].total.add(votes.active.forGroup[group].total);\n  }\n\n  /**\n   * @notice Returns the active votes made for `group`.\n   * @param group The address of the validator group.\n   * @return The active votes made for `group`.\n   */\n  function getActiveVotesForGroup(address group) public view returns (uint256) {\n    return votes.active.forGroup[group].total;\n  }\n\n  /**\n   * @notice Returns the pending votes made for `group`.\n   * @param group The address of the validator group.\n   * @return The pending votes made for `group`.\n   */\n  function getPendingVotesForGroup(address group) public view returns (uint256) {\n    return votes.pending.forGroup[group].total;\n  }\n\n  /**\n   * @notice Returns whether or not a group is eligible to receive votes.\n   * @return Whether or not a group is eligible to receive votes.\n   * @dev Eligible groups that have received their maximum number of votes cannot receive more.\n   */\n  function getGroupEligibility(address group) external view returns (bool) {\n    return votes.total.eligible.contains(group);\n  }\n\n  /**\n   * @notice Returns the amount of rewards that voters for `group` are due at the end of an epoch.\n   * @param group The group to calculate epoch rewards for.\n   * @param totalEpochRewards The total amount of rewards going to all voters.\n   * @param uptimes Array of Fixidity representations of the validators' uptimes, between 0 and 1.\n   * @return The amount of rewards that voters for `group` are due at the end of an epoch.\n   * @dev Eligible groups that have received their maximum number of votes cannot receive more.\n   */\n  function getGroupEpochRewards(\n    address group,\n    uint256 totalEpochRewards,\n    uint256[] calldata uptimes\n  ) external view returns (uint256) {\n    IValidators validators = getValidators();\n    // The group must meet the balance requirements for their voters to receive epoch rewards.\n    if (!validators.meetsAccountLockedGoldRequirements(group) || votes.active.total <= 0) {\n      return 0;\n    }\n\n    FixidityLib.Fraction memory votePortion = FixidityLib.newFixedFraction(\n      votes.active.forGroup[group].total,\n      votes.active.total\n    );\n    FixidityLib.Fraction memory score = FixidityLib.wrap(\n      validators.calculateGroupEpochScore(uptimes)\n    );\n    FixidityLib.Fraction memory slashingMultiplier = FixidityLib.wrap(\n      validators.getValidatorGroupSlashingMultiplier(group)\n    );\n    return\n      FixidityLib\n        .newFixed(totalEpochRewards)\n        .multiply(votePortion)\n        .multiply(score)\n        .multiply(slashingMultiplier)\n        .fromFixed();\n  }\n\n  /**\n   * @notice Distributes epoch rewards to voters for `group` in the form of active votes.\n   * @param group The group whose voters will receive rewards.\n   * @param value The amount of rewards to distribute to voters for the group.\n   * @param lesser The group receiving fewer votes than `group` after the rewards are added.\n   * @param greater The group receiving more votes than `group` after the rewards are added.\n   * @dev Can only be called directly by the protocol.\n   */\n  function distributeEpochRewards(address group, uint256 value, address lesser, address greater)\n    external\n    onlyVm\n  {\n    _distributeEpochRewards(group, value, lesser, greater);\n  }\n\n  /**\n   * @notice Distributes epoch rewards to voters for `group` in the form of active votes.\n   * @param group The group whose voters will receive rewards.\n   * @param value The amount of rewards to distribute to voters for the group.\n   * @param lesser The group receiving fewer votes than `group` after the rewards are added.\n   * @param greater The group receiving more votes than `group` after the rewards are added.\n   */\n  function _distributeEpochRewards(address group, uint256 value, address lesser, address greater)\n    internal\n  {\n    if (votes.total.eligible.contains(group)) {\n      uint256 newVoteTotal = votes.total.eligible.getValue(group).add(value);\n      votes.total.eligible.update(group, newVoteTotal, lesser, greater);\n    }\n\n    votes.active.forGroup[group].total = votes.active.forGroup[group].total.add(value);\n    votes.active.total = votes.active.total.add(value);\n    emit EpochRewardsDistributedToVoters(group, value);\n  }\n\n  /**\n   * @notice Increments the number of total votes for `group` by `value`.\n   * @param group The validator group whose vote total should be incremented.\n   * @param value The number of votes to increment.\n   * @param lesser The group receiving fewer votes than the group for which the vote was cast,\n   *   or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was cast,\n   *   or 0 if that group has the most votes of any validator group.\n   */\n  function incrementTotalVotes(address group, uint256 value, address lesser, address greater)\n    private\n  {\n    uint256 newVoteTotal = votes.total.eligible.getValue(group).add(value);\n    votes.total.eligible.update(group, newVoteTotal, lesser, greater);\n  }\n\n  /**\n   * @notice Decrements the number of total votes for `group` by `value`.\n   * @param group The validator group whose vote total should be decremented.\n   * @param value The number of votes to decrement.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *   or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *   or 0 if that group has the most votes of any validator group.\n   */\n  function decrementTotalVotes(address group, uint256 value, address lesser, address greater)\n    private\n  {\n    if (votes.total.eligible.contains(group)) {\n      uint256 newVoteTotal = votes.total.eligible.getValue(group).sub(value);\n      votes.total.eligible.update(group, newVoteTotal, lesser, greater);\n    }\n  }\n\n  /**\n   * @notice Marks a group ineligible for electing validators.\n   * @param group The address of the validator group.\n   * @dev Can only be called by the registered \"Validators\" contract.\n   */\n  function markGroupIneligible(address group)\n    external\n    onlyRegisteredContract(VALIDATORS_REGISTRY_ID)\n  {\n    votes.total.eligible.remove(group);\n    emit ValidatorGroupMarkedIneligible(group);\n  }\n\n  /**\n   * @notice Marks a group eligible for electing validators.\n   * @param group The address of the validator group.\n   * @param lesser The address of the group that has received fewer votes than this group.\n   * @param greater The address of the group that has received more votes than this group.\n   */\n  function markGroupEligible(address group, address lesser, address greater)\n    external\n    onlyRegisteredContract(VALIDATORS_REGISTRY_ID)\n  {\n    uint256 value = getTotalVotesForGroup(group);\n    votes.total.eligible.insert(group, value, lesser, greater);\n    emit ValidatorGroupMarkedEligible(group);\n  }\n\n  /**\n   * @notice Increments the number of pending votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @param value The number of votes.\n   */\n  function incrementPendingVotes(address group, address account, uint256 value) private {\n    PendingVotes storage pending = votes.pending;\n    pending.total = pending.total.add(value);\n\n    GroupPendingVotes storage groupPending = pending.forGroup[group];\n    groupPending.total = groupPending.total.add(value);\n\n    PendingVote storage pendingVote = groupPending.byAccount[account];\n    pendingVote.value = pendingVote.value.add(value);\n    pendingVote.epoch = getEpochNumber();\n  }\n\n  /**\n   * @notice Decrements the number of pending votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @param value The number of votes.\n   */\n  function decrementPendingVotes(address group, address account, uint256 value) private {\n    PendingVotes storage pending = votes.pending;\n    pending.total = pending.total.sub(value);\n\n    GroupPendingVotes storage groupPending = pending.forGroup[group];\n    groupPending.total = groupPending.total.sub(value);\n\n    PendingVote storage pendingVote = groupPending.byAccount[account];\n    pendingVote.value = pendingVote.value.sub(value);\n    if (pendingVote.value == 0) {\n      pendingVote.epoch = 0;\n    }\n  }\n\n  /**\n   * @notice Increments the number of active votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @param value The number of votes.\n   */\n  function incrementActiveVotes(address group, address account, uint256 value)\n    private\n    returns (uint256)\n  {\n    ActiveVotes storage active = votes.active;\n    active.total = active.total.add(value);\n\n    uint256 units = votesToUnits(group, value);\n\n    GroupActiveVotes storage groupActive = active.forGroup[group];\n    groupActive.total = groupActive.total.add(value);\n\n    groupActive.totalUnits = groupActive.totalUnits.add(units);\n    groupActive.unitsByAccount[account] = groupActive.unitsByAccount[account].add(units);\n    return units;\n  }\n\n  /**\n   * @notice Decrements the number of active votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @param value The number of votes.\n   */\n  function decrementActiveVotes(address group, address account, uint256 value)\n    private\n    returns (uint256)\n  {\n    ActiveVotes storage active = votes.active;\n    active.total = active.total.sub(value);\n\n    // Rounding may cause votesToUnits to return 0 for value != 0, preventing users\n    // from revoking the last of their votes. The case where value == votes is special cased\n    // to prevent this.\n    uint256 units = 0;\n    uint256 activeVotes = getActiveVotesForGroupByAccount(group, account);\n    GroupActiveVotes storage groupActive = active.forGroup[group];\n    if (activeVotes == value) {\n      units = groupActive.unitsByAccount[account];\n    } else {\n      units = votesToUnits(group, value);\n    }\n\n    groupActive.total = groupActive.total.sub(value);\n    groupActive.totalUnits = groupActive.totalUnits.sub(units);\n    groupActive.unitsByAccount[account] = groupActive.unitsByAccount[account].sub(units);\n    return units;\n  }\n\n  /**\n   * @notice Returns the number of units corresponding to `value` active votes.\n   * @param group The address of the validator group.\n   * @param value The number of active votes.\n   * @return The corresponding number of units.\n   */\n  function votesToUnits(address group, uint256 value) private view returns (uint256) {\n    if (votes.active.forGroup[group].totalUnits == 0) {\n      return value.mul(UNIT_PRECISION_FACTOR);\n    } else {\n      return\n        value.mul(votes.active.forGroup[group].totalUnits).div(votes.active.forGroup[group].total);\n    }\n  }\n\n  /**\n   * @notice Returns the number of active votes corresponding to `value` units.\n   * @param group The address of the validator group.\n   * @param value The number of units.\n   * @return The corresponding number of active votes.\n   */\n  function unitsToVotes(address group, uint256 value) private view returns (uint256) {"
    }
  ]
}