{
  "Title": "Parallel access control",
  "Content": "The `Protocol` contract inherits the OpenZeppelin `AccessControl` contract, and uses it to define [the role hierarchy](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/ProtoBase.sol#L18). It also provides a mechanism for the administrator to [grant an existing role](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Protocol.sol#L283) to a new address. However, this mechanism functions in parallel to the [inherited mechanism](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/access/AccessControl.sol#L130) for granting roles. This leads to two inconsistencies:\n\n\n* A role administrator can bypass the `whenNotPaused` restriction by using the inherited mechanism.\n* The `NS_ROLES_ADMIN` can use the new mechanism to grant the `NS_ROLES_GOVERNANCE_AGENT`, even though they [do not directly administer](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/ProtoBase.sol#L23) that role.\n\n\nConsider ensuring consistency between the two mechanisms. Depending on the desired outcome, this could involve relying on the original mechanism, changing the role relationships, or overriding the inherited `grantRole` function.\n\n\n**Update:** *Fixed as of commit `1d54d66493e3109c12d610f0231529cbd65b5ba9` in [pull request #157](https://github.com/neptune-mutual-blue/protocol/pull/157) and commit `4b929c274100a981107e35d40fbf5b57fabc9be4` in [pull request #196](https://github.com/neptune-mutual-blue/protocol/pull/196).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/ProtoBase.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/access/AccessControl.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/security/Pausable.sol\";\nimport \"../libraries/ProtoUtilV1.sol\";\nimport \"./Recoverable.sol\";\n\nabstract contract ProtoBase is AccessControl, Pausable, Recoverable {\n  using ProtoUtilV1 for IStore;\n  using ValidationLibV1 for IStore;\n\n  constructor(IStore store) Recoverable(store) {\n    _setAccessPolicy();\n  }\n\n  function _setAccessPolicy() private {\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_ADMIN, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_COVER_MANAGER, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_LIQUIDITY_MANAGER, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_GOVERNANCE_ADMIN, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_GOVERNANCE_AGENT, AccessControlLibV1.NS_ROLES_GOVERNANCE_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_UPGRADE_AGENT, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_RECOVERY_AGENT, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_PAUSE_AGENT, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_UNPAUSE_AGENT, AccessControlLibV1.NS_ROLES_ADMIN);\n\n    _setupRole(AccessControlLibV1.NS_ROLES_ADMIN, msg.sender);\n  }\n\n  function setupRole(\n    bytes32 role,\n    bytes32 adminRole,\n    address account\n  ) external nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeAdmin(s);\n\n    _setRoleAdmin(role, adminRole);\n\n    if (account != address(0)) {\n      _setupRole(role, account);\n    }\n  }\n\n  /**\n   * @dev Pauses this contract.\n   *\n   * Individual protocol contracts infer to the protocol's \"paused state\".\n   * So, if the protocol is paused, all other contracts are automatically\n   * paused without having to do anything special.\n   *\n   *\n   * In Neptune Mutual Protocol, `pause` and `unpause` features are\n   * considered to have different risk exposures.\n   *\n   * The pauser role is considered to be low-risk role while\n   * the unpauser is believed to be highly critical.\n   *\n   * In other words, pausing the protocol is believed to be less riskier than unpausing it.\n   *\n   * The only (private) key that is ever allowed to be programmatically used is the\n   * pause agents.\n   */\n  function pause() external nonReentrant whenNotPaused {\n    AccessControlLibV1.mustBePauseAgent(s);\n    super._pause();\n  }\n\n  /**\n   * @dev Unpauses or resumes this contract.\n   *\n   * Individual protocol contracts infer to the protocol's \"paused state\".\n   * So, if the protocol is paused, all other contracts are automatically\n   * paused without having to do anything special.\n   *\n   *\n   * In Neptune Mutual Protocol, `pause` and `unpause` features are\n   * considered to have different risk exposures.\n   *\n   * The pauser role is considered to be low-risk role while\n   * the unpauser is believed to be highly critical.\n   *\n   * In other words, pausing the protocol is believed to be less riskier than unpausing it.\n   *\n   * The only (private) key that is ever allowed to be programmatically used is the\n   * pause agents.\n   */\n  function unpause() external whenPaused nonReentrant whenPaused {\n    AccessControlLibV1.mustBeUnpauseAgent(s);\n    super._unpause();\n  }\n}"
    },
    {
      "filename": "contracts/core/ProtoBase.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/access/AccessControl.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/security/Pausable.sol\";\nimport \"../libraries/ProtoUtilV1.sol\";\nimport \"./Recoverable.sol\";\n\nabstract contract ProtoBase is AccessControl, Pausable, Recoverable {\n  using ProtoUtilV1 for IStore;\n  using ValidationLibV1 for IStore;\n\n  constructor(IStore store) Recoverable(store) {\n    _setAccessPolicy();\n  }\n\n  function _setAccessPolicy() private {\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_ADMIN, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_COVER_MANAGER, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_LIQUIDITY_MANAGER, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_GOVERNANCE_ADMIN, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_GOVERNANCE_AGENT, AccessControlLibV1.NS_ROLES_GOVERNANCE_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_UPGRADE_AGENT, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_RECOVERY_AGENT, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_PAUSE_AGENT, AccessControlLibV1.NS_ROLES_ADMIN);\n    _setRoleAdmin(AccessControlLibV1.NS_ROLES_UNPAUSE_AGENT, AccessControlLibV1.NS_ROLES_ADMIN);\n\n    _setupRole(AccessControlLibV1.NS_ROLES_ADMIN, msg.sender);\n  }\n\n  function setupRole(\n    bytes32 role,\n    bytes32 adminRole,\n    address account\n  ) external nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeAdmin(s);\n\n    _setRoleAdmin(role, adminRole);\n\n    if (account != address(0)) {\n      _setupRole(role, account);\n    }\n  }\n\n  /**\n   * @dev Pauses this contract.\n   *\n   * Individual protocol contracts infer to the protocol's \"paused state\".\n   * So, if the protocol is paused, all other contracts are automatically\n   * paused without having to do anything special.\n   *\n   *\n   * In Neptune Mutual Protocol, `pause` and `unpause` features are\n   * considered to have different risk exposures.\n   *\n   * The pauser role is considered to be low-risk role while\n   * the unpauser is believed to be highly critical.\n   *\n   * In other words, pausing the protocol is believed to be less riskier than unpausing it.\n   *\n   * The only (private) key that is ever allowed to be programmatically used is the\n   * pause agents.\n   */\n  function pause() external nonReentrant whenNotPaused {\n    AccessControlLibV1.mustBePauseAgent(s);\n    super._pause();\n  }\n\n  /**\n   * @dev Unpauses or resumes this contract.\n   *\n   * Individual protocol contracts infer to the protocol's \"paused state\".\n   * So, if the protocol is paused, all other contracts are automatically\n   * paused without having to do anything special.\n   *\n   *\n   * In Neptune Mutual Protocol, `pause` and `unpause` features are\n   * considered to have different risk exposures.\n   *\n   * The pauser role is considered to be low-risk role while\n   * the unpauser is believed to be highly critical.\n   *\n   * In other words, pausing the protocol is believed to be less riskier than unpausing it.\n   *\n   * The only (private) key that is ever allowed to be programmatically used is the\n   * pause agents.\n   */\n  function unpause() external whenPaused nonReentrant whenPaused {\n    AccessControlLibV1.mustBeUnpauseAgent(s);\n    super._unpause();\n  }\n}"
    }
  ]
}