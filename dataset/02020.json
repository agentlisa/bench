{
  "Title": "H-3: The formula used in ````SafeCall.callWithMinGas()```` is wrong",
  "Content": "# Issue H-3: The formula used in ````SafeCall.callWithMinGas()```` is wrong \n\nSource: https://github.com/sherlock-audit/2023-03-optimism-judging/issues/40 \n\n## Found by \nKingNFT, ShadowForce\n\n## Summary\nThe formula used in ````SafeCall.callWithMinGas()```` is not fully complying with EIP-150 and EIP-2929, the actual gas received by the sub-contract can be less than the required ````_minGas````. Withdrawal transactions can be finalized with less than specified gas limit, may lead to loss of funds.\n\n## Vulnerability Detail\n```solidity\nFile: contracts\\libraries\\SafeCall.sol\n048:     function callWithMinGas(\n049:         address _target,\n050:         uint256 _minGas,\n051:         uint256 _value,\n052:         bytes memory _calldata\n053:     ) internal returns (bool) {\n054:         bool _success;\n055:         assembly {\n056:             // Assertion: gasleft() >= ((_minGas + 200) * 64) / 63\n057:             //\n058:             // Because EIP-150 ensures that, a maximum of 63/64ths of the remaining gas in the call\n059:             // frame may be passed to a subcontext, we need to ensure that the gas will not be\n060:             // truncated to hold this function's invariant: \"If a call is performed by\n061:             // `callWithMinGas`, it must receive at least the specified minimum gas limit.\" In\n062:             // addition, exactly 51 gas is consumed between the below `GAS` opcode and the `CALL`\n063:             // opcode, so it is factored in with some extra room for error.\n064:             if lt(gas(), div(mul(64, add(_minGas, 200)), 63)) {\n065:                 // Store the \"Error(string)\" selector in scratch space.\n066:                 mstore(0, 0x08c379a0)\n067:                 // Store the pointer to the string length in scratch space.\n068:                 mstore(32, 32)\n069:                 // Store the string.\n070:                 //\n071:                 // SAFETY:\n072:                 // - We pad the beginning of the string with two zero bytes as well as the\n073:                 // length (24) to ensure that we override the free memory pointer at offset\n074:                 // 0x40. This is necessary because the free memory pointer is likely to\n075:                 // be greater than 1 byte when this function is called, but it is incredibly\n076:                 // unlikely that it will be greater than 3 bytes. As for the data within\n077:                 // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\n078:                 // - It's fine to clobber the free memory pointer, we're reverting.\n079:                 mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\n080: \n081:                 // Revert with 'Error(\"SafeCall: Not enough gas\")'\n082:                 revert(28, 100)\n083:             }\n084: \n085:             // The call will be supplied at least (((_minGas + 200) * 64) / 63) - 49 gas due to the\n086:             // above assertion. This ensures that, in all circumstances, the call will\n087:             // receive at least the minimum amount of gas specified.\n088:             // We can prove this property by solving the inequalities:\n089:             // ((((_minGas + 200) * 64) / 63) - 49) >= _minGas\n090:             // ((((_minGas + 200) * 64) / 63) - 51) * (63 / 64) >= _minGas\n091:             // Both inequalities hold true for all possible values of `_minGas`.\n092:             _success := call(\n093:                 gas(), // gas\n094:                 _target, // recipient\n095:                 _value, // ether value\n096:                 add(_calldata, 32), // inloc\n097:                 mload(_calldata), // inlen\n098:                 0x00, // outloc\n099:                 0x00 // outlen\n100:             )\n101:         }\n102:         return _success;\n103:     }\n\n```\nThe current formula used in ````SafeCall.callWithMinGas()```` involves two issues.\n\n### Firstly, the ````63/64```` rule is not the whole story of EIP-150 for the ````CALL```` opcode, let's take a look at the implementation of EIP-150, a ````base```` gas is subtracted before applying ````63/64```` rule.\nhttps://github.com/ethereum/go-ethereum/blob/2adce0b06640aa665706d014a92cd06f0720dcab/core/vm/gas.go#L37\n```go\nfunc callGas(isEip150 bool, availableGas, base uint64, callCost *uint256.Int) (uint64, error) {\n\tif isEip150 {\n\t\tavailableGas = availableGas - base\n\t\tgas := availableGas - availableGas/64\n\t\t// If the bit length exceeds 64 bit we know that the newly calculated \"gas\" for EIP150\n\t\t// is smaller than the requested amount. Therefore we return the new gas instead\n\t\t// of returning an error.\n\t\tif !callCost.IsUint64() || gas < callCost.Uint64() {\n\t\t\treturn gas, nil\n\t\t}\n\t}\n\tif !callCost.IsUint64() {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\n\treturn callCost.Uint64(), nil\n}\n```\nThe ````base```` gas is calculated in ````gasCall()```` of ````gas_table.go````,  which is subject to\n```solidity\n(1) L370~L376: call to a new account\n(2) L377~L379: call with non zero value\n(3) L380~L383: memory expansion\n```\nThe ````(1)```` and ````(3)```` are irrelevant  in this case, but ````(2)```` should be taken into account.\n\nhttps://github.com/ethereum/go-ethereum/blob/2adce0b06640aa665706d014a92cd06f0720dcab/core/vm/gas_table.go#L364\n```go\nFile: core\\vm\\gas_table.go\n364: func gasCall(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n365: \tvar (\n366: \t\tgas            uint64\n367: \t\ttransfersValue = !stack.Back(2).IsZero()\n368: \t\taddress        = common.Address(stack.Back(1).Bytes20())\n369: \t)\n370: \tif evm.chainRules.IsEIP158 {\n371: \t\tif transfersValue && evm.StateDB.Empty(address) {\n372: \t\t\tgas += params.CallNewAccountGas\n373: \t\t}\n374: \t} else if !evm.StateDB.Exist(address) {\n375: \t\tgas += params.CallNewAccountGas\n376: \t}\n377: \tif transfersValue {\n378: \t\tgas += params.CallValueTransferGas\n379: \t}\n380: \tmemoryGas, err := memoryGasCost(mem, memorySize)\n381: \tif err != nil {\n382: \t\treturn 0, err\n383: \t}\n384: \tvar overflow bool\n385: \tif gas, overflow = math.SafeAdd(gas, memoryGas); overflow {\n386: \t\treturn 0, ErrGasUintOverflow\n387: \t}\n388: \n389: \tevm.callGasTemp, err = callGas(evm.chainRules.IsEIP150, contract.Gas, gas, stack.Back(0))\n390: \tif err != nil {\n391: \t\treturn 0, err\n392: \t}\n393: \tif gas, overflow = math.SafeAdd(gas, evm.callGasTemp); overflow {\n394: \t\treturn 0, ErrGasUintOverflow\n395: \t}\n396: \treturn gas, nil\n397: }\n```\n\nThe ````raw```` extra gas for transferring value is\n```solidity\nparams.CallValueTransferGas - params.CallStipend * 64 / 63 = 9000 - 2300 * 64 / 63 = 6664\n```\nreleated LOCs:\nhttps://github.com/ethereum/go-ethereum/blob/2adce0b06640aa665706d014a92cd06f0720dcab/params/protocol_params.go#L30\nhttps://github.com/ethereum/go-ethereum/blob/2adce0b06640aa665706d014a92cd06f0720dcab/params/protocol_params.go#L37\nhttps://github.com/ethereum/go-ethereum/blob/2adce0b06640aa665706d014a92cd06f0720dcab/core/vm/instructions.go#L681-L684\n\n\n### Secondly, EIP-2929 also affects the gas cost of ````CALL```` opcode.\nLet's look at the implementation of EIP-2929 on ````CALL```` opcode, the ````ColdAccountAccessCostEIP2929 ```` is 2600 and the ````WarmStorageReadCostEIP2929```` is 100, they are subtracted before applying ````63/64```` rule too.\nhttps://github.com/ethereum/go-ethereum/blob/2adce0b06640aa665706d014a92cd06f0720dcab/core/vm/operations_acl.go#L160\n```go\nFile: core\\vm\\operations_acl.go\n195: \tgasCallEIP2929         = makeCallVariantGasCallEIP2929(gasCall)\n\nFile: core\\vm\\operations_acl.go\n160: func makeCallVariantGasCallEIP2929(oldCalculator gasFunc) gasFunc {\n161: \treturn func(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n162: \t\taddr := common.Address(stack.Back(1).Bytes20())\n163: \t\t// Check slot presence in the access list\n164: \t\twarmAccess := evm.StateDB.AddressInAccessList(addr)\n165: \t\t// The WarmStorageReadCostEIP2929 (100) is already deducted in the form of a constant cost, so\n166: \t\t// the cost to charge for cold access, if any, is Cold - Warm\n167: \t\tcoldCost := params.ColdAccountAccessCostEIP2929 - params.WarmStorageReadCostEIP2929\n168: \t\tif !warmAccess {\n169: \t\t\tevm.StateDB.AddAddressToAccessList(addr)\n170: \t\t\t// Charge the remaining difference here already, to correctly calculate available\n171: \t\t\t// gas for call\n172: \t\t\tif !contract.UseGas(coldCost) {\n173: \t\t\t\treturn 0, ErrOutOfGas\n174: \t\t\t}\n175: \t\t}\n176: \t\t// Now call the old calculator, which takes into account\n177: \t\t// - create new account\n178: \t\t// - transfer value\n179: \t\t// - memory expansion\n180: \t\t// - 63/64ths rule\n181: \t\tgas, err := oldCalculator(evm, contract, stack, mem, memorySize)\n182: \t\tif warmAccess || err != nil {\n183: \t\t\treturn gas, err\n184: \t\t}\n185: \t\t// In case of a cold access, we temporarily add the cold charge back, and also\n186: \t\t// add it to the returned gas. By adding it to the return, it will be charged\n187: \t\t// outside of this function, as part of the dynamic gas, and that will make it\n188: \t\t// also become correctly reported to tracers.\n189: \t\tcontract.Gas += coldCost\n190: \t\treturn gas + coldCost, nil\n191: \t}\n192: }\n\n```\n\nHere is a test script to show the impact of the two aspects mentioned above\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\nlibrary SafeCall {\n    function callWithMinGas(\n        address _target,\n        uint256 _minGas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        uint256 gasSent;\n        assembly {\n            // Assertion: gasleft() >= ((_minGas + 200) * 64) / 63\n            //\n            // Because EIP-150 ensures that, a maximum of 63/64ths of the remaining gas in the call\n            // frame may be passed to a subcontext, we need to ensure that the gas will not be\n            // truncated to hold this function's invariant: \"If a call is performed by\n            // `callWithMinGas`, it must receive at least the specified minimum gas limit.\" In\n            // addition, exactly 51 gas is consumed between the below `GAS` opcode and the `CALL`\n            // opcode, so it is factored in with some extra room for error.\n            if lt(gas(), div(mul(64, add(_minGas, 200)), 63)) {\n                // Store the \"Error(string)\" selector in scratch space.\n                mstore(0, 0x08c379a0)\n                // Store the pointer to the string length in scratch space.\n                mstore(32, 32)\n                // Store the string.\n                //\n                // SAFETY:\n                // - We pad the beginning of the string with two zero bytes as well as the\n                // length (24) to ensure that we override the free memory pointer at offset\n                // 0x40. This is necessary because the free memory pointer is likely to\n                // be greater than 1 byte when this function is called, but it is incredibly\n                // unlikely that it will be greater than 3 bytes. As for the data within\n                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\n                // - It's fine to clobber the free memory pointer, we're reverting.\n                mstore(\n                    88,\n                    0x0000185361666543616c6c3a204e6f7420656e6f75676820676173\n                )\n\n                // Revert with 'Error(\"SafeCall: Not enough gas\")'\n                revert(28, 100)\n            }\n\n            // The call will be supplied at least (((_minGas + 200) * 64) / 63) - 49 gas due to the\n            // above assertion. This ensures that, in all circumstances, the call will\n            // receive at least the minimum amount of gas specified.\n            // We can prove this property by solving the inequalities:\n            // ((((_minGas + 200) * 64) / 63) - 49) >= _minGas\n            // ((((_minGas + 200) * 64) / 63) - 51) * (63 / 64) >= _minGas\n            // Both inequalities hold true for all possible values of `_minGas`.\n            gasSent := gas() // @audit this operation costs 2 gas\n            _success := call(\n                gas(), // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 32), // inloc\n                mload(_calldata), // inlen\n                0x00, // outloc\n                0x00 // outlen\n            )\n        }\n        console.log(\"gasSent =\", gasSent);\n        return _success;\n    }\n}\n\ncontract Callee {\n    fallback() external payable {\n        uint256 gas = gasleft();\n        console.log(\"gasReceived =\", gas);\n    }\n}\n\ncontract Caller {\n    function execute(\n        address _target,\n        uint256 _minGas,\n        bytes memory _calldata\n    ) external payable {\n        SafeCall.callWithMinGas(_target, _minGas, msg.value, _calldata);\n    }\n}\n\ncontract TestCallWithMinGas is Test {\n    address callee;\n    Caller caller;\n\n    function setUp() public {\n        callee = address(new Callee());\n        caller = new Caller();\n    }\n\n    function testCallWithMinGas() public {\n        console.log(\"-------1st call------\");\n        caller.execute{gas: 64_855}(callee, 63_000, \"\");\n\n        console.log(\"\\n  -------2nd call------\");\n        caller.execute{gas: 64_855}(callee, 63_000, \"\");\n\n        console.log(\"\\n  -------3rd call------\");\n        caller.execute{gas: 62_555, value: 1}(callee, 63_000, \"\");\n    }\n}\n\n```\n\nAnd the log would be\n```solidity\nRunning 1 test for test/TestCallWithMinGas.sol:TestCallWithMinGas\n[PASS] testCallWithMinGas() (gas: 36065)\nLogs:\n  -------1st call------\n  gasReceived = 60582\n  gasSent = 64200\n\n  -------2nd call------\n  gasReceived = 63042\n  gasSent = 64200\n\n  -------3rd call------\n  gasReceived = 56483\n  gasSent = 64200\n```\nThe difference between ````1st call```` and ````2nd call```` is caused by EIP-2929, and the difference between ````2nd call```` and ````3rd call```` is caused by transferring value. We can see the actual received gas in the sub-contract is less than the 63,000 ````_minGas```` limit in both 1st and 3rd call.\n\n## Impact\n````SafeCall.callWithMinGas()```` is a key design to ensure withdrawal transactions will be executed with more gas than the limit specified by users. This issue breaks the specification. Finalizing withdrawal transactions with less than specified gas limit may fail unexpectedly due to out of gas, lead to loss of funds.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/libraries/SafeCall.sol#L48\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe migration logic may look like\n```solidity\nif (_value == 0) {\n     gasleft() >= ((_minGas + 200) * 64) / 63 + 2600\n} else {\n     gasleft() >= ((_minGas + 200) * 64) / 63 + 2600 + 6700\n}\n```\n\n\n\n## Discussion\n\n**GalloDaSballo**\n\nThe math checks out, the base-gas is ignoring CALL + Cold Address meaning that there are scenarios in which base gas is not sufficient\n\n**hrishibhat**\n\nSponsor comment:\nThis report is valid. The formula used in `SafeCall.callWithMinGas()` does not account for all of the dynamic gas costs of the `CALL` opcode.\n\n**GalloDaSballo**\n\nThe finding shows the full impact, agree with High Severity\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/63",
  "Code": [
    {
      "filename": "core/vm/gas.go",
      "content": "// Copyright 2015 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage vm\n\nimport (\n\t\"github.com/holiman/uint256\"\n)\n\n// Gas costs\nconst (\n\tGasQuickStep   uint64 = 2\n\tGasFastestStep uint64 = 3\n\tGasFastStep    uint64 = 5\n\tGasMidStep     uint64 = 8\n\tGasSlowStep    uint64 = 10\n\tGasExtStep     uint64 = 20\n)\n\n// callGas returns the actual gas cost of the call.\n//\n// The cost of gas was changed during the homestead price change HF.\n// As part of EIP 150 (TangerineWhistle), the returned gas is gas - base * 63 / 64.\nfunc callGas(isEip150 bool, availableGas, base uint64, callCost *uint256.Int) (uint64, error) {\n\tif isEip150 {\n\t\tavailableGas = availableGas - base\n\t\tgas := availableGas - availableGas/64\n\t\t// If the bit length exceeds 64 bit we know that the newly calculated \"gas\" for EIP150\n\t\t// is smaller than the requested amount. Therefore we return the new gas instead\n\t\t// of returning an error.\n\t\tif !callCost.IsUint64() || gas < callCost.Uint64() {\n\t\t\treturn gas, nil\n\t\t}\n\t}\n\tif !callCost.IsUint64() {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\n\treturn callCost.Uint64(), nil\n}"
    },
    {
      "filename": "core/vm/gas_table.go",
      "content": "// Copyright 2017 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage vm\n\nimport (\n\t\"errors\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/common/math\"\n\t\"github.com/ethereum/go-ethereum/params\"\n)\n\n// memoryGasCost calculates the quadratic gas for memory expansion. It does so\n// only for the memory region that is expanded, not the total memory.\nfunc memoryGasCost(mem *Memory, newMemSize uint64) (uint64, error) {\n\tif newMemSize == 0 {\n\t\treturn 0, nil\n\t}\n\t// The maximum that will fit in a uint64 is max_word_count - 1. Anything above\n\t// that will result in an overflow. Additionally, a newMemSize which results in\n\t// a newMemSizeWords larger than 0xFFFFFFFF will cause the square operation to\n\t// overflow. The constant 0x1FFFFFFFE0 is the highest number that can be used\n\t// without overflowing the gas calculation.\n\tif newMemSize > 0x1FFFFFFFE0 {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\tnewMemSizeWords := toWordSize(newMemSize)\n\tnewMemSize = newMemSizeWords * 32\n\n\tif newMemSize > uint64(mem.Len()) {\n\t\tsquare := newMemSizeWords * newMemSizeWords\n\t\tlinCoef := newMemSizeWords * params.MemoryGas\n\t\tquadCoef := square / params.QuadCoeffDiv\n\t\tnewTotalFee := linCoef + quadCoef\n\n\t\tfee := newTotalFee - mem.lastGasCost\n\t\tmem.lastGasCost = newTotalFee\n\n\t\treturn fee, nil\n\t}\n\treturn 0, nil\n}\n\n// memoryCopierGas creates the gas functions for the following opcodes, and takes\n// the stack position of the operand which determines the size of the data to copy\n// as argument:\n// CALLDATACOPY (stack position 2)\n// CODECOPY (stack position 2)\n// EXTCODECOPY (stack position 3)\n// RETURNDATACOPY (stack position 2)\nfunc memoryCopierGas(stackpos int) gasFunc {\n\treturn func(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\t\t// Gas for expanding the memory\n\t\tgas, err := memoryGasCost(mem, memorySize)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\t// And gas for copying data, charged per word at param.CopyGas\n\t\twords, overflow := stack.Back(stackpos).Uint64WithOverflow()\n\t\tif overflow {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\n\t\tif words, overflow = math.SafeMul(toWordSize(words), params.CopyGas); overflow {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\n\t\tif gas, overflow = math.SafeAdd(gas, words); overflow {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\t\treturn gas, nil\n\t}\n}\n\nvar (\n\tgasCallDataCopy   = memoryCopierGas(2)\n\tgasCodeCopy       = memoryCopierGas(2)\n\tgasExtCodeCopy    = memoryCopierGas(3)\n\tgasReturnDataCopy = memoryCopierGas(2)\n)\n\nfunc gasSStore(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\tvar (\n\t\ty, x    = stack.Back(1), stack.Back(0)\n\t\tcurrent = evm.StateDB.GetState(contract.Address(), x.Bytes32())\n\t)\n\t// The legacy gas metering only takes into consideration the current state\n\t// Legacy rules should be applied if we are in Petersburg (removal of EIP-1283)\n\t// OR Constantinople is not active\n\tif evm.chainRules.IsPetersburg || !evm.chainRules.IsConstantinople {\n\t\t// This checks for 3 scenario's and calculates gas accordingly:\n\t\t//\n\t\t// 1. From a zero-value address to a non-zero value         (NEW VALUE)\n\t\t// 2. From a non-zero value address to a zero-value address (DELETE)\n\t\t// 3. From a non-zero to a non-zero                         (CHANGE)\n\t\tswitch {\n\t\tcase current == (common.Hash{}) && y.Sign() != 0: // 0 => non 0\n\t\t\treturn params.SstoreSetGas, nil\n\t\tcase current != (common.Hash{}) && y.Sign() == 0: // non 0 => 0\n\t\t\tevm.StateDB.AddRefund(params.SstoreRefundGas)\n\t\t\treturn params.SstoreClearGas, nil\n\t\tdefault: // non 0 => non 0 (or 0 => 0)\n\t\t\treturn params.SstoreResetGas, nil\n\t\t}\n\t}\n\n\t// The new gas metering is based on net gas costs (EIP-1283):\n\t//\n\t// (1.) If current value equals new value (this is a no-op), 200 gas is deducted.\n\t// (2.) If current value does not equal new value\n\t//\t(2.1.) If original value equals current value (this storage slot has not been changed by the current execution context)\n\t//\t\t(2.1.1.) If original value is 0, 20000 gas is deducted.\n\t//\t\t(2.1.2.) Otherwise, 5000 gas is deducted. If new value is 0, add 15000 gas to refund counter.\n\t//\t(2.2.) If original value does not equal current value (this storage slot is dirty), 200 gas is deducted. Apply both of the following clauses.\n\t//\t\t(2.2.1.) If original value is not 0\n\t//\t\t\t(2.2.1.1.) If current value is 0 (also means that new value is not 0), remove 15000 gas from refund counter. We can prove that refund counter will never go below 0.\n\t//\t\t\t(2.2.1.2.) If new value is 0 (also means that current value is not 0), add 15000 gas to refund counter.\n\t//\t\t(2.2.2.) If original value equals new value (this storage slot is reset)\n\t//\t\t\t(2.2.2.1.) If original value is 0, add 19800 gas to refund counter.\n\t//\t\t\t(2.2.2.2.) Otherwise, add 4800 gas to refund counter.\n\tvalue := common.Hash(y.Bytes32())\n\tif current == value { // noop (1)\n\t\treturn params.NetSstoreNoopGas, nil\n\t}\n\toriginal := evm.StateDB.GetCommittedState(contract.Address(), x.Bytes32())\n\tif original == current {\n\t\tif original == (common.Hash{}) { // create slot (2.1.1)\n\t\t\treturn params.NetSstoreInitGas, nil\n\t\t}\n\t\tif value == (common.Hash{}) { // delete slot (2.1.2b)\n\t\t\tevm.StateDB.AddRefund(params.NetSstoreClearRefund)\n\t\t}\n\t\treturn params.NetSstoreCleanGas, nil // write existing slot (2.1.2)\n\t}\n\tif original != (common.Hash{}) {\n\t\tif current == (common.Hash{}) { // recreate slot (2.2.1.1)\n\t\t\tevm.StateDB.SubRefund(params.NetSstoreClearRefund)\n\t\t} else if value == (common.Hash{}) { // delete slot (2.2.1.2)\n\t\t\tevm.StateDB.AddRefund(params.NetSstoreClearRefund)\n\t\t}\n\t}\n\tif original == value {\n\t\tif original == (common.Hash{}) { // reset to original inexistent slot (2.2.2.1)\n\t\t\tevm.StateDB.AddRefund(params.NetSstoreResetClearRefund)\n\t\t} else { // reset to original existing slot (2.2.2.2)\n\t\t\tevm.StateDB.AddRefund(params.NetSstoreResetRefund)\n\t\t}\n\t}\n\treturn params.NetSstoreDirtyGas, nil\n}\n\n// Here come the EIP2200 rules:\n//\n//\t(0.) If *gasleft* is less than or equal to 2300, fail the current call.\n//\t(1.) If current value equals new value (this is a no-op), SLOAD_GAS is deducted.\n//\t(2.) If current value does not equal new value:\n//\t\t(2.1.) If original value equals current value (this storage slot has not been changed by the current execution context):\n//\t\t\t(2.1.1.) If original value is 0, SSTORE_SET_GAS (20K) gas is deducted.\n//\t\t\t(2.1.2.) Otherwise, SSTORE_RESET_GAS gas is deducted. If new value is 0, add SSTORE_CLEARS_SCHEDULE to refund counter.\n//\t\t(2.2.) If original value does not equal current value (this storage slot is dirty), SLOAD_GAS gas is deducted. Apply both of the following clauses:\n//\t\t\t(2.2.1.) If original value is not 0:\n//\t\t\t\t(2.2.1.1.) If current value is 0 (also means that new value is not 0), subtract SSTORE_CLEARS_SCHEDULE gas from refund counter.\n//\t\t\t\t(2.2.1.2.) If new value is 0 (also means that current value is not 0), add SSTORE_CLEARS_SCHEDULE gas to refund counter.\n//\t\t\t(2.2.2.) If original value equals new value (this storage slot is reset):\n//\t\t\t\t(2.2.2.1.) If original value is 0, add SSTORE_SET_GAS - SLOAD_GAS to refund counter.\n//\t\t\t\t(2.2.2.2.) Otherwise, add SSTORE_RESET_GAS - SLOAD_GAS gas to refund counter.\nfunc gasSStoreEIP2200(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\t// If we fail the minimum gas availability invariant, fail (0)\n\tif contract.Gas <= params.SstoreSentryGasEIP2200 {\n\t\treturn 0, errors.New(\"not enough gas for reentrancy sentry\")\n\t}\n\t// Gas sentry honoured, do the actual gas calculation based on the stored value\n\tvar (\n\t\ty, x    = stack.Back(1), stack.Back(0)\n\t\tcurrent = evm.StateDB.GetState(contract.Address(), x.Bytes32())\n\t)\n\tvalue := common.Hash(y.Bytes32())\n\n\tif current == value { // noop (1)\n\t\treturn params.SloadGasEIP2200, nil\n\t}\n\toriginal := evm.StateDB.GetCommittedState(contract.Address(), x.Bytes32())\n\tif original == current {\n\t\tif original == (common.Hash{}) { // create slot (2.1.1)\n\t\t\treturn params.SstoreSetGasEIP2200, nil\n\t\t}\n\t\tif value == (common.Hash{}) { // delete slot (2.1.2b)\n\t\t\tevm.StateDB.AddRefund(params.SstoreClearsScheduleRefundEIP2200)\n\t\t}\n\t\treturn params.SstoreResetGasEIP2200, nil // write existing slot (2.1.2)\n\t}\n\tif original != (common.Hash{}) {\n\t\tif current == (common.Hash{}) { // recreate slot (2.2.1.1)\n\t\t\tevm.StateDB.SubRefund(params.SstoreClearsScheduleRefundEIP2200)\n\t\t} else if value == (common.Hash{}) { // delete slot (2.2.1.2)\n\t\t\tevm.StateDB.AddRefund(params.SstoreClearsScheduleRefundEIP2200)\n\t\t}\n\t}\n\tif original == value {\n\t\tif original == (common.Hash{}) { // reset to original inexistent slot (2.2.2.1)\n\t\t\tevm.StateDB.AddRefund(params.SstoreSetGasEIP2200 - params.SloadGasEIP2200)\n\t\t} else { // reset to original existing slot (2.2.2.2)\n\t\t\tevm.StateDB.AddRefund(params.SstoreResetGasEIP2200 - params.SloadGasEIP2200)\n\t\t}\n\t}\n\treturn params.SloadGasEIP2200, nil // dirty update (2.2)\n}\n\nfunc makeGasLog(n uint64) gasFunc {\n\treturn func(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\t\trequestedSize, overflow := stack.Back(1).Uint64WithOverflow()\n\t\tif overflow {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\n\t\tgas, err := memoryGasCost(mem, memorySize)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif gas, overflow = math.SafeAdd(gas, params.LogGas); overflow {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\t\tif gas, overflow = math.SafeAdd(gas, n*params.LogTopicGas); overflow {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\n\t\tvar memorySizeGas uint64\n\t\tif memorySizeGas, overflow = math.SafeMul(requestedSize, params.LogDataGas); overflow {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\t\tif gas, overflow = math.SafeAdd(gas, memorySizeGas); overflow {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\t\treturn gas, nil\n\t}\n}\n\nfunc gasKeccak256(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\tgas, err := memoryGasCost(mem, memorySize)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\twordGas, overflow := stack.Back(1).Uint64WithOverflow()\n\tif overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\tif wordGas, overflow = math.SafeMul(toWordSize(wordGas), params.Keccak256WordGas); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\tif gas, overflow = math.SafeAdd(gas, wordGas); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\treturn gas, nil\n}\n\n// pureMemoryGascost is used by several operations, which aside from their\n// static cost have a dynamic cost which is solely based on the memory\n// expansion\nfunc pureMemoryGascost(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\treturn memoryGasCost(mem, memorySize)\n}\n\nvar (\n\tgasReturn  = pureMemoryGascost\n\tgasRevert  = pureMemoryGascost\n\tgasMLoad   = pureMemoryGascost\n\tgasMStore8 = pureMemoryGascost\n\tgasMStore  = pureMemoryGascost\n\tgasCreate  = pureMemoryGascost\n)\n\nfunc gasCreate2(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\tgas, err := memoryGasCost(mem, memorySize)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\twordGas, overflow := stack.Back(2).Uint64WithOverflow()\n\tif overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\tif wordGas, overflow = math.SafeMul(toWordSize(wordGas), params.Keccak256WordGas); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\tif gas, overflow = math.SafeAdd(gas, wordGas); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\treturn gas, nil\n}\n\nfunc gasCreateEip3860(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\tgas, err := memoryGasCost(mem, memorySize)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tsize, overflow := stack.Back(2).Uint64WithOverflow()\n\tif overflow || size > params.MaxInitCodeSize {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\t// Since size <= params.MaxInitCodeSize, these multiplication cannot overflow\n\tmoreGas := params.InitCodeWordGas * ((size + 31) / 32)\n\tif gas, overflow = math.SafeAdd(gas, moreGas); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\treturn gas, nil\n}\nfunc gasCreate2Eip3860(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\tgas, err := memoryGasCost(mem, memorySize)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tsize, overflow := stack.Back(2).Uint64WithOverflow()\n\tif overflow || size > params.MaxInitCodeSize {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\t// Since size <= params.MaxInitCodeSize, these multiplication cannot overflow\n\tmoreGas := (params.InitCodeWordGas + params.Keccak256WordGas) * ((size + 31) / 32)\n\tif gas, overflow = math.SafeAdd(gas, moreGas); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\treturn gas, nil\n}\n\nfunc gasExpFrontier(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\texpByteLen := uint64((stack.data[stack.len()-2].BitLen() + 7) / 8)\n\n\tvar (\n\t\tgas      = expByteLen * params.ExpByteFrontier // no overflow check required. Max is 256 * ExpByte gas\n\t\toverflow bool\n\t)\n\tif gas, overflow = math.SafeAdd(gas, params.ExpGas); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\treturn gas, nil\n}\n\nfunc gasExpEIP158(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\texpByteLen := uint64((stack.data[stack.len()-2].BitLen() + 7) / 8)\n\n\tvar (\n\t\tgas      = expByteLen * params.ExpByteEIP158 // no overflow check required. Max is 256 * ExpByte gas\n\t\toverflow bool\n\t)\n\tif gas, overflow = math.SafeAdd(gas, params.ExpGas); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\treturn gas, nil\n}\n\nfunc gasCall(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\tvar (\n\t\tgas            uint64\n\t\ttransfersValue = !stack.Back(2).IsZero()\n\t\taddress        = common.Address(stack.Back(1).Bytes20())\n\t)\n\tif evm.chainRules.IsEIP158 {\n\t\tif transfersValue && evm.StateDB.Empty(address) {\n\t\t\tgas += params.CallNewAccountGas\n\t\t}\n\t} else if !evm.StateDB.Exist(address) {\n\t\tgas += params.CallNewAccountGas\n\t}\n\tif transfersValue {\n\t\tgas += params.CallValueTransferGas\n\t}\n\tmemoryGas, err := memoryGasCost(mem, memorySize)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvar overflow bool\n\tif gas, overflow = math.SafeAdd(gas, memoryGas); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\n\tevm.callGasTemp, err = callGas(evm.chainRules.IsEIP150, contract.Gas, gas, stack.Back(0))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif gas, overflow = math.SafeAdd(gas, evm.callGasTemp); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\treturn gas, nil\n}\n\nfunc gasCallCode(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\tmemoryGas, err := memoryGasCost(mem, memorySize)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvar (\n\t\tgas      uint64\n\t\toverflow bool\n\t)\n\tif stack.Back(2).Sign() != 0 {\n\t\tgas += params.CallValueTransferGas\n\t}\n\tif gas, overflow = math.SafeAdd(gas, memoryGas); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\tevm.callGasTemp, err = callGas(evm.chainRules.IsEIP150, contract.Gas, gas, stack.Back(0))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif gas, overflow = math.SafeAdd(gas, evm.callGasTemp); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\treturn gas, nil\n}\n\nfunc gasDelegateCall(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\tgas, err := memoryGasCost(mem, memorySize)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tevm.callGasTemp, err = callGas(evm.chainRules.IsEIP150, contract.Gas, gas, stack.Back(0))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvar overflow bool\n\tif gas, overflow = math.SafeAdd(gas, evm.callGasTemp); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\treturn gas, nil\n}\n\nfunc gasStaticCall(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\tgas, err := memoryGasCost(mem, memorySize)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tevm.callGasTemp, err = callGas(evm.chainRules.IsEIP150, contract.Gas, gas, stack.Back(0))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvar overflow bool\n\tif gas, overflow = math.SafeAdd(gas, evm.callGasTemp); overflow {\n\t\treturn 0, ErrGasUintOverflow\n\t}\n\treturn gas, nil\n}\n\nfunc gasSelfdestruct(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize uint64) (uint64, error) {\n\tvar gas uint64\n\t// EIP150 homestead gas reprice fork:\n\tif evm.chainRules.IsEIP150 {\n\t\tgas = params.SelfdestructGasEIP150\n\t\tvar address = common.Address(stack.Back(0).Bytes20())\n\n\t\tif evm.chainRules.IsEIP158 {\n\t\t\t// if empty and transfers value\n\t\t\tif evm.StateDB.Empty(address) && evm.StateDB.GetBalance(contract.Address()).Sign() != 0 {\n\t\t\t\tgas += params.CreateBySelfdestructGas\n\t\t\t}\n\t\t} else if !evm.StateDB.Exist(address) {\n\t\t\tgas += params.CreateBySelfdestructGas\n\t\t}\n\t}\n\n\tif !evm.StateDB.HasSuicided(contract.Address()) {\n\t\tevm.StateDB.AddRefund(params.SelfdestructRefundGas)\n\t}\n\treturn gas, nil\n}"
    },
    {
      "filename": "params/protocol_params.go",
      "content": "// Copyright 2015 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage params\n\nimport \"math/big\"\n\nconst (\n\tGasLimitBoundDivisor uint64 = 1024               // The bound divisor of the gas limit, used in update calculations.\n\tMinGasLimit          uint64 = 5000               // Minimum the gas limit may ever be.\n\tMaxGasLimit          uint64 = 0x7fffffffffffffff // Maximum the gas limit (2^63-1).\n\tGenesisGasLimit      uint64 = 4712388            // Gas limit of the Genesis block.\n\n\tMaximumExtraDataSize  uint64 = 32    // Maximum size extra data may be after Genesis.\n\tExpByteGas            uint64 = 10    // Times ceil(log256(exponent)) for the EXP instruction.\n\tSloadGas              uint64 = 50    // Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added.\n\tCallValueTransferGas  uint64 = 9000  // Paid for CALL when the value transfer is non-zero.\n\tCallNewAccountGas     uint64 = 25000 // Paid for CALL when the destination address didn't exist prior.\n\tTxGas                 uint64 = 21000 // Per transaction not creating a contract. NOTE: Not payable on data of calls between transactions.\n\tTxGasContractCreation uint64 = 53000 // Per transaction that creates a contract. NOTE: Not payable on data of calls between transactions.\n\tTxDataZeroGas         uint64 = 4     // Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions.\n\tQuadCoeffDiv          uint64 = 512   // Divisor for the quadratic particle of the memory cost equation.\n\tLogDataGas            uint64 = 8     // Per byte in a LOG* operation's data.\n\tCallStipend           uint64 = 2300  // Free gas given at beginning of call.\n\n\tKeccak256Gas     uint64 = 30 // Once per KECCAK256 operation.\n\tKeccak256WordGas uint64 = 6  // Once per word of the KECCAK256 operation's data.\n\tInitCodeWordGas  uint64 = 2  // Once per word of the init code when creating a contract.\n\n\tSstoreSetGas    uint64 = 20000 // Once per SSTORE operation.\n\tSstoreResetGas  uint64 = 5000  // Once per SSTORE operation if the zeroness changes from zero.\n\tSstoreClearGas  uint64 = 5000  // Once per SSTORE operation if the zeroness doesn't change.\n\tSstoreRefundGas uint64 = 15000 // Once per SSTORE operation if the zeroness changes to zero.\n\n\tNetSstoreNoopGas  uint64 = 200   // Once per SSTORE operation if the value doesn't change.\n\tNetSstoreInitGas  uint64 = 20000 // Once per SSTORE operation from clean zero.\n\tNetSstoreCleanGas uint64 = 5000  // Once per SSTORE operation from clean non-zero.\n\tNetSstoreDirtyGas uint64 = 200   // Once per SSTORE operation from dirty.\n\n\tNetSstoreClearRefund      uint64 = 15000 // Once per SSTORE operation for clearing an originally existing storage slot\n\tNetSstoreResetRefund      uint64 = 4800  // Once per SSTORE operation for resetting to the original non-zero value\n\tNetSstoreResetClearRefund uint64 = 19800 // Once per SSTORE operation for resetting to the original zero value\n\n\tSstoreSentryGasEIP2200            uint64 = 2300  // Minimum gas required to be present for an SSTORE call, not consumed\n\tSstoreSetGasEIP2200               uint64 = 20000 // Once per SSTORE operation from clean zero to non-zero\n\tSstoreResetGasEIP2200             uint64 = 5000  // Once per SSTORE operation from clean non-zero to something else\n\tSstoreClearsScheduleRefundEIP2200 uint64 = 15000 // Once per SSTORE operation for clearing an originally existing storage slot\n\n\tColdAccountAccessCostEIP2929 = uint64(2600) // COLD_ACCOUNT_ACCESS_COST\n\tColdSloadCostEIP2929         = uint64(2100) // COLD_SLOAD_COST\n\tWarmStorageReadCostEIP2929   = uint64(100)  // WARM_STORAGE_READ_COST\n\n\t// In EIP-2200: SstoreResetGas was 5000.\n\t// In EIP-2929: SstoreResetGas was changed to '5000 - COLD_SLOAD_COST'.\n\t// In EIP-3529: SSTORE_CLEARS_SCHEDULE is defined as SSTORE_RESET_GAS + ACCESS_LIST_STORAGE_KEY_COST\n\t// Which becomes: 5000 - 2100 + 1900 = 4800\n\tSstoreClearsScheduleRefundEIP3529 uint64 = SstoreResetGasEIP2200 - ColdSloadCostEIP2929 + TxAccessListStorageKeyGas\n\n\tJumpdestGas   uint64 = 1     // Once per JUMPDEST operation.\n\tEpochDuration uint64 = 30000 // Duration between proof-of-work epochs.\n\n\tCreateDataGas         uint64 = 200   //\n\tCallCreateDepth       uint64 = 1024  // Maximum depth of call/create stack.\n\tExpGas                uint64 = 10    // Once per EXP instruction\n\tLogGas                uint64 = 375   // Per LOG* operation.\n\tCopyGas               uint64 = 3     //\n\tStackLimit            uint64 = 1024  // Maximum size of VM stack allowed.\n\tTierStepGas           uint64 = 0     // Once per operation, for a selection of them.\n\tLogTopicGas           uint64 = 375   // Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas.\n\tCreateGas             uint64 = 32000 // Once per CREATE operation & contract-creation transaction.\n\tCreate2Gas            uint64 = 32000 // Once per CREATE2 operation\n\tSelfdestructRefundGas uint64 = 24000 // Refunded following a selfdestruct operation.\n\tMemoryGas             uint64 = 3     // Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL.\n\n\tTxDataNonZeroGasFrontier  uint64 = 68   // Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions.\n\tTxDataNonZeroGasEIP2028   uint64 = 16   // Per byte of non zero data attached to a transaction after EIP 2028 (part in Istanbul)\n\tTxAccessListAddressGas    uint64 = 2400 // Per address specified in EIP 2930 access list\n\tTxAccessListStorageKeyGas uint64 = 1900 // Per storage key specified in EIP 2930 access list\n\n\t// These have been changed during the course of the chain\n\tCallGasFrontier              uint64 = 40  // Once per CALL operation & message call transaction.\n\tCallGasEIP150                uint64 = 700 // Static portion of gas for CALL-derivates after EIP 150 (Tangerine)\n\tBalanceGasFrontier           uint64 = 20  // The cost of a BALANCE operation\n\tBalanceGasEIP150             uint64 = 400 // The cost of a BALANCE operation after Tangerine\n\tBalanceGasEIP1884            uint64 = 700 // The cost of a BALANCE operation after EIP 1884 (part of Istanbul)\n\tExtcodeSizeGasFrontier       uint64 = 20  // Cost of EXTCODESIZE before EIP 150 (Tangerine)\n\tExtcodeSizeGasEIP150         uint64 = 700 // Cost of EXTCODESIZE after EIP 150 (Tangerine)\n\tSloadGasFrontier             uint64 = 50\n\tSloadGasEIP150               uint64 = 200\n\tSloadGasEIP1884              uint64 = 800  // Cost of SLOAD after EIP 1884 (part of Istanbul)\n\tSloadGasEIP2200              uint64 = 800  // Cost of SLOAD after EIP 2200 (part of Istanbul)\n\tExtcodeHashGasConstantinople uint64 = 400  // Cost of EXTCODEHASH (introduced in Constantinople)\n\tExtcodeHashGasEIP1884        uint64 = 700  // Cost of EXTCODEHASH after EIP 1884 (part in Istanbul)\n\tSelfdestructGasEIP150        uint64 = 5000 // Cost of SELFDESTRUCT post EIP 150 (Tangerine)\n\n\t// EXP has a dynamic portion depending on the size of the exponent\n\tExpByteFrontier uint64 = 10 // was set to 10 in Frontier\n\tExpByteEIP158   uint64 = 50 // was raised to 50 during Eip158 (Spurious Dragon)\n\n\t// Extcodecopy has a dynamic AND a static cost. This represents only the\n\t// static portion of the gas. It was changed during EIP 150 (Tangerine)\n\tExtcodeCopyBaseFrontier uint64 = 20\n\tExtcodeCopyBaseEIP150   uint64 = 700\n\n\t// CreateBySelfdestructGas is used when the refunded account is one that does\n\t// not exist. This logic is similar to call.\n\t// Introduced in Tangerine Whistle (Eip 150)\n\tCreateBySelfdestructGas uint64 = 25000\n\n\tDefaultBaseFeeChangeDenominator = 8          // Bounds the amount the base fee can change between blocks.\n\tDefaultElasticityMultiplier     = 2          // Bounds the maximum gas limit an EIP-1559 block may have.\n\tInitialBaseFee                  = 1000000000 // Initial base fee for EIP-1559 blocks.\n\n\tMaxCodeSize     = 24576           // Maximum bytecode to permit for a contract\n\tMaxInitCodeSize = 2 * MaxCodeSize // Maximum initcode to permit in a creation transaction and create instructions\n\n\t// Precompiled contract gas prices\n\n\tEcrecoverGas        uint64 = 3000 // Elliptic curve sender recovery gas price\n\tSha256BaseGas       uint64 = 60   // Base price for a SHA256 operation\n\tSha256PerWordGas    uint64 = 12   // Per-word price for a SHA256 operation\n\tRipemd160BaseGas    uint64 = 600  // Base price for a RIPEMD160 operation\n\tRipemd160PerWordGas uint64 = 120  // Per-word price for a RIPEMD160 operation\n\tIdentityBaseGas     uint64 = 15   // Base price for a data copy operation\n\tIdentityPerWordGas  uint64 = 3    // Per-work price for a data copy operation\n\n\tBn256AddGasByzantium             uint64 = 500    // Byzantium gas needed for an elliptic curve addition\n\tBn256AddGasIstanbul              uint64 = 150    // Gas needed for an elliptic curve addition\n\tBn256ScalarMulGasByzantium       uint64 = 40000  // Byzantium gas needed for an elliptic curve scalar multiplication\n\tBn256ScalarMulGasIstanbul        uint64 = 6000   // Gas needed for an elliptic curve scalar multiplication\n\tBn256PairingBaseGasByzantium     uint64 = 100000 // Byzantium base price for an elliptic curve pairing check\n\tBn256PairingBaseGasIstanbul      uint64 = 45000  // Base price for an elliptic curve pairing check\n\tBn256PairingPerPointGasByzantium uint64 = 80000  // Byzantium per-point price for an elliptic curve pairing check\n\tBn256PairingPerPointGasIstanbul  uint64 = 34000  // Per-point price for an elliptic curve pairing check\n\n\tBls12381G1AddGas          uint64 = 600    // Price for BLS12-381 elliptic curve G1 point addition\n\tBls12381G1MulGas          uint64 = 12000  // Price for BLS12-381 elliptic curve G1 point scalar multiplication\n\tBls12381G2AddGas          uint64 = 4500   // Price for BLS12-381 elliptic curve G2 point addition\n\tBls12381G2MulGas          uint64 = 55000  // Price for BLS12-381 elliptic curve G2 point scalar multiplication\n\tBls12381PairingBaseGas    uint64 = 115000 // Base gas price for BLS12-381 elliptic curve pairing check\n\tBls12381PairingPerPairGas uint64 = 23000  // Per-point pair gas price for BLS12-381 elliptic curve pairing check\n\tBls12381MapG1Gas          uint64 = 5500   // Gas price for BLS12-381 mapping field element to G1 operation\n\tBls12381MapG2Gas          uint64 = 110000 // Gas price for BLS12-381 mapping field element to G2 operation\n\n\t// The Refund Quotient is the cap on how much of the used gas can be refunded. Before EIP-3529,\n\t// up to half the consumed gas could be refunded. Redefined as 1/5th in EIP-3529\n\tRefundQuotient        uint64 = 2\n\tRefundQuotientEIP3529 uint64 = 5\n\n\tBlobTxMinDataGasprice            = 1       // Minimum gas price for data blobs\n\tBlobTxDataGaspriceUpdateFraction = 2225652 // Controls the maximum rate of change for data gas price\n)\n\n// Gas discount table for BLS12-381 G1 and G2 multi exponentiation operations\nvar Bls12381MultiExpDiscountTable = [128]uint64{1200, 888, 764, 641, 594, 547, 500, 453, 438, 423, 408, 394, 379, 364, 349, 334, 330, 326, 322, 318, 314, 310, 306, 302, 298, 294, 289, 285, 281, 277, 273, 269, 268, 266, 265, 263, 262, 260, 259, 257, 256, 254, 253, 251, 250, 248, 247, 245, 244, 242, 241, 239, 238, 236, 235, 233, 232, 231, 229, 228, 226, 225, 223, 222, 221, 220, 219, 219, 218, 217, 216, 216, 215, 214, 213, 213, 212, 211, 211, 210, 209, 208, 208, 207, 206, 205, 205, 204, 203, 202, 202, 201, 200, 199, 199, 198, 197, 196, 196, 195, 194, 193, 193, 192, 191, 191, 190, 189, 188, 188, 187, 186, 185, 185, 184, 183, 182, 182, 181, 180, 179, 179, 178, 177, 176, 176, 175, 174}\n\nvar (\n\tDifficultyBoundDivisor = big.NewInt(2048)   // The bound divisor of the difficulty, used in the update calculations.\n\tGenesisDifficulty      = big.NewInt(131072) // Difficulty of the Genesis block.\n\tMinimumDifficulty      = big.NewInt(131072) // The minimum that the difficulty may ever be.\n\tDurationLimit          = big.NewInt(13)     // The decision boundary on the blocktime duration used to determine whether difficulty should go up or not.\n)"
    },
    {
      "filename": "params/protocol_params.go",
      "content": "// Copyright 2015 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the G"
    }
  ]
}