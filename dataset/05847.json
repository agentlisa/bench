{
  "Title": "[M-01] No way to revoke Approval in `DelegateToken.approve` leads to unauthorized calling of `DelegateToken.transferFrom`",
  "Content": "\n<https://github.com/code-423n4/2023-09-delegate/blob/main/src/DelegateToken.sol#L134><br>\n<https://github.com/code-423n4/2023-09-delegate/blob/main/src/DelegateToken.sol#L168><br>\n<https://github.com/code-423n4/2023-09-delegate/blob/main/src/libraries/DelegateTokenStorageHelpers.sol#L149>\n\nThere is no way to revoke the approval which given via `DelegateToken.approve(address,delegateTokenId)`. They can able call the `DelegateToken.transferFrom` even the tokenHolder revoke the permission using the `DelegateToken.setApprovalForAll`.\n\nIf the spender address is approved by the PT token, we can call the `DelegateToken.withdraw`.\n\n### Proof of Concept\n\nAlice is the token Holder.\n\nAlice approves Bob via `DelegateToken.setApprovalForAll(Bob,true)`.\n\nBob approves himself using `DelegateToken.approve(Bob,delegateTokenId)`\n\nAlice revokes the Bob approval by calling `DelegateToken.setApprovalForAll(Bob,false);`\n\nNow Bob can still calls the `DelegateToken.transferFrom(Alice,to,delegateTokenId)` which is subjected to call only by approved address.\n\nThe transfer will be successful.\n\n**Code details**\n\n<https://github.com/code-423n4/2023-09-delegate/blob/main/src/libraries/DelegateTokenStorageHelpers.sol#L143>\n\n```solidity\n\nfunction revertNotApprovedOrOperator(\n        mapping(address account => mapping(address operator => bool enabled)) storage accountOperator,\n        mapping(uint256 delegateTokenId => uint256[3] info) storage delegateTokenInfo,\n        address account,\n        uint256 delegateTokenId\n    ) internal view {\n        if (msg.sender == account || accountOperator[account][msg.sender] || msg.sender == readApproved(delegateTokenInfo, delegateTokenId)) return;\n        revert Errors.NotApproved(msg.sender, delegateTokenId);\n    }\n```\n\nEven after revoking the approval for operator using `setApprovalAll` this `msg.sender == readApproved(delegateTokenInfo, delegateTokenId)` will be true and able to call `transferFrom` function.\n\n**Test function**\n\n```solidity\n\nfunction testFuzzingTransfer721(\n        address from,\n        address to,\n        uint256 underlyingTokenId,\n        bool expiryTypeRelative,\n        uint256 time\n    ) public {\n        vm.assume(from != address(0));\n        vm.assume(from != address(dt));\n\n        (\n            ,\n            /* ExpiryType */\n            uint256 expiry, /* ExpiryValue */\n\n        ) = prepareValidExpiry(expiryTypeRelative, time);\n        mockERC721.mint(address(from), 33);\n\n        vm.startPrank(from);\n        mockERC721.setApprovalForAll(address(dt), true);\n\n        vm.stopPrank();\n        vm.prank(from);\n        dt.setApprovalForAll(address(dt), true);\n        vm.prank(from);\n        uint256 delegateId1 = dt.create(\n            DelegateTokenStructs.DelegateInfo(\n                from,\n                IDelegateRegistry.DelegationType.ERC721,\n                from,\n                0,\n                address(mockERC721),\n                33,\n                \"\",\n                expiry\n            ),\n            SALT + 1\n        );\n\n        vm.prank(address(dt));\n        dt.approve(address(dt), delegateId1);\n\n        vm.prank(from);\n\n        dt.setApprovalForAll(address(dt), false);\n        address tmp = dt.getApproved(delegateId1);\n        console.log(tmp);\n        vm.prank(address(dt));\n        dt.transferFrom(from, address(0x320), delegateId1);\n    }\n```\n\n### Recommended Mitigation Steps\n\nIf token Holder revokes the approval for a operator using `DelegateToken.setApprovalForAll`, revoke the all the approvals(DelegateToken.approve) which is done by the operator.\n\n### Assessed type\n\nAccess Control\n\n**[0xfoobar (Delegate) confirmed and commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/383#issuecomment-1728555248):**\n > Need to double-check, but looks plausible.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/383#issuecomment-1740661652):**\n > In contrast to ERC721, which only allows the owner to changeÂ `approve`<br>\n> [ERC721.sol#L448-L454](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ef3e7771a7e2d9b30234a57f96ee7acf5dddb9ed/contracts/token/ERC721/ERC721.sol#L448-L454)\n> \n> `DT.approve` allows the operator to set themselves as approved, which can technically be undone via a multicall but may not be performed under normal usage.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/383#issuecomment-1742167006):**\n > Leaning towards Medium Severity as the finding requires:\n> - Alice `approvesForAll` Bob\n> - Bob approves self\n> - Alice revokes Bobs `approvalForAll`\n> - Alice doesn't revoke the `_approve` that Bob gave to self\n> \n> Notice that any transfer would reset the approval as well.\n\n**[0xfoobar (Delegate) commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/383#issuecomment-1745837556):**\n > A note about how ERC721 works: there are two different types of approvals. `approve()` lets an account move a single tokenId, while `setApprovalForAll()` marks an address as an operator to move all tokenIds. We can note the difference in the core OpenZeppelin ERC721 base contract, two separate mappings: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L32-L34\n> \n> So plausible that an operator could be permitted to add new tokenid-specific approvals, but see your point that OZ ERC721 doesn't allow this by default and so could lead to confusing states that are possible but not fun to get out of.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-delegate",
  "Code": [
    {
      "filename": "src/DelegateToken.sol",
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.21;\n\nimport {IDelegateToken, IERC721Metadata, IERC721Receiver, IERC1155Receiver} from \"./interfaces/IDelegateToken.sol\";\nimport {MarketMetadata} from \"src/MarketMetadata.sol\";\nimport {PrincipalToken} from \"src/PrincipalToken.sol\";\n\nimport {ReentrancyGuard} from \"openzeppelin/security/ReentrancyGuard.sol\";\n\nimport {IDelegateRegistry, DelegateTokenErrors as Errors, DelegateTokenStructs as Structs, DelegateTokenHelpers as Helpers} from \"src/libraries/DelegateTokenLib.sol\";\nimport {DelegateTokenStorageHelpers as StorageHelpers} from \"src/libraries/DelegateTokenStorageHelpers.sol\";\nimport {DelegateTokenRegistryHelpers as RegistryHelpers, RegistryHashes} from \"src/libraries/DelegateTokenRegistryHelpers.sol\";\nimport {DelegateTokenTransferHelpers as TransferHelpers, SafeERC20, IERC721, IERC20, IERC1155} from \"src/libraries/DelegateTokenTransferHelpers.sol\";\n\ncontract DelegateToken is ReentrancyGuard, IDelegateToken {\n    /*//////////////////////////////////////////////////////////////\n    /                           Immutables                         /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDelegateToken\n    address public immutable override delegateRegistry;\n\n    /// @inheritdoc IDelegateToken\n    address public immutable override principalToken;\n\n    address public immutable marketMetadata;\n\n    /*//////////////////////////////////////////////////////////////\n    /                            Storage                           /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev delegateId, a hash of (msg.sender, salt), points a unique id to the StoragePosition\n    mapping(uint256 delegateTokenId => uint256[3] info) internal delegateTokenInfo;\n\n    /// @notice mapping for ERC721 balances\n    mapping(address delegateTokenHolder => uint256 balance) internal balances;\n\n    /// @notice approve for all mapping\n    mapping(address account => mapping(address operator => bool enabled)) internal accountOperator;\n\n    /// @notice internal variables for Principle Token callbacks\n    Structs.Uint256 internal principalMintAuthorization = Structs.Uint256(StorageHelpers.MINT_NOT_AUTHORIZED);\n    Structs.Uint256 internal principalBurnAuthorization = Structs.Uint256(StorageHelpers.BURN_NOT_AUTHORIZED);\n\n    /// @notice internal variable 11155 callbacks\n    Structs.Uint256 internal erc1155PullAuthorization = Structs.Uint256(TransferHelpers.ERC1155_NOT_PULLED);\n\n    /*//////////////////////////////////////////////////////////////\n    /                      Constructor                             /\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Structs.DelegateTokenParameters memory parameters) {\n        if (parameters.delegateRegistry == address(0)) revert Errors.DelegateRegistryZero();\n        if (parameters.principalToken == address(0)) revert Errors.PrincipalTokenZero();\n        if (parameters.marketMetadata == address(0)) revert Errors.MarketMetadataZero();\n        delegateRegistry = parameters.delegateRegistry;\n        principalToken = parameters.principalToken;\n        marketMetadata = parameters.marketMetadata;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /                    Supported Interfaces                      /\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == 0x2a55205a // ERC165 Interface ID for ERC2981\n            || interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\n            || interfaceId == 0x5b5e139f // ERC165 Interface ID for ERC721Metadata\n            || interfaceId == 0x4e2312e0; // ERC165 Interface ID for ERC1155 Token receiver\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /                    Token Receiver methods                    /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external pure returns (bytes4) {\n        revert Errors.BatchERC1155TransferUnsupported();\n    }\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address operator, address, uint256, bytes calldata) external view returns (bytes4) {\n        if (address(this) == operator) return IERC721Receiver.onERC721Received.selector;\n        revert Errors.InvalidERC721TransferOperator();\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155Received(address operator, address, uint256, uint256, bytes calldata) external returns (bytes4) {\n        TransferHelpers.revertInvalidERC1155PullCheck(erc1155PullAuthorization, operator);\n        return IERC1155Receiver.onERC1155Received.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /                 ERC721 Method Implementations                /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function balanceOf(address delegateTokenHolder) external view returns (uint256) {\n        if (delegateTokenHolder == address(0)) revert Errors.DelegateTokenHolderZero();\n        return balances[delegateTokenHolder];\n    }\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 delegateTokenId) external view returns (address delegateTokenHolder) {\n        delegateTokenHolder = RegistryHelpers.loadTokenHolder(delegateRegistry, StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId));\n        if (delegateTokenHolder == address(0)) revert Errors.DelegateTokenHolderZero();\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 delegateTokenId) external view returns (address) {\n        StorageHelpers.revertNotMinted(delegateTokenInfo, delegateTokenId);\n        return StorageHelpers.readApproved(delegateTokenInfo, delegateTokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address account, address operator) external view returns (bool) {\n        return accountOperator[account][operator];\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 delegateTokenId, bytes calldata data) external {\n        transferFrom(from, to, delegateTokenId);\n        Helpers.revertOnInvalidERC721ReceiverCallback(from, to, delegateTokenId, data);\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 delegateTokenId) external {\n        transferFrom(from, to, delegateTokenId);\n        Helpers.revertOnInvalidERC721ReceiverCallback(from, to, delegateTokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function approve(address spender, uint256 delegateTokenId) external {\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        address delegateTokenHolder = RegistryHelpers.loadTokenHolder(delegateRegistry, registryHash);\n        StorageHelpers.revertNotOperator(accountOperator, delegateTokenHolder);\n        StorageHelpers.writeApproved(delegateTokenInfo, delegateTokenId, spender);\n        emit Approval(delegateTokenHolder, spender, delegateTokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) external {\n        accountOperator[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @inheritdoc IERC721\n    /// @dev should revert if msg.sender does not meet one of the following:\n    ///         - msg.sender is from address\n    ///         - from has approved msg.sender for all\n    ///         - msg.sender is approved for the delegateTokenId\n    /// @dev balances should be incremented / decremented for from / to\n    /// @dev approved for the delegateTokenId should be deleted (reset)\n    /// @dev must emit the ERC721 Transfer(from, to, delegateTokenId) event\n    /// @dev toAmount stored in the related registry delegation must be retrieved directly from registry storage and\n    ///      not via the CheckDelegate method to avoid invariants with \"[specific rights]\" and \"\" classes\n    /// @dev registryHash for the DelegateTokenId must point to the new registry delegation associated with the to\n    /// address\n    function transferFrom(address from, address to, uint256 delegateTokenId) public {\n        if (to == address(0)) revert Errors.ToIsZero();\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        (address delegateTokenHolder, address underlyingContract) = RegistryHelpers.loadTokenHolderAndContract(delegateRegistry, registryHash);\n        if (from != delegateTokenHolder) revert Errors.FromNotDelegateTokenHolder();\n        // We can use `from` here instead of delegateTokenHolder since we've just verified that from == delegateTokenHolder\n        StorageHelpers.revertNotApprovedOrOperator(accountOperator, delegateTokenInfo, from, delegateTokenId);\n        StorageHelpers.incrementBalance(balances, to);\n        StorageHelpers.decrementBalance(balances, from);\n        StorageHelpers.writeApproved(delegateTokenInfo, delegateTokenId, address(0));\n        emit Transfer(from, to, delegateTokenId);\n        IDelegateRegistry.DelegationType underlyingType = RegistryHashes.decodeType(registryHash);\n        bytes32 underlyingRights = RegistryHelpers.loadRights(delegateRegistry, registryHash);\n        bytes32 newRegistryHash = 0;\n        if (underlyingType == IDelegateRegistry.DelegationType.ERC721) {\n            uint256 underlyingTokenId = RegistryHelpers.loadTokenId(delegateRegistry, registryHash);\n            newRegistryHash = RegistryHashes.erc721Hash(address(this), underlyingRights, to, underlyingTokenId, underlyingContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.transferERC721(delegateRegistry, registryHash, from, newRegistryHash, to, underlyingRights, underlyingContract, underlyingTokenId);\n        } else if (underlyingType == IDelegateRegistry.DelegationType.ERC20) {\n            newRegistryHash = RegistryHashes.erc20Hash(address(this), underlyingRights, to, underlyingContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.transferERC20(\n                delegateRegistry,\n                registryHash,\n                from,\n                newRegistryHash,\n                to,\n                StorageHelpers.readUnderlyingAmount(delegateTokenInfo, delegateTokenId),\n                underlyingRights,\n                underlyingContract\n            );\n        } else if (underlyingType == IDelegateRegistry.DelegationType.ERC1155) {\n            uint256 underlyingTokenId = RegistryHelpers.loadTokenId(delegateRegistry, registryHash);\n            newRegistryHash = RegistryHashes.erc1155Hash(address(this), underlyingRights, to, underlyingTokenId, underlyingContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.transferERC1155(\n                delegateRegistry,\n                registryHash,\n                from,\n                newRegistryHash,\n                to,\n                StorageHelpers.readUnderlyingAmount(delegateTokenInfo, delegateTokenId),\n                underlyingRights,\n                underlyingContract,\n                underlyingTokenId\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /                EXTENDED ERC721 METHODS                       /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Metadata\n    function name() external pure returns (string memory) {\n        return \"Delegate Token\";\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function symbol() external pure returns (string memory) {\n        return \"DT\";\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 delegateTokenId) external view returns (string memory) {\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        return MarketMetadata(marketMetadata).delegateTokenURI(\n            RegistryHelpers.loadContract(delegateRegistry, registryHash),\n            RegistryHelpers.loadTokenId(delegateRegistry, registryHash),\n            StorageHelpers.readExpiry(delegateTokenInfo, delegateTokenId),\n            IERC721(principalToken).ownerOf(delegateTokenId)\n        );\n    }\n\n    /// @inheritdoc IDelegateToken\n    function isApprovedOrOwner(address spender, uint256 delegateTokenId) external view returns (bool) {\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        address delegateTokenHolder = RegistryHelpers.loadTokenHolder(delegateRegistry, registryHash);\n        return spender == delegateTokenHolder || accountOperator[delegateTokenHolder][spender] || StorageHelpers.readApproved(delegateTokenInfo, delegateTokenId) == spender;\n    }\n\n    /// @inheritdoc IDelegateToken\n    function baseURI() external view returns (string memory) {\n        return MarketMetadata(marketMetadata).delegateTokenBaseURI();\n    }\n\n    /// @inheritdoc IDelegateToken\n    function contractURI() external view returns (string memory) {\n        return MarketMetadata(marketMetadata).delegateTokenContractURI();\n    }\n\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount) {\n        (receiver, royaltyAmount) = MarketMetadata(marketMetadata).royaltyInfo(tokenId, salePrice);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /            LIQUID DELEGATE TOKEN METHODS                     /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDelegateToken\n    function getDelegateInfo(uint256 delegateTokenId) external view returns (Structs.DelegateInfo memory delegateInfo) {\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        delegateInfo.tokenType = RegistryHashes.decodeType(registryHash);\n        (delegateInfo.delegateHolder, delegateInfo.tokenContract) = RegistryHelpers.loadTokenHolderAndContract(delegateRegistry, registryHash);\n        delegateInfo.rights = RegistryHelpers.loadRights(delegateRegistry, registryHash);\n        delegateInfo.principalHolder = IERC721(principalToken).ownerOf(delegateTokenId);\n        delegateInfo.expiry = StorageHelpers.readExpiry(delegateTokenInfo, delegateTokenId);\n        if (delegateInfo.tokenType == IDelegateRegistry.DelegationType.ERC20) delegateInfo.tokenId = 0;\n        else delegateInfo.tokenId = RegistryHelpers.loadTokenId(delegateRegistry, registryHash);\n        if (delegateInfo.tokenType == IDelegateRegistry.DelegationType.ERC721) delegateInfo.amount = 0;\n        else delegateInfo.amount = StorageHelpers.readUnderlyingAmount(delegateTokenInfo, delegateTokenId);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function getDelegateId(address caller, uint256 salt) external view returns (uint256 delegateTokenId) {\n        delegateTokenId = Helpers.delegateIdNoRevert(caller, salt);\n        StorageHelpers.revertAlreadyExisted(delegateTokenInfo, delegateTokenId);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function burnAuthorizedCallback() external view {\n        StorageHelpers.checkBurnAuthorized(principalToken, principalBurnAuthorization);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function mintAuthorizedCallback() external view {\n        StorageHelpers.checkMintAuthorized(principalToken, principalMintAuthorization);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function create(Structs.DelegateInfo calldata delegateInfo, uint256 salt) external nonReentrant returns (uint256 delegateTokenId) {\n        TransferHelpers.checkAndPullByType(erc1155PullAuthorization, delegateInfo);\n        Helpers.revertOldExpiry(delegateInfo.expiry);\n        if (delegateInfo.delegateHolder == address(0)) revert Errors.ToIsZero();\n        delegateTokenId = Helpers.delegateIdNoRevert(msg.sender, salt);\n        StorageHelpers.revertAlreadyExisted(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.incrementBalance(balances, delegateInfo.delegateHolder);\n        StorageHelpers.writeExpiry(delegateTokenInfo, delegateTokenId, delegateInfo.expiry);\n        emit Transfer(address(0), delegateInfo.delegateHolder, delegateTokenId);\n        bytes32 newRegistryHash = 0;\n        if (delegateInfo.tokenType == IDelegateRegistry.DelegationType.ERC721) {\n            newRegistryHash = RegistryHashes.erc721Hash(address(this), delegateInfo.rights, delegateInfo.delegateHolder, delegateInfo.tokenId, delegateInfo.tokenContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.delegateERC721(delegateRegistry, newRegistryHash, delegateInfo);\n        } else if (delegateInfo.tokenType == IDelegateRegistry.DelegationType.ERC20) {\n            StorageHelpers.writeUnderlyingAmount(delegateTokenInfo, delegateTokenId, delegateInfo.amount);\n            newRegistryHash = RegistryHashes.erc20Hash(address(this), delegateInfo.rights, delegateInfo.delegateHolder, delegateInfo.tokenContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.incrementERC20(delegateRegistry, newRegistryHash, delegateInfo);\n        } else if (delegateInfo.tokenType == IDelegateRegistry.DelegationType.ERC1155) {\n            StorageHelpers.writeUnderlyingAmount(delegateTokenInfo, delegateTokenId, delegateInfo.amount);\n            newRegistryHash = RegistryHashes.erc1155Hash(address(this), delegateInfo.rights, delegateInfo.delegateHolder, delegateInfo.tokenId, delegateInfo.tokenContract);\n            StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, newRegistryHash);\n            RegistryHelpers.incrementERC1155(delegateRegistry, newRegistryHash, delegateInfo);\n        }\n        StorageHelpers.mintPrincipal(principalToken, principalMintAuthorization, delegateInfo.principalHolder, delegateTokenId);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function extend(uint256 delegateTokenId, uint256 newExpiry) external {\n        StorageHelpers.revertNotMinted(delegateTokenInfo, delegateTokenId);\n        Helpers.revertOldExpiry(newExpiry);\n        uint256 previousExpiry = StorageHelpers.readExpiry(delegateTokenInfo, delegateTokenId);\n        if (newExpiry <= previousExpiry) revert Errors.ExpiryTooSmall();\n        if (PrincipalToken(principalToken).isApprovedOrOwner(msg.sender, delegateTokenId)) {\n            StorageHelpers.writeExpiry(delegateTokenInfo, delegateTokenId, newExpiry);\n            emit ExpiryExtended(delegateTokenId, previousExpiry, newExpiry);\n            return;\n        }\n        revert Errors.NotApproved(msg.sender, delegateTokenId);\n    }\n\n    /// @inheritdoc IDelegateToken\n    function rescind(uint256 delegateTokenId) external {\n        //slither-disable-next-line timestamp\n        if (StorageHelpers.readExpiry(delegateTokenInfo, delegateTokenId) < block.timestamp) {\n            StorageHelpers.writeApproved(delegateTokenInfo, delegateTokenId, msg.sender);\n            // approve gets reset in transferFrom or this write gets undone if this function call reverts\n        }\n        transferFrom(\n            RegistryHelpers.loadTokenHolder(delegateRegistry, StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId)),\n            IERC721(principalToken).ownerOf(delegateTokenId),\n            delegateTokenId\n        );\n    }\n\n    /// @inheritdoc IDelegateToken\n    function withdraw(uint256 delegateTokenId) external nonReentrant {\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.writeRegistryHash(delegateTokenInfo, delegateTokenId, bytes32(StorageHelpers.ID_USED));\n        // Sets registry pointer to used flag\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        (address delegateTokenHolder, address underlyingContract) = RegistryHelpers.loadTokenHolderAndContract(delegateRegistry, registryHash);\n        StorageHelpers.revertInvalidWithdrawalConditions(delegateTokenInfo, accountOperator, delegateTokenId, delegateTokenHolder);\n        StorageHelpers.decrementBalance(balances, delegateTokenHolder);\n        delete delegateTokenInfo[delegateTokenId][StorageHelpers.PACKED_INFO_POSITION]; // Deletes both expiry and approved\n        emit Transfer(delegateTokenHolder, address(0), delegateTokenId);\n        IDelegateRegistry.DelegationType delegationType = RegistryHashes.decodeType(registryHash);\n        bytes32 underlyingRights = RegistryHelpers.loadRights(delegateRegistry, registryHash);\n        if (delegationType == IDelegateRegistry.DelegationType.ERC721) {\n            uint256 erc721UnderlyingTokenId = RegistryHelpers.loadTokenId(delegateRegistry, registryHash);\n            RegistryHelpers.revokeERC721(delegateRegistry, registryHash, delegateTokenHolder, underlyingContract, erc721UnderlyingTokenId, underlyingRights);\n            StorageHelpers.burnPrincipal(principalToken, principalBurnAuthorization, delegateTokenId);\n            IERC721(underlyingContract).transferFrom(address(this), msg.sender, erc721UnderlyingTokenId);\n        } else if (delegationType == IDelegateRegistry.DelegationType.ERC20) {\n            uint256 erc20UnderlyingAmount = StorageHelpers.readUnderlyingAmount(delegateTokenInfo, delegateTokenId);\n            StorageHelpers.writeUnderlyingAmount(delegateTokenInfo, delegateTokenId, 0); // Deletes amount\n            RegistryHelpers.decrementERC20(delegateRegistry, registryHash, delegateTokenHolder, underlyingContract, erc20UnderlyingAmount, underlyingRights);\n            StorageHelpers.burnPrincipal(principalToken, principalBurnAuthorization, delegateTokenId);\n            SafeERC20.safeTransfer(IERC20(underlyingContract), msg.sender, erc20UnderlyingAmount);\n        } else if (delegationType == IDelegateRegistry.DelegationType.ERC1155) {\n            uint256 erc1155UnderlyingAmount = StorageHelpers.readUnderlyingAmount(delegateTokenInfo, delegateTokenId);\n            StorageHelpers.writeUnderlyingAmount(delegateTokenInfo, delegateTokenId, 0); // Deletes amount\n            uint256 erc11551UnderlyingTokenId = RegistryHelpers.loadTokenId(delegateRegistry, registryHash);\n            RegistryHelpers.decrementERC1155(\n                delegateRegistry, registryHash, delegateTokenHolder, underlyingContract, erc11551UnderlyingTokenId, erc1155UnderlyingAmount, underlyingRights\n            );\n            StorageHelpers.burnPrincipal(principalToken, principalBurnAuthorization, delegateTokenId);\n            IERC1155(underlyingContract).safeTransferFrom(address(this), msg.sender, erc11551UnderlyingTokenId, erc1155UnderlyingAmount, \"\");\n        }\n    }\n\n    /// @inheritdoc IDelegateToken\n    function flashloan(Structs.FlashInfo calldata info) external payable nonReentrant {\n        StorageHelpers.revertNotOperator(accountOperator, info.delegateHolder);\n        if (info.tokenType == IDelegateRegistry.DelegationType.ERC721) {\n            RegistryHelpers.revertERC721FlashUnavailable(delegateRegistry, info);\n            IERC721(info.tokenContract).transferFrom(address(this), info.receiver, info.tokenId);\n            Helpers.revertOnCallingInvalidFlashloan(info);\n            TransferHelpers.checkERC721BeforePull(info.amount, info.tokenContract, info.tokenId);\n            TransferHelpers.pullERC721AfterCheck(info.tokenContract, info.tokenId);\n        } else if (info.tokenType == IDelegateRegistry.DelegationType.ERC20) {\n            RegistryHelpers.revertERC20FlashAmountUnavailable(delegateRegistry, info);\n            SafeERC20.safeTransfer(IERC20(info.tokenContract), info.receiver, info.amount);\n            Helpers.revertOnCallingInvalidFlashloan(info);\n            TransferHelpers.checkERC20BeforePull(info.amount, info.tokenContract, info.tokenId);\n            TransferHelpers.pullERC20AfterCheck(info.tokenContract, info.amount);\n        } else if (info.tokenType == IDelegateRegistry.DelegationType.ERC1155) {\n            RegistryHelpers.revertERC1155FlashAmountUnavailable(delegateRegistry, info);\n            TransferHelpers.checkERC1155BeforePull(erc1155PullAuthorization, info.amount);\n            IERC1155(info.tokenContract).safeTransferFrom(address(this), info.receiver, info.tokenId, info.amount, \"\");\n            Helpers.revertOnCallingInvalidFlashloan(info);\n            TransferHelpers.pullERC1155AfterCheck(erc1155PullAuthorization, info.amount, info.tokenContract, info.tokenId);\n        }\n    }\n}"
    },
    {
      "filename": "src/DelegateToken.sol",
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.21;\n\nimport {IDelegateToken, IERC721Metadata, IERC721Receiver, IERC1155Receiver} from \"./interfaces/IDelegateToken.sol\";\nimport {MarketMetadata} from \"src/MarketMetadata.sol\";\nimport {PrincipalToken} from \"src/PrincipalToken.sol\";\n\nimport {ReentrancyGuard} from \"openzeppelin/security/ReentrancyGuard.sol\";\n\nimport {IDelegateRegistry, DelegateTokenErrors as Errors, DelegateTokenStructs as Structs, DelegateTokenHelpers as Helpers} from \"src/libraries/DelegateTokenLib.sol\";\nimport {DelegateTokenStorageHelpers as StorageHelpers} from \"src/libraries/DelegateTokenStorageHelpers.sol\";\nimport {DelegateTokenRegistryHelpers as RegistryHelpers, RegistryHashes} from \"src/libraries/DelegateTokenRegistryHelpers.sol\";\nimport {DelegateTokenTransferHelpers as TransferHelpers, SafeERC20, IERC721, IERC20, IERC1155} from \"src/libraries/DelegateTokenTransferHelpers.sol\";\n\ncontract DelegateToken is ReentrancyGuard, IDelegateToken {\n    /*//////////////////////////////////////////////////////////////\n    /                           Immutables                         /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IDelegateToken\n    address public immutable override delegateRegistry;\n\n    /// @inheritdoc IDelegateToken\n    address public immutable override principalToken;\n\n    address public immutable marketMetadata;\n\n    /*//////////////////////////////////////////////////////////////\n    /                            Storage                           /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev delegateId, a hash of (msg.sender, salt), points a unique id to the StoragePosition\n    mapping(uint256 delegateTokenId => uint256[3] info) internal delegateTokenInfo;\n\n    /// @notice mapping for ERC721 balances\n    mapping(address delegateTokenHolder => uint256 balance) internal balances;\n\n    /// @notice approve for all mapping\n    mapping(address account => mapping(address operator => bool enabled)) internal accountOperator;\n\n    /// @notice internal variables for Principle Token callbacks\n    Structs.Uint256 internal principalMintAuthorization = Structs.Uint256(StorageHelpers.MINT_NOT_AUTHORIZED);\n    Structs.Uint256 internal principalBurnAuthorization = Structs.Uint256(StorageHelpers.BURN_NOT_AUTHORIZED);\n\n    /// @notice internal variable 11155 callbacks\n    Structs.Uint256 internal erc1155PullAuthorization = Structs.Uint256(TransferHelpers.ERC1155_NOT_PULLED);\n\n    /*//////////////////////////////////////////////////////////////\n    /                      Constructor                             /\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Structs.DelegateTokenParameters memory parameters) {\n        if (parameters.delegateRegistry == address(0)) revert Errors.DelegateRegistryZero();\n        if (parameters.principalToken == address(0)) revert Errors.PrincipalTokenZero();\n        if (parameters.marketMetadata == address(0)) revert Errors.MarketMetadataZero();\n        delegateRegistry = parameters.delegateRegistry;\n        principalToken = parameters.principalToken;\n        marketMetadata = parameters.marketMetadata;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /                    Supported Interfaces                      /\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == 0x2a55205a // ERC165 Interface ID for ERC2981\n            || interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\n            || interfaceId == 0x5b5e139f // ERC165 Interface ID for ERC721Metadata\n            || interfaceId == 0x4e2312e0; // ERC165 Interface ID for ERC1155 Token receiver\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /                    Token Receiver methods                    /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external pure returns (bytes4) {\n        revert Errors.BatchERC1155TransferUnsupported();\n    }\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address operator, address, uint256, bytes calldata) external view returns (bytes4) {\n        if (address(this) == operator) return IERC721Receiver.onERC721Received.selector;\n        revert Errors.InvalidERC721TransferOperator();\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155Received(address operator, address, uint256, uint256, bytes calldata) external returns (bytes4) {\n        TransferHelpers.revertInvalidERC1155PullCheck(erc1155PullAuthorization, operator);\n        return IERC1155Receiver.onERC1155Received.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n    /                 ERC721 Method Implementations                /\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function balanceOf(address delegateTokenHolder) external view returns (uint256) {\n        if (delegateTokenHolder == address(0)) revert Errors.DelegateTokenHolderZero();\n        return balances[delegateTokenHolder];\n    }\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 delegateTokenId) external view returns (address delegateTokenHolder) {\n        delegateTokenHolder = RegistryHelpers.loadTokenHolder(delegateRegistry, StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId));\n        if (delegateTokenHolder == address(0)) revert Errors.DelegateTokenHolderZero();\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 delegateTokenId) external view returns (address) {\n        StorageHelpers.revertNotMinted(delegateTokenInfo, delegateTokenId);\n        return StorageHelpers.readApproved(delegateTokenInfo, delegateTokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address account, address operator) external view returns (bool) {\n        return accountOperator[account][operator];\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 delegateTokenId, bytes calldata data) external {\n        transferFrom(from, to, delegateTokenId);\n        Helpers.revertOnInvalidERC721ReceiverCallback(from, to, delegateTokenId, data);\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 delegateTokenId) external {\n        transferFrom(from, to, delegateTokenId);\n        Helpers.revertOnInvalidERC721ReceiverCallback(from, to, delegateTokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function approve(address spender, uint256 delegateTokenId) external {\n        bytes32 registryHash = StorageHelpers.readRegistryHash(delegateTokenInfo, delegateTokenId);\n        StorageHelpers.revertNotMinted(registryHash, delegateTokenId);\n        address delegateTokenHolder = RegistryHelpers.loadTokenHolder(delegateRegistry, registryHash);\n        StorageHelpers.revertNotOperator(accountOperator, delegateTokenHolder);\n        StorageHelpers.writeApproved(delegateTokenInfo, delegateTokenId, spender);\n        emit Approval(delegateTokenHolder, spender,"
    }
  ]
}