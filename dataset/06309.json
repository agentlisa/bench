{
  "Title": "[M-03] LSP8 and LSP9's `ERC-165` interface ID differs from their specification",
  "Content": "\nAccording to [LSP7's specification](https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-7-DigitalAsset.md#specification), the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID for LSP7 token contracts should be `0x5fcaac27`:\n\n> ERC165 interface id: `0x5fcaac27`\n\nHowever, `_INTERFACEID_LSP7` has a different value in the code:\n\n[LSP7Constants.sol#L4-L5](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP7DigitalAsset/LSP7Constants.sol#L4-L5)\n\n```solidity\n// --- ERC165 interface ids\nbytes4 constant _INTERFACEID_LSP7 = 0xda1f85e4;\n```\n\nSimilarly, LSP8's interface ID should be `0x49399145` according to [LSP8's specification](https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-8-IdentifiableDigitalAsset.md#specification):\n\n> ERC165 interface id: `0x49399145`\n\nHowever, `_INTERFACEID_LSP8` has a different value in the code:\n\n[LSP8Constants.sol#L4-L5](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/LSP8Constants.sol#L4-L5)\n\n```solidity\n// --- ERC165 interface ids\nbytes4 constant _INTERFACEID_LSP8 = 0x622e7a01;\n```\n\nThese constants are used in `supportsInterface()` for the `LSP7DigitalAsset` and `LSP8IdentifiableDigitalAsset` contracts.\n\n### Impact\n\nProtocols that check for LSP7/LSP8 compatibility using the `ERC-165` interface IDs declared in the specification will receive incorrect return values when calling `supportsInterface()`.\n\n### Recommended Mitigation\n\nEnsure that the interface ID declared in the code matches their respective ones in their specifications.\n\n### Assessed type\n\nError\n\n**[CJ42 (LUKSO) disputed and commented via duplicate issue #101](https://github.com/code-423n4/2023-06-lukso-findings/issues/101#issuecomment-1649836277):**\n> The bytes4 interface ID is correct according to the specs.\n\n**[CJ42 (LUKSO) responded via private discord communication in regards to their previous comment above](https://github.com/code-423n4/2023-06-lukso-findings/issues/101#issuecomment-1649836277):**\n> The interface IDs for LSP7 + LSP8 are correct in terms of they represent correctly the XOR of all the function selectors of ILSP7 and ILSP8. So they are correct according to the Solidity code.\n> It’s in the LIP specs that there was an error (had not been updated and forgotten in a previous PR).\n> We fixed it in the LIP specs document. Reference this [PR](https://github.com/lukso-network/LIPs/pull/226).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "LSPs/LSP-7-DigitalAsset.md",
      "content": "---\nlip: 7\ntitle: Digital Asset\nauthor: Fabian Vogelsteller <fabian@lukso.network>, Claudio Weck <claudio@fanzone.media>, Matthew Stevens <@mattgstevens>, Ankit Kumar <@ankitkumar9018>\ndiscussions-to: https://discord.gg/E2rJPP4 (LUKSO), https://discord.gg/PQvJQtCV (FANZONE)\nstatus: Review\ntype: LSP\ncreated: 2021-09-02\nrequires: ERC165, ERC173, ERC725Y, LSP1, LSP2, LSP4, LSP17\n---\n\n<!--You can leave these HTML comments in your merged LIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new LIPs. Note that an LIP number will be assigned by an editor. When opening a pull request to submit your LIP, please use an abbreviated title in the filename, `lip-draft_title_abbrev.md`. The title should be 44 characters or less.-->\n\n## Simple Summary\n\n<!--\"If you can't explain it simply, you don't understand it well enough.\" Provide a simplified and layman-accessible explanation of the LIP.-->\n\nA standard interface for digital assets, for either fungible or non-fungible tokens.\n\n## Abstract\n\n<!--A short (~200 word) description of the technical issue being addressed.-->\n\nThis standard defines a digital asset standard that can represent either fungible tokens or non-fungible tokens (NFTs).\n\nKey functionalities of this asset standard include:\n\n- **Dynamic Information Attachment**: Leverages [ERC725Y] to add generic information to the asset even post-deployment according to the LSP4-DigitalAssetMetadata standard.\n\n- **Secure Transfers**: By checking whether the recipient is capable of handling the asset before the actual transfer, it avoids loss and transfer of tokens to uncontrolled addresses.\n\n- **Transfer Interaction**: Notifies the operator, sender, and the recipient about the transfer, allowing users to be informed about the incoming asset and decide how to react accordingly (e.g., denying the token, forwarding it, etc.).\n\n- **Future-Proof Functionalities**: Through [LSP17-ContractExtension], allows the asset to be extended and support new standardized functions and interface IDs over time.\n\n- **Asset Flexibility and Discoverability**: Offers several flexible features, such as batch transfers and the ability to add several operators, as well as the ability to discover them.\n\n## Motivation\n\n<!--The motivation is critical for LIPs that want to change the Lukso protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the LIP solves. LIP submissions without sufficient motivation may be rejected outright.-->\n\nThe motivation for developing this new digital asset standard can be organized into several key points, each showing a specific limitation of current token standards:\n\n- **Limited Asset Metadata**: Current token standards offer limited metadata attachment capabilities, typically confined to basic elements like `name`, `symbol`, and `tokenURI`. This limitation is particularly restrictive for assets that require verifiable, on-chain metadata – such as details about creators, the community behind the token, or dynamic attributes that allow an NFT to evolve.\n\n- **No Interaction and Notification**: Traditional token standards lack in terms of interaction, particularly in notifying recipients about transfers. As a result, users cannot be unaware of incoming tokens and lose the opportunity to respond, for example, react to transfers, whether to deny, accept, or forward the tokens.\n\n- **Limited Functionalities**: Many tokens are confined to the functionalities they possess at deployment, making them rigid and unable to adapt to new requirements or standards.\n\n- **Risk of asset loss**: A common issue with current assets is the risk of loss due to transfers to incorrect or uncontrolled addresses as these standards does not check whether the recipient is able to handle the asset or not.\n\n- **Limited Features**: The limitation of having only one operator and the absence of batch transfer capabilities or even the discoveribility of tokens a user own restricts and provide bad user experience. Users need to rely on centralized indexers to know which tokens they own, need to do several transactions to do a batch of transfers, and cannot have more than one operator.\n\n## Specification\n\n[ERC165] interface id: `0xc52d6008`\n\nThe LSP7 interface ID is calculated as the XOR of the LSP7 interface (see [interface cheat-sheet below](#interface-cheat-sheet)) and the [LSP17 Extendable interface ID](./LSP-17-ContractExtension.md#erc165-interface-id).\n\n### Methods\n\n#### decimals\n\n```solidity\nfunction decimals() external view returns (uint8);\n```\n\nReturns the number of decimals used to get its user representation.\n\nIf the token is non-divisible then `0` SHOULD be used, otherwise `18` is the common value.\n\n**Returns:** `uint8` the number of decimals to tranfrom a token value when displaying.\n\n#### totalSupply\n\n```solidity\nfunction totalSupply() external view returns (uint256);\n```\n\nReturns the number of existing tokens.\n\n**Returns:** `uint256` the number of existing tokens.\n\n#### balanceOf\n\n```solidity\nfunction balanceOf(address tokenOwner) external view returns (uint256);\n```\n\nReturns the number of tokens owned by `tokenOwner`.\n\n_Parameters:_\n\n- `tokenOwner` the address to query.\n\n**Returns:** `uint256` the number of tokens owned by this address.\n\n#### authorizeOperator\n\n```solidity\nfunction authorizeOperator(address operator, uint256 amount, bytes memory operatorNotificationData) external;\n```\n\nSets `amount` as the amount of tokens `operator` address has access to from callers tokens.\n\nTo increase or decrease the authorized amount of an operator, it's advised to call `increaseAllowance(..)`/`decreaseAllowance(..)` function with the added/subtracted amount, to avoid front-running through an allowance double-spend exploit.\nCheck more information [in this document](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/).\n\nMUST emit an [OperatorAuthorizationChanged event](#OperatorAuthorizationChanged).\n\n_Parameters:_\n\n- `operator` the address to authorize as an operator.\n- `amount` the amount of tokens operator has access to.\n- `operatorNotificationData` the data to send when notifying the operator via LSP1.\n\n_Requirements:_\n\n- `operator` cannot be the caller's address.\n- `operator` cannot be the zero address.\n\n**LSP1 Hooks:**\n\n- If the operator is a contract that supports LSP1 interface, it SHOULD call operator's [`universalReceiver(...)`] function with the parameters below:\n\n  - `typeId`: `keccak256('LSP7Tokens_OperatorNotification')` > `0x386072cc5a58e61263b434c722725f21031cd06e7c552cfaa06db5de8a320dbc`\n  - `data`: The data sent SHOULD be ABI encoded and contain the `tokenOwner` (address), `amount` (uint256) , and the `operatorNotificationData` (bytes) respectively.\n\n<br>\n\n#### revokeOperator\n\n```solidity\nfunction revokeOperator(address operator, address tokenOwner, bool notify, bytes memory operatorNotificationData) external;\n```\n\nRemoves `operator` address as an operator of callers tokens.\n\nMUST emit a [OperatorRevoked event](#OperatorRevoked).\n\n_Parameters:_\n\n- `operator` the address to revoke as an operator.\n- `tokenOwner` the address of the token owner to be revoked from as an operator.\n- `notify` the boolean indicating whether to notify the operator via LSP1 or not.\n- `operatorNotificationData` the data to send when notifying the operator via LSP1.\n\n_Requirements:_\n\n- `operator` cannot be the zero address.\n\n**LSP1 Hooks:**\n\n- If the `notify` parameter is set to `true`, and the operator is a contract that supports LSP1 interface, it SHOULD call operator's [`universalReceiver(...)`] function with the parameters below:\n\n  - `typeId`: `keccak256('LSP7Tokens_OperatorNotification')` > `0x386072cc5a58e61263b434c722725f21031cd06e7c552cfaa06db5de8a320dbc`\n  - `data`: The data sent SHOULD be ABI encoded and contain the `tokenOwner` (address), `amount` (uint256) (0 in case of revoke), and the `operatorNotificationData` (bytes) respectively.\n\n<br>\n\n#### increaseAllowance\n\n```solidity\nfunction increaseAllowance(address operator, uint256 addedAmount, bytes memory operatorNotificationData) external;\n```\n\nIncrease the allowance of `operator` by `addedAmount`. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard.\n\n_Parameters:_\n\n- `operator` the address to increase allowance as an operator.\n- `addedAmount` the amount to add to the existing allowance of tokens operator has access to.\n- `operatorNotificationData` the data to send when notifying the operator via LSP1.\n\n_Requirements:_\n\n- `operator`'s original allowance cannot be zero.\n- `operator` cannot be the zero address.\n- `operator` cannot be the caller's address.\n\n**LSP1 Hooks:**\n\n- If the operator is a contract that supports LSP1 interface, it SHOULD call operator's [`universalReceiver(...)`] function with the parameters below:\n\n  - `typeId`: `keccak256('LSP7Tokens_OperatorNotification')` > `0x386072cc5a58e61263b434c722725f21031cd06e7c552cfaa06db5de8a320dbc`\n  - `data`: The data sent SHOULD be ABI encoded and contain the `tokenOwner` (address), `amount` (uint256) (new allowance) , and the `operatorNotificationData` (bytes) respectively.\n\n<be>\n\n#### decreaseAllowance\n\n```solidity\nfunction decreaseAllowance(address operator, address tokenOwner, uint256 subtractedAmount, bytes memory operatorNotificationData) external;\n```\n\nDecrease the allowance of `operator` by `subtractedAmount`. This is an alternative approach to {authorizeOperator} that can be used as a mitigation for the double spending allowance problem. Notify the operator based on the LSP1-UniversalReceiver standard.\n\n_Parameters:_\n\n- `operator` the address to decrease allowance as an operator.\n- `tokenOwner` the address of the token owner to decrease allowance from as an operator.\n- `subtractedAmount` the amount to substract to the existing allowance of tokens operator has access to.\n- `operatorNotificationData` the data to send when notifying the operator via LSP1.\n\n_Requirements:_\n\n- `subtractedAmount` must be less than the `operator`'s current allowance.\n- `operator` cannot be the zero address.\n\n**LSP1 Hooks:**\n\n- If the operator is a contract that supports LSP1 interface, it SHOULD call operator's [`universalReceiver(...)`] function with the parameters below:\n\n  - `typeId`: `keccak256('LSP7Tokens_OperatorNotification')` > `0x386072cc5a58e61263b434c722725f21031cd06e7c552cfaa06db5de8a320dbc`\n  - `data`: The data sent SHOULD be ABI encoded and contain the `tokenOwner` (address), `amount` (uint256) (new allowance) , and the `operatorNotificationData` (bytes) respectively.\n\n<br>\n\n#### authorizedAmountFor\n\n```solidity\nfunction authorizedAmountFor(address operator, address tokenOwner) external view returns (uint256);\n```\n\nReturns amount of tokens `operator` address is authorized to spent from `tokenOwner`.\nOperators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.\n\n_Parameters:_\n\n- `operator` the address to query operator status for.\n- `tokenOwner` the address whose operator's allowance is being queried for.\n\n**Returns:** `uint256`, the amount of tokens `operator` has access to from `tokenOwner`.\n\n### getOperatorsOf\n\n```solidity\nfunction getOperatorsOf(address tokenOwner) external view returns (address[] memory);\n```\n\nReturns a list of operators allowed to transfer tokens on behalf of a `tokenOwner` from its balance. Their balance can be queried via [`authorizedAmountFor(address,address)`](#authorizedamountfor)\n\n_Parameters:_\n\n- `tokenOwner` the address to query the list of operators for.\n\n**Returns:** `address[]`, a list of token `operator`s for `tokenOwner`.\n\n#### transfer\n\n```solidity\nfunction transfer(address from, address to, uint256 amount, bool force, bytes memory data) external;\n```\n\nTransfers `amount` of tokens from `from` to `to`. The `force` parameter will be used when notifying the token sender and receiver and revert.\n\nMUST emit a [Transfer event](#transfer) when transfer was successful.\nMUST emit a [OperatorAuthorizationChanged](#operatorauthorizationchanged) or [OperatorRevoked](#operatorrevoked) when the transfer is done by an operator and his allowance was changed.\n\n_Parameters:_\n\n- `from` the sending address.\n- `to` the receiving address.\n- `amount` the amount of tokens to transfer.\n- `force` when set to TRUE, `to` may be any address; when set to FALSE `to` must be a contract that supports [LSP1 UniversalReceiver][LSP1] and not revert.\n- `data` additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.\n\n_Requirements:_\n\n- `from` cannot be the zero address.\n- `to` cannot be the zero address.\n- `amount` tokens must be owned by `from`.\n- If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens.\n\n**LSP1 Hooks:**\n\n- If the token **sender** is a contract that supports LSP1 interface, it SHOULD call the token sender's [`universalReceiver(...)`] function with the parameters below:\n\n  - `typeId`: keccak256('LSP7Tokens_SenderNotification') > `0x429ac7a06903dbc9c13dfcb3c9d11df8194581fa047c96d7a4171fc7402958ea`\n  - `data`: The data sent SHOULD be ABI encoded and contain the `caller` (address), `sender` (address), `receiver` (address), `amount` (uint256) and the `data` (bytes) respectively.\n\n<br>\n\n- If the token **recipient** is a contract that supports LSP1 interface, it SHOULD call the token recipient's [`universalReceiver(...)`] function with the parameters below:\n\n  - `typeId`: keccak256('LSP7Tokens_RecipientNotification') >`0x20804611b3e2ea21c480dc465142210acf4a2485947541770ec1fb87dee4a55c`\n  - `data`: The data sent SHOULD be ABI encoded and contain the `caller` (address), `sender` (address), `receiver` (address), `amount` (uint256) and the `data` (bytes) respectively.\n\n**Note:** LSP1 Hooks MUST be implemented in any type of token transfer (mint, transfer, burn, transferBatch).\n\n#### transferBatch\n\n```solidity\nfunction transferBatch(address[] memory from, address[] memory to, uint256[] memory amount, bool[] memory force, bytes[] memory data) external;\n```\n\nTransfers many tokens based on the list `from`, `to`, `amount`. If any transfer fails, the call will revert.\n\nMUST emit a [Transfer event](#transfer) for each transfered token.\nMUST emit a [OperatorAuthorizationChanged](#operatorauthorizationchanged) or [OperatorRevoked](#operatorrevoked) when the transfer is done by an operator and his allowance was changed for each transfered token.\n\n_Parameters:_\n\n- `from` the list of sending addresses.\n- `to` the list of receiving addresses.\n- `amount` the amount of tokens to transfer.\n- `force` when set to TRUE, `to` may be any address; when set to FALSE `to` must be a contract that supports [LSP1 UniversalReceiver][LSP1] and not revert.\n- `data` the list of additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.\n\n_Requirements:_\n\n- `from`, `to`, `amount`, `force`, and `data` lists are the same length.\n- no values in `from` can be the zero address.\n- no values in `to` can be the zero address.\n- each `amount` tokens must be owned by `from`.\n- If the caller is not `from`, it must be an operator for `from` with access to at least `amount` tokens.\n\n#### batchCalls\n\n```solidity\nfunction batchCalls(bytes[] memory data) external returns (bytes[] memory results);\n```\n\nEnables the execution of a batch of encoded function calls on the current contract in a single transaction, provided as an array of bytes.\n\nMUST use the [DELEGATECALL] opcode to execute each call in the same context of the current contract.\n\n_Parameters:_\n\n- `data`: an array of encoded function calls to be executed on the current contract.\n\nThe data field can be:\n\n- an array of ABI-encoded function calls such as an array of ABI-encoded `transfer`, `authorizeOperator`, `balanceOf` or any LSP8 functions.\n- an array of bytes which will resolve to the fallback function to be checked for an extension.\n\n_Requirements:_\n\n- MUST NOT be payable.\n\n_Returns:_ `results` , an array of bytes containing the return values of each executed function call.\n\n### Events\n\n#### Transfer\n\n```solidity\nevent Transfer(address indexed operator, address indexed from, address indexed to, uint256 amount, bool force, bytes data);\n```\n\nMUST be emitted when `amount` tokens is transferred from `from` to `to`.\n\n#### OperatorAuthorizationChanged\n\n```solidity\nevent OperatorAuthorizationChanged(address indexed operator, address indexed tokenOwner, uint256 indexed amount, bytes operatorNotificationData);\n```\n\n- MUST be emitted when the `operator` allowance of `tokenOwner` changes to `amount` tokens.\n\n#### OperatorRevoked\n\n```solidity\nevent OperatorRevoked(address indexed operator, address indexed tokenOwner, bool indexed notified, bytes memory operatorNotificationData);\n```\n\n- MUST be emitted when the `operator` allowance of `tokenOwner` changes to 0 tokens.\n\n## Rationale\n\n<!--The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->\n\nThere should be a base token standard for the LSP ecosystem of contracts, which will allow common tooling and clients to be built. Existing tools and clients that expect [ERC20][ERC20] & [ERC777][ERC777] can be made to work with this standard by using \"compatability\" contract extensions that match the desired interface.\n\n### Operators\n\nTo clarify the ability of an address to access tokens from another address, `operator` was chosen as the name for functions, events and variables in all cases. This is originally from [ERC777][ERC777] standard and replaces the `allowance` functionality from [ERC20][ERC20].\n\n### Token Transfers\n\nThere is only one transfer function, which is aware of operators. This deviates from [ERC20][ERC20] and [ERC777][ERC777] which added functions specifically for the token owner to use, and for those with access to tokens. By having a single function to call this makes it simple to move tokens, and the caller will be exposed in the `Transfer` event as an indexed value.\n\n### Usage of hooks\n\nWhen a token is changing owners (minting, transfering, burning) an attempt is made to notify the token sender and receiver using [LSP1 UniversalReceiver][LSP1] interface. The implementation uses `_notifyTokenSender` and `_notifyTokenReceiver` as the internal functions to process this.\n\nThe `force` parameter sent during `function transfer` SHOULD be used when notifying the token receiver, to determine if it must support [LSP1 UniversalReceiver][LSP1]. This is used to prevent accidental token transfers, which may results in lost tokens: non-contract addresses could be a copy paste issue, contracts not supporting [LSP1 UniversalReceiver][LSP1] might not be able to move tokens.\n\n## Implementation\n\n<!--The implementations must be completed before any LIP is given status \"Final\", but it need not be completed before the LIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of \"rough consensus and running code\" is still useful when it comes to resolving many discussions of API details.-->\n\nA implementation can be found in the [lukso-network/lsp-smart-contracts][LSP7.sol];\n\n## Interface Cheat Sheet\n\n```solidity\ninterface ILSP7 is /* IERC165 */ {\n\n    // ERC173\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n    function owner() external view returns (address);\n\n    function transferOwnership(address newOwner) external; // onlyOwner\n\n    function renounceOwnership() external; // onlyOwner\n\n\n    // ERC725Y\n\n    event DataChanged(bytes32 indexed dataKey, bytes dataValue);\n\n\n    function getData(bytes32 dataKey) external view returns (bytes memory value);\n\n    function setData(bytes32 dataKey, bytes memory value) external; // onlyOwner\n\n    function getDataBatch(bytes32[] memory dataKeys) external view returns (bytes[] memory values);\n\n    function setDataBatch(bytes32[] memory dataKeys, bytes[] memory values) external; // onlyOwner\n\n\n    // LSP7\n\n    event Transfer(address indexed operator, address indexed from, address indexed to, uint256 amount, bool force, bytes data);\n\n    event OperatorAuthorizationChanged(address indexed operator, address indexed tokenOwner, uint256 indexed amount, bytes operatorNotificationData);\n\n    event OperatorRevoked(address indexed operator, address indexed tokenOwner, bool indexed notified, bytes operatorNotificationData);\n\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address tokenOwner) external view returns (uint256);\n\n    function authorizeOperator(address operator, uint256 amount, bytes memory operatorNotificationData) external;\n\n    function revokeOperator(address operator, address tokenOwner, bool notify, bytes memory operatorNotificationData) external;\n\n    function increaseAllowance(address operator, uint256 addedAmount, bytes memory operatorNotificationData) external;\n\n    function decreaseAllowance(address operator, address tokenOwner, uint256 subtractedAmount, bytes memory operatorNotificationData) external;\n\n    function authorizedAmountFor(address operator, address tokenOwner) external view returns (uint256);\n\n    function getOperatorsOf(address tokenOwner) external view returns (address[] memory);\n\n    function transfer(address from, address to, uint256 amount, bool force, bytes memory data) external;\n\n    function transferBatch(address[] memory from, address[] memory to, uint256[] memory amount, bool[] memory force, bytes[] memory data) external;\n\n    function batchCalls(bytes[] memory data) external returns (bytes[] memory results);\n\n}\n\n```\n\n## Copyright\n\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\n\n[ERC165]: https://eips.ethereum.org/EIPS/eip-165\n[ERC20]: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n[ERC777]: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-777.md\n[LSP1]: ./LSP-1-UniversalReceiver.md\n[LSP4#erc725ykeys]: ./LSP-4-DigitalAsset-Metadata.md#erc725ykeys\n[LSP8]: ./LSP-8-IdentifiableDigitalAsset.md\n[LSP7.sol]: https://github.com/lukso-network/lsp-universalprofile-smart-contracts/blob/main/contracts/LSP7DigitalAsset/LSP7DigitalAsset.sol"
    },
    {
      "filename": "contracts/LSP7DigitalAsset/LSP7Constants.sol",
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.4;\n\n// --- ERC165 interface ids\nbytes4 constant _INTERFACEID_LSP7 = 0xda1f85e4;\n\n// --- Token Hooks\n\n// keccak256('LSP7Tokens_SenderNotification')\nbytes32 constant _TYPEID_LSP7_TOKENSSENDER = 0x429ac7a06903dbc9c13dfcb3c9d11df8194581fa047c96d7a4171fc7402958ea;\n\n// keccak256('LSP7Tokens_RecipientNotification')\nbytes32 constant _TYPEID_LSP7_TOKENSRECIPIENT = 0x20804611b3e2ea21c480dc465142210acf4a2485947541770ec1fb87dee4a55c;"
    },
    {
      "filename": "LSPs/LSP-8-IdentifiableDigitalAsset.md",
      "content": "---\nlip: 8\ntitle: Identifiable Digital Asset\nauthor: Claudio Weck <claudio@fanzone.media>, Fabian Vogelsteller <fabian@lukso.network>, Matthew Stevens <@mattgstevens>, Ankit Kumar <@ankitkumar9018>\ndiscussions-to: https://discord.gg/E2rJPP4 (LUKSO), https://discord.gg/PQvJQtCV (FANZONE)\nstatus: Review\ntype: LSP\ncreated: 2021-09-02\nrequires: ERC165, ERC725Y, LSP1, LSP2, LSP4, LSP17\n---\n\n<!--You can leave these HTML comments in your merged LIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new LIPs. Note that an LIP number will be assigned by an editor. When opening a pull request to submit your LIP, please use an abbreviated title in the filename, `lip-draft_title_abbrev.md`. The title should be 44 characters or less.-->\n\n## Simple Summary\n\n<!--\"If you can't explain it simply, you don't understand it well enough.\" Provide a simplified and layman-accessible explanation of the LIP.-->\n\nThe LSP8 Identifiable Digital Asset Standard defines a standard interface for uniquely identifiable digital assets. It allows tokens to be uniquely traded and given with metadata using [ERC725Y][erc725] and [LSP4](./LSP-4-DigitalAsset-Metadata.md#lsp4metadata).\n\n## Abstract\n\n<!--A short (~200 word) description of the technical issue being addressed.-->\n\nThis standard defines a digital asset standard that can represent non-fungible tokens (NFTs).\n\nKey functionalities of this asset standard include:\n\n- **Flexible Asset Representation**: The tokenId defined in the standard is `bytes32` allowing different tokenId identification including numbers, contract addresses, and any other unique identifiers (_e.g:_ serial numbers, NFTs with unique names, hash values, etc...).\n\n- **Dynamic Information Attachment**: Leverages [ERC725Y] to add generic information to the asset and to each tokenId even post-deployment according to the LSP4-DigitalAssetMetadata standard.\n\n- **Secure Transfers**: By checking whether the recipient is capable of handling the asset before the actual transfer, it avoids loss and transfer of tokens to uncontrolled addresses.\n\n- **Transfer Interaction**: Notifies the operator, sender, and the recipient about the transfer, allowing users to be informed about the incoming asset and decide how to react accordingly (e.g., denying the token, forwarding it, etc.).\n\n- **Future-Proof Functionalities**: Through [LSP17-ContractExtension], allows the asset to be extended and support new standardized functions and interface IDs over time.\n\n- **Asset Flexibility and Discoverability**: Offers several flexible features, such as batch transfers and the ability to add several operators, as well as the ability to discover them.\n\n## Motivation\n\n<!--The motivation is critical for LIPs that want to change the Lukso protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the LIP solves. LIP submissions without sufficient motivation may be rejected outright.-->\n\nThe motivation for developing this new digital asset standard can be organized into several key points, each showing a specific limitation of current token standards:\n\n- **Limited Asset Representation**: Current NFT standards represent tokenId as a simple `uint256` type with no indication about how to parse it, making the NFT very limited.\n\n- **Limited Asset Metadata**: Current token standards offer limited metadata attachment capabilities, typically confined to basic elements like `name`, `symbol`, and `tokenURI`. This limitation is particularly restrictive for assets that require verifiable, on-chain metadata – such as details about creators, the community behind the token, or dynamic attributes that allow an NFT to evolve.\n\n- **No Interaction and Notification**: Traditional token standards lack in terms of interaction, particularly in notifying recipients about transfers. As a result, users cannot be unaware of incoming tokens and lose the opportunity to respond, for example, react to transfers, whether to deny, accept, or forward the tokens.\n\n- **Limited Functionalities**: Many tokens are confined to the functionalities they possess at deployment, making them rigid and unable to adapt to new requirements or standards.\n\n- **Risk of asset loss**: A common issue with current assets is the risk of loss due to transfers to incorrect or uncontrolled addresses as these standards does not check whether the recipient is able to handle the asset or not.\n\n- **Limited Features**: The limitation of having only one operator and the absence of batch transfer capabilities or even the discoveribility of tokens a user own restricts and provide bad user experience. Users need to rely on centralized indexers to know which tokens they own, need to do several transactions to do a batch of transfers, and cannot have more than one operator.\n\n## Specification\n\n[ERC165] interface id: `0x3a271706`\n\nThe LSP8 interface ID is calculated as the XOR of the LSP8 interface (see [interface cheat-sheet below](#interface-cheat-sheet)) and the [LSP17 Extendable interface ID](./LSP-17-ContractExtension.md#erc165-interface-id).\n\n### Methods\n\n#### totalSupply\n\n```solidity\nfunction totalSupply() external view returns (uint256);\n```\n\nReturns the number of existing tokens.\n\n**Returns:** `uint256` the number of existing tokens.\n\n#### balanceOf\n\n```solidity\nfunction balanceOf(address tokenOwner) external view returns (uint256);\n```\n\nReturns the number of tokens owned by `tokenOwner`.\n\n_Parameters:_\n\n- `tokenOwner` the address to query.\n\n**Returns:** `uint256` the number of tokens owned by this address.\n\n#### tokenOwnerOf\n\n```solidity\nfunction tokenOwnerOf(bytes32 tokenId) external view returns (address);\n```\n\nReturns the `tokenOwner` address of the `tokenId` token.\n\n_Parameters:_\n\n- `tokenId` the token to query.\n\n_Requirements:_\n\n- `tokenId` must exist\n\n**Returns:** `address` the token owner.\n\n#### tokenIdsOf\n\n```solidity\nfunction tokenIdsOf(address tokenOwner) external view returns (bytes32[] memory);\n```\n\nReturns the list of `tokenIds` for the `tokenOwner` address.\n\n_Parameters:_\n\n- `tokenOwner` the address to query.\n\n**Returns:** `bytes32[]` the list of owned token ids.\n\n#### authorizeOperator\n\n```solidity\nfunction authorizeOperator(address operator, bytes32 tokenId, bytes memory operatorNotificationData) external;\n```\n\nMakes `operator` address an operator of `tokenId`.\n\nMUST emit an [OperatorAuthorizationChanged event](#OperatorAuthorizationChanged).\n\n_Parameters:_\n\n- `operator` the address to authorize as an operator.\n- `tokenId` the token to enable operator status to.\n- `operatorNotificationData` the data to send when notifying the operator via LSP1.\n\n_Requirements:_\n\n- `tokenId` must exist.\n- `operator` cannot be already authorized for the same tokenId.\n- caller must be current `tokenOwner` of `tokenId`.\n- `operator` cannot be calling address.\n- `operator` cannot be the zero address.\n\n**LSP1 Hooks:**\n\n- If the operator is a contract that supports LSP1 interface, it SHOULD call operator's [`universalReceiver(...)`] function with the parameters below:\n\n  - `typeId`: `keccak256('LSP8Tokens_OperatorNotification')` > `0x8a1c15a8799f71b547e08e2bcb2e85257e81b0a07eee2ce6712549eef1f00970`\n  - `data`: The data sent SHOULD be abi encoded and contain the `tokenOwner` (address), `tokenId` (bytes32), `isAuthorized` (boolean), and the `operatorNotificationData` (bytes) respectively.\n\n<br>\n\n#### revokeOperator\n\n```solidity\nfunction revokeOperator(address operator, bytes32 tokenId, bool notify, bytes memory operatorNotificationData) external;\n```\n\nRemoves `operator` address as an operator of `tokenId`.\n\nMUST emit a [OperatorRevoked event](#OperatorRevoked).\n\n_Parameters:_\n\n- `operator` the address to revoke as an operator.\n- `tokenId` the token to disable operator status to.\n- `notify` the boolean indicating whether to notify the operator via LSP1 or not.\n- `operatorNotificationData` the data to send when notifying the operator via LSP1.\n\n_Requirements:_\n\n- `tokenId` must exist.\n- `operator` must be authorized for `tokenId`.\n- caller must be current `tokenOwner` or the `operator` of `tokenId`.\n- `operator` cannot be the zero address.\n\n**LSP1 Hooks:**\n\n- If the `notify` boolean is set to `true` and the operator is a contract that supports LSP1 interface, it SHOULD call operator's [`universalReceiver(...)`] function with the parameters below:\n\n  - `typeId`: `keccak256('LSP8Tokens_OperatorNotification')` > `0x8a1c15a8799f71b547e08e2bcb2e85257e81b0a07eee2ce6712549eef1f00970`\n  - `data`: The data sent SHOULD be abi encoded and contain the `tokenOwner` (address), `tokenId` (bytes32), `isAuthorized` (boolean), and the `operatorNotificationData` (bytes) respectively.\n\n<br>\n\n#### isOperatorFor\n\n```solidity\nfunction isOperatorFor(address operator, bytes32 tokenId) external view returns (bool);\n```\n\nReturns whether `operator` address is an operator of `tokenId`.\nOperators can send and burn tokens on behalf of their owners. The tokenOwner is their own operator.\n\n_Parameters:_\n\n- `operator` the address to query operator status for.\n- `tokenId` the token to query.\n\n_Requirements:_\n\n- `tokenId` must exist\n\n**Returns:** `bool`, TRUE if `operator` address is an operator of `tokenId`, FALSE otherwise.\n\n#### getOperatorsOf\n\n```solidity\nfunc"
    }
  ]
}