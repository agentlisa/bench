{
  "Title": "[M-03] reward will be locked in the farm if no LP join the pool at epoch.startBlock",
  "Content": "_Submitted by TrungOre_\n\n[LPFarming.sol#L214](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L214)<br>\n[LPFarming.sol#L107](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L107)<br>\n\nA part of reward tokens will be locked in the farming pool if no user deposits lpToken at the epoch.startBlock.\n\n### Proof of Concept\n\n    it(\"a part of reward should be locked in farm if no LP join the pool at epoch.startBlock\", async() => {\n          // manual mine new block  \n          await network.provider.send(\"evm_setAutomine\", [false]);\n\n          // prepare \n          await lpTokens[0].transfer(alice.address, units(1000));\n          await lpTokens[0].connect(alice).approve(farming.address, units(1000));\n          await mineBlocks(1);\n\n          // create new pool\n          await farming.add(10, lpTokens[0].address);\n          await mineBlocks(1);\n          expect(await farming.poolLength()).to.equal(1);\n\n          let pool = await farming.poolInfo(0);\n          expect(pool.lpToken).to.equal(lpTokens[0].address);\n          expect(pool.allocPoint).to.equal(10);\n\n          // create new epoch ==> balance of pool will be 1000 \n          let blockNumber = await ethers.provider.getBlockNumber();\n          await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);\n\n          // skip the epoch.startBlock  \n          // it mean no one deposit lpToken to farm at this block \n          await mineBlocks(1);\n          expect(await jpeg.balanceOf(farming.address)).to.equal(1000);\n\n          // alice deposit \n          await farming.connect(alice).deposit(0, units(100));\n          await mineBlocks(1);\n\n          // skip the blocks to the end of epoch \n          await mineBlocks(13);\n\n          await farming.connect(alice).claim(0);\n          await mineBlocks(1);\n\n          console.log(\"reward of alice: \", (await jpeg.balanceOf(alice.address)).toString());\n          console.log(\"reward remain: \", await jpeg.balanceOf(farming.address));\n\n          // 100 jpeg will be locked in the pool forevers \n          expect(await jpeg.balanceOf(alice.address)).to.equal(900);\n          expect(await jpeg.balanceOf(farming.address)).to.equal(100);\n        }); \n\nIn the example above, I create an epoch from blockNumber + 1 to blockNumber + 11 with the reward for each block being 100JPEG. So, the total reward for this farm will be 1000JPEG. When I skip the epoch.startBlock and let Alice deposit 100 lpToken at the block right after, at the end of the farm (epoch.endBlock), the total reward of Alice is just 900JPEG, and 100JPEG still remains in the farming pool. Since there is no function for the admin (or users) to withdraw the remaining, 100JPEG will be stucked in the pool forever !!!\n\n### Tools Used\n\ntypescript\n\n### Recommended Mitigation Steps\n\nAdd a new function for the admin (or user) to claim all rewards which remained in the pool when epoch.endTime has passed\n\n    function claimRemainRewardsForOwner() external onlyOwner {\n            require(\n                block.number > epoch.endBlock, \n                'epoch has not ended'\n            );\n            uint256 remain = jpeg.balanceOf(address(this));\n            jpeg.safeTransfer(msg.sender, remain);\n        }\n\n**[spaghettieth (JPEG'd) acknowledged, but disagreed with Medium severity and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/14#issuecomment-1095301767):**\n > This is a very minor issue, severity should be 0.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/14#issuecomment-1109977048):**\n > I disagree with the sponsor. Funds are lost in this scenario and it is very easy to mitigate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-04-jpegd",
  "Code": [
    {
      "filename": "contracts/farming/LPFarming.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title JPEG'd LP Farming\n/// @notice Users can stake their JPEG'd ecosystem LP tokens to get JPEG rewards\n/// @dev This contract doesn't mint JPEG tokens, instead the owner (the JPEG'd DAO) allocates x amount of JPEG to be distributed as a reward for liquidity providers.\n/// To ensure that enough tokens are allocated, an epoch system is implemented.\n/// The owner is required to allocate enough tokens (`_rewardPerBlock * (_endBlock - _startBlock)`) when creating a new epoch.\n/// When there no epoch is ongoing, the contract stops emitting rewards\ncontract LPFarming is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Claim(address indexed user, uint256 indexed pid, uint256 amount);\n    event ClaimAll(address indexed user, uint256 amount);\n\n    /// @dev Data relative to a user's staking position\n    /// @param amount The amount of LP tokens the user has provided\n    /// @param lastAccRewardPerShare The `accRewardPerShare` pool value at the time of the user's last claim\n    struct UserInfo {\n        uint256 amount;\n        uint256 lastAccRewardPerShare;\n    }\n\n    /// @dev Data relative to an LP pool\n    /// @param lpToken The LP token accepted by the pool\n    /// @param allocPoint Allocation points assigned to the pool. Determines the share of `rewardPerBlock` allocated to this pool\n    /// @param lastRewardBlock Last block number in which reward distribution occurred\n    /// @param accRewardPerShare Accumulated rewards per share, times 1e36. The amount of rewards the pool has accumulated per unit of LP token deposited\n    struct PoolInfo {\n        IERC20 lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardBlock;\n        uint256 accRewardPerShare;\n    }\n\n    /// @dev Data relative to an epoch\n    /// @param startBlock The epoch's starting block\n    /// @param endBlock The epoch's starting block\n    /// @param rewardPerBlock The amount of JPEG rewards distributed per block during this epoch\n    struct EpochInfo {\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 rewardPerBlock;\n    }\n\n    /// @notice The reward token, JPEG\n    IERC20 public immutable jpeg;\n\n    /// @notice The current epoch\n    /// @dev We don't need to store data about previous epochs, to simplify logic we only store data about the current epoch\n    EpochInfo public epoch;\n    /// @notice All the LP pools, active and inactive\n    PoolInfo[] public poolInfo;\n    /// @notice User staking positions, divided by PID\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    /// @notice Sum of the allocation points for all the pools\n    /// @dev Used to calculate the share of `rewardPerBlock` for each pool.\n    uint256 public totalAllocPoint;\n\n    /// @dev User's (total) withdrawable rewards\n    mapping(address => uint256) private userRewards;\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _jpeg The reward token\n    constructor(address _jpeg) {\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the LP farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting liquidity providers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to start a new epoch. Can only be called when there's no ongoing epoch\n    /// @param _startBlock The new epoch's start block. Has to be greater than the previous epoch's `endBlock`\n    /// @param _endBlock The new epoch's end block. Has to be greater than `_startBlock`\n    /// @param _rewardPerBlock The new epoch's amount of rewards to distribute per block. Must be greater than 0\n    function newEpoch(\n        uint256 _startBlock,\n        uint256 _endBlock,\n        uint256 _rewardPerBlock\n    ) external onlyOwner {\n        require(_startBlock >= block.number, \"Invalid start block\");\n        require(_endBlock > _startBlock, \"Invalid end block\");\n        require(_rewardPerBlock > 0, \"Invalid reward per block\");\n\n        //update all pools to ensure that they have all been updated up to the last epoch's `endBlock`\n        _massUpdatePools();\n\n        uint256 remainingRewards = epoch.rewardPerBlock *\n            (epoch.endBlock - _blockNumber());\n        uint256 newRewards = _rewardPerBlock * (_endBlock - _startBlock);\n\n        epoch.startBlock = _startBlock;\n        epoch.endBlock = _endBlock;\n        epoch.rewardPerBlock = _rewardPerBlock;\n\n        if (remainingRewards > newRewards) {\n            jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);\n        } else if (remainingRewards < newRewards) {\n            jpeg.safeTransferFrom(\n                msg.sender,\n                address(this),\n                newRewards - remainingRewards\n            );\n        }\n    }\n\n    /// @notice Allows the owner to add a new pool\n    /// @param _allocPoint Allocation points to assign to the new pool\n    /// @param _lpToken The LP token accepted by the new pool\n    function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 lastRewardBlock = _blockNumber();\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accRewardPerShare: 0\n            })\n        );\n    }\n\n    /// @notice Allows the owner to change a pool's allocation points\n    /// @param _pid The pool id of the pool to modify\n    /// @param _allocPoint The new allocation points\n    function set(uint256 _pid, uint256 _allocPoint) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 prevAllocPoint = poolInfo[_pid].allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n        if (prevAllocPoint != _allocPoint) {\n            totalAllocPoint = totalAllocPoint - prevAllocPoint + _allocPoint;\n        }\n    }\n\n    /// @notice Returns the number of pools available\n    /// @return The length of the `poolInfo` array\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim from the pool with id `_pid`\n    /// @param _pid The pool id\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable from `_pid` by user `_user`\n    function pendingReward(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (blockNumber > lastRewardBlock && lpSupply != 0) {\n            uint256 reward = ((blockNumber - lastRewardBlock) *\n                epoch.rewardPerBlock *\n                1e36 *\n                pool.allocPoint) / totalAllocPoint;\n            accRewardPerShare += reward / lpSupply;\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (user.amount * (accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of LP tokens in the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _pid The id of the pool to deposit into\n    /// @param _amount The amount of LP tokens to deposit\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n        user.amount = user.amount + _amount;\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of LP tokens from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _pid The id of the pool to withdraw from\n    /// @param _amount The amount of LP tokens to withdraw\n    function withdraw(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"insufficient_amount\");\n\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        user.amount -= _amount;\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    /// @dev Normalizes the current `block.number`. See {_normalizeBlockNumber} for more info\n    /// @return Normalized `block.number`\n    function _blockNumber() internal view returns (uint256) {\n        return _normalizeBlockNumber(block.number);\n    }\n\n    /// @dev Normalizes `blockNumber` to fit within the bounds of an epoch.\n    /// This is done to ensure that no rewards are distributed for staking outside of an epoch without modifying the reward logic.\n    /// For example:\n    /// `blockNumber` is 1100, the epoch's `endBlock` is 1000. In this case the function would return 1000. If this value were to be used\n    /// in the {_updatePool} function, where the pool's `lastRewardBlock` is 990, only the rewards from block 990 to block 1000 would be distributed\n    /// @return Normalized `blockNumber`\n    function _normalizeBlockNumber(uint256 blockNumber)\n        internal\n        view\n        returns (uint256)\n    {\n        if (blockNumber < epoch.startBlock) return epoch.startBlock;\n\n        if (blockNumber > epoch.endBlock) return epoch.endBlock;\n\n        return blockNumber;\n    }\n\n    /// @dev Calls {_updatePool} for every pool\n    function _massUpdatePools() internal {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            _updatePool(pid);\n        }\n    }\n\n    /// @dev Updates the state of the pool at index `_pid`\n    /// @param _pid The pool to update\n    function _updatePool(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (pool.allocPoint == 0) {\n            return;\n        }\n\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        if (blockNumber <= lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = blockNumber;\n            return;\n        }\n        uint256 reward = ((blockNumber - lastRewardBlock) *\n            epoch.rewardPerBlock *\n            1e36 *\n            pool.allocPoint) / totalAllocPoint;\n        pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;\n        pool.lastRewardBlock = blockNumber;\n    }\n\n    /// @dev Updates `msg.sender`'s claimable rewards by adding pending rewards from `_pid`\n    /// @param _pid The pool to withdraw rewards from\n    function _withdrawReward(uint256 _pid) internal returns (uint256) {\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 pending = (user.amount *\n            (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n        if (pending > 0) {\n            userRewards[msg.sender] += pending;\n        }\n\n        user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @notice Allows users to claim rewards from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    /// @param _pid The pool to claim rewards from\n    function claim(uint256 _pid) external nonReentrant noContract(msg.sender) {\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit Claim(msg.sender, _pid, rewards);\n    }\n\n    /// @notice Allows users to claim rewards from all pools. Non whitelisted contracts can't call this function\n    /// @dev Emits a {ClaimAll} event\n    function claimAll() external nonReentrant noContract(msg.sender) {\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            _updatePool(i);\n            _withdrawReward(i);\n        }\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit ClaimAll(msg.sender, rewards);\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}"
    },
    {
      "filename": "contracts/farming/LPFarming.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title JPEG'd LP Farming\n/// @notice Users can stake their JPEG'd ecosystem LP tokens to get JPEG rewards\n/// @dev This contract doesn't mint JPEG tokens, instead the owner (the JPEG'd DAO) allocates x amount of JPEG to be distributed as a reward for liquidity providers.\n/// To ensure that enough tokens are allocated, an epoch system is implemented.\n/// The owner is required to allocate enough tokens (`_rewardPerBlock * (_endBlock - _startBlock)`) when creating a new epoch.\n/// When there no epoch is ongoing, the contract stops emitting rewards\ncontract LPFarming is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Claim(address indexed user, uint256 indexed pid, uint256 amount);\n    event ClaimAll(address indexed user, uint256 amount);\n\n    /// @dev Data relative to a user's staking position\n    /// @param amount The amount of LP tokens the user has provided\n    /// @param lastAccRewardPerShare The `accRewardPerShare` pool value at the time of the user's last claim\n    struct UserInfo {\n        uint256 amount;\n        uint256 lastAccRewardPerShare;\n    }\n\n    /// @dev Data relative to an LP pool\n    /// @param lpToken The LP token accepted by the pool\n    /// @param allocPoint Allocation points assigned to the pool. Determines the share of `rewardPerBlock` allocated to this pool\n    /// @param lastRewardBlock Last block number in which reward distribution occurred\n    /// @param accRewardPerShare Accumulated rewards per share, times 1e36. The amount of rewards the pool has accumulated per unit of LP token deposited\n    struct PoolInfo {\n        IERC20 lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardBlock;\n        uint256 accRewardPerShare;\n    }\n\n    /// @dev Data relative to an epoch\n    /// @param startBlock The epoch's starting block\n    /// @param endBlock The epoch's starting block\n    /// @param rewardPerBlock The amount of JPEG rewards distributed per block during this epoch\n    struct EpochInfo {\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 rewardPerBlock;\n    }\n\n    /// @notice The reward token, JPEG\n    IERC20 public immutable jpeg;\n\n    /// @notice The current epoch\n    /// @dev We don't need to store data about previous epochs, to simplify logic we only store data about the current epoch\n    EpochInfo public epoch;\n    /// @notice All the LP pools, active and inactive\n    PoolInfo[] public poolInfo;\n    /// @notice User staking positions, divided by PID\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    /// @notice Sum of the allocation points for all the pools\n    /// @dev Used to calculate the share of `rewardPerBlock` for each pool.\n    uint256 public totalAllocPoint;\n\n    /// @dev User's (total) withdrawable rewards\n    mapping(address => uint256) private userRewards;\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _jpeg The reward token\n    constructor(address _jpeg) {\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the LP farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting liquidity providers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to start a new epoch. Can only be called when there's no ongoing epoch\n    /// @param _startBlock The new epoch's start block. Has to be greater than the previous epoch's `endBlock`\n    /// @param _endBlock The new epoch's end block. Has to be greater than `_startBlock`\n    /// @param _rewardPerBlock The new epoch's amount of rewards to distribute per block. Must be greater than 0\n    function newEpoch(\n        uint256 _startBlock,\n        uint256 _endBlock,\n        uint256 _rewardPerBlock\n    ) external onlyOwner {\n        require(_startBlock >= block.number, \"Invalid start block\");\n        require(_endBlock > _startBlock, \"Invalid end block\");\n        require(_rewardPerBlock > 0, \"Invalid reward per block\");\n\n        //update all pools to ensure that they have all been updated up to the last epoch's `endBlock`\n        _massUpdatePools();\n\n        uint256 remainingRewards = epoch.rewardPerBlock *\n            (epoch.endBlock - _blockNumber());\n        uint256 newRewards = _rewardPerBlock * (_endBlock - _startBlock);\n\n        epoch.startBlock = _startBlock;\n        epoch.endBlock = _endBlock;\n        epoch.rewardPerBlock = _rewardPerBlock;\n\n        if (remainingRewards > newRewards) {\n            jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);\n        } else if (remainingRewards < newRewards) {\n            jpeg.safeTransferFrom(\n                msg.sender,\n                address(this),\n                newRewards - remainingRewards\n            );\n        }\n    }\n\n    /// @notice Allows the owner to add a new pool\n    /// @param _allocPoint Allocation points to assign to the new pool\n    /// @param _lpToken The LP token accepted by the new pool\n    function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 lastRewardBlock = _blockNumber();\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accRewardPerShare: 0\n            })\n        );\n    }\n\n    /// @notice Allows the owner to change a pool's allocation points\n    /// @param _pid The pool id of the pool to modify\n    /// @param _allocPoint The new allocation points\n    function set(uint256 _pid, uint256 _allocPoint) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 prevAllocPoint = poolInfo[_pid].allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n        if (prevAllocPoint != _allocPoint) {\n            totalAllocPoint = totalAllocPoint - prevAllocPoint + _allocPoint;\n        }\n    }\n\n    /// @notice Returns the number of pools available\n    /// @return The length of the `poolInfo` array\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim from the pool with id `_pid`\n    /// @param _pid The pool id\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable from `_pid` by user `_user`\n    function pendingReward(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (blockNumber > lastRewardBlock && lpSupply != 0) {\n            uint256 reward = ((blockNumber - lastRewardBlock) *\n                epoch.rewardPerBlock *\n                1e36 *\n                pool.allocPoint) / totalAllocPoint;\n            accRewardPerShare += reward / lpSupply;\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (user.amount * (accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of LP tokens in the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _pid The id of the pool to deposit into\n    /// @param _amount The amount of LP tokens to deposit\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n        user.amount = user.amount + _amount;\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of LP tokens from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _pid The id of the pool to withdraw from\n    /// @param _amount The amount of LP tokens to withdraw\n    function withdraw(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"insufficient_amount\");\n\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        user.amount -= _amount;\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    /// @dev Normalizes the current `block.number`. See {_normalizeBlockNumber} for more info\n    /// @return Normalized `block.number`\n    function _blockNumber() internal view returns (uint256) {\n        return _normalizeBlockNumber(block.number);\n    }\n\n    /// @dev Normalizes `blockNumber` to fit within the bounds of an epoch.\n    /// This is done to ensure that no rewards are distributed for staking outside of an epoch without modifying the reward logic.\n    /// For example:\n    /// `blockNumber` is 1100, the epoch's `endBlock` is 1000. In this case the function would return 1000. If this value were to be used\n    /// in the {_updatePool} function, where the pool's `lastRewardBlock` is 990, only the rewards from block 990 to block 1000 would be distributed\n    /// @return Normalized `blockNumber`\n    function _normalizeBlockNumber(uint256 blockNumber)\n        internal\n        view\n        returns (uint256)\n    {\n        if (blockNumber < epoch.startBlock) return epoch.startBlock;\n\n        if (blockNumber > epoch.endBlock) return epoch.endBlock;\n\n        return blockNumber;\n    }\n\n    /// @dev Calls {_updatePool} for every pool\n    function _massUpdatePools() internal {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            _updatePool(pid);\n        }\n    }\n\n    /// @dev Updates the state of the pool at index `_pid`\n    /// @param _pid The pool to update\n    function _updatePool(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (pool.allocPoint == 0) {\n            return;\n        }\n\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        if (blockNumber <= lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = blockNumber;\n            return;\n        }\n        uint256 reward = ((blockNumber - lastRewardBlock) *\n            epoch.rewardPerBlock *\n            1e36 *\n            pool.allocPoint) / totalAllocPoint;\n        pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;\n        pool.lastRewardBlock = blockNumber;\n    }\n\n    /// @dev Updates `msg.sender`'s claimable rewards by adding pending rewards from `_pid`\n    /// @param _pid The pool to withdraw rewards from\n    function _withdrawReward(uint256 _pid) internal returns (uint256) {\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 pending = (user.amount *\n            (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n        if (pending > 0) {\n            userRewards[msg.sender] += pending;\n        }\n\n        user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @notice Allows users to claim rewards from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    /// @param _pid The pool to claim rewards from\n    function claim(uint256 _pid) external nonReentrant noContract(msg.sender) {\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit Claim(msg.sender, _pid, rewards);\n    }\n\n    /// @notice Allows users to claim rewards from all pools. Non whitelisted contracts can't call this function\n    /// @dev Emits a {ClaimAll} event\n    function claimAll() external nonReentrant noContract(msg.sender) {\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            _updatePool(i);\n            _withdrawReward(i);\n        }\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit ClaimAll(msg.sender, rewards);\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}"
    }
  ]
}