{
  "Title": "H-8: Lack of access control for `mintRebalancer()` and `burnRebalancer()`",
  "Content": "# Issue H-8: Lack of access control for `mintRebalancer()` and `burnRebalancer()` \n\nSource: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/777 \n\n## Found by \n0x2e, 0xAzez, 0xHati, 0xMojito, 0xPkhatri, 0xRobocop, 0xSmartContract, 0xStalin, 0xeix, 0xyPhilic, 14si2o\\_Flint, AlexCzm, Angry\\_Mustache\\_Man, Aymen0909, Bahurum, Bauchibred, Bauer, BlockChomper, Brenzee, BugBusters, BugHunter101, Delvir0, DevABDee, Dug, Fanz, GimelSec, HonorLt, J4de, JohnnyTime, Juntao, Kodyvim, Kose, Lilyjjo, Madalad, Nyx, PokemonAuditSimulator, RaymondFam, Saeedalipoor01988, SanketKogekar, Schpiel, SensoYard, T1MOH, TheNaubit, Tricko, VAD37, Vagner, WATCHPUG, \\_\\_141345\\_\\_, anthony, ast3ros, auditsea, berlin-101, blackhole, blockdev, carrotsmuggler, chainNue, chalex.eth, cjm00n, coincoin, coryli, ctf\\_sec, curiousapple, dacian, evilakela, georgits, giovannidisiena, immeas, innertia, jah, juancito, kie, kiki\\_dev, lil.eth, m4ttm, mahdikarimi, mrpathfindr, n33k, neumo, ni8mare, nobody2018, pavankv241, pengun, qbs, qckhp, qpzm, ravikiran.web3, saidam017, sam\\_gmk, sashik\\_eth, shaka, shealtielanz, shogoki, simon135, slightscan, smiling\\_heretic, tallo, theOwl, the\\_endless\\_sea, toshii, tsvetanovv, tvdung94, twcctop, twicek, vagrant, ver0759, warRoom, whiteh4t9527, ww4tson, yy\n## Summary\n\nLack of access control in `USSD.mintRebalancer()` and `USSD.burnRebalancer()` can lead to a denial-of-service attack and malfunction of the rebalancer as it can alter `totalSupply`, which is used in `rebalancer.SellUSSDBuyCollateral` to calculate `ownval`.\n\n## Vulnerability Detail\n\nBased on the context, `USSD.mintRebalancer()` should be `onlyBalancer` as it should only be allowed to be called by the rebalancer.\n\nHowever, both `USSD.mintRebalancer()` and `USSD.burnRebalancer()` lack access control in the current implementation.\n\n## Impact\n\nAn attacker can mint an amount of `type(uint256).max - totalSupply()` and cause a denial-of-service attack by preventing anyone else from minting.\n\nAdditionally, minting will also change the `totalSupply` which alters the `collateralFactor` and cause the rebalancer to malfunction, as the `SellUSSDBuyCollateral()` function relies on the `USSD.collateralFactor()`.\n\nThe `totalSupply` is also used in `rebalancer.SellUSSDBuyCollateral` to calculate the `ownval`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L204-L210\n\n```solidity\nfunction mintRebalancer(uint256 amount) public override {\n    _mint(address(this), amount);\n}\n\nfunction burnRebalancer(uint256 amount) public override {\n    _burn(address(this), amount);\n}\n```\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L92-L107\n\n```solidity\n    function rebalance() override public {\n      uint256 ownval = getOwnValuation();\n      (uint256 USSDamount, uint256 DAIamount) = getSupplyProportion();\n      if (ownval < 1e6 - threshold) {\n        // peg-down recovery\n        BuyUSSDSellCollateral((USSDamount - DAIamount / 1e12)/2);\n      } else if (ownval > 1e6 + threshold) {\n        // mint and buy collateral\n        // never sell too much USSD for DAI so it 'overshoots' (becomes more in quantity than DAI on the pool)\n        // otherwise could be arbitraged through mint/redeem\n        // the execution difference due to fee should be taken into accounting too\n        // take 1% safety margin (estimated as 2 x 0.5% fee)\n        IUSSD(USSD).mintRebalancer(((DAIamount / 1e12 - USSDamount)/2) * 99 / 100); // mint ourselves amount till balance recover\n        SellUSSDBuyCollateral();\n      }\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L179-L194\n\n```solidity\nfunction collateralFactor() public view override returns (uint256) {\n    uint256 totalAssetsUSD = 0;\n    for (uint256 i = 0; i < collateral.length; i++) {\n        totalAssetsUSD +=\n            (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                address(this)\n            ) * 1e18) /\n                (10 **\n                    IERC20MetadataUpgradeable(collateral[i].token)\n                        .decimals())) *\n                collateral[i].oracle.getPriceUSD()) /\n            1e18;\n    }\n\n    return (totalAssetsUSD * 1e6) / totalSupply();\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`USSD.mintRebalancer()` should be `onlyBalancer`.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/82",
  "Code": [
    {
      "filename": "ussd-contracts/contracts/USSD.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"./interfaces/IStableOracle.sol\";\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\";\n\n/**\n    @notice USSD: Autonomous on-chain stablecoin\n */\ncontract USSD is\n    IUSSD,\n    ERC20Upgradeable,\n    AccessControlUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n\n    IUSSDRebalancer public rebalancer;\n\n    // allowed to manage collateral, set tresholds and perform management tasks\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        // mint 10k USSD to create initial pool\n        _mint(msg.sender, 10_000 * 1e6);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    /**\n        @dev restrict calls only by STABLE_CONTROL_ROLE role\n     */\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                Events\n    //////////////////////////////////////////////////////////////*/\n\n    event Mint(\n        address indexed from,\n        address indexed to,\n        address token,\n        uint256 amountToken,\n        uint256 amountStable\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                          COLLATERAL MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    CollateralInfo[] private collateral;\n\n    function collateralList()\n        public\n        view\n        override\n        returns (CollateralInfo[] memory)\n    {\n        return collateral;\n    }\n\n    function addCollateral(\n        address _address,\n        address _oracle,\n        bool _mint,\n        bool _redeem,\n        uint256[] calldata _ratios,\n        bytes memory _pathbuy,\n        bytes memory _pathsell,\n        uint256 index\n    ) public onlyControl {\n        CollateralInfo memory newCollateral = CollateralInfo({\n            token: _address,\n            mint: _mint,\n            redeem: _redeem,\n            oracle: IStableOracle(_oracle),\n            pathbuy: _pathbuy,\n            pathsell: _pathsell,\n            ratios: _ratios\n        });\n        if (index < collateral.length) {\n            collateral[index] = newCollateral; // for editing\n        } else {\n            collateral.push(newCollateral); // for adding new collateral\n        }\n    }\n\n    function swapCollateralIndexes(\n        uint256 _index1,\n        uint256 _index2\n    ) public onlyControl {\n        // cannot use (a, b) = (b, a) for storage variables\n        CollateralInfo memory tmp = collateral[_index1];\n        collateral[_index1] = collateral[_index2];\n        collateral[_index2] = tmp;\n    }\n\n    function removeCollateral(uint256 _index) public onlyControl {\n        collateral[_index] = collateral[collateral.length - 1];\n        collateral.pop();\n    }\n\n    function getCollateralIndex(\n        address _token\n    ) public view returns (uint256 index) {\n        for (index = 0; index < collateral.length; index++) {\n            if (collateral[index].token == _token) {\n                return index;\n            }\n        }\n    }\n\n    function hasCollateralMint(\n        address _token\n    ) public view returns (bool present) {\n        for (uint256 i = 0; i < collateral.length; i++) {\n            if (collateral[i].token == _token && collateral[i].mint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// Mint specific AMOUNT OF STABLE by giving token\n    function mintForToken(\n        address token,\n        uint256 tokenAmount,\n        address to\n    ) public returns (uint256 stableCoinAmount) {\n        require(hasCollateralMint(token), \"unsupported token\");\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        stableCoinAmount = calculateMint(token, tokenAmount);\n        _mint(to, stableCoinAmount);\n\n        emit Mint(msg.sender, to, token, tokenAmount, stableCoinAmount);\n    }\n\n    /// @dev Return how much STABLECOIN does user receive for AMOUNT of asset\n    function calculateMint(address _token, uint256 _amount) public view returns (uint256 stableCoinAmount) {\n        uint256 assetPrice = collateral[getCollateralIndex(_token)].oracle.getPriceUSD();\n        return (((assetPrice * _amount) / 1e18) * (10 ** decimals())) / (10 ** IERC20MetadataUpgradeable(_token).decimals());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function collateralFactor() public view override returns (uint256) {\n        uint256 totalAssetsUSD = 0;\n        for (uint256 i = 0; i < collateral.length; i++) {\n            totalAssetsUSD +=\n                (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                    address(this)\n                ) * 1e18) /\n                    (10 **\n                        IERC20MetadataUpgradeable(collateral[i].token)\n                            .decimals())) *\n                    collateral[i].oracle.getPriceUSD()) /\n                1e18;\n        }\n\n        return (totalAssetsUSD * 1e6) / totalSupply();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               REBALANCER\n    //////////////////////////////////////////////////////////////*/\n\n    function setRebalancer(address _rebalancer) public onlyControl {\n        rebalancer = IUSSDRebalancer(_rebalancer);\n    }\n\n    function mintRebalancer(uint256 amount) public override {\n        _mint(address(this), amount);\n    }\n\n    function burnRebalancer(uint256 amount) public override {\n        _burn(address(this), amount);\n    }\n\n    modifier onlyBalancer() {\n        require(msg.sender == address(rebalancer), \"bal\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               UNISWAP\n    //////////////////////////////////////////////////////////////*/\n\n    IV3SwapRouter public uniRouter; // uniswap router to handle operations\n\n    function setUniswapRouter(address _router) public onlyControl {\n        uniRouter = IV3SwapRouter(_router);\n    }\n\n    function UniV3SwapInput(\n        bytes memory _path,\n        uint256 _sellAmount\n    ) public override onlyBalancer {\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: _path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountIn: _sellAmount,\n                amountOutMinimum: 0\n            });\n        uniRouter.exactInput(params);\n    }\n\n    function approveToRouter(address _token) public {\n        IERC20Upgradeable(_token).approve(\n            address(uniRouter),\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n    }\n}"
    },
    {
      "filename": "ussd-contracts/contracts/USSDRebalancer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n    @dev rebalancer module for USSD ERC20 token. Performs swaps to return USSD/DAI pool balance 1-to-1\n         selling USSD for buying collateral or buying and burning USSD for selling collateral\n */\ncontract USSDRebalancer is AccessControlUpgradeable, IUSSDRebalancer {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // main USSD/DAI pool\n    IUniswapV3Pool public uniPool;\n\n    // USSD token\n    address public USSD;\n\n    // boundary to make rebalancing\n    uint256 private threshold;\n\n    // ratios of collateralization for different collateral accumulating\n    uint256[] public flutterRatios;\n    \n    // base asset for other pool leg (DAI)\n    address private baseAsset;\n\n    // role to perform rebalancer management functions\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(address _ussd) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        threshold = 1e4;\n        USSD = _ussd;\n    }\n\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    function setPoolAddress(address _pool) public onlyControl {\n      uniPool = IUniswapV3Pool(_pool);\n    }\n\n    function getPool() public view override returns (address) {\n        return address(uniPool);\n    }\n\n    function setTreshold(uint256 _threshold) public onlyControl {\n      threshold = _threshold;\n    }\n\n    function setFlutterRatios(uint256[] calldata _flutterRatios) public onlyControl {\n      flutterRatios = _flutterRatios;\n    }\n\n    function setBaseAsset(address _baseAsset) public onlyControl {\n      baseAsset = _baseAsset;\n    }\n\n    /// @dev get price estimation to DAI using pool address and uniswap price\n    function getOwnValuation() public view returns (uint256 price) {\n      (uint160 sqrtPriceX96,,,,,,) =  uniPool.slot0();\n      if(uniPool.token0() == USSD) {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))/(1e6) >> (96 * 2);\n      } else {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))*(1e18 /* 1e12 + 1e6 decimal representation */) >> (96 * 2);\n        // flip the fraction\n        price = (1e24 / price) / 1e12;\n      }\n    }\n\n    /// @dev return pool balances with USSD first\n    function getSupplyProportion() public view returns (uint256, uint256) {\n      uint256 vol1 = IERC20Upgradeable(uniPool.token0()).balanceOf(address(uniPool));\n      uint256 vol2 = IERC20Upgradeable(uniPool.token1()).balanceOf(address(uniPool));\n      if (uniPool.token0() == USSD) {\n        return (vol1, vol2);\n      }\n      return (vol2, vol1);\n    }\n\n    function rebalance() override public {\n      uint256 ownval = getOwnValuation();\n      (uint256 USSDamount, uint256 DAIamount) = getSupplyProportion();\n      if (ownval < 1e6 - threshold) {\n        // peg-down recovery\n        BuyUSSDSellCollateral((USSDamount - DAIamount / 1e12)/2);\n      } else if (ownval > 1e6 + threshold) {\n        // mint and buy collateral\n        // never sell too much USSD for DAI so it 'overshoots' (becomes more in quantity than DAI on the pool)\n        // otherwise could be arbitraged through mint/redeem\n        // the execution difference due to fee should be taken into accounting too\n        // take 1% safety margin (estimated as 2 x 0.5% fee)\n        IUSSD(USSD).mintRebalancer(((DAIamount / 1e12 - USSDamount)/2) * 99 / 100); // mint ourselves amount till balance recover\n        SellUSSDBuyCollateral();\n      }\n    }\n\n    function BuyUSSDSellCollateral(uint256 amountToBuy) internal {\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      //uint amountToBuyLeftUSD = amountToBuy * 1e12 * 1e6 / getOwnValuation();\n      uint amountToBuyLeftUSD = amountToBuy * 1e12;\n      uint DAItosell = 0;\n      // Sell collateral in order of collateral array\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval > amountToBuyLeftUSD) {\n          // sell a portion of collateral and exit\n          if (collateral[i].pathsell.length > 0) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          } else {\n            // no need to swap DAI\n            DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n          }\n          break;\n        } else {\n          // sell all or skip (if collateral is too little, 5% treshold)\n          if (collateralval >= amountToBuyLeftUSD / 20) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            // sell all collateral and move to next one\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          }\n        }\n      }\n\n      // buy USSD (sell DAI) to burn\n      // never sell too much DAI so USSD 'overshoots' (becomes less in quantity than DAI on the pool)\n      // otherwise could be arbitraged through mint/redeem\n      // the remainder (should be small, due to oracle twap lag) to be left as DAI collateral\n      // the execution difference due to fee should be taken into accounting too\n      // take 1% safety margin (estimated as 2 x 0.5% fee)\n      if (DAItosell > amountToBuy * 1e12 * 99 / 100) {\n        DAItosell = amountToBuy * 1e12 * 99 / 100;\n      }\n\n      if (DAItosell > 0) {\n        if (uniPool.token0() == USSD) {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), DAItosell);\n        } else {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), DAItosell);\n        }\n      }\n\n      IUSSD(USSD).burnRebalancer(IUSSD(USSD).balanceOf(USSD));\n    }\n\n    function SellUSSDBuyCollateral() internal {\n      uint256 amount = IUSSD(USSD).balanceOf(USSD);\n      // sell for DAI then swap by DAI routes\n      uint256 daibought = 0;\n      if (uniPool.token0() == USSD) {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      } else {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      }\n\n      // total collateral portions\n      uint256 cf = IUSSD(USSD).collateralFactor();\n      uint256 flutter = 0;\n      for (flutter = 0; flutter < flutterRatios.length; flutter++) {\n        if (cf < flutterRatios[flutter]) {\n          break;\n        }\n      }\n\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      uint portions = 0;\n      uint ownval = (getOwnValuation() * 1e18 / 1e6) * IUSSD(USSD).totalSupply() / 1e6; // 1e18 total USSD value\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          portions++;\n        }\n      }\n\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          if (collateral[i].token != uniPool.token0() || collateral[i].token != uniPool.token1()) {\n            // don't touch DAI if it's needed to be bought (it's already bought)\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathbuy, daibought/portions);\n          }\n        }\n      }\n    }\n}"
    },
    {
      "filename": "ussd-contracts/contracts/USSD.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"./interfaces/IStableOracle.sol\";\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\";\n\n/**\n    @notice USSD: Autonomous on-chain stablecoin\n */\ncontract USSD is\n    IUSSD,\n    ERC20Upgradeable,\n    AccessControlUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n\n    IUSSDRebalancer public rebalancer;\n\n    // allowed to manage collateral, set tresholds and perform management tasks\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        // mint 10k USSD to create initial pool\n        _mint(msg.sender, 10_000 * 1e6);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    /**\n        @dev restrict calls only by STABLE_CONTROL_ROLE role\n     */\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                Events\n    //////////////////////////////////////////////////////////////*/\n\n    event Mint(\n        address indexed from,\n        address indexed to,\n        address token,\n        uint256 amountToken,\n        uint256 amountStable\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                          COLLATERAL MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    CollateralInfo[] private collateral;\n\n    function collateralList()\n        public\n        view\n        override\n        returns (CollateralInfo[] memory)\n    {\n        return collateral;\n    }\n\n    function addCollateral(\n        address _address,\n        address _oracle,\n        bool _mint,\n        bool _redeem,\n        uint256[] calldata _ratios,\n        bytes memory _pathbuy,\n        bytes memory _pathsell,\n        uint256 index\n    ) public onlyControl {\n        CollateralInfo memory newCollateral = CollateralInfo({\n            token: _address,\n            mint: _mint,\n            redeem: _redeem,\n            oracle: IStableOracle(_oracle),\n            pathbuy: _pathbuy,\n            pathsell: _pathsell,\n            ratios: _ratios\n        });\n        if (index < collateral.length) {\n            collateral[index] = newCollateral; // for editing\n        } else {\n            collateral.push(newCollateral); // for adding new collateral\n        }\n    }\n\n    function swapCollateralIndexes(\n        uint256 _index1,\n        uint256 _index2\n    ) public onlyControl {\n        // cannot use (a, b) = (b, a) for storage variables\n        CollateralInfo memory tmp = collateral[_index1];\n        collateral[_index1] = collateral[_index2];\n        collateral[_index2] = tmp;\n    }\n\n    function removeCollateral(uint256 _index) public onlyControl {\n        collateral[_index] = collateral[collateral.length - 1];\n        collateral.pop();\n    }\n\n    function getCollateralIndex(\n        address _token\n    ) public view returns (uint256 index) {\n        for (index = 0; index < collateral.length; index++) {\n            if (collateral[index].token == _token) {\n                return index;\n            }\n        }\n    }\n\n    function hasCollateralMint(\n        address _token\n    ) public view returns (bool present) {\n        for (uint256 i = 0; i < collateral.length; i++) {\n            if (collateral[i].token == _token && collateral[i].mint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// Mint specific AMOUNT OF STABLE by giving token\n    function mintForToken(\n        address token,\n        uint256 tokenAmount,\n        address to\n    ) public returns (uint256 stableCoinAmount) {\n        require(hasCollateralMint(token), \"unsupported token\");\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        stableCoinAmount = calculateMint(token, tokenAmount);\n        _mint(to, stableCoinAmount);\n\n        emit Mint(msg.sender, to, token, tokenAmount, stableCoinAmount);\n    }\n\n    /// @dev Return how much STABLECOIN does user receive for AMOUNT of asset\n    function calculateMint(address _token, uint256 _amount) public view returns (uint256 stableCoinAmount) {\n        uint256 assetPrice = collateral[getCollateralIndex(_token)].oracle.getPriceUSD();\n        return (((assetPrice * _amount) / 1e18) * (10 ** decimals())) / (10 ** IERC20MetadataUpgradeable(_token).decimals());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function collateralFactor() public view override returns (uint256) {\n        uint256 totalAssetsUSD = 0;\n        for (uint256 i = 0; i < collateral.length; i++) {\n            totalAssetsUSD +=\n                (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                    address(this)\n                ) * 1e18) /\n                    (10 **\n                        IERC20MetadataUpgradeable(collateral[i].token)\n                            .decimals())) *\n                    collateral[i].oracle.getPriceUSD()) /\n                1e18;\n        }\n\n        return (totalAssetsUSD * 1e6) / totalSupply();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               REBALANCER\n    //////////////////////////////////////////////////////////////*/\n\n    function setRebalancer(address _rebalancer) public onlyControl {\n        rebalancer = IUSSDRebalancer(_rebalancer);\n    }\n\n    function mintRebalancer(uint256 amount) public override {\n        _mint(address(this), amount);\n    }\n\n    function burnRebalancer(uint256 amount) public override {\n        _burn(address(this), amount);\n    }\n\n    modifier onlyBalancer() {\n        require(msg.sender == address(rebalancer), \"bal\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               UNISWAP\n    //////////////////////////////////////////////////////////////*/\n\n    IV3SwapRouter public uniRouter; // uniswap router to handle operations\n\n    function setUniswapRouter(address _router) public onlyControl {\n        uniRouter = IV3SwapRouter(_router);\n    }\n\n    function UniV3SwapInput(\n        bytes memory _path,\n        uint256 _sellAmount\n    ) public override onlyBalancer {\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: _path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountIn: _sellAmount,\n                amountOutMinimum: 0\n            });\n        uniRouter.exactInput(params);\n    }\n\n    function approveToRouter(address _token) public {\n        IERC20Upgradeable(_token).approve(\n            address(uniRouter),\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n    }\n}"
    }
  ]
}