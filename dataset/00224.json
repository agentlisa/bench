{
  "Title": "H-1: The calculated value for slippage protection in the protocol is inaccurate",
  "Content": "# Issue H-1: The calculated value for slippage protection in the protocol is inaccurate \n\nSource: https://github.com/sherlock-audit/2024-04-alchemix-judging/issues/5 \n\n## Found by \nBauer, ge6a, jasonxiale, zigtur\n## Summary\n\n\nThe protocol calculates the slippage protection value based on the price of OP relative to USD and OP relative to ETH, while the intended exchange is for alUSD and alETH. This results in inaccuracies in the calculated slippage protection value.\n\n## Vulnerability Detail\n\nIn the `RewardRouter.distributeRewards()` function, the protocol first sends the OP rewards to the OptimismRewardCollector contract, \n```solidity\n         TokenUtils.safeTransfer(IRewardCollector(rewards[vault].rewardCollectorAddress).rewardToken(), rewards[vault].rewardCollectorAddress, amountToSend);\n            rewards[vault].lastRewardBlock = block.number;\n            rewards[vault].rewardPaid += amountToSend;\n\n```\n\n\nthen calls the `RewardCollector.claimAndDonateRewards()` function to convert OP into alUSD or alETH. \n```solidity\n        return IRewardCollector(rewards[vault].rewardCollectorAddress).claimAndDonateRewards(vault, IRewardCollector(rewards[vault].rewardCollectorAddress).getExpectedExchange(vault) * slippageBPS / BPS);\n\n\n```\n\nDuring the conversion process, there is a parameter for slippage protection, which is calculated using `OptimismRewardCollector.getExpectedExchange() * slippageBPS / BPS`. Let's take a look at the `getExpectedExchange()` function. In this function, the protocol retrieves the prices of optoUSD and optoETH from Chainlink.\n\n```solidity\n        (\n            uint80 roundID,\n            int256 opToUsd,\n            ,\n            uint256 updateTime,\n            uint80 answeredInRound\n        ) = IChainlinkOracle(opToUsdOracle).latestRoundData();\n\n```\n```solidity\n    // Ensure that round is complete, otherwise price is stale.\n        (\n            uint80 roundIDEth,\n            int256 ethToUsd,\n            ,\n            uint256 updateTimeEth,\n            uint80 answeredInRoundEth\n        ) = IChainlinkOracle(ethToUsdOracle).latestRoundData();\n\n```\n\n If `debtToken == alUsdOptimism`, the expectedExchange for slippage protection is calculated as totalToSwap * uint(opToUsd) / 1e8. \n```solidity\n     // Find expected amount out before calling harvest\n        if (debtToken == alUsdOptimism) {\n            expectedExchange = totalToSwap * uint(opToUsd) / 1e8;\n\n```\n\nIf debtToken == alEthOptimism, the expectedExchange for slippage protection is calculated as totalToSwap * uint(uint(opToUsd)) / uint(ethToUsd). \n```solidity\n  else if (debtToken == alEthOptimism) {\n            expectedExchange = totalToSwap * uint(uint(opToUsd)) / uint(ethToUsd);\n\n```\n\nHere, we observe that the `expectedExchange` is calculated based on the value of OP relative to USD and OP relative to ETH, while the protocol intends to exchange for alUSD and alETH. \n```solidity\n if (debtToken == 0xCB8FA9a76b8e203D8C3797bF438d8FB81Ea3326A) {\n            // Velodrome Swap Routes: OP -> USDC -> alUSD\n            IVelodromeSwapRouter.route[] memory routes = new IVelodromeSwapRouter.route[](2);\n            routes[0] = IVelodromeSwapRouter.route(0x4200000000000000000000000000000000000042, 0x7F5c764cBc14f9669B88837ca1490cCa17c31607, false);\n            routes[1] = IVelodromeSwapRouter.route(0x7F5c764cBc14f9669B88837ca1490cCa17c31607, 0xCB8FA9a76b8e203D8C3797bF438d8FB81Ea3326A, true);\n            TokenUtils.safeApprove(rewardToken, swapRouter, amountRewardToken);\n            IVelodromeSwapRouter(swapRouter).swapExactTokensForTokens(amountRewardToken, minimumAmountOut, routes, address(this), block.timestamp);\n        } else if (debtToken == 0x3E29D3A9316dAB217754d13b28646B76607c5f04) {\n            // Velodrome Swap Routes: OP -> alETH\n            IVelodromeSwapRouter.route[] memory routes = new IVelodromeSwapRouter.route[](1);\n            routes[0] = IVelodromeSwapRouter.route(0x4200000000000000000000000000000000000042, 0x3E29D3A9316dAB217754d13b28646B76607c5f04, false);\n            TokenUtils.safeApprove(rewardToken, swapRouter, amountRewardToken);\n            IVelodromeSwapRouter(swapRouter).swapExactTokensForTokens(amountRewardToken, minimumAmountOut, routes, address(this), block.timestamp);\n        } \n\n```\n\nHowever, the price of alUSD is not equivalent to USD, and the price of alETH is not equivalent to ETH. This discrepancy leads to inaccuracies in the calculated value for slippage protection, making the protocol vulnerable to sandwich attacks.\n\n## Impact\nThe protocol is susceptible to sandwich attacks.\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-04-alchemix/blob/main/v2-foundry/src/utils/collectors/OptimismRewardCollector.sol#L120-L126\n\n## Tool used\n\nManual Review\n\n## Recommendation\nCalculate using the correct prices.\n\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/alchemix-finance/v2-foundry/commit/f0e7530cde2c006fd13c7c34b695113679a9655b\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/273",
  "Code": [
    {
      "filename": "v2-foundry/src/utils/collectors/OptimismRewardCollector.sol",
      "content": "pragma solidity ^0.8.13;\n\nimport {IERC20} from \"../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport {TokenUtils} from \"../../libraries/TokenUtils.sol\";\n\nimport {IAlchemistV2} from \"../../interfaces/IAlchemistV2.sol\";\nimport {IVelodromeSwapRouter} from \"../../interfaces/external/velodrome/IVelodromeSwapRouter.sol\";\nimport {Unauthorized, IllegalState, IllegalArgument} from \"../../base/ErrorMessages.sol\";\n\nimport \"../../interfaces/external/chainlink/IChainlinkOracle.sol\";\n\n\nimport \"../../interfaces/IRewardCollector.sol\";\nimport \"../../libraries/Sets.sol\";\nimport \"../../libraries/TokenUtils.sol\";\nimport \"../../../lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\n\n\nstruct InitializationParams {\n    address alchemist;\n    address debtToken;\n    address rewardRouter;\n    address rewardToken;\n    address swapRouter;\n}\n\n/// @title  RewardCollectorOptimism\n/// @author Alchemix Finance\ncontract OptimismRewardCollector is IRewardCollector, Ownable {\n    address constant aaveIncentives = 0x929EC64c34a17401F460460D4B9390518E5B473e;\n    address constant alUsdOptimism = 0xCB8FA9a76b8e203D8C3797bF438d8FB81Ea3326A;\n    address constant alEthOptimism = 0x3E29D3A9316dAB217754d13b28646B76607c5f04;\n    address constant opToUsdOracle = 0x0D276FC14719f9292D5C1eA2198673d1f4269246;\n    address constant ethToUsdOracle = 0x13e3Ee699D1909E989722E753853AE30b17e08c5;\n\n    uint256 constant FIXED_POINT_SCALAR = 1e18;\n    uint256 constant BPS = 10000;\n    string public override version = \"1.1.0\";\n    address public alchemist;\n    address public debtToken;\n    address public rewardRouter;\n    address public override rewardToken;\n    address public override swapRouter;\n\n    constructor(InitializationParams memory params) {\n        alchemist       = params.alchemist;\n        debtToken       = params.debtToken;\n        rewardToken     = params.rewardToken;\n        rewardRouter    = params.rewardRouter;\n        swapRouter      = params.swapRouter;\n    }\n\n    function setRewardRouter(address _rewardRouter) external onlyOwner {\n        rewardRouter = _rewardRouter;\n    }\n\n    function claimAndDonateRewards(address token, uint256 minimumAmountOut) external returns (uint256) {\n        require(msg.sender == rewardRouter, \"Must be Reward Router\"); \n\n        // Amount of reward token claimed plus any sent to this contract from grants.\n        uint256 amountRewardToken = IERC20(rewardToken).balanceOf(address(this));\n\n        if (amountRewardToken == 0) return 0;\n\n        if (debtToken == 0xCB8FA9a76b8e203D8C3797bF438d8FB81Ea3326A) {\n            // Velodrome Swap Routes: OP -> USDC -> alUSD\n            IVelodromeSwapRouter.Route[] memory routes = new IVelodromeSwapRouter.Route[](2);\n            routes[0] = IVelodromeSwapRouter.Route(0x4200000000000000000000000000000000000042, 0x7F5c764cBc14f9669B88837ca1490cCa17c31607, false, 0xF1046053aa5682b4F9a81b5481394DA16BE5FF5a);\n            routes[1] = IVelodromeSwapRouter.Route(0x7F5c764cBc14f9669B88837ca1490cCa17c31607, 0xCB8FA9a76b8e203D8C3797bF438d8FB81Ea3326A, true, 0xF1046053aa5682b4F9a81b5481394DA16BE5FF5a);\n            TokenUtils.safeApprove(rewardToken, swapRouter, amountRewardToken);\n            IVelodromeSwapRouter(swapRouter).swapExactTokensForTokens(amountRewardToken, minimumAmountOut, routes, address(this), block.timestamp);\n        } else if (debtToken == 0x3E29D3A9316dAB217754d13b28646B76607c5f04) {\n            // Velodrome Swap Routes: OP -> alETH\n            IVelodromeSwapRouter.Route[] memory routes = new IVelodromeSwapRouter.Route[](2);\n            routes[0] = IVelodromeSwapRouter.Route(0x4200000000000000000000000000000000000042, 0x4200000000000000000000000000000000000006, false, 0xF1046053aa5682b4F9a81b5481394DA16BE5FF5a);\n            routes[1] = IVelodromeSwapRouter.Route(0x4200000000000000000000000000000000000006, 0x3E29D3A9316dAB217754d13b28646B76607c5f04, true, 0xF1046053aa5682b4F9a81b5481394DA16BE5FF5a);\n            TokenUtils.safeApprove(rewardToken, swapRouter, amountRewardToken);\n            IVelodromeSwapRouter(swapRouter).swapExactTokensForTokens(amountRewardToken, minimumAmountOut, routes, address(this), block.timestamp);\n        } else {\n            revert IllegalState(\"Reward collector `debtToken` is not supported\");\n        }\n\n        // Donate to alchemist depositors\n        uint256 debtReturned = IERC20(debtToken).balanceOf(address(this));\n        TokenUtils.safeApprove(debtToken, alchemist, debtReturned);\n        IAlchemistV2(alchemist).donate(token, debtReturned);\n\n        return amountRewardToken;\n    }\n\n    function getExpectedExchange(address yieldToken) external view returns (uint256) {\n        uint256 expectedExchange;\n        address[] memory token = new address[](1);\n        uint256 totalToSwap = TokenUtils.safeBalanceOf(rewardToken, address(this));\n\n        // Ensure that round is complete, otherwise price is stale.\n        (\n            uint80 roundID,\n            int256 opToUsd,\n            ,\n            uint256 updateTime,\n            uint80 answeredInRound\n        ) = IChainlinkOracle(opToUsdOracle).latestRoundData();\n        \n        require(\n            opToUsd > 0, \n            \"Chainlink Malfunction\"\n        );\n\n        if( updateTime < block.timestamp - 1200 seconds ) {\n            revert(\"Chainlink Malfunction\");\n        }\n\n        // Ensure that round is complete, otherwise price is stale.\n        (\n            uint80 roundIDEth,\n            int256 ethToUsd,\n            ,\n            uint256 updateTimeEth,\n            uint80 answeredInRoundEth\n        ) = IChainlinkOracle(ethToUsdOracle).latestRoundData();\n        \n        require(\n            ethToUsd > 0, \n            \"Chainlink Malfunction\"\n        );\n\n        if( updateTimeEth < block.timestamp - 1200 seconds ) {\n            revert(\"Chainlink Malfunction\");\n        }\n\n        // Find expected amount out before calling harvest\n        if (debtToken == alUsdOptimism) {\n            expectedExchange = totalToSwap * uint(opToUsd) / 1e8;\n        } else if (debtToken == alEthOptimism) {\n            expectedExchange = totalToSwap * uint(uint(opToUsd)) / uint(ethToUsd);\n        } else {\n            revert IllegalState(\"Invalid debt token\");\n        }\n\n        return expectedExchange;\n    }\n}"
    }
  ]
}