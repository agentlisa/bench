{
  "Title": "[M-08] Token guardian protection doesn't account for approved operators in `approve()`",
  "Content": "\nAccording to the [README](https://github.com/code-423n4/2023-07-lens/tree/main#definition-of-words-and-terms-in-lens-codebase), when an address has token guardian enabled, approvals should not work for the tokens owned by that address:\n\n> **Token Guardian:** Protection mechanism for the tokens held by an address, which restricts transfers and approvals when enabled. See [LIP-4](https://github.com/lens-protocol/LIPs/blob/main/LIPs/lip-4.md) for more.\n\nIn `LensHandles.sol`, token guardian is enforced by the `_hasTokenGuardianEnabled()` check in the `approve()` function:\n\n[LensHandles.sol#L139-L145](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/namespaces/LensHandles.sol#L139-L145)\n\n```solidity\n    function approve(address to, uint256 tokenId) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (to != address(0) && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n```\n\nHowever, this check is inadequate as approved operators (addresses approved using `setApprovalForAll()` by the owner) are also allowed to call `approve()`. We can see this in Openzeppelin's ERC-721 implementation:\n\n[ERC721.sol#L116-L119](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/token/ERC721/ERC721.sol#L116-L119)\n\n```solidity\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n```\n\nAs such, even if an owner has token guardian enabled, approvals can still be set for his tokens by other approved operators, leaving the owner's tokens vulnerable. For example:\n\n*   Alice sets Bob as an approved operator using `setApprovalForAll()`.\n*   Alice enables token guardian using `enableTokenGuardian()`.\n*   If Bob wants to set approvals for Alice's tokens, he can do so by:\n    *   Disabling his own token guardian using `DANGER__disableTokenGuardian()`.\n    *   Calling `approve()` for Alice's tokens. This will still work, even though Alice has token guardian enabled.\n\nNote that the `approve()` function in `LensProfiles.sol` also has the same vulnerability.\n\n### Impact\n\nAs token guardian protection in `approve()` does not account for approved operators, although an owner has token guardian enabled, approved operators will still be able to set approvals for his tokens.\n\n### Proof of Concept\n\nThe following Foundry test demonstrates the example above:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport 'forge-std/Test.sol';\nimport '../contracts/namespaces/LensHandles.sol';\n\ncontract TokenGuardian_POC is Test {\n    LensHandles lensHandles;\n\n    address ALICE;\n    address BOB;\n    uint256 tokenId;\n\n    function setUp() public {\n        // Setup LensHandles contract\n        lensHandles = new LensHandles(address(this), address(0), 0);\n\n        // Setup Alice and Bob addresses\n        ALICE = makeAddr(\"Alice\");\n        BOB = makeAddr(\"Bob\");\n\n        // Mint \"alice.lens\" to Alice\n        tokenId = lensHandles.mintHandle(ALICE, \"alice\");\n    }\n    \n    function testCanApproveWhileTokenGuardianEnabled() public {\n        // Alice disables tokenGuardian to set Bob as an approved operator\n        vm.startPrank(ALICE);\n        lensHandles.DANGER__disableTokenGuardian();\n        lensHandles.setApprovalForAll(BOB, true);\n\n        // Alice re-enables tokenGuardian\n        lensHandles.enableTokenGuardian();\n        vm.stopPrank();\n\n        // Bob disables tokenGuardian for himself\n        vm.startPrank(BOB);\n        lensHandles.DANGER__disableTokenGuardian();\n\n        // Alice still has tokenGuardian enabled\n        assertEq(lensHandles.getTokenGuardianDisablingTimestamp(ALICE), 0);\n\n        // However, Bob can still set approvals for Alice's handle\n        lensHandles.approve(address(0x1337), tokenId);\n        vm.stopPrank();\n        assertEq(lensHandles.getApproved(tokenId), address(0x1337));\n    }\n}\n```\n\n### Recommended Mitigation\n\nConsider checking if the token's owner has token guardian enabled as well:\n\n[LensHandles.sol#L139-L145](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/namespaces/LensHandles.sol#L139-L145)\n\n```diff\n    function approve(address to, uint256 tokenId) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n-       if (to != address(0) && _hasTokenGuardianEnabled(msg.sender)) {\n+       if (to != address(0) && (_hasTokenGuardianEnabled(msg.sender) || _hasTokenGuardianEnabled(_ownerOf(tokenId)))) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n```\n\n### Assessed type\n\nAccess Control\n\n**[donosonaumczuk (Lens) commented via duplicate issue `#90`](https://github.com/code-423n4/2023-07-lens-findings/issues/90#issuecomment-1667731698):**\n > This is Medium as assets cannot be stolen directly, but it requires a hypothetical attack path with stated assumptions.\n> \n> Note that the transferFrom function is not compromised itself, thus the victim could revoke the approval of the operator and the approvals from the assets before disabling the token guardian, and be safe.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/namespaces/LensHandles.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {ImmutableOwnable} from 'contracts/misc/ImmutableOwnable.sol';\nimport {ILensHandles} from 'contracts/interfaces/ILensHandles.sol';\nimport {HandlesEvents} from 'contracts/namespaces/constants/Events.sol';\nimport {HandlesErrors} from 'contracts/namespaces/constants/Errors.sol';\nimport {HandleTokenURILib} from 'contracts/libraries/token-uris/HandleTokenURILib.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * A handle is defined as a local name inside a namespace context. A handle is represented as the local name with its\n * namespace applied as a suffix, using the dot symbol as separator.\n *\n *      handle = ${localName}.${namespace}\n *\n * Handle and local name can be used interchangeably once you are in a context of a namespace, as it became redundant.\n *\n *      handle === ${localName} ; inside some namespace.\n */\ncontract LensHandles is ERC721, ImmutableOwnable, ILensHandles {\n    using Address for address;\n\n    uint256 internal constant MAX_HANDLE_LENGTH = 31;\n    string internal constant NAMESPACE = 'lens';\n    uint256 internal immutable NAMESPACE_LENGTH = bytes(NAMESPACE).length;\n    uint256 internal constant SEPARATOR_LENGTH = 1; // bytes('.').length;\n    bytes32 internal constant NAMESPACE_HASH = keccak256(bytes(NAMESPACE));\n    uint256 internal immutable TOKEN_GUARDIAN_COOLDOWN;\n\n    mapping(address => uint256) internal _tokenGuardianDisablingTimestamp;\n\n    mapping(uint256 tokenId => string localName) internal _localNames;\n\n    modifier onlyOwnerOrWhitelistedProfileCreator() {\n        if (\n            msg.sender != OWNER && !ILensHub(LENS_HUB).isProfileCreatorWhitelisted(msg.sender)\n        ) {\n            revert HandlesErrors.NotOwnerNorWhitelisted();\n        }\n        _;\n    }\n\n    modifier onlyEOA() {\n        if (msg.sender.isContract()) {\n            revert HandlesErrors.NotEOA();\n        }\n        _;\n    }\n\n    modifier onlyHub() {\n        if (msg.sender != LENS_HUB) {\n            revert HandlesErrors.NotHub();\n        }\n        _;\n    }\n\n    constructor(\n        address owner,\n        address lensHub,\n        uint256 tokenGuardianCooldown\n    ) ERC721('', '') ImmutableOwnable(owner, lensHub) {\n        TOKEN_GUARDIAN_COOLDOWN = tokenGuardianCooldown;\n    }\n\n    function name() public pure override returns (string memory) {\n        return string.concat(symbol(), ' Handles');\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return string.concat('.', NAMESPACE);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireMinted(tokenId);\n        return HandleTokenURILib.getTokenURI(tokenId, _localNames[tokenId]);\n    }\n\n    /// @inheritdoc ILensHandles\n    function mintHandle(address to, string calldata localName)\n        external\n        onlyOwnerOrWhitelistedProfileCreator\n        returns (uint256)\n    {\n        _validateLocalName(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function migrateHandle(address to, string calldata localName) external onlyHub returns (uint256) {\n        _validateLocalNameMigration(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function burn(uint256 tokenId) external {\n        if (msg.sender != ownerOf(tokenId)) {\n            revert HandlesErrors.NotOwner();\n        }\n        _burn(tokenId);\n        delete _localNames[tokenId];\n    }\n\n    /// ************************************\n    /// ****  TOKEN GUARDIAN FUNCTIONS  ****\n    /// ************************************\n\n    function DANGER__disableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] != 0) {\n            revert HandlesErrors.DisablingAlreadyTriggered();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = block.timestamp + TOKEN_GUARDIAN_COOLDOWN;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: false,\n            tokenGuardianDisablingTimestamp: block.timestamp + TOKEN_GUARDIAN_COOLDOWN,\n            timestamp: block.timestamp\n        });\n    }\n\n    function enableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] == 0) {\n            revert HandlesErrors.AlreadyEnabled();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = 0;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: true,\n            tokenGuardianDisablingTimestamp: 0,\n            timestamp: block.timestamp\n        });\n    }\n\n    function approve(address to, uint256 tokenId) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (to != address(0) && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (approved && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.setApprovalForAll(operator, approved);\n    }\n\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function getNamespace() external pure returns (string memory) {\n        return NAMESPACE;\n    }\n\n    function getNamespaceHash() external pure returns (bytes32) {\n        return NAMESPACE_HASH;\n    }\n\n    // TODO: Should we revert if it doesn't exist?\n    function getLocalName(uint256 tokenId) public view returns (string memory) {\n        string memory localName = _localNames[tokenId];\n        if (bytes(localName).length == 0) {\n            revert HandlesErrors.DoesNotExist();\n        }\n        return _localNames[tokenId];\n    }\n\n    // TODO: Should we revert if it doesn't exist?\n    function getHandle(uint256 tokenId) public view returns (string memory) {\n        string memory localName = getLocalName(tokenId);\n        return string.concat(localName, '.', NAMESPACE);\n    }\n\n    function getTokenId(string memory localName) public pure returns (uint256) {\n        return uint256(keccak256(bytes(localName)));\n    }\n\n    function getTokenGuardianDisablingTimestamp(address wallet) external view returns (uint256) {\n        return _tokenGuardianDisablingTimestamp[wallet];\n    }\n\n    //////////////////////////////////////\n    ///        INTERNAL FUNCTIONS      ///\n    //////////////////////////////////////\n\n    function _mintHandle(address to, string calldata localName) internal returns (uint256) {\n        uint256 tokenId = getTokenId(localName);\n        _mint(to, tokenId);\n        _localNames[tokenId] = localName;\n        emit HandlesEvents.HandleMinted(localName, NAMESPACE, tokenId, to, block.timestamp);\n        return tokenId;\n    }\n\n    function _validateLocalNameMigration(string memory localName) internal view {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength + SEPARATOR_LENGTH + NAMESPACE_LENGTH > MAX_HANDLE_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        bytes1 firstByte = localNameAsBytes[0];\n        if (firstByte == '-' || firstByte == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '-' && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _validateLocalName(string memory localName) internal view {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength + SEPARATOR_LENGTH + NAMESPACE_LENGTH > MAX_HANDLE_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        if (localNameAsBytes[0] == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _isAlphaNumeric(bytes1 char) internal pure returns (bool) {\n        return (char >= '0' && char <= '9') || (char >= 'a' && char <= 'z');\n    }\n\n    function _hasTokenGuardianEnabled(address wallet) internal view returns (bool) {\n        return\n            !wallet.isContract() &&\n            (_tokenGuardianDisablingTimestamp[wallet] == 0 ||\n                block.timestamp < _tokenGuardianDisablingTimestamp[wallet]);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* firstTokenId */,\n        uint256 batchSize\n    ) internal override {\n        if (from != address(0) && _hasTokenGuardianEnabled(from)) {\n            // Cannot transfer handle if the guardian is enabled, except at minting time.\n            revert HandlesErrors.GuardianEnabled();\n        }\n\n        super._beforeTokenTransfer(from, to, 0, batchSize);\n    }\n}"
    },
    {
      "filename": "contracts/token/ERC721/ERC721.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}"
    },
    {
      "filename": "contracts/namespaces/LensHandles.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {ImmutableOwnable} from 'contracts/misc/ImmutableOwnable.sol';\nimport {ILensHandles} from 'contracts/interfaces/ILensHandles.sol';\nimport {HandlesEvents} from 'contracts/namespaces/constants/Events.sol';\nimport {HandlesErrors} from 'contracts/namespaces/constants/Errors.sol';\nimport {HandleTokenURILib} from 'contracts/libraries/token-uris/HandleTokenURILib.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * A handle is defined as a local name inside a namespace context. A handle is represented as the local name with its\n * namespace applied as a suffix, using the dot symbol as separator.\n *\n *      handle = ${localName}.${namespace}\n *\n * Handle and local name can be used interchangeably once you are in a context of a namespace, as it became redundant.\n *\n *      handle === ${localName} ; inside some namespace.\n */\ncontract LensHandles is ERC721, ImmutableOwnable, ILensHandles {\n    using Address for address;\n\n    uint256 internal constant MAX_HANDLE_LENGTH = 31;\n    string internal constant NAMESPACE = 'lens';\n    uint256 internal immutable NAMESPACE_LENGTH = bytes(NAMESPACE).length;\n    uint256 internal constant SEPARATOR_LENGTH = 1; // bytes('.').length;\n    bytes32 internal constant NAMESPACE_HASH = keccak256(bytes(NAMESPACE));\n    uint256 internal immutable TOKEN_GUARDIAN_COOLDOWN;\n\n    mapping(address => uint256) internal _tokenGuardianDisablingTimestamp;\n\n    mapping(uint256 tokenId => string localName) internal _localNames;\n\n    modifier onlyOwnerOrWhitelistedProfileCreator() {\n        if (\n            msg.sender != OWNER && !ILensHub(LENS_HUB).isProfileCreatorWhitelisted(msg.sender)\n        ) {\n            revert HandlesErrors.NotOwnerNorWhitelisted();\n        }\n        _;\n    }\n\n    modifier onlyEOA() {\n        if (msg.sender.isContract()) {\n            revert HandlesErrors.NotEOA();\n        }\n        _;\n    }\n\n    modifier onlyHub() {\n        if (msg.sender != LENS_HUB) {\n            revert HandlesErrors.NotHub();\n        }\n        _;\n    }\n\n    constructor(\n        address owner,\n        address lensHub,\n        uint256 tokenGuardianCooldown\n    ) ERC721('', '') ImmutableOwnable(owner, lensHub) {\n        TOKEN_GUARDIAN_COOLDOWN = tokenGuardianCooldown;\n    }\n\n    function name() public pure override returns (string memory) {\n        return string.concat(symbol(), ' Handles');\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return string.concat('.', NAMESPACE);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireMinted(tokenId);\n        return HandleTokenURILib.getTokenURI(tokenId, _localNames[tokenId]);\n    }\n\n    /// @inheritdoc ILensHandles\n    function mintHandle(address to, string calldata localName)\n        external\n        onlyOwnerOrWhitelistedProfileCreator\n        returns (uint256)\n    {\n        _validateLocalName(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function migrateHandle(address to, string calldata localName) external onlyHub returns (uint256) {\n        _validateLocalNameMigration(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function burn(uint256 tokenId) external {\n        if (msg.sender != ownerOf(tokenId)) {\n            revert HandlesErrors.NotOwner();\n        }\n        _burn(tokenId);\n        delete _localNames[tokenId];\n    }\n\n    /// ************************************\n    /// ****  TOKEN GUARDIAN FUNCTIONS  ****\n    /// ************************************\n\n    function DANGER__disableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] != 0) {\n            revert HandlesErrors.DisablingAlreadyTriggered();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = block.timestamp + TOKEN_GUARDIAN_COOLDOWN;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: false,\n            tokenGuardianDisablingTimestamp: block.timestamp + TOKEN_GUARDIAN_COOLDOWN,\n            timestamp: block.timestamp\n        });\n    }\n\n    function enableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] == 0) {\n            revert HandlesErrors.AlreadyEnabled();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = 0;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: true,\n            tokenGuardianDisablingTimestamp: 0,\n            timestamp: block.timestamp\n        });\n    }\n\n    function approve(address to, uint256 tokenId) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (to != address(0) && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (approved && _hasTokenGuardianEnabled(msg.sender)) {\n            revert Hand"
    }
  ]
}