{
  "Title": "[C02] Any owner of the Multisig can execute unconfirmed transactions",
  "Content": "The Celo project has a custom implementation of a [MultiSig](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol) wallet. This contract gives allowance to a group of accounts, known as owners, to submit, confirm, and execute transactions to other smart contracts, or to itself. It also defines a maximum number of 50 owners.\n\n\nFor a transaction to be executed, there must be a minimum number of owners that have to confirm it after it is submitted. This minimum is defined by the [`required`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L36) variable.\n\n\nThe contract provides a group of functions for [adding new owners](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L126), [removing](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L140) and [replacing](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L155) already existent owners. When a new owner is added, it will be pushed to the [`owners`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L35) array, and will be mapped in [`isOwner`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L34) mapping to `true`. Some restrictions defined in these functions are:\n\n\n* An already existent owner cannot be added twice\n* An owner cannot be removed if they are not part of the multisig\n* An existent owner cannot be replaced by another existent owner\n* A non-existent owner cannot be replaced by another owner\n\n\nThe `isOwner` and `owners` variables can get out of sync when the last added owner is replaced. In this case it is possible to set the `newOwner` as `true` and the `owner` as `false` in the `isOwner` mapping, but not replace it in the `owners` array.\n\n\nWhen this happens, the whole logic of the contract gets broken as these two variables are used throughout the contract interchangeably to check whether a specific account possess ownership over the wallet, and whether they have confirmed transactions to be executed. The Multisig wallet will:\n\n\n* Allow any owner to execute unconfirmed transactions\n* Not be able to reach the `requirement` value in future transactions, and therefore not be able to execute transactions at all\n* Not be able to fully remove an owner from the Multisig\n* Change the number of required confirmations without enough confirmers\n* Show an unconfirmed transaction as confirmed\n* Show an unreal number of confirmations per transaction\n* Show an incorrect list of owners\n* Not be able to reach the `MAX_OWNER_COUNT` limit\n\n\nStep-by-step proof-of-concept exploits for some of the scenarios listed above can be found in [this private gist](https://gist.github.com/jcarpanelli/c4c24d5111a2752bdf13730e5e13b208).\n\n\nConsider reimplementing the `replaceOwner` function so it can handle the replacement of the last added owner, by removing the `-1` in the break condition of the [`for loop`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L162).\n\n\n***Update:** Fixed in [pull request #2808](https://github.com/celo-org/celo-monorepo/pull/2808). The [`replaceOwner` function now handles the replacement of the last added owner](https://github.com/celo-org/celo-monorepo/pull/2808/files#diff-6e01ecc58691e01e9952938140664a3bR162). A regression unit test was added in [pull request #3351](https://github.com/celo-org/celo-monorepo/pull/3351/files#diff-98e2c5b79b4dd0cabb54febef4e67675R174). cLabs’ statement for this issue:*\n\n\n\n> \n> *The team working on Celo chose to use the Gnosis multisig implementation, rather than build a new one, in order to use proven, audited code. But as mentioned on N18, there’s no actual process to verify this on a regular basis, which will be addressed as stated in the N18 response.*\n> \n> \n> \n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/MultiSig.sol",
      "content": "pragma solidity ^0.5.3;\n/* solhint-disable no-inline-assembly, avoid-low-level-calls, func-name-mixedcase, func-order */\n\nimport \"./Initializable.sol\";\nimport \"./libraries/AddressesHelper.sol\";\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before\n/// execution.\n/// @author Stefan George - <stefan.george@consensys.net>\ncontract MultiSig is Initializable {\n  /*\n   *  Events\n   */\n  event Confirmation(address indexed sender, uint256 indexed transactionId);\n  event Revocation(address indexed sender, uint256 indexed transactionId);\n  event Submission(uint256 indexed transactionId);\n  event Execution(uint256 indexed transactionId);\n  event ExecutionFailure(uint256 indexed transactionId);\n  event Deposit(address indexed sender, uint256 value);\n  event OwnerAddition(address indexed owner);\n  event OwnerRemoval(address indexed owner);\n  event RequirementChange(uint256 required);\n\n  /*\n   *  Constants\n   */\n  uint256 public constant MAX_OWNER_COUNT = 50;\n\n  /*\n   *  Storage\n   */\n  mapping(uint256 => Transaction) public transactions;\n  mapping(uint256 => mapping(address => bool)) public confirmations;\n  mapping(address => bool) public isOwner;\n  address[] public owners;\n  uint256 public required;\n  uint256 public transactionCount;\n\n  struct Transaction {\n    address destination;\n    uint256 value;\n    bytes data;\n    bool executed;\n  }\n\n  /*\n   *  Modifiers\n   */\n  modifier onlyWallet() {\n    require(msg.sender == address(this), \"msg.sender was not multisig wallet\");\n    _;\n  }\n\n  modifier ownerDoesNotExist(address owner) {\n    require(!isOwner[owner], \"owner already existed\");\n    _;\n  }\n\n  modifier ownerExists(address owner) {\n    require(isOwner[owner], \"owner does not exist\");\n    _;\n  }\n\n  modifier transactionExists(uint256 transactionId) {\n    require(transactions[transactionId].destination != address(0), \"transaction does not exist\");\n    _;\n  }\n\n  modifier confirmed(uint256 transactionId, address owner) {\n    require(confirmations[transactionId][owner], \"transaction was not confirmed for owner\");\n    _;\n  }\n\n  modifier notConfirmed(uint256 transactionId, address owner) {\n    require(!confirmations[transactionId][owner], \"transaction was already confirmed for owner\");\n    _;\n  }\n\n  modifier notExecuted(uint256 transactionId) {\n    require(!transactions[transactionId].executed, \"transaction was executed already\");\n    _;\n  }\n\n  modifier notNull(address _address) {\n    require(_address != address(0), \"address was null\");\n    _;\n  }\n\n  modifier validRequirement(uint256 ownerCount, uint256 _required) {\n    require(\n      ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0,\n      \"invalid requirement\"\n    );\n    _;\n  }\n\n  /// @dev Fallback function allows to deposit ether.\n  function() external payable {\n    if (msg.value > 0) emit Deposit(msg.sender, msg.value);\n  }\n\n  /*\n   * Public functions\n   */\n  /// @dev Contract constructor sets initial owners and required number of confirmations.\n  /// @param _owners List of initial owners.\n  /// @param _required Number of required confirmations.\n  function initialize(address[] calldata _owners, uint256 _required)\n    external\n    initializer\n    validRequirement(_owners.length, _required)\n  {\n    for (uint256 i = 0; i < _owners.length; i++) {\n      require(\n        !isOwner[_owners[i]] && _owners[i] != address(0),\n        \"owner was null or already given owner status\"\n      );\n      isOwner[_owners[i]] = true;\n    }\n    owners = _owners;\n    required = _required;\n  }\n\n  /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n  /// @param owner Address of new owner.\n  function addOwner(address owner)\n    external\n    onlyWallet\n    ownerDoesNotExist(owner)\n    notNull(owner)\n    validRequirement(owners.length + 1, required)\n  {\n    isOwner[owner] = true;\n    owners.push(owner);\n    emit OwnerAddition(owner);\n  }\n\n  /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n  /// @param owner Address of owner.\n  function removeOwner(address owner) external onlyWallet ownerExists(owner) {\n    isOwner[owner] = false;\n    for (uint256 i = 0; i < owners.length - 1; i++)\n      if (owners[i] == owner) {\n        owners[i] = owners[owners.length - 1];\n        break;\n      }\n    owners.length -= 1;\n    if (required > owners.length) changeRequirement(owners.length);\n    emit OwnerRemoval(owner);\n  }\n\n  /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n  /// @param owner Address of owner to be replaced.\n  /// @param newOwner Address of new owner.\n  function replaceOwner(address owner, address newOwner)\n    external\n    onlyWallet\n    ownerExists(owner)\n    notNull(newOwner)\n    ownerDoesNotExist(newOwner)\n  {\n    for (uint256 i = 0; i < owners.length - 1; i++)\n      if (owners[i] == owner) {\n        owners[i] = newOwner;\n        break;\n      }\n    isOwner[owner] = false;\n    isOwner[newOwner] = true;\n    emit OwnerRemoval(owner);\n    emit OwnerAddition(newOwner);\n  }\n\n  /// @dev Allows to change the number of required confirmations. Transaction has to be sent by\n  /// wallet.\n  /// @param _required Number of required confirmations.\n  function changeRequirement(uint256 _required)\n    public\n    onlyWallet\n    validRequirement(owners.length, _required)\n  {\n    required = _required;\n    emit RequirementChange(_required);\n  }\n\n  /// @dev Allows an owner to submit and confirm a transaction.\n  /// @param destination Transaction target address.\n  /// @param value Transaction ether value.\n  /// @param data Transaction data payload.\n  /// @return Returns transaction ID.\n  function submitTransaction(address destination, uint256 value, bytes calldata data)\n    external\n    returns (uint256 transactionId)\n  {\n    transactionId = addTransaction(destination, value, data);\n    confirmTransaction(transactionId);\n  }\n\n  /// @dev Allows an owner to confirm a transaction.\n  /// @param transactionId Transaction ID.\n  function confirmTransaction(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    transactionExists(transactionId)\n    notConfirmed(transactionId, msg.sender)\n  {\n    confirmations[transactionId][msg.sender] = true;\n    emit Confirmation(msg.sender, transactionId);\n    executeTransaction(transactionId);\n  }\n\n  /// @dev Allows an owner to revoke a confirmation for a transaction.\n  /// @param transactionId Transaction ID.\n  function revokeConfirmation(uint256 transactionId)\n    external\n    ownerExists(msg.sender)\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n  {\n    confirmations[transactionId][msg.sender] = false;\n    emit Revocation(msg.sender, transactionId);\n  }\n\n  /// @dev Allows anyone to execute a confirmed transaction.\n  /// @param transactionId Transaction ID.\n  function executeTransaction(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n  {\n    if (isConfirmed(transactionId)) {\n      Transaction storage txn = transactions[transactionId];\n      txn.executed = true;\n      if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n        emit Execution(transactionId);\n      else {\n        emit ExecutionFailure(transactionId);\n        txn.executed = false;\n      }\n    }\n  }\n\n  // call has been separated into its own function in order to take advantage\n  // of the Solidity's code generator to produce a loop that copies tx.data into memory.\n  function external_call(address destination, uint256 value, uint256 dataLength, bytes memory data)\n    private\n    returns (bool)\n  {\n    bool result;\n\n    if (dataLength > 0)\n      require(AddressesHelper.isContract(destination), \"Invalid contract address\");\n\n    /* solhint-disable max-line-length */\n    assembly {\n      let x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n      let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n      result := call(\n        sub(gas, 34710), // 34710 is the value that solidity is currently emitting\n        // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n        // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n        destination,\n        value,\n        d,\n        dataLength, // Size of the input (in bytes) - this is what fixes the padding problem\n        x,\n        0 // Output is ignored, therefore the output size is zero\n      )\n    }\n    /* solhint-enable max-line-length */\n    return result;\n  }\n\n  /// @dev Returns the confirmation status of a transaction.\n  /// @param transactionId Transaction ID.\n  /// @return Confirmation status.\n  function isConfirmed(uint256 transactionId) public view returns (bool) {\n    uint256 count = 0;\n    for (uint256 i = 0; i < owners.length; i++) {\n      if (confirmations[transactionId][owners[i]]) count += 1;\n      if (count == required) return true;\n    }\n  }\n\n  /*\n   * Internal functions\n   */\n  /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n  /// @param destination Transaction target address.\n  /// @param value Transaction ether value.\n  /// @param data Transaction data payload.\n  /// @return Returns transaction ID.\n  function addTransaction(address destination, uint256 value, bytes memory data)\n    internal\n    notNull(destination)\n    returns (uint256 transactionId)\n  {\n    transactionId = transactionCount;\n    transactions[transactionId] = Transaction({\n      destination: destination,\n      value: value,\n      data: data,\n      executed: false\n    });\n    transactionCount += 1;\n    emit Submission(transactionId);\n  }\n\n  /*\n   * Web3 call functions\n   */\n  /// @dev Returns number of confirmations of a transaction.\n  /// @param transactionId Transaction ID.\n  /// @return Number of confirmations.\n  function getConfirmationCount(uint256 transactionId) external view returns (uint256 count) {\n    for (uint256 i = 0; i < owners.length; i++)\n      if (confirmations[transactionId][owners[i]]) count += 1;\n  }\n\n  /// @dev Returns total number of transactions after filers are applied.\n  /// @param pending Include pending transactions.\n  /// @param executed Include executed transactions.\n  /// @return Total number of transactions after filters are applied.\n  function getTransactionCount(bool pending, bool executed) external view returns (uint256 count) {\n    for (uint256 i = 0; i < transactionCount; i++)\n      if ((pending && !transactions[i].executed) || (executed && transactions[i].executed))\n        count += 1;\n  }\n\n  /// @dev Returns list of owners.\n  /// @return List of owner addresses.\n  function getOwners() external view returns (address[] memory) {\n    return owners;\n  }\n\n  /// @dev Returns array with owner addresses, which confirmed transaction.\n  /// @param transactionId Transaction ID.\n  /// @return Returns array of owner addresses.\n  function getConfirmations(uint256 transactionId)\n    external\n    view\n    returns (address[] memory _confirmations)\n  {\n    address[] memory confirmationsTemp = new address[](owners.length);\n    uint256 count = 0;\n    uint256 i;\n    for (i = 0; i < owners.length; i++)\n      if (confirmations[transactionId][owners[i]]) {\n        confirmationsTemp[count] = owners[i];\n        count += 1;\n      }\n    _confirmations = new address[](count);\n    for (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\n  }\n\n  /// @dev Returns list of transaction IDs in defined range.\n  /// @param from Index start position of transaction array.\n  /// @param to Index end position of transaction array.\n  /// @param pending Include pending transactions.\n  /// @param executed Include executed transactions.\n  /// @return Returns array of transaction IDs.\n  function getTransactionIds(uint256 from, uint256 to, bool pending, bool executed)\n    external\n    view\n    returns (uint256[] memory _transactionIds)\n  {\n    uint256[] memory transactionIdsTemp = new uint256[](transactionCount);\n    uint256 count = 0;\n    uint256 i;\n    for (i = 0; i < transactionCount; i++)\n      if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\n        transactionIdsTemp[count] = i;\n        count += 1;\n      }\n    _transactionIds = new uint256[](to - from);\n    for (i = from; i < to; i++) _transactionIds[i - from] = transactionIdsTemp[i];\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/MultiSig.sol",
      "content": "pragma solidity ^0.5.3;\n/* solhint-disable no-inline-assembly, avoid-low-level-calls, func-name-mixedcase, func-order */\n\nimport \"./Initializable.sol\";\nimport \"./libraries/AddressesHelper.sol\";\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before\n/// execution.\n/// @author Stefan George - <stefan.george@consensys.net>\ncontract MultiSig is Initializable {\n  /*\n   *  Events\n   */\n  event Confirmation(address indexed sender, uint256 indexed transactionId);\n  event Revocation(address indexed sender, uint256 indexed transactionId);\n  event Submission(uint256 indexed transactionId);\n  event Execution(uint256 indexed transactionId);\n  event ExecutionFailure(uint256 indexed transactionId);\n  event Deposit(address indexed sender, uint256 value);\n  event OwnerAddition(address indexed owner);\n  event OwnerRemoval(address indexed owner);\n  event RequirementChange(uint256 required);\n\n  /*\n   *  Constants\n   */\n  uint256 public constant MAX_OWNER_COUNT = 50;\n\n  /*\n   *  Storage\n   */\n  mapping(uint256 => Transaction) public transactions;\n  mapping(uint256 => mapping(address => bool)) public confirmations;\n  mapping(address => bool) public isOwner;\n  address[] public owners;\n  uint256 public required;\n  uint256 public transactionCount;\n\n  struct Transaction {\n    address destination;\n    uint256 value;\n    bytes data;\n    bool executed;\n  }\n\n  /*\n   *  Modifiers\n   */\n  modifier onlyWallet() {\n    require(msg.sender == address(this), \"msg.sender was not multisig wallet\");\n    _;\n  }\n\n  modifier ownerDoesNotExist(address owner) {\n    require(!isOwner[owner], \"owner already existed\");\n    _;\n  }\n\n  modifier ownerExists(address owner) {\n    require(isOwner[owner], \"owner does not exist\");\n    _;\n  }\n\n  modifier transactionExists(uint256 transactionId) {\n    require(transactions[transactionId].destination != address(0), \"transaction does not exist\");\n    _;\n  }\n\n  modifier confirmed(uint256 transactionId, address owner) {\n    require(confirmations[transactionId][owner], \"transaction was not confirmed for owner\");\n    _;\n  }\n\n  modifier notConfirmed(uint256 transactionId, address owner) {\n    require(!confirmations[transactionId][owner], \"transaction was already confirmed for owner\");\n    _;\n  }\n\n  modifier notExecuted(uint256 transactionId) {\n    require(!transactions[transactionId].executed, \"transaction was executed already\");\n    _;\n  }\n\n  modifier notNull(address _address) {\n    require(_address != address(0), \"address was null\");\n    _;\n  }\n\n  modifier validRequirement(uint256 ownerCount, uint256 _required) {\n    require(\n      ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0,\n      \"invalid requirement\"\n    );\n    _;\n  }\n\n  /// @dev Fallback function allows to deposit ether.\n  function() external payable {\n    if (msg.value > 0) emit Deposit(msg.sender, msg.value);\n  }\n\n  /*\n   * Public functions\n   */\n  /// @dev Contract constructor sets initial owners and required number of confirmations.\n  /// @param _owners List of initial owners.\n  /// @param _required Number of required confirmations.\n  function initialize(address[] calldata _owners, uint256 _required)\n    external\n    initializer\n    validRequirement(_owners.length, _required)\n  {\n    for (uint256 i = 0; i < _owners.length; i++) {\n      require(\n        !isOwner[_owners[i]] && _owners[i] != address(0),\n        \"owner was null or already given owner status\"\n      );\n      isOwner[_owners[i]] = true;\n    }\n    owners = _owners;\n    required = _required;\n  }\n\n  /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n  /// @param owner Address of new owner.\n  function addOwner(address owner)\n    external\n    onlyWallet\n    ownerDoesNotExist(owner)\n    notNull(owner)\n    validRequirement(owners.length + 1, required)\n  {\n    isOwner[owner] = true;\n    owners.push(owner);\n    emit OwnerAddition(owner);\n  }\n\n  /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n  /// @param owner Address of owner.\n  function removeOwner(address owner) external onlyWallet ownerExists(owner) {\n    isOwner[owner] = false;\n    for (uint256 i = 0; i < owners.length - 1; i++)\n      if (owners[i] == owner) {\n        owners[i] = owners[owners.length - 1];\n        break;\n      }\n    owners.length -= 1;\n    if (required > owners.length) changeRequirement(owners.length);\n    emit OwnerRemoval(owner);\n  }\n\n  /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n  /// @param owner Address of owner to be replaced.\n  /// @param newOwner Address of new owner.\n  function replaceOwner(address owner, address newOwner)\n    external\n    onlyWallet\n    ownerExists(owner)\n    notNull(newOwner)\n    ownerDoesNotExist(newOwner)\n  {\n    for (uint256 i = 0; i < owners.length - 1; i++)\n      if (owners[i] == owner) {\n        owners[i] = newOwner;\n        break;\n      }\n    isOwner[owner] = false;\n    isOwner[newOwner] = true;\n    emit OwnerRemoval(owner);\n    emit OwnerAddition(newOwner);\n  }\n\n  /// @dev Allows to change the number of required confirmations. Transaction has to be sent by\n  /// wallet.\n  /// @param _required Number of required confirmations.\n  function changeRequirement(uint256 _required)\n    public\n    onlyWallet\n    validRequirement(owners.length, _required)\n  {\n    required = _required;\n    emit RequirementChange(_required);\n  }\n\n  /// @dev Allows an owner to submit and confirm a transaction.\n  /// @param destination Transaction target address.\n  /// @param value Transaction ether value.\n  /// @param data Transaction data payload.\n  /// @return Returns transaction ID.\n  function submitTransaction(address destination, uint256 value, bytes calldata data)\n    external\n    returns (uint256 transactionId)\n  {\n    transactionId = addTransaction(destination, value, data);\n    confirmTransaction(transactionId);\n  }\n\n  /// @dev Allows an owner to confirm a transaction.\n  /// @param transactionId Transaction ID.\n  function confirmTransaction(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    transactionExists(transactionId)\n    notConfirmed(transactionId, msg.sender)\n  {\n    confirmations[transactionId][msg.sender] = true;\n    emit Confirmation(msg.sender, transactionId);\n    executeTransaction(transactionId);\n  }\n\n  /// @dev Allows an owner to revoke a confirmation for a transaction.\n  /// @param transactionId Transaction ID.\n  function revokeConfirmation(uint256 transactionId)\n    external\n    ownerExists(msg.sender)\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n  {\n    confirmations[transactionId][msg.sender] = false;\n    emit Revocation(msg.sender, transactionId);\n  }\n\n  /// @dev Allows anyone to execute a confirmed transaction.\n  /// @param transactionId Transaction ID.\n  function executeTransaction(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n  {\n    if (isConfirmed(transactionId)) {\n      Transaction storage txn = transactions[transactionId];\n      txn.executed = true;\n      if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n        emit Execution(transactionId);\n      else {\n        emit ExecutionFailure(transactionId);\n        txn.executed = false;\n      }\n    }\n  }\n\n  // call has been separated into its own function in order to take advantage\n  // of the Solidity's code generator to produce a loop that copies tx.data into memory.\n  function external_call(address destination, uint256 value, uint256 dataLength, bytes memory data)\n    private\n    returns (bool)\n  {\n    bool result;\n\n    if (dataLength > 0)\n      require(AddressesHelper.isContract(destination), \"Invalid contract address\");\n\n    /* solhint-disable max-line-length */\n    assembly {\n      let x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n      let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n      result := call(\n        sub(gas, 34710), // 34710 is the value that solidity is currently emitting\n        // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n        // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n        destination,\n        value,\n        d,\n        dataLength, // Size of the input (in bytes) - this is what fixes the padding problem\n        x,\n        0 // Output is ignored, therefore the output size is zero\n      )\n    }\n    /* solhint-enable max-line-length */\n    return result;\n  }\n\n  /// @dev Returns the confirmation status of a transaction.\n  /// @param transactionId Transaction ID.\n  /// @return Confirmation status.\n  function isConfirmed(uint256 transactionId) public view returns (bool) {\n    uint256 count = 0;\n    for (uint256 i = 0; i < owners.length; i++) {\n      if (confirmations[transactionId][owners[i]]) count += 1;\n      if (count == required) return true;\n    }\n  }\n\n  /*\n   * Internal functions\n   */\n  /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n  /// @param destination Transaction target address.\n  /// @param value Transaction ether value.\n  /// @param data Transaction data payload.\n  /// @return Returns transaction ID.\n  function addTransaction(address destination, uint256 value, bytes memory data)\n    internal\n    notNull(destination)\n    returns (uint256 transactionId)\n  {\n    transactionId = transactionCount;\n    transactions[transactionId] = Transaction({\n      destination: destination,\n      value: value,\n      data: data,\n      executed: false\n    });\n    transactionCount += 1;\n    emit Submission(transactionId);\n  }\n\n  /*\n   * Web3 call functions\n   */\n  /// @dev Returns number of confirmations of a transaction.\n  /// @param transactionId Transaction ID.\n  /// @return Number of confirmations.\n  function getConfirmationCount(uint256 transactionId) external view returns (uint256 count) {\n    for (uint256 i = 0; i < owners.length; i++)\n      if (confirmations[transactionId][owners[i]]) count += 1;\n  }\n\n  /// @dev Returns total number of transactions after filers are applied.\n  /// @param pending Include pending transactions.\n  /// @param executed Include executed transactions.\n  /// @return Total number of transactions after filters are applied.\n  function getTransactionCount(bool pending, bool executed) external view returns (uint256 count) {\n    for (uint256 i = 0; i < transactionCount; i++)\n      if ((pending && !transactions[i].executed) || (executed && transactions[i].executed))\n        count += 1;\n  }\n\n  /// @dev Returns list of owners.\n  /// @return List of owner addresses.\n  function getOwners() external view returns (address[] memory) {\n    return owners;\n  }\n\n  /// @dev Returns array with owner addresses, which confirmed transaction.\n  /// @param transactionId Transaction ID.\n  /// @return Returns array of owner addresses.\n  function getConfirmations(uint256 transactionId)\n    external\n    view\n    returns (address[] memory _confirmations)\n  {\n    address[] memory confirmationsTemp = new address[](owners.length);\n    uint256 count = 0;\n    uint256 i;\n    for (i = 0; i < owners.length; i++)\n      if (confirmations[transactionId][owners[i]]) {\n        confirmationsTemp[count] = owners[i];\n        count += 1;\n      }\n    _confirmations = new address[](count);\n    for (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\n  }\n\n  /// @dev Returns list of transaction IDs in defined range.\n  /// @param from Index start position of transaction array.\n  /// @param to Index end position of transaction array.\n  /// @param pending Include pending transactions.\n  /// @param executed Include executed transactions.\n  /// @return Returns array of transaction IDs.\n  function getTransactionIds(uint256 from, uint256 to, bool pending, bool executed)\n    external\n    view\n    returns (uint256[] memory _transactionIds)\n  {\n    uint256[] memory transactionIdsTemp = new uint256[](transactionCount);\n    uint256 count = 0;\n    uint256 i;\n    for (i = 0; i < transactionCount; i++)\n      if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\n        transactionIdsTemp[count] = i;\n        count += 1;\n      }\n    _transactionIds = new uint256[](to - from);\n    for (i = from; i < to; i++) _transactionIds[i - from] = transactionIdsTemp[i];\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/MultiSig.sol",
      "content": "pragma solidity ^0.5.3;\n/* solhint-disable no-inline-assembly, avoid-low-level-calls, func-name-mixedcase, func-order */\n\nimport \"./Initializable.sol\";\nimport \"./libraries/AddressesHelper.sol\";\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before\n/// execution.\n/// @author Stefan George - <stefan.george@consensys.net>\ncontract MultiSig is Initializable {\n  /*\n   *  Events\n   */\n  event Confirmation(address indexed sender, uint256 indexed transactionId);\n  event Revocation(address indexed sender, uint256 indexed transactionId);\n  event Submission(uint256 indexed transactionId);\n  event Execution(uint256 indexed transactionId);\n  event ExecutionFailure(uint256 indexed transactionId);\n  event Deposit(address indexed sender, uint256 value);\n  event OwnerAddition(address indexed owner);\n  event OwnerRemoval(address indexed owner);\n  event RequirementChange(uint256 required);\n\n  /*\n   *  Constants\n   */\n  uint256 public constant MAX_OWNER_COUNT = 50;\n\n  /*\n   *  Storage\n   */\n  mapping(uint256 => Transaction) public transactions;\n  mapping(uint256 => mapping(address => bool)) public confirmations;\n  mapping(address => bool) public isOwner;\n  address[] public owners;\n  uint256 public required;\n  uint256 public transactionCount;\n\n  struct Transaction {\n    address destination;\n    uint256 value;\n    bytes data;\n    bool executed;\n  }\n\n  /*\n   *  Modifiers\n   */\n  modifier onlyWallet() {\n    require(msg.sender == address(this), \"msg.sender was not multisig wallet\");\n    _;\n  }\n\n  modifier ownerDoesNotExist(address owner) {\n    require(!isOwner[owner], \"owner already existed\");\n    _;\n  }\n\n  modifier ownerExists(address owner) {\n    require(isOwner[owner], \"owner does not exist\");\n    _;\n  }\n\n  modifier transactionExists(uint256 transactionId) {\n    require(transactions[transactionId].destination != address(0), \"transaction does not exist\");\n    _;\n  }\n\n  modifier confirmed(uint256 transactionId, address owner) {\n    require(confirmations[transactionId][owner], \"transaction was not confirmed for owner\");\n    _;\n  }\n\n  modifier notConfirmed(uint256 transactionId, address owner) {\n    require(!confirmations[transactionId][owner], \"transaction was already confirmed for owner\");\n    _;\n  }\n\n  modifier notExecuted(uint256 transactionId) {\n    require(!transactions[transactionId].executed, \"transaction was executed already\");\n    _;\n  }\n\n  modifier notNull(address _address) {\n    require(_address != address(0), \"address was null\");\n    _;\n  }\n\n  modifier validRequirement(uint256 ownerCount, uint256 _required) {\n    require(\n      ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0,\n      \"invalid requirement\"\n    );\n    _;\n  }\n\n  /// @dev Fallback function allows to deposit ether.\n  function() external payable {\n    if (msg.value > 0) emit Deposit(msg.sender, msg.value);\n  }\n\n  /*\n   * Public functions\n   */\n  /// @dev Contract constructor sets initial owners and required number of confirmations.\n  /// @param _owners List of initial owners.\n  /// @param _required Number of required confirmations.\n  function initialize(address[] calldata _owners, uint256 _required)\n    external\n    initializer\n    validRequirement(_owners.length, _required)\n  {\n    for (uint256 i = 0; i < _owners.length; i++) {\n      require(\n        !isOwner[_owners[i]] && _owners[i] != address(0),\n        \"owner was null or already given owner status\"\n      );\n      isOwner[_owners[i]] = true;\n    }\n    owners = _owners;\n    required = _required;\n  }\n\n  /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n  /// @param owner Address of new owner.\n  function addOwner(address owner)\n    external\n    onlyWallet\n    ownerDoesNotExist(owner)\n    notNull(owner)\n    validRequirement(owners.length + 1, required)\n  {\n    isOwner[owner] = true;\n    owners.push(owner);\n    emit OwnerAddition(owner);\n  }\n\n  /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n  /// @param owner Address of owner.\n  function removeOwner(address owner) external onlyWallet ownerExists(owner) {\n    isOwner[owner] = false;\n    for (uint256 i = 0; i < owners.length - 1; i++)\n      if (owners[i] == owner) {\n        owners[i] = owners[owners.length - 1];\n        break;\n      }\n    owners.length -= 1;\n    if (required > owners.length) changeRequirement(owners.length);\n    emit OwnerRemoval(owner);\n  }\n\n  /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n  /// @param owner Address of owner to be replaced.\n  /// @param newOwner Address of new owner.\n  function replaceOwner(address owner, address newOwner)\n    external\n    onlyWallet\n    ownerExists(owner)\n    notNull(newOwner)\n    ownerDoesNotExist(newOwner)\n  {\n    for (uint256 i = 0; i < owners.length - 1; i++)\n      if (owners[i] == owner) {\n        owners[i] = newOwner;\n        break;\n      }\n    isOwner[owner] = false;\n    isOwner[newOwner] = true;\n    emit OwnerRemoval(owner);\n    emit OwnerAddition(newOwner);\n  }\n\n  /// @dev Allows to change the number of required confirmations. Transaction has to be sent by\n  /// wallet.\n  /// @param _required Number of required confirmations.\n  function changeRequirement(uint256 _required)\n    public\n    onlyWallet\n    validRequirement(owners.length, _required)\n  {\n    required = _required;\n    emit RequirementChange(_required);\n  }\n\n  /// @dev Allows an owner to submit and confirm a transaction.\n  /// @param destination Transaction target address.\n  /// @param value Transaction ether value.\n  /// @param data Transaction data payload.\n  /// @return Returns transaction ID.\n  function submitTransaction(address destination, uint256 value, bytes calldata data)\n    external\n    returns (uint256 transactionId)\n  {\n    transactionId = addTransaction(destination, value, data);\n    confirmTransaction(transactionId);\n  }\n\n  /// @dev Allows an owner to confirm a transaction.\n  /// @param transactionId Transaction ID.\n  function confirmTransaction(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    transactionExists(transactionId)\n    notConfirmed(transactionId, msg.sender)\n  {\n    confirmations[transactionId][msg.sender] = true;\n    emit Confirmation(msg.sender, transactionId);\n    executeTransaction(transactionId);\n  }\n\n  /// @dev Allows an owner to revoke a confirmation for a transaction.\n  /// @param transactionId Transaction ID.\n  function revokeConfirmation(uint256 transactionId)\n    external\n    ownerExists(msg.sender)\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n  {\n    confirmations[transactionId][msg.sender] = false;\n    emit Revocation(msg.sender, transactionId);\n  }\n\n  /// @dev Allows anyone to execute a confirmed transaction.\n  /// @param transactionId Transaction ID.\n  function executeTransaction(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n  {\n    if (isConfirmed(transactionId)) {\n      Transaction storage txn = transactions[transactionId];\n      txn.executed = true;\n      if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n        emit Execution(transactionId);\n      else {\n        emit ExecutionFailure(transactionId);\n        txn.executed = false;\n      }\n    }\n  }\n\n  // call has been separated into its own function in order to take advantage\n  // of the Solidity's code generator to produce a loop that copies tx.data into memory.\n  function external_call(address destination, uint256 value, uint256 dataLength, bytes memory data)\n    private\n    returns (bool)\n  {\n    bool result;\n\n    if (dataLength > 0)\n      requ"
    }
  ]
}