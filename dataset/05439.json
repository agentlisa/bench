{
  "Title": "[M-23] Rounding errors can cause ERC20RebaseDistributor transfers and mints to fail for underflow",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/ERC20RebaseDistributor.sol#L618>\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/ERC20RebaseDistributor.sol#L531>\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/ERC20RebaseDistributor.sol#L594>\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/ERC20RebaseDistributor.sol#L688>\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/ERC20RebaseDistributor.sol#L712>\n\n### Vulnerability details\n\nWhen calculating share changes during ERC20RebaseDistributor token transfers, the logic computes the share delta as follows:\n\n```Solidity\nFile: ERC20RebaseDistributor.sol\n553:     function transfer(\n554:         address to,\n555:         uint256 amount\n556:     ) public virtual override returns (bool) {\n---\n603:         if (rebasingStateTo.isRebasing == 1) {\n---\n618:             uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares;\n```\n\nIt is possible that due to rounding, `rebasingStateTo.nShares` is higher than `toSharesAfter` by `1 wei`, causing the transfer to fail.\n\nA similar issue can happen when unminted rewards are taken off the rebase pool:\n\n```Solidity\nFile: ERC20RebaseDistributor.sol\n228:     function decreaseUnmintedRebaseRewards(uint256 amount) internal {\n229:         InterpolatedValue memory val = __unmintedRebaseRewards;\n230:         uint256 _unmintedRebaseRewards = interpolatedValue(val);\n231:         __unmintedRebaseRewards = InterpolatedValue({\n232:             lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // now\n233:             lastValue: SafeCastLib.safeCastTo224(\n234:                 _unmintedRebaseRewards - amount\n235:             ), // adjusted current\n236:             targetTimestamp: val.targetTimestamp, // unchanged\n237:             targetValue: val.targetValue - SafeCastLib.safeCastTo224(amount) // adjusted target\n238:         });\n239:     }\n```\n\nHere it is possible that the `amount` is higher than `_unmintedRebaseRewards`, introducing also in this place a revert condition.\n\n### Impact\n\nTransfers and mints from or towards addresses that are rebasing may fail in real-world scenarios. This failure can be used as a means to DoS sensitive operations like liquidations. Addresses who enter this scenario aren't also able to exit rebase to fix their transfers.\n\n### Proof of Concept\n\nBelow a foundry PoC (full setup [here](https://gist.github.com/3docSec/a54c62acdcf2f7bf0a532ff8e0aab805)) which shows a scenario where a transfer (or mint) to a rebasing user can fail by underflow on the `_unmintedRebaseRewards - amount` operation:\n\n```Solidity\n    function testM2bis() external {\n        uint t0 = block.timestamp;\n\n        // set up the credit token with the minimum 100e18 rebasing supply\n        // as indicated here -> \n        // https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/ERC20RebaseDistributor.sol#L37\n        ct.mint(address(1), 100e18);\n        vm.prank(address(1));\n        ct.enterRebase();\n        \n        ct.mint(address(2), 6e11); vm.prank(address(2)); ct.distribute(6e11);\n        vm.warp(2);\n        ct.mint(address(2), 3e12); vm.prank(address(2)); ct.distribute(3e12);\n        vm.warp(3);\n        \n        ct.mint(address(3), 1e20);\n        vm.prank(address(3));\n\n        // ☢️ this shouldn't revert!\n        vm.expectRevert();\n        ct.transfer(address(1), 1e20);\n\n        // ☢️ this shouldn't either!\n        vm.expectRevert();\n        ct.mint(address(1), 1e20);\n\n        // ☢️ this too..\n        vm.prank(address(1));\n        vm.expectRevert();\n        ct.exitRebase();\n\n        // ☢️ same here...\n        vm.startPrank(address(1));\n        vm.expectRevert();\n        ct.transfer(address(3), 1e20);\n\n        // ☢️ I bet you saw this coming...\n        ct.approve(address(3), 1e20);\n        vm.startPrank(address(3));\n        vm.expectRevert();\n        ct.transferFrom(address(1), address(3), 1e20);\n    }\n```\n\nThis is with a lower impact because involving a zero-value transfer, the following PoC in Foundry (the full runnable test can be found [here](https://gist.github.com/3docSec/293c8d72394c7a72253af9650acdbeef)) shows a transfer failing on the `toSharesAfter - rebasingStateTo.nShares` operation:\n\n```Solidity\n    function testM2() external {\n        address from = address(uint160(1));\n        address to = address(uint160(2));\n\n        ct.mint(to, 100 ether);\n\n        vm.startPrank(to);\n        ct.enterRebase();\n        ct.distribute(1 ether);\n\n        vm.warp(block.timestamp + 1);\n        vm.startPrank(from);\n\n        vm.expectRevert();\n        ct.transfer(to, 0);\n\n        vm.expectRevert();\n        ct.transferFrom(from, to, 0);\n    }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nConsider adapting shares calculations to tolerate rounding fluctuations, i.e. by flooring to `0` the mentioned subtractions.\n\n### Assessed type\n\nToken-Transfer\n\n**[eswak (Ethereum Credit Guild) confirmed](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/294#issuecomment-1881241506)**\n\n**[Soul22 (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/294#issuecomment-1925206861):**\n > After carefully reviewing the report and discussing it with other auditors, I believe that the severity of this issue should be reassessed.\n> \n> The problem is that division rounds down and more divisions result in greater precision loss. Specifically, in this report, the calculation of `toSharesAfter` involves three divisions, which results in underflow during the subsequent subtraction. It is important to note that the underflow issue in the provided POC above is temporary and **only lasts for 31 seconds**. After this time, the `transfer()` and `mint()` functions will work as expected.\n> \n> **Proof of Concept**\n> \n> The variable `toSharesAfter` is determined by [this formula](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/ERC20RebaseDistributor.sol#L614): \n>\n> ```solidity\n>     uint256 toSharesAfter = _balance2shares(toBalanceAfter, _rebasingSharePrice);\n> \n>     function _balance2shares(\n>         uint256 balance,\n>         uint256 sharePrice\n>     ) internal pure returns (uint256) {\n>         return (balance * START_REBASING_SHARE_PRICE) / sharePrice;\n>     }\n> ```\n>\n> The `toBalanceAfter` variable is determined by [this formula](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/ERC20RebaseDistributor.sol#L606):\n>\n> ```solidity\n>     uint256 rawToBalanceAfter = ERC20.balanceOf(to);\n>     uint256 toBalanceAfter = _shares2balance(\n>          rebasingStateTo.nShares,\n>          _rebasingSharePrice,\n>          amount,\n>          rawToBalanceAfter\n>      );\n> ```\n>\n> The `toBalanceAfter` variable depends on `_rebasingSharePrice`, which means that `toSharesAfter` also heavily relies on it.\n> \n> It is important to note that the `_rebasingSharePrice` variable is not a constant and it is increased linearly. \n> \n> ```solidity \n>        uint256 _rebasingSharePrice =  (rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1)\n>                                         ? rebasingSharePrice()\n>                                         : 0; // only SLOAD if at least one address is rebasing\n>        \n>        function rebasingSharePrice() public view returns (uint256) {\n>           return interpolatedValue(__rebasingSharePrice);\n>        }\n>   \n>         function interpolatedValue(\n>             InterpolatedValue memory val\n>         ) internal view returns (uint256) {\n>             // load state\n>             uint256 lastTimestamp = uint256(val.lastTimestamp); // safe upcast\n>             uint256 lastValue = uint256(val.lastValue); // safe upcast\n>             uint256 targetTimestamp = uint256(val.targetTimestamp); // safe upcast\n>             uint256 targetValue = uint256(val.targetValue); // safe upcast\n>     \n>             // interpolate increase over period\n>             if (block.timestamp >= targetTimestamp) {\n>                 // if period is passed, return target value\n>                 return targetValue;\n>             } else {\n>                 // block.timestamp is within [lastTimestamp, targetTimestamp[\n>                 uint256 elapsed = block.timestamp - lastTimestamp;\n>                 uint256 delta = targetValue - lastValue;\n>                 return lastValue + (delta * elapsed) / (targetTimestamp - lastTimestamp);//note linear unlock\n>             }\n>         }\n> ```\n> \n> Next, we determine the amount of time needed for the rounding error to disappear. The result is 31 seconds.\n> \n> Please add the following test to the `CreditToken.t.sol` file and run it using the command `forge test --mc CreditTokenUnitTest --mt test_issue294`.\n> \n> ```solidity\n>     function test_issue294() public {\n>         // create/grant role\n>         vm.startPrank(governor);\n>         core.createRole(CoreRoles.CREDIT_MINTER, CoreRoles.GOVERNOR);\n>         core.grantRole(CoreRoles.CREDIT_MINTER, address(this));\n>         core.grantRole(CoreRoles.CREDIT_REBASE_PARAMETERS, address(this));\n>         vm.stopPrank();\n> \n>         token.mint(address(1), 100e18);\n>         vm.prank(address(1));\n>         token.enterRebase();\n> \n>         token.mint(address(2), 6e11);\n>         vm.prank(address(2));\n>         token.distribute(6e11);\n>         vm.warp(block.timestamp + 2 seconds);\n> \n>         token.mint(address(2), 3e12);\n>         vm.prank(address(2));\n>         token.distribute(3e12);\n>         vm.warp(block.timestamp + 31 seconds); //note wait for 31 seconds\n> \n>         token.mint(address(3), 1e20);\n>         vm.startPrank(address(3));\n>         // this works\n>         // vm.expectRevert();\n>         token.transfer(address(1), 1e20);\n>         vm.stopPrank();\n> \n>         // this works\n>         // vm.expectRevert();\n>         token.mint(address(1), 1e20);\n> \n>         // this works\n>         vm.startPrank(address(1));\n>         // vm.expectRevert();\n>         token.exitRebase();\n>         vm.stopPrank();\n> \n>         // this works\n>         vm.startPrank(address(1));\n>         // vm.expectRevert();\n>         token.transfer(address(3), 1e20);\n> \n>         // this works\n>         token.approve(address(3), 1e20);\n>         vm.startPrank(address(3));\n>         // vm.expectRevert();\n>         token.transferFrom(address(1), address(3), 1e20);\n>         vm.stopPrank();\n>     }\n> ```\n\n**[3docSec (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/294#issuecomment-1925207961):**\n > @Soul22 - while the attack in the PoC is temporary, new small-amount distributions (which are permissionless) with appropriate timing and amounts can be made to make the DoS last longer.\n\n**[Soul22 (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/294#issuecomment-1925325373):**\n > Upon further investigation, I found that if we remove the `vm.warp(block.timestamp + 2 seconds);` statement, then the underflow disappears immediately. \n> \n> ```solidity \n>     function test_issue294_removeVmWarp() public {\n>         // create/grant role\n>         vm.startPrank(governor);\n>         core.createRole(CoreRoles.CREDIT_MINTER, CoreRoles.GOVERNOR);\n>         core.grantRole(CoreRoles.CREDIT_MINTER, address(this));\n>         core.grantRole(CoreRoles.CREDIT_REBASE_PARAMETERS, address(this));\n>         vm.stopPrank();\n> \n>         token.mint(address(1), 100e18);\n>         vm.prank(address(1));\n>         token.enterRebase();\n> \n>         token.mint(address(2), 6e11);\n>         vm.prank(address(2));\n>         token.distribute(6e11);\n>         // vm.warp(block.timestamp + 2 seconds);\n> \n>         token.mint(address(2), 3e12);\n>         vm.prank(address(2));\n>         token.distribute(3e12);\n>         // vm.warp(block.timestamp + 31 seconds); //note no need to wait anymore\n> \n>         token.mint(address(3), 1e20);\n>         vm.startPrank(address(3));\n>         // this works\n>         // vm.expectRevert();\n>         token.transfer(address(1), 1e20);\n>         vm.stopPrank();\n> \n>         // this works\n>         // vm.expectRevert();\n>         token.mint(address(1), 1e20);\n> \n>         // this works\n>         vm.startPrank(address(1));\n>         // vm.expectRevert();\n>         token.exitRebase();\n>         vm.stopPrank();\n> \n>         // this works\n>         vm.startPrank(address(1));\n>         // vm.expectRevert();\n>         token.transfer(address(3), 1e20);\n> \n>         // this works\n>         token.approve(address(3), 1e20);\n>         vm.startPrank(address(3));\n>         // vm.expectRevert();\n>         token.transferFrom(address(1), address(3), 1e20);\n>         vm.stopPrank();\n>     }\n> ```\n\n**[TrungOre (judge) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/294#issuecomment-1931566285):**\n > Although the likelihood is low, the impact of this issue is significant since it can brick Credit token's minting and transferring, potentially preventing users from unstaking from `SurplusGuildMinter` in certain cases. The duration of the Denial of Service (DoS) attack is temporary, but users may not be able to unstake promptly to avoid being slashed in `SurplusGuildMinter`. Therefore, medium severity is appropriate.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/tokens/ERC20RebaseDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeCastLib} from \"@src/external/solmate/SafeCastLib.sol\";\n\n/** \n@title  An ERC20 with rebase capabilities. Anyone can sacrifice tokens to rebase up the balance\n        of all addresses that are currently rebasing.\n@author eswak\n@notice This contract is meant to be used to distribute rewards proportionately to all holders of\n        a token, for instance to distribute buybacks or income generated by a protocol.\n\n        Anyone can subscribe to rebasing by calling `enterRebase()`, and unsubcribe with `exitRebase()`.\n        Anyone can burn tokens they own to `distribute(uint256)` proportionately to rebasing addresses.\n\n        The following conditions are always met :\n        ```\n        totalSupply() == nonRebasingSupply() + rebasingSupply()\n        sum of balanceOf(x) == totalSupply() [+= rounding down errors of 1 wei for each balanceOf]\n        ```\n\n        Internally, when a user subscribes to the rebase, their balance is converted to a number of\n        shares, and the total number of shares is updated. When a user unsubscribes, their shares are\n        converted back to a balance, and the total number of shares is updated.\n\n        On each distribution, the share price of rebasing tokens is updated to reflect the new value\n        of rebasing shares. The formula is as follow :\n\n        ```\n        newSharePrice = oldSharePrice * (rebasingSupply + amount) / rebasingSupply\n        ```\n\n        If the rebasingSupply is 0 (nobody subscribed to rebasing), the tokens distributed are burnt\n        but nobody benefits for the share price increase, since the share price cannot be updated.\n\n        /!\\ The first user subscribing to rebase should have a meaningful balance in order to avoid\n        share price manipulation (see hundred finance exploit).\n        It is advised to keep a minimum balance rebasing at all times, for instance with a small\n        rebasing balance held by the deployer address or address(0) or the token itself.\n*/\nabstract contract ERC20RebaseDistributor is ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                            EVENTS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when an `account` enters rebasing.\n    event RebaseEnter(address indexed account, uint256 indexed timestamp);\n    /// @notice Emitted when an `account` exits rebasing.\n    event RebaseExit(address indexed account, uint256 indexed timestamp);\n    /// @notice Emitted when an `amount` of tokens is distributed by `source` to the rebasing accounts.\n    event RebaseDistribution(\n        address indexed source,\n        uint256 indexed timestamp,\n        uint256 amountDistributed,\n        uint256 amountRebasing\n    );\n    /// @notice Emitted when an `amount` of tokens is realized as rebase rewards for `account`.\n    /// @dev `totalSupply()`, `rebasingSupply()`, and `balanceOf()` reflect the rebase rewards\n    /// in real time, but the internal storage only realizes rebase rewards if the user has an\n    /// interaction with the token contract in one of the following functions:\n    /// - exitRebase()\n    /// - burn()\n    /// - mint()\n    /// - transfer() received or sent\n    /// - transferFrom() received or sent\n    event RebaseReward(\n        address indexed account,\n        uint256 indexed timestamp,\n        uint256 amount\n    );\n\n    /*///////////////////////////////////////////////////////////////\n                            INTERNAL STATE\n    ///////////////////////////////////////////////////////////////*/\n\n    struct RebasingState {\n        uint8 isRebasing;\n        uint248 nShares;\n    }\n\n    /// @notice For internal accounting. Number of rebasing shares for each rebasing accounts. 0 if account is not rebasing.\n    mapping(address => RebasingState) internal rebasingState;\n\n    /// @notice For internal accounting. Total number of rebasing shares\n    uint256 internal totalRebasingShares;\n\n    /// @notice The starting share price for rebasing addresses.\n    /// @dev rounding errors start to appear when balances of users are near `rebasingSharePrice()`,\n    /// due to rounding down in the number of shares attributed, and rounding down in the number of\n    /// tokens per share. We use a high base to ensure no crazy rounding errors happen at runtime\n    /// (balances of users would have to be > START_REBASING_SHARE_PRICE for rounding errors to start to materialize).\n    uint256 internal constant START_REBASING_SHARE_PRICE = 1e30;\n\n    /// @notice share price increase and pending rebase rewards from distribute() are\n    /// interpolated linearly over a period of DISTRIBUTION_PERIOD seconds after a distribution.\n    uint256 public constant DISTRIBUTION_PERIOD = 30 days;\n\n    struct InterpolatedValue {\n        uint32 lastTimestamp;\n        uint224 lastValue;\n        uint32 targetTimestamp;\n        uint224 targetValue;\n    }\n\n    /// @notice For internal accounting. Number of tokens per share for the rebasing supply.\n    /// Starts at START_REBASING_SHARE_PRICE and goes up only.\n    InterpolatedValue internal __rebasingSharePrice =\n        InterpolatedValue({\n            lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),\n            lastValue: uint224(START_REBASING_SHARE_PRICE), // safe initial value\n            targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),\n            targetValue: uint224(START_REBASING_SHARE_PRICE) // safe initial value\n        });\n\n    /// @notice For internal accounting. Number of tokens distributed to rebasing addresses that have not\n    /// yet been materialized by a movement in the rebasing addresses.\n    InterpolatedValue internal __unmintedRebaseRewards =\n        InterpolatedValue({\n            lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),\n            lastValue: 0,\n            targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),\n            targetValue: 0\n        });\n\n    /*///////////////////////////////////////////////////////////////\n                            INTERNAL UTILS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice get the current value of an interpolated value\n    function interpolatedValue(\n        InterpolatedValue memory val\n    ) internal view returns (uint256) {\n        // load state\n        uint256 lastTimestamp = uint256(val.lastTimestamp); // safe upcast\n        uint256 lastValue = uint256(val.lastValue); // safe upcast\n        uint256 targetTimestamp = uint256(val.targetTimestamp); // safe upcast\n        uint256 targetValue = uint256(val.targetValue); // safe upcast\n\n        // interpolate increase over period\n        if (block.timestamp >= targetTimestamp) {\n            // if period is passed, return target value\n            return targetValue;\n        } else {\n            // block.timestamp is within [lastTimestamp, targetTimestamp[\n            uint256 elapsed = block.timestamp - lastTimestamp;\n            uint256 delta = targetValue - lastValue;\n            return\n                lastValue +\n                (delta * elapsed) /\n                (targetTimestamp - lastTimestamp);\n        }\n    }\n\n    /// @notice called to update the number of rebasing shares.\n    /// This can happen in multiple situations:\n    /// - enterRebase()\n    /// - exitRebase()\n    /// - burn() from a rebasing address\n    /// - mint() to a rebasing address\n    /// - transfer() from a rebasing address\n    /// - transfer() to a rebasing address\n    /// - transferFrom() from a rebasing address\n    /// - transferFrom() to a rebasing address\n    /// If the number of shares is updated during the interpolation, the target share price\n    /// of the interpolation should be changed to reflect the reduced or increased number of shares\n    /// and keep a constant rebasing supply value (current & target).\n    function updateTotalRebasingShares(\n        uint256 currentRebasingSharePrice,\n        int256 sharesDelta\n    ) internal {\n        if (sharesDelta == 0) return;\n        uint256 sharesBefore = totalRebasingShares;\n        uint256 sharesAfter;\n        if (sharesDelta > 0) {\n            sharesAfter = sharesBefore + uint256(sharesDelta);\n        } else {\n            uint256 shareDecrease = uint256(-sharesDelta);\n            if (shareDecrease < sharesBefore) {\n                unchecked {\n                    sharesAfter = sharesBefore - shareDecrease;\n                }\n            }\n            // else sharesAfter stays 0\n        }\n        totalRebasingShares = sharesAfter;\n\n        // reset interpolation & share price if going to 0 rebasing supply\n        if (sharesAfter == 0) {\n            __rebasingSharePrice = InterpolatedValue({\n                lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // now\n                lastValue: uint224(START_REBASING_SHARE_PRICE), // safe initial value\n                targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // now\n                targetValue: uint224(START_REBASING_SHARE_PRICE) // safe initial value\n            });\n            __unmintedRebaseRewards = InterpolatedValue({\n                lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),\n                lastValue: 0,\n                targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),\n                targetValue: 0\n            });\n            return;\n        }\n\n        // when total shares is multiplied by x, the remaining share price change (\"delta\" below)\n        // should be multiplied by 1/x, e.g. going from a share price of 1.0 to 1.5, and current\n        // value is 1.25, the remaining share price change \"delta\" is 0.25.\n        // if the rebasing supply 2x, the share price change should 0.5x to 0.125.\n        // at the end of the interpolation period, the share price will be 1.375.\n        InterpolatedValue memory val = __rebasingSharePrice;\n        uint256 delta = uint256(val.targetValue) - currentRebasingSharePrice;\n        if (delta != 0) {\n            uint256 percentChange = (sharesAfter * START_REBASING_SHARE_PRICE) /\n                sharesBefore;\n            uint256 targetNewSharePrice = currentRebasingSharePrice +\n                (delta * START_REBASING_SHARE_PRICE) /\n                percentChange;\n            __rebasingSharePrice = InterpolatedValue({\n                lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // now\n                lastValue: SafeCastLib.safeCastTo224(currentRebasingSharePrice), // current value\n                targetTimestamp: val.targetTimestamp, // unchanged\n                targetValue: SafeCastLib.safeCastTo224(targetNewSharePrice) // adjusted target\n            });\n        }\n    }\n\n    /// @notice decrease unminted rebase rewards, when rewards are minted to users\n    function decreaseUnmintedRebaseRewards(uint256 amount) internal {\n        InterpolatedValue memory val = __unmintedRebaseRewards;\n        uint256 _unmintedRebaseRewards = interpolatedValue(val);\n        __unmintedRebaseRewards = InterpolatedValue({\n            lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // now\n            lastValue: SafeCastLib.safeCastTo224(\n                _unmintedRebaseRewards - amount\n            ), // adjusted current\n            targetTimestamp: val.targetTimestamp, // unchanged\n            targetValue: val.targetValue - SafeCastLib.safeCastTo224(amount) // adjusted target\n        });\n    }\n\n    /// @notice get the current rebasing share price\n    function rebasingSharePrice() internal view returns (uint256) {\n        return interpolatedValue(__rebasingSharePrice);\n    }\n\n    /// @notice get the current unminted rebase rewards\n    function unmintedRebaseRewards() internal view returns (uint256) {\n        return interpolatedValue(__unmintedRebaseRewards);\n    }\n\n    /// @notice convert a balance to a number of shares\n    function _balance2shares(\n        uint256 balance,\n        uint256 sharePrice\n    ) internal pure returns (uint256) {\n        return (balance * START_REBASING_SHARE_PRICE) / sharePrice;\n    }\n\n    /// @notice convert a number of shares to a balance\n    function _shares2balance(\n        uint256 shares,\n        uint256 sharePrice,\n        uint256 deltaBalance,\n        uint256 minBalance\n    ) internal pure returns (uint256) {\n        uint256 rebasedBalance = (shares * sharePrice) /\n            START_REBASING_SHARE_PRICE +\n            deltaBalance;\n        if (rebasedBalance < minBalance) {\n            rebasedBalance = minBalance;\n        }\n        return rebasedBalance;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            EXTERNAL API\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice Enter rebasing supply. All subsequent distributions will increase the balance\n    /// of `msg.sender` proportionately.\n    function enterRebase() external {\n        require(\n            rebasingState[msg.sender].isRebasing == 0,\n            \"ERC20RebaseDistributor: already rebasing\"\n        );\n        _enterRebase(msg.sender);\n    }\n\n    function _enterRebase(address account) internal {\n        uint256 balance = ERC20.balanceOf(account);\n        uint256 currentRebasingSharePrice = rebasingSharePrice();\n        uint256 shares = _balance2shares(balance, currentRebasingSharePrice);\n        rebasingState[account] = RebasingState({\n            isRebasing: 1,\n            nShares: uint248(shares)\n        });\n        updateTotalRebasingShares(currentRebasingSharePrice, int256(shares));\n        emit RebaseEnter(account, block.timestamp);\n    }\n\n    /// @notice Exit rebasing supply. All unminted rebasing rewards are physically minted to the user,\n    /// and they won't be affected by rebases anymore.\n    function exitRebase() external {\n        require(\n            rebasingState[msg.sender].isRebasing == 1,\n            \"ERC20RebaseDistributor: not rebasing\"\n        );\n        _exitRebase(msg.sender);\n    }\n\n    function _exitRebase(address account) internal {\n        uint256 rawBalance = ERC20.balanceOf(account);\n        RebasingState memory _rebasingState = rebasingState[account];\n        uint256 shares = uint256(_rebasingState.nShares);\n        uint256 currentRebasingSharePrice = rebasingSharePrice();\n        uint256 rebasedBalance = _shares2balance(\n            shares,\n            currentRebasingSharePrice,\n            0,\n            rawBalance\n        );\n        uint256 mintAmount = rebasedBalance - rawBalance;\n        if (mintAmount != 0) {\n            ERC20._mint(account, mintAmount);\n            decreaseUnmintedRebaseRewards(mintAmount);\n            emit RebaseReward(account, block.timestamp, mintAmount);\n        }\n\n        rebasingState[account] = RebasingState({isRebasing: 0, nShares: 0});\n        updateTotalRebasingShares(currentRebasingSharePrice, -int256(shares));\n\n        emit RebaseExit(account, block.timestamp);\n    }\n\n    /// @notice distribute tokens proportionately to all rebasing accounts.\n    /// @dev if no addresses are rebasing, calling this function will burn tokens\n    /// from `msg.sender` and emit an event, but won't rebase up any balances.\n    function distribute(uint256 amount) external {\n        require(amount != 0, \"ERC20RebaseDistributor: cannot distribute zero\");\n\n        // burn the tokens received\n        _burn(msg.sender, amount);\n\n        // emit event\n        uint256 _rebasingSharePrice = rebasingSharePrice();\n        uint256 _totalRebasingShares = totalRebasingShares;\n        uint256 _rebasingSupply = _shares2balance(\n            _totalRebasingShares,\n            _rebasingSharePrice,\n            0,\n            0\n        );\n        emit RebaseDistribution(\n            msg.sender,\n            block.timestamp,\n            amount,\n            _rebasingSupply\n        );\n\n        // adjust up the balance of all accounts that are rebasing by increasing\n        // the share price of rebasing tokens\n        if (_rebasingSupply != 0) {\n            // update rebasingSharePrice interpolation\n            uint256 endTimestamp = block.timestamp + DISTRIBUTION_PERIOD;\n            uint256 newTargetSharePrice = (amount *\n                START_REBASING_SHARE_PRICE +\n                __rebasingSharePrice.targetValue *\n                _totalRebasingShares) / _totalRebasingShares;\n            __rebasingSharePrice = InterpolatedValue({\n                lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),\n                lastValue: SafeCastLib.safeCastTo224(_rebasingSharePrice),\n                targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),\n                targetValue: SafeCastLib.safeCastTo224(newTargetSharePrice)\n            });\n\n            // update unmintedRebaseRewards interpolation\n            uint256 _unmintedRebaseRewards = unmintedRebaseRewards();\n            __unmintedRebaseRewards = InterpolatedValue({\n                lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),\n                lastValue: SafeCastLib.safeCastTo224(_unmintedRebaseRewards),\n                targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),\n                targetValue: __unmintedRebaseRewards.targetValue +\n                    SafeCastLib.safeCastTo224(amount)\n            });\n        }\n    }\n\n    /// @notice True if an address subscribed to rebasing.\n    function isRebasing(address account) public view returns (bool) {\n        return rebasingState[account].isRebasing == 1;\n    }\n\n    /// @notice Total number of the tokens that are rebasing.\n    function rebasingSupply() public view returns (uint256) {\n        return _shares2balance(totalRebasingShares, rebasingSharePrice(), 0, 0);\n    }\n\n    /// @notice Total number of the tokens that are not rebasing.\n    function nonRebasingSupply() external view virtual returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        uint256 _rebasingSupply = rebasingSupply();\n\n        // compare rebasing supply to total supply :\n        // rounding errors due to share price & number of shares could otherwise\n        // make this function revert due to an underflow\n        if (_rebasingSupply > _totalSupply) {\n            return 0;\n        } else {\n            return _totalSupply - _rebasingSupply;\n        }\n    }\n\n    /// @notice get the number of distributed tokens that have not yet entered\n    /// circulation through rebase due to the interpolation of rewards over time.\n    function pendingDistributedSupply() external view returns (uint256) {\n        InterpolatedValue memory val = __unmintedRebaseRewards;\n        uint256 _unmintedRebaseRewards = interpolatedValue(val);\n        return __unmintedRebaseRewards.targetValue - _unmintedRebaseRewards;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC20 OVERRIDE\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice Override of balanceOf() that takes into account the unminted rebase rewards.\n    function balanceOf(\n        address account\n    ) public view virtual override returns (uint256) {\n        RebasingState memory _rebasingState = rebasingState[account];\n        if (_rebasingState.isRebasing == 0) {\n            return ERC20.balanceOf(account);\n        } else {\n            return\n                _shares2balance(\n                    _rebasingState.nShares,\n                    rebasingSharePrice(),\n                    0,\n                    ERC20.balanceOf(account)\n                );\n        }\n    }\n\n    /// @notice Total number of the tokens in existence.\n    function totalSupply() public view virtual override returns (uint256) {\n        return ERC20.totalSupply() + unmintedRebaseRewards();\n    }\n\n    /// @notice Target total number of the tokens in existence after interpolations\n    /// of rebase rewards will have completed.\n    /// @dev Equal to totalSupply() + pendingDistributedSupply().\n    function targetTotalSupply() external view returns (uint256) {\n        return ERC20.totalSupply() + __unmintedRebaseRewards.targetValue;\n    }\n\n    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),\n    /// and re-enter rebasing after movement (if rebasing).\n    /// @dev for _burn(), _mint(), transfer(), and transferFrom() overrides, a naive\n    /// and concise implementation would be to just _exitRebase(), call the default ERC20 behavior,\n    /// and then _enterRebase(), on the 2 addresses affected by the movement, but this is highly gas\n    /// inefficient and the more complex implementations below are saving up to 40% gas costs.\n    function _burn(address account, uint256 amount) internal virtual override {\n        // if `account` is rebasing, materialize the tokens from rebase first, to ensure\n        // proper behavior in `ERC20._burn()`.\n        RebasingState memory _rebasingState = rebasingState[account];\n        uint256 balanceBefore;\n        uint256 _rebasingSharePrice;\n        if (_rebasingState.isRebasing == 1) {\n            balanceBefore = ERC20.balanceOf(account);\n            _rebasingSharePrice = rebasingSharePrice();\n            uint256 rebasedBalance = _shares2balance(\n                _rebasingState.nShares,\n                _rebasingSharePrice,\n                0,\n                balanceBefore\n            );\n            uint256 mintAmount = rebasedBalance - balanceBefore;\n            if (mintAmount != 0) {\n                ERC20._mint(account, mintAmount);\n                balanceBefore += mintAmount;\n                decreaseUnmintedRebaseRewards(mintAmount);\n                emit RebaseReward(account, block.timestamp, mintAmount);\n            }\n        }\n\n        // do ERC20._burn()\n        ERC20._burn(account, amount);\n\n        // if `account` is rebasing, update its number of shares\n        if (_rebasingState.isRebasing == 1) {\n            uint256 balanceAfter = balanceBefore - amount;\n            uint256 sharesAfter = _balance2shares(\n                balanceAfter,\n                _rebasingSharePrice\n            );\n            uint256 sharesBurnt = _rebasingState.nShares - sharesAfter;\n            rebasingState[account] = RebasingState({\n                isRebasing: 1,\n                nShares: uint248(sharesAfter)\n            });\n            updateTotalRebasingShares(\n                _rebasingSharePrice,\n                -int256(sharesBurnt)\n            );\n        }\n    }\n\n    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),\n    /// and re-enter rebasing after movement (if rebasing).\n    function _mint(address account, uint256 amount) internal virtual override {\n        // do ERC20._mint()\n        ERC20._mint(account, amount);\n\n        // if `account` is rebasing, update its number of shares\n        RebasingState memory _rebasingState = rebasingState[account];\n        if (_rebasingState.isRebasing == 1) {\n            // compute rebased balance\n            uint256 _rebasingSharePrice = rebasingSharePrice();\n            uint256 rawBalance = ERC20.balanceOf(account);\n            uint256 rebasedBalance = _shares2balance(\n                _rebasingState.nShares,\n                _rebasingSharePrice,\n                amount,\n                rawBalance\n            );\n\n            // update number of shares\n            uint256 sharesAfter = _balance2shares(\n                rebasedBalance,\n                _rebasingSharePrice\n            );\n            uint256 sharesReceived = sharesAfter - _rebasingState.nShares;\n            rebasingState[account] = RebasingState({\n                isRebasing: 1,\n                nShares: uint248(sharesAfter)\n            });\n            updateTotalRebasingShares(\n                _rebasingSharePrice,\n                int256(sharesReceived)\n            );\n\n            // \"realize\" unminted rebase rewards\n            uint256 mintAmount = rebasedBalance - rawBalance;\n            if (mintAmount != 0) {\n                ERC20._mint(account, mintAmount);\n                decreaseUnmintedRebaseRewards(mintAmount);\n                emit RebaseReward(account, block.timestamp, mintAmount);\n            }\n        }\n    }\n\n    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),\n    /// and re-enter rebasing after movement (if rebasing).\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        // if `from` is rebasing, materialize the tokens from rebase to ensure\n        // proper behavior in `ERC20.transfer()`.\n        RebasingState memory rebasingStateFrom = rebasingState[msg.sender];\n        RebasingState memory rebasingStateTo = rebasingState[to];\n        uint256 fromBalanceBefore = ERC20.balanceOf(msg.sender);\n        uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||\n            rebasingStateTo.isRebasing == 1)\n            ? rebasingSharePrice()\n            : 0; // only SLOAD if at least one address is rebasing\n        if (rebasingStateFrom.isRebasing == 1) {\n            uint256 shares = uint256(rebasingStateFrom.nShares);\n            uint256 rebasedBalance = _shares2balance(\n                shares,\n                _rebasingSharePrice,\n                0,\n                fromBalanceBefore\n            );\n            uint256 mintAmount = rebasedBalance - fromBalanceBefore;\n            if (mintAmount != 0) {\n                ERC20._mint(msg.sender, mintAmount);\n                fromBalanceBefore += mintAmount;\n                decreaseUnmintedRebaseRewards(mintAmount);\n                emit RebaseReward(msg.sender, block.timestamp, mintAmount);\n            }\n        }\n\n        // do ERC20.transfer()\n        bool success = ERC20.transfer(to, amount);\n\n        // if `from` is rebasing, update its number of shares\n        int256 sharesDelta;\n        if (rebasingStateFrom.isRebasing == 1) {\n            uint256 fromBalanceAfter = fromBalanceBefore - amount;\n            uint256 fromSharesAfter = _balance2shares(\n                fromBalanceAfter,\n                _rebasingSharePrice\n            );\n            uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;\n            sharesDelta -= int256(sharesSpent);\n            rebasingState[msg.sender] = RebasingState({\n                isRebasing: 1,\n                nShares: uint248(fromSharesAfter)\n            });\n        }\n\n        // if `to` is rebasing, update its number of shares\n        if (rebasingStateTo.isRebasing == 1) {\n            // compute rebased balance\n            uint256 rawToBalanceAfter = ERC20.balanceOf(to);\n            uint256 toBalanceAfter = _shares2balance(\n                rebasingStateTo.nShares,\n                _rebasingSharePrice,\n                amount,\n                rawToBalanceAfter\n            );\n\n            // update number of shares\n            uint256 toSharesAfter = _balance2shares(\n                toBalanceAfter,\n                _rebasingSharePrice\n            );\n            uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares;\n            sharesDelta += int256(sharesReceived);\n            rebasingState[to] = RebasingState({\n                isRebasing: 1,\n                nShares: uint248(toSharesAfter)\n            });\n\n            // \"realize\" unminted rebase rewards\n            uint256 mintAmount = toBalanceAfter - rawToBalanceAfter;\n            if (mintAmount != 0) {\n                ERC20._mint(to, mintAmount);\n                decreaseUnmintedRebaseRewards(mintAmount);\n                emit RebaseReward(to, block.timestamp, mintAmount);\n            }\n        }\n\n        // if `from` or `to` was rebasing, update the total number of shares\n        if (\n            rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1\n        ) {\n            updateTotalRebasingShares(_rebasingSharePrice, sharesDelta);\n        }\n\n        return success;\n    }\n\n    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),\n    /// and re-enter rebasing after movement (if rebasing).\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        // if `from` is rebasing, materialize the tokens from rebase to ensure\n        // proper behavior in `ERC20.transfer()`.\n        RebasingState memory rebasingStateFrom = rebasingState[from];\n        RebasingState memory rebasingStateTo = rebasingState[to];\n        uint256 fromBalanceBefore = ERC20.balanceOf(from);\n        uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||\n            rebasingStateTo.isRebasing == 1)\n            ? rebasingSharePrice()\n            : 0;\n        if (rebasingStateFrom.isRebasing == 1) {\n            uint256 shares = uint256(rebasingStateFrom.nShares);\n            uint256 rebasedBalance = _shares2balance(\n                shares,\n                _rebasingSharePrice,\n                0,\n                fromBalanceBefore\n            );\n            uint256 mintAmount = rebasedBalance - fromBalanceBefore;\n            if (mintAmount != 0) {\n                ERC20._mint(from, mintAmount);\n                fromBalanceBefore += mintAmount;\n                decreaseUnmintedRebaseRewards(mintAmount);\n                emit RebaseReward(from, block.timestamp, mintAmount);\n            }\n        }\n\n        // do ERC20.transferFrom()\n        bool success = ERC20.transferFrom(from, to, amount);\n\n        // if `from` is rebasing, update its number of shares\n        int256 sharesDelta;\n        if (rebasingStateFrom.isRebasing == 1) {\n            uint256 fromBalanceAfter = fromBalanceBefore - amount;\n            uint256 fromSharesAfter = _balance2shares(\n                fromBalanceAfter,\n                _rebasingSharePrice\n            );\n            uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;\n            sharesDelta -= int256(sharesSpent);\n            rebasingState[from] = RebasingState({\n                isRebasing: 1,\n                nShares: uint248(fromSharesAfter)\n            });\n        }\n\n        // if `to` is rebasing, update its number of shares\n        if (rebasingStateTo.isRebasing == 1) {\n            // compute rebased balance\n            uint256 rawToBalanceAfter = ERC20.balanceOf(to);\n            uint256 toBalanceAfter = _shares2balance(\n                rebasingStateTo.nShares,\n                _rebasingSharePrice,\n                amount,\n                rawToBalanceAfter\n            );\n\n            // update number of shares\n            uint256 toSharesAfter = _balance2shares(\n                toBalanceAfter,\n                _rebasingSharePrice\n            );\n            uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares;\n            sharesDelta += int256(sharesReceived);\n            rebasingState[to] = RebasingState({\n                isRebasing: 1,\n                nShares: uint248(toSharesAfter)\n            });\n\n            // \"realize\" unminted rebase rewards\n            uint256 mintAmount = toBalanceAfter - rawToBalanceAfter;\n            if (mintAmount != 0) {\n                ERC20._mint(to, mintAmount);\n                decreaseUnmintedRebaseRewards(mintAmount);\n                emit RebaseReward(to, block.timestamp, mintAmount);\n            }\n        }\n\n        // if `from` or `to` was rebasing, update the total number of shares\n        if (\n            rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1\n        ) {\n            updateTotalRebasingShares(_rebasingSharePrice, sharesDelta);\n        }\n\n        return success;\n    }\n}"
    },
    {
      "filename": "src/tokens/ERC20RebaseDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeCastLib} from \"@src/external/solmate/SafeCastLib.sol\";\n\n/** \n@title  An ERC20 with rebase capabilities. Anyone can sacrifice tokens to rebase up the balance\n        of all addresses that are currently rebasing.\n@author eswak\n@notice This contract is meant to be used to distribute rewards proportionately to all holders of\n        a token, for instance to distribute buybacks or income generated by a protocol.\n\n        Anyone can subscribe to rebasing by calling `enterRebase()`, and unsubcribe with `exitRebase()`.\n        Anyone can burn tokens they own to `distribute(uint256)` proportionately to rebasing addresses.\n\n        The following conditions are always met :\n        ```\n        totalSupply() == nonRebasingSupply() + rebasingSupply()\n        sum of balanceOf(x) == totalSupply() [+= rounding down errors of 1 wei for each balanceOf]\n        ```\n\n        Internally, when a user subscribes to the rebase, their balance is converted to a number of\n        shares, and the total number of s"
    }
  ]
}