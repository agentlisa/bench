{
  "Title": "H-4: StrategyVault can perform a full exit without repaying all secondary debt",
  "Content": "# Issue H-4: StrategyVault can perform a full exit without repaying all secondary debt \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/184 \n\n## Found by \nxiaoming90\n## Summary\n\nStrategyVault can perform a full exit without repaying all secondary debt, leaving bad debt with the protocol.\n\n## Vulnerability Detail\n\nNoted from the [codebase's comment](https://github.com/notional-finance/contracts-v2/blob/63eb0b46ec37e5fc5447bdde3d951dd90f245741/contracts/external/actions/VaultAction.sol#L61) that:\n\n> Vaults can borrow up to the capacity using the `borrowSecondaryCurrencyToVault` and `repaySecondaryCurrencyToVault` methods. Vaults that use a secondary currency must ALWAYS repay the secondary debt during redemption and handle accounting for the secondary currency themselves.\n\nThus, when the StrategyVault-side performs a full exit for a vault account, Notional-side does not check that all secondary debts of that vault account are cleared (= zero) and will simply trust StrategyVault-side has already handled them properly.\n\nLine 271 below shows that only validates the primary debt but not the secondary debt during a full exit.\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/VaultAccountAction.sol#L271\n\n```solidity\nFile: VaultAccountAction.sol\n271:         if (vaultAccount.accountDebtUnderlying == 0 && vaultAccount.vaultShares == 0) {\n272:             // If the account has no position in the vault at this point, set the maturity to zero as well\n273:             vaultAccount.maturity = 0;\n274:         }\n275:         vaultAccount.setVaultAccount({vaultConfig: vaultConfig, checkMinBorrow: true});\n276: \n277:         // It's possible that the user redeems more vault shares than they lend (it is not always the case\n278:         // that they will be increasing their collateral ratio here, so we check that this is the case). No\n279:         // need to check if the account has exited in full (maturity == 0).\n280:         if (vaultAccount.maturity != 0) {\n281:             IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n282:         }\n```\n\n## Impact\n\nLeveraged vaults are designed to be as isolated as possible to mitigate the risk to the Notional protocol and its users. However, the above implementation seems to break this principle. As such, if there is a vulnerability in the leverage vault that allows someone to exploit this issue and bypass the repayment of the secondary debt, the protocol will be left with a bad debt which affects the insolvency of the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/VaultAccountAction.sol#L271\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider checking that all secondary debts of a vault account are cleared before executing a full exit.\n\n```diff\n+ int256 accountDebtOne;\n+ int256 accountDebtTwo;\n\n+ if (vaultConfig.hasSecondaryBorrows()) {\n+ \t(/* */, accountDebtOne, accountDebtTwo) = VaultSecondaryBorrow.getAccountSecondaryDebt(vaultConfig, account, pr);\n+ }\n\n- if (vaultAccount.accountDebtUnderlying == 0 && vaultAccount.vaultShares == 0) {\n+ if (vaultAccount.accountDebtUnderlying == 0 && vaultAccount.vaultShares == 0 && accountDebtOne == 0 && accountDebtTwo == 0) {\n\t// If the account has no position in the vault at this point, set the maturity to zero as well\n\tvaultAccount.maturity = 0;\n}\nvaultAccount.setVaultAccount({vaultConfig: vaultConfig, checkMinBorrow: true});\n```\n\n\n\n## Discussion\n\n**jeffywu**\n\nValid suggestion\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts/external/actions/VaultAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {IVaultAction} from \"../../../interfaces/notional/IVaultController.sol\";\nimport \"../../internal/vaults/VaultConfiguration.sol\";\nimport \"../../internal/vaults/VaultAccount.sol\";\nimport {VaultStateLib, VaultState} from \"../../internal/vaults/VaultState.sol\";\n\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\ncontract VaultAction is ActionGuards, IVaultAction {\n    using VaultConfiguration for VaultConfig;\n    using VaultAccountLib for VaultAccount;\n    using VaultStateLib for VaultState;\n    using AssetRate for AssetRateParameters;\n    using TokenHandler for Token;\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n\n    /// @notice Updates or lists a deployed vault along with its configuration.\n    /// @param vaultAddress address of deployed vault\n    /// @param vaultConfig struct of vault configuration\n    /// @param maxPrimaryBorrowCapacity maximum borrow capacity\n    function updateVault(\n        address vaultAddress,\n        VaultConfigStorage calldata vaultConfig,\n        uint80 maxPrimaryBorrowCapacity\n    ) external override onlyOwner {\n        VaultConfiguration.setVaultConfig(vaultAddress, vaultConfig);\n        VaultConfiguration.setMaxBorrowCapacity(vaultAddress, vaultConfig.borrowCurrencyId, maxPrimaryBorrowCapacity);\n        bool enabled = (vaultConfig.flags & VaultConfiguration.ENABLED) == VaultConfiguration.ENABLED;\n        emit VaultUpdated(vaultAddress, enabled, maxPrimaryBorrowCapacity);\n    }\n\n    /// @notice Enables or disables a vault. If a vault is disabled, no one can enter\n    /// the vault but exits are still possible.\n    /// @param vaultAddress address of deployed vault\n    /// @param enable true if the vault should be enabled immediately\n    function setVaultPauseStatus(\n        address vaultAddress,\n        bool enable\n    ) external override onlyOwner {\n        VaultConfiguration.setVaultEnabledStatus(vaultAddress, enable);\n        emit VaultPauseStatus(vaultAddress, enable);\n    }\n\n    /// @notice Enables or disables deleverage on a vault.\n    /// @param vaultAddress address of deployed vault\n    /// @param disableDeleverage true if the vault deleverage should be disabled\n    function setVaultDeleverageStatus(\n        address vaultAddress,\n        bool disableDeleverage\n    ) external override onlyOwner {\n        VaultConfiguration.setVaultDeleverageStatus(vaultAddress, disableDeleverage);\n        emit VaultDeleverageStatus(vaultAddress, disableDeleverage);\n    }\n\n    /// @notice Whitelists a secondary borrow currency for a vault, vaults can borrow up to the capacity\n    /// using the `borrowSecondaryCurrencyToVault` and `repaySecondaryCurrencyToVault` methods. Vaults that\n    /// use a secondary currency must ALWAYS repay the secondary debt during redemption and handle accounting\n    /// for the secondary currency themselves.\n    /// @param vaultAddress address of deployed vault\n    /// @param secondaryCurrencyId struct of vault configuration\n    /// @param maxBorrowCapacity maximum borrow capacity\n    function updateSecondaryBorrowCapacity(\n        address vaultAddress,\n        uint16 secondaryCurrencyId,\n        uint80 maxBorrowCapacity\n    ) external override onlyOwner {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vaultAddress);\n        // Tokens with transfer fees create lots of issues with vault mechanics, we prevent them\n        // from being listed here.\n        Token memory assetToken = TokenHandler.getAssetToken(secondaryCurrencyId);\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(secondaryCurrencyId);\n        require(!assetToken.hasTransferFee && !underlyingToken.hasTransferFee); \n\n        // The secondary borrow currency must be white listed on the configuration before we can set a max\n        // capacity.\n        require(\n            secondaryCurrencyId == vaultConfig.secondaryBorrowCurrencies[0] ||\n            secondaryCurrencyId == vaultConfig.secondaryBorrowCurrencies[1],\n            \"Invalid Currency\"\n        );\n\n        VaultConfiguration.setMaxBorrowCapacity(vaultAddress, secondaryCurrencyId, maxBorrowCapacity);\n        emit VaultUpdateSecondaryBorrowCapacity(vaultAddress, secondaryCurrencyId, maxBorrowCapacity);\n    }\n\n\n    /// @notice Allows the owner to reduce the max borrow capacity on the vault\n    /// @param vaultAddress address of the vault\n    /// @param maxVaultBorrowCapacity the new max vault borrow capacity on the primary currency\n    function setMaxBorrowCapacity(\n        address vaultAddress,\n        uint80 maxVaultBorrowCapacity\n    ) external override onlyOwner {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vaultAddress);\n        VaultConfiguration.setMaxBorrowCapacity(vaultAddress, vaultConfig.borrowCurrencyId, maxVaultBorrowCapacity);\n\n        emit VaultUpdated(vaultAddress, vaultConfig.getFlag(VaultConfiguration.ENABLED), maxVaultBorrowCapacity);\n    }\n\n    /// @notice Allows the owner to reduce the max borrow capacity on the vault and force\n    /// the redemption of strategy tokens to cash to reduce the overall risk of the vault.\n    /// This method is intended to be used in emergencies to mitigate insolvency risk. The effect\n    /// of this method will mean that the overall max borrow capacity is reduced, the total used\n    /// capacity will be unchanged (redeemStrategyTokensToCash does not do any lending to reduce\n    /// the outstanding fCash), and accounts will be locked out of entering the maturity which was\n    /// targeted by this method. Other maturities for that vault may still be entered depending on\n    /// whether or not the vault is above or below the max vault borrow capacity.\n    /// @param vaultAddress address of the vault\n    /// @param maxVaultBorrowCapacity the new max vault borrow capacity on the primary currency\n    /// @param maturity the maturity to redeem tokens in, will generally be either the current\n    /// maturity or the next maturity.\n    /// @param strategyTokensToRedeem how many tokens we would want to redeem in the maturity\n    /// @param vaultData vault data to pass to the vault\n    function reduceMaxBorrowCapacity(\n        address vaultAddress,\n        uint80 maxVaultBorrowCapacity,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata vaultData\n    ) external override onlyOwner {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vaultAddress);\n        VaultConfiguration.setMaxBorrowCapacity(vaultAddress, vaultConfig.borrowCurrencyId, maxVaultBorrowCapacity);\n\n        // Redeems strategy tokens to be held against fCash debt\n        _redeemStrategyTokensToCashInternal(vaultConfig, maturity, strategyTokensToRedeem, vaultData);\n\n        emit VaultUpdated(vaultAddress, vaultConfig.getFlag(VaultConfiguration.ENABLED), maxVaultBorrowCapacity);\n    }\n\n    /// @notice Strategy vaults can call this method to redeem strategy tokens to cash and hold them\n    /// as asset cash within the pool. This should typically be used during settlement but can also be\n    /// used for vault-wide deleveraging.\n    /// @param maturity the maturity of the vault where the redemption will take place\n    /// @param strategyTokensToRedeem the number of strategy tokens redeemed\n    /// @param vaultData arbitrary data to pass back to the vault\n    /// @return assetCashRequiredToSettle amount of asset cash still remaining to settle the debt\n    /// @return underlyingCashRequiredToSettle amount of underlying cash still remaining to settle the debt\n    function redeemStrategyTokensToCash(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata vaultData\n    ) external override returns (int256 assetCashRequiredToSettle, int256 underlyingCashRequiredToSettle) {\n        // NOTE: this call must come from the vault itself\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(msg.sender);\n        // NOTE: if the msg.sender is not the vault itself this will revert\n        require(vaultConfig.getFlag(VaultConfiguration.ENABLED), \"Paused\");\n        return _redeemStrategyTokensToCashInternal(vaultConfig, maturity, strategyTokensToRedeem, vaultData);\n    }\n\n    /// @notice Redeems strategy tokens to cash\n    function _redeemStrategyTokensToCashInternal(\n        VaultConfig memory vaultConfig,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata vaultData\n    ) private nonReentrant returns (int256 assetCashRequiredToSettle, int256 underlyingCashRequiredToSettle) {\n        // If the vault allows further re-entrancy then set the status back to the default\n        if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n            reentrancyStatus = _NOT_ENTERED;\n        }\n\n        VaultState memory vaultState = VaultStateLib.getVaultState(vaultConfig.vault, maturity);\n        (int256 assetCashReceived, uint256 underlyingToReceiver) = vaultConfig.redeemWithoutDebtRepayment(\n            vaultConfig.vault, strategyTokensToRedeem, maturity, vaultData\n        );\n        require(assetCashReceived > 0);\n        // Safety check to ensure that the vault does not somehow receive tokens in this scenario\n        require(underlyingToReceiver == 0);\n\n        vaultState.totalAssetCash = vaultState.totalAssetCash.add(uint256(assetCashReceived));\n        vaultState.totalStrategyTokens = vaultState.totalStrategyTokens.sub(strategyTokensToRedeem);\n        vaultState.setVaultState(vaultConfig.vault);\n\n        emit VaultRedeemStrategyToken(vaultConfig.vault, maturity, assetCashReceived, strategyTokensToRedeem);\n        return _getCashRequiredToSettle(vaultConfig, vaultState, maturity);\n    }\n\n    /// @notice Strategy vaults can call this method to deposit asset cash into strategy tokens.\n    /// @param maturity the maturity of the vault where the redemption will take place\n    /// @param assetCashInternal the number of asset cash tokens to deposit (external)\n    /// @param vaultData arbitrary data to pass back to the vault for deposit\n    function depositVaultCashToStrategyTokens(\n        uint256 maturity,\n        uint256 assetCashInternal,\n        bytes calldata vaultData\n    ) external override nonReentrant {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(msg.sender);\n        // NOTE: if the msg.sender is not the vault itself this will revert\n        require(vaultConfig.getFlag(VaultConfiguration.ENABLED), \"Paused\");\n\n        // If the vault allows further re-entrancy then set the status back to the default\n        if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n            reentrancyStatus = _NOT_ENTERED;\n        }\n\n        VaultState memory vaultState = VaultStateLib.getVaultState(msg.sender, maturity);\n        uint256 strategyTokensMinted = vaultConfig.deposit(\n            vaultConfig.vault, assetCashInternal.toInt(), maturity, 0, vaultData\n        );\n\n        vaultState.totalAssetCash = vaultState.totalAssetCash.sub(assetCashInternal);\n        vaultState.totalStrategyTokens = vaultState.totalStrategyTokens.add(strategyTokensMinted);\n        vaultState.setVaultState(msg.sender);\n\n        // When exchanging asset cash for strategy tokens we will decrease the vault's collateral, ensure that\n        // we don't go under the configured minimum here.\n        (int256 collateralRatio, /* */) = vaultConfig.calculateCollateralRatio(\n            vaultState, msg.sender, vaultState.totalVaultShares, vaultState.totalfCash\n        );\n        require(vaultConfig.minCollateralRatio <= collateralRatio, \"Insufficient Collateral\");\n        emit VaultMintStrategyToken(msg.sender, maturity, assetCashInternal, strategyTokensMinted);\n    }\n\n    /// @notice Allows a vault to borrow a secondary currency if it is whitelisted to do so\n    /// @param account account that is borrowing the secondary currency\n    /// @param maturity the maturity to borrow at\n    /// @param fCashToBorrow fCash to borrow for the first and second secondary currencies\n    /// @param maxBorrowRate maximum borrow rate for the first and second secondary currencies\n    /// @param minRollLendRate max roll lend rate for the first and second borrow currencies\n    /// @return underlyingTokensTransferred amount of tokens transferred back to the vault\n    function borrowSecondaryCurrencyToVault(\n        address account,\n        uint256 maturity,\n        uint256[2] calldata fCashToBorrow,\n        uint32[2] calldata maxBorrowRate,\n        uint32[2] calldata minRollLendRate\n    ) external override returns (uint256[2] memory underlyingTokensTransferred) {\n        // This method call must come from the vault\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(msg.sender);\n        // This also ensures that the caller is an actual vault\n        require(vaultConfig.getFlag(VaultConfiguration.ENABLED), \"Paused\");\n        uint16[2] memory currencies = vaultConfig.secondaryBorrowCurrencies;\n        require(currencies[0] != 0 || currencies[1] != 0);\n\n        VaultAccountSecondaryDebtShareStorage storage s = \n            LibStorage.getVaultAccountSecondaryDebtShare()[account][vaultConfig.vault];\n        uint256 accountMaturity = s.maturity;\n        \n        // If the borrower is rolling their primary debt forward, we need to check that here and roll\n        // their secondary debt forward in the same manner (simulate lending and then borrow more in\n        // a longer dated maturity to repay their borrowing). Rolling debts forward can only occur if:\n        //  - borrower has an existing debt position\n        //  - borrower is rolling to a longer dated maturity\n        //  - vault allows rolling positions forward\n        //  - borrower is not the vault itself (only individual accounts can roll borrows)\n        int256[2] memory costToRepay;\n        if (\n            accountMaturity != 0 &&\n            accountMaturity < maturity &&\n            vaultConfig.getFlag(VaultConfiguration.ALLOW_ROLL_POSITION) &&\n            account != msg.sender\n        ) {\n            costToRepay[0] = _repayDuringRoll(\n                vaultConfig, account, currencies[0], accountMaturity, s.accountDebtSharesOne, minRollLendRate[0]\n            );\n            costToRepay[1] = _repayDuringRoll(\n                vaultConfig, account, currencies[1], accountMaturity, s.accountDebtSharesTwo, minRollLendRate[1]\n            );\n        }\n\n        underlyingTokensTransferred[0] = _borrowAndTransfer(\n            vaultConfig, account, currencies[0], maturity, costToRepay[0], fCashToBorrow[0], maxBorrowRate[0]\n        );\n        underlyingTokensTransferred[1] = _borrowAndTransfer(\n            vaultConfig, account, currencies[1], maturity, costToRepay[1], fCashToBorrow[1], maxBorrowRate[1]\n        );\n    }\n\n    function _repayDuringRoll(\n        VaultConfig memory vaultConfig,\n        address account,\n        uint16 currencyId,\n        uint256 maturity,\n        uint256 accountDebtShares,\n        uint32 minLendRate\n    ) private returns (int256 costToRepay) {\n        if (currencyId != 0 && accountDebtShares != 0) {\n            (costToRepay, /* */) = vaultConfig.repaySecondaryBorrow(\n                account, currencyId, maturity, accountDebtShares, minLendRate\n            );\n        }\n    }\n\n    function _borrowAndTransfer(\n        VaultConfig memory vaultConfig,\n        address account,\n        uint16 currencyId,\n        uint256 maturity,\n        int256 costToRepay,\n        uint256 fCashToBorrow,\n        uint32 maxBorrowRate\n    ) private returns (uint256 underlyingTokensTransferred) {\n        if ((currencyId == 0 || fCashToBorrow == 0) && costToRepay == 0) return 0;\n\n        (int256 netBorrowedCash, /* */) = vaultConfig.increaseSecondaryBorrow(\n            account, currencyId, maturity, fCashToBorrow, maxBorrowRate\n        );\n\n        netBorrowedCash = netBorrowedCash.add(costToRepay);\n        require(netBorrowedCash >= 0, \"Insufficient Secondary Borrow\");\n\n        underlyingTokensTransferred = VaultConfiguration.transferFromNotional(\n            vaultConfig.vault, currencyId, netBorrowedCash\n        );\n    }\n\n    /// @notice Allows a vault to repay a secondary currency that it has borrowed. Will be executed via a callback\n    /// which will request that the vault repay a specific amount of underlying tokens.\n    /// @param account account that is repaying the secondary currency\n    /// @param currencyId currency id of the secondary currency\n    /// @param maturity the maturity to lend at\n    /// @param debtSharesToRepay amount of debt shares to repay (used to calculate fCashToLend)\n    /// @param minLendRate minimum lend rate\n    /// @return returnData arbitrary return data to pass back to the vault\n    function repaySecondaryCurrencyFromVault(\n        address account,\n        uint16 currencyId,\n        uint256 maturity,\n        uint256 debtSharesToRepay,\n        uint32 minLendRate,\n        bytes calldata callbackData\n    ) external override returns (bytes memory returnData) {\n        // Short circuits a zero debt shares to repay to save gas and avoid divide by zero issues\n        if (debtSharesToRepay == 0) return returnData;\n\n        // This method call must come from the vault\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(msg.sender);\n        require(vaultConfig.getFlag(VaultConfiguration.ENABLED), \"Paused\");\n\n        (int256 netAssetCash, /* */) = vaultConfig.repaySecondaryBorrow(\n            account, currencyId, maturity, debtSharesToRepay, minLendRate\n        );\n\n        Token memory assetToken = TokenHandler.getAssetToken(currencyId);\n        // The vault MUST return exactly this amount of underlying tokens to the vault in the callback. We use\n        // a callback here because it is more precise and gas efficient than calculating netAssetCash twice\n        uint256 balanceTransferred;\n        {\n            // If the asset token is NonMintable then the underlying is the same object.\n            Token memory underlyingToken = assetToken.tokenType == TokenType.NonMintable ? \n                assetToken :\n                TokenHandler.getUnderlyingToken(currencyId);\n\n            uint256 underlyingExternalToRepay = underlyingToken.convertToUnderlyingExternalWithAdjustment(\n                vaultConfig.assetRate.convertToUnderlying(netAssetCash).neg()\n            ).toUint();\n\n            uint256 balanceBefore = underlyingToken.balanceOf(address(this));\n            // Tells the vault will redeem the strategy token amount and transfer asset tokens back to Notional\n            returnData = IStrategyVault(msg.sender).repaySecondaryBorrowCallback(\n                underlyingToken.tokenAddress, underlyingExternalToRepay, callbackData\n            );\n            uint256 balanceAfter = underlyingToken.balanceOf(address(this));\n            balanceTransferred = balanceAfter.sub(balanceBefore);\n            require(balanceTransferred >= underlyingExternalToRepay, \"Insufficient Repay\");\n        }\n\n        // NonMintable tokens do not require minting\n        if (assetToken.tokenType != TokenType.NonMintable) {\n            assetToken.mint(currencyId, balanceTransferred);\n        }\n    }\n\n    /**\n     * @notice MUST be called by vaults that are using secondary borrows to initiate the settlement\n     * process. Once settlement process has been initiated, no further secondary borrows may occur in\n     * this maturity. Repayments can only occur via the vault itself, individual accounts cannot repay\n     * secondary borrows after this occurs. Can only be called by the vault.\n     * @param maturity maturity in which to initiate settlement\n     * @return secondaryBorrowSnapshot value of fCash in primary currency terms for both secondary borrow\n     * currencies\n     */\n    function initiateSecondaryBorrowSettlement(\n        uint256 maturity\n    ) external override returns (uint256[2] memory secondaryBorrowSnapshot) {\n        // This method call must come from the vault\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(msg.sender);\n        require(vaultConfig.getFlag(VaultConfiguration.ENABLED), \"Paused\");\n\n        secondaryBorrowSnapshot[0] = vaultConfig.snapshotSecondaryBorrowAtSettlement(\n            vaultConfig.secondaryBorrowCurrencies[0],\n            maturity\n        ).toUint();\n\n        secondaryBorrowSnapshot[1] = vaultConfig.snapshotSecondaryBorrowAtSettlement(\n            vaultConfig.secondaryBorrowCurrencies[1],\n            maturity\n        ).toUint();\n    }\n\n    /// @notice Settles a vault and sets the final settlement rates\n    /// @param vault the vault to settle\n    /// @param maturity the maturity of the vault\n    function settleVault(address vault, uint256 maturity) external override nonReentrant {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        // Allow anyone to call this method unless it must be authorized by the vault. Generally speaking,\n        // as long as there is sufficient cash on the vault we should be able to settle\n        vaultConfig.authorizeCaller(msg.sender, VaultConfiguration.ONLY_VAULT_SETTLE);\n\n        VaultState memory vaultState = VaultStateLib.getVaultState(vault, maturity);\n        // Ensure that we are past maturity and the vault is able to settle\n        require(maturity <= block.timestamp && vaultState.isSettled == false, \"Cannot Settle\");\n\n        AssetRateParameters memory settlementRate = AssetRate.buildSettlementRateStateful(\n            vaultConfig.borrowCurrencyId,\n            maturity,\n            block.timestamp\n        );\n\n        // This is how much it costs in asset cash to settle the pooled portion of the vault\n        uint256 assetCashRequiredToSettle = settlementRate.convertFromUnderlying(\n            vaultState.totalfCash.neg()\n        ).toUint();\n\n        // Validate that all secondary currencies have been paid off.\n        mapping(uint256 => VaultSecondaryBorrowStorage) storage perCurrencyBalance =\n            LibStorage.getVaultSecondaryBorrow()[vault][maturity];\n        if (vaultConfig.secondaryBorrowCurrencies[0] != 0) {\n            require(perCurrencyBalance[vaultConfig.secondaryBorrowCurrencies[0]].totalfCashBorrowed == 0, \"Unpaid Borrow\");\n        }\n        if (vaultConfig.secondaryBorrowCurrencies[1] != 0) {\n            require(perCurrencyBalance[vaultConfig.secondaryBorrowCurrencies[1]].totalfCashBorrowed == 0, \"Unpaid Borrow\");\n        }\n\n        if (vaultState.totalAssetCash < assetCashRequiredToSettle) {\n            // Don't allow the pooled portion of the vault to have a cash shortfall unless all\n            // strategy tokens have been redeemed to asset cash.\n            require(vaultState.totalStrategyTokens == 0, \"Redeem all tokens\");\n\n            // After this point, we have a cash shortfall and will need to resolve it.\n            // Underflow checked above\n            int256 assetCashShortfall = (assetCashRequiredToSettle - vaultState.totalAssetCash).toInt();\n            uint256 assetCashRaised = VaultConfiguration.resolveShortfallWithReserve(\n                vaultConfig.vault, vaultConfig.borrowCurrencyId, assetCashShortfall, maturity\n            ).toUint();\n\n            vaultState.totalAssetCash = vaultState.totalAssetCash.add(assetCashRaised);\n            vaultState.setVaultState(vault);\n        }\n\n        // Clears the used borrow capacity regardless of the insolvency state of the vault. Since vaults are\n        // automatically paused in the case of any shortfall, no accounts will be able to enter regardless\n        // but we still want to maintain proper accounting of the borrow capacity.\n        VaultConfiguration.updateUsedBorrowCapacity(vault, vaultConfig.borrowCurrencyId, vaultState.totalfCash.neg());\n        vaultState.setSettledVaultState(vaultConfig, settlementRate, maturity, block.timestamp);\n    }\n\n    /** View Methods **/\n    function getVaultConfig(\n        address vault\n    ) external view override returns (VaultConfig memory vaultConfig) {\n        vaultConfig = VaultConfiguration.getVaultConfigView(vault);\n    }\n\n    function getVaultState(\n        address vault,\n        uint256 maturity\n    ) external view override returns (VaultState memory vaultState) {\n        vaultState = VaultStateLib.getVaultState(vault, maturity);\n    }\n\n    function getBorrowCapacity(\n        address vault,\n        uint16 currencyId\n    ) external view override returns (\n        uint256 totalUsedBorrowCapacity,\n        uint256 maxBorrowCapacity\n    ) {\n        VaultBorrowCapacityStorage storage cap = LibStorage.getVaultBorrowCapacity()[vault][currencyId];\n        totalUsedBorrowCapacity = cap.totalUsedBorrowCapacity;\n        maxBorrowCapacity = cap.maxBorrowCapacity;\n    }\n\n    function getSecondaryBorrow(\n        address vault,\n        uint16 currencyId,\n        uint256 maturity\n    ) external view override returns (\n        uint256 totalfCashBorrowed,\n        uint256 totalAccountDebtShares,\n        uint256 totalfCashBorrowedInPrimarySnapshot\n    ) {\n        VaultSecondaryBorrowStorage storage balance = \n            LibStorage.getVaultSecondaryBorrow()[vault][maturity][currencyId];\n        totalfCashBorrowed = balance.totalfCashBorrowed;\n        totalAccountDebtShares = balance.totalAccountDebtShares;\n        totalfCashBorrowedInPrimarySnapshot = balance.totalfCashBorrowedInPrimarySnapshot;\n    }\n\n    function getCashRequiredToSettle(\n        address vault,\n        uint256 maturity\n    ) external view override returns (\n        int256 assetCashRequiredToSettle,\n        int256 underlyingCashRequiredToSettle\n    ) {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigView(vault);\n        VaultState memory vaultState = VaultStateLib.getVaultState(vaultConfig.vault, maturity);\n        return _getCashRequiredToSettle(vaultConfig, vaultState, maturity);\n    }\n\n    function _getCashRequiredToSettle(\n        VaultConfig memory vaultConfig,\n        VaultState memory vaultState,\n        uint256 maturity\n    ) private view returns (\n        int256 assetCashRequiredToSettle,\n        int256 underlyingCashRequiredToSettle\n    ) {\n        // If this is prior to maturity, it will return the current asset rate. After maturity it will\n        // return the settlement rate.\n        AssetRateParameters memory ar = AssetRate.buildSettlementRateView(vaultConfig.borrowCurrencyId, maturity);\n        \n        // If this is a positive number, there is more cash remaining to be settled.\n        // If this is a negative number, there is more cash than required to repay the debt\n        int256 assetCashInternal = ar.convertFromUnderlying(vaultState.totalfCash)\n            .add(vaultState.totalAssetCash.toInt())\n            .neg();\n\n        Token memory assetToken = TokenHandler.getAssetToken(vaultConfig.borrowCurrencyId);\n        // If the asset token is NonMintable then the underlying is the same object.\n        assetCashRequiredToSettle = assetToken.convertToExternal(assetCashInternal);\n\n        if (assetToken.tokenType == TokenType.NonMintable) {\n            // In this case both values are the same, there is no underlying token\n            underlyingCashRequiredToSettle = assetCashRequiredToSettle;\n        } else {\n            Token memory underlyingToken = TokenHandler.getUnderlyingToken(vaultConfig.borrowCurrencyId);\n            underlyingCashRequiredToSettle = underlyingToken.convertToUnderlyingExternalWithAdjustment(\n                ar.convertToUnderlying(assetCashInternal)\n            );\n        }\n    }\n\n    function getLibInfo() external pure returns (address) {\n        return address(TradingAction);\n    }\n}"
    },
    {
      "filename": "contracts-v2/contracts/external/actions/VaultAccountAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    VaultAccount,\n    VaultState,\n    PrimeRate,\n    VaultConfig\n} from \"../../global/Types.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\n\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {VaultConfiguration} from \"../../internal/vaults/VaultConfiguration.sol\";\nimport {VaultAccountLib} from \"../../internal/vaults/VaultAccount.sol\";\nimport {VaultValuation} from \"../../internal/vaults/VaultValuation.sol\";\nimport {VaultStateLib, VaultState} from \"../../internal/vaults/VaultState.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {TradingAction} from \"./TradingAction.sol\";\nimport {IVaultAccountAction, IVaultAccountHealth} from \"../../../interfaces/notional/IVaultController.sol\";\n\ncontract VaultAccountAction is ActionGuards, IVaultAccountAction {\n    using VaultConfiguration for VaultConfig;\n    using VaultAccountLib for VaultAccount;\n    using VaultStateLib for VaultState;\n    using PrimeRateLib for PrimeRate;\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n\n    /// @notice Settles a matured vault account by transforming it from an fCash maturity into\n    /// a prime cash account. This method is not authenticated, anyone can settle a vault account\n    /// without permission. Generally speaking, this action is economically equivalent no matter\n    /// when it is called. In some edge conditions when the vault is holding prime cash, it is\n    /// advantageous for the vault account to have this called sooner. All vault account actions\n    /// will first settle the vault account before taking any further actions.\n    /// @param account the address to settle\n    /// @param vault the vault the account is in\n    function settleVaultAccount(address account, address vault) external override nonReentrant {\n        requireValidAccount(account);\n        require(account != vault);\n\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n        \n        // Require that the account settled, otherwise we may leave the account in an unintended\n        // state in this method because we allow it to skip the min borrow check in the next line.\n        (bool didSettle, bool didTransfer) = vaultAccount.settleVaultAccount(vaultConfig);\n        require(didSettle, \"No Settle\");\n\n        vaultAccount.accruePrimeCashFeesToDebt(vaultConfig);\n\n        // Skip Min Borrow Check so that accounts can always be settled\n        vaultAccount.setVaultAccount({vaultConfig: vaultConfig, checkMinBorrow: false});\n\n        if (didTransfer) {\n            // If the vault did a transfer (i.e. withdrew cash) we have to check their collateral ratio. There\n            // is an edge condition where a vault with secondary borrows has an emergency exit. During that process\n            // an account will be left some cash balance in both currencies. It may have excess cash in one and\n            // insufficient cash in the other. A withdraw of the excess in one side will cause the vault account to\n            // be insolvent if we do not run this check. If this scenario indeed does occur, the vault itself must\n            // be upgraded in order to facilitate orderly exits for all of the accounts since they will be prevented\n            // from settling.\n            IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n        }\n    }\n\n    /// @notice Borrows a specified amount of fCash in the vault's borrow currency and deposits it\n    /// all plus the depositAmountExternal into the vault to mint strategy tokens.\n    /// @param account the address that will enter the vault\n    /// @param vault the vault to enter\n    /// @param depositAmountExternal some amount of additional collateral in the borrowed currency\n    /// to be transferred to vault\n    /// @param maturity the maturity to borrow at\n    /// @param borrowAmount amount to borrow, for fCash maturities this is the fCash amount. For pCash\n    /// maturities this is the underlying borrowed.\n    /// @param maxBorrowRate maximum interest rate to borrow at, only applies as a slippage limit for\n    /// fCash maturities\n    /// @param vaultData additional data to pass to the vault contract\n    /// @return vaultSharesAdded the total vault shares tokens added to the maturity. Allows enterVault\n    /// to be used by off-chain methods to get an accurate simulation of the strategy tokens minted.\n    function enterVault(\n        address account,\n        address vault,\n        uint256 depositAmountExternal,\n        uint256 maturity"
    }
  ]
}