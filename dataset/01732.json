{
  "Title": "M-9: A trader close to liquidation risks being liquidated by trying to reduce her position",
  "Content": "# Issue M-9: A trader close to liquidation risks being liquidated by trying to reduce her position \n\nSource: https://github.com/sherlock-audit/2023-05-perennial-judging/issues/76 \n\n## Found by \ncergyk\n## Summary\nA trader close to liquidation risks being liquidated by trying to reduce her position\n\n## Vulnerability Detail\nWe can see in the implementation of closeTake/closeMake that the `maintenanceInvariant` is not enforced:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L246-L256\n\nand the takerFee is deducted immediately from traders collateral, whereas the position reduction only takes effect at next settlement:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L258-L273\n\nThis means that a legitimate user close to liquidation, who may want to reduce leverage by closing position will end up immediately liquidatable.\n\nExample:\n>Maintenance factor is 2%\n>Liquidation fee is 5%\n>Taker fee is 0.1%\n>Funding fee is 0%\n\nAlice has a 50x leverage `taker` position opened as authorized per maintenance invariant:\n\nAlice collateral: 100 DSU\nAlice taker position: notional of 5000 DSU\n\nAlice tries to reduce her position to a more reasonable 40x, calls `closeTake(1000)`. \nA 1 DSU taker fee is deducted immediately from her collateral. Since the reduction of the position only takes effect on next oracle version, her position becomes immediately liquidatable. \nA liquidator closes it entirely, making Alice lose an additional 4 DSU `takerFee` on next settlement and 250 DSU of liquidationFee.\n\n## Impact\nA user trying to avoid liquidation is liquidated unjustly\n\n## Code Snippet\n\n## Tool used\nManual Review\n\n## Recommendation\nEither:\n- Do not deduce takerFee from collateral immediately, but at next settlement, as any other fees\nor\n- Enforce `maintenanceInvariant` on closing of positions, to make transaction revert (except when closing is liquidation already)\n\n\n\n## Discussion\n\n**SergeKireev**\n\nEscalate for 10 USDC\n\nDisagree with downgrading of severity.\nAlthough it can be argued the loss of funds is self-inflicted, reducing the position when near liquidation is the most reasonable choice to avoid liquidation.\nInstead of avoiding the liquidation, the user makes himself instantly liquidatable and risks losing 5% to 10% of collateral, which can be an unbounded loss of funds.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Disagree with downgrading of severity.\n> Although it can be argued the loss of funds is self-inflicted, reducing the position when near liquidation is the most reasonable choice to avoid liquidation.\n> Instead of avoiding the liquidation, the user makes himself instantly liquidatable and risks losing 5% to 10% of collateral, which can be an unbounded loss of funds.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**sherlock-admin**\n\n> Escalate for 10 USDC\n> This is not valid M.\n> In this situation on the verge of liquidation, no matter what you do, if the price moves in the direction of loss, the liquidation will occur. On the contrary, the position is safe. This is a normal phenomenon. The safe thing to do is to increase the margin.\n\n    You've deleted an escalation for this issue.\n\n**mstpr**\n\nEscalate for 10 USDC\n\nI think this issue is invalid or informational.\n\nFirst of all, that's a great point. However, I feel like that the users should be aware of this already. Maker/taker fees are actually the open/close position fees which they should be aware all the time. So, if a user closes some of their position they should know that there is a fee that they need to pay. If that fee takes them to liquidation level, this should be ok because that's how the system works. \n\nHere how I see the case: \nIn a product with both open/close position fees;\nIf a user with a perfectly healthy position wants to leverage its position, they will pay an open position fee which is acceptable. When the same users wants to deleverage, it's also acceptable to take the close position fee. However, just because the deleverage now puts the user in liquidation, why is it not acceptable to take the close position fees? I think this is how the system works. Just because user is liquidatable after the position fees shouldn't mean that the protocol should not take fees from their action.\n\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I think this issue is invalid or informational.\n> \n> First of all, that's a great point. However, I feel like that the users should be aware of this already. Maker/taker fees are actually the open/close position fees which they should be aware all the time. So, if a user closes some of their position they should know that there is a fee that they need to pay. If that fee takes them to liquidation level, this should be ok because that's how the system works. \n> \n> Here how I see the case: \n> In a product with both open/close position fees;\n> If a user with a perfectly healthy position wants to leverage its position, they will pay an open position fee which is acceptable. When the same users wants to deleverage, it's also acceptable to take the close position fee. However, just because the deleverage now puts the user in liquidation, why is it not acceptable to take the close position fees? I think this is how the system works. Just because user is liquidatable after the position fees shouldn't mean that the protocol should not take fees from their action.\n> \n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**SergeKireev**\n\n> Escalate for 10 USDC\n> \n> I think this issue is invalid or informational.\n> \n> First of all, that's a great point. However, I feel like that the users should be aware of this already. Maker/taker fees are actually the open/close position fees which they should be aware all the time. So, if a user closes some of their position they should know that there is a fee that they need to pay. If that fee takes them to liquidation level, this should be ok because that's how the system works. \n> \n> Here how I see the case: \n> In a product with both open/close position fees;\n> If a user with a perfectly healthy position wants to leverage its position, they will pay an open position fee which is acceptable. When the same users wants to deleverage, it's also acceptable to take the close position fee. However, just because the deleverage now puts the user in liquidation, why is it not acceptable to take the close position fees? I think this is how the system works. Just because user is liquidatable after the position fees shouldn't mean that the protocol should not take fees from their action.\n> \n> \n\nGreat point as well. This report does not argue that the protocol should not take a fee in that case, just that it should be taken at next settlement (like funding fees for example).\nThe user reduces position, fee is deducted upon next settlement, and the user is never liquidatable, everybody is happy\n\nThe situation described in this report arises from the fact that collateral handling is not consistent:\nopen/close fee is subtracted right away, and all other collateral/position modifications occur at next settlement\n\n\n**KenzoAgada**\n\nI think the various points above show why a medium severity is appropriate.\n\nOn one hand it is self inflicted, limited in scope, and depends upon a user not leaving any room for error (price movements/fees) at all, so I don't think it deserves high severity.\n\nOn the other hand, it is unintuitive that partially closing a dangerous position should make you liquidatable right away. I think there _is_ a seeming inconsistency in the fact that position fees are deducted right away and can make a position that was already safe in the current version liquidatable. When withdrawing collateral there is a check that the user has enough collateral for maintenance of current version, but there's no such check in the scenario this issue describes.\n\nI would maintain medium severity.\n\n**jacksanford1**\n\n@mstpr Thoughts on the above comments? Seems like it's the ordering of not taking the fee at next settlement?\n\n**mstpr**\n\n@jacksanford1 I would say it is probably not possible or not a secure way to do that. I would love to hear the protocol teams response on that since taking the fee after settlement or before settlement is their design choice. In my opinion, it looks too risky or undoable to take the fee after settlement so that's why they went for this implementation. \n\n**SergeKireev**\n\n@jacksanford1 @mstpr additional remarks:\n- It is understood that unifying this fees handling is a bit more than a trivial fix. A temporary solution could just to add an invariant which checks if the user becomes liquidatable by doing this call and revert in that case.\n\n- There is another really weird quirk with current implementation: If the user goes through the scenario outlined in the report, and closes his position entirely, the liquidator just takes some of the collateral without providing any utility.\n\nIndeed the positions are already being closed, so this call is a noop:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L362-L372\n\nThe liquidator does not help the protocol but takes a potentially hefty fee at the expense of an innocent user.\n\n**jacksanford1**\n\n@mstpr @SergeKireev I hear your points on the difficulty of the fix, but the difficulty of the fix should not have an effect on the severity of the issue. \n\nIs there an argument for why this issue is invalid? @mstpr \n\nAnd what is the argument for High vs. Medium @SergeKireev (after seeing Kenzo's latest comment)?\n\n**SergeKireev**\n\n> @mstpr @SergeKireev I hear your points on the difficulty of the fix, but the difficulty of the fix should not have an effect on the severity of the issue.\n> \n> Is there an argument for why this issue is invalid? @mstpr\n> \n> And what is the argument for High vs. Medium @SergeKireev (after seeing Kenzo's latest comment)?\n\nMy argument for saying this should be `High` is an assessment of impact and probability:\n- Impact: Loss of user funds for a large amount (The whole amount of collateral of the user).\n- Probability:\nIf the user is on the brink of liquidation, closing or reducing her position seems like the most sensible action.\nWith regards to latest @KenzoAgada comment, a user does not necessarily need to open a 50x (max leverage) position, he can also get into this situation simply by accumulating negative uPnl\n\n**mstpr**\n\nI am still seeing this issue as a design choice. Users are aware that there is a maker fee and it's updatable by the protocol team. Traders should always be cautious on their position and maintain it, that's their responsibility and that's a risk they took by taking the position. If user doesn't want to get liquidated, they can add some collateral and deleverage in the current design. It's not that the user has no other ways to dodge liquidation.  @jacksanford1 @SergeKireev \n\n\n\n\n\n**jacksanford1**\n\nThanks @SergeKireev @mstpr \n\nI see it pretty clearly as a Medium. This is not a \"blackhat can exploit the whole protocol\" type of magnitude, it's just one user who is likely already near the brink of liquidation. \n\nBut I think the issue is real and worth potentially fixing (or at least knowing about) because it could have a very negative unintended effect for a user who wants to derisk their position. \n\n**jacksanford1**\n\nResult:\nMedium\nUnique\nPlease see above comment for full reasoning. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [SergeKireev](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/76/#issuecomment-1614702123): rejected\n- [mstpr](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/76/#issuecomment-1615195887): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/79",
  "Code": [
    {
      "filename": "perennial-mono/packages/perennial/contracts/product/Product.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../controller/UControllerProvider.sol\";\nimport \"./UPayoffProvider.sol\";\nimport \"./UParamProvider.sol\";\nimport \"./types/position/AccountPosition.sol\";\nimport \"./types/accumulator/AccountAccumulator.sol\";\n\n/**\n * @title Product\n * @notice Manages logic and state for a single product market.\n * @dev Cloned by the Controller contract to launch new product markets.\n */\ncontract Product is IProduct, UInitializable, UParamProvider, UPayoffProvider, UReentrancyGuard {\n    /// @dev Whether or not the product is closed\n    BoolStorage private constant _closed = BoolStorage.wrap(keccak256(\"equilibria.perennial.Product.closed\"));\n\n    function closed() public view returns (bool) {\n        return _closed.read();\n    }\n\n    /// @dev The name of the product\n    string public name;\n\n    /// @dev The symbol of the product\n    string public symbol;\n\n    /// @dev The individual position state for each account\n    mapping(address => AccountPosition) private _positions;\n\n    /// @dev The global position state for the product\n    VersionedPosition private _position;\n\n    /// @dev The individual accumulator state for each account\n    mapping(address => AccountAccumulator) private _accumulators;\n\n    /// @dev The global accumulator state for the product\n    VersionedAccumulator private _accumulator;\n\n    /**\n     * @notice Initializes the contract state\n     * @param productInfo_ Product initialization params\n     */\n    function initialize(ProductInfo calldata productInfo_) external initializer(1) {\n        __UControllerProvider__initialize(IController(msg.sender));\n        __UPayoffProvider__initialize(productInfo_.oracle, productInfo_.payoffDefinition);\n        __UReentrancyGuard__initialize();\n        __UParamProvider__initialize(\n            productInfo_.maintenance,\n            productInfo_.fundingFee,\n            productInfo_.makerFee,\n            productInfo_.takerFee,\n            productInfo_.positionFee,\n            productInfo_.makerLimit,\n            productInfo_.utilizationCurve\n        );\n\n        name = productInfo_.name;\n        symbol = productInfo_.symbol;\n    }\n\n    /**\n     * @notice Surfaces global settlement externally\n     */\n    function settle() external nonReentrant notPaused {\n        _settle();\n    }\n\n    /**\n     * @notice Core global settlement flywheel\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settle() private returns (IOracleProvider.OracleVersion memory currentOracleVersion) {\n        IController _controller = controller();\n\n        // Get current oracle version\n        currentOracleVersion = _sync();\n\n        // Get latest oracle version\n        uint256 _latestVersion = latestVersion();\n        if (_latestVersion == currentOracleVersion.version) return currentOracleVersion; // short circuit entirely if a == c\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(_latestVersion);\n\n        // Get settle oracle version\n        uint256 _settleVersion = _position.pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // Initiate\n        _controller.incentivizer().sync(currentOracleVersion);\n        UFixed18 boundedFundingFee = _boundedFundingFee();\n\n        // value a->b\n        UFixed18 accumulatedFee = _accumulator.accumulate(\n            boundedFundingFee, _position, latestOracleVersion, settleOracleVersion);\n\n        // position a->b\n        _position.settle(_latestVersion, settleOracleVersion);\n\n        // Apply any pending fee updates if present\n        _settleFeeUpdates();\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // value b->c\n            accumulatedFee = accumulatedFee.add(\n                _accumulator.accumulate(boundedFundingFee, _position, settleOracleVersion, currentOracleVersion)\n            );\n\n            // position b->c (every accumulator version needs a position stamp)\n            _position.settle(settleOracleVersion.version, currentOracleVersion);\n        }\n\n        // settle collateral\n        _controller.collateral().settleProduct(accumulatedFee);\n\n        emit Settle(settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Surfaces account settlement externally\n     * @param account Account to settle\n     */\n    function settleAccount(address account) external nonReentrant notPaused {\n        IOracleProvider.OracleVersion memory currentOracleVersion = _settle();\n        _settleAccount(account, currentOracleVersion);\n    }\n\n    /**\n     * @notice Core account settlement flywheel\n     * @param account Account to settle\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settleAccount(address account, IOracleProvider.OracleVersion memory currentOracleVersion) private {\n        IController _controller = controller();\n\n        // Get latest oracle version\n        if (latestVersion(account) == currentOracleVersion.version) return; // short circuit entirely if a == c\n\n        // Get settle oracle version\n        uint256 _settleVersion = _positions[account].pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // sync incentivizer before accumulator\n        _controller.incentivizer().syncAccount(account, settleOracleVersion);\n\n        // value a->b\n        Fixed18 accumulated = _accumulators[account].syncTo(\n            _accumulator, _positions[account], settleOracleVersion.version).sum();\n\n        // position a->b\n        _positions[account].settle(settleOracleVersion);\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // sync incentivizer before accumulator\n            _controller.incentivizer().syncAccount(account, currentOracleVersion);\n\n            // value b->c\n            accumulated = accumulated.add(\n                _accumulators[account].syncTo(_accumulator, _positions[account], currentOracleVersion.version).sum()\n            );\n        }\n\n        // settle collateral\n        _controller.collateral().settleAccount(account, accumulated);\n\n        emit AccountSettle(account, settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Opens a taker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openTake(UFixed18 amount) external {\n        openTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open the position for\n     * @param amount Amount of the position to open\n     */\n    function openTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        maxUtilizationInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openTake(latestOracleVersion.version, amount);\n        _position.pre.openTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeTake(UFixed18 amount) external {\n        closeTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeTake(account, amount);\n    }\n\n    function _closeTake(address account, UFixed18 amount) private {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.closeTake(latestOracleVersion.version, amount);\n        _position.pre.closeTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeClosed(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Opens a maker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openMake(UFixed18 amount) external {\n        openMakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a maker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open position for\n     * @param amount Amount of the position to open\n     */\n    function openMakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        nonZeroVersionInvariant\n        makerInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openMake(latestOracleVersion.version, amount);\n        _position.pre.openMake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(makerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit MakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a maker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeMake(UFixed18 amount) external {\n        closeMakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a maker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeMakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        takerInvariant\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeMake(account, amount);\n    }\n\n    function _closeMake(address account, UFixed18 amount) private {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.closeMake(latestOracleVersion.version, amount);\n        _position.pre.closeMake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(makerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit MakeClosed(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes all open and pending positions, locking for liquidation\n     * @dev Only callable by the Collateral contract as part of the liquidation flow\n     * @param account Account to close out\n     */\n    function closeAll(address account) external onlyCollateral notClosed settleForAccount(account) {\n        AccountPosition storage accountPosition = _positions[account];\n        Position memory p = accountPosition.position.next(_positions[account].pre);\n\n        // Close all positions\n        _closeMake(account, p.maker);\n        _closeTake(account, p.taker);\n\n        // Mark liquidation to lock position\n        accountPosition.liquidation = true;\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account`\n     * @param account Account to return for\n     * @return The current maintenance requirement\n     */\n    function maintenance(address account) external view returns (UFixed18) {\n        return _positions[account].maintenance();\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account` after next settlement\n     * @dev Assumes no price change and no funding, used to protect user from over-opening\n     * @param account Account to return for\n     * @return The next maintenance requirement\n     */\n    function maintenanceNext(address account) external view returns (UFixed18) {\n        return _positions[account].maintenanceNext();\n    }\n\n    /**\n     * @notice Returns whether `account` has a completely zero'd position\n     * @param account Account to return for\n     * @return The the account is closed\n     */\n    function isClosed(address account) external view returns (bool) {\n        return _positions[account].isClosed();\n    }\n\n    /**\n     * @notice Returns whether `account` is currently locked for an in-progress liquidation\n     * @param account Account to return for\n     * @return Whether the account is in liquidation\n     */\n    function isLiquidating(address account) external view returns (bool) {\n        return _positions[account].liquidation;\n    }\n\n    /**\n     * @notice Returns `account`'s current position\n     * @param account Account to return for\n     * @return Current position of the account\n     */\n    function position(address account) external view returns (Position memory) {\n        return _positions[account].position;\n    }\n\n    /**\n     * @notice Returns `account`'s current pending-settlement position\n     * @param account Account to return for\n     * @return Current pre-position of the account\n     */\n    function pre(address account) external view returns (PrePosition memory) {\n        return _positions[account].pre;\n    }\n\n    /**\n     * @notice Returns the global latest settled oracle version\n     * @return Latest settled oracle version of the product\n     */\n    function latestVersion() public view returns (uint256) {\n        return _accumulator.latestVersion;\n    }\n\n    /**\n     * @notice Returns the global position at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global position at oracle version\n     */\n    function positionAtVersion(uint256 oracleVersion) public view returns (Position memory) {\n        return _position.positionAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns the current global pending-settlement position\n     * @return Global pending-settlement position\n     */\n    function pre() external view returns (PrePosition memory) {\n        return _position.pre;\n    }\n\n    /**\n     * @notice Returns the global accumulator value at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator value at oracle version\n     */\n    function valueAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.valueAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns the global accumulator share at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator share at oracle version\n     */\n    function shareAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.shareAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns `account`'s latest settled oracle version\n     * @param account Account to return for\n     * @return Latest settled oracle version of the account\n     */\n    function latestVersion(address account) public view returns (uint256) {\n        return _accumulators[account].latestVersion;\n    }\n\n    /**\n     * @notice Returns The per-second rate based on the provided `position`\n     * @dev Handles 0-maker/taker edge cases\n     * @param position_ Position to base utilization on\n     * @return The per-second rate\n     */\n    function rate(Position calldata position_) public view returns (Fixed18) {\n        UFixed18 utilization = position_.taker.unsafeDiv(position_.maker);\n        Fixed18 annualizedRate = utilizationCurve().compute(utilization);\n        return annualizedRate.div(Fixed18Lib.from(365 days));\n    }\n\n    /**\n     * @notice Returns the minimum funding fee parameter with a capped range for safety\n     * @dev Caps controller.minFundingFee() <= fundingFee() <= 1\n     * @return Safe minimum funding fee parameter\n     */\n    function _boundedFundingFee() private view returns (UFixed18) {\n        return fundingFee().max(controller().minFundingFee());\n    }\n\n    /**\n     * @notice Updates product closed state\n     * @dev only callable by product owner. Settles the product before flipping the flag\n     * @param newClosed new closed value\n     */\n    function updateClosed(bool newClosed) external nonReentrant notPaused onlyProductOwner {\n        IOracleProvider.OracleVersion memory oracleVersion = _settle();\n        _closed.store(newClosed);\n        emit ClosedUpdated(newClosed, oracleVersion.version);\n    }\n\n    /**\n     * @notice Updates underlying product oracle\n     * @dev only callable by product owner\n     * @param newOracle new oracle address\n     */\n    function updateOracle(IOracleProvider newOracle) external onlyProductOwner {\n        _updateOracle(address(newOracle), latestVersion());\n    }\n\n    /// @dev Limit total maker for guarded rollouts\n    modifier makerInvariant() {\n        _;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n\n        if (next.maker.gt(makerLimit())) revert ProductMakerOverLimitError();\n    }\n\n    /// @dev Limit maker short exposure to the range 0.0-1.0x of their position. Does not apply when in closeOnly state\n    modifier takerInvariant() {\n        _;\n\n        if (closed()) return;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n        UFixed18 socializationFactor = next.socializationFactor();\n\n        if (socializationFactor.lt(UFixed18Lib.ONE)) revert ProductInsufficientLiquidityError(socializationFactor);\n    }\n\n    /// @dev Limit utilization to (1 - utilizationBuffer)\n    modifier maxUtilizationInvariant() {\n        _;\n\n        if (closed()) return;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n        UFixed18 utilization = next.taker.unsafeDiv(next.maker);\n        if (utilization.gt(UFixed18Lib.ONE.sub(utilizationBuffer())))\n            revert ProductInsufficientLiquidityError(utilization);\n    }\n\n    /// @dev Ensure that the user has only taken a maker or taker position, but not both\n    modifier positionInvariant(address account) {\n        _;\n\n        if (_positions[account].isDoubleSided()) revert ProductDoubleSidedError();\n    }\n\n    /// @dev Ensure that the user hasn't closed more than is open\n    modifier closeInvariant(address account) {\n        _;\n\n        if (_positions[account].isOverClosed()) revert ProductOverClosedError();\n    }\n\n    /// @dev Ensure that the user will have sufficient margin for maintenance after next settlement\n    modifier maintenanceInvariant(address account) {\n        _;\n\n        if (controller().collateral().liquidatableNext(account, IProduct(this)))\n            revert ProductInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the user is not currently being liquidated\n    modifier liquidationInvariant(address account) {\n        if (_positions[account].liquidation) revert ProductInLiquidationError();\n\n        _;\n    }\n\n    /// @dev Helper to fully settle an account's state\n    modifier settleForAccount(address account) {\n        IOracleProvider.OracleVersion memory _currentVersion = _settle();\n        _settleAccount(account, _currentVersion);\n\n        _;\n    }\n\n    /// @dev Ensure we have bootstraped the oracle before creating positions\n    modifier nonZeroVersionInvariant() {\n        if (latestVersion() == 0) revert ProductOracleBootstrappingError();\n\n        _;\n    }\n\n    /// @dev Ensure the product is not closed\n    modifier notClosed() {\n        if (closed()) revert ProductClosedError();\n\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial/contracts/product/Product.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../controller/UControllerProvider.sol\";\nimport \"./UPayoffProvider.sol\";\nimport \"./UParamProvider.sol\";\nimport \"./types/position/AccountPosition.sol\";\nimport \"./types/accumulator/AccountAccumulator.sol\";\n\n/**\n * @title Product\n * @notice Manages logic and state for a single product market.\n * @dev Cloned by the Controller contract to launch new product markets.\n */\ncontract Product is IProduct, UInitializable, UParamProvider, UPayoffProvider, UReentrancyGuard {\n    /// @dev Whether or not the product is closed\n    BoolStorage private constant _closed = BoolStorage.wrap(keccak256(\"equilibria.perennial.Product.closed\"));\n\n    function closed() public view returns (bool) {\n        return _closed.read();\n    }\n\n    /// @dev The name of the product\n    string public name;\n\n    /// @dev The symbol of the product\n    string public symbol;\n\n    /// @dev The individual position state for each account\n    mapping(address => AccountPosition) private _positions;\n\n    /// @dev The global position state for the product\n    VersionedPosition private _position;\n\n    /// @dev The individual accumulator state for each account\n    mapping(address => AccountAccumulator) private _accumulators;\n\n    /// @dev The global accumulator state for the product\n    VersionedAccumulator private _accumulator;\n\n    /**\n     * @notice Initializes the contract state\n     * @param productInfo_ Product initialization params\n     */\n    function initialize(ProductInfo calldata productInfo_) external initializer(1) {\n        __UControllerProvider__initialize(IController(msg.sender));\n        __UPayoffProvider__initialize(productInfo_.oracle, productInfo_.payoffDefinition);\n        __UReentrancyGuard__initialize();\n        __UParamProvider__initialize(\n            productInfo_.maintenance,\n            productInfo_.fundingFee,\n            productInfo_.makerFee,\n            productInfo_.takerFee,\n            productInfo_.positionFee,\n            productInfo_.makerLimit,\n            productInfo_.utilizationCurve\n        );\n\n        name = productInfo_.name;\n        symbol = productInfo_.symbol;\n    }\n\n    /**\n     * @notice Surfaces global settlement externally\n     */\n    function settle() external nonReentrant notPaused {\n        _settle();\n    }\n\n    /**\n     * @notice Core global settlement flywheel\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settle() private returns (IOracleProvider.OracleVersion memory currentOracleVersion) {\n        IController _controller = controller();\n\n        // Get current oracle version\n        currentOracleVersion = _sync();\n\n        // Get latest oracle version\n        uint256 _latestVersion = latestVersion();\n        if (_latestVersion == currentOracleVersion.version) return currentOracleVersion; // short circuit entirely if a == c\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(_latestVersion);\n\n        // Get settle oracle version\n        uint256 _settleVersion = _position.pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // Initiate\n        _controller.incentivizer().sync(currentOracleVersion);\n        UFixed18 boundedFundingFee = _boundedFundingFee();\n\n        // value a->b\n        UFixed18 accumulatedFee = _accumulator.accumulate(\n            boundedFundingFee, _position, latestOracleVersion, settleOracleVersion);\n\n        // position a->b\n        _position.settle(_latestVersion, settleOracleVersion);\n\n        // Apply any pending fee updates if present\n        _settleFeeUpdates();\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // value b->c\n            accumulatedFee = accumulatedFee.add(\n                _accumulator.accumulate(boundedFundingFee, _position, settleOracleVersion, currentOracleVersion)\n            );\n\n            // position b->c (every accumulator version needs a position stamp)\n            _position.settle(settleOracleVersion.version, currentOracleVersion);\n        }\n\n        // settle collateral\n        _controller.collateral().settleProduct(accumulatedFee);\n\n        emit Settle(settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Surfaces account settlement externally\n     * @param account Account to settle\n     */\n    function settleAccount(address account) external nonReentrant notPaused {\n        IOracleProvider.OracleVersion memory currentOracleVersion = _settle();\n        _settleAccount(account, currentOracleVersion);\n    }\n\n    /**\n     * @notice Core account settlement flywheel\n     * @param account Account to settle\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settleAccount(address account, IOracleProvider.OracleVersion memory currentOracleVersion) private {\n        IController _controller = controller();\n\n        // Get latest oracle version\n        if (latestVersion(account) == currentOracleVersion.version) return; // short circuit entirely if a == c\n\n        // Get settle oracle version\n        uint256 _settleVersion = _positions[account].pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // sync incentivizer before accumulator\n        _controller.incentivizer().syncAccount(account, settleOracleVersion);\n\n        // value a->b\n        Fixed18 accumulated = _accumulators[account].syncTo(\n            _accumulator, _positions[account], settleOracleVersion.version).sum();\n\n        // position a->b\n        _positions[account].settle(settleOracleVersion);\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // sync incentivizer before accumulator\n            _controller.incentivizer().syncAccount(account, currentOracleVersion);\n\n            // value b->c\n            accumulated = accumulated.add(\n                _accumulators[account].syncTo(_accumulator, _positions[account], currentOracleVersion.version).sum()\n            );\n        }\n\n        // settle collateral\n        _controller.collateral().settleAccount(account, accumulated);\n\n        emit AccountSettle(account, settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Opens a taker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openTake(UFixed18 amount) external {\n        openTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open the position for\n     * @param amount Amount of the position to open\n     */\n    function openTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        maxUtilizationInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openTake(latestOracleVersion.version, amount);\n        _position.pre.openTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeTake(UFixed18 amount) external {\n        closeTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)"
    }
  ]
}