{
  "Title": "Anyone can prevent stakers from getting their rewards",
  "Content": "The [`recoverErc20`](https://github.com/across-protocol/across-token/blob/42130387f81debf2a20d2f7b40d9f0ccc1dcd06a/contracts/AcceleratingDistributor.sol#L131) function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the [`AcceleratingDistributor`](https://github.com/across-protocol/across-token/blob/42130387f81debf2a20d2f7b40d9f0ccc1dcd06a/contracts/AcceleratingDistributor.sol) contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the `AcceleratingDistributor` contract to the owner of `AcceleratingDistributor`. The only ERC20 tokens that are explicitly disallowed from being recovered are `stakedToken`s that have already been initialized in the system.\n\n\nHowever, it is currently possible to recover the ERC20 `rewardToken` using the `recoverErc20` function. Doing so would [transfer some specified `amount` of `rewardToken` from the `AcceleratingDistributor` contract to the contract’s owner](https://github.com/across-protocol/across-token/blob/42130387f81debf2a20d2f7b40d9f0ccc1dcd06a/contracts/AcceleratingDistributor.sol#L133). This would, subsequently, prevent stakers from being able to access their rewards because `AcceleratingDistributor` could be left with an insufficient balance of `rewardToken`s.\n\n\nEven if the owner were to send `rewardToken`s back to the `AcceleratingDistributor` contract, a malicious actor could immediately transfer all of the `rewardTokens` back to the owner. Redeployment would be necessary to fix the issue.\n\n\nConsider disallowing recovery of the `rewardToken` within the `recoverErc20` function.\n\n\n***Update:** Fixed as of commit `bcdabc06ca6d789b95c5b26d23f48dab8bfad277` in [pull request #5](https://github.com/across-protocol/across-token/pull/5).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/AcceleratingDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./test/Testable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @notice Across token distribution contract. Contract is inspired by Synthetix staking contract and Ampleforth geyser.\n * Stakers start by earning their pro-rate share of a baseEmissionRate per second which increases based on how long\n * they have staked in the contract, up to a maximum of maxEmissionRate. Multiple LP tokens can be staked in this\n * contract enabling depositors to batch stake and claim via multicall.\n *\n */\n\ncontract AcceleratingDistributor is Testable, ReentrancyGuard, Pausable, Ownable, Multicall {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n\n    // Each User deposit is tracked with the information below.\n    struct UserDeposit {\n        uint256 cumulativeBalance;\n        uint256 averageDepositTime;\n        uint256 rewardsPaidPerToken;\n        uint256 rewardsOutstanding;\n    }\n\n    struct StakingToken {\n        bool enabled;\n        uint256 baseEmissionRate;\n        uint256 maxMultiplier;\n        uint256 secondsToMaxMultiplier;\n        uint256 cumulativeStaked;\n        uint256 rewardPerTokenStored;\n        uint256 lastUpdateTime;\n        mapping(address => UserDeposit) stakingBalances;\n    }\n\n    mapping(address => StakingToken) public stakingTokens;\n\n    modifier onlyEnabled(address stakedToken) {\n        require(stakingTokens[stakedToken].enabled, \"stakedToken not enabled\");\n        _;\n    }\n\n    modifier onlyInitialized(address stakedToken) {\n        require(stakingTokens[stakedToken].lastUpdateTime != 0, \"stakedToken not initialized\");\n        _;\n    }\n\n    constructor(address _rewardToken, address _timer) Testable(_timer) {\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    /**************************************\n     *               EVENTS               *\n     **************************************/\n\n    event TokenEnabledForStaking(\n        address token,\n        bool enabled,\n        uint256 baseEmissionRate,\n        uint256 maxMultiplier,\n        uint256 secondsToMaxMultiplier,\n        uint256 lastUpdateTime\n    );\n    event RecoverErc20(address token, address to, uint256 amount);\n    event Stake(address token, address user, uint256 amount, uint256 averageDepositTime, uint256 cumulativeBalance);\n    event Unstake(address token, address user, uint256 amount, uint256 remainingCumulativeBalance);\n    event GetReward(address token, address user, uint256 rewardsToSend);\n    event Exit(address token, address user);\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Enable a token for staking.\n     * @param stakedToken The address of the token that can be staked.\n     * @param enabled Whether the token is enabled for staking.\n     * @param baseEmissionRate The base emission rate for staking the token. This is split pro-rate between all users.\n     * @param maxMultiplier The maximum multiplier for staking which increases your rewards the longer you stake.\n     * @param secondsToMaxMultiplier The number of seconds needed to stake to reach the maximum multiplier.\n     */\n    function enableStaking(\n        address stakedToken,\n        bool enabled,\n        uint256 baseEmissionRate,\n        uint256 maxMultiplier,\n        uint256 secondsToMaxMultiplier\n    ) public onlyOwner {\n        // Because of the way balances are managed, the staked token cannot be the reward token. Otherwise, reward\n        // payouts could eat into user balances.\n        require(stakedToken != address(rewardToken), \"Staked token is reward token\");\n\n        StakingToken storage stakingToken = stakingTokens[stakedToken];\n\n        // If this token is already initialized, make sure we update the rewards before modifying any params.\n        if (stakingToken.lastUpdateTime != 0) _updateReward(stakedToken, address(0));\n\n        stakingToken.enabled = enabled;\n        stakingToken.baseEmissionRate = baseEmissionRate;\n        stakingToken.maxMultiplier = maxMultiplier;\n        stakingToken.secondsToMaxMultiplier = secondsToMaxMultiplier;\n        stakingToken.lastUpdateTime = getCurrentTime();\n\n        emit TokenEnabledForStaking(\n            stakedToken,\n            enabled,\n            baseEmissionRate,\n            maxMultiplier,\n            secondsToMaxMultiplier,\n            stakingToken.lastUpdateTime\n        );\n    }\n\n    /**\n     * @notice Recover an ERC20 token either dropped on the contract or excess after the end of the staking program ends.\n     * @dev Any wallet can call this function as it will only ever send tokens to the owner of the distributor.\n     * @param tokenAddress The address of the token to recover.\n     * @param amount The amount of the token to recover.\n     */\n    function recoverErc20(address tokenAddress, uint256 amount) external {\n        require(stakingTokens[tokenAddress].lastUpdateTime == 0, \"Can't recover staking token\");\n        IERC20(tokenAddress).safeTransfer(owner(), amount);\n\n        emit RecoverErc20(tokenAddress, owner(), amount);\n    }\n\n    /**************************************\n     *          STAKER FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Stake tokens for rewards.\n     * @dev The caller of this function must approve this contract to spend amount of stakedToken.\n     * @param stakedToken The address of the token to stake.\n     * @param amount The amount of the token to stake.\n     */\n    function stake(address stakedToken, uint256 amount) public nonReentrant onlyEnabled(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];\n\n        uint256 averageDepositTime = getAverageDepositTimePostDeposit(stakedToken, msg.sender, amount);\n\n        userDeposit.averageDepositTime = averageDepositTime;\n        userDeposit.cumulativeBalance += amount;\n        stakingTokens[stakedToken].cumulativeStaked += amount;\n\n        IERC20(stakedToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(stakedToken, msg.sender, amount, averageDepositTime, userDeposit.cumulativeBalance);\n    }\n\n    /**\n     * @notice Withdraw staked tokens.\n     * @param stakedToken The address of the token to withdraw.\n     * @param amount The amount of the token to withdraw.\n     */\n    function unstake(address stakedToken, uint256 amount) public nonReentrant onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];\n\n        // Note: these will revert if underflow so you cant unstake more than your cumulativeBalance.\n        userDeposit.cumulativeBalance -= amount;\n        stakingTokens[stakedToken].cumulativeStaked -= amount;\n\n        IERC20(stakedToken).transfer(msg.sender, amount);\n\n        emit Unstake(stakedToken, msg.sender, amount, userDeposit.cumulativeBalance);\n    }\n\n    /**\n     * @notice Get entitled rewards for the staker.\n     * @dev Calling this method will reset the callers reward multiplier.\n     * @param stakedToken The address of the token to get rewards for.\n     */\n    function getReward(address stakedToken) public nonReentrant onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];\n\n        uint256 rewardsToSend = userDeposit.rewardsOutstanding;\n        if (rewardsToSend > 0) {\n            userDeposit.rewardsOutstanding = 0;\n            userDeposit.averageDepositTime = getCurrentTime();\n            rewardToken.safeTransfer(msg.sender, rewardsToSend);\n        }\n\n        emit GetReward(stakedToken, msg.sender, rewardsToSend);\n    }\n\n    /**\n     * @notice Exits a staking position by unstaking and getting rewards. This totally exists the staking position.\n     * @dev Calling this method will reset the callers reward multiplier.\n     * @param stakedToken The address of the token to get rewards for.\n     */\n    function exit(address stakedToken) external onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        unstake(stakedToken, stakingTokens[stakedToken].stakingBalances[msg.sender].cumulativeBalance);\n        getReward(stakedToken);\n\n        emit Exit(stakedToken, msg.sender);\n    }\n\n    /**************************************\n     *           VIEW FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Returns the total staked for a given stakedToken.\n     * @param stakedToken The address of the staked token to query.\n     * @return uint256 Total amount staked of the stakedToken.\n     */\n    function getCumulativeStaked(address stakedToken) public view returns (uint256) {\n        return stakingTokens[stakedToken].cumulativeStaked;\n    }\n\n    /**\n     * @notice Returns the all information associated with a user's stake.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of user to query.\n     * @return UserDeposit Struct with: {cumulativeBalance,averageDepositTime,rewardsPaidPerToken,rewardsOutstanding}\n     */\n    function getUserStake(address stakedToken, address account) public view returns (UserDeposit memory) {\n        return stakingTokens[stakedToken].stakingBalances[account];\n    }\n\n    /**\n     * @notice Returns the base rewards per staked token for a given staking token. This factors in the last time\n     * any internal logic was called on this contract to correctly attribute retroactive cumulative rewards.\n     * @param stakedToken The address of the staked token to query.\n     * @return uint256 Total base reward per token that will be applied, pro-rata, to stakers.\n     */\n    function baseRewardPerToken(address stakedToken) public view returns (uint256) {\n        StakingToken storage stakingToken = stakingTokens[stakedToken];\n        if (stakingToken.cumulativeStaked == 0) return stakingToken.rewardPerTokenStored;\n\n        return\n            stakingToken.rewardPerTokenStored +\n            ((getCurrentTime() - stakingToken.lastUpdateTime) * stakingToken.baseEmissionRate * 1e18) /\n            stakingToken.cumulativeStaked;\n    }\n\n    /**\n     * @notice Returns the multiplier applied to the base reward per staked token for a given staking token and account.\n     * The longer a user stakes the higher their multiplier up to maxMultiplier for that given staking token.\n     * any internal logic was called on this contract to correctly attribute retroactive cumulative rewards.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     * @return uint256 User multiplier, applied to the baseRewardPerToken, when claiming rewards.\n     */\n    function getUserRewardMultiplier(address stakedToken, address account) public view returns (uint256) {\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];\n        if (userDeposit.averageDepositTime == 0 || userDeposit.cumulativeBalance == 0) return 1e18;\n        uint256 fractionOfMaxMultiplier = ((getTimeFromLastDeposit(stakedToken, account)) * 1e18) /\n            stakingTokens[stakedToken].secondsToMaxMultiplier;\n\n        // At maximum, the multiplier should be equal to the maxMultiplier.\n        if (fractionOfMaxMultiplier > 1e18) fractionOfMaxMultiplier = 1e18;\n        return 1e18 + (fractionOfMaxMultiplier * (stakingTokens[stakedToken].maxMultiplier - 1e18)) / (1e18);\n    }\n\n    /**\n     * @notice Returns the total outstanding rewards entitled to a user for a given staking token. This factors in the\n     * users staking duration (and therefore reward multiplier) and their pro-rata share of the total rewards.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     * @return uint256 Total outstanding rewards entitled to user.\n     */\n    function getOutstandingRewards(address stakedToken, address account) public view returns (uint256) {\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];\n\n        uint256 userRewardMultiplier = getUserRewardMultiplier(stakedToken, account);\n\n        uint256 newUserRewards = (userDeposit.cumulativeBalance *\n            (baseRewardPerToken(stakedToken) - userDeposit.rewardsPaidPerToken) *\n            userRewardMultiplier) / (1e18 * 1e18);\n\n        return newUserRewards + userDeposit.rewardsOutstanding;\n    }\n\n    /**\n     * @notice Returns the time that has elapsed between the current time and the last users average deposit time.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     *@return uint256 Time, in seconds, between the users average deposit time and the current time.\n     */\n    function getTimeFromLastDeposit(address stakedToken, address account) public view returns (uint256) {\n        return getCurrentTime() - stakingTokens[stakedToken].stakingBalances[account].averageDepositTime;\n    }\n\n    /**\n     * @notice Returns a users new average deposit time, considering the addition of a new deposit. This factors in the\n     * cumulative previous deposits, new deposit and time from the last deposit.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     * @return uint256 Average post deposit time, considering all deposits to date.\n     */\n    function getAverageDepositTimePostDeposit(\n        address stakedToken,\n        address account,\n        uint256 amount\n    ) public view returns (uint256) {\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];\n        if (amount == 0) return userDeposit.averageDepositTime;\n        uint256 amountWeightedTime = (((amount * 1e18) / (userDeposit.cumulativeBalance + amount)) *\n            (getTimeFromLastDeposit(stakedToken, account))) / 1e18;\n        return userDeposit.averageDepositTime + amountWeightedTime;\n    }\n\n    /**************************************\n     *         INTERNAL FUNCTIONS         *\n     **************************************/\n\n    // Update the internal counters for a given stakedToken and user.\n    function _updateReward(address stakedToken, address account) internal {\n        StakingToken storage stakingToken = stakingTokens[stakedToken];\n        stakingToken.rewardPerTokenStored = baseRewardPerToken(stakedToken);\n        stakingToken.lastUpdateTime = getCurrentTime();\n        if (account != address(0)) {\n            UserDeposit storage userDeposit = stakingToken.stakingBalances[account];\n            userDeposit.rewardsOutstanding = getOutstandingRewards(stakedToken, account);\n            userDeposit.rewardsPaidPerToken = stakingToken.rewardPerTokenStored;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/AcceleratingDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./test/Testable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @notice Across token distribution contract. Contract is inspired by Synthetix staking contract and Ampleforth geyser.\n * Stakers start by earning their pro-rate share of a baseEmissionRate per second which increases based on how long\n * they have staked in the contract, up to a maximum of maxEmissionRate. Multiple LP tokens can be staked in this\n * contract enabling depositors to batch stake and claim via multicall.\n *\n */\n\ncontract AcceleratingDistributor is Testable, ReentrancyGuard, Pausable, Ownable, Multicall {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n\n    // Each User deposit is tracked with the information below.\n    struct UserDeposit {\n        uint256 cumulativeBalance;\n        uint256 averageDepositTime;\n        uint256 rewardsPaidPerToken;\n        uint256 rewardsOutstanding;\n    }\n\n    struct StakingToken {\n        bool enabled;\n        uint256 baseEmissionRate;\n        uint256 maxMultiplier;\n        uint256 secondsToMaxMultiplier;\n        uint256 cumulativeStaked;\n        uint256 rewardPerTokenStored;\n        uint256 lastUpdateTime;\n        mapping(address => UserDeposit) stakingBalances;\n    }\n\n    mapping(address => StakingToken) public stakingTokens;\n\n    modifier onlyEnabled(address stakedToken) {\n        require(stakingTokens[stakedToken].enabled, \"stakedToken not enabled\");\n        _;\n    }\n\n    modifier onlyInitialized(address stakedToken) {\n        require(stakingTokens[stakedToken].lastUpdateTime != 0, \"stakedToken not initialized\");\n        _;\n    }\n\n    constructor(address _rewardToken, address _timer) Testable(_timer) {\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    /**************************************\n     *               EVENTS               *\n     **************************************/\n\n    event TokenEnabledForStaking(\n        address token,\n        bool enabled,\n        uint256 baseEmissionRate,\n        uint256 maxMultiplier,\n        uint256 secondsToMaxMultiplier,\n        uint256 lastUpdateTime\n    );\n    event RecoverErc20(address token, address to, uint256 amount);\n    event Stake(address token, address user, uint256 amount, uint256 averageDepositTime, uint256 cumulativeBalance);\n    event Unstake(address token, address user, uint256 amount, uint256 remainingCumulativeBalance);\n    event GetReward(address token, address user, uint256 rewardsToSend);\n    event Exit(address token, address user);\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Enable a token for staking.\n     * @param stakedToken The address of the token that can be staked.\n     * @param enabled Whether the token is enabled for staking.\n     * @param baseEmissionRate The base emission rate for staking the token. This is split pro-rate between all users.\n     * @param maxMultiplier The maximum multiplier for staking which increases your rewards the longer you stake.\n     * @param secondsToMaxMultiplier The number of seconds needed to stake to reach the maximum multiplier.\n     */\n    function enableStaking(\n        address stakedToken,\n        bool enabled,\n        uint256 baseEmissionRate,\n        uint256 maxMultiplier,\n        uint256 secondsToMaxMultiplier\n    ) public onlyOwner {\n        // Because of the way balances are managed, the staked token cannot be the reward token. Otherwise, reward\n        // payouts could eat into user balances.\n        require(stakedToken != address(rewardToken), \"Staked token is reward token\");\n\n        StakingToken storage stakingToken = stakingTokens[stakedToken];\n\n        // If this token is already initialized, make sure we update the rewards before modifying any params.\n        if (stakingToken.lastUpdateTime != 0) _updateReward(stakedToken, address(0));\n\n        stakingToken.enabled = enabled;\n        stakingToken.baseEmissionRate = baseEmissionRate;\n        stakingToken.maxMultiplier = maxMultiplier;\n        stakingToken.secondsToMaxMultiplier = secondsToMaxMultiplier;\n        stakingToken.lastUpdateTime = getCurrentTime();\n\n        emit TokenEnabledForStaking(\n            stakedToken,\n            enabled,\n            baseEmissionRate,\n            maxMultiplier,\n            secondsToMaxMultiplier,\n            stakingToken.lastUpdateTime\n        );\n    }\n\n    /**\n     * @notice Recover an ERC20 token either dropped on the contract or excess after the end of the staking program ends.\n     * @dev Any wallet can call this function as it will only ever send tokens to the owner of the distributor.\n     * @param tokenAddress The address of the token to recover.\n     * @param amount The amount of the token to recover.\n     */\n    function recoverErc20(address tokenAddress, uint256 amount) external {\n        require(stakingTokens[tokenAddress].lastUpdateTime == 0, \"Can't recover staking token\");\n        IERC20(tokenAddress).safeTransfer(owner(), amount);\n\n        emit RecoverErc20(tokenAddress, owner(), amount);\n    }\n\n    /**************************************\n     *          STAKER FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Stake tokens for rewards.\n     * @dev The caller of this function must approve this contract to spend amount of stakedToken.\n     * @param stakedToken The address of the token to stake.\n     * @param amount The amount of the token to stake.\n     */\n    function stake(address stakedToken, uint256 amount) public nonReentrant onlyEnabled(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];\n\n        uint256 averageDepositTime = getAverageDepositTimePostDeposit(stakedToken, msg.sender, amount);\n\n        userDeposit.averageDepositTime = averageDepositTime;\n        userDeposit.cumulativeBalance += amount;\n        stakingTokens[stakedToken].cumulativeStaked += amount;\n\n        IERC20(stakedToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(stakedToken, msg.sender, amount, averageDepositTime, userDeposit.cumulativeBalance);\n    }\n\n    /**\n     * @notice Withdraw staked tokens.\n     * @param stakedToken The address of the token to withdraw.\n     * @param amount The amount of the token to withdraw.\n     */\n    function unstake(address stakedToken, uint256 amount) public nonReentrant onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];\n\n        // Note: these will revert if underflow so you cant unstake more than your cumulativeBalance.\n        userDeposit.cumulativeBalance -= amount;\n        stakingTokens[stakedToken].cumulativeStaked -= amount;\n\n        IERC20(stakedToken).transfer(msg.sender, amount);\n\n        emit Unstake(stakedToken, msg.sender, amount, userDeposit.cumulativeBalance);\n    }\n\n    /**\n     * @notice Get entitled rewards for the staker.\n     * @dev Calling this method will reset the callers reward multiplier.\n     * @param stakedToken The address of the token to get rewards for.\n     */\n    function getReward(address stakedToken) public nonReentrant onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];\n\n        uint256 rewardsToSend = userDeposit.rewardsOutstanding;\n        if (rewardsToSend > 0) {\n            userDeposit.rewardsOutstanding = 0;\n            userDeposit.averageDepositTime = getCurrentTime();\n            rewardToken.safeTransfer(msg.sender, rewardsToSend);\n        }\n\n        emit GetReward(stakedToken, msg.sender, rewardsToSend);\n    }\n\n    /**\n     * @notice Exits a staking position by unstaking and getting rewards. This totally exists the staking position.\n     * @dev Calling this method will reset the callers reward multiplier.\n     * @param stakedToken The address of the token to get rewards for.\n     */\n    function exit(address stakedToken) external onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        unstake(stakedToken, stakingTokens[stakedToken].stakingBalances[msg.sender].cumulativeBalance);\n        getReward(stakedToken);\n\n        emit Exit(stakedToken, msg.sender);\n    }\n\n    /**************************************\n     *           VIEW FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Returns the total staked for a given stakedToken.\n     * @param stakedToken The address of the staked token to query.\n     * @return uint256 Total amount staked of the stakedToken.\n     */\n    function getCumulativeStaked(address stakedToken) public view returns (uint256) {\n        return stakingTokens[stakedToken].cumulativeStaked;\n    }\n\n    /**\n     * @notice Returns the all information associated with a user's stake.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of user to query.\n     * @return UserDeposit Struct with: {cumulativeBalance,averageDepositTime,rewardsPaidPerToken,rewardsOutstanding}\n     */\n    function getUserStake(address stakedToken, address account) public view returns (UserDeposit memory) {\n        return stakingTokens[stakedToken].stakingBalances[account];\n    }\n\n    /**\n     * @notice Returns the base rewards per staked token for a given staking token. This factors in the last time\n     * any internal logic was called on this contract to correctly attribute retroactive cumulative rewards.\n     * @param stakedToken The address of the staked token to query.\n     * @return uint256 Total base reward per token that will be applied, pro-rata, to stakers.\n     */\n    function baseRewardPerToken(address stakedToken) public view returns (uint256) {\n        StakingToken storage stakingToken = stakingTokens[stakedToken];\n        if (stakingToken.cumulativeStaked == 0) return stakingToken.rewardPerTokenStored;\n\n        return\n            stakingToken.rewardPerTokenStored +\n            ((getCurrentTime() - stakingToken.lastUpdateTime) * stakingToken.baseEmissionRate * 1e18) /\n            stakingToken.cumulativeStaked;\n    }\n\n    /**\n     * @notice Returns the multiplier applied to the base reward per staked token for a given staking token and account.\n     * The longer a user stakes the higher their multiplier up to maxMultiplier for that given staking token.\n     * any internal logic was called on this contract to correctly attribute retroactive cumulative rewards.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     * @return uint256 User multiplier, applied to the baseRewardPerToken, when claiming rewards.\n     */\n    function getUserRewardMultiplier(address stakedToken, address account) public view returns (uint256) {\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];\n        if (userDeposit.averageDepositTime == 0 || userDeposit.cumulativeBalance == 0) return 1e18;\n        uint256 fractionOfMaxMultiplier = ((getTimeFromLastDeposit(stakedToken, account)) * 1e18) /\n            stakingTokens[stakedToken].secondsToMaxMultiplier;\n\n        // At maximum, the multiplier should be equal to the maxMultiplier.\n        if (fractionOfMaxMultiplier > 1e18) fractionOfMaxMultiplier = 1e18;\n        return 1e18 + (fractionOfMaxMultiplier * (stakingTokens[stakedToken].maxMultiplier - 1e18)) / (1e18);\n    }\n\n    /**\n     * @notice Returns the total outstanding rewards entitled to a user for a given staking token. This factors in the\n     * users staking duration (and therefore reward multiplier) and their pro-rata share of the total rewards.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     * @return uint256 Total outstanding rewards entitled to user.\n     */\n    function getOutstandingRewards(address stakedToken, address account) public view returns (uint256) {\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];\n\n        uint256 userRewardMultiplier = getUserRewardMultiplier(stakedToken, account);\n\n        uint256 newUserRewards = (userDeposit.cumulativeBalance *\n            (baseRewardPerToken(stakedToken) - userDeposit.rewardsPaidPerToken) *\n            userRewardMultiplier) / (1e18 * 1e18);\n\n        return newUserRewards + userDeposit.rewardsOutstanding;\n    }\n\n    /**\n     * @notice Returns the time that has elapsed between the current time and the last users average deposit time.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     *@return uint256 Time, in seconds, between the users average deposit time and the current time.\n     */\n    function getTimeFromLastDeposit(address stakedToken, address account) public view returns (uint256) {\n        return getCurrentTime() - stakingTokens[stakedToken].stakingBalances[account].averageDepositTime;\n    }\n\n    /**\n     * @notice Returns a users new average deposit time, considering the addition of a new deposit. This factors in the\n     * cumulative previous deposits, new deposit and time from the last deposit.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     * @return uint256 Average post deposit time, considering all deposits to date.\n     */\n    function getAverageDepositTimePostDeposit(\n        address stakedToken,\n        address account,\n        uint256 amount\n    ) public view returns (uint256) {\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];\n        if (amount == 0) return userDeposit.averageDepositTime;\n        uint256 amountWeightedTime = (((amount * 1e18) / (userDeposit.cumulativeBalance + amount)) *\n            (getTimeFromLastDeposit(stakedToken, account))) / 1e18;\n        return userDeposit.averageDepositTime + amountWeightedTime;\n    }\n\n    /**************************************\n     *         INTERNAL FUNCTIONS         *\n     **************************************/\n\n    // Update the internal counters for a given stakedToken and user.\n    function _updateReward(address stakedToken, address account) internal {\n        StakingToken storage stakingToken = stakingTokens[stakedToken];\n        stakingToken.rewardPerTokenStored = baseRewardPerToken(stakedToken);\n        stakingToken.lastUpdateTime = getCurrentTime();\n        if (account != address(0)) {\n            UserDeposit storage userDeposit = stakingToken.stakingBalances[account];\n            userDeposit.rewardsOutstanding = getOutstandingRewards(stakedToken, account);\n            userDeposit.rewardsPaidPerToken = stakingToken.rewardPerTokenStored;\n        }\n    }\n}"
    }
  ]
}