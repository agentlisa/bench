{
  "Title": "[L-02] Comparison in `_calcPayout()` should include equality",
  "Content": "<h2 id=\"l-02-comparison-in-_calcpayout-should-include-equality\" style=\"position:relative;\"><a href=\"#l-02-comparison-in-_calcpayout-should-include-equality\" aria-label=\"l 02 comparison in _calcpayout should include equality permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02] Comparison in <code>_calcPayout()</code> should include equality</h2>\n<p><a href=\"https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L586\">Witch.sol#L586</a><br></p>\n<h3 id=\"tldr\" style=\"position:relative;\"><a href=\"#tldr\" aria-label=\"tldr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TLDR</h3>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"diff\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">- else if (elapsed &gt; duration)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+ else if (elapsed &gt;= duration)</span></span></span></code></pre>\n<h3 id=\"description\" style=\"position:relative;\"><a href=\"#description\" aria-label=\"description permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description</h3>\n<p>In the case where <code>elapsed == duration</code>, <code>proportionNow</code> evaluates to <code>1e18</code>, which is the same result when <code>elapsed &gt; duration</code>. Proof below.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">proportionNow</span><span class=\"mtk1\"> =</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">uint256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">initialProportion</span><span class=\"mtk1\">) +</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">uint256</span><span class=\"mtk1\">(</span><span class=\"mtk7\">1e18</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">initialProportion</span><span class=\"mtk1\">).</span><span class=\"mtk11\">wmul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">elapsed</span><span class=\"mtk1\">.</span><span class=\"mtk11\">wdiv</span><span class=\"mtk1\">(</span><span class=\"mtk12\">duration</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// = initialProportion + (1e18 - initialProportion).wmul(1e18)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// = initialProportion + (1e18 - initialProportion) * 1e18 / 1e18</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// = initialProportion + 1e18 - initialProportion</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// = 1e18</span></span></span></code></pre>\n<p>Of slightly greater importance, this handles the edge case when <code>elapsed = duration = 0</code>, ie. the liquidation transaction is included in the same block / has the same timestamp as the auction initialization transaction</p>\n<h3 id=\"recommended-mitigation-steps-3\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-3\" aria-label=\"recommended mitigation steps 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>As per the TLDR.</p>\n<h3 id=\"ps-regarding-zero-duration-auctions\" style=\"position:relative;\"><a href=\"#ps-regarding-zero-duration-auctions\" aria-label=\"ps regarding zero duration auctions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>P.S. Regarding zero duration auctions</h3>\n<p>Since the proportion given for zero duration auctions is <code>1e18</code>, it is equivalent to an auction of infinite duration with 100% initial offer: <code>duration == type(uint32).max</code> and <code>line_.initialOffer = 1e18</code>.</p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-07-yield-witch-v2-contest",
  "Code": [
    {
      "filename": "contracts/Witch.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.14;\n\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/vault-interfaces/src/ILadle.sol\";\nimport \"@yield-protocol/vault-interfaces/src/ICauldron.sol\";\nimport \"@yield-protocol/vault-interfaces/src/IJoin.sol\";\nimport \"@yield-protocol/vault-interfaces/src/DataTypes.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WMul.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WDiv.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol\";\n\n/// @title  The Witch is a DataTypes.Auction/Liquidation Engine for the Yield protocol\n/// @notice The Witch grabs uncollateralized vaults, replacing the owner by itself. Then it sells\n/// the vault collateral in exchange for underlying to pay its debt. The amount of collateral\n/// given increases over time, until it offers to sell all the collateral for underlying to pay\n/// all the debt. The auction is held open at the final price indefinitely.\n/// @dev After the debt is settled, the Witch returns the vault to its original owner.\ncontract Witch is AccessControl {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU256U128 for uint256;\n\n    // ==================== User events ====================\n\n    error VaultAlreadyUnderAuction(bytes12 vaultId, address witch);\n    error VaultNotLiquidable(bytes12 vaultId, bytes6 ilkId, bytes6 baseId);\n    error AuctioneerRewardTooHigh(uint128 max, uint128 actual);\n\n    event Auctioned(bytes12 indexed vaultId, uint256 indexed start);\n    event Cancelled(bytes12 indexed vaultId);\n    event Ended(bytes12 indexed vaultId);\n    event Bought(\n        bytes12 indexed vaultId,\n        address indexed buyer,\n        uint256 ink,\n        uint256 art\n    );\n\n    // ==================== Governance events ====================\n\n    event Point(bytes32 indexed param, address indexed value);\n    event LineSet(\n        bytes6 indexed ilkId,\n        bytes6 indexed baseId,\n        uint32 duration,\n        uint64 proportion,\n        uint64 initialOffer\n    );\n    event LimitSet(bytes6 indexed ilkId, bytes6 indexed baseId, uint128 max);\n    event AnotherWitchSet(address indexed value, bool isWitch);\n    event IgnoredPairSet(\n        bytes6 indexed ilkId,\n        bytes6 indexed baseId,\n        bool ignore\n    );\n    event AuctioneerRewardSet(uint128 auctioneerReward);\n\n    ICauldron public immutable cauldron;\n    ILadle public ladle;\n\n    // Reward given to whomever calls `auction`. It represents a % of the bought collateral\n    uint128 public auctioneerReward = 0.01e18;\n\n    mapping(bytes12 => DataTypes.Auction) public auctions;\n    mapping(bytes6 => mapping(bytes6 => DataTypes.Line)) public lines;\n    mapping(bytes6 => mapping(bytes6 => DataTypes.Limits)) public limits;\n    mapping(address => bool) public otherWitches;\n    mapping(bytes6 => mapping(bytes6 => bool)) public ignoredPairs;\n\n    constructor(ICauldron cauldron_, ILadle ladle_) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n    }\n\n    // ======================================================================\n    // =                        Governance functions                        =\n    // ======================================================================\n\n    /// @dev Point to a different ladle\n    /// @param param Name of parameter to set (must be \"ladle\")\n    /// @param value Address of new ladle\n    function point(bytes32 param, address value) external auth {\n        require(param == \"ladle\", \"Unrecognized\");\n        ladle = ILadle(value);\n        emit Point(param, value);\n    }\n\n    /// @dev Governance function to set the parameters that govern how much collateral is sold over time.\n    /// @param ilkId Id of asset used for collateral\n    /// @param baseId Id of asset used for underlying\n    /// @param duration Time that auctions take to go to minimal price\n    /// @param proportion Vault proportion that is set for auction each time\n    /// @param initialOffer Proportion of collateral that is sold at auction start (1e18 = 100%)\n    function setLine(\n        bytes6 ilkId,\n        bytes6 baseId,\n        uint32 duration,\n        uint64 proportion,\n        uint64 initialOffer\n    ) external auth {\n        require(initialOffer <= 1e18, \"InitialOffer above 100%\");\n        require(proportion <= 1e18, \"Proportion above 100%\");\n        require(\n            initialOffer == 0 || initialOffer >= 0.01e18,\n            \"InitialOffer below 1%\"\n        );\n        require(proportion >= 0.01e18, \"Proportion below 1%\");\n        lines[ilkId][baseId] = DataTypes.Line({\n            duration: duration,\n            proportion: proportion,\n            initialOffer: initialOffer\n        });\n        emit LineSet(ilkId, baseId, duration, proportion, initialOffer);\n    }\n\n    /// @dev Governance function to set auction limits.\n    ///  - the auction duration to calculate liquidation prices\n    ///  - the proportion of the collateral that will be sold at auction start\n    ///  - the maximum collateral that can be auctioned at the same time\n    ///  - the minimum collateral that must be left when buying, unless buying all\n    ///  - The decimals for maximum and minimum\n    /// @param ilkId Id of asset used for collateral\n    /// @param baseId Id of asset used for underlying\n    /// @param max Maximum concurrent auctioned collateral\n    function setLimit(\n        bytes6 ilkId,\n        bytes6 baseId,\n        uint128 max\n    ) external auth {\n        limits[ilkId][baseId] = DataTypes.Limits({\n            max: max,\n            sum: limits[ilkId][baseId].sum // sum is initialized at zero, and doesn't change when changing any ilk parameters\n        });\n        emit LimitSet(ilkId, baseId, max);\n    }\n\n    /// @dev Governance function to set other liquidation contracts that may have taken vaults already.\n    /// @param value The address that may be set/unset as another witch\n    /// @param isWitch Is this address a witch or not\n    function setAnotherWitch(address value, bool isWitch) external auth {\n        otherWitches[value] = isWitch;\n        emit AnotherWitchSet(value, isWitch);\n    }\n\n    /// @dev Governance function to ignore pairs that can't be liquidated\n    /// @param ilkId Id of asset used for collateral\n    /// @param baseId Id of asset used for underlying\n    /// @param ignore Should this pair be ignored for liquidation\n    function setIgnoredPair(\n        bytes6 ilkId,\n        bytes6 baseId,\n        bool ignore\n    ) external auth {\n        ignoredPairs[ilkId][baseId] = ignore;\n        emit IgnoredPairSet(ilkId, baseId, ignore);\n    }\n\n    /// @dev Governance function to set the % paid to whomever starts an auction\n    /// @param auctioneerReward_ New % to be used, must have 18 dec precision\n    function setAuctioneerReward(uint128 auctioneerReward_) external auth {\n        if (auctioneerReward_ > 1e18) {\n            revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);\n        }\n        auctioneerReward = auctioneerReward_;\n        emit AuctioneerRewardSet(auctioneerReward_);\n    }\n\n    // ======================================================================\n    // =                    Auction management functions                    =\n    // ======================================================================\n\n    /// @dev Put an undercollateralized vault up for liquidation\n    /// @param vaultId Id of vault to liquidate\n    /// @param to Receiver of the auctioneer reward\n    function auction(bytes12 vaultId, address to)\n        external\n        returns (DataTypes.Auction memory auction_)\n    {\n        DataTypes.Vault memory vault = cauldron.vaults(vaultId);\n        if (vault.owner == address(this) || otherWitches[vault.owner]) {\n            revert VaultAlreadyUnderAuction(vaultId, vault.owner);\n        }\n        DataTypes.Series memory series = cauldron.series(vault.seriesId);\n        if (ignoredPairs[vault.ilkId][series.baseId]) {\n            revert VaultNotLiquidable(vaultId, vault.ilkId, series.baseId);\n        }\n\n        require(cauldron.level(vaultId) < 0, \"Not undercollateralized\");\n\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        DataTypes.Debt memory debt = cauldron.debt(series.baseId, vault.ilkId);\n\n        // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit.\n        // If the limit has been surpassed, no more vaults of that collateral can be put for auction.\n        // This avoids the scenario where some vaults might be too large to be auctioned.\n        DataTypes.Limits memory limits_ = limits[vault.ilkId][\n            series.baseId\n        ];\n        require(limits_.sum <= limits_.max, \"Collateral limit reached\");\n\n        auction_ = _calcAuction(vault, series, to, balances, debt);\n\n        limits_.sum += auction_.ink;\n        limits[vault.ilkId][series.baseId] = limits_;\n\n        auctions[vaultId] = auction_;\n\n        _auctionStarted(vaultId);\n    }\n\n    /// @dev Moves the vault ownership to the witch.\n    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties\n    function _auctionStarted(bytes12 vaultId) internal virtual {\n        // The Witch is now in control of the vault under auction\n        cauldron.give(vaultId, address(this));\n        emit Auctioned(vaultId, uint32(block.timestamp));\n    }\n\n    /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed\n    /// and what's the max ink that will be offered in exchange. For the realtime amount of ink that's on offer\n    /// use `_calcPayout`\n    function _calcAuction(\n        DataTypes.Vault memory vault,\n        DataTypes.Series memory series,\n        address to,\n        DataTypes.Balances memory balances,\n        DataTypes.Debt memory debt\n    ) internal view returns (DataTypes.Auction memory) {\n        // We store the proportion of the vault to auction, which is the whole vault if the debt would be below dust.\n        DataTypes.Line storage line = lines[vault.ilkId][series.baseId];\n        uint128 art = uint256(balances.art).wmul(line.proportion).u128();\n        if (art < debt.min * (10**debt.dec)) art = balances.art;\n        uint128 ink = (art == balances.art)\n            ? balances.ink\n            : uint256(balances.ink).wmul(line.proportion).u128();\n\n        return\n            DataTypes.Auction({\n                owner: vault.owner,\n                start: uint32(block.timestamp), // Overflow is fine\n                seriesId: vault.seriesId,\n                baseId: series.baseId,\n                ilkId: vault.ilkId,\n                art: art,\n                ink: ink,\n                auctioneer: to\n            });\n    }\n\n    /// @dev Cancel an auction for a vault that isn't undercollateralized anymore\n    /// @param vaultId Id of vault to return\n    function cancel(bytes12 vaultId) external {\n        DataTypes.Auction storage auction_ = auctions[vaultId];\n        require(auction_.start > 0, \"Vault not under auction\");\n        require(cauldron.level(vaultId) >= 0, \"Undercollateralized\");\n\n        // Update concurrent collateral under auction\n        limits[auction_.ilkId][auction_.baseId].sum -= auction_.ink;\n\n        _auctionEnded(vaultId, auction_.owner);\n\n        emit Cancelled(vaultId);\n    }\n\n    /// @dev Moves the vault ownership back to the original owner & clean internal state.\n    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties\n    function _auctionEnded(bytes12 vaultId, address owner) internal virtual {\n        cauldron.give(vaultId, owner);\n        delete auctions[vaultId];\n        emit Ended(vaultId);\n    }\n\n    // ======================================================================\n    // =                          Bidding functions                         =\n    // ======================================================================\n\n    /// @dev Pay at most `maxBaseIn` of the debt in a vault in liquidation, getting at least `minInkOut` collateral.\n    /// @param vaultId Id of vault to buy\n    /// @param to Receiver of the collateral bought\n    /// @param minInkOut Minimum amount of collateral that must be received\n    /// @param maxBaseIn Maximum amount of base that the liquidator will pay\n    /// @return liquidatorCut Amount paid to `to`.\n    /// @return auctioneerCut Amount paid to whomever started the auction. 0 if it's the same address that's calling this method\n    /// @return baseIn Amount of underlying taken\n    function payBase(\n        bytes12 vaultId,\n        address to,\n        uint128 minInkOut,\n        uint128 maxBaseIn\n    )\n        external\n        returns (\n            uint256 liquidatorCut,\n            uint256 auctioneerCut,\n            uint256 baseIn\n        )\n    {\n        DataTypes.Auction memory auction_ = auctions[vaultId];\n        require(auction_.start > 0, \"Vault not under auction\");\n\n        // Find out how much debt is being repaid\n        uint128 artIn = uint128(\n            cauldron.debtFromBase(auction_.seriesId, maxBaseIn)\n        );\n\n        // If offering too much base, take only the necessary.\n        artIn = artIn > auction_.art ? auction_.art : artIn;\n        baseIn = cauldron.debtToBase(auction_.seriesId, artIn);\n\n        // Calculate the collateral to be sold\n        (liquidatorCut, auctioneerCut) = _calcPayout(auction_, to, artIn);\n        require(liquidatorCut >= minInkOut, \"Not enough bought\");\n\n        // Update Cauldron and local auction data\n        _updateAccounting(\n            vaultId,\n            auction_,\n            liquidatorCut + auctioneerCut,\n            artIn\n        );\n\n        // Move the assets\n        _payInk(auction_, to, liquidatorCut, auctioneerCut);\n        if (baseIn != 0) {\n            // Take underlying from liquidator\n            IJoin baseJoin = ladle.joins(auction_.baseId);\n            require(baseJoin != IJoin(address(0)), \"Join not found\");\n            baseJoin.join(msg.sender, baseIn.u128());\n        }\n\n        _collateralBought(vaultId, to, liquidatorCut + auctioneerCut, artIn);\n    }\n\n    /// @dev Pay up to `maxArtIn` debt from a vault in liquidation using fyToken, getting at least `minInkOut` collateral.\n    /// @notice If too much fyToken are offered, only the necessary amount are taken.\n    /// @param vaultId Id of vault to buy\n    /// @param to Receiver for the collateral bought\n    /// @param maxArtIn Maximum amount of fyToken that will be paid\n    /// @param minInkOut Minimum amount of collateral that must be received\n    /// @return liquidatorCut Amount paid to `to`.\n    /// @return auctioneerCut Amount paid to whomever started the auction. 0 if it's the same address that's calling this method\n    /// @return artIn Amount of fyToken taken\n    function payFYToken(\n        bytes12 vaultId,\n        address to,\n        uint128 minInkOut,\n        uint128 maxArtIn\n    )\n        external\n        returns (\n            uint256 liquidatorCut,\n            uint256 auctioneerCut,\n            uint256 artIn\n        )\n    {\n        DataTypes.Auction memory auction_ = auctions[vaultId];\n        require(auction_.start > 0, \"Vault not under auction\");\n\n        // If offering too much fyToken, take only the necessary.\n        artIn = maxArtIn > auction_.art ? auction_.art : maxArtIn;\n\n        // Calculate the collateral to be sold\n        (liquidatorCut, auctioneerCut) = _calcPayout(auction_, to, artIn);\n        require(liquidatorCut >= minInkOut, \"Not enough bought\");\n\n        // Update Cauldron and local auction data\n        _updateAccounting(\n            vaultId,\n            auction_,\n            liquidatorCut + auctioneerCut,\n            artIn\n        );\n\n        // Move the assets\n        _payInk(auction_, to, liquidatorCut, auctioneerCut);\n        if (artIn != 0) {\n            // Burn fyToken from liquidator\n            cauldron.series(auction_.seriesId).fyToken.burn(msg.sender, artIn);\n        }\n\n        _collateralBought(vaultId, to, liquidatorCut + auctioneerCut, artIn);\n    }\n\n    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people)\n    function _payInk(\n        DataTypes.Auction memory auction_,\n        address to,\n        uint256 liquidatorCut,\n        uint256 auctioneerCut\n    ) internal {\n        // If liquidatorCut is 0, then auctioneerCut is 0 too, so no need to double check\n        if (liquidatorCut > 0) {\n            IJoin ilkJoin = ladle.joins(auction_.ilkId);\n            require(ilkJoin != IJoin(address(0)), \"Join not found\");\n\n            // Pay auctioneer's cut if necessary\n            if (auctioneerCut > 0) {\n                ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128());\n            }\n\n            // Give collateral to the liquidator\n            ilkJoin.exit(to, liquidatorCut.u128());\n        }\n    }\n\n    /// @notice Update accounting on the Witch and on the Cauldron. Delete the auction and give back the vault if finished.\n    /// This function doesn't verify the vaultId matches the vault and auction passed. Check before calling.\n    function _updateAccounting(\n        bytes12 vaultId,\n        DataTypes.Auction memory auction_,\n        uint256 inkOut,\n        uint256 artIn\n    ) internal {\n        // Duplicate check, but guarantees data integrity\n        require(auction_.start > 0, \"Vault not under auction\");\n\n        // Update concurrent collateral under auction\n        DataTypes.Limits memory limits_ = limits[auction_.ilkId][\n            auction_.baseId\n        ];\n\n        // Update local auction\n        {\n            if (auction_.art == artIn) {\n                // If there is no debt left, return the vault with the collateral to the owner\n                _auctionEnded(vaultId, auction_.owner);\n\n                // Update limits - reduce it by the whole auction\n                limits_.sum -= auction_.ink;\n            } else {\n                // Ensure enough dust is left\n                DataTypes.Debt memory debt = cauldron.debt(\n                    auction_.baseId,\n                    auction_.ilkId\n                );\n                require(\n                    auction_.art - artIn >= debt.min * (10**debt.dec),\n                    \"Leaves dust\"\n                );\n\n                // Update the auction\n                auction_.ink -= inkOut.u128();\n                auction_.art -= artIn.u128();\n\n                // Store auction changes\n                auctions[vaultId] = auction_;\n\n                // Update limits - reduce it by whatever was bought\n                limits_.sum -= inkOut.u128();\n            }\n        }\n\n        // Store limit changes\n        limits[auction_.ilkId][auction_.baseId] = limits_;\n\n        // Update accounting at Cauldron\n        cauldron.slurp(vaultId, inkOut.u128(), artIn.u128());\n    }\n\n    /// @dev Logs that a certain amount of a vault was liquidated\n    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties\n    function _collateralBought(\n        bytes12 vaultId,\n        address buyer,\n        uint256 ink,\n        uint256 art\n    ) internal virtual {\n        emit Bought(vaultId, buyer, ink, art);\n    }\n\n    // ======================================================================\n    // =                         Quoting functions                          =\n    // ======================================================================\n\n    /*\n\n       x x x\n     x      x    Hi Fren!\n    x  .  .  x   I want to buy this vault under auction!  I'll pay\n    x        x   you in the same `base` currency of the debt, or in fyToken, but\n    x        x   I want no less than `uint min` of the collateral, ok?\n    x   ===  x\n    x       x\n      xxxxx\n        x                             __  Ok Fren!\n        x     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  _(\\    |@@|\n        xxxxxxâ”‚ BASE BUCKS â”‚ (__/\\__ \\--/ __\n        x     â”‚     OR     â”‚    \\___|----|  |   __\n        x     â”‚   FYTOKEN  â”‚        \\ }{ /\\ )_ / _\\\n       x x    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        /\\__/\\ \\__O (__\n                                   (--/\\--)    \\__/\n                            â”‚      _)(  )(_\n                            â”‚     `---''---`\n                            â–¼\n      _______\n     /  12   \\  First lets check how much time `t` is left on the auction\n    |    |    | because that helps us determine the price we will accept\n    |9   |   3| for the debt! Yay!\n    |     \\   |                       p + (1 - p) * t\n    |         |\n     \\___6___/          (p is the auction starting price!)\n\n                            â”‚\n                            â”‚\n                            â–¼                  (\\\n                                                \\ \\\n    Then the Cauldron updates our internal    __    \\/ ___,.-------..__        __\n    accounting by slurping up the debt      //\\\\ _,-'\\\\               `'--._ //\\\\\n    and the collateral from the vault!      \\\\ ;'      \\\\                   `: //\n                                            `(          \\\\                   )'\n    The Join  then dishes out the collateral   :.          \\\\,----,         ,;\n    to you, dear user. And the debt is          `.`--.___   (    /  ___.--','\n    settled with the base join or debt fyToken.   `.     ``-----'-''     ,'\n                                                    -.               ,-\n                                                       `-._______.-'gpyy\n\n\n    */\n    /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount\n    /// Works for both Auctioned and ToBeAuctioned vaults\n    /// @param vaultId The vault to get a quote for\n    /// @param to Address that would get the collateral bought\n    /// @param maxArtIn How much of the vault debt will be paid. GT than available art means all\n    /// @return liquidatorCut How much collateral the liquidator is expected to get\n    /// @return auctioneerCut How much collateral the auctioneer is expected to get. 0 if liquidator == auctioneer\n    /// @return artIn How much debt the liquidator is expected to pay\n    function calcPayout(\n        bytes12 vaultId,\n        address to,\n        uint256 maxArtIn\n    )\n        external\n        view\n        returns (\n            uint256 liquidatorCut,\n            uint256 auctioneerCut,\n            uint256 artIn\n        )\n    {\n        DataTypes.Auction memory auction_ = auctions[vaultId];\n        DataTypes.Vault memory vault = cauldron.vaults(vaultId);\n\n        // If the vault hasn't been auctioned yet, we calculate what values it'd have if it was started right now\n        if (auction_.start == 0) {\n            DataTypes.Series memory series = cauldron.series(vault.seriesId);\n            DataTypes.Balances memory balances = cauldron.balances(vaultId);\n            DataTypes.Debt memory debt = cauldron.debt(\n                series.baseId,\n                vault.ilkId\n            );\n            auction_ = _calcAuction(vault, series, to, balances, debt);\n        }\n\n        // GT check is to cater for partial buys right before this method executes\n        artIn = maxArtIn > auction_.art ? auction_.art : maxArtIn;\n\n        (liquidatorCut, auctioneerCut) = _calcPayout(auction_, to, artIn);\n    }\n\n    /// @notice Return how much collateral should be given out.\n    function _calcPayout(\n        DataTypes.Auction memory auction_,\n        address to,\n        uint256 artIn\n    ) internal view returns (uint256 liquidatorCut, uint256 auctioneerCut) {\n        // Calculate how much collateral to give for paying a certain amount of debt, at a certain time, for a certain vault.\n        // inkOut = (artIn / totalArt) * totalInk * (p + (1 - p) * t)\n        DataTypes.Line memory line_ = lines[auction_.ilkId][\n            auction_.baseId\n        ];\n        uint256 duration = line_.duration;\n        uint256 initialProportion = line_.initialOffer;\n\n        // If the world has not turned to ashes and darkness, auctions will malfunction on\n        // the 7th of February 2106, at 06:28:16 GMT\n        // TODO: Replace this contract before then ðŸ˜°\n        // UPDATE: Added reminder to Google calendar âœ…\n        uint256 elapsed;\n        uint256 proportionNow;\n        unchecked {\n            elapsed = uint32(block.timestamp) - uint256(auction_.start); // Overflow on block.timestamp is fine\n        }\n        if (duration == type(uint32).max) {     // Interpreted as infinite duration\n            proportionNow = initialProportion;\n        } else if (elapsed > duration) {\n            proportionNow = 1e18;\n        } else {\n            proportionNow =\n                uint256(initialProportion) +\n                uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));\n        }\n\n        uint256 inkAtEnd = uint256(artIn).wdiv(auction_.art).wmul(auction_.ink);\n        liquidatorCut = inkAtEnd.wmul(proportionNow);\n        if (auction_.auctioneer != to) {\n            auctioneerCut = liquidatorCut.wmul(auctioneerReward);\n            liquidatorCut -= auctioneerCut;\n        }\n    }\n}"
    }
  ]
}