{
  "Title": "H-2: Requested oracle versions, which have expired, must return this oracle version as invalid, but they return it as a normal version with previous version's price instead",
  "Content": "# Issue H-2: Requested oracle versions, which have expired, must return this oracle version as invalid, but they return it as a normal version with previous version's price instead \n\nSource: https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/6 \n\n## Found by \nbin2chen, panprog\n## Summary\n\nEach market action requests a new oracle version which must be commited by the keepers. However, if keepers are unable to commit requested version's price (for example, no price is available at the time interval, network or keepers are down), then after a certain timeout this oracle version will be commited as invalid, using the previous valid version's price.\n\nThe issue is that when this expired oracle version is used by the market (using `oracle.at`), the version returned will be valid (`valid = true`), because oracle returns version as invalid only if `price = 0`, but the `commit` function sets the previous version's price for these, thus it's not 0.\n\nThis leads to market using invalid versions as if they're valid, keeping the orders (instead of invalidating them), which is a broken core functionality and a security risk for the protocol.\n\n## Vulnerability Detail\n\nWhen requested oracle version is commited, but is expired (commited after a certain timeout), the price of the previous valid version is set to this expired oracle version:\n```solidity\nfunction _commitRequested(OracleVersion memory version) private returns (bool) {\n    if (block.timestamp <= (next() + timeout)) {\n        if (!version.valid) revert KeeperOracleInvalidPriceError();\n        _prices[version.timestamp] = version.price;\n    } else {\n        // @audit previous valid version's price is set for expired version\n        _prices[version.timestamp] = _prices[_global.latestVersion]; \n    }\n    _global.latestIndex++;\n    return true;\n}\n```\n\nLater, `Market._processOrderGlobal` reads the oracle version using the `oracle.at`, invalidating the order if the version is invalid:\n```solidity\nfunction _processOrderGlobal(\n    Context memory context,\n    SettlementContext memory settlementContext,\n    uint256 newOrderId,\n    Order memory newOrder\n) private {\n    OracleVersion memory oracleVersion = oracle.at(newOrder.timestamp);\n\n    context.pending.global.sub(newOrder);\n    if (!oracleVersion.valid) newOrder.invalidate();\n```\n\nHowever, expired oracle version will return `valid = true`, because this flag is only set to `false` if `price = 0`:\n```solidity\nfunction at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n    (oracleVersion.timestamp, oracleVersion.price) = (timestamp, _prices[timestamp]);\n    oracleVersion.valid = !oracleVersion.price.isZero(); // @audit <<< valid = false only if price = 0\n}\n```\n\nThis means that `_processOrderGlobal` will treat this expired oracle version as valid and won't invalidate the order.\n\n## Impact\n\nMarket uses invalid (expired) oracle versions as if they're valid, keeping the orders (instead of invalidating them), which is a broken core functionality and a security risk for the protocol.\n\n## Code Snippet\n\n`KeeperOracle._commitRequested` sets `_prices` to the last valid version's price for expired versions:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol#L153-L162\n\n`Market._processOrderGlobal` reads the oracle version using the `oracle.at`, invalidating the order if the version is invalid:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L604-L613\n\n`KeeperOracle.at` returns `valid = false` only if `price = 0`, but since expired version has valid price, it will be returned as a valid version:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol#L109-L112\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd validity map along with the price map to `KeeperOracle` when recording commited price.\n\n\n\n## Discussion\n\n**nevillehuang**\n\n@arjun-io @panprog @bin2chen66 For the current supported tokens in READ.ME, I think medium severity remains appropriate given they are both stablecoins. Do you agree?\n\n**arjun-io**\n\n> @arjun-io @panprog @bin2chen66 For the current supported tokens in READ.ME, I think medium severity remains appropriate given they are both stablecoins. Do you agree?\n\nI'm not entirely sure how the stablecoin in use matters here? Returning an invalid versions as valid can be very detrimental in markets where invalid versions can be triggered at will (such as in markets that close) which can result in users being able to open or close positions when they shouldn't be able to\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/equilibria-xyz/perennial-v2/pull/308\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/254",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"../interfaces/IKeeperFactory.sol\";\n\n/// @title KeeperOracle\n/// @notice Generic implementation of the IOracle interface for keeper-based oracles.\n/// @dev One instance per price feed should be deployed. Multiple products may use the same\n///      KeeperOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract KeeperOracle is IKeeperOracle, Instance {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 public immutable timeout;\n\n    /// @dev List of all requested oracle versions\n    mapping(uint256 => uint256) public versions;\n\n    /// @dev The global state of the oracle\n    Global private _global;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from version to a set of registered markets for settlement callback\n    mapping(uint256 => EnumerableSet.AddressSet) private _globalCallbacks;\n\n    /// @dev Mapping from version and market to a set of registered accounts for settlement callback\n    mapping(uint256 => mapping(IMarket => EnumerableSet.AddressSet)) private _localCallbacks;\n\n    /// @notice Constructs the contract\n    /// @param timeout_ The timeout for a version to be committed\n    constructor(uint256 timeout_)  {\n        timeout = timeout_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Instance__initialize();\n    }\n\n    /// @notice Returns the global state of the oracle\n    /// @return The global state of the oracle\n    function global() external view returns (Global memory) { return _global; }\n\n    /// @notice Returns the global oracle callback set for a version\n    /// @param version The version to lookup\n    /// @return The global oracle callback set for the version\n    function globalCallbacks(uint256 version) external view returns (address[] memory) {\n        return _globalCallbacks[version].values();\n    }\n\n    /// @notice Returns the local oracle callback set for a version and market\n    /// @param version The version to lookup\n    /// @param market The market to lookup\n    /// @return The local oracle callback set for the version and market\n    function localCallbacks(uint256 version, IMarket market) external view returns (address[] memory) {\n        return _localCallbacks[version][market].values();\n    }\n\n    /// @notice Returns the next requested oracle version\n    /// @dev Returns 0 if no next version is requested\n    /// @return The next requested oracle version\n    function next() public view returns (uint256) {\n        return versions[_global.latestIndex + 1];\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @param market The market to callback to\n    /// @param account The account to callback to\n    function request(IMarket market, address account) external onlyAuthorized {\n        uint256 currentTimestamp = current();\n\n        _globalCallbacks[currentTimestamp].add(address(market));\n        _localCallbacks[currentTimestamp][market].add(account);\n        emit CallbackRequested(SettlementCallback(market, account, currentTimestamp));\n\n        if (versions[_global.currentIndex] == currentTimestamp) return;\n        versions[++_global.currentIndex] = currentTimestamp;\n        emit OracleProviderVersionRequested(currentTimestamp);\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return Latest oracle version\n    function latest() public view returns (OracleVersion memory) {\n        return at(_global.latestVersion);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IKeeperFactory(address(factory())).current();\n    }\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        (oracleVersion.timestamp, oracleVersion.price) = (timestamp, _prices[timestamp]);\n        oracleVersion.valid = !oracleVersion.price.isZero();\n    }\n\n    /// @notice Commits the price to specified version\n    /// @dev Verification of price happens in the oracle's factory\n    /// @param version The oracle version to commit\n    /// @return requested Whether the commit was requested\n    function commit(OracleVersion memory version) external onlyFactory returns (bool requested) {\n        if (version.timestamp == 0) revert KeeperOracleVersionOutsideRangeError();\n        requested = (version.timestamp == next()) ? _commitRequested(version) : _commitUnrequested(version);\n        _global.latestVersion = uint64(version.timestamp);\n\n        for (uint256 i; i < _globalCallbacks[version.timestamp].length(); i++)\n            _settle(IMarket(_globalCallbacks[version.timestamp].at(i)), address(0));\n\n        emit OracleProviderVersionFulfilled(version);\n    }\n\n    /// @notice Performs an asynchronous local settlement callback\n    /// @dev Distribution of keeper incentive is consolidated in the oracle's factory\n    /// @param market The market to settle\n    /// @param version The version to settle\n    /// @param maxCount The maximum number of settlement callbacks to perform before exiting\n    function settle(IMarket market, uint256 version, uint256 maxCount) external onlyFactory {\n        EnumerableSet.AddressSet storage callbacks = _localCallbacks[version][market];\n\n        if (_global.latestVersion < version) revert KeeperOracleVersionOutsideRangeError();\n        if (maxCount == 0) revert KeeperOracleInvalidCallbackError();\n        if (callbacks.length() == 0) revert KeeperOracleInvalidCallbackError();\n\n        for (uint256 i; i < maxCount && callbacks.length() > 0; i++) {\n            address account = callbacks.at(0);\n            _settle(market, account);\n            callbacks.remove(account);\n            emit CallbackFulfilled(SettlementCallback(market, account, version));\n        }\n    }\n\n    /// @notice Commits the price to a requested version\n    /// @dev This commit function will pay out a keeper fee if the committed version is valid\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitRequested(OracleVersion memory version) private returns (bool) {\n        if (block.timestamp <= (next() + timeout)) {\n            if (!version.valid) revert KeeperOracleInvalidPriceError();\n            _prices[version.timestamp] = version.price;\n        } else {\n            _prices[version.timestamp] = _prices[_global.latestVersion];\n        }\n        _global.latestIndex++;\n        return true;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitUnrequested(OracleVersion memory version) private returns (bool) {\n        if (!version.valid) revert KeeperOracleInvalidPriceError();\n        if (version.timestamp <= _global.latestVersion || (next() != 0 && version.timestamp >= next()))\n            revert KeeperOracleVersionOutsideRangeError();\n        _prices[version.timestamp] = version.price;\n        return false;\n    }\n\n    /// @notice Performs a settlement callback for the account on the market\n    /// @param market The market to settle\n    /// @param account The account to settle\n    function _settle(IMarket market, address account) private {\n        market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.ZERO, false);\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\nimport \"./libs/InvariantLib.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    Fixed6 private constant MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL = Fixed6.wrap(type(int256).min);\n    UFixed6 private constant MAGIC_VALUE_UNCHANGED_POSITION = UFixed6.wrap(type(uint256).max);\n    UFixed6 private constant MAGIC_VALUE_FULLY_CLOSED_POSITION = UFixed6.wrap(type(uint256).max - 1);\n\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev DEPRECATED SLOT -- previously the reward token\n    bytes32 private __unused0__;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev DEPRECATED SLOT -- previously the payoff provider\n    bytes32 private __unused1__;\n\n    /// @dev Beneficiary of the market, receives donations\n    address private beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address private coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev DEPRECATED SLOT -- previously the global pending positions\n    bytes32 private __unused2__;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev DEPRECATED SLOT -- previously the local pending positions\n    bytes32 private __unused3__;\n\n    /// @dev The historical version accumulator data for each accessed version\n    mapping(uint256 => VersionStorage) private _versions;\n\n    /// @dev The global pending order for each id\n    mapping(uint256 => OrderStorageGlobal) private _pendingOrder;\n\n    /// @dev The local pending order for each id for each account\n    mapping(address => mapping(uint256 => OrderStorageLocal)) private _pendingOrders;\n\n    /// @dev The global aggregate pending order\n    OrderStorageGlobal private _pending;\n\n    /// @dev The local aggregate pending order for each account\n    mapping(address => OrderStorageLocal) private _pendings;\n\n    /// @dev The local checkpoint for each id for each account\n    mapping(address => mapping(uint256 => CheckpointStorage)) private _checkpoints;\n\n    /// @dev The liquidator for each id for each account\n    mapping(address => mapping(uint256 => address)) public liquidators;\n\n    /// @dev The referrer for each id for each account\n    mapping(address => mapping(uint256 => address)) public referrers;\n\n    /// @notice Initializes the contract state\n    /// @param definition_ The market definition\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __ReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n    }\n\n    /// @notice Settles the account's position and collateral\n    /// @param account The account to operate on\n    function settle(address account) external nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n\n        _storeContext(context, account);\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external {\n        update(account, newMaker, newLong, newShort, collateral, protect, address(0));\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    /// @param referrer The referrer of the order\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect,\n        address referrer\n    ) public nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _update(context, account, newMaker, newLong, newShort, collateral, protect, referrer);\n\n        _storeContext(context, account);\n    }\n\n    /// @notice Updates the oracle of the market\n    /// @dev For the v2.1.1 -> v2.2 migration process, not to be used otherwise\n    /// @param newOracle The new oracle address\n    function updateOracle(IOracleProvider newOracle) external onlyOwner {\n        oracle = newOracle;\n        emit OracleUpdated(newOracle);\n    }\n\n    /// @notice Updates the beneficiary, coordinator, and parameter set of the market\n    /// @param newBeneficiary The new beneficiary address\n    /// @param newCoordinator The new coordinator address\n    /// @param newParameter The new parameter set\n    function updateParameter(\n        address newBeneficiary,\n        address newCoordinator,\n        MarketParameter memory newParameter\n    ) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n\n        coordinator = newCoordinator;\n        emit CoordinatorUpdated(newCoordinator);\n\n        _parameter.validateAndStore(newParameter, IMarketFactory(address(factory())).parameter());\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the risk parameter set of the market\n    /// @param newRiskParameter The new risk parameter set\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external onlyCoordinator {\n\n        // credit impact update fee to the protocol account\n        Global memory newGlobal = _global.read();\n        Position memory latestPosition = _position.read();\n        RiskParameter memory latestRiskParameter = _riskParameter.read();\n        OracleVersion memory latestVersion = oracle.at(latestPosition.timestamp);\n\n        Fixed6 updateFee = latestRiskParameter.makerFee\n            .update(newRiskParameter.makerFee, latestPosition.maker, latestVersion.price.abs())\n            .add(latestRiskParameter.takerFee\n                .update(newRiskParameter.takerFee, latestPosition.skew(), latestVersion.price.abs()));\n\n        newGlobal.exposure = newGlobal.exposure.sub(updateFee);\n        _global.store(newGlobal);\n\n        // update\n        _riskParameter.validateAndStore(newRiskParameter, IMarketFactory(address(factory())).parameter());\n        emit RiskParameterUpdated(newRiskParameter);\n    }\n\n    /// @notice Claims any available fee that the sender has accrued\n    /// @dev Applicable fees include: protocol, oracle, risk, donation, and claimable\n    function claimFee() external {\n        Global memory newGlobal = _global.read();\n        Local memory newLocal = _locals[msg.sender].read();\n\n        if (_claimFee(factory().owner(), newGlobal.protocolFee)) newGlobal.protocolFee = UFixed6Lib.ZERO;\n        if (_claimFee(address(IMarketFactory(address(factory())).oracleFactory()), newGlobal.oracleFee))\n            newGlobal.oracleFee = UFixed6Lib.ZERO;\n        if (_claimFee(coordinator, newGlobal.riskFee)) newGlobal.riskFee = UFixed6Lib.ZERO;\n        if (_claimFee(beneficiary, newGlobal.donation)) newGlobal.donation = UFixed6Lib.ZERO;\n        if (_claimFee(msg.sender, newLocal.claimable)) newLocal.claimable = UFixed6Lib.ZERO;\n\n        _global.store(newGlobal);\n        _locals[msg.sender].store(newLocal);\n    }\n\n    /// @notice Settles any exposure that has accrued to the market\n    /// @dev Resets exposure to zero, caller pays or receives to net out the exposure\n    function claimExposure() external onlyOwner {\n        Global memory newGlobal = _global.read();\n\n        if (newGlobal.exposure.sign() == 1) token.push(msg.sender, UFixed18Lib.from(newGlobal.exposure.abs()));\n        if (newGlobal.exposure.sign() == -1) token.pull(msg.sender, UFixed18Lib.from(newGlobal.exposure.abs()));\n\n        emit ExposureClaimed(msg.sender, newGlobal.exposure);\n\n        newGlobal.exposure = Fixed6Lib.ZERO;\n        _global.store(newGlobal);\n    }\n\n    /// @notice Helper function to handle a singular fee claim.\n    /// @param receiver The address to receive the fee\n    /// @param fee The amount of the fee to claim\n    function _claimFee(address receiver, UFixed6 fee) private returns (bool) {\n        if (msg.sender != receiver || fee.isZero()) return false;\n\n        token.push(receiver, UFixed18Lib.from(fee));\n        emit FeeClaimed(receiver, fee);\n        return true;\n    }\n\n    /// @notice Returns the payoff provider\n    /// @dev For backwards compatibility\n    function payoff() external pure returns (address) {\n        return address(0);\n    }\n\n    /// @notice Returns the current parameter set\n    function parameter() external view returns (MarketParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the current risk parameter set\n    function riskParameter() external view returns (RiskParameter memory) {\n        return _riskParameter.read();\n    }\n\n    /// @notice Returns the current global position\n    function position() external view returns (Position memory) {\n        return _position.read();\n    }\n\n    /// @notice Returns the current local position for the account\n    /// @param account The account to query\n    function positions(address account) external view returns (Position memory) {\n        return _positions[account].read();\n    }\n\n    /// @notice Returns the current global state\n    function global() external view returns (Global memory) {\n        return _global.read();\n    }\n\n    /// @notice Returns the historical version snapshot at the given timestamp\n    /// @param timestamp The timestamp to query\n    function versions(uint256 timestamp) external view returns (Version memory) {\n        return _versions[timestamp].read();\n    }\n\n    /// @notice Returns the local state for the given account\n    /// @param account The account to query\n    function locals(address account) external view returns (Local memory) {\n        return _locals[account].read();\n    }\n\n    /// @notice Returns the global pending order for the given id\n    /// @param id The id to query\n    function pendingOrder(uint256 id) external view returns (Order memory) {\n        return _pendingOrder[id].read();\n    }\n\n    /// @notice Returns the local pending order for the given account and id\n    /// @param account The account to query\n    /// @param id The id to query\n    function pendingOrders(address account, uint256 id) external view returns (Order memory) {\n        return _pendingOrders[account][id].read();\n    }\n\n    /// @notice Returns the aggregate global pending order\n    function pending() external view returns (Order memory) {\n        return _pending.read();\n    }\n\n    /// @notice Returns the aggregate local pending order for the given account\n    /// @param account The account to query\n    function pendings(address account) external view returns (Order memory) {\n        return _pendings[account].read();\n    }\n\n    /// @notice Returns the local checkpoint for the given account and version\n    /// @param account The account to query\n    /// @param version The version to query\n    function checkpoints(address account, uint256 version) external view returns (Checkpoint memory) {\n        return _checkpoints[account][version].read();\n    }\n\n    /// @notice Loads the transaction context\n    /// @param account The account to load for\n    /// @return context The transaction context\n    function _loadContext(address account) private view returns (Context memory context) {\n        // parameters\n        context.marketParameter = _parameter.read();\n        context.riskParameter = _riskParameter.read();\n        context.protocolParameter = IMarketFactory(address(factory())).parameter();\n\n        // oracle\n        (context.latestOracleVersion, context.currentTimestamp) = oracle.status();\n\n        // state\n        context.global = _global.read();\n        context.local = _locals[account].read();\n\n        // latest positions\n        context.latestPosition.global = _position.read();\n        context.latestPosition.local = _positions[account].read();\n\n        // aggregate pending orders\n        context.pending.global = _pending.read();\n        context.pending.local = _pendings[account].read();\n    }\n\n    /// @notice Stores the context for the transaction\n    /// @param context The context to store\n    /// @param account The account to store for\n    function _storeContext(Context memory context, address account) private {\n        // state\n        _global.store(context.global);\n        _locals[account].store(context.local);\n\n        // latest positions\n        _position.store(context.latestPosition.global);\n        _positions[account].store(context.latestPosition.local);\n\n        // aggregate pending orders\n        _pending.store(context.pending.global);\n        _pendings[account].store(context.pending.local);\n    }\n\n    /// @notice Loads the context for the update process\n    /// @param context The context to load to\n    /// @param account The account to load for\n    /// @param referrer The referrer to load for\n    /// @return updateContext The update context\n    function _loadUpdateContext(\n        Context memory context,\n        address account,\n        address referrer\n    ) private view returns (UpdateContext memory updateContext) {\n        // load current position\n        updateContext.currentPosition.global = context.latestPosition.global.clone();\n        updateContext.currentPosition.global.update(context.pending.global);\n        updateContext.currentPosition.local = context.latestPosition.local.clone();\n        updateContext.currentPosition.local.update(context.pending.local);\n\n        // load current order\n        updateContext.order.global = _pendingOrder[context.global.currentId].read();\n        updateContext.order.local = _pendingOrders[account][context.local.currentId].read();\n\n        // load external actors\n        updateContext.operator = IMarketFactory(address(factory())).operators(account, msg.sender);\n        updateContext.liquidator = liquidators[account][context.local.currentId];\n        updateContext.referrer = referrers[account][context.local.currentId];\n        updateContext.referralFee = IMarketFactory(address(factory())).referralFee(referrer);\n    }\n\n    /// @notice Stores the context for the update process\n    /// @param context The transaction context\n    /// @param updateContext The update context to store\n    /// @param account The account to store for\n    function _storeUpdateContext(Context memory context, UpdateContext memory updateContext, address account) private {\n        // current orders\n        _pendingOrder[context.global.currentId].store(updateContext.order.global);\n        _pendingOrders[account][context.local.currentId].store(updateContext.order.local);\n\n        // external actors\n        liquidators[account][context.local.currentId] = updateContext.liquidator;\n        referrers[account][context.local.currentId] = updateContext.referrer;\n    }\n\n    /// @notice Updates the current position\n    /// @param context The context to use\n    /// @param account The account to update\n    /// @param newMaker The new maker position size\n    /// @param newLong The new long position size\n    /// @param newShort The new short position size\n    /// @param collateral The change in collateral\n    /// @param protect Whether to protect the position for liquidation\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect,\n        address referrer\n    ) private notSettleOnly(context) {\n        // load\n        UpdateContext memory updateContext = _loadUpdateContext(context, account, referrer);\n\n        // magic values\n        collateral = _processCollateralMagicValue(context, collateral);\n        newMaker = _processPositionMagicValue(context, updateContext.currentPosition.local.maker, newMaker);\n        newLong = _processPositionMagicValue(context, updateContext.currentPosition.local.long, newLong);\n        newShort = _processPositionMagicValue(context, updateContext.currentPosition.local.short, newShort);\n\n        // referral fee\n        UFixed6 referralFee = _processReferralFee(context, updateContext, referrer);\n\n        // advance to next id if applicable\n        if (context.currentTimestamp > updateContext.order.local.timestamp) {\n            updateContext.order.local.next(context.currentTimestamp);\n            context.local.currentId++;\n        }\n        if (context.currentTimestamp > updateContext.order.global.timestamp) {\n            updateContext.order.global.next(context.currentTimestamp);\n            context.global.currentId++;\n        }\n\n        // update current position\n        Order memory newOrder = OrderLib.from(\n            context.currentTimestamp,\n            updateContext.currentPosition.local,\n            collateral,\n            newMaker,\n            newLong,\n            newShort,\n            protect,\n            referralFee\n        );\n        updateContext.currentPosition.global.update(newOrder);\n        updateContext.currentPosition.local.update(newOrder);\n\n        // apply new order\n        updateContext.order.local.add(newOrder);\n        updateContext.order.global.add(newOrder);\n        context.pending.global.add(newOrder);\n        context.pending.local.add(newOrder);\n\n        // update collateral\n        context.local.update(collateral);\n\n        // protect account\n        if (newOrder.protected()) updateContext.liquidator = msg.sender;\n\n        // apply referrer\n        _processReferrer(updateContext, newOrder, referrer);\n\n        // request version\n        if (!newOrder.isEmpty()) oracle.request(IMarket(this), account);\n\n        // after\n        InvariantLib.validate(context, updateContext, msg.sender, account, newOrder, collateral);\n\n        // store\n        _storeUpdateContext(context, updateContext, account);\n\n        // fund\n        if (collateral.sign() == 1) token.pull(msg.sender, UFixed18Lib.from(collateral.abs()));\n        if (collateral.sign() == -1) token.push(msg.sender, UFixed18Lib.from(collateral.abs()));\n\n        // events\n        emit Updated(msg.sender, account, context.currentTimestamp, newMaker, newLong, newShort, collateral, protect, referrer);\n        emit OrderCreated(account, newOrder);\n    }\n\n    /// @notice Processes the referral fee for the given order\n    /// @param context The context to use\n    /// @param updateContext The update context to use\n    /// @param referrer The referrer of the order\n    /// @return The referral fee to apply\n    function _processReferralFee(\n        Context memory context,\n        UpdateContext memory updateContext,\n        address referrer\n    ) private pure returns (UFixed6) {\n        if (referrer == address(0)) return UFixed6Lib.ZERO;\n        if (!updateContext.referralFee.isZero()) return updateContext.referralFee;\n        return context.protocolParameter.referralFee;\n    }\n\n    /// @notice Processes the referrer for the given order\n    /// @param updateContext The update context to use\n    /// @param newOrder The order to process\n    /// @param referrer The referrer of the order\n    function _processReferrer(\n        UpdateContext memory updateContext,\n        Order memory newOrder,\n        address referrer\n    ) private pure {\n        if (newOrder.makerReferral.isZero() && newOrder.takerReferral.isZero()) return;\n        if (updateContext.referrer == address(0)) updateContext.referrer = referrer;\n        if (updateContext.referrer == referrer) return;\n\n        revert MarketInvalidReferrerError();\n    }\n\n    /// @notice Loads the settlement context\n    /// @param context The transaction context\n    /// @param account The account to load for\n    /// @return settlementContext The settlement context\n    function _loadSettlementContext(\n        Context memory context,\n        address account\n    ) private view returns (SettlementContext memory settlementContext) {\n        // processing accumulators\n        settlementContext.latestVersion = _versions[context.latestPosition.global.timestamp].read();\n        settlementContext.latestCheckpoint = _checkpoints[account][context.latestPosition.local.timestamp].read();\n        settlementContext.orderOracleVersion = oracle.at(context.latestPosition.global.timestamp);\n\n        // v2.2 migration (if latest checkpoint is empty, initialize with latest local collateral)\n        if (\n            settlementContext.latestCheckpoint.tradeFee.isZero() &&\n            settlementContext.latestCheckpoint.settlementFee.isZero() &&\n            settlementContext.latestCheckpoint.transfer.isZero() &&\n            settlementContext.latestCheckpoint.collateral.isZero() &&\n            context.pending.local.collateral.isZero()\n        ) settlementContext.latestCheckpoint.collateral = context.local.collateral;\n    }\n\n    /// @notice Settles the account position up to the latest version\n    /// @param context The context to use\n    /// @param account The account to settle\n    function _settle(Context memory context, address account) private {\n        SettlementContext memory settlementContext = _loadSettlementContext(context, account);\n\n        Order memory nextOrder;\n\n        // settle\n        while (\n            context.global.currentId != context.global.latestId &&\n            (nextOrder = _pendingOrder[context.global.latestId + 1].read()).ready(context.latestOracleVersion)\n        ) _processOrderGlobal(context, settlementContext, context.global.latestId + 1, nextOrder);\n\n        while (\n            context.local.currentId != context.local.latestId &&\n            (nextOrder = _pendingOrders[account][context.local.latestId + 1].read()).ready(context.latestOracleVersion)\n        ) _processOrderLocal(context, settlementContext, account, context.local.latestId + 1, nextOrder);\n\n        // sync\n        if (context.latestOracleVersion.timestamp > context.latestPosition.global.timestamp) {\n            nextOrder = _pendingOrder[context.global.latestId].read();\n            nextOrder.next(context.latestOracleVersion.timestamp);\n            _processOrderGlobal(context, settlementContext, context.global.latestId, nextOrder);\n        }\n\n        if (context.latestOracleVersion.timestamp > context.latestPosition.local.timestamp) {\n            nextOrder = _pendingOrders[account][context.local.latestId].read();\n            nextOrder.next(context.latestOracleVersion.timestamp);\n            _processOrderLocal(context, settlementContext, account, context.local.latestId, nextOrder);\n        }\n    }\n\n    /// @notice Modifies the collateral input per magic values\n    /// @param context The context to"
    }
  ]
}