{
  "Title": "[G-01] Using `calldata` instead of `memory` for read-only arguments in external functions saves gas",
  "Content": "\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. Each iteration of this for-loop costs at least 60 gas (i.e. `60 * <mem_array>.length`). Using calldata directly, obliviates the need for such a loop in the contract code and runtime execution.\n\nIf the array is passed to an `internal` function which passes the array to another `internal` function where the array is modified and therefore `memory` is used in the `external` call, it's still more gas-efficient to use `calldata` when the external function uses modifiers, since the modifiers may prevent the `internal` functions from being called. `Structs` have the same overhead as an array of length one\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #1\n\n28:       function addOperator(IOperatorResolver.Operator memory operator, bytes32 name) external {\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L28\n```\n\n```solidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #2\n\n52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external {\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52\n```\n\n```solidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #3\n\n52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external {\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-06-nested-finance-contest",
  "Code": [
    {
      "filename": "contracts/governance/scripts/OperatorScripts.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../../interfaces/INestedFactory.sol\";\nimport \"../../interfaces/IOperatorResolver.sol\";\nimport \"../../abstracts/MixinOperatorResolver.sol\";\nimport \"../../interfaces/external/ITransparentUpgradeableProxy.sol\";\n\ncontract OperatorScripts {\n    struct tupleOperator {\n        bytes32 name;\n        bytes4 selector;\n    }\n\n    address public immutable nestedFactory;\n    address public immutable resolver;\n\n    constructor(address _nestedFactory, address _resolver) {\n        require(_nestedFactory != address(0), \"AO-SCRIPT: INVALID_FACTORY_ADDR\");\n        require(_resolver != address(0), \"AO-SCRIPT: INVALID_RESOLVER_ADDR\");\n        nestedFactory = _nestedFactory;\n        resolver = _resolver;\n    }\n\n    /// @notice Call NestedFactory and OperatorResolver to add an operator.\n    /// @param operator The operator to add\n    /// @param name The operator bytes32 name\n    function addOperator(IOperatorResolver.Operator memory operator, bytes32 name) external {\n        require(operator.implementation != address(0), \"AO-SCRIPT: INVALID_IMPL_ADDRESS\");\n\n        // Init arrays with length 1 (only one operator to import)\n        bytes32[] memory names = new bytes32[](1);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](1);\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n\n        names[0] = name;\n        operatorsToImport[0] = operator;\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n\n        ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n            ITransparentUpgradeableProxy(nestedFactory).implementation(),\n            abi.encodeWithSelector(INestedFactory.addOperator.selector, name)\n        );\n    }\n\n    /// @notice Deploy and add operators\n    /// @dev One address and multiple selectors/names\n    /// @param bytecode Operator implementation bytecode\n    /// @param operators Array of tuples => bytes32/bytes4 (name and selector)\n    function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external {\n        uint256 operatorLength = operators.length;\n        require(operatorLength != 0, \"DAO-SCRIPT: INVALID_OPERATOR_LEN\");\n        require(bytecode.length != 0, \"DAO-SCRIPT: BYTECODE_ZERO\");\n\n        address deployedAddress;\n        assembly {\n            deployedAddress := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n        require(deployedAddress != address(0), \"DAO-SCRIPT: FAILED_DEPLOY\");\n\n        // Init arrays\n        bytes32[] memory names = new bytes32[](operatorLength);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](operatorLength);\n\n        for (uint256 i; i < operatorLength; i++) {\n            names[i] = operators[i].name;\n            operatorsToImport[i] = IOperatorResolver.Operator(deployedAddress, operators[i].selector);\n        }\n\n        // Only the NestedFactory as destination\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        // Start importing operators\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n\n        // Add all the operators to the factory\n        for (uint256 i; i < operatorLength; i++) {\n            ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n                ITransparentUpgradeableProxy(nestedFactory).implementation(),\n                abi.encodeWithSelector(INestedFactory.addOperator.selector, operators[i].name)\n            );\n        }\n    }\n\n    /// @notice Call NestedFactory and OperatorResolver to remove an operator.\n    /// @param name The operator bytes32 name\n    function removeOperator(bytes32 name) external {\n        ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n            ITransparentUpgradeableProxy(nestedFactory).implementation(),\n            abi.encodeWithSelector(INestedFactory.removeOperator.selector, name)\n        );\n\n        // Init arrays with length 1 (only one operator to remove)\n        bytes32[] memory names = new bytes32[](1);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](1);\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n\n        names[0] = name;\n        operatorsToImport[0] = IOperatorResolver.Operator({ implementation: address(0), selector: bytes4(0) });\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n    }\n}"
    },
    {
      "filename": "contracts/governance/scripts/OperatorScripts.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../../interfaces/INestedFactory.sol\";\nimport \"../../interfaces/IOperatorResolver.sol\";\nimport \"../../abstracts/MixinOperatorResolver.sol\";\nimport \"../../interfaces/external/ITransparentUpgradeableProxy.sol\";\n\ncontract OperatorScripts {\n    struct tupleOperator {\n        bytes32 name;\n        bytes4 selector;\n    }\n\n    address public immutable nestedFactory;\n    address public immutable resolver;\n\n    constructor(address _nestedFactory, address _resolver) {\n        require(_nestedFactory != address(0), \"AO-SCRIPT: INVALID_FACTORY_ADDR\");\n        require(_resolver != address(0), \"AO-SCRIPT: INVALID_RESOLVER_ADDR\");\n        nestedFactory = _nestedFactory;\n        resolver = _resolver;\n    }\n\n    /// @notice Call NestedFactory and OperatorResolver to add an operator.\n    /// @param operator The operator to add\n    /// @param name The operator bytes32 name\n    function addOperator(IOperatorResolver.Operator memory operator, bytes32 name) external {\n        require(operator.implementation != address(0), \"AO-SCRIPT: INVALID_IMPL_ADDRESS\");\n\n        // Init arrays with length 1 (only one operator to import)\n        bytes32[] memory names = new bytes32[](1);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](1);\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n\n        names[0] = name;\n        operatorsToImport[0] = operator;\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n\n        ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n            ITransparentUpgradeableProxy(nestedFactory).implementation(),\n            abi.encodeWithSelector(INestedFactory.addOperator.selector, name)\n        );\n    }\n\n    /// @notice Deploy and add operators\n    /// @dev One address and multiple selectors/names\n    /// @param bytecode Operator implementation bytecode\n    /// @param operators Array of tuples => bytes32/bytes4 (name and selector)\n    function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external {\n        uint256 operatorLength = operators.length;\n        require(operatorLength != 0, \"DAO-SCRIPT: INVALID_OPERATOR_LEN\");\n        require(bytecode.length != 0, \"DAO-SCRIPT: BYTECODE_ZERO\");\n\n        address deployedAddress;\n        assembly {\n            deployedAddress := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n        require(deployedAddress != address(0), \"DAO-SCRIPT: FAILED_DEPLOY\");\n\n        // Init arrays\n        bytes32[] memory names = new bytes32[](operatorLength);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](operatorLength);\n\n        for (uint256 i; i < operatorLength; i++) {\n            names[i] = operators[i].name;\n            operatorsToImport[i] = IOperatorResolver.Operator(deployedAddress, operators[i].selector);\n        }\n\n        // Only the NestedFactory as destination\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        // Start importing operators\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n\n        // Add all the operators to the factory\n        for (uint256 i; i < operatorLength; i++) {\n            ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n                ITransparentUpgradeableProxy(nestedFactory).implementation(),\n                abi.encodeWithSelector(INestedFactory.addOperator.selector, operators[i].name)\n            );\n        }\n    }\n\n    /// @notice Call NestedFactory and OperatorResolver to remove an operator.\n    /// @param name The operator bytes32 name\n    function removeOperator(bytes32 name) external {\n        ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n            ITransparentUpgradeableProxy(nestedFactory).implementation(),\n            abi.encodeWithSelector(INestedFactory.removeOperator.selector, name)\n        );\n\n        // Init arrays with length 1 (only one operator to remove)\n        bytes32[] memory names = new bytes32[](1);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](1);\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n\n        names[0] = name;\n        operatorsToImport[0] = IOperatorResolver.Operator({ implementation: address(0), selector: bytes4(0) });\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n    }\n}"
    },
    {
      "filename": "contracts/governance/scripts/OperatorScripts.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../../interfaces/INestedFactory.sol\";\nimport \"../../interfaces/IOperatorResolver.sol\";\nimport \"../../abstracts/MixinOperatorResolver.sol\";\nimport \"../../interfaces/external/ITransparentUpgradeableProxy.sol\";\n\ncontract OperatorScripts {\n    struct tupleOperator {\n        bytes32 name;\n        bytes4 selector;\n    }\n\n    address public immutable nestedFactory;\n    address public immutable resolver;\n\n    constructor(address _nestedFactory, address _resolver) {\n        require(_nestedFactory != address(0), \"AO-SCRIPT: INVALID_FACTORY_ADDR\");\n        require(_resolver != address(0), \"AO-SCRIPT: INVALID_RESOLVER_ADDR\");\n        nestedFactory = _nestedFactory;\n        resolver = _resolver;\n    }\n\n    /// @notice Call NestedFactory and OperatorResolver to add an operator.\n    /// @param operator The operator to add\n    /// @param name The operator bytes32 name\n    function addOperator(IOperatorResolver.Operator memory operator, bytes32 name) external {\n        require(operator.implementation != address(0), \"AO-SCRIPT: INVALID_IMPL_ADDRESS\");\n\n        // Init arrays with length 1 (only one operator to import)\n        bytes32[] memory names = new bytes32[](1);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](1);\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n\n        names[0] = name;\n        operatorsToImport[0] = operator;\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n\n        ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n            ITransparentUpgradeableProxy(nestedFactory).implementation(),\n            abi.encodeWithSelector(INestedFactory.addOperator.selector, name)\n        );\n    }\n\n    /// @notice Deploy and add operators\n    /// @dev One address and multiple selectors/names\n    /// @param bytecode Operator implementation bytecode\n    /// @param operators Array of tuples => bytes32/bytes4 (name and selector)\n    function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external {\n        uint256 operatorLength = operators.length;\n        require(operatorLength != 0, \"DAO-SCRIPT: INVALID_OPERATOR_LEN\");\n        require(bytecode.length != 0, \"DAO-SCRIPT: BYTECODE_ZERO\");\n\n        address deployedAddress;\n        assembly {\n            deployedAddress := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n        require(deployedAddress != address(0), \"DAO-SCRIPT: FAILED_DEPLOY\");\n\n        // Init arrays\n        bytes32[] memory names = new bytes32[](operatorLength);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](operatorLength);\n\n        for (uint256 i; i < operatorLength; i++) {\n            names[i] = operators[i].name;\n            operatorsToImport[i] = IOperatorResolver.Operator(deployedAddress, operators[i].selector);\n        }\n\n        // Only the NestedFactory as destination\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        // Start importing operators\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n\n        // Add all the operators to the factory\n        for (uint256 i; i < operatorLength; i++) {\n            ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n                ITransparentUpgradeableProxy(nestedFactory).implementation(),\n                abi.encodeWithSelector(INestedFactory.addOperator.selector, operators[i].name)\n            );\n        }\n    }\n\n    /// @notice Call NestedFactory and OperatorResolver to remove an operator.\n    /// @param name The operator bytes32 name\n    function removeOperator(bytes32 name) external {\n        ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n            ITransparentUpgradeableProxy(nestedFactory).implementation(),\n            abi.encodeWithSelector(INestedFactory.removeOperator.selector, name)\n        );\n\n        // Init arrays with length 1 (only one operator to remove)\n        bytes32[] memory names = new bytes32[](1);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](1);\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n\n        names[0] = name;\n        operatorsToImport[0] = IOperatorResolver.Operator({ implementation: address(0), selector: bytes4(0) });\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n    }\n}"
    }
  ]
}