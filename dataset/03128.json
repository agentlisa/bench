{
  "Title": "Magic numbers are used",
  "Content": "Throughout the codebase, there are occurrences of literal values with unexplained meaning. For example, the operation to get the [maximum slashable stake](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L296) in the `FortaStaking` contract uses explicit numbers during the calculation without documenting the reasons of such values.\n\n\nTo improve the code’s readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. For complex values, consider adding an inline comment explaining how they were calculated or why they were chosen.\n\n\n***Update:** Fixed on [commit `802b183505f637d1f4ec97a64b2c8b3d58057096` in pull request 60](https://github.com/forta-protocol/forta-token/pull/60/commits/802b183505f637d1f4ec97a64b2c8b3d58057096).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/components/staking/FortaStaking.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/draft-IERC2612.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/Timers.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol\";\n\nimport \"./FortaStakingUtils.sol\";\nimport \"./FortaStakingSubjectTypes.sol\";\nimport \"./IStakeController.sol\";\nimport \"../BaseComponentUpgradeable.sol\";\nimport \"../../tools/Distributions.sol\";\nimport \"../../tools/FullMath.sol\";\n\ninterface IRewardReceiver {\n    function onRewardReceived(uint8 subjectType, uint256 subject, uint256 amount) external;\n}\n\n/**\n * @dev This is a generic staking contract for the Forta platform. It allows any account to deposit ERC20 tokens to\n * delegate their \"power\" by staking on behalf of a particular subject. The subject can be scanner, or any other actor\n * in the Forta ecosystem, who need to lock assets in order to contribute to the system.\n *\n * Stakers take risks with their funds, as bad action from a subject can lead to slashing of the funds. In the\n * meantime, stakers are elligible for rewards. Rewards distributed to a particular subject's stakers are distributed\n * following to each staker's share in the subject.\n *\n * Stakers can withdraw their funds, following a withdrawal delay. During the withdrawal delay, funds are no longer\n * counting toward the active stake of a subject, but are still slashable.\n *\n * The SLASHER_ROLE should be given to a future smart contract that will be in charge of resolving disputes.\n *\n * Stakers receive ERC1155 shares in exchange for their stake, making the active stake transferable. When a withdrawal\n * is initiated, similarly the ERC1155 tokens representing the (transferable) active shares are burned in exchange for\n * non-transferable ERC1155 tokens representing the inactive shares.\n *\n * ERC1155 shares representing active stake are transferable, and can be used in an AMM. Their value is however subject\n * to quick devaluation in case of slashing event for the corresponding subject. Thus, trading of such shares should be\n * be done very carefully.\n */\ncontract FortaStaking is BaseComponentUpgradeable, ERC1155SupplyUpgradeable, IStakeController {\n    using Distributions for Distributions.Balances;\n    using Distributions for Distributions.SignedBalances;\n    using Timers        for Timers.Timestamp;\n    using ERC165Checker for address;\n\n    IERC20 public stakedToken;\n\n    // subject => active stake\n    Distributions.Balances private _activeStake;\n    // subject => inactive stake\n    Distributions.Balances private _inactiveStake;\n    \n\n    // subject => staker => inactive stake timer\n    mapping(uint256 => mapping(address => Timers.Timestamp)) private _lockingDelay;\n\n    // subject => reward\n    Distributions.Balances private _rewards;\n    // subject => staker => released reward\n    mapping(uint256 => Distributions.SignedBalances) private _released;\n\n    // frozen tokens\n    mapping(uint256 => bool) private _frozen;\n\n    // withdrawal delay\n    uint64 private _withdrawalDelay;\n\n    // treasury for slashing\n    address private _treasury;\n\n    // minimum stake per subject type\n    mapping(uint8 => uint256) private _minStakes;\n\n    event StakeDeposited(uint8 indexed subjectType, uint256 indexed subject, address indexed account, uint256 amount);\n    event WithdrawalInitiated(uint8 indexed subjectType, uint256 indexed subject, address indexed account, uint64 deadline);\n    event WithdrawalExecuted(uint8 indexed subjectType, uint256 indexed subject, address indexed account);\n    event Froze(uint8 indexed subjectType, uint256 indexed subject, address indexed by, bool isFrozen);\n    event Slashed(uint8 indexed subjectType, uint256 indexed subject, address indexed by, uint256 value);\n    event Rewarded(uint8 indexed subjectType, uint256 indexed subject, address indexed from, uint256 value);\n    event Released(uint8 indexed subjectType, uint256 indexed subject, address indexed to, uint256 value);\n    event DelaySet(uint256 newWithdrawalDelay);\n    event TreasurySet(address newTreasury);\n\n    modifier onlyValidSubjectType(uint8 subjectType) {\n        require(\n            subjectType == SCANNER_SUBJECT ||\n            subjectType == AGENT_SUBJECT,\n            \"FortaStaking: invalid subjectType\"\n        );\n        _;\n    }\n\n    string public constant version = \"0.1.0\";\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address forwarder) initializer ForwardedContext(forwarder) {}\n\n    function initialize(\n        address __manager,\n        address __router,\n        IERC20 __stakedToken,\n        uint64 __withdrawalDelay,\n        address __treasury\n    ) public initializer {\n        __AccessManaged_init(__manager);\n        __Routed_init(__router);\n        __UUPSUpgradeable_init();\n        __ERC1155_init(\"\");\n\n        stakedToken = __stakedToken;\n        _withdrawalDelay = __withdrawalDelay;\n        _treasury = __treasury;\n        emit DelaySet(__withdrawalDelay);\n        emit TreasurySet(__treasury);\n    }\n\n    /**\n     * @dev Get stake of a subject\n     */\n    function activeStakeFor(uint8 subjectType, uint256 subject) public view returns (uint256) {\n        return _activeStake.balanceOf(FortaStakingUtils.subjectToActive(subjectType, subject));\n    }\n\n    /**\n     * @dev Get total stake of all subjects\n     */\n    function totalActiveStake() public view returns (uint256) {\n        return _activeStake.totalSupply();\n    }\n\n    /**\n     * @dev Get stake inactive for withdrawal of a subject\n     */\n    function inactiveStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256) {\n        return _inactiveStake.balanceOf(FortaStakingUtils.subjectToInactive(subjectType, subject));\n    }\n\n    /**\n     * @dev Get total stake inactive for withdrawal of all subjects\n     */\n    function totalInactiveStake() public view returns (uint256) {\n        return _inactiveStake.totalSupply();\n    }\n\n    /**\n     * @dev Get (active) shares of an account on a subject, corresponding to a fraction of the subject stake.\n     * NOTE: This is equivalent to getting the ERC1155 balanceOf for keccak256(abi.encodePacked(subjectType, subject)),\n     * shifted 9 bits, with the 9th bit set and uint8(subjectType) masked in\n     */\n    function sharesOf(uint8 subjectType, uint256 subject, address account) public view returns (uint256) {\n        return balanceOf(account, FortaStakingUtils.subjectToActive(subjectType, subject));\n    }\n\n    /**\n     * @dev Get the total (active) shares on a subject.\n     *\n     * NOTE: This is equivalent to getting the ERC1155 totalSupply for keccak256(abi.encodePacked(subjectType, subject)),\n     * shifted 9 bits, with the 9th bit set and uint8(subjectType) masked in\n     */\n    function totalShares(uint8 subjectType, uint256 subject) external view returns (uint256) {\n        return totalSupply(FortaStakingUtils.subjectToActive(subjectType, subject));\n    }\n\n    /**\n     * @dev Get inactive shares of an account on a subject, corresponding to a fraction of the subject inactive stake.\n     *\n     * NOTE: This is equivalent to getting the ERC1155 balanceOf for keccak256(abi.encodePacked(subjectType, subject)),\n     * shifted 9 bits, with the 9th bit unset and uint8(subjectType) masked in\n     */\n    function inactiveSharesOf(uint8 subjectType, uint256 subject, address account) external view returns (uint256) {\n        return balanceOf(account, FortaStakingUtils.subjectToInactive(subjectType, subject));\n    }\n\n    /**\n     * @dev Get the total inactive shares on a subject.\n     *\n     * NOTE: This is equivalent to getting the ERC1155 totalSupply for keccak256(abi.encodePacked(subjectType, subject)),\n     * shifted 9 bits, with the 9th bit unset and uint8(subjectType) masked in\n     */\n    function totalInactiveShares(uint8 subjectType, uint256 subject) external view returns (uint256) {\n        return totalSupply(FortaStakingUtils.subjectToInactive(subjectType, subject));\n    }\n\n    /**\n     * @dev Is a subject frozen (stake of frozen subject cannot be withdrawn).\n     */\n    function isFrozen(uint8 subjectType, uint256 subject) public view returns (bool) {\n        return _frozen[FortaStakingUtils.subjectToActive(subjectType, subject)];\n    }\n\n    /**\n     * @dev Deposit `stakeValue` tokens for a given `subject`, and mint the corresponding shares.\n     * NOTE: Subject type is necessary because we can't infer subject ID uniqueness between scanners, agents, etc\n     * Emits a ERC1155.TransferSingle event and StakeDeposited (to allow accounting per subject type)\n     */\n    function deposit(uint8 subjectType, uint256 subject, uint256 stakeValue)\n        public\n        onlyValidSubjectType(subjectType)\n        returns (uint256)\n    {\n        address staker = _msgSender();\n        uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n\n        uint256 sharesValue = _stakeToActiveShares(activeSharesId, stakeValue);\n        SafeERC20.safeTransferFrom(stakedToken, staker, address(this), stakeValue);\n\n        _activeStake.mint(activeSharesId, stakeValue);\n        _mint(staker, activeSharesId, sharesValue, new bytes(0));\n        emit StakeDeposited(subjectType, subject, staker, stakeValue);\n        _emitHook(abi.encodeWithSignature(\"hook_afterStakeChanged(uint8, uint256)\", subjectType, subject));\n        return sharesValue;\n    }\n\n    /**\n     * @dev Schedule the withdrawal of shares.\n     *\n     * Emits a WithdrawalInitiated event.\n     */\n    function initiateWithdrawal(uint8 subjectType, uint256 subject, uint256 sharesValue)\n        public\n        onlyValidSubjectType(subjectType)\n        returns (uint64)\n    {\n        address staker = _msgSender();\n        uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n        uint64 deadline = SafeCast.toUint64(block.timestamp) + _withdrawalDelay;\n\n        _lockingDelay[activeSharesId][staker].setDeadline(deadline);\n\n        uint256 activeShares   = Math.min(sharesValue, balanceOf(staker, activeSharesId));\n        uint256 stakeValue     = _activeSharesToStake(activeSharesId, activeShares);\n        uint256 inactiveShares = _stakeToInactiveShares(FortaStakingUtils.activeToInactive(activeSharesId), stakeValue);\n\n        _activeStake.burn(activeSharesId, stakeValue);\n        _inactiveStake.mint(FortaStakingUtils.activeToInactive(activeSharesId), stakeValue);\n        _burn(staker, activeSharesId, activeShares);\n        _mint(staker, FortaStakingUtils.activeToInactive(activeSharesId), inactiveShares, new bytes(0));\n\n        emit WithdrawalInitiated(subjectType, subject, staker, deadline);\n\n        _emitHook(abi.encodeWithSignature(\"hook_afterStakeChanged(uint8, uint256)\", subjectType, subject));\n        return deadline;\n    }\n\n    /**\n     * @dev Burn `sharesValue` shares for a given `subject`, and withdraw the corresponding tokens.\n     *\n     * Emits events WithdrawalExecuted and ERC1155.TransferSingle.\n     */\n    function withdraw(uint8 subjectType, uint256 subject)\n        public\n        onlyValidSubjectType(subjectType)\n        returns (uint256)\n    {\n        address staker = _msgSender();\n        uint256 inactiveSharesId = FortaStakingUtils.subjectToInactive(subjectType, subject);\n        require(!_frozen[FortaStakingUtils.inactiveToActive(inactiveSharesId)], \"Subject unstaking is currently frozen\");\n\n        Timers.Timestamp storage timer = _lockingDelay[FortaStakingUtils.inactiveToActive(inactiveSharesId)][staker];\n        require(timer.isExpired(), 'Withdrawal is not ready');\n        timer.reset();\n        emit WithdrawalExecuted(subjectType, subject, staker);\n\n        uint256 inactiveShares = balanceOf(staker, inactiveSharesId);\n        uint256 stakeValue     = _inactiveSharesToStake(inactiveSharesId, inactiveShares);\n\n        _inactiveStake.burn(inactiveSharesId, stakeValue);\n        _burn(staker, inactiveSharesId, inactiveShares);\n        SafeERC20.safeTransfer(stakedToken, staker, stakeValue);\n\n        _emitHook(abi.encodeWithSignature(\"hook_afterStakeChanged(uint8, uint256)\", subjectType, subject));\n\n        return stakeValue;\n    }\n\n    /**\n     * @dev Slash a fraction of a subject stake, and transfer it to the treasury. Restricted to the `SLASHER_ROLE`.\n     *\n     * Emits a Slashed event.\n     */\n    function slash(uint8 subjectType, uint256 subject, uint256 stakeValue)\n        public\n        onlyRole(SLASHER_ROLE)\n        onlyValidSubjectType(subjectType)\n        returns (uint256)\n    {\n        uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n        uint256 activeStake       = _activeStake.balanceOf(activeSharesId);\n        uint256 inactiveStake     = _inactiveStake.balanceOf(FortaStakingUtils.activeToInactive(activeSharesId));\n\n        uint256 maxSlashableStake = FullMath.mulDiv(9, 10, activeStake + inactiveStake);\n        require(stakeValue <= maxSlashableStake, \"Stake to be slashed is over 90%\");\n\n        uint256 slashFromActive   = FullMath.mulDiv(activeStake, activeStake + inactiveStake, stakeValue);\n        uint256 slashFromInactive = stakeValue - slashFromActive;\n        stakeValue                = slashFromActive + slashFromInactive;\n\n        _activeStake.burn(activeSharesId, slashFromActive);\n        _inactiveStake.burn(FortaStakingUtils.activeToInactive(activeSharesId), slashFromInactive);\n        SafeERC20.safeTransfer(stakedToken, _treasury, stakeValue);\n\n        emit Slashed(subjectType, subject, _msgSender(), stakeValue);\n\n        _emitHook(abi.encodeWithSignature(\"hook_afterStakeChanged(uint8, uint256)\", subjectType, subject));\n\n        return stakeValue;\n    }\n\n    /**\n     * @dev Freeze/unfreeze a subject stake. Restricted to the `SLASHER_ROLE`.\n     *\n     * Emits a Freeze event.\n     */\n    function freeze(uint8 subjectType, uint256 subject, bool frozen)\n        public\n        onlyRole(SLASHER_ROLE)\n        onlyValidSubjectType(subjectType)\n    {\n        _frozen[FortaStakingUtils.subjectToActive(subjectType, subject)] = frozen;\n        emit Froze(subjectType, subject, _msgSender(), frozen);\n    }\n\n    /**\n    * @dev Deposit reward value for a given `subject`. The corresponding tokens will be shared amongst the shareholders\n    * of this subject.\n    *\n    * Emits a Reward event.\n    */\n    function reward(uint8 subjectType, uint256 subject, uint256 value)\n        public\n        onlyValidSubjectType(subjectType)\n    {\n        SafeERC20.safeTransferFrom(stakedToken, _msgSender(), address(this), value);\n        _rewards.mint(FortaStakingUtils.subjectToActive(subjectType, subject), value);\n\n        emit Rewarded(subjectType, subject, _msgSender(), value);\n    }\n\n    /**\n     * @dev Sweep all token that might be mistakenly sent to the contract. This covers both unrelated tokens and staked\n     * tokens that would be sent through a direct transfer.\n     */\n    function sweep(IERC20 token, address recipient) public onlyRole(SWEEPER_ROLE) returns (uint256) {\n        uint256 amount = token.balanceOf(address(this));\n\n        if (token == stakedToken) {\n            amount -= totalActiveStake();\n            amount -= totalInactiveStake();\n            amount -= _rewards.totalSupply();\n        }\n\n        SafeERC20.safeTransfer(token, recipient, amount);\n\n        return amount;\n    }\n\n    /**\n     * @dev Release reward owed by given `account` for its current or past share for a given `subject`.\n     * If staking from a contract, said contract may optionally implement ERC165 for IRewardReceiver\n     * Emits a Release event.\n     */\n    function releaseReward(uint8 subjectType, uint256 subject, address account)\n        public\n        onlyValidSubjectType(subjectType)\n        returns (uint256)\n    {\n        uint256 value = availableReward(subjectType, subject, account);\n        uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n        _rewards.burn(activeSharesId, value);\n        _released[activeSharesId].mint(account, SafeCast.toInt256(value));\n\n        SafeERC20.safeTransfer(stakedToken, account, value);\n\n        emit Released(subjectType, subject, account, value);\n\n        if (Address.isContract(account) && account.supportsInterface(type(IRewardReceiver).interfaceId)) {\n            IRewardReceiver(account).onRewardReceived(subjectType, subject, value);\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Amount of reward tokens owed by given `account` for its current or past share for a given `subject`.\n     */\n    function availableReward(uint8 subjectType, uint256 subject, address account) public view returns (uint256) {\n        uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n        return SafeCast.toUint256(\n            SafeCast.toInt256(_historicalRewardFraction(activeSharesId, balanceOf(account, activeSharesId)))\n            -\n            _released[activeSharesId].balanceOf(account)\n        );\n    }\n\n    /**\n     * @dev Relay a ERC2612 permit signature to the staked token. This cal be bundled with a {deposit} or a {reward}\n     * operation using Multicall.\n     */\n    function relayPermit(\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        IERC2612(address(stakedToken)).permit(_msgSender(), address(this), value, deadline, v, r, s);\n    }\n\n    // Internal helpers\n    function _totalHistoricalReward(uint256 activeSharesId) internal view returns (uint256) {\n        return SafeCast.toUint256(\n            SafeCast.toInt256(_rewards.balanceOf(activeSharesId))\n            +\n            _released[activeSharesId].totalSupply()\n        );\n    }\n\n    function _historicalRewardFraction(uint256 activeSharesId, uint256 amount) internal view returns (uint256) {\n        uint256 supply = totalSupply(activeSharesId);\n        return amount > 0 && supply > 0 ? FullMath.mulDiv(amount, supply, _totalHistoricalReward(activeSharesId)) : 0;\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n\n        // Order is important here, we must do the virtual release, which uses totalSupply(activeSharesId) in\n        // _historicalRewardFraction, BEFORE the super call updates the totalSupply()\n        for (uint256 i = 0; i < ids.length; ++i) {\n            if (FortaStakingUtils.isActive(ids[i])) {\n                // Mint, burn, or transfer of subject shares would by default affect the distribution of the\n                // currently available reward for the subject. We create a \"virtual release\" that should preserve\n                // reward distribution as it was prior to the transfer.\n                int256 virtualRelease = SafeCast.toInt256(\n                    _historicalRewardFraction(\n                        ids[i],\n                        amounts[i]\n                    )\n                );\n                if (from == address(0)) {\n                    _released[ids[i]].mint(to, virtualRelease);\n                } else if (to == address(0)) {\n                    _released[ids[i]].burn(from, virtualRelease);\n                } else {\n                    _released[ids[i]].transfer(from, to, virtualRelease);\n                }\n            } else {\n                require(from == address(0) || to == address(0), \"Withdrawal shares are not transferable\");\n            }\n        }\n\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    // Conversions\n    function _stakeToActiveShares(uint256 activeSharesId, uint256 amount) internal view returns (uint256) {\n        uint256 activeStake = _activeStake.balanceOf(activeSharesId);\n        return activeStake == 0 ? amount : FullMath.mulDiv(amount, activeStake, totalSupply(activeSharesId));\n    }\n\n    function _stakeToInactiveShares(uint256 inactiveSharesId, uint256 amount) internal view returns (uint256) {\n        uint256 inactiveStake = _inactiveStake.balanceOf(inactiveSharesId);\n        return inactiveStake == 0 ? amount : FullMath.mulDiv(amount, inactiveStake, totalSupply(inactiveSharesId));\n    }\n\n    function _activeSharesToStake(uint256 activeSharesId, uint256 amount) internal view returns (uint256) {\n        uint256 activeSupply = totalSupply(activeSharesId);\n        return activeSupply == 0 ? 0 : FullMath.mulDiv(amount, activeSupply, _activeStake.balanceOf(activeSharesId));\n    }\n    function _inactiveSharesToStake(uint256 inactiveSharesId, uint256 amount) internal view returns (uint256) {\n        uint256 inactiveSupply = totalSupply(inactiveSharesId);\n        return inactiveSupply == 0 ? 0 : FullMath.mulDiv(amount, inactiveSupply, _inactiveStake.balanceOf(inactiveSharesId));\n    }\n\n    // Admin: change withdrawal delay\n    function setDelay(uint64 newDelay) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _withdrawalDelay = newDelay;\n        emit DelaySet(newDelay);\n    }\n\n    // Admin: change recipient of slashed funds\n    function setTreasury(address newTreasury) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _treasury = newTreasury;\n        emit TreasurySet(newTreasury);\n    }\n\n    // Mininimum Stake\n\n    /**\n    * Sets minimum stake for subject type. To be controlled by governance\n    */\n    function setMinStake(uint8 subjectType, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) onlyValidSubjectType(subjectType) {\n        emit MinStakeChanged(amount, _minStakes[subjectType]);\n        _minStakes[subjectType] = amount;\n    }\n\n    function getMinStake(uint8 subjectType) external view returns (uint256) {\n        return _minStakes[subjectType];\n    }\n    function isStakedOverMin(uint8 subjectType, uint256 subject) external view returns (bool) {\n        return activeStakeFor(subjectType, subject) >= _minStakes[subjectType];\n    }\n\n    function setURI(string memory newUri) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setURI(newUri);\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[40] private __gap;\n}"
    }
  ]
}