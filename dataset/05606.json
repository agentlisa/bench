{
  "Title": "[M-01] When a batch of withdrawals expires, that batch is often underpaid their owed interest",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketBase.sol#L361-L376><br>\n<https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketBase.sol#L466-L492>\n\n### Impact\n\nUntil the exact timestamp that a payment is processed for a given withdrawal batch (`batch.scaledAmountBurned` incremented, `batch.normalizedAmountPaid` incremented), the underlying amount of that batch should continue to be earning interest. It's only when the payment is actually made that the underlying amount of the batch should stop earning interest - at this point users in that batch are actually able to withdraw funds. This is clear with the general flow of logic of how `_applyWithdrawalBatchPayment` is being called.\n\nThis flow is not being followed when a batch of withdrawals first expires. Instead of getting paid interest up until the current `block.timestamp`, they are only paid interest up to the timestamp of the expiry. This means, (assuming theres enough assets currently in the market to pay off that batch of withdrawals) users in that batch are unfairly losing out on (`block.timestamp` - expiry) the duration of interest. As this duration increases, those lenders are losing increasing amounts of interest.\n\n### Proof of Concept\n\nThe logic for handling a withdrawal batch when it first expires occurs in the `WildcatMarketBase:_getUpdatedState` function, which is defined as follows:\n\n```solidity\nfunction _getUpdatedState() internal returns (MarketState memory state) {\n  state = _state;\n  // Handle expired withdrawal batch\n  if (state.hasPendingExpiredBatch()) {\n    uint256 expiry = state.pendingWithdrawalExpiry;\n    // Only accrue interest if time has passed since last update.\n    // This will only be false if withdrawalBatchDuration is 0.\n    if (expiry != state.lastInterestAccruedTimestamp) {\n      (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n        .updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          expiry // @issue\n        );\n      emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n    }\n    _processExpiredWithdrawalBatch(state);\n  }\n  ...\n}\n```\n\nEffectively, the market parameters related to the accrued interest owed to lenders (most important of which is `state.scaleFactor`) is updated in the `state.updateScaleFactorAndFees(..)` call, which we can see updates the interest up to the `expiry` timestamp. Let's consider a scenario where `state.lastInterestAccruedTimestamp` = N, `expiry`= N, and `block.timestamp`= N+`86_400` (one day). At this point in time, all lenders in this market (including lenders in this expiring withdrawal batch) are owed interest for N+`86_400`-N = `86_400`, which is the duration from the current `block.timestamp` to the previous timestamp that interest was accrued.\n\nConsidering this, in the above function call, `(expiry != state.lastInterestAccruedTimestamp)`= False and so it is skipped. However, even if `expiry` = N+1 for example, and it is not skipped, there is still a fundamental issue. For simplicity, I'm just assuming `expiry` = N. Next, `_processExpiredWithdrawalBatch` is called, which is defined as follows:\n\n```solidity\nfunction _processExpiredWithdrawalBatch(MarketState memory state) internal {\n  uint32 expiry = state.pendingWithdrawalExpiry;\n  WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n  // Burn as much of the withdrawal batch as possible with available liquidity.\n  uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n  if (availableLiquidity > 0) {\n    _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n  }\n  ...\n}\n```\n\nHere, let's assume that the borrower has left enough assets in the Market so that the entire withdrawal batch which just expired can be paid out in full. This logic is implemented in the `_applyWithdrawalBatchPayment` function, which is defined as follows:\n\n```solidity\nfunction _applyWithdrawalBatchPayment(\n  WithdrawalBatch memory batch,\n  MarketState memory state,\n  uint32 expiry,\n  uint256 availableLiquidity\n) internal {\n  uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).toUint104();\n  uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n  // Do nothing if batch is already paid\n  if (scaledAmountOwed == 0) {\n    return;\n  }\n  uint104 scaledAmountBurned = uint104(MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed));\n  uint128 normalizedAmountPaid = state.normalizeAmount(scaledAmountBurned).toUint128();\n\n  batch.scaledAmountBurned += scaledAmountBurned;\n  batch.normalizedAmountPaid += normalizedAmountPaid;\n  state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n  // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n  state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n  ...\n}\n```\n\nThe important thing to note here is that the `normalizedAmountPaid` is based on referencing the current `state.scaleFactor`. However, this `state.scaleFactor` does not include the `86_400` seconds of interest which is actually owed to the lenders in this withdrawal batch. Rather, they are being cheated out of this interest entirely.\n\n### Recommended Mitigation Steps\n\nIt is not logical that the most recent expired batch only get paid interest up to the expiry. Instead, they should be getting the full amount of interest up to the amount of time they are paid. The `WildcatMarketBase:_getUpdatedState` function should be changed accordingly:\n\n```solidity\nfunction _getUpdatedState() internal returns (MarketState memory state) {\n  state = _state;\n\n  if (block.timestamp != state.lastInterestAccruedTimestamp) {\n    (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n      .updateScaleFactorAndFees(\n        protocolFeeBips,\n        delinquencyFeeBips,\n        delinquencyGracePeriod,\n        block.timestamp\n      );\n    emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n  }\n\n  // Handle expired withdrawal batch\n  if (state.hasPendingExpiredBatch()) {\n    _processExpiredWithdrawalBatch(state);\n  }\n}\n```\n\n**[d1ll0n (Wildcat) acknowledged](https://github.com/code-423n4/2023-10-wildcat-findings/issues/644#issuecomment-1794598752)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/market/WildcatMarketBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport '../libraries/Withdrawal.sol';\nimport { queryName, querySymbol } from '../libraries/StringQuery.sol';\nimport '../interfaces/IMarketEventsAndErrors.sol';\nimport '../interfaces/IWildcatMarketController.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport { IERC20, IERC20Metadata } from '../interfaces/IERC20Metadata.sol';\nimport '../ReentrancyGuard.sol';\nimport '../libraries/BoolUtils.sol';\n\ncontract WildcatMarketBase is ReentrancyGuard, IMarketEventsAndErrors {\n  using WithdrawalLib for MarketState;\n  using SafeCastLib for uint256;\n  using MathUtils for uint256;\n  using BoolUtils for bool;\n\n  // ==================================================================== //\n  //                       Market Config (immutable)                       //\n  // ==================================================================== //\n\n  string public constant version = '1.0';\n\n  /// @dev Account with blacklist control, used for blocking sanctioned addresses.\n  address public immutable sentinel;\n\n  /// @dev Account with authority to borrow assets from the market.\n  address public immutable borrower;\n\n  /// @dev Account that receives protocol fees.\n  address public immutable feeRecipient;\n\n  /// @dev Protocol fee added to interest paid by borrower.\n  uint256 public immutable protocolFeeBips;\n\n  /// @dev Penalty fee added to interest earned by lenders, does not affect protocol fee.\n  uint256 public immutable delinquencyFeeBips;\n\n  /// @dev Time after which delinquency incurs penalty fee.\n  uint256 public immutable delinquencyGracePeriod;\n\n  /// @dev Address of the Market Controller.\n  address public immutable controller;\n\n  /// @dev Address of the underlying asset.\n  address public immutable asset;\n\n  /// @dev Time before withdrawal batches are processed.\n  uint256 public immutable withdrawalBatchDuration;\n\n  /// @dev Token decimals (same as underlying asset).\n  uint8 public immutable decimals;\n\n  /// @dev Token name (prefixed name of underlying asset).\n  string public name;\n\n  /// @dev Token symbol (prefixed symbol of underlying asset).\n  string public symbol;\n\n  // ===================================================================== //\n  //                             Market State                               //\n  // ===================================================================== //\n\n  MarketState internal _state;\n\n  mapping(address => Account) internal _accounts;\n\n  WithdrawalData internal _withdrawalData;\n\n  // ===================================================================== //\n  //                             Constructor                               //\n  // ===================================================================== //\n\n  constructor() {\n    MarketParameters memory parameters = IWildcatMarketController(msg.sender).getMarketParameters();\n\n    if ((parameters.protocolFeeBips > 0).and(parameters.feeRecipient == address(0))) {\n      revert FeeSetWithoutRecipient();\n    }\n    if (parameters.annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n    if (parameters.reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n    if (parameters.protocolFeeBips > BIP) {\n      revert InterestFeeTooHigh();\n    }\n    if (parameters.delinquencyFeeBips > BIP) {\n      revert PenaltyFeeTooHigh();\n    }\n\n    // Set asset metadata\n    asset = parameters.asset;\n    name = string.concat(parameters.namePrefix, queryName(parameters.asset));\n    symbol = string.concat(parameters.symbolPrefix, querySymbol(parameters.asset));\n    decimals = IERC20Metadata(parameters.asset).decimals();\n\n    _state = MarketState({\n      isClosed: false,\n      maxTotalSupply: parameters.maxTotalSupply,\n      accruedProtocolFees: 0,\n      normalizedUnclaimedWithdrawals: 0,\n      scaledTotalSupply: 0,\n      scaledPendingWithdrawals: 0,\n      pendingWithdrawalExpiry: 0,\n      isDelinquent: false,\n      timeDelinquent: 0,\n      annualInterestBips: parameters.annualInterestBips,\n      reserveRatioBips: parameters.reserveRatioBips,\n      scaleFactor: uint112(RAY),\n      lastInterestAccruedTimestamp: uint32(block.timestamp)\n    });\n\n    sentinel = parameters.sentinel;\n    borrower = parameters.borrower;\n    controller = parameters.controller;\n    feeRecipient = parameters.feeRecipient;\n    protocolFeeBips = parameters.protocolFeeBips;\n    delinquencyFeeBips = parameters.delinquencyFeeBips;\n    delinquencyGracePeriod = parameters.delinquencyGracePeriod;\n    withdrawalBatchDuration = parameters.withdrawalBatchDuration;\n  }\n\n  // ===================================================================== //\n  //                              Modifiers                                //\n  // ===================================================================== //\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) revert NotApprovedBorrower();\n    _;\n  }\n\n  modifier onlyController() {\n    if (msg.sender != controller) revert NotController();\n    _;\n  }\n\n  // ===================================================================== //\n  //                       Internal State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Retrieve an account from storage.\n   *\n   *      Reverts if account is blocked.\n   */\n  function _getAccount(address accountAddress) internal view returns (Account memory account) {\n    account = _accounts[accountAddress];\n    if (account.approval == AuthRole.Blocked) {\n      revert AccountBlacklisted();\n    }\n  }\n\n  /**\n   * @dev Block an account and transfer its balance of market tokens\n   *      to an escrow contract.\n   *\n   *      If the account is already blocked, this function does nothing.\n   */\n  function _blockAccount(MarketState memory state, address accountAddress) internal {\n    Account memory account = _accounts[accountAddress];\n    if (account.approval != AuthRole.Blocked) {\n      uint104 scaledBalance = account.scaledBalance;\n      account.approval = AuthRole.Blocked;\n      emit AuthorizationStatusUpdated(accountAddress, AuthRole.Blocked);\n\n      if (scaledBalance > 0) {\n        account.scaledBalance = 0;\n        address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n          accountAddress,\n          borrower,\n          address(this)\n        );\n        emit Transfer(accountAddress, escrow, state.normalizeAmount(scaledBalance));\n        _accounts[escrow].scaledBalance += scaledBalance;\n        emit SanctionedAccountAssetsSentToEscrow(\n          accountAddress,\n          escrow,\n          state.normalizeAmount(scaledBalance)\n        );\n      }\n      _accounts[accountAddress] = account;\n    }\n  }\n\n  /**\n   * @dev Retrieve an account from storage and assert that it has at\n   *      least the required role.\n   *\n   *      If the account's role is not set, queries the controller to\n   *      determine if it is an approved lender; if it is, its role\n   *      is initialized to DepositAndWithdraw.\n   */\n  function _getAccountWithRole(\n    address accountAddress,\n    AuthRole requiredRole\n  ) internal returns (Account memory account) {\n    account = _getAccount(accountAddress);\n    // If account role is null, see if it is authorized on controller.\n    if (account.approval == AuthRole.Null) {\n      if (IWildcatMarketController(controller).isAuthorizedLender(accountAddress)) {\n        account.approval = AuthRole.DepositAndWithdraw;\n        emit AuthorizationStatusUpdated(accountAddress, AuthRole.DepositAndWithdraw);\n      }\n    }\n    // If account role is insufficient, revert.\n    if (uint256(account.approval) < uint256(requiredRole)) {\n      revert NotApprovedLender();\n    }\n  }\n\n  // ===================================================================== //\n  //                       External State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is obligated\n   *      to maintain in the market to avoid delinquency.\n   */\n  function coverageLiquidity() external view nonReentrantView returns (uint256) {\n    return currentState().liquidityRequired();\n  }\n\n  /**\n   * @dev Returns the scale factor (in ray) used to convert scaled balances\n   *      to normalized balances.\n   */\n  function scaleFactor() external view nonReentrantView returns (uint256) {\n    return currentState().scaleFactor;\n  }\n\n  /**\n   * @dev Total balance in underlying asset.\n   */\n  function totalAssets() public view returns (uint256) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is allowed\n   *      to borrow.\n   *\n   *      This is the balance of underlying assets minus:\n   *      - pending (unpaid) withdrawals\n   *      - paid withdrawals\n   *      - reserve ratio times the portion of the supply not pending withdrawal\n   *      - protocol fees\n   */\n  function borrowableAssets() external view nonReentrantView returns (uint256) {\n    return currentState().borrowableAssets(totalAssets());\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees (in underlying asset amount)\n   *      that have accrued and are pending withdrawal.\n   */\n  function accruedProtocolFees() external view nonReentrantView returns (uint256) {\n    return currentState().accruedProtocolFees;\n  }\n\n  /**\n   * @dev Returns the state of the market as of the last update.\n   */\n  function previousState() external view returns (MarketState memory) {\n    return _state;\n  }\n\n  /**\n   * @dev Return the state the market would have at the current block after applying\n   *      interest and fees accrued since the last update and processing the pending\n   *      withdrawal batch if it is expired.\n   */\n  function currentState() public view nonReentrantView returns (MarketState memory state) {\n    (state, , ) = _calculateCurrentState();\n  }\n\n  /**\n   * @dev Returns the scaled total supply the vaut would have at the current block\n   *      after applying interest and fees accrued since the last update and burning\n   *      market tokens for the pending withdrawal batch if it is expired.\n   */\n  function scaledTotalSupply() external view nonReentrantView returns (uint256) {\n    return currentState().scaledTotalSupply;\n  }\n\n  /**\n   * @dev Returns the scaled balance of `account`\n   */\n  function scaledBalanceOf(address account) external view nonReentrantView returns (uint256) {\n    return _accounts[account].scaledBalance;\n  }\n\n  /**\n   * @dev Returns current role of `account`.\n   */\n  function getAccountRole(address account) external view nonReentrantView returns (AuthRole) {\n    return _accounts[account].approval;\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees that are currently\n   *      withdrawable by the fee recipient.\n   */\n  function withdrawableProtocolFees() external view returns (uint128) {\n    return currentState().withdrawableProtocolFees(totalAssets());\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently paid by borrower.\n   *      Borrower pays base APR, protocol fee (on base APR) and delinquency\n   *      fee (if delinquent beyond grace period).\n   *\n   * @return apr paid by borrower in ray\n   */\n  function effectiveBorrowerAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    // apr + (apr * protocolFee)\n    uint256 apr = MathUtils.bipToRay(state.annualInterestBips).bipMul(BIP + protocolFeeBips);\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += MathUtils.bipToRay(delinquencyFeeBips);\n    }\n    return apr;\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently earned by lenders.\n   *     Lenders earn base APR and delinquency fee (if delinquent beyond grace period)\n   *\n   * @return apr earned by lender in ray\n   */\n  function effectiveLenderAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    uint256 apr = state.annualInterestBips;\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += delinquencyFeeBips;\n    }\n    return MathUtils.bipToRay(apr);\n  }\n\n  // /*//////////////////////////////////////////////////////////////\n  //                     Internal State Handlers\n  // //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @dev Returns cached MarketState after accruing interest and delinquency / protocol fees\n   *      and processing expired withdrawal batch, if any.\n   *\n   *      Used by functions that make additional changes to `state`.\n   *\n   *      NOTE: Returned `state` does not match `_state` if interest is accrued\n   *            Calling function must update `_state` or revert.\n   *\n   * @return state Market state after interest is accrued.\n   */\n  function _getUpdatedState() internal returns (MarketState memory state) {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      uint256 expiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      if (expiry != state.lastInterestAccruedTimestamp) {\n        (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n          .updateScaleFactorAndFees(\n            protocolFeeBips,\n            delinquencyFeeBips,\n            delinquencyGracePeriod,\n            expiry\n          );\n        emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n      }\n      _processExpiredWithdrawalBatch(state);\n    }\n    // Apply interest and fees accrued since last update (expiry or previous tx)\n    if (block.timestamp != state.lastInterestAccruedTimestamp) {\n      (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n        .updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          block.timestamp\n        );\n      emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n    }\n  }\n\n  /**\n   * @dev Calculate the current state, applying fees and interest accrued since\n   *      the last state update as well as the effects of withdrawal batch expiry\n   *      on the market state.\n   *      Identical to _getUpdatedState() except it does not modify storage or\n   *      or emit events.\n   *      Returns expired batch data, if any, so queries against batches have\n   *      access to the most recent data.\n   */\n  function _calculateCurrentState()\n    internal\n    view\n    returns (\n      MarketState memory state,\n      uint32 expiredBatchExpiry,\n      WithdrawalBatch memory expiredBatch\n    )\n  {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      expiredBatchExpiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      if (expiredBatchExpiry != state.lastInterestAccruedTimestamp) {\n        state.updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          expiredBatchExpiry\n        );\n      }\n\n      expiredBatch = _withdrawalData.batches[expiredBatchExpiry];\n      uint256 availableLiquidity = expiredBatch.availableLiquidityForPendingBatch(\n        state,\n        totalAssets()\n      );\n      if (availableLiquidity > 0) {\n        _applyWithdrawalBatchPaymentView(expiredBatch, state, availableLiquidity);\n      }\n      state.pendingWithdrawalExpiry = 0;\n    }\n\n    if (state.lastInterestAccruedTimestamp != block.timestamp) {\n      state.updateScaleFactorAndFees(\n        protocolFeeBips,\n        delinquencyFeeBips,\n        delinquencyGracePeriod,\n        block.timestamp\n      );\n    }\n  }\n\n  /**\n   * @dev Writes the cached MarketState to storage and emits an event.\n   *      Used at the end of all functions which modify `state`.\n   */\n  function _writeState(MarketState memory state) internal {\n    bool isDelinquent = state.liquidityRequired() > totalAssets();\n    state.isDelinquent = isDelinquent;\n    _state = state;\n    emit StateUpdated(state.scaleFactor, isDelinquent);\n  }\n\n  /**\n   * @dev Handles an expired withdrawal batch:\n   *      - Retrieves the amount of underlying assets that can be used to pay for the batch.\n   *      - If the amount is sufficient to pay the full amount owed to the batch, the batch\n   *        is closed and the total withdrawal amount is reserved.\n   *      - If the amount is insufficient to pay the full amount owed to the batch, the batch\n   *        is recorded as an unpaid batch and the available assets are reserved.\n   *      - The assets reserved for the batch are scaled by the current scale factor and that\n   *        amount of scaled tokens is burned, ensuring borrowers do not continue paying interest\n   *        on withdrawn assets.\n   */\n  function _processExpiredWithdrawalBatch(MarketState memory state) internal {\n    uint32 expiry = state.pendingWithdrawalExpiry;\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Burn as much of the withdrawal batch as possible with available liquidity.\n    uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n    if (availableLiquidity > 0) {\n      _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n    }\n\n    emit WithdrawalBatchExpired(\n      expiry,\n      batch.scaledTotalAmount,\n      batch.scaledAmountBurned,\n      batch.normalizedAmountPaid\n    );\n\n    if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n      _withdrawalData.unpaidBatches.push(expiry);\n    } else {\n      emit WithdrawalBatchClosed(expiry);\n    }\n\n    state.pendingWithdrawalExpiry = 0;\n\n    _withdrawalData.batches[expiry] = batch;\n  }\n\n  /**\n   * @dev Process withdrawal payment, burning market tokens and reserving\n   *      underlying assets so they are only available for withdrawals.\n   */\n  function _applyWithdrawalBatchPayment(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint32 expiry,\n    uint256 availableLiquidity\n  ) internal {\n    uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).toUint104();\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) {\n      return;\n    }\n    uint104 scaledAmountBurned = uint104(MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed));\n    uint128 normalizedAmountPaid = state.normalizeAmount(scaledAmountBurned).toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n\n    // Emit transfer for external trackers to indicate burn.\n    emit Transfer(address(this), address(0), normalizedAmountPaid);\n    emit WithdrawalBatchPayment(expiry, scaledAmountBurned, normalizedAmountPaid);\n  }\n\n  function _applyWithdrawalBatchPaymentView(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint256 availableLiquidity\n  ) internal pure {\n    uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).toUint104();\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) {\n      return;\n    }\n    uint104 scaledAmountBurned = uint104(MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed));\n    uint128 normalizedAmountPaid = state.normalizeAmount(scaledAmountBurned).toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarketBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport '../libraries/Withdrawal.sol';\nimport { queryName, querySymbol } from '../libraries/StringQuery.sol';\nimport '../interfaces/IMarketEventsAndErrors.sol';\nimport '../interfaces/IWildcatMarketController.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport { IERC20, IERC20Metadata } from '../interfaces/IERC20Metadata.sol';\nimport '../ReentrancyGuard.sol';\nimport '../libraries/BoolUtils.sol';\n\ncontract WildcatMarketBase is ReentrancyGuard, IMarketEventsAndErrors {\n  using WithdrawalLib for MarketState;\n  using SafeCastLib for uint256;\n  using MathUtils for uint256;\n  using BoolUtils for bool;\n\n  // ==================================================================== //\n  //                       Market Config (immutable)                       //\n  // ==================================================================== //\n\n  string public constant version = '1.0';\n\n  /// @dev Account with blacklist control, used for blocking sanctioned addresses.\n  address public immutable sentinel;\n\n  /// @dev Account with authority to borrow assets from the market.\n  address public immutable borrower;\n\n  /// @dev Account that receives protocol fees.\n  address public immutable feeRecipient;\n\n  /// @dev Protocol fee added to interest paid by borrower.\n  uint256 public immutable protocolFeeBips;\n\n  /// @dev Penalty fee added to interest earned by lenders, does not affect protocol fee.\n  uint256 public immutable delinquencyFeeBips;\n\n  /// @dev Time after which delinquency incurs penalty fee.\n  uint256 public immutable delinquencyGracePeriod;\n\n  /// @dev Address of the Market Controller.\n  address public immutable controller;\n\n  /// @dev Address of the underlying asset.\n  address public immutable asset;\n\n  /// @dev Time before withdrawal batches are processed.\n  uint256 public immutable withdrawalBatchDuration;\n\n  /// @dev Token decimals (same as underlying asset).\n  uint8 public immutable decimals;\n\n  /// @dev Token name (prefixed name of underlying asset).\n  string public name;\n\n  /// @dev Token symbol (prefixed symbol of underlying asset).\n  string public symbol;\n\n  // ===================================================================== //\n  //                             Market State                               //\n  // ===================================================================== //\n\n  MarketState internal _state;\n\n  mapping(address => Account) internal _accounts;\n\n  WithdrawalData internal _withdrawalData;\n\n  // ===================================================================== //\n  //                             Constructor                               //\n  // ===================================================================== //\n\n  constructor() {\n    MarketParameters memory parameters = IWildcatMarketController(msg.sender).getMarketParameters();\n\n    if ((parameters.protocolFeeBips > 0).and(parameters.feeRecipient == address(0))) {\n      revert FeeSetWithoutRecipient();\n    }\n    if (parameters.annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n    if (parameters.reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n    if (parameters.protocolFeeBips > BIP) {\n      revert InterestFeeTooHigh();\n    }\n    if (parameters.delinquencyFeeBips > BIP) {\n      revert PenaltyFeeTooHigh();\n    }\n\n    // Set asset metadata\n    asset = parameters.asset;\n    name = string.concat(parameters.namePrefix, queryName(parameters.asset));\n    symbol = string.concat(parameters.symbolPrefix, querySymbol(parameters.asset));\n    decimals = IERC20Metadata(parameters.asset).decimals();\n\n    _state = MarketState({\n      isClosed: false,\n      maxTotalSupply: parameters.maxTotalSupply,\n      accruedProtocolFees: 0,\n      normalizedUnclaimedWithdrawals: 0,\n      scaledTotalSupply: 0,\n      scaledPendingWithdrawals: 0,\n      pendingWithdrawalExpiry: 0,\n      isDelinquent: false,\n      timeDelinquent: 0,\n      annualInterestBips: parameters.annualInterestBips,\n      reserveRatioBips: parameters.reserveRatioBips,\n      scaleFactor: uint112(RAY),\n      lastInterestAccruedTimestamp: uint32(block.timestamp)\n    });\n\n    sentinel = parameters.sentinel;\n    borrower = parameters.borrower;\n    controller = parameters.controller;\n    feeRecipient = parameters.feeRecipient;\n    protocolFeeBips = parameters.protocolFeeBips;\n    delinquencyFeeBips = parameters.delinquencyFeeBips;\n    delinquencyGracePeriod = parameters.delinquencyGracePeriod;\n    withdrawalBatchDuration = parameters.withdrawalBatchDuration;\n  }\n\n  // ===================================================================== //\n  //                              Modifiers                                //\n  // ===================================================================== //\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) revert NotApprovedBorrower();\n    _;\n  }\n\n  modifier onlyController() {\n    if (msg.sender != controller) revert NotController();\n    _;\n  }\n\n  // ===================================================================== //\n  //                       Internal State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Retrieve an account from storage.\n   *\n   *      Reverts if account is blocked.\n   */\n  function _getAccount(address accountAddress) internal view returns (Account memory account) {\n    account = _accounts[accountAddress];\n    if (account.approval == AuthRole.Blocked) {\n      revert AccountBlacklisted();\n    }\n  }\n\n  /**\n   * @dev Block an account and transfer its balance of market tokens\n   *      to an escrow contract.\n   *\n   *      If the account is already blocked, this function does nothing.\n   */\n  function _blockAccount(MarketState memory state, address accountAddress) internal {\n    Account memory account = _accounts[accountAddress];\n    if (account.approval != AuthRole.Blocked) {\n      uint104 scaledBalance = account.scaledBalance;\n      account.approval = AuthRole.Blocked;\n      emit AuthorizationStatusUpdated(accountAddress, AuthRole.Blocked);\n\n      if (scaledBalance > 0) {\n        account.scaledBalance = 0;\n        address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n          accountAddress,\n          borrower,\n          address(this)\n        );\n        emit Transfer(accountAddress, escrow, state.normalizeAmount(scaledBalance));\n        _accounts[escrow].scaledBalance += scaledBalance;\n        emit SanctionedAccountAssetsSentToEscrow(\n          accountAddress,\n          escrow,\n          state.normalizeAmount(scaledBalance)\n        );\n      }\n      _accounts[accountAddress] = account;\n    }\n  }\n\n  /**\n   * @dev Retrieve an account from storage and assert that it has at\n   *      least the required role.\n   *\n   *      If the account's role is not set, queries the controller to\n   *      determine if it is an approved lender; if it is, its role\n   *      is initialized to DepositAndWithdraw.\n   */\n  function _getAccountWithRole(\n    address accountAddress,\n    AuthRole requiredRole\n  ) internal returns (Account memory account) {\n    account = _getAccount(accountAddress);\n    // If account role is null, see if it is authorized on controller.\n    if (account.approval == AuthRole.Null) {\n      if (IWildcatMarketController(controller).isAuthorizedLender(accountAddress)) {\n        account.approval = AuthRole.DepositAndWithdraw;\n        emit AuthorizationStatusUpdated(accountAddress, AuthRole.DepositAndWithdraw);\n      }\n    }\n    // If account role is insufficient, revert.\n    if (uint256(account.approval) < uint256(requiredRole)) {\n      revert NotApprovedLender();\n    }\n  }\n\n  // ===================================================================== //\n  //                       External State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is obligated\n   *      to maintain in the market to avoid delinquency.\n   */\n  function coverageLiquidity() external view nonReentrantView returns (uint256) {\n    return currentState().liquidityRequired();\n  }\n\n  /**\n   * @dev Returns the scale factor (in ray) used to convert scaled balances\n   *      to normalized balances.\n   */\n  function scaleFactor() external view nonReentrantView returns (uint256) {\n    return currentState().scaleFactor;\n  }\n\n  /**\n   * @dev Total balance in underlying asset.\n   */\n  function totalAssets() public view returns (uint256) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is allowed\n   *      to borrow.\n   *\n   *      This is the balance of underlying assets minus:\n   *      - pending (unpaid) withdrawals\n   *      - paid withdrawals\n   *      - reserve ratio times the portion of the supply not pending withdrawal\n   *      - protocol fees\n   */\n  function borrowableAssets() external view nonReentrantView returns (uint256) {\n    return currentState().borrowableAssets(totalAssets());\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees (in underlying asset amount)\n   *      that have accrued and are pending withdrawal.\n   */\n  function accruedProtocolFees() external view nonReentrantView returns (uint256) {\n    return currentState().accruedProtocolFees;\n  }\n\n  /**\n   * @dev Returns the state of the market as of the last update.\n   */\n  function previousState() external view returns (MarketState memory) {\n    return _state;\n  }\n\n  /**\n   * @dev Return the state the market would have at the current block after applying\n   *      interest and fees accrued since the last update and processing the pending\n   *      withdrawal batch if it is expired.\n   */\n  function currentState() public view nonReentrantView returns (MarketState memory state) {\n    (state, , ) = _calculateCurrentState();\n  }\n\n  /**\n   * @dev Returns the scaled total supply the vaut would have at the current block\n   *      after applying interest and fees accrued since the last update and burning\n   *      market tokens for the pending withdrawal batch if it is expired.\n   */\n  function scaledTotalSupply() external view nonReentrantView returns (uint256) {\n    return currentState().scaledTotalSupply;\n  }\n\n  /**\n   * @dev Returns the scaled balance of `account`\n   */\n  function scaledBalanceOf(address account) external view nonReentrantView returns (uint256) {\n    return _accounts[account].scaledBalance;\n  }\n\n  /**\n   * @dev Returns current role of `account`.\n   */\n  function getAccountRole(address account) external view nonReentrantView returns (AuthRole) {\n    return _accounts[account].approval;\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees that are currently\n   *      withdrawable by the fee recipient.\n   */\n  function withdrawableProtocolFees() external view returns (uint128) {\n    return currentState().withdrawableProtocolFees(totalAssets());\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently paid by borrower.\n   *      Borrower pays base APR, protocol fee (on base APR) and delinquency\n   *      fee (if delinquent beyond grace period).\n   *\n   * @return apr paid by borrower in ray\n   */\n  function effectiveBorrowerAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    // apr + (apr * protocolFee)\n    uint256 apr = MathUtils.bipToRay(state.annualInterestBips).bipMul(BIP + protocolFeeBips);\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += MathUtils.bipToRay(delinquencyFeeBips);\n    }\n    return apr;\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently earned by lenders.\n   *     Lenders earn base APR and delinquency fee (if delinquent beyond grace period)\n   *\n   * @return apr earned by lender in ray\n   */\n  function effectiveLenderAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    uint256 apr = state.annualInterestBips;\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += delinquencyFeeBips;\n    }\n    return MathUtils.bipToRay(apr);\n  }\n\n  // /*//"
    }
  ]
}