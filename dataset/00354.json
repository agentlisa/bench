{
  "Title": "RecordKeyChange Ignores ErrorNotFound",
  "Content": "When the `recordKeyChange` function in [`view.go`](https://github.com/ava-labs/avalanchego/blob/73c4c0ff9817cb13fdb8b205939596af0c416f1f/x/merkledb/view.go#L779) gets called with the boolean parameter `newNode` set to `false`, the function calls `v.getParentTrie().getEditableNode(key, hadValue)`. However, if there is an error of type `database.ErrNotFound`, the [error gets ignored](https://github.com/ava-labs/avalanchego/blob/73c4c0ff9817cb13fdb8b205939596af0c416f1f/x/merkledb/view.go#L797C35-L797C55).\n\n\nIf this edge case happens, the resulting `before` value from calling `v.getParentTrie().getEditableNode(key, hadValue)` would be `nil`, which [would be registered in the `v.changes.nodes` mapping](https://github.com/ava-labs/avalanchego/blob/73c4c0ff9817cb13fdb8b205939596af0c416f1f/x/merkledb/view.go#L801). This would be inconsistent as it should not be possible that there is no `before` if this is not a new node. So while in theory, this error should never happen as long as the caller of `recordKeyChange` is properly using the `newNode` parameter, the function should nonetheless fail in case the caller misuses it.\n\n\nConsider not ignoring the return error `database.ErrNotFound` and having the function return an error.\n\n\n***Update:** Resolved in [pull request #2743](https://github.com/ava-labs/avalanchego/pull/2743).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "x/merkledb/view.go",
      "content": "// Copyright (C) 2019-2024, Ava Labs, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\npackage merkledb\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"sync\"\n\n\t\"go.opentelemetry.io/otel/attribute\"\n\n\toteltrace \"go.opentelemetry.io/otel/trace\"\n\n\t\"golang.org/x/exp/slices\"\n\n\t\"github.com/ava-labs/avalanchego/database\"\n\t\"github.com/ava-labs/avalanchego/ids\"\n\t\"github.com/ava-labs/avalanchego/utils\"\n\t\"github.com/ava-labs/avalanchego/utils/maybe\"\n)\n\nconst (\n\tinitKeyValuesSize        = 256\n\tdefaultPreallocationSize = 100\n)\n\nvar (\n\t_ View = (*view)(nil)\n\n\tErrCommitted                  = errors.New(\"view has been committed\")\n\tErrInvalid                    = errors.New(\"the trie this view was based on has changed, rendering this view invalid\")\n\tErrPartialByteLengthWithValue = errors.New(\n\t\t\"the underlying db only supports whole number of byte keys, so cannot record changes with partial byte lengths\",\n\t)\n\tErrVisitPathToKey         = errors.New(\"failed to visit expected node during insertion\")\n\tErrStartAfterEnd          = errors.New(\"start key > end key\")\n\tErrNoChanges              = errors.New(\"no changes provided\")\n\tErrParentNotDatabase      = errors.New(\"parent trie is not database\")\n\tErrNodesAlreadyCalculated = errors.New(\"cannot modify the trie after the node changes have been calculated\")\n)\n\ntype view struct {\n\t// If true, this view has been committed.\n\t// [commitLock] must be held while accessing this field.\n\tcommitted  bool\n\tcommitLock sync.RWMutex\n\n\t// tracking bool to enforce that no changes are made to the trie after the nodes have been calculated\n\tnodesAlreadyCalculated utils.Atomic[bool]\n\n\t// calculateNodesOnce is a once to ensure that node calculation only occurs a single time\n\tcalculateNodesOnce sync.Once\n\n\t// Controls the view's validity related fields.\n\t// Must be held while reading/writing [childViews], [invalidated], and [parentTrie].\n\t// Only use to lock current view or descendants of the current view\n\t// DO NOT grab the [validityTrackingLock] of any ancestor trie while this is held.\n\tvalidityTrackingLock sync.RWMutex\n\n\t// If true, this view has been invalidated and can't be used.\n\t//\n\t// Invariant: This view is marked as invalid before any of its ancestors change.\n\t// Since we ensure that all subviews are marked invalid before making an invalidating change\n\t// then if we are still valid at the end of the function, then no corrupting changes could have\n\t// occurred during execution.\n\t// Namely, if we have a method with:\n\t//\n\t// *Code Accessing Ancestor State*\n\t//\n\t// if v.isInvalid() {\n\t//     return ErrInvalid\n\t//  }\n\t// return [result]\n\t//\n\t// If the invalidated check passes, then we're guaranteed that no ancestor changes occurred\n\t// during the code that accessed ancestor state and the result of that work is still valid\n\t//\n\t// [validityTrackingLock] must be held when reading/writing this field.\n\tinvalidated bool\n\n\t// the uncommitted parent trie of this view\n\t// [validityTrackingLock] must be held when reading/writing this field.\n\tparentTrie View\n\n\t// The valid children of this view.\n\t// [validityTrackingLock] must be held when reading/writing this field.\n\tchildViews []*view\n\n\t// Changes made to this view.\n\t// May include nodes that haven't been updated\n\t// but will when their ID is recalculated.\n\tchanges *changeSummary\n\n\tdb *merkleDB\n\n\t// The root of the trie represented by this view.\n\troot maybe.Maybe[*node]\n\n\ttokenSize int\n}\n\n// NewView returns a new view on top of this view where the passed changes\n// have been applied.\n// Adds the new view to [v.childViews].\n// Assumes [v.commitLock] isn't held.\nfunc (v *view) NewView(\n\tctx context.Context,\n\tchanges ViewChanges,\n) (View, error) {\n\tif v.isInvalid() {\n\t\treturn nil, ErrInvalid\n\t}\n\tv.commitLock.RLock()\n\tdefer v.commitLock.RUnlock()\n\n\tif v.committed {\n\t\treturn v.getParentTrie().NewView(ctx, changes)\n\t}\n\n\tif err := v.calculateNodeIDs(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tnewView, err := newView(v.db, v, changes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tv.validityTrackingLock.Lock()\n\tdefer v.validityTrackingLock.Unlock()\n\n\tif v.invalidated {\n\t\treturn nil, ErrInvalid\n\t}\n\tv.childViews = append(v.childViews, newView)\n\n\treturn newView, nil\n}\n\n// Creates a new view with the given [parentTrie].\nfunc newView(\n\tdb *merkleDB,\n\tparentTrie View,\n\tchanges ViewChanges,\n) (*view, error) {\n\tnewView := &view{\n\t\troot:       maybe.Bind(parentTrie.getRoot(), (*node).clone),\n\t\tdb:         db,\n\t\tparentTrie: parentTrie,\n\t\tchanges:    newChangeSummary(len(changes.BatchOps) + len(changes.MapOps)),\n\t\ttokenSize:  db.tokenSize,\n\t}\n\n\tfor _, op := range changes.BatchOps {\n\t\tkey := op.Key\n\t\tif !changes.ConsumeBytes {\n\t\t\tkey = slices.Clone(op.Key)\n\t\t}\n\n\t\tnewVal := maybe.Nothing[[]byte]()\n\t\tif !op.Delete {\n\t\t\tnewVal = maybe.Some(op.Value)\n\t\t\tif !changes.ConsumeBytes {\n\t\t\t\tnewVal = maybe.Some(slices.Clone(op.Value))\n\t\t\t}\n\t\t}\n\t\tif err := newView.recordValueChange(toKey(key), newVal); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tfor key, val := range changes.MapOps {\n\t\tif !changes.ConsumeBytes {\n\t\t\tval = maybe.Bind(val, slices.Clone[[]byte])\n\t\t}\n\t\tif err := newView.recordValueChange(toKey(stringToByteSlice(key)), val); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn newView, nil\n}\n\n// Creates a view of the db at a historical root using the provided [changes].\n// Returns ErrNoChanges if [changes] is empty.\nfunc newViewWithChanges(\n\tdb *merkleDB,\n\tchanges *changeSummary,\n) (*view, error) {\n\tif changes == nil {\n\t\treturn nil, ErrNoChanges\n\t}\n\n\tnewView := &view{\n\t\troot:       changes.rootChange.after,\n\t\tdb:         db,\n\t\tparentTrie: db,\n\t\tchanges:    changes,\n\t\ttokenSize:  db.tokenSize,\n\t}\n\t// since this is a set of historical changes, all nodes have already been calculated\n\t// since no new changes have occurred, no new calculations need to be done\n\tnewView.calculateNodesOnce.Do(func() {})\n\tnewView.nodesAlreadyCalculated.Set(true)\n\treturn newView, nil\n}\n\nfunc (v *view) getTokenSize() int {\n\treturn v.tokenSize\n}\n\nfunc (v *view) getRoot() maybe.Maybe[*node] {\n\treturn v.root\n}\n\n// Recalculates the node IDs for all changed nodes in the trie.\n// Cancelling [ctx] doesn't cancel calculation. It's used only for tracing.\nfunc (v *view) calculateNodeIDs(ctx context.Context) error {\n\tvar err error\n\tv.calculateNodesOnce.Do(func() {\n\t\tif v.isInvalid() {\n\t\t\terr = ErrInvalid\n\t\t\treturn\n\t\t}\n\t\tdefer v.nodesAlreadyCalculated.Set(true)\n\n\t\toldRoot := maybe.Bind(v.root, (*node).clone)\n\n\t\t// We wait to create the span until after checking that we need to actually\n\t\t// calculateNodeIDs to make traces more useful (otherwise there may be a span\n\t\t// per key modified even though IDs are not re-calculated).\n\t\t_, span := v.db.infoTracer.Start(ctx, \"MerkleDB.view.calculateNodeIDs\")\n\t\tdefer span.End()\n\n\t\t// add all the changed key/values to the nodes of the trie\n\t\tfor key, change := range v.changes.values {\n\t\t\tif change.after.IsNothing() {\n\t\t\t\t// Note we're setting [err] defined outside this function.\n\t\t\t\tif err = v.remove(key); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// Note we're setting [err] defined outside this function.\n\t\t\t} else if _, err = v.insert(key, change.after); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif !v.root.IsNothing() {\n\t\t\t_ = v.db.calculateNodeIDsSema.Acquire(context.Background(), 1)\n\t\t\tv.changes.rootID = v.calculateNodeIDsHelper(v.root.Value())\n\t\t\tv.db.calculateNodeIDsSema.Release(1)\n\t\t} else {\n\t\t\tv.changes.rootID = ids.Empty\n\t\t}\n\n\t\tv.changes.rootChange = change[maybe.Maybe[*node]]{\n\t\t\tbefore: oldRoot,\n\t\t\tafter:  v.root,\n\t\t}\n\n\t\t// ensure no ancestor changes occurred during execution\n\t\tif v.isInvalid() {\n\t\t\terr = ErrInvalid\n\t\t\treturn\n\t\t}\n\t})\n\treturn err\n}\n\n// Calculates the ID of all descendants of [n] which need to be recalculated,\n// and then calculates the ID of [n] itself.\nfunc (v *view) calculateNodeIDsHelper(n *node) ids.ID {\n\t// We use [wg] to wait until all descendants of [n] have been updated.\n\tvar wg sync.WaitGroup\n\n\tfor childIndex := range n.children {\n\t\tchildEntry := n.children[childIndex]\n\t\tchildKey := n.key.Extend(ToToken(childIndex, v.tokenSize), childEntry.compressedKey)\n\t\tchildNodeChange, ok := v.changes.nodes[childKey]\n\t\tif !ok {\n\t\t\t// This child wasn't changed.\n\t\t\tcontinue\n\t\t}\n\t\tchildEntry.hasValue = childNodeChange.after.hasValue()\n\n\t\t// Try updating the child and its descendants in a goroutine.\n\t\tif ok := v.db.calculateNodeIDsSema.TryAcquire(1); ok {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tchildEntry.id = v.calculateNodeIDsHelper(childNodeChange.after)\n\t\t\t\tv.db.calculateNodeIDsSema.Release(1)\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t} else {\n\t\t\t// We're at the goroutine limit; do the work in this goroutine.\n\t\t\tchildEntry.id = v.calculateNodeIDsHelper(childNodeChange.after)\n\t\t}\n\t}\n\n\t// Wait until all descendants of [n] have been updated.\n\twg.Wait()\n\n\t// The IDs [n]'s descendants are up to date so we can calculate [n]'s ID.\n\treturn n.calculateID(v.db.metrics)\n}\n\n// GetProof returns a proof that [bytesPath] is in or not in trie [t].\nfunc (v *view) GetProof(ctx context.Context, key []byte) (*Proof, error) {\n\t_, span := v.db.infoTracer.Start(ctx, \"MerkleDB.view.GetProof\")\n\tdefer span.End()\n\n\tif err := v.calculateNodeIDs(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult, err := getProof(v, key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif v.isInvalid() {\n\t\treturn nil, ErrInvalid\n\t}\n\treturn result, nil\n}\n\n// GetRangeProof returns a range proof for (at least part of) the key range [start, end].\n// The returned proof's [KeyValues] has at most [maxLength] values.\n// [maxLength] must be > 0.\nfunc (v *view) GetRangeProof(\n\tctx context.Context,\n\tstart maybe.Maybe[[]byte],\n\tend maybe.Maybe[[]byte],\n\tmaxLength int,\n) (*RangeProof, error) {\n\t_, span := v.db.infoTracer.Start(ctx, \"MerkleDB.view.GetRangeProof\")\n\tdefer span.End()\n\n\tif err := v.calculateNodeIDs(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\tresult, err := getRangeProof(v, start, end, maxLength)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif v.isInvalid() {\n\t\treturn nil, ErrInvalid\n\t}\n\treturn result, nil\n}\n\n// CommitToDB commits changes from this view to the underlying DB.\nfunc (v *view) CommitToDB(ctx context.Context) error {\n\tctx, span := v.db.infoTracer.Start(ctx, \"MerkleDB.view.CommitToDB\")\n\tdefer span.End()\n\n\tv.db.commitLock.Lock()\n\tdefer v.db.commitLock.Unlock()\n\n\treturn v.commitToDB(ctx)\n}\n\n// Commits the changes from [trieToCommit] to this view,\n// this view to its parent, and so on until committing to the db.\n// Assumes [v.db.commitLock] is held.\nfunc (v *view) commitToDB(ctx context.Context) error {\n\tv.commitLock.Lock()\n\tdefer v.commitLock.Unlock()\n\n\tctx, span := v.db.infoTracer.Start(ctx, \"MerkleDB.view.commitToDB\", oteltrace.WithAttributes(\n\t\tattribute.Int(\"changeCount\", len(v.changes.values)),\n\t))\n\tdefer span.End()\n\n\t// Call this here instead of in [v.db.commitChanges]\n\t// because doing so there would be a deadlock.\n\tif err := v.calculateNodeIDs(ctx); err != nil {\n\t\treturn err\n\t}\n\n\tif err := v.db.commitChanges(ctx, v); err != nil {\n\t\treturn err\n\t}\n\n\tv.committed = true\n\n\treturn nil\n}\n\n// Assumes [v.validityTrackingLock] isn't held.\nfunc (v *view) isInvalid() bool {\n\tv.validityTrackingLock.RLock()\n\tdefer v.validityTrackingLock.RUnlock()\n\n\treturn v.invalidated\n}\n\n// Invalidates this view and all descendants.\n// Assumes [v.validityTrackingLock] isn't held.\nfunc (v *view) invalidate() {\n\tv.validityTrackingLock.Lock()\n\tdefer v.validityTrackingLock.Unlock()\n\n\tv.invalidated = true\n\n\tfor _, childView := range v.childViews {\n\t\tchildView.invalidate()\n\t}\n\n\t// after invalidating the children, they no longer need to be tracked\n\tv.childViews = make([]*view, 0, defaultPreallocationSize)\n}\n\nfunc (v *view) updateParent(newParent View) {\n\tv.validityTrackingLock.Lock()\n\tdefer v.validityTrackingLock.Unlock()\n\n\tv.parentTrie = newParent\n}\n\n// GetMerkleRoot returns the ID of the root of this view.\nfunc (v *view) GetMerkleRoot(ctx context.Context) (ids.ID, error) {\n\tif err := v.calculateNodeIDs(ctx); err != nil {\n\t\treturn ids.Empty, err\n\t}\n\treturn v.changes.rootID, nil\n}\n\nfunc (v *view) GetValues(ctx context.Context, keys [][]byte) ([][]byte, []error) {\n\t_, span := v.db.debugTracer.Start(ctx, \"MerkleDB.view.GetValues\", oteltrace.WithAttributes(\n\t\tattribute.Int(\"keyCount\", len(keys)),\n\t))\n\tdefer span.End()\n\n\tresults := make([][]byte, len(keys))\n\tvalueErrors := make([]error, len(keys))\n\n\tfor i, key := range keys {\n\t\tresults[i], valueErrors[i] = v.getValueCopy(ToKey(key))\n\t}\n\treturn results, valueErrors\n}\n\n// GetValue returns the value for the given [key].\n// Returns database.ErrNotFound if it doesn't exist.\nfunc (v *view) GetValue(ctx context.Context, key []byte) ([]byte, error) {\n\t_, span := v.db.debugTracer.Start(ctx, \"MerkleDB.view.GetValue\")\n\tdefer span.End()\n\n\treturn v.getValueCopy(ToKey(key))\n}\n\n// getValueCopy returns a copy of the value for the given [key].\n// Returns database.ErrNotFound if it doesn't exist.\nfunc (v *view) getValueCopy(key Key) ([]byte, error) {\n\tval, err := v.getValue(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn slices.Clone(val), nil\n}\n\nfunc (v *view) getValue(key Key) ([]byte, error) {\n\tif v.isInvalid() {\n\t\treturn nil, ErrInvalid\n\t}\n\n\tif change, ok := v.changes.values[key]; ok {\n\t\tv.db.metrics.ViewValueCacheHit()\n\t\tif change.after.IsNothing() {\n\t\t\treturn nil, database.ErrNotFound\n\t\t}\n\t\treturn change.after.Value(), nil\n\t}\n\tv.db.metrics.ViewValueCacheMiss()\n\n\t// if we don't have local copy of the key, then grab a copy from the parent trie\n\tvalue, err := v.getParentTrie().getValue(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// ensure no ancestor changes occurred during execution\n\tif v.isInvalid() {\n\t\treturn nil, ErrInvalid\n\t}\n\n\treturn value, nil\n}\n\n// Must not be called after [calculateNodeIDs] has returned.\nfunc (v *view) remove(key Key) error {\n\tif v.nodesAlreadyCalculated.Get() {\n\t\treturn ErrNodesAlreadyCalculated\n\t}\n\n\t// confirm a node exists with a value\n\tkeyNode, err := v.getNode(key, true)\n\tif err != nil {\n\t\tif errors.Is(err, database.ErrNotFound) {\n\t\t\t// [key] isn't in the trie.\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif !keyNode.hasValue() {\n\t\t// [key] doesn't have a value.\n\t\treturn nil\n\t}\n\n\t// if the node exists and contains a value\n\t// mark all ancestor for change\n\t// grab parent and grandparent nodes for path compression\n\tvar grandParent, parent, nodeToDelete *node\n\tif err := visitPathToKey(v, key, func(n *node) error {\n\t\tgrandParent = parent\n\t\tparent = nodeToDelete\n\t\tnodeToDelete = n\n\t\treturn v.recordNodeChange(n)\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\tnodeToDelete.setValue(maybe.Nothing[[]byte]())\n\n\t// if the removed node has no children, the node can be removed from the trie\n\tif len(nodeToDelete.children) == 0 {\n\t\tif err := v.recordNodeDeleted(nodeToDelete); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif nodeToDelete.key == v.root.Value().key {\n\t\t\t// We deleted the root. The trie is empty now.\n\t\t\tv.root = maybe.Nothing[*node]()\n\t\t\treturn nil\n\t\t}\n\n\t\t// Note [parent] != nil since [nodeToDelete.key] != [v.root.key].\n\t\t// i.e. There's the root and at least one more node.\n\t\tparent.removeChild(nodeToDelete, v.tokenSize)\n\n\t\t// merge the parent node and its child into a single node if possible\n\t\treturn v.compressNodePath(grandParent, parent)\n\t}\n\n\t// merge this node and its descendants into a single node if possible\n\treturn v.compressNodePath(parent, nodeToDelete)\n}\n\n// Merges together nodes in the inclusive descendants of [n] that\n// have no value and a single child into one node with a compressed\n// path until a node that doesn't meet those criteria is reached.\n// [parent] is [n]'s parent. If [parent] is nil, [n] is the root\n// node and [v.root] is updated to [n].\n// Assumes at least one of the following is true:\n// * [n] has a value.\n// * [n] has children.\n// Must not be called after [calculateNodeIDs] has returned.\nfunc (v *view) compressNodePath(parent, n *node) error {\n\tif v.nodesAlreadyCalculated.Get() {\n\t\treturn ErrNodesAlreadyCalculated\n\t}\n\n\tif len(n.children) != 1 || n.hasValue() {\n\t\treturn nil\n\t}\n\n\tif err := v.recordNodeDeleted(n); err != nil {\n\t\treturn err\n\t}\n\n\tvar (\n\t\tchildEntry *child\n\t\tchildKey   Key\n\t)\n\t// There is only one child, but we don't know the index.\n\t// \"Cycle\" over the key/values to find the only child.\n\t// Note this iteration once because len(node.children) == 1.\n\tfor index, entry := range n.children {\n\t\tchildKey = n.key.Extend(ToToken(index, v.tokenSize), entry.compressedKey)\n\t\tchildEntry = entry\n\t}\n\n\tif parent == nil {\n\t\troot, err := v.getNode(childKey, childEntry.hasValue)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.root = maybe.Some(root)\n\t\treturn nil\n\t}\n\n\tparent.setChildEntry(childKey.Token(parent.key.length, v.tokenSize),\n\t\t&child{\n\t\t\tcompressedKey: childKey.Skip(parent.key.length + v.tokenSize),\n\t\t\tid:            childEntry.id,\n\t\t\thasValue:      childEntry.hasValue,\n\t\t})\n\treturn v.recordNodeChange(parent)\n}\n\n// Get a copy of the node matching the passed key from the view.\n// Used by views to get nodes from their ancestors.\nfunc (v *view) getEditableNode(key Key, hadValue bool) (*node, error) {\n\tif v.isInvalid() {\n\t\treturn nil, ErrInvalid\n\t}\n\n\t// grab the node in question\n\tn, err := v.getNode(key, hadValue)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// ensure no ancestor changes occurred during execution\n\tif v.isInvalid() {\n\t\treturn nil, ErrInvalid\n\t}\n\n\t// return a clone of the node, so it can be edited without affecting this view\n\treturn n.clone(), nil\n}\n\n// insert a key/value pair into the correct node of the trie.\n// Must not be called after [calculateNodeIDs] has returned.\nfunc (v *view) insert(\n\tkey Key,\n\tvalue maybe.Maybe[[]byte],\n) (*node, error) {\n\tif v.nodesAlreadyCalculated.Get() {\n\t\treturn nil, ErrNodesAlreadyCalculated\n\t}\n\n\tif v.root.IsNothing() {\n\t\t// the trie is empty, so create a new root node.\n\t\troot := newNode(key)\n\t\troot.setValue(value)\n\t\tv.root = maybe.Some(root)\n\t\treturn root, v.recordNewNode(root)\n\t}\n\n\t// Find the node that most closely matches [key].\n\tvar closestNode *node\n\tif err := visitPathToKey(v, key, func(n *node) error {\n\t\tclosestNode = n\n\t\t// Need to recalculate ID for all nodes on path to [key].\n\t\treturn v.recordNodeChange(n)\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif closestNode == nil {\n\t\t// [v.root.key] isn't a prefix of [key].\n\t\tvar (\n\t\t\toldRoot            = v.root.Value()\n\t\t\tcommonPrefixLength = getLengthOfCommonPrefix(oldRoot.key, key, 0 /*offset*/, v.tokenSize)\n\t\t\tcommonPrefix       = oldRoot.key.Take(commonPrefixLength)\n\t\t\tnewRoot            = newNode(commonPrefix)\n\t\t\toldRootID          = oldRoot.calculateID(v.db.metrics)\n\t\t)\n\n\t\t// Call addChildWithID instead of addChild so the old root is added\n\t\t// to the new root with the correct ID.\n\t\t// TODO:\n\t\t// [oldRootID] shouldn't need to be calculated here.\n\t\t// Either oldRootID should already be calculated or will be calculated at the end with the other nodes\n\t\t// Initialize the v.changes.rootID during newView and then use that here instead of oldRootID\n\t\tnewRoot.addChildWithID(oldRoot, v.tokenSize, oldRootID)\n\t\tif err := v.recordNewNode(newRoot); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tv.root = maybe.Some(newRoot)\n\n\t\tclosestNode = newRoot\n\t}\n\n\t// a node with that exact key already exists so update its value\n\tif closestNode.key == key {\n\t\tclosestNode.setValue(value)\n\t\t// closestNode was already marked as changed in the ancestry loop above\n\t\treturn closestNode, nil\n\t}\n\n\t// A node with the exact key doesn't exist so determine the portion of the\n\t// key that hasn't been matched yet\n\t// Note that [key] has prefix [closestNode.key], so [key] must be longer\n\t// and the following index won't OOB.\n\texistingChildEntry, hasChild := closestNode.children[key.Token(closestNode.key.length, v.tokenSize)]\n\tif !hasChild {\n\t\t// there are no existing nodes along the key [key], so create a new node to insert [value]\n\t\tnewNode := newNode(key)\n\t\tnewNode.setValue(value)\n\t\tclosestNode.addChild(newNode, v.tokenSize)\n\t\treturn newNode, v.recordNewNode(newNode)\n\t}\n\n\t// if we have reached this point, then the [key] we are trying to insert and\n\t// the existing path node have some common prefix.\n\t// a new branching node will be created that will represent this common prefix and\n\t// have the existing path node and the value being inserted as children.\n\n\t// generate the new branch node\n\t// find how many tokens are common between the existing child's compressed key and\n\t// the current key(offset by the closest node's key),\n\t// then move all the common tokens into the branch node\n\tcommonPrefixLength := getLengthOfCommonPrefix(\n\t\texistingChildEntry.compressedKey,\n\t\tkey,\n\t\tclosestNode.key.length+v.tokenSize,\n\t\tv.tokenSize,\n\t)\n\n\tif existingChildEntry.compressedKey.length <= commonPrefixLength {\n\t\t// Since the compressed key is shorter than the common prefix,\n\t\t// we should have visited [existingChildEntry] in [visitPathToKey].\n\t\treturn nil, ErrVisitPathToKey\n\t}\n\n\tbranchNode := newNode(key.Take(closestNode.key.length + v.tokenSize + commonPrefixLength))\n\tclosestNode.addChild(branchNode, v.tokenSize)\n\tnodeWithValue := branchNode\n\n\tif key.length == branchNode.key.length {\n\t\t// the branch node has exactly the key to be inserted as its key, so set the value on the branch node\n\t\tbranchNode.setValue(value)\n\t} else {\n\t\t// the key to be inserted is a child of the branch node\n\t\t// create a new node and add the value to it\n\t\tnewNode := newNode(key)\n\t\tnewNode.setValue(value)\n\t\tbranchNode.addChild(newNode, v.tokenSize)\n\t\tif err := v.recordNewNode(newNode); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnodeWithValue = newNode\n\t}\n\n\t// add the existing child onto the branch node\n\tbranchNode.setChildEntry(\n\t\texistingChildEntry.compressedKey.Token(commonPrefixLength, v.tokenSize),\n\t\t&child{\n\t\t\tcompressedKey: existingChildEntry.compressedKey.Skip(commonPrefixLength + v.tokenSize),\n\t\t\tid:            existingChildEntry.id,\n\t\t\thasValue:      existingChildEntry.hasValue,\n\t\t})\n\n\treturn nodeWithValue, v.recordNewNode(branchNode)\n}\n\nfunc getLengthOfCommonPrefix(first, second Key, secondOffset int, tokenSize int) int {\n\tcommonIndex := 0\n\tfor first.length > commonIndex && second.length > commonIndex+secondOffset &&\n\t\tfirst.Token(commonIndex, tokenSize) == second.Token(commonIndex+secondOffset, tokenSize) {\n\t\tcommonIndex += tokenSize\n\t}\n\treturn commonIndex\n}\n\n// Records that a node has been created.\n// Must not be called after [calculateNodeIDs] has returned.\nfunc (v *view) recordNewNode(after *node) error {\n\treturn v.recordKeyChange(after.key, after, after.hasValue(), true /* newNode */)\n}\n\n// Records that an existing node has been changed.\n// Must not be called after [calculateNodeIDs] has returned.\nfunc (v *view) recordNodeChange(after *node) error {\n\treturn v.recordKeyChange(after.key, after, after.hasValue(), false /* newNode */)\n}\n\n// Records that the node associated with the given key has been deleted.\n// Must not be called after [calculateNodeIDs] has returned.\nfunc (v *view) recordNodeDeleted(after *node) error {\n\treturn v.recordKeyChange(after.key, nil, after.hasValue(), false /* newNode */)\n}\n\n// Records that the node associated with the given key has been changed.\n// If it is an existing node, record what its value was before it was changed.\n// Must not be called after [calculateNodeIDs] has returned.\nfunc (v *view) recordKeyChange(key Key, after *node, hadValue bool, newNode bool) error {\n\tif v.nodesAlreadyCalculated.Get() {\n\t\treturn ErrNodesAlreadyCalculated\n\t}\n\n\tif existing, ok := v.changes.nodes[key]; ok {\n\t\texisting.after = after\n\t\treturn nil\n\t}\n\n\tif newNode {\n\t\tv.changes.nodes[key] = &change[*node]{\n\t\t\tafter: after,\n\t\t}\n\t\treturn nil\n\t}\n\n\tbefore, err := v.getParentTrie().getEditableNode(key, hadValue)\n\tif err != nil && !errors.Is(err, database.ErrNotFound) {\n\t\treturn err\n\t}\n\tv.changes.nodes[key] = &change[*node]{\n\t\tbefore: before,\n\t\tafter:  after,\n\t}\n\treturn nil\n}\n\n// Records that a key's value has been added or updated.\n// Doesn't actually change the trie data structure.\n// That's deferred until we call [calculateNodeIDs].\n// Must not be called after [calculateNodeIDs] has returned.\nfunc (v *view) recordValueChange(key Key, value maybe.Maybe[[]byte]) error {\n\tif v.nodesAlreadyCalculated.Get() {\n\t\treturn ErrNodesAlreadyCalculated\n\t}\n\n\t// update the existing change if it exists\n\tif existing, ok := v.changes.values[key]; ok {\n\t\texisting.after = value\n\t\treturn nil\n\t}\n\n\t// grab the before value\n\tvar beforeMaybe maybe.Maybe[[]byte]\n\tbefore, err := v.getParentTrie().getValue(key)\n\tswitch err {\n\tcase nil:\n\t\tbeforeMaybe = maybe.Some(before)\n\tcase database.ErrNotFound:\n\t\tbeforeMaybe = maybe.Nothing[[]byte]()\n\tdefault:\n\t\treturn err\n\t}\n\n\tv.changes.values[key] = &change[maybe.Maybe[[]byte]]{\n\t\tbefore: beforeMaybe,\n\t\tafter:  value,\n\t}\n\treturn nil\n}\n\n// Retrieves a node with the given [key].\n// If the node is fetched from [v.parentTrie] and [id] isn't empty,\n// sets the node's ID to [id].\n// If the node is loaded from the baseDB, [hasValue] determines which database the node is stored in.\n// Returns database.ErrNotFound if the node doesn't exist.\nfunc (v *view) getNode(key Key, hasValue bool) (*node, error) {\n\t// check for the key within the changed nodes\n\tif nodeChange, isChanged := v.changes.nodes[key]; isChanged {\n\t\tv.db.metrics.ViewNodeCacheHit()\n\t\tif nodeChange.after == nil {\n\t\t\treturn nil, database.ErrNotFound\n\t\t}\n\t\treturn nodeChange.after, nil\n\t}\n\n\t// get the node from the parent trie and store a local copy\n\treturn v.getParentTrie().getEditableNode(key, hasValue)\n}\n\n// Get the parent trie of the view\nfunc (v *view) getParentTrie() View {\n\tv.validityTrackingLock.RLock()\n\tdefer v.validityTrackingLock.RUnlock()\n\treturn v.parentTrie\n}"
    },
    {
      "filename": "x/merkledb/view.go",
      "content": "// Copyright (C) 2019-2024, Ava Labs, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\npackage merkledb\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"sync\"\n\n\t\"go.opentelemetry.io/otel/attribute\"\n\n\toteltrace \"go.opentelemetry.io/otel/trace\"\n\n\t\"golang.org/x/exp/slices\"\n\n\t\"github.com/ava-labs/avalanchego/database\"\n\t\"github.com/ava-labs/avalanchego/ids\"\n\t\"github.com/ava-labs/avalanchego/utils\"\n\t\"github.com/ava-labs/avalanchego/utils/maybe\"\n)\n\nconst (\n\tinitKeyValuesSize        = 256\n\tdefaultPreallocationSize = 100\n)\n\nvar (\n\t_ View = (*view)(nil)\n\n\tErrCommitted                  = errors.New(\"view has been committed\")\n\tErrInvalid                    = errors.New(\"the trie this view was based on has changed, rendering this view invalid\")\n\tErrPartialByteLengthWithValue = errors.New(\n\t\t\"the underlying db only supports whole number of byte keys, so cannot record changes with partial byte lengths\",\n\t)\n\tErrVisitPathToKey         = errors.New(\"failed to visit expected node during insertion\")\n\tErrStartAfterEnd          = errors.New(\"start key > end key\")\n\tErrNoChanges              = errors.New(\"no changes provided\")\n\tErrParentNotDatabase      = errors.New(\"parent trie is not database\")\n\tErrNodesAlreadyCalculated = errors.New(\"cannot modify the trie after the node changes have been calculated\")\n)\n\ntype view struct {\n\t// If true, this view has been committed.\n\t// [commitLock] must be held while accessing this field.\n\tcommitted  bool\n\tcommitLock sync.RWMutex\n\n\t// tracking bool to enforce that no changes are made to the trie after the nodes have been calculated\n\tnodesAlreadyCalculated utils.Atomic[bool]\n\n\t// calculateNodesOnce is a once to ensure that node calculation only occurs a single time\n\tcalculateNodesOnce sync.Once\n\n\t// Controls the view's validity related fields.\n\t// Must be held while reading/writing [childViews], [invalidated], and [parentTrie].\n\t// Only use to lock current view or descendants of the current view\n\t// DO NOT grab the [validityTrackingLock] of any ancestor trie while this is held.\n\tvalidityTrackingLock sync.RWMutex\n\n\t// If true, this view has been invalidated and can't be used.\n\t//\n\t// Invariant: This view is marked as invalid before any of its ancestors change.\n\t// Since we ensure that all subviews are marked invalid before making an invalidating change\n\t// then if we are still valid at the end of the function, then no corrupting changes could have\n\t// occurred during execution.\n\t// Namely, if we have a method with:\n\t//\n\t// *Code Accessing Ancestor State*\n\t//\n\t// if v.isInvalid() {\n\t//     return ErrInvalid\n\t//  }\n\t// return [result]\n\t//\n\t// If the invalidated check passes, then we're guaranteed that no ancestor changes occurred\n\t// during the code that accessed ancestor state and the result of that work is still valid\n\t//\n\t// [validityTrackingLock] must be held when reading/writing this field.\n\tinvalidated bool\n\n\t// the uncommitted parent trie of this view\n\t// [validityTrackingLock] must be held when reading/writing this field.\n\tparentTrie View\n\n\t// The valid children of this view.\n\t// [validityTrackingLock] must be held when reading/writing this field.\n\tchildViews []*view\n\n\t// Changes made to this view.\n\t// May include nodes that haven't been updated\n\t// but will when their ID is recalculated.\n\tchanges *changeSummary\n\n\tdb *merkleDB\n\n\t// The root of the trie represented by this view.\n\troot maybe.Maybe[*node]\n\n\ttokenSize int\n}\n\n// NewView returns a new view on top of this view where the passed changes\n// have been applied.\n// Adds the new view to [v.childViews].\n// Assumes [v.commitLock] isn't held.\nfunc (v *view) NewView(\n\tctx context.Context,\n\tchanges ViewChanges,\n) (View, error) {\n\tif v.isInvalid() {\n\t\treturn nil, ErrInvalid\n\t}\n\tv.commitLock.RLock()\n\tdefer v.commitLock.RUnlock()\n\n\tif v.committed {\n\t\treturn v.getParentTrie().NewView(ctx, changes)\n\t}\n\n\tif err := v.calculateNodeIDs(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tnewView, err := newView(v.db, v, changes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tv.validityTrackingLock.Lock()\n\tdefer v.validityTrackingLock.Unlock()\n\n\tif v.invalidated {\n\t\treturn nil, ErrInvalid\n\t}\n\tv.childViews = append(v.childViews, newView)\n\n\treturn newView, nil\n}\n\n// Creates a new view with the given [parentTrie].\nfunc newView(\n\tdb *merkleDB,\n\tparentTrie View,\n\tchanges ViewChanges,\n) (*view, error) {\n\tnewView := &view{\n\t\troot:       maybe.Bind(parentTrie.getRoot(), (*node).clone),\n\t\tdb:         db,\n\t\tparentTrie: parentTrie,\n\t\tchanges:    newChangeSummary(len(changes.BatchOps) + len(changes.MapOps)),\n\t\ttokenSize:  db.tokenSize,\n\t}\n\n\tfor _, op := range changes.BatchOps {\n\t\tkey := op.Key\n\t\tif !changes.ConsumeBytes {\n\t\t\tkey = slices.Clone(op.Key)\n\t\t}\n\n\t\tnewVal := maybe.Nothing[[]byte]()\n\t\tif !op.Delete {\n\t\t\tnewVal = maybe.Some(op.Value)\n\t\t\tif !changes.ConsumeBytes {\n\t\t\t\tnewVal = maybe.Some(slices.Clone(op.Value))\n\t\t\t}\n\t\t}\n\t\tif err := newView.recordValueChange(toKey(key), newVal); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tfor key, val := range changes.MapOps {\n\t\tif !changes.ConsumeBytes {\n\t\t\tval = maybe.Bind(val, slices.Clone[[]byte])\n\t\t}\n\t\tif err := newView.recordValueChange(toKey(stringToByteSlice(key)), val); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn newView, nil\n}\n\n// Creates a view of the db at a historical root using the provided [changes].\n// Returns ErrNoChanges if [changes] is empty.\nfunc newViewWithChanges(\n\tdb *merkleDB,\n\tchanges *changeSummary,\n) (*view, error) {\n\tif changes == nil {\n\t\treturn nil, ErrNoChanges\n\t}\n\n\tnewView := &view{\n\t\troot:       changes.rootChange.after,\n\t\tdb:         db,\n\t\tparentTrie: db,\n\t\tchanges:    changes,\n\t\ttokenSize:  db.tokenSize,\n\t}\n\t// since this is a set of historical changes, all nodes have already been calculated\n\t// since no new changes have occurred, no new calculations need to be done\n\tnewView.calculateNodesOnce.Do(func() {})\n\tnewView.nodesAlreadyCalculated.Set(true)\n\treturn newView, nil\n}\n\nfunc (v *view) getTokenSize() int {\n\treturn v.tokenSize\n}\n\nfunc (v *view) getRoot() maybe.Maybe[*node] {\n\treturn v.root\n}\n\n// Recalculates the node IDs for all changed nodes in the trie.\n// Cancelling [ctx] doesn't cancel calculation. It's used only for tracing.\nfunc (v *view) calculateNodeIDs(ctx context.Context) error {\n\tvar err error\n\tv.calculateNodesOnce.Do(func() {\n\t\tif v.isInvalid() {\n\t\t\terr = ErrInvalid\n\t\t\treturn\n\t\t}\n\t\tdefer v.nodesAlreadyCalculated.Set(true)\n\n\t\toldRoot := maybe.Bind(v.root, (*node).clone)\n\n\t\t// We wait to create the span until after checking that we need to actually\n\t\t// calculateNodeIDs to make traces more useful (otherwise there may be a span\n\t\t// per key modified even though IDs are not re-calculated).\n\t\t_, span := v.db.infoTracer.Start(ctx, \"MerkleDB.view.calculateNodeIDs\")\n\t\tdefer span.End()\n\n\t\t// add all the changed key/values to the nodes of the trie\n\t\tfor key, change := range v.changes.values {\n\t\t\tif change.after.IsNothing() {\n\t\t\t\t// Note we're setting [err] defined outside this function.\n\t\t\t\tif err = v.remove(key); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// Note we're setting [err] defined outside this function.\n\t\t\t} else if _, err = v.insert(key, change.after); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif !v.root.IsNothing() {\n\t\t\t_ = v.db.calculateNodeIDsSema.Acquire(context.Background(), 1)\n\t\t\tv.changes.rootID = v.calculateNodeIDsHelper(v.root.Value())\n\t\t\tv.db.calculateNo"
    }
  ]
}