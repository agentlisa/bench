{
  "Title": "M-19: Rounding error when closing quote",
  "Content": "# Issue M-19: Rounding error when closing quote \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/251 \n\n## Found by \nmstpr-brainbot, xiaoming90\n## Summary\n\nRounding errors could occur if the provided `filledAmount` is too small, resulting in the locked balance of an account remains the same even though a certain amount of the position has been closed.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L155\n\n```solidity\nFile: LibQuote.sol\n149:     function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n150:         QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n151:         AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n152: \n153:         quote.modifyTimestamp = block.timestamp;\n154: \n155:         LockedValues memory lockedValues = LockedValues(\n156:             quote.lockedValues.cva -\n157:                 ((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n158:             quote.lockedValues.mm -\n159:                 ((quote.lockedValues.mm * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n160:             quote.lockedValues.lf -\n161:                 ((quote.lockedValues.lf * filledAmount) / (LibQuote.quoteOpenAmount(quote)))\n162:         );\n163:         accountLayout.lockedBalances[quote.partyA].subQuote(quote).add(lockedValues);\n164:         accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].subQuote(quote).add(\n165:             lockedValues\n166:         );\n167:         quote.lockedValues = lockedValues;\n168: \n169:         (bool hasMadeProfit, uint256 pnl) = LibQuote.getValueOfQuoteForPartyA(\n170:             closedPrice,\n171:             filledAmount,\n172:             quote\n173:         );\n174:         if (hasMadeProfit) {\n175:             accountLayout.allocatedBalances[quote.partyA] += pnl;\n176:             accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] -= pnl;\n177:         } else {\n178:             accountLayout.allocatedBalances[quote.partyA] -= pnl;\n179:             accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] += pnl;\n180:         }\n\n```\n\nIn Lines 157, 159, and 161 above, a malicious user could make the numerator smaller than the denominator (`LibQuote.quoteOpenAmount(quote)`), and the result will be zero due to a rounding error in Solidity.\n\nIn this case, the `quote.lockedValues` will not decrease and will remain the same. As a result, the locked balance of the account will remain the same even though a certain amount of the position has been closed. This could cause the account's locked balance to be higher than expected, and the errors will accumulate if it happens many times.\n\n## Impact\n\nWhen an account's locked balances are higher than expected, their available balance will be lower than expected. The available balance affects the amount that users can withdraw from their accounts. The \"silent\" increase in their locked values means that the amount that users can withdraw becomes lesser over time, and these amounts are lost due to the errors.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L155\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen the `((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote)))` rounds down to zero, this means that a rounding error has occurred as the numerator is smaller than the denominator. The CVA, `filledAmount` or both might be too small.\n\nConsider performing input validation against the `filledAmount` within the `fillCloseRequest` function to ensure that the provided values are sufficiently large and will not result in a rounding error.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Given that:\n> - All amounts are of precision 18 decimals and multiplication before division rule is implemented\n> - Multiple checks on locked amounts wrt quantity opened:\n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L50-L65\n> \n> The amounts remaining locked are very small (magnitude of few wei per call), this issue should be of low severity per sherlock standards\n\n    You've deleted an escalation for this issue.\n\n**xiaoming9090**\n\nEscalate\n\n> Escalate\n>\n> Given that:\n>\n> * All amounts are of precision 18 decimals and multiplication before division rule is implemented\n> * Multiple checks on locked amounts wrt quantity opened:\n>   https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L50-L65\n>\n> The amounts remaining locked are very small (magnitude of few wei per call), this issue should be of low severity per sherlock standards\n\nRegarding the second bullet point, the checks will only be relevant if the position is fully closed via the `forceClosePosition` or `emergencyClosePosition` function, as they are forced to close the entire quantity of the position. However, if the position is partially filled via the `fillCloseRequest`, the error might still occur since the caller can specify an arbitrary `filledAmount`.\n\nIf an account has only traded a few times and the error only happens a few times, it might be fine. However, this is a trading protocol, and it is expected that there will be users who are active traders or entities that perform high-frequency or algorithmic trading. \n\nThus, the error will eventually accumulate into a significant value for these types of traders, and they will suffer the consequences as mentioned in my impact section of the report. In addition, it breaks an important protocol invariant where the locked balance does not decrease when a position is closed, which is unacceptable.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> > Escalate\n> >\n> > Given that:\n> >\n> > * All amounts are of precision 18 decimals and multiplication before division rule is implemented\n> > * Multiple checks on locked amounts wrt quantity opened:\n> >   https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L50-L65\n> >\n> > The amounts remaining locked are very small (magnitude of few wei per call), this issue should be of low severity per sherlock standards\n> \n> Regarding the second bullet point, the checks will only be relevant if the position is fully closed via the `forceClosePosition` or `emergencyClosePosition` function, as they are forced to close the entire quantity of the position. However, if the position is partially filled via the `fillCloseRequest`, the error might still occur since the caller can specify an arbitrary `filledAmount`.\n> \n> If an account has only traded a few times and the error only happens a few times, it might be fine. However, this is a trading protocol, and it is expected that there will be users who are active traders or entities that perform high-frequency or algorithmic trading. \n> \n> Thus, the error will eventually accumulate into a significant value for these types of traders, and they will suffer the consequences as mentioned in my impact section of the report. In addition, it breaks an important protocol invariant where the locked balance does not decrease when a position is closed, which is unacceptable.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**SergeKireev**\n\nEscalate\n\nThis issue is invalid because `LibQuote.quoteOpenAmount(quote))` is defined as:\n```\nfunction quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n    return quote.quantity - quote.closedAmount;\n}\n```\n\nin the `closeQuote` function, `quote.closedAmount` is also updated as follows:\n```\nquote.closedAmount += filledAmount;\n```\n\nWhich means that when the user closes the position completely `filledAmount == LibQuote.quoteOpenAmount(quote))` (which also means `filledAmount/LibQuote.quoteOpenAmount(quote)) == 1` and without  rounding error) and the whole amount is unlocked in any case\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This issue is invalid because `LibQuote.quoteOpenAmount(quote))` is defined as:\n> ```\n> function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n>     return quote.quantity - quote.closedAmount;\n> }\n> ```\n> \n> in the `closeQuote` function, `quote.closedAmount` is also updated as follows:\n> ```\n> quote.closedAmount += filledAmount;\n> ```\n> \n> Which means that when the user closes the position completely `filledAmount == LibQuote.quoteOpenAmount(quote))` (which also means `filledAmount/LibQuote.quoteOpenAmount(quote)) == 1` and without  rounding error) and the whole amount is unlocked in any case\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\n@xiaoming9090 any comment on the escalation by @SergeKireev ?\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/24\n\n**xiaoming9090**\n\n> Escalate\n> \n> This issue is invalid because `LibQuote.quoteOpenAmount(quote))` is defined as:\n> \n> ```\n> function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n>     return quote.quantity - quote.closedAmount;\n> }\n> ```\n> \n> in the `closeQuote` function, `quote.closedAmount` is also updated as follows:\n> \n> ```\n> quote.closedAmount += filledAmount;\n> ```\n> \n> Which means that when the user closes the position completely `filledAmount == LibQuote.quoteOpenAmount(quote))` (which also means `filledAmount/LibQuote.quoteOpenAmount(quote)) == 1` and without rounding error) and the whole amount is unlocked in any case\n\nDisagree. This does not make the issue invalid. If the trader executes many small partial closes without completely closing the position, the accumulated error in the locked values will exist. It is unacceptable for the protocol to have inaccurate locked values at any single point in time. The locked values are used to determine many crucial decisions throughout the protocol, such as in assessing the solvency of an account.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAgree with the fix and the comment here:\nhttps://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/251#issuecomment-1685574052\nmaintaining severity as is\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/251/#issuecomment-1652872462): accepted\n- [SergeKireev](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/251/#issuecomment-1653204545): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/libraries/LibQuote.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"./LibLockedValues.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\nimport \"../storages/GlobalAppStorage.sol\";\nimport \"../storages/SymbolStorage.sol\";\nimport \"../storages/MAStorage.sol\";\n\nlibrary LibQuote {\n    using LockedValuesOps for LockedValues;\n\n    function getAmountToLockOfQuote(Quote storage quote) internal view returns (uint256) {\n        return quote.lockedValues.total();\n    }\n\n    function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n        return quote.quantity - quote.closedAmount;\n    }\n\n    function getIndexOfItem(\n        uint256[] storage array_,\n        uint256 item\n    ) internal view returns (uint256) {\n        for (uint256 index = 0; index < array_.length; index++) {\n            if (array_[index] == item) return index;\n        }\n        return type(uint256).max;\n    }\n\n    function removeFromArray(uint256[] storage array_, uint256 item) internal {\n        uint256 index = getIndexOfItem(array_, item);\n        require(index != type(uint256).max, \"LibQuote: Item not Found\");\n        array_[index] = array_[array_.length - 1];\n        array_.pop();\n    }\n\n    function removeFromPartyAPendingQuotes(Quote storage quote) internal {\n        removeFromArray(QuoteStorage.layout().partyAPendingQuotes[quote.partyA], quote.id);\n    }\n\n    function removeFromPartyBPendingQuotes(Quote storage quote) internal {\n        removeFromArray(\n            QuoteStorage.layout().partyBPendingQuotes[quote.partyB][quote.partyA],\n            quote.id\n        );\n    }\n\n    function removeFromPendingQuotes(Quote storage quote) internal {\n        removeFromPartyAPendingQuotes(quote);\n        removeFromPartyBPendingQuotes(quote);\n    }\n\n    function addToOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n\n        quoteLayout.partyAOpenPositions[quote.partyA].push(quote.id);\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].push(quote.id);\n\n        quoteLayout.partyAPositionsIndex[quote.id] = quoteLayout.partyAPositionsCount[quote.partyA];\n        quoteLayout.partyBPositionsIndex[quote.id] = quoteLayout.partyBPositionsCount[quote.partyB][\n            quote.partyA\n        ];\n\n        quoteLayout.partyAPositionsCount[quote.partyA] += 1;\n        quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] += 1;\n    }\n\n    function removeFromOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        uint256 indexOfPartyAPosition = quoteLayout.partyAPositionsIndex[quote.id];\n        uint256 indexOfPartyBPosition = quoteLayout.partyBPositionsIndex[quote.id];\n        uint256 lastOpenPositionIndex = quoteLayout.partyAPositionsCount[quote.partyA] - 1;\n        quoteLayout.partyAOpenPositions[quote.partyA][indexOfPartyAPosition] = quoteLayout\n            .partyAOpenPositions[quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyAPositionsIndex[\n            quoteLayout.partyAOpenPositions[quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyAPosition;\n        quoteLayout.partyAOpenPositions[quote.partyA].pop();\n\n        lastOpenPositionIndex = quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] - 1;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][\n            indexOfPartyBPosition\n        ] = quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyBPositionsIndex[\n            quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyBPosition;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].pop();\n\n        quoteLayout.partyAPositionsIndex[quote.id] = 0;\n        quoteLayout.partyBPositionsIndex[quote.id] = 0;\n    }\n\n    function getValueOfQuoteForPartyA(\n        uint256 currentPrice,\n        uint256 filledAmount,\n        Quote storage quote\n    ) internal view returns (bool hasMadeProfit, uint256 pnl) {\n        if (currentPrice > quote.openedPrice) {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = true;\n            } else {\n                hasMadeProfit = false;\n            }\n            pnl = ((currentPrice - quote.openedPrice) * filledAmount) / 1e18;\n        } else {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = false;\n            } else {\n                hasMadeProfit = true;\n            }\n            pnl = ((quote.openedPrice - currentPrice) * filledAmount) / 1e18;\n        }\n    }\n\n    function getTradingFee(uint256 quoteId) internal view returns (uint256 fee) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        Symbol storage symbol = SymbolStorage.layout().symbols[quote.symbolId];\n        if (quote.orderType == OrderType.LIMIT) {\n            fee =\n                (LibQuote.quoteOpenAmount(quote) * quote.requestedOpenPrice * symbol.tradingFee) /\n                1e36;\n        } else {\n            fee = (LibQuote.quoteOpenAmount(quote) * quote.marketPrice * symbol.tradingFee) / 1e36;\n        }\n    }\n\n    function returnTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] += tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] -= tradingFee;\n    }\n\n    function receiveTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] -= tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] += tradingFee;\n    }\n\n    function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        quote.modifyTimestamp = block.timestamp;\n\n        LockedValues memory lockedValues = LockedValues(\n            quote.lockedValues.cva -\n                ((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.mm -\n                ((quote.lockedValues.mm * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.lf -\n                ((quote.lockedValues.lf * filledAmount) / (LibQuote.quoteOpenAmount(quote)))\n        );\n        accountLayout.lockedBalances[quote.partyA].subQuote(quote).add(lockedValues);\n        accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].subQuote(quote).add(\n            lockedValues\n        );\n        quote.lockedValues = lockedValues;\n\n        (bool hasMadeProfit, uint256 pnl) = LibQuote.getValueOfQuoteForPartyA(\n            closedPrice,\n            filledAmount,\n            quote\n        );\n        if (hasMadeProfit) {\n            accountLayout.allocatedBalances[quote.partyA] += pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] -= pnl;\n        } else {\n            accountLayout.allocatedBalances[quote.partyA] -= pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] += pnl;\n        }\n\n        quote.avgClosedPrice =\n            (quote.avgClosedPrice * quote.closedAmount + filledAmount * closedPrice) /\n            (quote.closedAmount + filledAmount);\n\n        quote.closedAmount += filledAmount;\n        quote.quantityToClose -= filledAmount;\n\n        if (quote.closedAmount == quote.quantity) {\n            quote.quoteStatus = QuoteStatus.CLOSED;\n            quote.requestedClosePrice = 0;\n            removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[quote.partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] -= 1;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING || quote.quantityToClose == 0\n        ) {\n            quote.quoteStatus = QuoteStatus.OPENED;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0; // for CANCEL_CLOSE_PENDING status\n        } else {\n            require(\n                quote.lockedValues.total() >=\n                    SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"LibQuote: Remaining quote value is low\"\n            );\n        }\n    }\n\n    function expireQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(block.timestamp > quote.deadline, \"LibQuote: Quote isn't expired\");\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING ||\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"LibQuote: Invalid state\"\n        );\n        require(\n            !MAStorage.layout().liquidationStatus[quote.partyA],\n            \"LibQuote: PartyA isn't solvent\"\n        );\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[quote.partyB][quote.partyA],\n            \"LibQuote: PartyB isn't solvent\"\n        );\n        if (\n            quote.quoteStatus == QuoteStatus.PENDING ||\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            // send trading Fee back to partyA\n            LibQuote.returnTradingFee(quoteId);\n            removeFromPartyAPendingQuotes(quote);\n            if (\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n            ) {\n                accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n                removeFromPartyBPendingQuotes(quote);\n            }\n            quote.quoteStatus = QuoteStatus.EXPIRED;\n            result = QuoteStatus.EXPIRED;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0;\n            quote.quoteStatus = QuoteStatus.OPENED;\n            result = QuoteStatus.OPENED;\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/libraries/LibQuote.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"./LibLockedValues.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\nimport \"../storages/GlobalAppStorage.sol\";\nimport \"../storages/SymbolStorage.sol\";\nimport \"../storages/MAStorage.sol\";\n\nlibrary LibQuote {\n    using LockedValuesOps for LockedValues;\n\n    function getAmountToLockOfQuote(Quote storage quote) internal view returns (uint256) {\n        return quote.lockedValues.total();\n    }\n\n    function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n        return quote.quantity - quote.closedAmount;\n    }\n\n    function getIndexOfItem(\n        uint256[] storage array_,\n        uint256 item\n    ) internal view returns (uint256) {\n        for (uint256 index = 0; index < array_.length; index++) {\n            if (array_[index] == item) return index;\n        }\n        return type(uint256).max;\n    }\n\n    function removeFromArray(uint256[] storage array_, uint256 item) internal {\n        uint256 index = getIndexOfItem(array_, item);\n        require(index != type(uint256).max, \"LibQuote: Item not Found\");\n        array_[index] = array_[array_.length - 1];\n        array_.pop();\n    }\n\n    function removeFromPartyAPendingQuotes(Quote storage quote) internal {\n        removeFromArray(QuoteStorage.layout().partyAPendingQuotes[quote.partyA], quote.id);\n    }\n\n    function removeFromPartyBPendingQuotes(Quote storage quote) internal {\n        removeFromArray(\n            QuoteStorage.layout().partyBPendingQuotes[quote.partyB][quote.partyA],\n            quote.id\n        );\n    }\n\n    function removeFromPendingQuotes(Quote storage quote) internal {\n        removeFromPartyAPendingQuotes(quote);\n        removeFromPartyBPendingQuotes(quote);\n    }\n\n    function addToOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n\n        quoteLayout.partyAOpenPositions[quote.partyA].push(quote.id);\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].push(quote.id);\n\n        quoteLayout.partyAPositionsIndex[quote.id] = quoteLayout.partyAPositionsCount[quote.partyA];\n        quoteLayout.partyBPositionsIndex[quote.id] = quoteLayout.partyBPositionsCount[quote.partyB][\n            quote.partyA\n        ];\n\n        quoteLayout.partyAPositionsCount[quote.partyA] += 1;\n        quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] += 1;\n    }\n\n    function removeFromOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        uint256 indexOfPartyAPosition = quoteLayout.partyAPositionsIndex[quote.id];\n        uint256 indexOfPartyBPosition = quoteLayout.partyBPositionsIndex[quote.id];\n        uint256 lastOpenPositionIndex = quoteLayout.partyAPositionsCount[quote.partyA] - 1;\n        quoteLayout.partyAOpenPositions[quote.partyA][indexOfPartyAPosition] = quoteLayout\n            .partyAOpenPositions[quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyAPositionsIndex[\n            quoteLayout.partyAOpenPositions[quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyAPosition;\n        quoteLayout.partyAOpenPositions[quote.partyA].pop();\n\n        lastOpenPositionIndex = quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] - 1;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][\n            indexOfPartyBPosition\n        ] = quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyBPositionsIndex[\n            quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyBPosition;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].pop();\n\n        quoteLayout.partyAPositionsIndex[quote.id] = 0;\n        quoteLayout.partyBPositionsIndex[quote.id] = 0;\n    }\n\n    function getValueOfQuoteForPartyA(\n        uint256 currentPrice,\n        uint256 filledAmount,\n        Quote storage quote\n    ) internal view returns (bool hasMadeProfit, uint256 pnl) {\n        if (currentPrice > quote.openedPrice) {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = true;\n            } else {\n                hasMadeProfit = false;\n            }\n            pnl = ((currentPrice - quote.openedPrice) * filledAmount) / 1e18;\n        } else {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = false;\n            } else {\n                hasMadeProfit = true;\n            }\n            pnl = ((quote.openedPrice - currentPrice) * filledAmount) / 1e18;\n        }\n    }\n\n    function getTradingFee(uint256 quoteId) internal view returns (uint256 fee) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        Symbol storage symbol = SymbolStorage.layout().symbols[quote.symbolId];\n        if (quote.orderType == OrderType.LIMIT) {\n            fee =\n                (LibQuote.quoteOpenAmount(quote) * quote.requestedOpenPrice * symbol.tradingFee) /\n                1e36;\n        } else {\n            fee = (LibQuote.quoteOpenAmount(quote) * quote.marketPrice * symbol.tradingFee) / 1e36;\n        }\n    }\n\n    function returnTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] += tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] -= tradingFee;\n    }\n\n    function receiveTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] -= tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] += tradingFee;\n    }\n\n    function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        quote.modifyTimestamp = block.timestamp;\n\n        LockedValues memory lockedValues = LockedValues(\n            quote.lockedValues.cva -\n                ((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.mm -\n                ((quote.lockedValues.mm * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.lf -\n                ((quote.lockedValues.lf * filledAmount) / (LibQuote.quoteOpenAmount(quote)))\n        );\n        accountLayout.lockedBalances[quote.partyA].subQuote(quote).add(lockedValues);\n        accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].subQuote(quote).add(\n            lockedValues\n        );\n        quote.lockedValues = lockedValues;\n\n        (bool hasMadeProfit, uint256 pnl) = LibQuote.getValueOfQuoteForPartyA(\n            closedPrice,\n            filledAmount,\n            quote\n        );\n        if (hasMadeProfit) {\n            accountLayout.allocatedBalances[quote.partyA] += pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] -= pnl;\n        } else {\n            accountLayout.allocatedBalances[quote.partyA] -= pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] += pnl;\n        }\n\n        quote.avgClosedPrice =\n            (quote.avgClosedPrice * quote.closedAmount + filledAmount * closedPrice) /\n            (quote.closedAmount + filledAmount);\n\n        quote.closedAmount += filledAmount;\n        quote.quantityToClose -= filledAmount;\n\n        if (quote.closedAmount == quote.quantity) {\n            quote.quoteStatus = QuoteStatus.CLOSED;\n            quote.requestedClosePrice = 0;\n            removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[quote.partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] -= 1;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING || quote.quantityToClose == 0\n        ) {\n            quote.quoteStatus = QuoteStatus.OPENED;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0; // for CANCEL_CLOSE_PENDING status\n        } else {\n            require(\n                quote.lockedValues.total() >=\n                    SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"LibQuote: Remaining quote value is low\"\n            );\n        }\n    }\n\n    function expireQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(block.timestamp > quote.deadline, \"LibQuote: Quote isn't expired\");\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING ||\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"LibQuote: Invalid state\"\n        );\n        require(\n            !MAStorage.layout().liquidationStatus[quote.partyA],\n            \"LibQuote: PartyA isn't solvent\"\n        );\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[quote.partyB][quote.partyA],\n            \"LibQuote: PartyB isn't solvent\"\n        );\n        if (\n            quote.quoteStatus == QuoteStatus.PENDING ||\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            // send trading Fee back to partyA\n            LibQuote.returnTradingFee(quoteId);\n            removeFromPartyAPendingQuotes(quote);\n            if (\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n            ) {\n                accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n                removeFromPartyBPendingQuotes(quote);\n            }\n            quote.quoteStatus = QuoteStatus.EXPIRED;\n            result = QuoteStatus.EXPIRED;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0;\n            quote.quoteStatus = QuoteStatus.OPENED;\n            result = QuoteStatus.OPENED;\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyAFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function sendQuote(\n        address[] memory partyBsWhiteList,\n        uint256 symbolId,\n        PositionType positionType,\n        OrderType orderType,\n        uint256 price,\n        uint256 quantity,\n        uint256 cva,\n        uint256 mm,\n        uint256 lf,\n        uint256 maxInterestRate,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n\n        require(\n            quoteLayout.partyAPendingQuotes[msg.sender].length < maLayout.pendingQuotesValidLength,\n            \"PartyAFacet: Number of pending quotes out of range\"\n        );\n        require(symbolLayout.symbols[symbolId].isValid, \"PartyAFacet: Symbol is not valid\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n\n        LockedValues memory lockedValues = LockedValues(cva, mm, lf);\n        uint256 tradingPrice = orderType == OrderType.LIMIT ? price : upnlSig.price;\n        uint256 notionalValue = (quantity * tradingPrice) / 1e18;\n        require(\n            lockedValues.total() <= notionalValue,\n            \"PartyAFacet: Leverage can't be lower than one\"\n        );\n\n        require(\n            lockedValues.lf >=\n                (symbolLayout.symbols[symbolId].minAcceptablePortionLF * lockedValues.total()) /\n                    1e18,\n            \"PartyAFacet: LF is not enough\"\n        );\n\n        require(\n            lockedValues.total() >= symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            \"PartyAFacet: Quote value is low\"\n        );\n        for (uint8 i = 0; i < partyBsWhiteList.length; i++) {\n            require(\n                partyBsWhiteList[i] != msg.sender,\n                \"PartyAFacet: Sender isn't allowed in partyBWhiteList\"\n            );\n        }\n\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, msg.sender, symbolId);\n\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance > 0, \"PartyAFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >=\n                lockedValues.total() +\n                    ((quantity * tradingPrice * symbolLayout.symbols[symbolId].tradingFee) / 1e36),\n            \"PartyAFacet: insufficient available balance\"\n        );\n\n        // lock funds the in middle of way\n        accountLayout.pendingLockedBalances[msg.sender].add(lockedValues);\n        currentId = ++quoteLayout.lastId;\n        accountLayout.partyANonces[msg.sender] += 1;\n\n        // create quote.\n        Quote memory quote = Quote({\n            id: currentId,\n            partyBsWhiteList: partyBsWhiteList,\n            symbolId: symbolId,\n            positionType: positionType,\n            orderType: orderType,\n            openedPrice: 0,\n            requestedOpenPrice: price,\n            marketPrice: upnlSig.price,\n            quantity: quantity,\n            closedAmount: 0,\n            lockedValues: lockedValues,\n            initialLockedValues: lockedValues,\n            maxInterestRate: maxInterestRate,\n            partyA: msg.sender,\n            partyB: address(0),\n            quoteStatus: QuoteStatus.PENDING,\n            avgClosedPrice: 0,\n            requestedClosePrice: 0,\n            parentId: 0,\n            createTimestamp: block.timestamp,\n            modifyTimestamp: block.timestamp,\n            quantityToClose: 0,\n            deadline: deadline\n        });\n        quoteLayout.quoteIdsOf[msg.sender].push(currentId);\n        quoteLayout.partyAPendingQuotes[msg.sender].push(currentId);\n        quoteLayout.quotes[currentId] = quote;\n\n        LibQuote.receiveTradingFee(currentId);\n    }\n\n    function requestToCancelQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING || quote.quoteStatus == QuoteStatus.LOCKED,\n            \"PartyAFacet: Invalid state\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n\n        if (block.timestamp > quote.deadline) {\n            result = LibQuote.expireQuote(quoteId);\n        } else if (quote.quoteStatus == QuoteStatus.PENDING) {\n            quote.quoteStatus = QuoteStatus.CANCELED;\n            LibQuote.returnTradingFee(quoteId);\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyAPendingQuotes(quote);\n            result = QuoteStatus.CANCELED;\n        } else {\n            // Quote is locked\n            quote.quoteStatus = QuoteStatus.CANCEL_PENDING;\n            result = QuoteStatus.CANCEL_PENDING;\n        }\n        quote.modifyTimestamp = block.timestamp;\n    }\n\n    function requestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        OrderType orderType,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyAFacet: Invalid state\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n        require(\n            LibQuote.quoteOpenAmount(quote) >= quantityToClose,\n            \"PartyAFacet: Invalid quantityToClose\"\n        );\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterRequestToClosePosition(\n            quoteId,\n            closePrice,\n            quantityToClose,\n            upnlSig\n        );\n\n        // check that remaining position is not too small\n        if (LibQuote.quoteOpenAmount(quote) > quantityToClose) {\n            require(\n                ((LibQuote.quoteOpenAmount(quote) - quantityToClose) * quote.lockedValues.total()) /\n                    LibQuote.quoteOpenAmount(quote) >=\n                    symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyAFacet: Remaining quote value is low\"\n            );\n        }\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CLOSE_PENDING;\n        quote.requestedClosePrice = closePrice;\n        quote.quantityToClose = quantityToClose;\n        quote.orderType = orderType;\n        quote.deadline = deadline;\n    }\n\n    function requestToCancelCloseRequest(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            LibQuote.expireQuote(quoteId);\n            return QuoteStatus.OPENED;\n        } else {\n            accountLayout.partyANonces[quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.CANCEL_CLOSE_PENDING;\n            return QuoteStatus.CANCEL_CLOSE_PENDING;\n        }\n    }\n\n    function forceCancelQuote(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.p"
    }
  ]
}