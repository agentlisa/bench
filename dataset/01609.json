{
  "Title": "H-5: `depositAndAllocateForPartyB` is broken due to incorrect precision",
  "Content": "# Issue H-5: `depositAndAllocateForPartyB` is broken due to incorrect precision \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/222 \n\n## Found by \n0xChinedu, 0xmuxyz, AkshaySrivastav, Ch\\_301, Juntao, PokemonAuditSimulator, berndartmueller, josephdara, kutugu, nobody2018, shaka, tvdung94, xiaoming90\n## Summary\n\nDue to incorrect precision, any users or external protocols utilizing the `depositAndAllocateForPartyB` to allocate 1000 USDC will end up only having 0.000000001 USDC allocated to their account. This might potentially lead to unexpected loss of funds due to the broken functionality if they rely on the accuracy of the function outcome to perform certain actions that deal with funds/assets.\n\n## Vulnerability Detail\n\nThe input `amount` of the `depositForPartyB` function must be in native precision (e.g. USDC should be 6 decimals) as the function will automatically scale the amount to 18 precision in Lines 114-115 below.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/Account/AccountFacetImpl.sol#L108\n\n```solidity\nFile: AccountFacetImpl.sol\n108:     function depositForPartyB(uint256 amount) internal {\n109:         IERC20(GlobalAppStorage.layout().collateral).safeTransferFrom(\n110:             msg.sender,\n111:             address(this),\n112:             amount\n113:         );\n114:         uint256 amountWith18Decimals = (amount * 1e18) /\n115:         (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n116:         AccountStorage.layout().balances[msg.sender] += amountWith18Decimals;\n117:     }\n```\n\nOn the other hand, the input `amount` of `allocateForPartyB` function must be in 18 decimals precision. Within the protocol, it uses 18 decimals for internal accounting.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/Account/AccountFacetImpl.sol#L119\n\n```solidity\nFile: AccountFacetImpl.sol\n119:     function allocateForPartyB(uint256 amount, address partyA, bool increaseNonce) internal {\n120:         AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n121: \n122:         require(accountLayout.balances[msg.sender] >= amount, \"PartyBFacet: Insufficient balance\");\n123:         require(\n124:             !MAStorage.layout().partyBLiquidationStatus[msg.sender][partyA],\n125:             \"PartyBFacet: PartyB isn't solvent\"\n126:         );\n127:         if (increaseNonce) {\n128:             accountLayout.partyBNonces[msg.sender][partyA] += 1;\n129:         }\n130:         accountLayout.balances[msg.sender] -= amount;\n131:         accountLayout.partyBAllocatedBalances[msg.sender][partyA] += amount;\n132:     }\n```\n\nThe `depositAndAllocateForPartyB` function allows the users to deposit and allocate to their accounts within a single transaction. Within the function, it calls the `depositForPartyB` function followed by the `allocateForPartyB` function. The function passes the same `amount` into both the `depositForPartyB` and `allocateForPartyB` functions. However, the problem is that one accepts `amount` in native precision (e.g. 6 decimals) while the other accepts `amount` in scaled decimals (e.g. 18 decimals).\n\nAssume that Alice calls the `depositAndAllocateForPartyB` function and intends to deposit and allocate 1000 USDC. Thus, she set the `amount` of the `depositAndAllocateForPartyB` function to `1000e6` as the precision of USDC is `6`.\n\nThe `depositForPartyB` function at Line 78 will work as intended because it will automatically be scaled up to internal accounting precision (18 decimals) within the function, and 1000 USDC will be deposited to her account.\n\nThe `allocateForPartyB` at Line 79 will not work as intended. The function expects the `amount` to be in internal accounting precision (18 decimals), but an `amount` in native precision (6 decimals for USDC) is passed in. As a result, only 0.000000001 USDC will be allocated to her account.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/Account/AccountFacet.sol#L74\n\n```solidity\nFile: AccountFacet.sol\n74:     function depositAndAllocateForPartyB(\n75:         uint256 amount,\n76:         address partyA\n77:     ) external whenNotPartyBActionsPaused onlyPartyB {\n78:         AccountFacetImpl.depositForPartyB(amount);\n79:         AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n80:         emit DepositForPartyB(msg.sender, amount);\n81:         emit AllocateForPartyB(msg.sender, partyA, amount);\n82:     }\n```\n\n## Impact\n\nAny users or external protocols utilizing the `depositAndAllocateForPartyB` to allocate 1000 USDC will end up only having 0.000000001 USDC allocated to their account, which might potentially lead to unexpected loss of funds due to the broken functionality if they rely on the accuracy of the outcome to perform certain actions dealing with funds/assets.\n\nFor instance, Bob's account is close to being liquidated. Thus, he might call the `depositAndAllocateForPartyB` function in an attempt to increase its allocated balance and improve its account health level to avoid being liquidated. However, the `depositAndAllocateForPartyB` is not working as expected, and its allocated balance only increased by a very small amount (e.g. 0.000000001 USDC in our example). Bob believed that his account was healthy, but in reality, his account was still in danger as it only increased by 0.000000001 USDC. In the next one or two blocks, the price swung, and Bob's account was liquidated.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/Account/AccountFacet.sol#L74\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nScale the `amount` to internal accounting precision (18 decimals) before passing it to the `allocateForPartyB` function.\n\n```diff\nfunction depositAndAllocateForPartyB(\n    uint256 amount,\n    address partyA\n) external whenNotPartyBActionsPaused onlyPartyB {\n    AccountFacetImpl.depositForPartyB(amount);\n+    uint256 amountWith18Decimals = (amount * 1e18) /\n+    (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n-    AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n+    AccountFacetImpl.allocateForPartyB(amountWith18Decimals, partyA, true);\n    emit DepositForPartyB(msg.sender, amount);\n    emit AllocateForPartyB(msg.sender, partyA, amount);\n}\n```\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 usdc\nThis report describes the scenario regarding the loss of funds: PartyB, which should not have been liquidated, was liquidated due to this issue. Many dups don't recognize this impact. Normally, it just wastes the caller's gas. According to Duplication rules, these reports should be downgraded. They are: #3, #21, #120, #133, #174, #183, #285.\n#153 describes PartyA, a different problem. This should be invalid.\n\n**sherlock-admin2**\n\n > Escalate for 10 usdc\n> This report describes the scenario regarding the loss of funds: PartyB, which should not have been liquidated, was liquidated due to this issue. Many dups don't recognize this impact. Normally, it just wastes the caller's gas. According to Duplication rules, these reports should be downgraded. They are: #3, #21, #120, #133, #174, #183, #285.\n> #153 describes PartyA, a different problem. This should be invalid.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**panprog**\n\nEscalate\n\nThis should be valid medium, not high. \n\nThere is no material loss of funds: funds are in the user account, just don't make it to the allocated balance, which can be easily fixed by allocating. The scenario described is quite unlikely: the partyB has to deposit just a few blocks before being liquidated which is not what users normally do. If such situation happens due to large price movement, then there is a higher probability that user is liquidated due to network congestion and being unable to deposit in time, rather than due to this bug. In all the other circumstances the user should have enough time to notice lack of allocated balance and react appropriately.\n\nSince loss of funds is possible but not very likely, this should be medium.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should be valid medium, not high. \n> \n> There is no material loss of funds: funds are in the user account, just don't make it to the allocated balance, which can be easily fixed by allocating. The scenario described is quite unlikely: the partyB has to deposit just a few blocks before being liquidated which is not what users normally do. If such situation happens due to large price movement, then there is a higher probability that user is liquidated due to network congestion and being unable to deposit in time, rather than due to this bug. In all the other circumstances the user should have enough time to notice lack of allocated balance and react appropriately.\n> \n> Since loss of funds is possible but not very likely, this should be medium.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**xiaoming9090**\n\nEscalate\n\nThe feature (`depositAndAllocateForPartyB`) provided by the protocol is fundamentally broken. When users aim to allocate 1000 USDC, the system allocates only 0.000000001 USDC to their account, which is a negligible amount. The caller of the `depositAndAllocateForPartyB` function expects the function to perform as intended, and we cannot assume that every caller (can be a person or smart contract/external protocol) will go back and verify whether their allocated balance has correctly increased after each use.\n\nLiquidations frequently occur in the real world, particularly within large protocols (e.g. Compound, AAVE). Assuming that one of their deposit functions has a bug where deposited assets fail to increase the account's collateral level appropriately, it is certain that their users and external protocols that integrate with them will be unfairly liquidated, suffering a loss. The same applies here. Thus, it should be considered of High severity.\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> The feature (`depositAndAllocateForPartyB`) provided by the protocol is fundamentally broken. When users aim to allocate 1000 USDC, the system allocates only 0.000000001 USDC to their account, which is a negligible amount. The caller of the `depositAndAllocateForPartyB` function expects the function to perform as intended, and we cannot assume that every caller (can be a person or smart contract/external protocol) will go back and verify whether their allocated balance has correctly increased after each use.\n> \n> Liquidations frequently occur in the real world, particularly within large protocols (e.g. Compound, AAVE). Assuming that one of their deposit functions has a bug where deposited assets fail to increase the account's collateral level appropriately, it is certain that their users and external protocols that integrate with them will be unfairly liquidated, suffering a loss. The same applies here. Thus, it should be considered of High severity.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\n> The feature (depositAndAllocateForPartyB) provided by the protocol is fundamentally broken. When users aim to allocate 1000 USDC, the system allocates only 0.000000001 USDC to their account, which is a negligible amount.\n\nAgree with senior watson,\n\nthe severity is indeed high because of the broken accounting\n\nwill address securitygrid's escalation seperately\n\n**SergeKireev**\n\nEscalate\n\nThe bug does not cause a loss of funds, but fails to allocate funds.\nAs stated by @panprog the user can simply allocate later with an additional call.\n\nThe scenario described by Lead watson in addition of being highly unlikely as a setup, assumes a user mistake as the trigger:\n> and we cannot assume that every caller (can be a person or smart contract/external protocol) will go back and verify whether their allocated balance has correctly increased after each use. \n\nSeverity should be low\n\n**sherlock-admin2**\n\n > Escalate\n> \n> The bug does not cause a loss of funds, but fails to allocate funds.\n> As stated by @panprog the user can simply allocate later with an additional call.\n> \n> The scenario described by Lead watson in addition of being highly unlikely as a setup, assumes a user mistake as the trigger:\n> > and we cannot assume that every caller (can be a person or smart contract/external protocol) will go back and verify whether their allocated balance has correctly increased after each use. \n> \n> Severity should be low\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/12\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\nThis is a valid high issue. Since the funds need to be allocated to be able to trade, there is a valid error in fund allocation. The function does not work as expected. It is not a user's responsibility to go back and verify the allocations. And there is valid loss of funds because of this. \n\nWhile I can understand the @panprog's argument to make this a medium, I do not think this is a strong enough reason to downgrade this issue. \n> In all the other circumstances the user should have enough time to notice lack of allocated balance and react appropriately.\n\nIn addition to the points mentioned above agree with @xiaoming9090's points here:\n> Liquidations frequently occur in the real world, particularly within large protocols (e.g. Compound, AAVE). Assuming that one of their deposit functions has a bug where deposited assets fail to increase the account's collateral level appropriately, it is certain that their users and external protocols that integrate with them will be unfairly liquidated, suffering a loss. The same applies here. Thus, it should be considered of High severity.\n\nAlso regarding @securitygrid's escalation, although agree with the points, the issues mentioned will still be considered duplicates because of the [duplication rules](https://docs.sherlock.xyz/audits/judging/judging#duplication-rules)\nAgree on #153 not being a duplicate as it does not clearly identify the core issue.\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [securitygrid](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/222/#issuecomment-1651492715): accepted\n- [xiaoming9090](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/222/#issuecomment-1653365144): accepted\n- [panprog](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/222/#issuecomment-1652993001): rejected\n- [SergeKireev](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/222/#issuecomment-1653525190): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/Account/AccountFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\n\nlibrary AccountFacetImpl {\n    using SafeERC20 for IERC20;\n\n    function deposit(address user, uint256 amount) internal {\n        GlobalAppStorage.Layout storage appLayout = GlobalAppStorage.layout();\n        IERC20(appLayout.collateral).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(appLayout.collateral).decimals());\n        AccountStorage.layout().balances[user] += amountWith18Decimals;\n    }\n\n    function withdraw(address user, uint256 amount) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        GlobalAppStorage.Layout storage appLayout = GlobalAppStorage.layout();\n        require(\n            block.timestamp >=\n            accountLayout.withdrawCooldown[msg.sender] + MAStorage.layout().deallocateCooldown,\n            \"AccountFacet: Cooldown hasn't reached\"\n        );\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(appLayout.collateral).decimals());\n        accountLayout.balances[msg.sender] -= amountWith18Decimals;\n        IERC20(appLayout.collateral).safeTransfer(user, amount);\n    }\n\n    function allocate(uint256 amount) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            accountLayout.allocatedBalances[msg.sender] + amount <=\n            GlobalAppStorage.layout().balanceLimitPerUser,\n            \"AccountFacet: Allocated balance limit reached\"\n        );\n        require(accountLayout.balances[msg.sender] >= amount, \"AccountFacet: Insufficient balance\");\n        accountLayout.partyANonces[msg.sender] += 1;\n        accountLayout.balances[msg.sender] -= amount;\n        accountLayout.allocatedBalances[msg.sender] += amount;\n    }\n\n    function deallocate(uint256 amount, SingleUpnlSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            accountLayout.allocatedBalances[msg.sender] >= amount,\n            \"AccountFacet: Insufficient allocated Balance\"\n        );\n        LibMuon.verifyPartyAUpnl(upnlSig, msg.sender);\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance >= 0, \"AccountFacet: Available balance is lower than zero\");\n        require(uint256(availableBalance) >= amount, \"AccountFacet: partyA will be liquidatable\");\n\n        accountLayout.partyANonces[msg.sender] += 1;\n        accountLayout.allocatedBalances[msg.sender] -= amount;\n        accountLayout.balances[msg.sender] += amount;\n        accountLayout.withdrawCooldown[msg.sender] = block.timestamp;\n    }\n\n    function transferAllocation(\n        uint256 amount,\n        address origin,\n        address recipient,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][origin],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][recipient],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        // deallocate from origin\n        require(\n            accountLayout.partyBAllocatedBalances[msg.sender][origin] >= amount,\n            \"PartyBFacet: Insufficient locked balance\"\n        );\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, origin);\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnlSig.upnl,\n            msg.sender,\n            origin\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(uint256(availableBalance) >= amount, \"PartyBFacet: Will be liquidatable\");\n\n        accountLayout.partyBNonces[msg.sender][origin] += 1;\n        accountLayout.partyBAllocatedBalances[msg.sender][origin] -= amount;\n        // allocate for recipient\n        accountLayout.partyBNonces[msg.sender][recipient] += 1;\n        accountLayout.partyBAllocatedBalances[msg.sender][recipient] += amount;\n    }\n\n    function depositForPartyB(uint256 amount) internal {\n        IERC20(GlobalAppStorage.layout().collateral).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n        AccountStorage.layout().balances[msg.sender] += amountWith18Decimals;\n    }\n\n    function allocateForPartyB(uint256 amount, address partyA, bool increaseNonce) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        require(accountLayout.balances[msg.sender] >= amount, \"PartyBFacet: Insufficient balance\");\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[msg.sender][partyA],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        if (increaseNonce) {\n            accountLayout.partyBNonces[msg.sender][partyA] += 1;\n        }\n        accountLayout.balances[msg.sender] -= amount;\n        accountLayout.partyBAllocatedBalances[msg.sender][partyA] += amount;\n    }\n\n    function deallocateForPartyB(\n        uint256 amount,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            accountLayout.partyBAllocatedBalances[msg.sender][partyA] >= amount,\n            \"PartyBFacet: Insufficient locked balance\"\n        );\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnlSig.upnl,\n            msg.sender,\n            partyA\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(uint256(availableBalance) >= amount, \"PartyBFacet: Will be liquidatable\");\n\n        accountLayout.partyBNonces[msg.sender][partyA] += 1;\n        accountLayout.partyBAllocatedBalances[msg.sender][partyA] -= amount;\n        accountLayout.balances[msg.sender] += amount;\n        accountLayout.withdrawCooldown[msg.sender] = block.timestamp;\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/Account/AccountFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\n\nlibrary AccountFacetImpl {\n    using SafeERC20 for IERC20;\n\n    function deposit(address user, uint256 amount) internal {\n        GlobalAppStorage.Layout storage appLayout = GlobalAppStorage.layout();\n        IERC20(appLayout.collateral).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(appLayout.collateral).decimals());\n        AccountStorage.layout().balances[user] += amountWith18Decimals;\n    }\n\n    function withdraw(address user, uint256 amount) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        GlobalAppStorage.Layout storage appLayout = GlobalAppStorage.layout();\n        require(\n            block.timestamp >=\n            accountLayout.withdrawCooldown[msg.sender] + MAStorage.layout().deallocateCooldown,\n            \"AccountFacet: Cooldown hasn't reached\"\n        );\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(appLayout.collateral).decimals());\n        accountLayout.balances[msg.sender] -= amountWith18Decimals;\n        IERC20(appLayout.collateral).safeTransfer(user, amount);\n    }\n\n    function allocate(uint256 amount) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            accountLayout.allocatedBalances[msg.sender] + amount <=\n            GlobalAppStorage.layout().balanceLimitPerUser,\n            \"AccountFacet: Allocated balance limit reached\"\n        );\n        require(accountLayout.balances[msg.sender] >= amount, \"AccountFacet: Insufficient balance\");\n        accountLayout.partyANonces[msg.sender] += 1;\n        accountLayout.balances[msg.sender] -= amount;\n        accountLayout.allocatedBalances[msg.sender] += amount;\n    }\n\n    function deallocate(uint256 amount, SingleUpnlSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            accountLayout.allocatedBalances[msg.sender] >= amount,\n            \"AccountFacet: Insufficient allocated Balance\"\n        );\n        LibMuon.verifyPartyAUpnl(upnlSig, msg.sender);\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance >= 0, \"AccountFacet: Available balance is lower than zero\");\n        require(uint256(availableBalance) >= amount, \"AccountFacet: partyA will be liquidatable\");\n\n        accountLayout.partyANonces[msg.sender] += 1;\n        accountLayout.allocatedBalances[msg.sender] -= amount;\n        accountLayout.balances[msg.sender] += amount;\n        accountLayout.withdrawCooldown[msg.sender] = block.timestamp;\n    }\n\n    function transferAllocation(\n        uint256 amount,\n        address origin,\n        address recipient,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][origin],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][recipient],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        // deallocate from origin\n        require(\n            accountLayout.partyBAllocatedBalances[msg.sender][origin] >= amount,\n            \"PartyBFacet: Insufficient locked balance\"\n        );\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, origin);\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnlSig.upnl,\n            msg.sender,\n            origin\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(uint256(availableBalance) >= amount, \"PartyBFacet: Will be liquidatable\");\n\n        accountLayout.partyBNonces[msg.sender][origin] += 1;\n        accountLayout.partyBAllocatedBalances[msg.sender][origin] -= amount;\n        // allocate for recipient\n        accountLayout.partyBNonces[msg.sender][recipient] += 1;\n        accountLayout.partyBAllocatedBalances[msg.sender][recipient] += amount;\n    }\n\n    function depositForPartyB(uint256 amount) internal {\n        IERC20(GlobalAppStorage.layout().collateral).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n        AccountStorage.layout().balances[msg.sender] += amountWith18Decimals;\n    }\n\n    function allocateForPartyB(uint256 amount, address partyA, bool increaseNonce) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        require(accountLayout.balances[msg.sender] >= amount, \"PartyBFacet: Insufficient balance\");\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[msg.sender][partyA],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        if (increaseNonce) {\n            accountLayout.partyBNonces[msg.sender][partyA] += 1;\n        }\n        accountLayout.balances[msg.sender] -= amount;\n        accountLayout.partyBAllocatedBalances[msg.sender][partyA] += amount;\n    }\n\n    function deallocateForPartyB(\n        uint256 amount,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            accountLayout.partyBAllocatedBalances[msg.sender][partyA] >= amount,\n            \"PartyBFacet: Insufficient locked balance\"\n        );\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnlSig.upnl,\n            msg.sender,\n            partyA\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(uint256(availableBalance) >= amount, \"PartyBFacet: Will be liquidatable\");\n\n        accountLayout.partyBNonces[msg.sender][partyA] += 1;\n        accountLayout.partyBAllocatedBalances[msg.sender][partyA] -= amount;\n        accountLayout.balances[msg.sender] += amount;\n        accountLayout.withdrawCooldown[msg.sender] = block.timestamp;\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/Account/AccountFacet.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../utils/Accessibility.sol\";\nimport \"../../utils/Pausable.sol\";\nimport \"./IAccountEvents.sol\";\nimport \"./AccountFacetImpl.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\n\ncontract AccountFacet is Accessibility, Pausable, IAccountEvents {\n\n    //Party A\n    function deposit(uint256 amount) external whenNotAccountingPaused {\n        AccountFacetImpl.deposit(msg.sender, amount);\n        emit Deposit(msg.sender, msg.sender, amount);\n    }\n\n    function depositFor(address user, uint256 amount) external whenNotAccountingPaused {\n        AccountFacetImpl.deposit(user, amount);\n        emit Deposit(msg.sender, user, amount);\n    }\n\n    function withdraw(uint256 amount) external whenNotAccountingPaused notSuspended(msg.sender) {\n        AccountFacetImpl.withdraw(msg.sender, amount);\n        emit Withdraw(msg.sender, msg.sender, amount);\n    }\n\n    function withdrawTo(\n        address user,\n        uint256 amount\n    ) external whenNotAccountingPaused notSuspended(msg.sender) {\n        AccountFacetImpl.withdraw(user, amount);\n        emit Withdraw(msg.sender, user, amount);\n    }\n\n    function allocate(\n        uint256 amount\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.allocate(amount);\n        emit AllocatePartyA(msg.sender, amount);\n    }\n\n    function depositAndAllocate(\n        uint256 amount\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.deposit(msg.sender, amount);\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n        AccountFacetImpl.allocate(amountWith18Decimals);\n        emit Deposit(msg.sender, msg.sender, amount);\n        emit AllocatePartyA(msg.sender, amountWith18Decimals);\n    }\n\n    function deallocate(\n        uint256 amount,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.deallocate(amount, upnlSig);\n        emit DeallocatePartyA(msg.sender, amount);\n    }\n\n    // PartyB\n    function allocateForPartyB(\n        uint256 amount,\n        address partyA\n    ) public whenNotPartyBActionsPaused notLiquidatedPartyB(msg.sender, partyA) onlyPartyB {\n        AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n        emit AllocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function depositAndAllocateForPartyB(\n        uint256 amount,\n        address partyA\n    ) external whenNotPartyBActionsPaused onlyPartyB {\n        AccountFacetImpl.depositForPartyB(amount);\n        AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n        emit DepositForPartyB(msg.sender, amount);\n        emit AllocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function deallocateForPartyB(\n        uint256 amount,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused notLiquidatedPartyB(msg.sender, partyA) onlyPartyB {\n        AccountFacetImpl.deallocateForPartyB(amount, partyA, upnlSig);\n        emit DeallocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function depositForPartyB(uint256 amount) external whenNotPartyBActionsPaused onlyPartyB {\n        AccountFacetImpl.depositForPartyB(amount);\n        emit DepositForPartyB(msg.sender, amount);\n    }\n\n    function transferAllocation(\n        uint256 amount,\n        address origin,\n        address recipient,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused {\n        AccountFacetImpl.transferAllocation(amount, origin, recipient, upnlSig);\n        emit TransferAllocation(amount, origin, recipient);\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/Account/AccountFacet.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../utils/Accessibility.sol\";\nimport \"../../utils/Pausable.sol\";\nimport \"./IAccountEvents.sol\";\nimport \"./AccountFacetImpl.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\n\ncontract AccountFacet is Accessibility, Pausable, IAccountEvents {\n\n    //Party A\n    function deposit(uint256 amount) external whenNotAccountingPaused {\n        AccountFacetImpl.deposit(msg.sender, amount);\n        emit Deposit(msg.sender, msg.sender, amount);\n    }\n\n    function depositFor(address user, uint256 amount) external whenNotAccountingPaused {\n        AccountFacetImpl.deposit(user, amount);\n        emit Deposit(msg.sender, user, amount);\n    }\n\n    function withdraw(uint256 amount) external whenNotAccountingPaused notSuspended(msg.sender) {\n        AccountFacetImpl.withdraw(msg.sender, amount);\n        emit Withdraw(msg.sender, msg.sender, amount);\n    }\n\n    function withdrawTo(\n        address user,\n        uint256 amount\n    ) external whenNotAccountingPaused notSuspended(msg.sender) {\n        AccountFacetImpl.withdraw(user, amount);\n        emit Withdraw(msg.sender, user, amount);\n    }\n\n    function allocate(\n        uint256 amount\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.allocate(amount);\n        emit AllocatePartyA(msg.sender, amount);\n    }\n\n    function depositAndAllocate(\n        uint256 amount\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.deposit(msg.sender, amount);\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n        AccountFacetImpl.allocate(amountWith18Decimals);\n        emit Deposit(msg.sender, msg.sender, amount);\n        emit AllocatePartyA(msg.sender, amountWith18Decimals);\n    }\n\n    function deallocate(\n        uint256 amount,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.deallocate(amount, upnlSig);\n        emit DeallocatePartyA(msg.sender, amount);\n    }\n\n    // PartyB\n    function allocateForPartyB(\n        uint256 amount,\n        address partyA\n    ) public whenNotPartyBActionsPaused notLiquidatedPartyB(msg.sender, partyA) onlyPartyB {\n        AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n        emit AllocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function depositAndAllocateForPartyB(\n        uint256 amount,\n        address partyA\n    ) external whenNotPartyBActionsPaused onlyPartyB {\n        AccountFacetImpl.depositForPartyB(amount);\n        AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n        emit DepositForPartyB(msg.sender, amount);\n        emit AllocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function deallocateForPartyB(\n        uint256 amount,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused notLiquidatedPartyB(msg.sender, partyA) onlyPartyB {\n        AccountFacetImpl.deallocateForPartyB(amount, partyA, upnlSig);\n        emit DeallocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function depositForPartyB(uint256 amount) external whenNotPartyBActionsPaused onlyPartyB {\n        AccountFacetImpl.depositForPartyB(amount);\n        emit DepositForPartyB(msg.sender, amount);\n    }\n\n    function transferAllocation(\n        uint256 amount,\n        address origin,\n        address recipient,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused {\n        AccountFacetImpl.transferAllocation(amount, origin, recipient, upnlSig);\n        emit TransferAllocation(amount, origin, recipient);\n    }\n}"
    }
  ]
}