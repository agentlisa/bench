{
  "Title": "[M05] Asset price can be reset by owner",
  "Content": "The [`addStableCoin` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L47) of the `HoldefiPrices` contract is used to introduce new token prices to the Holdefi system with an initial price of [`priceDecimal`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L16), that will later be used for performing sensible operations such as [withdrawing collaterals](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L270), [borrowing market assets](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L308), and [liquidating a borrowerâ€™s collateral](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L434) on the `Holdefi` contract.\n\n\nThe problem resides in that the `addStableCoin` function does not check whether an asset has already been added to the system or not, leading to scenarios where the owner of the contract could reset its value by calling this function multiple times, overwriting the current price of a given asset with the initial `priceDecimal` value.\n\n\nConsider checking whether a given asset price has already been added to the system by checking its existence in the [`assetPrices` mapping](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L47) before calling the `setPrice` function inside the `addStableCoin` function.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/HoldefiPrices.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\ninterface ETHMedianizerInterface {\r\n\r\n   function read() external view returns(uint price);\r\n}\r\n\r\n //This contract will be changed before adding ERC20 tokens that are not stable coin\r\ncontract HoldefiPrices is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint constant public priceDecimal = 10**18;\r\n   \r\n    mapping(address => uint) public assetPrices;\r\n\r\n    ETHMedianizerInterface public ethMedianizer;\r\n\r\n    event PriceChanged(address asset, uint newPrice);\r\n\r\n    constructor(address newOwnerChanger, ETHMedianizerInterface ethMedianizerContract) public Ownable(newOwnerChanger) {\r\n        ethMedianizer = ethMedianizerContract;\r\n    }\r\n\r\n    // Returns price of selected asset\r\n    function getPrice(address asset) external view returns(uint price) {\r\n    \tif (asset == address(0)){\r\n    \t\tprice = uint(ethMedianizer.read());\r\n    \t}\r\n        else {\r\n            price = assetPrices[asset];\r\n        }\r\n    }\r\n\r\n     // TODO: This function should be internal for the first version of priceFeed\r\n    function setPrice(address asset, uint newPrice) public onlyOwner {\r\n        require (asset != address(0),'Price of ETH can not be changed');\r\n\r\n        assetPrices[asset] = newPrice;\r\n        emit PriceChanged(asset, newPrice);\r\n    }\r\n\r\n    // Called by owner to add new stable token at 1$ price\r\n    function addStableCoin(address asset) public onlyOwner {\r\n        setPrice(asset, priceDecimal);\r\n    }\r\n    \r\n    function() payable external {\r\n        revert();\r\n    }\r\n}"
    },
    {
      "filename": "contracts/HoldefiPrices.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\ninterface ETHMedianizerInterface {\r\n\r\n   function read() external view returns(uint price);\r\n}\r\n\r\n //This contract will be changed before adding ERC20 tokens that are not stable coin\r\ncontract HoldefiPrices is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint constant public priceDecimal = 10**18;\r\n   \r\n    mapping(address => uint) public assetPrices;\r\n\r\n    ETHMedianizerInterface public ethMedianizer;\r\n\r\n    event PriceChanged(address asset, uint newPrice);\r\n\r\n    constructor(address newOwnerChanger, ETHMedianizerInterface ethMedianizerContract) public Ownable(newOwnerChanger) {\r\n        ethMedianizer = ethMedianizerContract;\r\n    }\r\n\r\n    // Returns price of selected asset\r\n    function getPrice(address asset) external view returns(uint price) {\r\n    \tif (asset == address(0)){\r\n    \t\tprice = uint(ethMedianizer.read());\r\n    \t}\r\n        else {\r\n            price = assetPrices[asset];\r\n        }\r\n    }\r\n\r\n     // TODO: This function should be internal for the first version of priceFeed\r\n    function setPrice(address asset, uint newPrice) public onlyOwner {\r\n        require (asset != address(0),'Price of ETH can not be changed');\r\n\r\n        assetPrices[asset] = newPrice;\r\n        emit PriceChanged(asset, newPrice);\r\n    }\r\n\r\n    // Called by owner to add new stable token at 1$ price\r\n    function addStableCoin(address asset) public onlyOwner {\r\n        setPrice(asset, priceDecimal);\r\n    }\r\n    \r\n    function() payable external {\r\n        revert();\r\n    }\r\n}"
    }
  ]
}