{
  "Title": "[M-07] Unchecked return value bug on `TransferHelper::_safeTransferFrom()`",
  "Content": "\nCurrently, the `WiseLending` protocol supports several ERC-20 tokens and will also support more tokens in the future:\n\n> *ERC20 in scope: WETH, WBTC, LINK, DAI, WstETH, sDAI, USDC, USDT, WISE and may others in the future. (Also corresponding Aave tokens if existing).*\n\nOn some ERC-20 tokens, the [`transferFrom()` will return `false` on failure instead of reverting a transaction](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#no-revert-on-failure). I noticed that the `TransferHelper::_safeTransferFrom()`, which is used throughout the protocol, is vulnerable to detecting the token transfer failure if the `transferFrom()` returns `false` due to the unchecked return value bug.\n\nThe following lists the functions directly invoking the vulnerable `_safeTransferFrom()`:\n\n1. [`WiseCore::_coreLiquidation()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L674-L679)\n2. [`WiseLending::depositExactAmount()]`(https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L476-L481)\n3. [`WiseLending::solelyDeposit()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L622-L627)\n4. [`WiseLending::paybackExactAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L1190-L1195)\n5. [`WiseLending::paybackExactShares()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L1230-L1235)\n6. [`FeeManager::paybackBadDebtForToken()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L788-L793)\n7. [`FeeManager::paybackBadDebtNoReward()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L860-L865)\n8. [`PendlePowerFarm::_manuallyPaybackShares()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarm.sol#L136-L141)\n9. [`PendlePowerManager::enterFarm()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarm/PendlePowerManager.sol#L109-L114)\n10. [`PendlePowerFarmController::exchangeRewardsForCompoundingWithIncentive()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L86-L91)\n11. [`PendlePowerFarmController::exchangeLpFeesForPendleWithIncentive()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L142-L147)\n12. [`PendlePowerFarmController::lockPendle()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L397-L402)\n13. [`PendlePowerFarmToken::addCompoundRewards()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L518-L523)\n14. [`PendlePowerFarmToken::depositExactAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L579-L584)\n15. [`AaveHub::depositExactAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WrapperHub/AaveHub.sol#L132-L137)\n16. [`AaveHub::paybackExactAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WrapperHub/AaveHub.sol#L451-L456)\n17. [`AaveHub::paybackExactShares()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WrapperHub/AaveHub.sol#L583-L588)\n\nDue to the unchecked return value bug, users or attackers can exploit these protocol's functions without supplying a token (please refer to the `Proof of Concept` section for more details).\n\n### Proof of Concept\n\n> On some ERC-20 tokens, the [`transferFrom()` will return false on failure instead of reverting a transaction](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#no-revert-on-failure).\n\nThe `WiseLending` protocol implements the `TransferHub::_callOptionalReturn()` as a helper function for executing low-level calls. In case the `transferFrom()` returns `false` on failure, the `_callOptionalReturn()` will receive the returned parameters: [`success` `==` true and `returndata` `!=` `bytes(0)`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L21).\n\nThen, the `_callOptionalReturn()` will decode the received `returndata` for the success status. If the `transferFrom()` returns `false`, the [results will become `false`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L26-L29).\n\nWith the `results` `==` `false`, finally, the `_callOptionalReturn()` will [return `false` to its function caller](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L35-L37).\n\nOn the `TransferHelper::_safeTransferFrom()`, I noticed that the function [does not evaluate the return value](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/TransferHelper.sol#L42) (i.e., unchecked return value bug) of the `_callOptionalReturn()`. Subsequently, the `_safeTransferFrom()` cannot detect the token transfer failure if the `transferFrom()` returns `false`.\n\n```solidity\n    // FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol\n    function _callOptionalReturn(\n        address token,\n        bytes memory data\n    )\n        internal\n        returns (bool call)\n    {\n        (\n            bool success,\n@1          bytes memory returndata //@audit -- On some tokens, the transferFrom() will return false instead of reverting a transaction\n        ) = token.call(\n            data\n        );\n\n@2      bool results = returndata.length == 0 || abi.decode(\n@2          returndata, //@audit -- If the transferFrom() returns false, the results == false\n@2          (bool)\n@2      );\n\n        if (success == false) {\n            revert();\n        }\n\n@3      call = success\n@3          && results // @audit -- If the results == false, the _callOptionalReturn() will return false\n@3          && token.code.length > 0;\n    }\n\n    ...\n\n    // FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/TransferHelper.sol\n    function _safeTransferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n@4      _callOptionalReturn( //@audit -- The _safeTransferFrom() cannot detect the token transfer failure if the transferFrom() returns false instead of reverting a transaction due to the unchecked return value bug\n            _token,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                _from,\n                _to,\n                _value\n            )\n        );\n    }\n```\n\n`@1 -- On some tokens, the transferFrom() will return false instead of reverting a transaction`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L21>).\n\n`@2 -- If the transferFrom() returns false, the results == false`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L26-L29>).\n\n`@3 -- If the results == false, the _callOptionalReturn() will return false`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/CallOptionalReturn.sol#L35-L37>).\n\n`@4 -- The _safeTransferFrom() cannot detect the token transfer failure if the transferFrom() returns false instead of reverting a transaction due to the unchecked return value bug`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/TransferHelper.sol#L42>).\n\nNote: Please refer to the `Impact` section for a complete list of the functions directly invoking the vulnerable `_safeTransferFrom()`.\n\nThe following briefly analyzes 2 of the 17 functions that would affect the exploitation as examples:\n\n- Due to the unchecked return value bug, the [`WiseCore::_coreLiquidation()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L674-L679) cannot be aware of the token transfer failure. Thus, a rogue liquidator can steal collateral from the target liquidable position without supplying any debt token (`tokenToPayback`).\n\n- On the [`WiseLending::depositExactAmount()`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L476-L481), a rogue depositor can increase their collateral without spending any token.\n\n```solidity\n    // FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol\n    function _coreLiquidation(\n        CoreLiquidationStruct memory _data\n    )\n        internal\n        returns (uint256 receiveAmount)\n    {\n        ...\n\n@5      _safeTransferFrom( //@audit -- Liquidator can steal collateral (_receiveToken) from the target liquidable position\n@5          _data.tokenToPayback,\n@5          _data.caller,\n@5          address(this),\n@5          _data.paybackAmount\n@5      );\n\n        ...\n    }\n\n    ...\n\n    // FILE: https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol\n    function depositExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n@6      _safeTransferFrom( //@audit -- Depositor can increase their collateral without supplying any token\n@6          _poolToken,\n@6          msg.sender,\n@6          address(this),\n@6          _amount\n@6      );\n\n        return shareAmount;\n    }\n```\n\n`@5 -- Liquidator can steal collateral (_receiveToken) from the target liquidable position`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseCore.sol#L674-L679>).\n\n`@6 -- Depositor can increase their collateral without supplying any token`: see [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L476-L481>).\n\n### Recommended Mitigation Steps\n\nImprove the `_safeTransferFrom()` by checking the return value from the `_callOptionalReturn()` and reverting a transaction if it is `false`.\n\n```diff\n    function _safeTransferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n-       _callOptionalReturn(\n+       bool success = _callOptionalReturn(\n            _token,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                _from,\n                _to,\n                _value\n            )\n        );\n\n+       require(success, \"Token transfer failed\");\n    }\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/245#issuecomment-2032204776):**\n > This then leads to some tokens unusable (like USDT, for example) and this topic was already discussed severely during hats competition where I can send links to findings, so should be scraped in my opinion. Also sufficient checks are already done in `_callOptionalReturn` directly.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/245#issuecomment-2090406869):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n> \n> Additionally, `WiseLending` is not meant to be used with corrupted tokens that have unsupported transfer/transferFrom implementations.\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseCore.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./MainHelper.sol\";\nimport \"./TransferHub/TransferHelper.sol\";\n\nabstract contract WiseCore is MainHelper, TransferHelper {\n\n    /**\n     * @dev Wrapper function combining pool\n     * preparations for borrow and collaterals.\n     * Bypassed when called by powerFarms.\n     */\n    function _prepareAssociatedTokens(\n        uint256 _nftId,\n        address _poolTokenLend,\n        address _poolTokenBorrow\n    )\n        internal\n        returns (\n            address[] memory,\n            address[] memory\n        )\n    {\n        return (\n            _preparationTokens(\n                positionLendTokenData,\n                _nftId,\n                _poolTokenLend\n            ),\n            _preparationTokens(\n                positionBorrowTokenData,\n                _nftId,\n                _poolTokenBorrow\n            )\n        );\n    }\n\n    /**\n     * @dev Core function combining withdraw\n     * logic and security checks.\n     */\n    function _coreWithdrawToken(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares,\n        bool _onBehalf\n    )\n        internal\n    {\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        powerFarmCheck = WISE_SECURITY.checksWithdraw(\n            _nftId,\n            _caller,\n            _poolToken\n        );\n\n        _coreWithdrawBare(\n            _nftId,\n            _poolToken,\n            _amount,\n            _shares\n        );\n\n        if (_onBehalf == true) {\n            emit FundsWithdrawnOnBehalf(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        } else {\n            emit FundsWithdrawn(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        }\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    /**\n     * @dev Internal function combining deposit\n     * logic, security checks and event emit.\n     */\n    function _handleDeposit(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 shareAmount = calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _amount,\n                _maxSharePrice: false\n            }\n        );\n\n        _validateNonZero(\n            shareAmount\n        );\n\n        _checkDeposit(\n            _nftId,\n            _caller,\n            _poolToken,\n            _amount\n        );\n\n        _increasePositionLendingDeposit(\n            _nftId,\n            _poolToken,\n            shareAmount\n        );\n\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            shareAmount,\n            _increaseTotalPool,\n            _increasePseudoTotalPool,\n            _increaseTotalDepositShares\n        );\n\n        _addPositionTokenData(\n            _nftId,\n            _poolToken,\n            hashMapPositionLending,\n            positionLendTokenData\n        );\n\n        emit FundsDeposited(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            shareAmount,\n            block.timestamp\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev External wrapper for\n     * {_checkPositionLocked}.\n     */\n\n    function checkPositionLocked(\n        uint256 _nftId,\n        address _caller\n    )\n        external\n        view\n    {\n        _checkPositionLocked(\n            _nftId,\n            _caller\n        );\n    }\n\n    /**\n     * @dev Checks if a postion is locked\n     * for powerFarms. Get skipped when\n     * aaveHub or a powerFarm itself is\n     * the {msg.sender}.\n     */\n\n    function _checkPositionLocked(\n        uint256 _nftId,\n        address _caller\n    )\n        internal\n        view\n    {\n        if (_byPassCase(_caller) == true) {\n            return;\n        }\n\n        if (positionLocked[_nftId] == false) {\n            return;\n        }\n\n        revert PositionLocked();\n    }\n\n    /**\n     * @dev External wrapper for\n     * {_checkDeposit}.\n     */\n    function checkDeposit(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        view\n    {\n        _checkDeposit(\n            _nftId,\n            _caller,\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Internal function including\n     * security checks for deposit logic.\n     */\n    function _checkDeposit(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        view\n    {\n\n        if (WISE_ORACLE.chainLinkIsDead(_poolToken) == true) {\n            revert DeadOracle();\n        }\n\n        _checkAllowDeposit(\n            _nftId,\n            _caller\n        );\n\n        _checkPositionLocked(\n            _nftId,\n            _caller\n        );\n\n        WISE_SECURITY.checkPoolWithMinDeposit(\n            _poolToken,\n            _amount\n        );\n\n        _checkMaxDepositValue(\n            _poolToken,\n            _amount\n        );\n    }\n\n    function _checkAllowDeposit(\n        uint256 _nftId,\n        address _caller\n    )\n        internal\n        view\n    {\n        if (_caller == AAVE_HUB_ADDRESS) {\n            return;\n        }\n\n        if (POSITION_NFT.isOwner(_nftId, _caller) == true) {\n            return;\n        }\n\n        revert InvalidAction();\n    }\n\n    /**\n     * @dev Internal function checking\n     * if the deposit amount for the\n     * pool token is reached.\n     */\n    function _checkMaxDepositValue(\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n        view\n    {\n        bool state = maxDepositValueToken[_poolToken]\n            < globalPoolData[_poolToken].totalBareToken\n            + lendingPoolData[_poolToken].pseudoTotalPool\n            + _amount;\n\n        if (state == true) {\n            revert InvalidAction();\n        }\n    }\n\n    /**\n     * @dev Low level core function combining\n     * pure withdraw math (without security\n     * checks).\n     */\n    function _coreWithdrawBare(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares\n    )\n        private\n    {\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            _shares,\n            _decreaseTotalPool,\n            _decreasePseudoTotalPool,\n            _decreaseTotalDepositShares\n        );\n\n        _decreaseLendingShares(\n            _nftId,\n            _poolToken,\n            _shares\n        );\n\n        _removeEmptyLendingData(\n            _nftId,\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Core function combining borrow\n     * logic with security checks.\n     */\n    function _coreBorrowTokens(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares,\n        bool _onBehalf\n    )\n        internal\n    {\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            ZERO_ADDRESS,\n            _poolToken\n        );\n\n        powerFarmCheck = WISE_SECURITY.checksBorrow(\n            _nftId,\n            _caller,\n            _poolToken\n        );\n\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            _shares,\n            _increasePseudoTotalBorrowAmount,\n            _decreaseTotalPool,\n            _increaseTotalBorrowShares\n        );\n\n        _increaseMappingValue(\n            userBorrowShares,\n            _nftId,\n            _poolToken,\n            _shares\n        );\n\n        _addPositionTokenData(\n            _nftId,\n            _poolToken,\n            hashMapPositionBorrow,\n            positionBorrowTokenData\n        );\n\n        if (_onBehalf == true) {\n            emit FundsBorrowedOnBehalf(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        } else {\n            emit FundsBorrowed(\n                _caller,\n                _nftId,\n                _poolToken,\n                _amount,\n                _shares,\n                block.timestamp\n            );\n        }\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    /**\n     * @dev Internal math function for liquidation logic\n     * caluclating amount to withdraw from pure\n     * collateral for liquidation.\n     */\n    function _withdrawPureCollateralLiquidation(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _percentLiquidation\n    )\n        private\n        returns (uint256 transferAmount)\n    {\n        uint256 product = _percentLiquidation\n            * pureCollateralAmount[_nftId][_poolToken];\n\n        transferAmount = product / PRECISION_FACTOR_E18;\n\n        _decreasePositionMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            transferAmount\n        );\n\n        _decreaseTotalBareToken(\n            _poolToken,\n            transferAmount\n        );\n    }\n\n    /**\n     * @dev Internal math function for liquidation logic\n     * which checks if pool has enough token to pay out\n     * liquidator. If not, liquidator get corresponding\n     * shares for later withdraw.\n     */\n    function _withdrawOrAllocateSharesLiquidation(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _poolToken,\n        uint256 _percentWishCollateral\n    )\n        private\n        returns (uint256)\n    {\n        uint256 product = _percentWishCollateral\n            * userLendingData[_nftId][_poolToken].shares;\n\n        uint256 cashoutShares = product / PRECISION_FACTOR_E18 + 1;\n\n        uint256 withdrawAmount = _cashoutAmount(\n            _poolToken,\n            cashoutShares\n        );\n\n        uint256 totalPoolToken = globalPoolData[_poolToken].totalPool;\n\n        if (withdrawAmount <= totalPoolToken) {\n\n            _coreWithdrawBare(\n                _nftId,\n                _poolToken,\n                withdrawAmount,\n                cashoutShares\n            );\n\n            return withdrawAmount;\n        }\n\n        uint256 totalPoolInShares = calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: totalPoolToken,\n                _maxSharePrice: false\n            }\n        );\n\n        uint256 shareDifference = cashoutShares\n            - totalPoolInShares;\n\n        _coreWithdrawBare(\n            _nftId,\n            _poolToken,\n            totalPoolToken,\n            totalPoolInShares\n        );\n\n        _decreaseLendingShares(\n            _nftId,\n            _poolToken,\n            shareDifference\n        );\n\n        _increasePositionLendingDeposit(\n            _nftIdLiquidator,\n            _poolToken,\n            shareDifference\n        );\n\n        _addPositionTokenData(\n            _nftIdLiquidator,\n            _poolToken,\n            hashMapPositionLending,\n            positionLendTokenData\n        );\n\n        _removeEmptyLendingData(\n            _nftId,\n            _poolToken\n        );\n\n        return totalPoolToken;\n    }\n\n    /**\n     * @dev Internal math function combining functionallity\n     * of {_withdrawPureCollateralLiquidation} and\n     * {_withdrawOrAllocateSharesLiquidation}.\n     */\n    function _calculateReceiveAmount(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _receiveTokens,\n        uint256 _removePercentage\n    )\n        private\n        returns (uint256 receiveAmount)\n    {\n        if (pureCollateralAmount[_nftId][_receiveTokens] > 0) {\n            receiveAmount = _withdrawPureCollateralLiquidation(\n                _nftId,\n                _receiveTokens,\n                _removePercentage\n            );\n        }\n\n        uint256 potentialPureExtraCashout;\n        uint256 userShares = userLendingData[_nftId][_receiveTokens].shares;\n        uint256 pureCollateral = pureCollateralAmount[_nftId][_receiveTokens];\n\n        if (pureCollateral > 0 && userShares > 0) {\n            potentialPureExtraCashout = _calculatePotentialPureExtraCashout(\n                userShares,\n                _receiveTokens,\n                _removePercentage\n            );\n        }\n\n        if (potentialPureExtraCashout > 0 && potentialPureExtraCashout <= pureCollateral) {\n            _decreasePositionMappingValue(\n                pureCollateralAmount,\n                _nftId,\n                _receiveTokens,\n                potentialPureExtraCashout\n            );\n\n            _decreaseTotalBareToken(\n                _receiveTokens,\n                potentialPureExtraCashout\n            );\n\n            return receiveAmount + potentialPureExtraCashout;\n        }\n\n        if (userShares == 0) {\n            return receiveAmount;\n        }\n\n        if (userLendingData[_nftId][_receiveTokens].unCollateralized == true) {\n            return receiveAmount;\n        }\n\n        return _withdrawOrAllocateSharesLiquidation(\n            _nftId,\n            _nftIdLiquidator,\n            _receiveTokens,\n            _removePercentage\n        ) + receiveAmount;\n    }\n\n    function _calculatePotentialPureExtraCashout(\n        uint256 _userShares,\n        address _poolToken,\n        uint256 _removePercentage\n    )\n        private\n        view\n        returns (uint256)\n    {\n        return _cashoutAmount(\n            _poolToken,\n            _removePercentage\n                * _userShares\n                / PRECISION_FACTOR_E18\n        );\n    }\n\n    /**\n     * @dev Core liquidation function for\n     * security checks and liquidation math.\n     */\n    function _coreLiquidation(\n        CoreLiquidationStruct memory _data\n    )\n        internal\n        returns (uint256 receiveAmount)\n    {\n        _validateNonZero(\n            _data.paybackAmount\n        );\n\n        uint256 collateralPercentage = WISE_SECURITY.calculateWishPercentage(\n            _data.nftId,\n            _data.tokenToRecieve,\n            WISE_ORACLE.getTokensInETH(\n                _data.tokenToPayback,\n                _data.paybackAmount\n            ),\n            _data.maxFeeETH,\n            _data.baseRewardLiquidation\n        );\n\n        _validateParameter(\n            collateralPercentage,\n            PRECISION_FACTOR_E18\n        );\n\n        _corePayback(\n            _data.nftId,\n            _data.tokenToPayback,\n            _data.paybackAmount,\n            _data.shareAmountToPay\n        );\n\n        receiveAmount = _calculateReceiveAmount(\n            _data.nftId,\n            _data.nftIdLiquidator,\n            _data.tokenToRecieve,\n            collateralPercentage\n        );\n\n        WISE_SECURITY.checkBadDebtLiquidation(\n            _data.nftId\n        );\n\n        _curveSecurityChecks(\n            _data.lendTokens,\n            _data.borrowTokens\n        );\n\n        _safeTransferFrom(\n            _data.tokenToPayback,\n            _data.caller,\n            address(this),\n            _data.paybackAmount\n        );\n\n        _safeTransfer(\n            _data.tokenToRecieve,\n            _data.caller,\n            receiveAmount\n        );\n    }\n}"
    },
    {
      "filename": "contracts/WiseLending.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author RenÃ© Hochmuth\n * @author Christoph Krpoun\n * @author Vitally Marinchenko\n */\n\nimport \"./PoolManager.sol\";\n\n/**\n * @dev WISE lending is an automated lending platform on which users can collateralize\n * their assets and borrow tokens against them.\n *\n * Users need to pay borrow rates for debt tokens, which are reflected in a borrow APY for\n * each asset type (pool). This borrow rate is variable over time and determined through the\n * utilization of the pool. The bounding curve is a family of different bonding curves adjusted\n * automatically by LASA (Lending Automated Scaling Algorithm). For more information, see:\n * [https://wisesoft.gitbook.io/wise/wise-lending-protocol/lasa-ai]\n *\n * In addition to normal deposit, withdraw, borrow, and payback functions, there are other\n * interacting modes:\n *\n * - Solely deposit and withdraw allows the user to keep their funds private, enabling\n *    them to withdraw even when the pools are borrowed empty.\n *\n * - Aave pools  allow for maximal capital efficiency by earning aave supply APY for not\n *   borrowed funds.\n *\n * - Special curve pools nside beefy farms can be used as collateral, opening up new usage\n *   possibilities for these asset types.\n *\n * - Users can pay back their borrow with lending shares of the same asset type, making it\n *   easier to manage their positions.\n *\n * - Users save their collaterals and borrows inside a position NFT, making it possible\n *   to trade their whole positions or use them in second-layer contracts\n *   (e.g., spot trading with PTP NFT trading platforms).\n */\n\ncontract WiseLending is PoolManager {\n\n    /**\n     * @dev Standard receive functions forwarding\n     * directly send ETH to the master address.\n     */\n    receive()\n        external\n        payable\n    {\n        if (msg.sender == WETH_ADDRESS) {\n            return;\n        }\n\n        _sendValue(\n            master,\n            msg.value\n        );\n    }\n\n    /**\n     * @dev Checks if position is healthy\n     * after all state changes are done.\n     */\n    modifier healthStateCheck(\n        uint256 _nftId\n    ) {\n        _;\n\n        _healthStateCheck(\n            _nftId\n        );\n    }\n\n    function _healthStateCheck(\n        uint256 _nftId\n    )\n        private\n    {\n        _checkHealthState(\n            _nftId,\n            powerFarmCheck\n        );\n\n        if (powerFarmCheck == true) {\n            powerFarmCheck = false;\n        }\n    }\n\n    /**\n     * @dev Runs the LASA algorithm known as\n     * Lending Automated Scaling Algorithm\n     * and updates pool data based on token\n     */\n    modifier syncPool(\n        address _poolToken\n    ) {\n        (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        ) = _syncPoolBeforeCodeExecution(\n            _poolToken\n        );\n\n        _;\n\n        _syncPoolAfterCodeExecution(\n            _poolToken,\n            lendSharePrice,\n            borrowSharePrice\n        );\n    }\n\n    constructor(\n        address _master,\n        address _wiseOracleHubAddress,\n        address _nftContract\n    )\n        WiseLendingDeclaration(\n            _master,\n            _wiseOracleHubAddress,\n            _nftContract\n        )\n    {}\n\n    function _emitFundsSolelyWithdrawn(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyWithdrawn(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    function _emitFundsSolelyDeposited(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyDeposited(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Fetches share price of lending shares.\n     */\n    function _getSharePrice(\n        address _poolToken\n    )\n        private\n        view\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        uint256 borrowSharePrice = borrowPoolData[_poolToken].pseudoTotalBorrowAmount\n            * PRECISION_FACTOR_E18\n            / borrowPoolData[_poolToken].totalBorrowShares;\n\n        _validateParameter(\n            MIN_BORROW_SHARE_PRICE,\n            borrowSharePrice\n        );\n\n        return (\n            lendingPoolData[_poolToken].pseudoTotalPool\n                * PRECISION_FACTOR_E18\n                / lendingPoolData[_poolToken].totalDepositShares,\n            borrowSharePrice\n        );\n    }\n\n    function _checkHealthState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n    {\n        WISE_SECURITY.checkHealthState(\n            _nftId,\n            _powerFarm\n        );\n    }\n\n    /**\n     * @dev Compares share prices before and after\n     * execution. If borrow share price increased\n     * or lending share price decreased, revert.\n     */\n    function _compareSharePrices(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n        view\n    {\n        (\n            uint256 lendSharePriceAfter,\n            uint256 borrowSharePriceAfter\n        ) = _getSharePrice(\n            _poolToken\n        );\n\n        uint256 currentSharePriceMax = _getCurrentSharePriceMax(\n            _poolToken\n        );\n\n        _validateParameter(\n            _lendSharePriceBefore,\n            lendSharePriceAfter\n        );\n\n        _validateParameter(\n            lendSharePriceAfter,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            _borrowSharePriceBefore,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            borrowSharePriceAfter,\n            _borrowSharePriceBefore\n        );\n    }\n\n    /**\n    * @dev Since pool inception share price\n    * increase for both lending and borrow shares\n    * is capped at 500% apr max in between a transaction.\n    */\n    function _getCurrentSharePriceMax(\n        address _poolToken\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 timeDifference = block.timestamp\n            - timestampsPoolData[_poolToken].initialTimeStamp;\n\n        return timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n    }\n\n    /**\n     * @dev First part of pool sync updating pseudo\n     * amounts. Is skipped when powerFarms or aaveHub\n     * is calling the function.\n     */\n    function _syncPoolBeforeCodeExecution(\n        address _poolToken\n    )\n        private\n        returns (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        )\n    {\n        _checkReentrancy();\n\n        _preparePool(\n            _poolToken\n        );\n\n        if (_aboveThreshold(_poolToken) == true) {\n            _scalingAlgorithm(\n                _poolToken\n            );\n        }\n\n        (\n            lendSharePrice,\n            borrowSharePrice\n        ) = _getSharePrice(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Second part of pool sync updating\n     * the borrow pool rate and share price.\n     */\n    function _syncPoolAfterCodeExecution(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n    {\n        _newBorrowRate(\n            _poolToken\n        );\n\n        _compareSharePrices(\n            _poolToken,\n            _lendSharePriceBefore,\n            _borrowSharePriceBefore\n        );\n    }\n\n    /**\n     * @dev Enables _poolToken to be used as a collateral.\n     */\n    function collateralizeDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        WISE_SECURITY.checksCollateralizeDeposit(\n            _nftId,\n            msg.sender,\n            _poolToken\n        );\n\n        userLendingData[_nftId][_poolToken].unCollateralized = false;\n    }\n\n    /**\n     * @dev Disables _poolToken to be used as a collateral.\n     */\n    function unCollateralizeDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        userLendingData[_nftId][_poolToken].unCollateralized = true;\n\n        WISE_SECURITY.checkUncollateralizedDeposit(\n            _nftId,\n            _poolToken\n        );\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    // --------------- Deposit Functions -------------\n\n    /**\n     * @dev Allows to supply funds using ETH.\n     * Without converting to WETH, use ETH directly.\n     */\n    function depositExactAmountETH(\n        uint256 _nftId\n    )\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        return _depositExactAmountETH(\n            _nftId\n        );\n    }\n\n    function _depositExactAmountETH(\n        uint256 _nftId\n    )\n        private\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n\n        _wrapETH(\n            msg.value\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH.\n     * Without converting to WETH, use ETH directly,\n     * also mints position to avoid extra transaction.\n     */\n    function depositExactAmountETHMint()\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        return _depositExactAmountETH(\n            _reservePosition()\n        );\n    }\n\n    /**\n     * @dev Allows to supply _poolToken and user\n     * can decide if _poolToken should be collateralized,\n     * also mints position to avoid extra transaction.\n     */\n    function depositExactAmountMint(\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        returns (uint256)\n    {\n        return depositExactAmount(\n            _reservePosition(),\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Allows to supply _poolToken and user\n     * can decide if _poolToken should be collateralized.\n     */\n    function depositExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     * Also mints position to avoid extra transaction.\n     */\n    function solelyDepositETHMint()\n        external\n        payable\n    {\n        solelyDepositETH(\n            _reservePosition()\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     */\n    function solelyDepositETH(\n        uint256 _nftId\n    )\n        public\n        payable\n        syncPool(WETH_ADDRESS)\n    {\n        _handleSolelyDeposit(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n\n        _wrapETH(\n            msg.value\n        );\n\n        _emitFundsSolelyDeposited(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n    }\n\n    /**\n     * @dev Core function combining\n     * supply logic with security\n     * checks for solely deposit.\n     */\n    function _handleSolelyDeposit(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        _checkDeposit(\n            _nftId,\n            _caller,\n            _poolToken,\n            _amount\n        );\n\n        _increaseMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _increaseTotalBareToken(\n            _poolToken,\n            _amount\n        );\n\n        _addPositionTokenData(\n            _nftId,\n            _poolToken,\n            hashMapPositionLending,\n            positionLendTokenData\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ERC20 in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     * Also mints position to avoid extra transaction.\n     */\n    function solelyDepositMint(\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n    {\n        solelyDeposit(\n            _reservePosition(),\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ERC20 in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     */\n    function solelyDeposit(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n    {\n        _handleSolelyDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _emitFundsSolelyDeposited(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n    }\n\n    // --------------- Withdraw Functions -------------\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ETH funds using exact amount.\n     */\n    function withdrawExactAmountETH(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = _handleWithdrawAmount(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: WETH_ADDRESS,\n                _amount: _amount,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawShares\n        );\n\n        _unwrapETH(\n            _amount\n        );\n\n        _sendValue(\n            msg.sender,\n            _amount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ETH funds using exact shares.\n     */\n    function withdrawExactSharesETH(\n        uint256 _nftId,\n        uint256 _shares\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: WETH_ADDRESS,\n                _shares: _shares,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawAmount\n        );\n\n        _unwrapETH(\n            withdrawAmount\n        );\n\n        _sendValue(\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ERC20 funds using exact amount.\n     */\n    function withdrawExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = _handleWithdrawAmount(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawShares\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposite"
    }
  ]
}