{
  "Title": "[P2-H01] Broken token approval implementation",
  "Content": "###### High\n\n\nContracts inheriting from [OpenZeppelin’s ERC20 implementation](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.2.0/contracts/token/ERC20/ERC20.sol), such as [`BeamBalanceStore`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol) and [`ERC223BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol), reimplement several inherited ERC20 features (sometimes unnecessarily, as reported in **“Unnecessary reimplementation of ERC20 features in ERC223BeamToken”** and **“Unnecessary reimplementation of ERC20 features in BeamBalanceStore”**). This attempts to seamlessly integrate different token interfaces with the [generational balance store](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/README.md#the-generational-store) in `BeamBalanceStore`. Unexpectedly, these contracts override functionalities related to token approvals, such as the inherited [`approve`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L72) and [`allowance`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L49) functions. Moreover, both `BeamBalanceStore` and `ERC223BeamToken` declare an internal `allowances` mapping (see [`BeamBalanceStore`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L94) [at line 94](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L94) and [`ERC223BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L22) [at line 22](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L22)) to independently track token allowances. Both `approve` and `allowance` were customized to work with this new `allowances` mapping.\n\n\nBesides those already mentioned, two other relevant functions are inherited from the `ERC20` contract: [`increaseAllowance`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L101) and [`decreaseAllowance`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L116), which are intended to increase and decrease allowances in a way that mitigates the [known front-running vulnerability in ERC20 contracts](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit). While both functions are inherited and therefore publicly available in the contracts’ APIs, neither of these two functions are overridden in `BeamBalanceStore` nor `ERC223BeamToken` to work with the previously mentioned `allowances` mapping (as [`approve`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L434) and [`allowance`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L443) do). Instead, `increaseAllowance` and `decreaseAllowance` work with the [private](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L23) [`_allowed`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L23) [mapping](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L23) defined in the parent [`ERC20`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.2.0/contracts/token/ERC20/ERC20.sol) contract. This leads to a severe mismatch in how allowances are tracked in the contracts, breaking the token approval feature. As regular [`Approval`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/IERC20.sol#L22) events are emitted by these calls, they will seem successful in the eyes of the caller, yet the modification in the allowance will not be reflected when querying the [`allowance`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L443) public getter. If users notice this mismatch and thus attempt to use the [`approve`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L434) function to increase/decrease token allowances, they will then become vulnerable to the referenced front-running attack.\n\n\nThis issue stems from having the entire token approval mechanism reimplemented in both the `BeamBalanceStore` and `ERC223BeamToken` contracts. Consider reassessing the need to redefine such functionality when it is already inherited from a secure, audited, and battle-tested contract such as OpenZeppelin’s ERC20. Should the development team still consider it necessary to adapt the inherited functions, all of them must be carefully and thoroughly tested to avoid severe bugs that can break entire contract features.\n\n\n***Update:** Fixed. The `ERC223BeamToken` contract has been removed. The [`EcoBalanceStore` contract no longer inherits from `ERC20`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L23). The functions `approve` and `allowance` were removed. The `allowances` mapping was removed. Eco’s statement for this issue:*\n\n\n\n> When we upgraded the OpenZeppelin contract versions that we had been building on top of, we didn’t notice significant changes in the layout of the OpenZeppelin Contracts package. Contracts that used to be interface definitions only were modified to be full implementations. This broke some functionality, and introduced duplicate implementation of others. Our tests have improved since then, and we’re more careful about upgrading dependencies.\n> \n> \n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/token/ERC20/ERC20.sol",
      "content": "pragma solidity ^0.5.2;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://eips.ethereum.org/EIPS/eip-20\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the balance of.\n     * @return A uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n     * @dev Transfer token to a specified address\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Transfer token for a specified addresses\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Approve an address to spend another addresses' tokens.\n     * @param owner The address that owns the tokens.\n     * @param spender The address that will spend the tokens.\n     * @param value The number of tokens that can be spent.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(spender != address(0));\n        require(owner != address(0));\n\n        _allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n    }\n}"
    }
  ]
}