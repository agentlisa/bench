{
  "Title": "[M-01] An attacker can make users unable to cancel their L1 calls on Ethereum To Arbitrum",
  "Content": "\n[EthereumToArbitrumRelayer.sol#L118-#L127](https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-#L127)<br>\n\nWhen someone wants to make  calls to Arbitrum from Ethereum, first they call `relayCalls` to fingerprint their data and then anyone else can call `processCalls` to process the calls. According to the doc in Inbox source code <https://github.com/OffchainLabs/nitro/blob/1f32bec6b9b228bb2fab4bfa02867716f65d0c5c/contracts/src/bridge/Inbox.sol#L427>, function `createRetryableTicket` has one parameter called `callValueRefundAddress` and this is the address that is granted the option to `cancel` a `Retryable`. In `EthereumToArbitrumRelayer.sol` it's currently set as `msg.sender` (5th parameter) which is whoever make the call to  function `processCall`:\n\n    uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(\n          address(executor),\n          0,\n          _maxSubmissionCost,\n          msg.sender,\n          msg.sender,\n          _gasLimit,\n          _gasPriceBid,\n          _data\n        );\n\nThis implementation allows an attacker to remove the possibility of a user to cancel their calls, which is an important mechanism to be properly implemented. This scenario demonstrates how this could happen:\n\n*   User A call `relayCalls` to fingerprint their calls\n*   User B call `processCalls` to process user A's calls.\n*   User A now changes his mind and wants to cancel his calls but he's unable to since  `callValueRefundAddress` is set to user B's address, now user B is the one who decides whether to cancel user A's calls or not, which should be user A's option.\n*   Another common case is when users's calls failed, anyone can try to `redeem` it, according to the doc <https://developer.arbitrum.io/arbos/l1-to-l2-messaging>. So if a someone calls `processCalls` to process others's calls and it fails, the owner of the calls now cannot cancel their calls and anyone else can redeem (reexecute) them.\n\nIt should be noted here that `EthereumToArbitrumRelayer.sol` provides no other functionality to cancel users's calls, but it seems to rely only on Arbitrum's Retryable cancel mechanism to do so.\n\n### Recommended Mitigation Steps\n\nCurrently, anyone can process others's calls by calling `processCalls` functions and I think this does not pose any security risk as long as the user who actually fingerprinted these calls can reserve their rights to cancel it if they want to. Therefore, I recommend changing `callValueRefundAddress` in `createRetryableTicket` to `_sender`, this combines with event `ProcessedCalls(_nonce, msg.sender, _ticketID)` emitted at the end of `processCalls` function will allow a user to be notified if their calls has been processed by anyone else and they can cancel it in L2 using `_ticketID`.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/60#issuecomment-1345665985):**\n > Relayer has privilege to cancel arbitrum txs, I think there may be a similar finding, but for now will keep separate.\n\n**[PierrickGT (PoolTogether) confirmed and commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/60#issuecomment-1352223144):**\n > Very nice find! I've fixed the issue in the following PR: https://github.com/pooltogether/ERC5164/pull/10\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/60#issuecomment-1365451144):**\n > Worth flagging that allowing the caller to pass an arbitrary address may not solve, as I'd argue the only address that would rationally prevent the grief is the `_sender`, not fully sure if that is sufficient though.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/60#issuecomment-1365451641):**\n > The Warden has shown a specific scenario in which Arbitrum tickets, which are meant to be cancellable by the caller / the sender, can be griefed.\n> \n> Because this breaks the expectations of the code, and denies a functionality which was explicitly added, I agree with Medium Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-12-pooltogether",
  "Code": [
    {
      "filename": "src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.16;\n\nimport { IInbox } from \"@arbitrum/nitro-contracts/src/bridge/IInbox.sol\";\n\nimport { ICrossChainExecutor } from \"../interfaces/ICrossChainExecutor.sol\";\nimport { ICrossChainRelayer } from \"../interfaces/ICrossChainRelayer.sol\";\nimport \"../libraries/CallLib.sol\";\n\n/**\n * @title CrossChainRelayerArbitrum contract\n * @notice The CrossChainRelayerArbitrum contract allows a user or contract to send messages from Ethereum to Arbitrum.\n *         It lives on the Ethereum chain and communicates with the `CrossChainExecutorArbitrum` contract on the Arbitrum chain.\n */\ncontract CrossChainRelayerArbitrum is ICrossChainRelayer {\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted once a message has been processed and put in the Arbitrum inbox.\n   * @dev Using the `ticketId`, this message can be reexecuted for some fixed amount of time if it reverts.\n   * @param nonce Nonce to uniquely idenfity the batch of calls\n   * @param sender Address who processed the calls\n   * @param ticketId Id of the newly created retryable ticket\n   */\n  event ProcessedCalls(uint256 indexed nonce, address indexed sender, uint256 indexed ticketId);\n\n  /* ============ Variables ============ */\n\n  /// @notice Address of the Arbitrum inbox on the Ethereum chain.\n  IInbox public immutable inbox;\n\n  /// @notice Address of the executor contract on the Arbitrum chain.\n  ICrossChainExecutor public executor;\n\n  /// @notice Gas limit provided for free on Arbitrum.\n  uint256 public immutable maxGasLimit;\n\n  /// @notice Nonce to uniquely idenfity each batch of calls.\n  uint256 internal nonce;\n\n  /**\n   * @notice Hash of transactions that were relayed in `relayCalls`.\n   *         txHash => boolean\n   * @dev Ensure that messages passed to `processCalls` have been relayed first.\n   */\n  mapping(bytes32 => bool) public relayed;\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice CrossChainRelayer constructor.\n   * @param _inbox Address of the Arbitrum inbox on Ethereum\n   * @param _maxGasLimit Gas limit provided for free on Arbitrum\n   */\n  constructor(IInbox _inbox, uint256 _maxGasLimit) {\n    require(address(_inbox) != address(0), \"Relayer/inbox-not-zero-address\");\n    require(_maxGasLimit > 0, \"Relayer/max-gas-limit-gt-zero\");\n\n    inbox = _inbox;\n    maxGasLimit = _maxGasLimit;\n  }\n\n  /* ============ External Functions ============ */\n\n  /// @inheritdoc ICrossChainRelayer\n  function relayCalls(CallLib.Call[] calldata _calls, uint256 _gasLimit)\n    external\n    payable\n    returns (uint256)\n  {\n    uint256 _maxGasLimit = maxGasLimit;\n\n    if (_gasLimit > _maxGasLimit) {\n      revert GasLimitTooHigh(_gasLimit, _maxGasLimit);\n    }\n\n    nonce++;\n\n    uint256 _nonce = nonce;\n\n    relayed[_getTxHash(_nonce, _calls, msg.sender, _gasLimit)] = true;\n\n    emit RelayedCalls(_nonce, msg.sender, _calls, _gasLimit);\n\n    return _nonce;\n  }\n\n  /**\n   * @notice Process calls that have been relayed.\n   * @dev The transaction hash must match the one stored in the `relayed` mapping.\n   * @dev We store `_data` in memory to avoid a stack too deep error.\n   * @param _nonce Nonce of the batch of calls to process\n   * @param _calls Array of calls being processed\n   * @param _sender Address who relayed the `_calls`\n   * @param _gasLimit Maximum amount of gas required for the `_calls` to be executed\n   * @param _maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n   * @param _gasPriceBid Gas price bid for L2 execution\n   * @return uint256 Id of the retryable ticket that was created\n   */\n  function processCalls(\n    uint256 _nonce,\n    CallLib.Call[] calldata _calls,\n    address _sender,\n    uint256 _gasLimit,\n    uint256 _maxSubmissionCost,\n    uint256 _gasPriceBid\n  ) external payable returns (uint256) {\n    require(relayed[_getTxHash(_nonce, _calls, _sender, _gasLimit)], \"Relayer/calls-not-relayed\");\n\n    bytes memory _data = abi.encodeWithSignature(\n      \"executeCalls(uint256,address,(address,bytes)[])\",\n      _nonce,\n      _sender,\n      _calls\n    );\n\n    uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(\n      address(executor),\n      0,\n      _maxSubmissionCost,\n      msg.sender,\n      msg.sender,\n      _gasLimit,\n      _gasPriceBid,\n      _data\n    );\n\n    emit ProcessedCalls(_nonce, msg.sender, _ticketID);\n\n    return _ticketID;\n  }\n\n  /**\n   * @notice Set executor contract address.\n   * @dev Will revert if it has already been set.\n   * @param _executor Address of the executor contract on the Arbitrum chain\n   */\n  function setExecutor(ICrossChainExecutor _executor) external {\n    require(address(executor) == address(0), \"Relayer/executor-already-set\");\n    executor = _executor;\n  }\n\n  /**\n   * @notice Get transaction hash.\n   * @dev The transaction hash is used to ensure that only calls that were relayed are processed.\n   * @param _nonce Nonce uniquely identifying the batch of calls that were relayed\n   * @param _calls Array of calls that were relayed\n   * @param _sender Address who relayed the calls\n   * @param _gasLimit Maximum amount of gas that will be consumed by the calls\n   * @return bytes32 Transaction hash\n   */\n  function getTxHash(\n    uint256 _nonce,\n    CallLib.Call[] calldata _calls,\n    address _sender,\n    uint256 _gasLimit\n  ) external view returns (bytes32) {\n    return _getTxHash(_nonce, _calls, _sender, _gasLimit);\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /**\n   * @notice Get transaction hash.\n   * @dev The transaction hash is used to ensure that only calls that were relayed are processed.\n   * @param _nonce Nonce uniquely identifying the batch of calls that were relayed\n   * @param _calls Array of calls that were relayed\n   * @param _sender Address who relayed the calls\n   * @param _gasLimit Maximum amount of gas that will be consumed by the calls\n   * @return bytes32 Transaction hash\n   */\n  function _getTxHash(\n    uint256 _nonce,\n    CallLib.Call[] calldata _calls,\n    address _sender,\n    uint256 _gasLimit\n  ) internal view returns (bytes32) {\n    return keccak256(abi.encode(address(this), _nonce, _calls, _sender, _gasLimit));\n  }\n}"
    },
    {
      "filename": "contracts/src/bridge/Inbox.sol",
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport {\n    AlreadyInit,\n    NotOrigin,\n    DataTooLarge,\n    AlreadyPaused,\n    AlreadyUnpaused,\n    Paused,\n    InsufficientValue,\n    InsufficientSubmissionCost,\n    NotAllowedOrigin,\n    RetryableData,\n    NotRollupOrOwner,\n    L1Forked,\n    NotForked\n} from \"../libraries/Error.sol\";\nimport \"./IInbox.sol\";\nimport \"./ISequencerInbox.sol\";\nimport \"./IBridge.sol\";\n\nimport \"./Messages.sol\";\nimport \"../libraries/AddressAliasHelper.sol\";\nimport \"../libraries/DelegateCallAware.sol\";\nimport {\n    L2_MSG,\n    L1MessageType_L2FundedByL1,\n    L1MessageType_submitRetryableTx,\n    L1MessageType_ethDeposit,\n    L2MessageType_unsignedEOATx,\n    L2MessageType_unsignedContractTx\n} from \"../libraries/MessageTypes.sol\";\nimport {MAX_DATA_SIZE} from \"../libraries/Constants.sol\";\nimport \"../precompiles/ArbSys.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/**\n * @title Inbox for user and contract originated messages\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\n * to await inclusion in the SequencerInbox\n */\ncontract Inbox is DelegateCallAware, PausableUpgradeable, IInbox {\n    IBridge public bridge;\n    ISequencerInbox public sequencerInbox;\n\n    /// ------------------------------------ allow list start ------------------------------------ ///\n\n    bool public allowListEnabled;\n    mapping(address => bool) public isAllowed;\n\n    event AllowListAddressSet(address indexed user, bool val);\n    event AllowListEnabledUpdated(bool isEnabled);\n\n    function setAllowList(address[] memory user, bool[] memory val) external onlyRollupOrOwner {\n        require(user.length == val.length, \"INVALID_INPUT\");\n\n        for (uint256 i = 0; i < user.length; i++) {\n            isAllowed[user[i]] = val[i];\n            emit AllowListAddressSet(user[i], val[i]);\n        }\n    }\n\n    function setAllowListEnabled(bool _allowListEnabled) external onlyRollupOrOwner {\n        require(_allowListEnabled != allowListEnabled, \"ALREADY_SET\");\n        allowListEnabled = _allowListEnabled;\n        emit AllowListEnabledUpdated(_allowListEnabled);\n    }\n\n    /// @dev this modifier checks the tx.origin instead of msg.sender for convenience (ie it allows\n    /// allowed users to interact with the token bridge without needing the token bridge to be allowList aware).\n    /// this modifier is not intended to use to be used for security (since this opens the allowList to\n    /// a smart contract phishing risk).\n    modifier onlyAllowed() {\n        // solhint-disable-next-line avoid-tx-origin\n        if (allowListEnabled && !isAllowed[tx.origin]) revert NotAllowedOrigin(tx.origin);\n        _;\n    }\n\n    /// ------------------------------------ allow list end ------------------------------------ ///\n\n    modifier onlyRollupOrOwner() {\n        IOwnable rollup = bridge.rollup();\n        if (msg.sender != address(rollup)) {\n            address rollupOwner = rollup.owner();\n            if (msg.sender != rollupOwner) {\n                revert NotRollupOrOwner(msg.sender, address(rollup), rollupOwner);\n            }\n        }\n        _;\n    }\n\n    uint256 internal immutable deployTimeChainId = block.chainid;\n\n    function _chainIdChanged() internal view returns (bool) {\n        return deployTimeChainId != block.chainid;\n    }\n\n    /// @inheritdoc IInbox\n    function pause() external onlyRollupOrOwner {\n        _pause();\n    }\n\n    /// @inheritdoc IInbox\n    function unpause() external onlyRollupOrOwner {\n        _unpause();\n    }\n\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox)\n        external\n        initializer\n        onlyDelegated\n    {\n        bridge = _bridge;\n        sequencerInbox = _sequencerInbox;\n        allowListEnabled = false;\n        __Pausable_init();\n    }\n\n    /// @inheritdoc IInbox\n    function postUpgradeInit(IBridge) external onlyDelegated onlyProxyOwner {}\n\n    /// @inheritdoc IInbox\n    function sendL2MessageFromOrigin(bytes calldata messageData)\n        external\n        whenNotPaused\n        onlyAllowed\n        returns (uint256)\n    {\n        if (_chainIdChanged()) revert L1Forked();\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender != tx.origin) revert NotOrigin();\n        if (messageData.length > MAX_DATA_SIZE)\n            revert DataTooLarge(messageData.length, MAX_DATA_SIZE);\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\n        emit InboxMessageDeliveredFromOrigin(msgNum);\n        return msgNum;\n    }\n\n    /// @inheritdoc IInbox\n    function sendL2Message(bytes calldata messageData)\n        external\n        whenNotPaused\n        onlyAllowed\n        returns (uint256)\n    {\n        if (_chainIdChanged()) revert L1Forked();\n        return _deliverMessage(L2_MSG, msg.sender, messageData);\n    }\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    gasLimit,\n                    maxFeePerGas,\n                    nonce,\n                    uint256(uint160(to)),\n                    msg.value,\n                    data\n                )\n            );\n    }\n\n    function sendL1FundedContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        bytes calldata data\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedContractTx,\n                    gasLimit,\n                    maxFeePerGas,\n                    uint256(uint160(to)),\n                    msg.value,\n                    data\n                )\n            );\n    }\n\n    function sendUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external whenNotPaused onlyAllowed returns (uint256) {\n        return\n            _deliverMessage(\n                L2_MSG,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    gasLimit,\n                    maxFeePerGas,\n                    nonce,\n                    uint256(uint160(to)),\n                    value,\n                    data\n                )\n            );\n    }\n\n    function sendContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external whenNotPaused onlyAllowed returns (uint256) {\n        return\n            _deliverMessage(\n                L2_MSG,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedContractTx,\n                    gasLimit,\n                    maxFeePerGas,\n                    uint256(uint160(to)),\n                    value,\n                    data\n                )\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function sendL1FundedUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\n        if (!_chainIdChanged()) revert NotForked();\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender != tx.origin) revert NotOrigin();\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                // undoing sender alias here to cancel out the aliasing\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender),\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    gasLimit,\n                    maxFeePerGas,\n                    nonce,\n                    uint256(uint160(to)),\n                    msg.value,\n                    data\n                )\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function sendUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external whenNotPaused onlyAllowed returns (uint256) {\n        if (!_chainIdChanged()) revert NotForked();\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender != tx.origin) revert NotOrigin();\n        return\n            _deliverMessage(\n                L2_MSG,\n                // undoing sender alias here to cancel out the aliasing\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender),\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    gasLimit,\n                    maxFeePerGas,\n                    nonce,\n                    uint256(uint160(to)),\n                    value,\n                    data\n                )\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function sendWithdrawEthToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        uint256 value,\n        address withdrawTo\n    ) external whenNotPaused onlyAllowed returns (uint256) {\n        if (!_chainIdChanged()) revert NotForked();\n        // solhint-disable-next-line avoid-tx-origin\n        if (msg.sender != tx.origin) revert NotOrigin();\n        return\n            _deliverMessage(\n                L2_MSG,\n                // undoing sender alias here to cancel out the aliasing\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender),\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    gasLimit,\n                    maxFeePerGas,\n                    nonce,\n                    uint256(uint160(address(100))), // ArbSys address\n                    value,\n                    abi.encode(ArbSys.withdrawEth.selector, withdrawTo)\n                )\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\n        public\n        view\n        returns (uint256)\n    {\n        // Use current block basefee if baseFee parameter is 0\n        return (1400 + 6 * dataLength) * (baseFee == 0 ? block.basefee : baseFee);\n    }\n\n    /// @inheritdoc IInbox\n    function depositEth() public payable whenNotPaused onlyAllowed returns (uint256) {\n        address dest = msg.sender;\n\n        // solhint-disable-next-line avoid-tx-origin\n        if (AddressUpgradeable.isContract(msg.sender) || tx.origin != msg.sender) {\n            // isContract check fails if this function is called during a contract's constructor.\n            dest = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        return\n            _deliverMessage(\n                L1MessageType_ethDeposit,\n                msg.sender,\n                abi.encodePacked(dest, msg.value)\n            );\n    }\n\n    /// @notice deprecated in favour of depositEth with no parameters\n    function depositEth(uint256) external payable whenNotPaused onlyAllowed returns (uint256) {\n        return depositEth();\n    }\n\n    /**\n     * @notice deprecated in favour of unsafeCreateRetryableTicket\n     * @dev deprecated in favour of unsafeCreateRetryableTicket\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicketNoRefundAliasRewrite(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\n        return\n            unsafeCreateRetryableTicket(\n                to,\n                l2CallValue,\n                maxSubmissionCost,\n                excessFeeRefundAddress,\n                callValueRefundAddress,\n                gasLimit,\n                maxFeePerGas,\n                data\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function createRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable whenNotPaused onlyAllowed returns (uint256) {\n        // ensure the user's deposit alone will make submission succeed\n        if (msg.value < (maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas)) {\n            revert InsufficientValue(\n                maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas,\n                msg.value\n            );\n        }\n\n        // if a refund address is a contract, we apply the alias to it\n        // so that it can access its funds on the L2\n        // since the beneficiary and other refund addresses don't get rewritten by arb-os\n        if (AddressUpgradeable.isContract(excessFeeRefundAddress)) {\n            excessFeeRefundAddress = AddressAliasHelper.applyL1ToL2Alias(excessFeeRefundAddress);\n        }\n        if (AddressUpgradeable.isContract(callValueRefundAddress)) {\n            // this is the beneficiary. be careful since this is the address that can cancel the retryable in the L2\n            callValueRefundAddress = AddressAliasHelper.applyL1ToL2Alias(callValueRefundAddress);\n        }\n\n        return\n            unsafeCreateRetryableTicket(\n                to,\n                l2CallValue,\n                maxSubmissionCost,\n                excessFeeRefundAddress,\n                callValueRefundAddress,\n                gasLimit,\n                maxFeePerGas,\n                data\n            );\n    }\n\n    /// @inheritdoc IInbox\n    function unsafeCreateRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) public payable whenNotPaused onlyAllowed returns (uint256) {\n        // gas price and limit of 1 should never be a valid input, so instead they are used as\n        // magic values to trigger a revert in eth calls that surface data without requiring a tx trace\n        if (gasLimit == 1 || maxFeePerGas == 1)\n            revert RetryableData(\n                msg.sender,\n                to,\n                l2CallValue,\n                msg.value,\n                maxSubmissionCost,\n                excessFeeRefundAddress,\n                callValueRefundAddress,\n                gasLimit,\n                maxFeePerGas,\n                data\n            );\n\n        uint256 submissionFee = calculateRetryableSubmissionFee(data.length, block.basefee);\n        if (maxSubmissionCost < submissionFee)\n            revert InsufficientSubmissionCost(submissionFee, maxSubmissionCost);\n\n        return\n            _deliverMessage(\n                L1MessageType_submitRetryableTx,\n                msg.sender,\n                abi.encodePacked(\n                    uint256(uint160(to)),\n                    l2CallValue,\n                    msg.value,\n                    maxSubmissionCost,\n                    uint256(uint160(excessFeeRefundAddress)),\n                    uint256(uint160(callValueRefundAddress)),\n                    gasLimit,\n                    maxFeePerGas,\n                    data.length,\n                    data\n                )\n            );\n    }\n\n    function _deliverMessage(\n        uint8 _kind,\n        address _sender,\n        bytes memory _messageData\n    ) internal returns (uint256) {\n        if (_messageData.length > MAX_DATA_SIZE)\n            revert DataTooLarge(_messageData.length, MAX_DATA_SIZE);\n        uint256 msgNum = deliverToBridge(_kind, _sender, keccak256(_messageData));\n        emit InboxMessageDelivered(msgNum, _messageData);\n        return msgNum;\n    }\n\n    function deliverToBridge(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) internal returns (uint256) {\n        return\n            bridge.enqueueDelayedMessage{value: msg.value}(\n                kind,\n                AddressAliasHelper.applyL1ToL2Alias(sender),\n                messageDataHash\n            );\n    }\n}"
    }
  ]
}