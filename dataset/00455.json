{
  "Title": "M-36: SGL and BB repay do not round up both on allowance spending and elastic amount",
  "Content": "# Issue M-36: SGL and BB repay do not round up both on allowance spending and elastic amount \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/150 \n\n## Found by \nhyh\n## Summary\n\nThe shares to amount translation isn't done in protocol favor on BB/SGL repay.\n\n## Vulnerability Detail\n\nAmount provided by the user can be less than shares being written off on debt repayment.\n\n## Impact\n\nProtocol can be exploited by paying out very little amount many times, when the absence of rounding up becomes material. The impact is up to closing the debt for free.\n\n## Code Snippet\n\nSGL repay do not round up both on allowance spending and elastic amount for the given base amount:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLendingCommon.sol#L91-L107\n\n```solidity\n    function _repay(address from, address to, bool skim, uint256 part) internal returns (uint256 amount) {\n        if (part > userBorrowPart[to]) {\n            part = userBorrowPart[to];\n        }\n        if (part == 0) revert NothingToRepay();\n\n        if (msg.sender != from) {\n            uint256 partInAmount;\n            Rebase memory _totalBorrow = totalBorrow;\n>>          (_totalBorrow, partInAmount) = _totalBorrow.sub(part, false);\n\n            uint256 allowanceShare =\n                _computeAllowanceAmountInAsset(to, exchangeRate, partInAmount, _safeDecimals(asset));\n            if (allowanceShare == 0) revert AllowanceNotValid();\n            _allowedBorrow(from, allowanceShare);\n        }\n>>      (totalBorrow, amount) = totalBorrow.sub(part, false);\n```\n\nBB repay correctly reduces allowance, but doesn't round up the elastic amount for the given base amount:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLendingCommon.sol#L107-L126\n\n```solidity\n    function _repay(address from, address to, uint256 part) internal returns (uint256 amount) {\n        if (part > userBorrowPart[to]) {\n            part = userBorrowPart[to];\n        }\n        if (part == 0) revert NothingToRepay();\n\n        // @dev check allowance\n        if (msg.sender != from) {\n            uint256 partInAmount;\n            Rebase memory _totalBorrow = totalBorrow;\n>>          (_totalBorrow, partInAmount) = _totalBorrow.sub(part, false);\n            uint256 allowanceShare =\n                _computeAllowanceAmountInAsset(to, exchangeRate, partInAmount, _safeDecimals(asset));\n            if (allowanceShare == 0) revert AllowanceNotValid();\n            _allowedBorrow(from, allowanceShare);\n        }\n\n        // @dev sub `part` of totalBorrow\n>>      (totalBorrow, amount) = totalBorrow.sub(part, true);\n        userBorrowPart[to] -= part;\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using `true` for amount calculations in all this cases, rounding the amounts up for the shares given.\n\n\n\n## Discussion\n\n**maarcweiss**\n\nThis is an interesting one. Did some research and if you take a look to all the Cualdrons, degenBox from Abracadabra (recently exploited) they indeed round up in repay. You can check all the examples at: https://www.codeslaw.app/search?chain=ethereum&q=totalBorrow.sub%28part\n\nI will give the last word to @cryptotechmaker @0xRektora on this one, but seems true. Additionally, if possible a PoC for this rounding issues would be fantastic (to assess severity too as different roundings have different levels of loss of funds), but I guess the submitter can wait until the team decision has been taken, though leading towards valid.\n\n**cryptotechmaker**\n\nYes, it seems true, but I would like to suggest for a PoC as well. Thanks!\nThe reason for the PoC (even if it's sounds feasible) is because this code was already covered by another audit and it had a similar rounding issue submitted but this part was not included. \n\n**cryptotechmaker**\n\nWhat status should we assign to it until then @maarcweiss ?\n\n**dmitriia**\n\nThis looks like a consequence of the mitigation changes being too general. See p.4 of Alex's Spearbit review [issue](https://github.com/spearbit-audits/tapioca-review/issues/78) (5.3.34 in public report) and [mitigation commit part that wasn't needed](https://github.com/Tapioca-DAO/Tapioca-bar/commit/6709263874ed52ae9a534f54302de2960b56b759#diff-dc546045a87dcd2462a835b063302f87fc5b0b58b464b01db665a232a6028de8L113-R124). The reason is that rounding `amount` up wasn't forgiving as this `amount` was to be paid by the repaying user, while `part` being written off was fixed. I.e. while the idea of that issue was correct, these particular repayment code parts listed here indeed represent the standard rounding up of the amount due in the favor of the protocol and need to remain so.\n\nPOC is straightforward:\n\n1. Repay dust `part` that have `(, amount) = _totalBorrow.sub(part, false)` substantially smaller vs rounding upwards (zero will not work due to `if (allowanceShare == 0) revert AllowanceNotValid()` check added earlier as a fix to a similar issue).  It can be `part = 1 wei`, `amount = 1 wei`, while `amount` was actually `1.9 wei` in a bigger precision and was [rounded](https://github.com/boringcrypto/BoringSolidity/blob/78f4817d9c0d95fe9c45cd42e307ccd22cf5f4fc/contracts/libraries/BoringRebase.sol#L36) to be `1 wei`.\n\n2. Repeat many times over so the `1.9x` worth of `asset` debt is fully repaid with `1x` worth of `asset` paid.\n\nThe tx costs are the biggest barrier here: supposing attacker will pack the execution optimally there still be significant expenses with regard to amount as it have to be small as upwards rounding is [adding](https://github.com/boringcrypto/BoringSolidity/blob/78f4817d9c0d95fe9c45cd42e307ccd22cf5f4fc/contracts/libraries/BoringRebase.sol#L38) `1 wei` only. So this can be viable in L2 setting when asset being repaid is valuable enough to cover these costs.\n\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/372.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLLendingCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20, IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {SGLCommon} from \"./SGLCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLLendingCommon is SGLCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeCast for uint256;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BorrowCapReached();\n    error NothingToRepay();\n    error AllowanceNotValid();\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    /// @dev Concrete implementation of `addCollateral`.\n    function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        userCollateralShare[to] += share;\n        totalCollateralShare = oldTotalCollateralShare + share;\n\n        _addTokens(from, to, collateralId, share, oldTotalCollateralShare, skim);\n\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(address from, address to, uint256 share) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(address from, address to, uint256 amount) internal returns (uint256 part, uint256 share) {\n        share = yieldBox.toShare(assetId, amount, true);\n        Rebase memory _totalAsset = totalAsset;\n        if (_totalAsset.base < 1000) revert MinLimit();\n\n        uint256 fullAssetAmountBefore = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + totalBorrow.elastic;\n\n        _totalAsset.elastic -= share.toUint128();\n\n        uint256 feeAmount = (amount * borrowOpeningFee) / FEE_PRECISION; // A flat % fee is charged for any borrow\n\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n        if (totalBorrowCap != 0) {\n            if (totalBorrow.elastic > totalBorrowCap) revert BorrowCapReached();\n        }\n        userBorrowPart[from] += part;\n        emit LogBorrow(from, to, amount, feeAmount, part);\n\n        if (feeAmount > 0) {\n            uint256 feeFraction = (feeAmount * _totalAsset.base) / fullAssetAmountBefore;\n            _totalAsset.base += feeFraction.toUint128();\n            balanceOf[address(penrose)] += feeFraction;\n        }\n\n        totalAsset = _totalAsset;\n\n        yieldBox.transfer(address(this), to, assetId, share);\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(address from, address to, bool skim, uint256 part) internal returns (uint256 amount) {\n        if (part > userBorrowPart[to]) {\n            part = userBorrowPart[to];\n        }\n        if (part == 0) revert NothingToRepay();\n\n        if (msg.sender != from) {\n            uint256 partInAmount;\n            Rebase memory _totalBorrow = totalBorrow;\n            (_totalBorrow, partInAmount) = _totalBorrow.sub(part, false);\n\n            uint256 allowanceShare =\n                _computeAllowanceAmountInAsset(to, exchangeRate, partInAmount, _safeDecimals(asset));\n            if (allowanceShare == 0) revert AllowanceNotValid();\n            _allowedBorrow(from, allowanceShare);\n        }\n        (totalBorrow, amount) = totalBorrow.sub(part, false);\n\n        userBorrowPart[to] -= part;\n\n        uint256 share = yieldBox.toShare(assetId, amount, true);\n        uint128 totalShare = totalAsset.elastic;\n        _addTokens(from, to, assetId, share, uint256(totalShare), skim);\n        totalAsset.elastic = totalShare + share.toUint128();\n\n        emit LogRepay(skim ? address(yieldBox) : from, to, amount, part);\n    }\n\n    function _safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567)); //decimals() selector\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLendingCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {IUsdo} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {BBCommon} from \"./BBCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLendingCommon is BBCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BorrowCapReached();\n    error OracleCallFailed();\n    error NothingToRepay();\n    error RepayAmountNotValid();\n    error AllowanceNotValid();\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        userCollateralShare[to] += share;\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare + share;\n        _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(address from, address to, uint256 share) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(address from, address to, uint256 amount, uint256 feeAmount)\n        internal\n        returns (uint256 part, uint256 share)\n    {\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n\n        if (totalBorrowCap > 0) {\n            if (totalBorrow.elastic > totalBorrowCap) revert BorrowCapReached();\n        }\n\n        userBorrowPart[from] += part;\n        emit LogBorrow(from, to, amount, feeAmount, part);\n\n        //mint USDO\n        IUsdo(address(asset)).mint(address(this), amount);\n\n        //deposit borrowed amount to user\n        share = _depositAmountToYb(asset, to, assetId, amount);\n    }\n\n    function _computeVariableOpeningFee(uint256 amount) internal returns (uint256) {\n        if (amount == 0) return 0;\n\n        //get asset <> USDC price ( USDO <> USDC )\n        (bool updated, uint256 _exchangeRate) = assetOracle.get(oracleData);\n        if (!updated) revert OracleCallFailed();\n\n        if (_exchangeRate >= minMintFeeStart) {\n            return (amount * minMintFee) / FEE_PRECISION;\n        }\n        if (_exchangeRate <= maxMintFeeStart) {\n            return (amount * maxMintFee) / FEE_PRECISION;\n        }\n\n        uint256 fee = maxMintFee\n            - (((_exchangeRate - maxMintFeeStart) * (maxMintFee - minMintFee)) / (minMintFeeStart - maxMintFeeStart));\n\n        if (fee > maxMintFee) return (amount * maxMintFee) / FEE_PRECISION;\n        if (fee < minMintFee) return (amount * minMintFee) / FEE_PRECISION;\n\n        if (fee > 0) {\n            return (amount * fee) / FEE_PRECISION;\n        }\n        return 0;\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(address from, address to, uint256 part) internal returns (uint256 amount) {\n        if (part > userBorrowPart[to]) {\n            part = userBorrowPart[to];\n        }\n        if (part == 0) revert NothingToRepay();\n\n        // @dev check allowance\n        if (msg.sender != from) {\n            uint256 partInAmount;\n            Rebase memory _totalBorrow = totalBorrow;\n            (_totalBorrow, partInAmount) = _totalBorrow.sub(part, false);\n            uint256 allowanceShare =\n                _computeAllowanceAmountInAsset(to, exchangeRate, partInAmount, _safeDecimals(asset));\n            if (allowanceShare == 0) revert AllowanceNotValid();\n            _allowedBorrow(from, allowanceShare);\n        }\n\n        // @dev sub `part` of totalBorrow\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n        userBorrowPart[to] -= part;\n\n        // @dev amount includes the opening & accrued fees\n        yieldBox.withdraw(assetId, from, address(this), amount, 0);\n\n        // @dev burn USDO\n        IUsdo(address(asset)).burn(address(this), amount);\n\n        emit LogRepay(from, to, amount, part);\n    }\n\n    function _safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567)); //decimals() selector\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/BoringRebase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\n                base++;\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\n                elastic++;\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic += uint128(elastic);\n        total.base += uint128(base);\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic -= uint128(elastic);\n        total.base -= uint128(base);\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic += uint128(elastic);\n        total.base += uint128(base);\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic -= uint128(elastic);\n        total.base -= uint128(base);\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic += uint128(elastic);\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic -= uint128(elastic);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/BoringRebase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\n                base++;\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\n                elastic++;\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic += uint128(elastic);\n        total.base += uint128(base);\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic -= uint128(elastic);\n        total.base -= uint128(base);\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic += uint128(elastic);\n        total.base += uint128(base);\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic -= uint128(elastic);\n        total.base -= uint128(base);\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic += uint128(elastic);\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic -= uint128(elastic);\n    }\n}"
    }
  ]
}