{
  "Title": "H-1: When private keeper mode is off users can queue orders with the wrong asset",
  "Content": "# Issue H-1: When private keeper mode is off users can queue orders with the wrong asset \n\nSource: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/85 \n\n## Found by \nKingNFT, adriro, bin2chen, 0x52, kaliberpoziomka\n\n## Summary\n\nAfter an order is initiated, it must be filled by calling resolveQueuedTrades. This function validates that the asset price has been signed but never validates that the asset being passed in matches the asset of the queuedTrade. When private keeper mode is off, which is the default state of the contract, this can be abused to cause huge loss of funds.\n\n## Vulnerability Detail\n\n        for (uint32 index = 0; index < params.length; index++) {\n            OpenTradeParams memory currentParams = params[index];\n            QueuedTrade memory queuedTrade = queuedTrades[\n                currentParams.queueId\n            ];\n            bool isSignerVerifed = _validateSigner(\n                currentParams.timestamp,\n                currentParams.asset,\n                currentParams.price,\n                currentParams.signature\n            );\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailResolve(\n                    currentParams.queueId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n            if (\n                !queuedTrade.isQueued ||\n                currentParams.timestamp != queuedTrade.queuedTime\n            ) {\n                // Trade has already been opened or cancelled or the timestamp is wrong.\n                // So ignore this trade.\n                continue;\n            }\n\n            // If the opening time is much greater than the queue time then cancel the trad\n            if (block.timestamp - queuedTrade.queuedTime <= MAX_WAIT_TIME) {\n                _openQueuedTrade(currentParams.queueId, currentParams.price);\n            } else {\n                _cancelQueuedTrade(currentParams.queueId);\n                emit CancelTrade(\n                    queuedTrade.user,\n                    currentParams.queueId,\n                    \"Wait time too high\"\n                );\n            }\n\n            // Track the next queueIndex to be processed for user\n            userNextQueueIndexToProcess[queuedTrade.user] =\n                queuedTrade.userQueueIndex +\n                1;\n        }\n\nBufferRouter#resolveQueueTrades never validates that the asset passed in for params is the same asset as the queuedTrade. It only validates that the price is the same, then passes the price and queueId to _openQueuedTrade:\n\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n\n        bool isSlippageWithinRange = optionsContract.isStrikeValid(\n            queuedTrade.slippage,\n            price,\n            queuedTrade.expectedStrike\n        );\n\n        if (!isSlippageWithinRange) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(\n                queuedTrade.user,\n                queueId,\n                \"Slippage limit exceeds\"\n            );\n\n            return;\n        }\n\n        ...\n\n        optionParams.totalFee = revisedFee;\n        optionParams.strike = price;\n        optionParams.amount = amount;\n\n        uint256 optionId = optionsContract.createFromRouter(\n            optionParams,\n            isReferralValid\n        );\n\nInside _openQueuedTrade it checks that the price is within the slippage bounds of the order, cancelling if its not. Otherwise it uses the price to open an option. According to documentation, the same router will be used across a large number of assets/pools, which means the publisher for every asset is the same, given that router only has one publisher variable.\n\nExamples:\n\nImagine two assets are listed that have close prices, asset A = $0.95 and asset B = $1. An adversary could create an call that expires in 10 minutes on asset B with 5% slippage, then immediately queue it with the price of asset A. $0.95 is within the slippage bounds so it creates the option with a strike price of $0.95. Since the price of asset B is actually $1 the adversary will almost guaranteed make money, stealing funds from the LPs. This can be done back and forth between both pools until pools for both assets are drained.\n\nIn a similar scenario, if the price of the assets are very different, the adversary could use this to DOS another user by always calling queue with the wrong asset, causing the order to be cancelled.\n\n## Impact\n\nAdversary can rug LPs and DOS other users\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L136-L185\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nPass the asset address through so the BufferBinaryOptions contract can validate it is being called with the correct asset\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/24",
  "Code": [
    {
      "filename": "contracts/contracts/core/BufferRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/Interfaces.sol\";\n\n/**\n * @author Heisenberg\n * @notice Buffer Options Router Contract\n */\ncontract BufferRouter is AccessControl, IBufferRouter {\n    uint16 MAX_WAIT_TIME = 1 minutes;\n    uint256 public nextQueueId = 0;\n    address public publisher;\n    uint256 public nextQueueIdToProcess = 0;\n    bool public isInPrivateKeeperMode = true;\n\n    mapping(address => uint256[]) public userQueuedIds;\n    mapping(address => uint256[]) public userCancelledQueuedIds;\n    mapping(address => uint256) public userNextQueueIndexToProcess;\n    mapping(uint256 => QueuedTrade) public queuedTrades;\n    mapping(address => bool) public contractRegistry;\n    mapping(address => bool) public isKeeper;\n\n    constructor(address _publisher) {\n        publisher = _publisher;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /************************************************\n     *  ADMIN ONLY FUNCTIONS\n     ***********************************************/\n\n    function setContractRegistry(address targetContract, bool register)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        contractRegistry[targetContract] = register;\n    }\n\n    function setKeeper(address _keeper, bool _isActive)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        isKeeper[_keeper] = _isActive;\n    }\n\n    function setInPrivateKeeperMode() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        isInPrivateKeeperMode = !isInPrivateKeeperMode;\n    }\n\n    /************************************************\n     *  USER WRITE FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Adds an option creation request in the queue\n     */\n    function initiateTrade(\n        uint256 totalFee,\n        uint256 period,\n        bool isAbove,\n        address targetContract,\n        uint256 expectedStrike,\n        uint256 slippage,\n        bool allowPartialFill,\n        string memory referralCode,\n        uint256 traderNFTId\n    ) external returns (uint256 queueId) {\n        // Checks if the target contract has been registered\n        require(\n            contractRegistry[targetContract],\n            \"Router: Unauthorized contract\"\n        );\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            targetContract\n        );\n\n        optionsContract.runInitialChecks(slippage, period, totalFee);\n\n        // Transfer the fee specified from the user to this contract.\n        // User has to approve first inorder to execute this function\n        IERC20(optionsContract.tokenX()).transferFrom(\n            msg.sender,\n            address(this),\n            totalFee\n        );\n        queueId = nextQueueId;\n        nextQueueId++;\n\n        QueuedTrade memory queuedTrade = QueuedTrade(\n            queueId,\n            userQueueCount(msg.sender),\n            msg.sender,\n            totalFee,\n            period,\n            isAbove,\n            targetContract,\n            expectedStrike,\n            slippage,\n            allowPartialFill,\n            block.timestamp,\n            true,\n            referralCode,\n            traderNFTId\n        );\n\n        queuedTrades[queueId] = queuedTrade;\n\n        userQueuedIds[msg.sender].push(queueId);\n\n        emit InitiateTrade(msg.sender, queueId, block.timestamp);\n    }\n\n    /**\n     * @notice Cancels a queued traded. Can only be called by the trade owner\n     */\n    function cancelQueuedTrade(uint256 queueId) external {\n        QueuedTrade memory queuedTrade = queuedTrades[queueId];\n        require(msg.sender == queuedTrade.user, \"Router: Forbidden\");\n        require(queuedTrade.isQueued, \"Router: Trade has already been opened\");\n        _cancelQueuedTrade(queueId);\n        emit CancelTrade(queuedTrade.user, queueId, \"User Cancelled\");\n    }\n\n    /************************************************\n     *  KEEPER ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Verifies the trade parameter via the signature and resolves all the valid queued trades\n     */\n    function resolveQueuedTrades(OpenTradeParams[] calldata params) external {\n        _validateKeeper();\n        for (uint32 index = 0; index < params.length; index++) {\n            OpenTradeParams memory currentParams = params[index];\n            QueuedTrade memory queuedTrade = queuedTrades[\n                currentParams.queueId\n            ];\n            bool isSignerVerifed = _validateSigner(\n                currentParams.timestamp,\n                currentParams.asset,\n                currentParams.price,\n                currentParams.signature\n            );\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailResolve(\n                    currentParams.queueId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n            if (\n                !queuedTrade.isQueued ||\n                currentParams.timestamp != queuedTrade.queuedTime\n            ) {\n                // Trade has already been opened or cancelled or the timestamp is wrong.\n                // So ignore this trade.\n                continue;\n            }\n\n            // If the opening time is much greater than the queue time then cancel the trade\n            if (block.timestamp - queuedTrade.queuedTime <= MAX_WAIT_TIME) {\n                _openQueuedTrade(currentParams.queueId, currentParams.price);\n            } else {\n                _cancelQueuedTrade(currentParams.queueId);\n                emit CancelTrade(\n                    queuedTrade.user,\n                    currentParams.queueId,\n                    \"Wait time too high\"\n                );\n            }\n\n            // Track the next queueIndex to be processed for user\n            userNextQueueIndexToProcess[queuedTrade.user] =\n                queuedTrade.userQueueIndex +\n                1;\n        }\n        // Track the next queueIndex to be processed overall\n        nextQueueIdToProcess = params[params.length - 1].queueId + 1;\n    }\n\n    /**\n     * @notice Verifies the option parameter via the signature and unlocks an array of options\n     */\n    function unlockOptions(CloseTradeParams[] calldata optionData) external {\n        _validateKeeper();\n\n        uint32 arrayLength = uint32(optionData.length);\n        for (uint32 i = 0; i < arrayLength; i++) {\n            CloseTradeParams memory params = optionData[i];\n            IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n                params.asset\n            );\n            (, , , , , uint256 expiration, , , ) = optionsContract.options(\n                params.optionId\n            );\n\n            bool isSignerVerifed = _validateSigner(\n                params.expiryTimestamp,\n                params.asset,\n                params.priceAtExpiry,\n                params.signature\n            );\n\n            // Silently fail if the timestamp of the signature is wrong\n            if (expiration != params.expiryTimestamp) {\n                emit FailUnlock(params.optionId, \"Router: Wrong price\");\n                continue;\n            }\n\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailUnlock(\n                    params.optionId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n\n            try\n                optionsContract.unlock(params.optionId, params.priceAtExpiry)\n            {} catch Error(string memory reason) {\n                emit FailUnlock(params.optionId, reason);\n                continue;\n            }\n        }\n    }\n\n    /************************************************\n     *  READ ONLY FUNCTIONS\n     ***********************************************/\n\n    function userQueueCount(address user) public view returns (uint256) {\n        return userQueuedIds[user].length;\n    }\n\n    function userCancelledQueueCount(address user)\n        external\n        view\n        returns (uint256)\n    {\n        return userCancelledQueuedIds[user].length;\n    }\n\n    /************************************************\n     *  INTERNAL FUNCTIONS\n     ***********************************************/\n    function _validateKeeper() private view {\n        require(\n            !isInPrivateKeeperMode || isKeeper[msg.sender],\n            \"Keeper: forbidden\"\n        );\n    }\n\n    function _validateSigner(\n        uint256 timestamp,\n        address asset,\n        uint256 price,\n        bytes memory signature\n    ) internal view returns (bool) {\n        bytes32 digest = ECDSA.toEthSignedMessageHash(\n            keccak256(abi.encodePacked(timestamp, asset, price))\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        return recoveredSigner == publisher;\n    }\n\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n\n        // Check if slippage lies within the bounds\n        bool isSlippageWithinRange = optionsContract.isStrikeValid(\n            queuedTrade.slippage,\n            price,\n            queuedTrade.expectedStrike\n        );\n\n        if (!isSlippageWithinRange) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(\n                queuedTrade.user,\n                queueId,\n                \"Slippage limit exceeds\"\n            );\n\n            return;\n        }\n\n        // Check all the parameters and compute the amount and revised fee\n        uint256 amount;\n        uint256 revisedFee;\n        bool isReferralValid;\n        IBufferBinaryOptions.OptionParams\n            memory optionParams = IBufferBinaryOptions.OptionParams(\n                queuedTrade.expectedStrike,\n                0,\n                queuedTrade.period,\n                queuedTrade.isAbove,\n                queuedTrade.allowPartialFill,\n                queuedTrade.totalFee,\n                queuedTrade.user,\n                queuedTrade.referralCode,\n                queuedTrade.traderNFTId\n            );\n        try optionsContract.checkParams(optionParams) returns (\n            uint256 _amount,\n            uint256 _revisedFee,\n            bool _isReferralValid\n        ) {\n            (amount, revisedFee, isReferralValid) = (\n                _amount,\n                _revisedFee,\n                _isReferralValid\n            );\n        } catch Error(string memory reason) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(queuedTrade.user, queueId, reason);\n            return;\n        }\n\n        // Transfer the fee to the target options contract\n        IERC20 tokenX = IERC20(optionsContract.tokenX());\n        tokenX.transfer(queuedTrade.targetContract, revisedFee);\n\n        // Refund the user in case the trade amount was lesser\n        if (revisedFee < queuedTrade.totalFee) {\n            tokenX.transfer(\n                queuedTrade.user,\n                queuedTrade.totalFee - revisedFee\n            );\n        }\n\n        optionParams.totalFee = revisedFee;\n        optionParams.strike = price;\n        optionParams.amount = amount;\n\n        uint256 optionId = optionsContract.createFromRouter(\n            optionParams,\n            isReferralValid\n        );\n\n        queuedTrade.isQueued = false;\n\n        emit OpenTrade(queuedTrade.user, queueId, optionId);\n    }\n\n    function _cancelQueuedTrade(uint256 queueId) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n        queuedTrade.isQueued = false;\n        IERC20(optionsContract.tokenX()).transfer(\n            queuedTrade.user,\n            queuedTrade.totalFee\n        );\n\n        userCancelledQueuedIds[queuedTrade.user].push(queueId);\n    }\n}"
    }
  ]
}