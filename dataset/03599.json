{
  "Title": "[L11] Identical constants defined independently",
  "Content": "The constant `PLACEHOLDER_UINT` is defined in [`ShareMath`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/ShareMath.sol#L11) and again in [`RibbonVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L38). In both cases the constant is set to the same value, `1`. However, having no single source of truth for identical constants is error prone, especially as the project is iterated on and refactored.\n\n\nSince every contract that uses `PLACEHOLDER_UINT` also imports `ShareMath`, consider using `ShareMath.PLACEHOLDER_UINT` instead of redefining `PLACEHOLDER_UINT` in `RibbonVault`. Alternatively, consider setting the locally defined `PLACEHOLDER_UINT` equal to `ShareMath.PLACEHOLDER_UINT` directly, so that if the latter is updated the former will be as well.\n\n\n**Update**: *Fixed in [commit `a869738765a4c40b6f8bf5b03703bb255ba4da7f` of PR#98](https://github.com/ribbon-finance/ribbon-v2/pull/98/commits/a869738765a4c40b6f8bf5b03703bb255ba4da7f).*\n\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/ShareMath.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nlibrary ShareMath {\n    using SafeMath for uint256;\n\n    uint256 constant PLACEHOLDER_UINT = 1;\n\n    function underlyingToShares(\n        uint256 underlyingAmount,\n        uint256 pps,\n        uint8 decimals\n    ) internal pure returns (uint104) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(pps > PLACEHOLDER_UINT, \"Invalid pps\");\n\n        uint256 shares =\n            uint256(underlyingAmount).mul(10**uint256(decimals)).div(pps);\n        assertUint104(shares);\n\n        return uint104(shares);\n    }\n\n    function sharesToUnderlying(\n        uint256 shares,\n        uint256 pps,\n        uint8 decimals\n    ) internal pure returns (uint256) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(pps > PLACEHOLDER_UINT, \"Invalid pps\");\n\n        uint256 underlyingAmount =\n            uint256(shares).mul(pps).div(10**uint256(decimals));\n        assertUint104(shares);\n\n        return underlyingAmount;\n    }\n\n    /**\n     * @notice Returns the shares unredeemed by the user given their DepositReceipt\n     * @param depositReceipt is the user's deposit receipt\n     * @param currentRound is the `round` stored on the vault\n     * @param pps is the price in underlying per share\n     * @param decimals is the number of decimals the underlying/shares use\n     * @return unredeemedShares is the user's virtual balance of shares that are owed\n     */\n    function getSharesFromReceipt(\n        Vault.DepositReceipt memory depositReceipt,\n        uint256 currentRound,\n        uint256 pps,\n        uint8 decimals\n    ) internal pure returns (uint128 unredeemedShares) {\n        if (\n            depositReceipt.round > 0 &&\n            depositReceipt.round < currentRound &&\n            !depositReceipt.processed\n        ) {\n            uint256 sharesFromRound =\n                underlyingToShares(depositReceipt.amount, pps, decimals);\n\n            assertUint104(sharesFromRound);\n\n            uint256 unredeemedShares256 =\n                uint256(depositReceipt.unredeemedShares).add(sharesFromRound);\n            assertUint128(unredeemedShares256);\n\n            unredeemedShares = uint128(unredeemedShares256);\n        } else {\n            unredeemedShares = depositReceipt.unredeemedShares;\n        }\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n\n    function assertUint104(uint256 num) internal pure {\n        require(num <= type(uint104).max, \">U104\");\n    }\n\n    function assertUint128(uint256 num) internal pure {\n        require(num <= type(uint128).max, \">U128\");\n    }\n}"
    }
  ]
}