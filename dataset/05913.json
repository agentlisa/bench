{
  "Title": "[M-07] The owner of RPDX Decaying Bonds is not updated on token transfers",
  "Content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/decaying-bonds/RdpxDecayingBonds.sol#L36-L44> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/decaying-bonds/RdpxDecayingBonds.sol#L122>\n\nThe `RdpxDecayingBonds` contract keeps track of a `bonds` mapping with bonds information including the bond token owner. When the token is transfered, the `bonds[bondId].owner` value should be updated, but it isn't.\n\n### Impact\n\nThe `owner` value will be bricked when a token is transfered, as it can't be changed by any means.\n\nAny integration relying on this value will make wrong trusted assumptions related to the bond token owner, potentially leading to critical issues as loss of funds, because of the importance of the `owner` attribute has.\n\nRanking it as Medium, as there is no direct loss of funds within the current scope, but bricks the contract functionality, as there is no way to fix it.\n\n### Proof of Concept\n\nThe `owner` attribute of the `bonds` mapping is set on each `mint()`, but its value is never updated:\n\n```solidity\n  // Array of bonds\n  mapping(uint256 => Bond) public bonds;\n\n  // Structure to store the bond information\n  struct Bond {\n    address owner; // @audit\n    uint256 expiry;\n    uint256 rdpxAmount;\n  }\n```\n\n[RdpxDecayingBonds.sol#L36-L44](https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/decaying-bonds/RdpxDecayingBonds.sol#L36-L44)\n\n```solidity\n  function mint(\n    address to,\n    uint256 expiry,\n    uint256 rdpxAmount\n  ) external onlyRole(MINTER_ROLE) {\n    _whenNotPaused();\n    require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n    uint256 bondId = _mintToken(to);\n@>  bonds[bondId] = Bond(to, expiry, rdpxAmount); // @audit\n\n    emit BondMinted(to, bondId, expiry, rdpxAmount);\n  }\n```\n\n[RdpxDecayingBonds.sol#L122](https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/decaying-bonds/RdpxDecayingBonds.sol#L122)\n\n### Coded Proof of Concept\n\nThis test shows how the `owner` remains the same on the `bonds` transfer after performing a transfer.\n\nAdd this test to the `tests/RdpxDecayingBondsTest.t.sol` file, and run `forge test --mt \"testSameOwnerOnTransfer\"`:\n\n```solidity\n  function testSameOwnerOnTransfer() public {\n    // Mint a token\n    rdpxDecayingBonds.mint(address(this), 1223322, 5e18);\n\n    // The tokenId is 1\n    // This can be confirmed by the fact that it changes its `ownerOf()` result on the OZ ERC721 after the transfer\n    uint256 tokenId = 1;\n\n    // Check the bond token owner before the transfer\n    // Check for both via the `bonds` mapping, and the OZ `ownerOf()` function\n    (address ownerBeforeTransfer,,) = rdpxDecayingBonds.bonds(tokenId);\n    assertEq(ownerBeforeTransfer, address(this));\n    assertEq(rdpxDecayingBonds.ownerOf(tokenId), address(this));\n\n    // Transfer token\n    rdpxDecayingBonds.safeTransferFrom(address(this), address(420), tokenId);\n\n    // The `owner` changes on the OZ `ownerOf` function, while it remains the same on the `bonds` mapping\n    (address ownerAfterTransfer,,) = rdpxDecayingBonds.bonds(tokenId);\n    assertEq(ownerAfterTransfer, address(this));                        // @audit remains the same after the transfer\n    assertEq(rdpxDecayingBonds.ownerOf(tokenId), address(420));\n  }\n```\n\n### Recommended Mitigation Steps\n\nEither update the `owner` value on each token transfer, or remove it, as the owner of the token is already tracked via the OZ ERC721 contract.\n\n**[psytama (Dopex) confirmed](https://github.com/code-423n4/2023-08-dopex-findings/issues/1030#issuecomment-1734120024)**\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/1030#issuecomment-1759301770):**\n > The finding lacks a clear loss of funds, although that may be possible since `ownerOf` is used for internal checks.\n>\n> The code breaks the implementation of EIP721, and may also cause losses + issues with integrations.\n> \n> I think Medium Severity is appropriate.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/decaying-bonds/RdpxDecayingBonds.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\ncontract RdpxDecayingBonds is\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  Pausable,\n  AccessControl\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  Counters.Counter private _tokenIdCounter;\n\n  // Create a new role identifier for the minter role\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  // Create a new role identifier for the Rdpx v2 core role\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  // Array of bonds\n  mapping(uint256 => Bond) public bonds;\n\n  // Structure to store the bond information\n  struct Bond {\n    address owner;\n    uint256 expiry;\n    uint256 rdpxAmount;\n  }\n\n  event BondMinted(\n    address to,\n    uint256 bondId,\n    uint256 expiry,\n    uint256 rdpxAmount\n  );\n\n  event EmergencyWithdraw(address sender);\n\n  /*==== CONSTRUCTOR ====*/\n  constructor(\n    string memory _name,\n    string memory _symbol\n  ) ERC721(_name, _symbol) {\n    // Grant the minter role and admin role to deployer\n    _setupRole(MINTER_ROLE, msg.sender);\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _tokenIdCounter.increment();\n  }\n\n  /*============ ADMIN FUNCTIONS ============*/\n\n  /// @notice Pauses the vault for emergency cases\n  /// @dev Can only be called by the owner\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /// @notice Unpauses the vault\n  /// @dev Can only be called by the owner\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   * @param  transferNative Whether should transfer the native currency\n   * @param  to The address to transfer the funds to\n   * @param  amount The amount to transfer\n   * @param  gas The gas to use for the transfer\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens,\n    bool transferNative,\n    address payable to,\n    uint256 amount,\n    uint256 gas\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    if (transferNative) {\n      (bool success, ) = to.call{ value: amount, gas: gas }(\"\");\n      require(success, \"RdpxReserve: transfer failed\");\n    }\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n  }\n\n  /// @notice Mints decaying rdpx bonds\n  /// @dev Can only be called by the minter\n  /// @param to address of the user to mint the bonds for\n  /// @param expiry timestamp of the bond expiry\n  /// @param rdpxAmount amount of rdpx to bond\n  function mint(\n    address to,\n    uint256 expiry,\n    uint256 rdpxAmount\n  ) external onlyRole(MINTER_ROLE) {\n    _whenNotPaused();\n    require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n    uint256 bondId = _mintToken(to);\n    bonds[bondId] = Bond(to, expiry, rdpxAmount);\n\n    emit BondMinted(to, bondId, expiry, rdpxAmount);\n  }\n\n  /// @dev Internal function to mint a bond position token\n  /// @param to the address to mint the position to\n  function _mintToken(address to) private returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(to, tokenId);\n  }\n\n  /// @notice Decreases the bond amount\n  /// @dev Can only be called by the rdpxV2Core\n  /// @param bondId id of the bond to decrease\n  /// @param amount amount to decrease\n  function decreaseAmount(\n    uint256 bondId,\n    uint256 amount\n  ) public onlyRole(RDPXV2CORE_ROLE) {\n    _whenNotPaused();\n    bonds[bondId].rdpxAmount = amount;\n  }\n\n  /*============ VIEW FUNCTIONS ============*/\n\n  /// @notice returns the bonds owned by an address\n  /// @param _address address of the user\n  function getBondsOwned(\n    address _address\n  ) external view returns (uint256[] memory) {\n    uint256 ownerTokenCount = balanceOf(_address);\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n    for (uint256 i; i < ownerTokenCount; i++) {\n      tokenIds[i] = tokenOfOwnerByIndex(_address, i);\n    }\n    return tokenIds;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  // The following functions are overrides required by Solidity.\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}"
    },
    {
      "filename": "contracts/decaying-bonds/RdpxDecayingBonds.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\ncontract RdpxDecayingBonds is\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  Pausable,\n  AccessControl\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  Counters.Counter private _tokenIdCounter;\n\n  // Create a new role identifier for the minter role\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  // Create a new role identifier for the Rdpx v2 core role\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  // Array of bonds\n  mapping(uint256 => Bond) public bonds;\n\n  // Structure to store the bond information\n  struct Bond {\n    address owner;\n    uint256 expiry;\n    uint256 rdpxAmount;\n  }\n\n  event BondMinted(\n    address to,\n    uint256 bondId,\n    uint256 expiry,\n    uint256 rdpxAmount\n  );\n\n  event EmergencyWithdraw(address sender);\n\n  /*==== CONSTRUCTOR ====*/\n  constructor(\n    string memory _name,\n    string memory _symbol\n  ) ERC721(_name, _symbol) {\n    // Grant the minter role and admin role to deployer\n    _setupRole(MINTER_ROLE, msg.sender);\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _tokenIdCounter.increment();\n  }\n\n  /*============ ADMIN FUNCTIONS ============*/\n\n  /// @notice Pauses the vault for emergency cases\n  /// @dev Can only be called by the owner\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /// @notice Unpauses the vault\n  /// @dev Can only be called by the owner\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   * @param  transferNative Whether should transfer the native currency\n   * @param  to The address to transfer the funds to\n   * @param  amount The amount to transfer\n   * @param  gas The gas to use for the transfer\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens,\n    bool transferNative,\n    address payable to,\n    uint256 amount,\n    uint256 gas\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    if (transferNative) {\n      (bool success, ) = to.call{ value: amount, gas: gas }(\"\");\n      require(success, \"RdpxReserve: transfer failed\");\n    }\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n  }\n\n  /// @notice Mints decaying rdpx bonds\n  /// @dev Can only be called by the minter\n  /// @param to address of the user to mint the bonds for\n  /// @param expiry timestamp of the bond expiry\n  /// @param rdpxAmount amount of rdpx to bond\n  function mint(\n    address to,\n    uint256 expiry,\n    uint256 rdpxAmount\n  ) external onlyRole(MINTER_ROLE) {\n    _whenNotPaused();\n    require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n    uint256 bondId = _mintToken(to);\n    bonds[bondId] = Bond(to, expiry, rdpxAmount);\n\n    emit BondMinted(to, bondId, expiry, rdpxAmount);\n  }\n\n  /// @dev Internal function to mint a bond position token\n  /// @param to the address to mint the position to\n  function _mintToken(address to) private returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(to, tokenId);\n  }\n\n  /// @notice Decreases the bond amount\n  /// @dev Can only be called by the rdpxV2Core\n  /// @param bondId id of the bond to decrease\n  /// @param amount amount to decrease\n  function decreaseAmount(\n    uint256 bondId,\n    uint256 amount\n  ) public onlyRole(RDPXV2CORE_ROLE) {\n    _whenNotPaused();\n    bonds[bondId].rdpxAmount = amount;\n  }\n\n  /*============ VIEW FUNCTIONS ============*/\n\n  /// @notice returns the bonds owned by an address\n  /// @param _address address of the user\n  function getBondsOwned(\n    address _address\n  ) external view returns (uint256[] memory) {\n    uint256 ownerTokenCount = balanceOf(_address);\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n    for (uint256 i; i < ownerTokenCount; i++) {\n      tokenIds[i] = tokenOfOwnerByIndex(_address, i);\n    }\n    return tokenIds;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  // The following functions are overrides required by Solidity.\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}"
    },
    {
      "filename": "contracts/decaying-bonds/RdpxDecayingBonds.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\ncontract RdpxDecayingBonds is\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  Pausable,\n  AccessControl\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  Counters.Counter private _tokenIdCounter;\n\n  // Create a new role identifier for the minter role\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  // Create a new role identifier for the Rdpx v2 core role\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  // Array of bonds\n  mapping(uint256 => Bond) public bonds;\n\n  // Structure to store the bond information\n  struct Bond {\n    address owner;\n    uint256 expiry;\n    uint256 rdpxAmount;\n  }\n\n  event BondMinted(\n    address to,\n    uint256 bondId,\n    uint256 expiry,\n    uint256 rdpxAmount\n  );\n\n  event EmergencyWithdraw(address sender);\n\n  /*==== CONSTRUCTOR ====*/\n  constructor(\n    string memory _name,\n    string memory _symbol\n  ) ERC721(_name, _symbol) {\n    // Grant the minter role and admin role to deployer\n    _setupRole(MINTER_ROLE, msg.sender);\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _tokenIdCounter.increment();\n  }\n\n  /*============ ADMIN FUNCTIONS ============*/\n\n  /// @notice Pauses the vault for emergency cases\n  /// @dev Can only be called by the owner\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /// @notice Unpauses the vault\n  /// @dev Can only be called by the owner\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   * @param  transferNative Whether should transfer the native currency\n   * @param  to The address to transfer the funds to\n   * @param  amount The amount to transfer\n   * @param  gas The gas to use for the transfer\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens,\n    bool transferNative,\n    address payable to,\n    uint256 amount,\n    uint256 gas\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    if (transferNative) {\n      (bool success, ) = to.call{ value: amount, gas: gas }(\"\");\n      require(success, \"RdpxReserve: transfer failed\");\n    }\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n  }\n\n  /// @notice Mints decaying rdpx bonds\n  /// @dev Can only be called by the minter\n  /// @param to address of the user to mint the bonds for\n  /// @param expiry timestamp of the bond expiry\n  /// @param rdpxAmount amount of rdpx to bond\n  function mint(\n    address to,\n    uint256 expiry,\n    uint256 rdpxAmount\n  ) external onlyRole(MINTER_ROLE) {\n    _whenNotPaused();\n    require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n    uint256 bondId = _mintToken(to);\n    bonds[bondId] = Bond(to, expiry, rdpxAmount);\n\n    emit BondMinted(to, bondId, expiry, rdpxAmount);\n  }\n\n  /// @dev Internal function to mint a bond position token\n  /// @param to the address to mint the position to\n  function _mintToken(address to) private returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(to, tokenId);\n  }\n\n  /// @notice Decreases the bond amount\n  /// @dev Can only be called by the rdpxV2Core\n  /// @param bondId id of the bond to decrease\n  /// @param amount amount to decrease\n  function decreaseAmount(\n    uint256 bondId,\n    uint256 amount\n  ) public onlyRole(RDPXV2CORE_ROLE) {\n    _whenNotPaused();\n    bonds[bondId].rdpxAmount = amount;\n  }\n\n  /*============ VIEW FUNCTIONS ============*/\n\n  /// @notice returns the bonds owned by an address\n  /// @param _address address of the user\n  function getBondsOwned(\n    address _address\n  ) external view returns (uint256[] memory) {\n    uint256 ownerTokenCount = balanceOf(_address);\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n    for (uint256 i; i < ownerTokenCount; i++) {\n      tokenIds[i] = tokenOfOwnerByIndex(_address, i);\n    }\n    return tokenIds;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  // The following functions are overrides required by Solidity.\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}"
    },
    {
      "filename": "contracts/decaying-bonds/RdpxDecayingBonds.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\ncontract RdpxDecayingBonds is\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  Pausable,\n  AccessControl\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  Counters.Counter private _tokenIdCounter;\n\n  // Create a new role identifier for the minter role\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  // Create a new role identifier for the Rdpx v2 core role\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  // Array of bonds\n  mapping(uint256 => Bond) public bonds;\n\n  // Structure to store the bond information\n  struct Bond {\n    address owner;\n    uint256 expiry;\n    uint256 rdpxAmount;\n  }\n\n  event BondMinted(\n    address to,\n    uint256 bondId,\n    uint256 expiry,\n    uint256 rdpxAmount\n  );\n\n  event EmergencyWithdraw(address sender);\n\n  /*==== CONSTRUCTOR ====*/\n  constructor(\n    string memory _name,\n    string memory _symbol\n  ) ERC721(_name, _symbol) {\n    // Grant the minter role and admin role to deployer\n    _setupRole(MINTER_ROLE, msg.sender);\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _tokenIdCounter.increment();\n  }\n\n  /*============ ADMIN FUNCTIONS ============*/\n\n  /// @notice Pauses the vault for emergency cases\n  /// @dev Can only be called by the owner\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /// @notice Unpauses the vault\n  /// @dev Can only be called by the owner\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   * @param  transferNative Whether should transfer the native currency\n   * @param  to The address to transfer the funds to\n   * @param  amount The amount to transfer\n   * @param  gas The gas to use for the transfer\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens,\n    bool transferNative,\n    address payable to,\n    uint256 amount,\n    uint256 gas\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    if (transferNative) {\n      (bool success, ) = to.call{ value: amount, gas: gas }(\"\");\n      require(success, \"RdpxReserve: transfer failed\");\n    }\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n  }\n\n  /// @notice Mints decaying rdpx bonds\n  /// @dev Can only be called by the minter\n  /// @param to address of the user to mint the bonds for\n  /// @param expiry timestamp of the bond expiry\n  /// @param rdpxAmount amount of rdpx to bond\n  function mint(\n    address to,\n    uint256 expiry,\n    uint256 rdpxAmount\n  ) external onlyRole(MINTER_ROLE) {\n    _whenNotPaused();\n    require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n    uint256 bondId = _mintToken(to);\n    bonds[bondId] = Bond(to, expiry, rdpxAmount);\n\n    emit BondMinted(to, bondId, expiry, rdpxAmount);\n  }\n\n  /// @dev Internal function to mint a bond position token\n  /// @param to the address to mint the position to\n  function _mintToken(address to) private returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(to, tokenId);\n  }\n\n  /// @notice Decreases the bond amount\n  /// @dev Can only be called by the rdpxV2Core\n  /// @param bondId id of the bond to decrease\n  /// @param amount amount to decrease\n  function decreaseAmount(\n    uint256 bondId,\n    uint256 amount\n  ) public onlyRole(RDPXV2CORE_ROLE) {\n    _whenNotPaused();\n    bonds[bondId].rdpxAmount = amount;\n  }\n\n  /*============ VIEW FUNCTIONS ============*/\n\n  /// @notice returns the bonds owned by an address\n  /// @param _address address of the user\n  function getBondsOwned(\n    address _address\n  ) external view returns (uint256[] memory) {\n    uint256 ownerTokenCount = balanceOf(_address);\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n    for (uint256 i; i < ownerTokenCount; i++) {\n      tokenIds[i] = tokenOfOwnerByIndex(_address, i);\n    }\n    return tokenIds;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  // The following functions are overrides required by Solidity.\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}"
    }
  ]
}