{
  "Title": "[M-08] The Restriction Manager does not completely implement ERC1404 which leads to accounts that are supposed to be restricted actually having access to do with their tokens as they see fit",
  "Content": "\nMedium, contract's intended logic is for *blacklisted* users not to be able to interact with their system so as to follow rules set by regulationary bodies in the case where a user does anything that warrants them to be blacklisted, but this is clearly broken since only half the window is closed as current implementation only checks on receiver being blacklisted and not sender.\n\n### Proof of Concept\n\nThe current implementation of the ERC1404 restrictions within the `RestrictionManager.sol` contract only places restrictions on the receiving address in token transfer instances. This oversight means that the sending addresses are not restricted, which poses a regulatory and compliance risk. Should a user be `blacklisted` for any reason, they can continue to transfer tokens as long as the receiving address is a valid member. This behaviour is contrary to expectations from regulatory bodies, especially say in the U.S where these bodies are very strict and a little in-compliance could land Centrifuge a lawsuit., which may expect complete trading restrictions for such blacklisted individuals.\n\nWithin the `RestrictionManager` contract, the method `detectTransferRestriction` only checks if the receiving address (`to`) is a valid member:\n\n[RestrictionManager.sol#L28-L34](https://github.com/code-423n4/2023-09-centrifuge/blob/512e7a71ebd9ae76384f837204216f26380c9f91/src/token/RestrictionManager.sol#L28-L34)\n\n```solidity\nfunction detectTransferRestriction(address from, address to, uint256 value) public view returns (uint8) {\n    if (!hasMember(to)) {\n        return DESTINATION_NOT_A_MEMBER_RESTRICTION_CODE;\n    }\n    return SUCCESS_CODE;\n}\n```\n\nIn the above code, the sending address (`from`) is never checked against the membership restrictions, which means blacklisted users can still initiate transfers and when checking the transfer restriction from both `tranchtoken.sol` and the `liquiditypool.sol` it's going to wrongly return true for a personnel that should be false\n\nSee [Tranche.sol#L80-L82)](https://github.com/code-423n4/2023-09-centrifuge/blob/512e7a71ebd9ae76384f837204216f26380c9f91/src/token/Tranche.sol#L80-L82)\n\n```solidity\n// function checkTransferRestriction(address from, address to, uint256 value) public view returns (bool) {\n//     return share.checkTransferRestriction(from, to, value);\n// }\n```\n\nAlso [Tranche.sol#L35-L39](https://github.com/code-423n4/2023-09-centrifuge/blob/512e7a71ebd9ae76384f837204216f26380c9f91/src/token/Tranche.sol#L35-L39)\n\n```solidity\n    modifier restricted(address from, address to, uint256 value) {\n        uint8 restrictionCode = detectTransferRestriction(from, to, value);\n        require(restrictionCode == restrictionManager.SUCCESS_CODE(), messageForTransferRestriction(restrictionCode));\n        _;\n    }\n```\n\nThis function suggests that the system's logic may rely on the `detectTransferRestriction` method in other parts of the ecosystem. Consequently, if the restriction manager's logic is flawed, these other parts may also allow unauthorised transfers.\n\n**Foundry POC**\n\nAdd this to the `Tranche.t.sol` contract\n\n```solidity\n    function testTransferFromTokensFromBlacklistedAccountWorks(uint256 amount, address targetUser, uint256 validUntil) public {\n        vm.assume(baseAssumptions(validUntil, targetUser));\n\n        restrictionManager.updateMember(targetUser, validUntil);\n        assertEq(restrictionManager.members(targetUser), validUntil);\n        restrictionManager.updateMember(address(this), block.timestamp);\n        assertEq(restrictionManager.members(address(this)), block.timestamp);\n\n        token.mint(address(this), amount);\n        vm.warp(block.timestamp + 1);\n\n        token.transferFrom(address(this), targetUser, amount);\n        assertEq(token.balanceOf(targetUser), amount);\n    }\n```\n\nAs seen even after `address(this)` stops being a member they could still transfer tokens to another user in as much as said user is still a member, which means a *blacklisted* user could easily do anything with their tokens all they need to do is to delegate to another member.\n\n### Recommended Mitigation Steps\n\nRefactor`detectTransferRestriction()`, i.e modify the method to also validate the sending address (`from`). Ensure both `from` and `to` addresses are valid members before allowing transfers.\n\nIf this is contract's intended logic then this information should be duly passed to the regulatory bodies that a `user` can't really get blacklisted and more of user's could be stopped from receiving tokens.\n\n### Assessed type\n\nContext\n\n**[hieronx (Centrifuge) commented](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/779#issuecomment-1734178040):**\n > This is a design decision. Transferring to a valid member is fine if that destination is still allowed to hold the tokens.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/779#issuecomment-1735811683):**\n > > This is a design decision. Transferring to a valid member is fine if that destination is still allowed to hold the tokens.\n> \n> This seems to contradict with `Removing an investor from the memberlist in the Restriction Manager locks their tokens. This is expected behaviour.` (See [here](https://github.com/code-423n4/2023-09-centrifuge/blob/512e7a71ebd9ae76384f837204216f26380c9f91/README.md?plain=1#L140))\n\n**[hieronx (Centrifuge) commented](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/779#issuecomment-1735838137):**\n > Yes you're right, that's unfortunate wording. What I said above is correct, and the text in the README is incorrect. What was meant was that it locks their tranche tokens from being redeemed.\n> \n> It is indeed fair to say though that, based on the README text, the above issue is valid.\n\n**[hieronx (Centrifuge) commented](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/779#issuecomment-1745021967):**\n > Mitigated in https://github.com/centrifuge/liquidity-pools/pull/138\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-centrifuge",
  "Code": [
    {
      "filename": "src/token/RestrictionManager.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.21;\n\nimport {Auth} from \"./../util/Auth.sol\";\n\ninterface MemberlistLike {\n    function updateMember(address user, uint256 validUntil) external;\n    function members(address user) external view returns (uint256);\n    function hasMember(address user) external view returns (bool);\n}\n\n/// @title  Restriction Manager\n/// @notice ERC1404 based contract that checks transfer restrictions.\ncontract RestrictionManager is Auth {\n    uint8 public constant SUCCESS_CODE = 0;\n    uint8 public constant DESTINATION_NOT_A_MEMBER_RESTRICTION_CODE = 1;\n    string public constant SUCCESS_MESSAGE = \"RestrictionManager/transfer-allowed\";\n    string public constant DESTINATION_NOT_A_MEMBER_RESTRICTION_MESSAGE = \"RestrictionManager/destination-not-a-member\";\n\n    mapping(address => uint256) public members;\n\n    constructor() {\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- ERC1404 implementation ---\n    function detectTransferRestriction(address from, address to, uint256 value) public view returns (uint8) {\n        if (!hasMember(to)) {\n            return DESTINATION_NOT_A_MEMBER_RESTRICTION_CODE;\n        }\n\n        return SUCCESS_CODE;\n    }\n\n    function messageForTransferRestriction(uint8 restrictionCode) public view returns (string memory) {\n        if (restrictionCode == DESTINATION_NOT_A_MEMBER_RESTRICTION_CODE) {\n            return DESTINATION_NOT_A_MEMBER_RESTRICTION_MESSAGE;\n        }\n\n        return SUCCESS_MESSAGE;\n    }\n\n    // --- Checking members ---\n    function member(address user) public view {\n        require((members[user] >= block.timestamp), \"RestrictionManager/destination-not-a-member\");\n    }\n\n    function hasMember(address user) public view returns (bool) {\n        if (members[user] >= block.timestamp) {\n            return true;\n        }\n        return false;\n    }\n\n    // --- Updating members ---\n    function updateMember(address user, uint256 validUntil) public auth {\n        require(block.timestamp <= validUntil, \"RestrictionManager/invalid-valid-until\");\n        members[user] = validUntil;\n    }\n\n    function updateMembers(address[] memory users, uint256 validUntil) public auth {\n        uint256 userLength = users.length;\n        for (uint256 i = 0; i < userLength; i++) {\n            updateMember(users[i], validUntil);\n        }\n    }\n}"
    },
    {
      "filename": "src/token/Tranche.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.21;\n\nimport {ERC20} from \"./ERC20.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\ninterface TrancheTokenLike is IERC20 {\n    function file(bytes32 what, string memory data) external;\n    function restrictionManager() external view returns (address);\n}\n\ninterface ERC1404Like {\n    function detectTransferRestriction(address from, address to, uint256 value) external view returns (uint8);\n    function messageForTransferRestriction(uint8 restrictionCode) external view returns (string memory);\n    function SUCCESS_CODE() external view returns (uint8);\n}\n\n/// @title  Tranche Token\n/// @notice Extension of ERC20 + ERC1404 for tranche tokens,\n///         which manages the liquidity pools that are considered\n///         trusted forwarded for the ERC20 token, and ensures\n///         the transfer restrictions as defined in the RestrictionManager.\ncontract TrancheToken is ERC20, ERC1404Like {\n    ERC1404Like public restrictionManager;\n\n    mapping(address => bool) public liquidityPools;\n\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n    event AddLiquidityPool(address indexed liquidityPool);\n    event RemoveLiquidityPool(address indexed liquidityPool);\n\n    constructor(uint8 decimals_) ERC20(decimals_) {}\n\n    modifier restricted(address from, address to, uint256 value) {\n        uint8 restrictionCode = detectTransferRestriction(from, to, value);\n        require(restrictionCode == restrictionManager.SUCCESS_CODE(), messageForTransferRestriction(restrictionCode));\n        _;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) public auth {\n        if (what == \"restrictionManager\") restrictionManager = ERC1404Like(data);\n        else revert(\"TrancheToken/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    function addLiquidityPool(address liquidityPool) public auth {\n        liquidityPools[liquidityPool] = true;\n        emit AddLiquidityPool(liquidityPool);\n    }\n\n    function removeLiquidityPool(address liquidityPool) public auth {\n        liquidityPools[liquidityPool] = false;\n        emit RemoveLiquidityPool(liquidityPool);\n    }\n\n    // --- Restrictions ---\n    function transfer(address to, uint256 value) public override restricted(_msgSender(), to, value) returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value)\n        public\n        override\n        restricted(from, to, value)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, value);\n    }\n\n    function mint(address to, uint256 value) public override restricted(_msgSender(), to, value) {\n        return super.mint(to, value);\n    }\n\n    function detectTransferRestriction(address from, address to, uint256 value) public view returns (uint8) {\n        return restrictionManager.detectTransferRestriction(from, to, value);\n    }\n\n    function checkTransferRestriction(address from, address to, uint256 value) public view returns (bool) {\n        return restrictionManager.detectTransferRestriction(from, to, value) == SUCCESS_CODE();\n    }\n\n    function messageForTransferRestriction(uint8 restrictionCode) public view returns (string memory) {\n        return restrictionManager.messageForTransferRestriction(restrictionCode);\n    }\n\n    function SUCCESS_CODE() public view returns (uint8) {\n        return restrictionManager.SUCCESS_CODE();\n    }\n\n    // --- ERC2771Context ---\n    function isTrustedForwarder(address forwarder) public view returns (bool) {\n        // Liquidity Pools are considered trusted forwarders\n        // for the ERC2771Context implementation of the underlying\n        // ERC20 token\n        return liquidityPools[forwarder];\n    }\n\n    /// @dev    Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n    ///         a call is not performed by the trusted forwarder or the calldata length is less than\n    ///         20 bytes (an address length).\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n}"
    },
    {
      "filename": "src/token/Tranche.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.21;\n\nimport {ERC20} from \"./ERC20.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\ninterface TrancheTokenLike is IERC20 {\n    function file(bytes32 what, string memory data) external;\n    function restrictionManager() external view returns (address);\n}\n\ninterface ERC1404Like {\n    function detectTransferRestriction(address from, address to, uint256 value) external view returns (uint8);\n    function messageForTransferRestriction(uint8 restrictionCode) external view returns (string memory);\n    function SUCCESS_CODE() external view returns (uint8);\n}\n\n/// @title  Tranche Token\n/// @notice Extension of ERC20 + ERC1404 for tranche tokens,\n///         which manages the liquidity pools that are considered\n///         trusted forwarded for the ERC20 token, and ensures\n///         the transfer restrictions as defined in the RestrictionManager.\ncontract TrancheToken is ERC20, ERC1404Like {\n    ERC1404Like public restrictionManager;\n\n    mapping(address => bool) public liquidityPools;\n\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n    event AddLiquidityPool(address indexed liquidityPool);\n    event RemoveLiquidityPool(address indexed liquidityPool);\n\n    constructor(uint8 decimals_) ERC20(decimals_) {}\n\n    modifier restricted(address from, address to, uint256 value) {\n        uint8 restrictionCode = detectTransferRestriction(from, to, value);\n        require(restrictionCode == restrictionManager.SUCCESS_CODE(), messageForTransferRestriction(restrictionCode));\n        _;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) public auth {\n        if (what == \"restrictionManager\") restrictionManager = ERC1404Like(data);\n        else revert(\"TrancheToken/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    function addLiquidityPool(address liquidityPool) public auth {\n        liquidityPools[liquidityPool] = true;\n        emit AddLiquidityPool(liquidityPool);\n    }\n\n    function removeLiquidityPool(address liquidityPool) public auth {\n        liquidityPools[liquidityPool] = false;\n        emit RemoveLiquidityPool(liquidityPool);\n    }\n\n    // --- Restrictions ---\n    function transfer(address to, uint256 value) public override restricted(_msgSender(), to, value) returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value)\n        public\n        override\n        restricted(from, to, value)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, value);\n    }\n\n    function mint(address to, uint256 value) public override restricted(_msgSender(), to, value) {\n        return super.mint(to, value);\n    }\n\n    function detectTransferRestriction(address from, address to, uint256 value) public view returns (uint8) {\n        return restrictionManager.detectTransferRestriction(from, to, value);\n    }\n\n    function checkTransferRestriction(address from, address to, uint256 value) public view returns (bool) {\n        return restrictionManager.detectTransferRestriction(from, to, value) == SUCCESS_CODE();\n    }\n\n    function messageForTransferRestriction(uint8 restrictionCode) public view returns (string memory) {\n        return restrictionManager.messageForTransferRestriction(restrictionCode);\n    }\n\n    function SUCCESS_CODE() public view returns (uint8) {\n        return restrictionManager.SUCCESS_CODE();\n    }\n\n    // --- ERC2771Context ---\n    function isTrustedForwarder(address forwarder) public view returns (bool) {\n        // Liquidity Pools are considered trusted forwarders\n        // for the ERC2771Context implementation of the underlying\n        // ERC20 token\n        return liquidityPools[forwarder];\n    }\n\n    /// @dev    Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n    ///         a call is not performed by the trusted forwarder or the calldata length is less than\n    ///         20 bytes (an address length).\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n}"
    },
    {
      "filename": "README.md?plain=1",
      "content": "[![Centrifuge](https://github.com/code-423n4/2023-09-centrifuge/blob/main/images/header.png?raw=true)](https://github.com/code-423n4/2023-09-centrifuge)\n\nThe institutional ecosystem for onchain credit.  \n[**View our website »**](https://centrifuge.io/)   [**Read the documentation »**](https://docs.centrifuge.io/)   [**Try the app »**](https://app.centrifuge.io/)\n\n# Centrifuge audit details\n- Total Prize Pool: $70,000 USDC\n  - HM awards: $49,300 USDC\n  - Analysis awards: $2,900 USDC\n  - QA awards: $1,450 USDC\n  - Bot Race awards: $4,350 USDC\n  - Gas awards: $0 USDC \n  - Judge awards: $7,000 USDC\n  - Lookout awards: $4,500 USDC \n  - Scout awards: $500 USDC \n- Join [C4 Discord](https://discord.gg/code4rena) to register\n- Submit findings [using the C4 form](https://code4rena.com/contests/2023-09-centrifuge/submit)\n- [Read our guidelines for more details](https://docs.code4rena.com/roles/wardens)\n- Starts September 8, 2023 20:00 UTC \n- Ends September 14, 2023 20:00 UTC \n\n## Automated Findings / Publicly Known Issues\n\nAutomated findings output for the audit can be found [here](https://github.com/code-423n4/2023-09-centrifuge/blob/main/bot-report.md) within 24 hours of audit opening.\n\n*Note for C4 wardens: Anything included in the automated findings output is considered a publicly known issue and is ineligible for awards.*\n\n# Overview\nFounded in 2017, Centrifuge is the institutional platform for credit onchain. Centrifuge was the first protocol where MakerDAO minted DAI against a real-world asset, the first onchain securitization, and Centrifuge launched the RWA Market with Aave. Centrifuge’s multi-chain strategy allows investors to access native RWA yields on the network of their choice.\n\nCentrifuge works based on a hub-and-spoke model. RWA pools are managed by borrowers on Centrifuge Chain, an application-specific blockchain built purposely for managing real world assets. Liquidity Pools are deployed on any other L1 or L2 where there is demand for RWA, and each Liquidity Pool deployment communicates directly with Centrifuge Chain using messaging layers.\n\n## High level contract overview\n![Contract overview.](https://github.com/code-423n4/2023-09-centrifuge/blob/main/images/contracts.png?raw=true)\n\nInvestors can invest in multiple tranches for each RWA pool. Each of these tranches is a separate deployment of a Liquidity Pool and a Tranche Token.\n- [**Liquidity Pool**](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol): A [ERC-4626](https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/) compatible contract that enables investors to deposit and withdraw stablecoins to invest in tranches of pools.\n- [**Tranche Token**](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/token/Tranche.sol): An [ERC-20](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/) token for the tranche, linked to a [`RestrictionManager`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/token/RestrictionManager.sol) that manages transfer restrictions. Prices for tranche tokens are computed on Centrifuge.\n\nThe deployment of these tranches and the management of investments is controlled by the underlying InvestmentManager, TokenManager, Gateway, and Routers.\n- [**Investment Manager**](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol): The core business logic contract that handles pool creation, tranche deployment, managing investments and sending tokens to the [`Escrow`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/Escrow.sol) and [`UserEscrow`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/UserEscrow.sol), and more.\n- [**Pool Manager**](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/PoolManager.sol): The second business logic contract that handles currency bookkeeping, and transferring tranche tokens as well as currencies.\n- [**Gateway**](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/gateway/Gateway.sol): Intermediary contract that encodes and decodes messages using [`Messages`](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/gateway/Messages.sol) and handles routing to/from Centrifuge.\n- [**Routers**](https://github.com/code-423n4/2023-09-centrifuge/tree/main/src/routers): Contracts that handle communication of messages to and from Centrifuge Chain.\n\n> [!NOTE]  \n> The coding style of the `liquidity-pools` code base is heavily inspired by [MakerDAO's coding style](https://github.com/makerdao/pe-checklists/blob/master/core/standards.md). Composition over inheritance, no upgradeable proxies but rather using contract migrations, and as few dependencies as possible. Authentication uses the `ward` pattern, in which addresses can be `relied` or `denied` to get access. Key parameter updates of contracts are executed through `file` methods.\n\n## How it works\nUsing the Centrifuge protocol, issuers can launch pools of real-world assets. Each pool can have 1 or more tranches that investors can buy. The purpose of these tranches is to give investors different kinds of risk exposure and yield on the same asset class. Each pool has 1 pool currency. The decimals of this pool currency define the decimals of the tranche tokens that are issued per tranche. Both deposit (also known as investments) and redemptions in tranches of Centrifuge pool happen asynchronously, through an epoch mechanism. Prices for tranches are calculated on Centrifuge Chain based on the Net Asset Value of the real world assets in the pool. More information on this can be found in the [documentation](https://docs.centrifuge.io/getting-started/securitization/).\n\nBecause of the epoch mechanism, as well as the fact that Liquidity Pools communicate with Centrifuge Chain through messaging layers, deposits and redemptions cannot be executed automatically, and rather are executed asynchronously. A key goal if Liquidity Pools is to increase composability of Centrifuge assets, by leveraging ERC4626. However, ERC4626 assumes atomic deposits and withdrawals, thus the Liquidity Pool contracts are extended with methods for requesting deposits & redemptions. There is also support for permits when requesting deposits/redemptions. More details on this in `User flows` below.\n\nThe communication between Liquidity Pools and Centrifuge Chain uses external general message passing protocols. Messages are encoded using a compacted ABI encoding scheme, as implemented in `src/gateway/Messages.sol`.\n\n### Multiple currency support\nWhile there is 1 native pool currency, Liquidity Pools (acronym: LP) are built to support deposits in multiple currencies. Each Liquidity Pool is linked to 1 currency (asset) and 1 tranche token (share), but Liquidity Pools can be deployed linked to the same tranche token (share). The Liquidity Pool contract therefore passes through the ERC20 methods to the underlying share implementation. To support this, the ERC20 of the tranche token uses ERC2771 context, and the tranche token contract ensures that all Liquidity Pools are considered trusted forwarders for this.\n\nThe other challenge with supporting multiple currencies is that the decimals between the tranche token (which is based on the native pool currency decimals) and the investment currency (or asset) can differ. Therefore, all price calculations and conversions between shares and assets (or tranche tokens and currencies) need to account for these differences. This is accomplished by normalizing all balances and prices to 18 decimal fixed point integers, doing the calculations using these normalized values, and then unnormalizing back to the intended decimals. Currencies with more than 18 decimals are not supported and blocked in the contracts.\n\n### Access setup\nThe `Root` contract is a `ward` on all other contracts. The `PauseAdmin` can instantaneously pause the protocol. The `DelayedAdmin` can make itself `ward` on any contract through `Root.relyContract`, but this needs to go through the timelock specified in `Root.delay`. The `Root.delay` will initially be set to 48 hours.\n\nBy default, all actions in Liquidity Pools should occur through messages coming in from a router, that was transported from Centrifuge Chain. This includes any upgrades, which can be triggered through a `ScheduleUpgrade` message. This also calls `Root.relyContract`, and also is protected by the timelock.\n\nSome possible emergency scenarios are described below:\n\n**Someone gains control over a router and triggers a malicious `ScheduleUpgrade` message**\n\n* Within 48h, the pause admin calls `pause()` to block further incoming messages from the router. The delayed admin calls `cancelRely()` to cancel the scheduled rely from the router exploiter.\n* The delayed admin submits a `scheduleRely()` to remove the router from the gateway contract 48h later.\n* After 48h, the router is removed and cannot interact with the system anymore.\n\n**Someone controls 1 pause admin and triggers a malicious `pause()`**\n\n* The delayed admin is a `ward` on the pause admin and can trigger `PauseAdmin.removePauser`.\n* It can then trigger `root.unpause()`.\n\n**Someone gains control over a router and triggers a malicious `Transfer` message**\n\nThis scenario is not fully protected, as funds currently locked in the `Escrow` contract can be transferred out. However, there are two important factors that reduce the capital at stake.\n\n1. As described in `Liquidity management`, liquidity is constantly transferred between different blockchains. Since funds are actually withdrawn from the pool by a borrower, this leads to most funds not being stuck in the Escrow. In practice, only funds currently in process of being invested are in the `Escrow` contract.\n2. For tokens that have been `requestRedeem()`ed, but not yet withdrawn, these are held in the `UserEscrow` contract. The key design principle of this contract is that once tokens are transferred in, they are locked to a specific destination, and can only be transferred out to this destination. Even a `ward` on the `UserEscrow` contract cannot transfer tokens to any other destination.\n\nThe full relationships of `wards` can be seen below.\n\n![Wards.](https://github.com/code-423n4/2023-09-centrifuge/blob/main/images/wards.png?raw=true)\n\n### User flows\n#### How pools and tranches are created and deployed\n![Pool creation flow.](https://github.com/code-423n4/2023-09-centrifuge/blob/main/images/pool_creation_flow.png?raw=true)\n\n#### How users can invest\n![Simple investment flow.](https://github.com/code-423n4/2023-09-centrifuge/blob/main/images/investment_flow.png?raw=true)\n\n#### How liquidity is managed\nWhen investors deposit in a currency that is not equivalent to the native pool currency, this needs to be swapped in order to execute the investment. And vice versa for redemptions. These swaps occur on Centrifuge Chain. These swaps also guarantee that sufficient liquidity is in the escrow contract to fulfill any orders. Note that locking, for example, USDC in Liquidity Pools on Ethereum, leads to Wrapped Ethereum LP on USDC, which will be non-fungible with USDC locked in Liquidity Pools on Arbitrum, which leads to Wrapped Arbitrum LP on USDC.\n\nAn example flow for how this works is visualized below:\n\n![Liquidity overview.](https://github.com/code-423n4/2023-09-centrifuge/blob/main/images/liquidity_flow1.png?raw=true)\n![Liquidity overview.](https://github.com/code-423n4/2023-09-centrifuge/blob/main/images/liquidity_flow2.png?raw=true)\n\n# Scope\n\n> [!WARNING]  \n> `src/gateway/Messages.sol` is a large file but contains only repetitive encoding/decoding functions.\n> All files excluding `Factory.sol` in the `src/util` directory are imported libraries.\n\n| Contract | SLOC | Purpose | Libraries used |  \n| ----------- | ----------- | ----------- | ----------- |\n| [src/LiquidityPool.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/LiquidityPool.sol) | 225 | A [ERC-4626](https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/) compatible contract that enables investors to deposit and withdraw stablecoins to invest in tranches of pools | SafeMath |\n| [src/InvestmentManager.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/InvestmentManager.sol) | 527 | Main contract LiquidityPools interact with for both incoming and outgoing investment transactions. | SafeMath, SafeTransfer |\n| [src/PoolManager.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/PoolManager.sol) | 261 | Manages which pools & tranches exist | SafeTransfer |\n| [src/Escrow.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/Escrow.sol) | 17 | Token holding contract | SafeTransfer |\n| [src/UserEscrow.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/UserEscrow.sol) | 30 | Token holding contract with locked destinations | SafeTransfer |\n| [src/Root.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/Root.sol) | 66 | Core contract that is a ward on all other deployed contracts |  |\n| [src/admins/PauseAdmin.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/admins/PauseAdmin.sol) | 30 | Simple pausing contract |  |\n| [src/admins/DelayedAdmin.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/admins/DelayedAdmin.sol) | 24 | Admin contract that can trigger the timelock on Root |  |\n| [src/token/Tranche.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/token/Tranche.sol) | 76 | Tranche token contract that inherits from ERC20 |  |\n| [src/token/ERC20.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/token/ERC20.sol) | 183 | ERC20 implementation with mint/burn & permit functionality |  |\n| [src/token/RestrictionManager.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/token/RestrictionManager.sol) | 49 | ERC1404 based contract that checks transfer restrictions |  |\n| [src/gateway/Gateway.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/gateway/Gateway.sol) | 328 | Incoming & outgoing message parsing |  |\n| [src/gateway/Messages.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/gateway/Messages.sol) | 619 | Message encoding & decoding |  |\n| [src/gateway/routers/axelar/Router.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/gateway/routers/axelar/Router.sol) | 88 | Routing contract that integrates with Axelar |  |\n| [src/util/Auth.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/util/Auth.sol) | 18 | Simple authentication contract |  |\n| [src/util/Context.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/util/Context.sol) | 6 | ERC2771 base contract | OZ Context |\n| [src/util/Factory.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/util/Factory.sol) | 93 | Factory contract for deploying LPs and tranche tokens |  |\n| [src/util/SafeTransferLib.sol](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/util/SafeTransferLib.sol) | 17 | Safe transfer lib | SafeTransfer |\n\n## Out of scope\n\n- `src/util/BytesLib.sol`\n- `src/util/MathLib.sol`\n- The [XCM router](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/gateway/routers/xcm/Router.sol) implementation.\n- While the [Axelar router](https://github.com/code-423n4/2023-09-centrifuge/blob/main/src/gateway/routers/axelar/Router.sol) implementation is in scope, any issues in the Axelar gateway or other external contracts from Axelar are out of scope.\n- Rebase and fee-on-transfer tokens are not supported.\n- A malicious router and any ward on the `DelayedAdmin` can trigger become ward on any contract and abuse the system, but should not be able to get additional wards before `root.delay` (the timelock should be enforced).\n- Removing an investor from the memberlist in the Restriction Manager locks their tokens. This is expected behaviour.\n- Since Centrifuge Chain uses `uint128` for calculations and all messages use `uint128` types for values, only `uint128` values are supported (anything larger should revert).\n- Deployments scripts (all files in `scripts`) are out of scope.\n- Some dust can be stuck in the escrow due to rounding. This is expected behaviour.\n\n# Additional Context\n\n## Scoping Details \n```\n- If you have a public code repo, please share it here: N/A\n- How many contracts are in scope?: 18\n- Total SLoC for these contracts?: 2657\n- How many external imports are there?:  0\n- How many separate interfaces and struct definitions are there for the contracts within scope?: 2 interfaces, 3 structs\n- Does most of your code generally use composition or inheritance?:  Composition\n- How many external calls?: Only ERC20 transfers\n- What is the overall line coverage percentage provided by your tests?: 80%\n- Is this an upgrade of an existing system?: No\n- Check all that apply (e.g. timelock, NFT, AMM, ERC20, rollups, etc.): Timelock, DeFi, Multi-chain\n- Is there a need to understand a separate part of the codebase / get context in order to audit this part of the protocol?: No\n- Please describe required context: Liquidity Pools interact with Centrifuge Chain over general message passing protocols, but auditors can assume Centrifuge Chain is a blackbox\n- Does it use an oracle?:  No\n- Describe any novel or unique curve logic or mathematical models your code uses: None\n- Is this either a fork of or an alternate implementation of another project?:   No\n- Does it use a side-chain?: No\n- Describe any specific areas you would like addressed: Loss of funds, stuck funds, bypass of timelock, price manipulation\n```\n\n# Tests\nMake sure Foundry is installed.\n\n```sh\ngit clone https://github.com/code-423n4/2023-09-centrifuge.git\ncd 2023-09-centrifuge\nforge test\n```"
    }
  ]
}