{
  "Title": "[M-13] Unused rewards(because of totalSupply()==0 for some period) will be locked forever in VE3DRewardPool and BaseRewardPool",
  "Content": "_Submitted by unforgiven, also found by csanuragjain_\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/BaseRewardPool.sol#L152-L162>\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L170-L183>\n\n### Impact\n\nThe `VE3DRewardPool` and `BaseRewardPool` contract is supposed to distribute rewards to stackers, but if in some period, `totalSupply()` was equal to `0`, then for that time period, rewards will not added to `rewardPerTokenStored` and those period rewards would not distribute to any address and those rewards will stuck in contract forever.\n\n### Proof of Concept\n\nThis is `notifyRewardAmount()` code in `BaseRewardPool` contract: (`VE3DRewardPool` code is similar)\n\n          function notifyRewardAmount(uint256 reward) internal updateReward(address(0)) {\n            historicalRewards = historicalRewards.add(reward);\n            if (block.timestamp >= periodFinish) {\n                rewardRate = reward.div(duration);\n            } else {\n                uint256 remaining = periodFinish.sub(block.timestamp);\n                uint256 leftover = remaining.mul(rewardRate);\n                reward = reward.add(leftover);\n                rewardRate = reward.div(duration);\n            }\n            currentRewards = reward;\n            lastUpdateTime = block.timestamp;\n            periodFinish = block.timestamp.add(duration);\n            emit RewardAdded(reward);\n        }\n\nAs you can see, in the line `rewardRate = reward.div(duration);` the value of `rewardRate` has been set to the division of available `reward` to `duration`. so if we distribute `rewardRate` amount in every second between stackers, then all rewards will be used by contract. contract uses ` updateReward()  ` modifier to update `rewardPerTokenStored` (this variable keeps track of distributed tokens) and this modifier uses  `rewardPerToken()` to update `BaseRewardPool`:\n\n          modifier updateReward(address account) {\n            rewardPerTokenStored = rewardPerToken();\n            lastUpdateTime = lastTimeRewardApplicable();\n            if (account != address(0)) {\n                rewards[account] = earned(account);\n                userRewardPerTokenPaid[account] = rewardPerTokenStored;\n            }\n            emit RewardUpdated(account, rewards[account], rewardPerTokenStored, lastUpdateTime);\n            _;\n        }\n\nThis is `rewardPerToken()` code in `BaseRewardPool`:\n\n        function rewardPerToken() public view returns (uint256) {\n            if (totalSupply() == 0) {\n                return rewardPerTokenStored;\n            }\n            return\n                rewardPerTokenStored.add(\n                    lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(\n                        totalSupply()\n                    )\n                );\n        }\n\nIf for some period `totalSupply()` was `0` then contract won't increase `rewardPerTokenStored` and those periods reward stuck in contract forever, because there is no mechanism to calculate them and withdraw them in contract.\nFor example if `operator` deploy and initialize the pool immediately before others having a chance of stacking their tokens, and use `queueNewRewards()` to queue the rewards then The rewards for early period of pool will be locked forever.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nAdd some mechanism to recalculate `rewardRate` or calculated undistributed rewards(calculated undistributed reward based on `rewardRate` and when `totalSupply()` is `0`).\n\n**[solvetony (veToken Finance) disagreed with severity and commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/168#issuecomment-1156648983):**\n > Recover function would solve this issue. Middle risk.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/168#issuecomment-1193413011):**\n > The warden has found a valid problem, however a coded POC would have gone a long way.\n> \n> In order to judge the issue I had to code it for myself to be able to demonstrate the problem.\n> \n> Anyhow this is a Brownie dump of me setting up the contract (removing transferFrom to get it done rapidly)\n> Showing how skipping 1/3 of reward duration will cause a loss of 1/3 of the yield.\n> \n> Meaning that the accumulator used for rewards is not redistributing the old rewards\n> \n> ```\n> >>> x.lastTimeRewardApplicable()\n> 0\n> >>> x.queueNewRewards(1e18, {\"from\": a[0]})\n> Transaction sent: 0x0b959c886d959038396aa0a9a82cef39c6bc817e4e48026068b242b0a46df81f\n>   Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 5\n>   BaseRewardPool.queueNewRewards confirmed   Block: 15208165   Gas used: 46822 (0.39%)\n> \n> <Transaction '0x0b959c886d959038396aa0a9a82cef39c6bc817e4e48026068b242b0a46df81f'>\n> >>> x.lastTimeRewardApplicable()\n> 1658703966\n> >>> chain.time()\n> 1658703975\n> >>> 1658703966 - 1658703975\n> -9\n> >>> x.lastTimeRewardApplicable()\n> 1658703966\n> >>> x.lastUpdateTime()\n> 1658703966\n> >>> x.periodFinish()\n> 1659308766\n> >>> 1658703966 - 1659308766\n> -604800\n> >>> chain.sleep(604800 // 3) \\#\\# Sleep for third of time\n> >>> chain.time()\n> 1658905644\n> >>> 1658905644- 1659308766\n> -403122\n> >>> x.stake(1e18, {\"from\": a[0]})\n> Transaction sent: 0x4899faa962b45d2f746db4f045b9858fdd506185cecab019516f4b9cae4bfd37\n>   Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 6\n>   BaseRewardPool.stake confirmed   Block: 15208166   Gas used: 73201 (0.61%)\n> \n> <Transaction '0x4899faa962b45d2f746db4f045b9858fdd506185cecab019516f4b9cae4bfd37'>\n> >>> x.balanceOf(a[0])\n> 1000000000000000000\n> >>> x.earned(a[0])\n> 0\n> >>> chain.sleep(x.duration())\n> >>> x.earned(a[0])\n> 0\n> >>> x.getReward(a[0], False)\n> Transaction sent: 0xba12fac5aa76e59d51fa277245cd96db53d7ca2685bdf97abdee734550f102e8\n>   Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 7\n>   BaseRewardPool.getReward confirmed   Block: 15208167   Gas used: 57623 (0.48%)\n> \n> <Transaction '0xba12fac5aa76e59d51fa277245cd96db53d7ca2685bdf97abdee734550f102e8'>\n> >>> history[-1].return_value\n> 666502976190414339\n> >>>\n> ``` \n> \n> Which means, that the warden has found a valid vulnerability and any time spent with a totalSupply of 0 will cause those rewards to be lost.\n> \n> Because this is contingent on:\n> - No deposits before adding rewards\n> - Lasts only until a deposit has happened\n> - Is related to loss of yield\n> \n> I believe Medium Severity to be more appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-vetoken-finance-contest",
  "Code": [
    {
      "filename": "contracts/BaseRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/IDeposit.sol\";\n\ncontract BaseRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 constant BLOCKS_PER_DAY = 6450;\n    uint256 constant BLOCKS_PER_YEAR = BLOCKS_PER_DAY * 365;\n    uint256 constant EXTRA_REWARD_POOLS = 3;\n\n    address public operator;\n    address public rewardManager;\n\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event ExtraRewardAdded(address indexed reward);\n    event ExtraRewardCleared();\n    event RewardUpdated(\n        address indexed user,\n        uint256 reward,\n        uint256 rewardPerTokenStored,\n        uint256 lastUpdateTime\n    );\n    event Donated(uint256 queuedRewards);\n\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns (bool) {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n        require(extraRewards.length < EXTRA_REWARD_POOLS, \"!extra reward pools exceed\");\n\n        extraRewards.push(_reward);\n        emit ExtraRewardAdded(_reward);\n        return true;\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n        emit ExtraRewardCleared();\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        emit RewardUpdated(account, rewards[account], rewardPerTokenStored, lastUpdateTime);\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(\n                    totalSupply()\n                )\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function withdraw(uint256 amount, bool claim) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns (bool)\n    {\n        //also withdraw from linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid, amount, msg.sender);\n        emit Withdrawn(msg.sender, amount);\n\n        //get rewards too\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external {\n        withdrawAndUnwrap(_balances[msg.sender], claim);\n    }\n\n    function getReward(address _account, bool _claimExtras)\n        public\n        updateReward(_account)\n        returns (bool)\n    {\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            for (uint256 i = 0; i < extraRewards.length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\n    function getReward() external returns (bool) {\n        getReward(msg.sender, true);\n        return true;\n    }\n\n    function donate(uint256 _amount) external {\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        queuedRewards = queuedRewards.add(_amount);\n        emit Donated(queuedRewards);\n    }\n\n    function queueNewRewards(uint256 _rewards) external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        } else {\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(uint256 reward) internal updateReward(address(0)) {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n\n    function getAPY() external view returns (uint256) {\n        return rewardRate.mul(BLOCKS_PER_YEAR).mul(1e18).div(totalSupply());\n    }\n}"
    },
    {
      "filename": "contracts/VE3DRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: vetokenRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract VE3DRewardPool is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public immutable rewardManager;\n\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    // reward token => reward token info\n    mapping(address => RewardTokenInfo) public rewardTokenInfo;\n    // list of reward tokens\n    EnumerableSet.AddressSet internal rewardTokens;\n    EnumerableSet.AddressSet internal operators;\n\n    address[] public extraRewards;\n\n    struct RewardTokenInfo {\n        address veAssetDeposits;\n        address ve3TokenRewards;\n        address ve3Token;\n        uint256 queuedRewards;\n        uint256 rewardRate;\n        uint256 historicalRewards;\n        uint256 rewardPerTokenStored;\n        uint256 currentRewards;\n        uint256 periodFinish;\n        uint256 lastUpdateTime;\n        mapping(address => uint256) userRewardPerTokenPaid;\n        mapping(address => uint256) rewards;\n    }\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(address stakingToken_, address rewardManager_) {\n        stakingToken = IERC20(stakingToken_);\n\n        rewardManager = rewardManager_;\n    }\n\n    function addReward(\n        address _rewardToken,\n        address _veAssetDeposits,\n        address _ve3TokenRewards,\n        address _ve3Token\n    ) external onlyOwner {\n        rewardTokenInfo[_rewardToken].veAssetDeposits = _veAssetDeposits;\n        rewardTokenInfo[_rewardToken].ve3TokenRewards = _ve3TokenRewards;\n        rewardTokenInfo[_rewardToken].ve3Token = _ve3Token;\n        rewardTokens.add(_rewardToken);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n\n        extraRewards.push(_reward);\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored = rewardPerToken(_rewardToken);\n            rewardTokenInfo[_rewardToken].lastUpdateTime = lastTimeRewardApplicable(_rewardToken);\n            if (account != address(0)) {\n                rewardTokenInfo[_rewardToken].rewards[account] = earnedReward(\n                    _rewardToken,\n                    account\n                );\n                rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account] = rewardTokenInfo[\n                    _rewardToken\n                ].rewardPerTokenStored;\n            }\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable(address _rewardToken) public view returns (uint256) {\n        return Math.min(block.timestamp, rewardTokenInfo[_rewardToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardToken) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return rewardTokenInfo[_rewardToken].rewardPerTokenStored;\n        }\n        return\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored.add(\n                lastTimeRewardApplicable(_rewardToken)\n                    .sub(rewardTokenInfo[_rewardToken].lastUpdateTime)\n                    .mul(rewardTokenInfo[_rewardToken].rewardRate)\n                    .mul(1e18)\n                    .div(supply)\n            );\n    }\n\n    function earnedReward(address _rewardToken, address account) internal view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(\n                    rewardPerToken(_rewardToken).sub(\n                        rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account]\n                    )\n                )\n                .div(1e18)\n                .add(rewardTokenInfo[_rewardToken].rewards[account]);\n    }\n\n    function earned(address _rewardToken, address account) external view returns (uint256) {\n        uint256 depositFeeRate = IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits)\n            .lockIncentive();\n\n        uint256 r = earnedReward(_rewardToken, account);\n        uint256 fees = r.mul(depositFeeRate).div(FEE_DENOMINATOR);\n\n        //fees dont apply until whitelist+veVeAsset lock begins so will report\n        //slightly less value than what is actually received.\n        return r.sub(fees);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to sender balance sheet\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function stakeAll() external {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to _for's balance sheet\n        _balances[_for] = _balances[_for].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _amount, bool claim) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(_amount);\n        stakingToken.safeTransfer(msg.sender, _amount);\n        emit Withdrawn(msg.sender, _amount);\n\n        if (claim) {\n            getReward(msg.sender, true, false);\n        }\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function getReward(\n        address _account,\n        bool _claimExtras,\n        bool _stake\n    ) public updateReward(_account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n\n            uint256 reward = earnedReward(_rewardToken, _account);\n            if (reward > 0) {\n                rewardTokenInfo[_rewardToken].rewards[_account] = 0;\n                IERC20(_rewardToken).safeApprove(rewardTokenInfo[_rewardToken].veAssetDeposits, 0);\n                IERC20(_rewardToken).safeApprove(\n                    rewardTokenInfo[_rewardToken].veAssetDeposits,\n                    reward\n                );\n                IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits).deposit(\n                    reward,\n                    false\n                );\n\n                uint256 ve3TokenBalance = IERC20(rewardTokenInfo[_rewardToken].ve3Token).balanceOf(\n                    address(this)\n                );\n                if (_stake) {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        0\n                    );\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        ve3TokenBalance\n                    );\n                    IRewards(rewardTokenInfo[_rewardToken].ve3TokenRewards).stakeFor(\n                        _account,\n                        ve3TokenBalance\n                    );\n                } else {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeTransfer(\n                        _account,\n                        ve3TokenBalance\n                    );\n                }\n                emit RewardPaid(_account, ve3TokenBalance);\n            }\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            uint256 length = extraRewards.length;\n            for (uint256 i = 0; i < length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n    }\n\n    function getReward(bool _stake) external {\n        getReward(msg.sender, true, _stake);\n    }\n\n    function donate(address _rewardToken, uint256 _amount) external {\n        IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        rewardTokenInfo[_rewardToken].queuedRewards += _amount;\n    }\n\n    function queueNewRewards(address _rewardToken, uint256 _rewards) external {\n        require(operators.contains(_msgSender()), \"!authorized\");\n\n        _rewards = _rewards.add(rewardTokenInfo[_rewardToken].queuedRewards);\n\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(\n            rewardTokenInfo[_rewardToken].periodFinish.sub(duration)\n        );\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardTokenInfo[_rewardToken].rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n        } else {\n            rewardTokenInfo[_rewardToken].queuedRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardToken, uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        rewardTokenInfo[_rewardToken].historicalRewards += reward;\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = rewardTokenInfo[_rewardToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardTokenInfo[_rewardToken].rewardRate);\n            reward = reward.add(leftover);\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        }\n        rewardTokenInfo[_rewardToken].currentRewards = reward;\n        rewardTokenInfo[_rewardToken].lastUpdateTime = block.timestamp;\n        rewardTokenInfo[_rewardToken].periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    }
  ]
}