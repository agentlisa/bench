{
  "Title": "[G-01] State variables can be cached instead of re-reading them from storage",
  "Content": "Caching of a state variable replaces each `Gwarmaccess (100 gas)` with a much cheaper stack read.\n\n*Note: These are instances missed by the Bot Race.*\n\nTotal Instances: `22`\n\nEstimated Gas Saved: `22 * 100 = 2200`\n\n<details>\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L212-L214\n\n### Cache `depositedAsset[_provider]` to save 1 SLOAD\n```solidity\nFile: contracts/lybra/pools/base/LybraPeUSDVaultBase.sol\n212:    function _withdraw(address _provider, address _onBehalfOf, uint256 _amount) internal {\n213:        require(depositedAsset[_provider] >= _amount, \"Withdraw amount exceeds deposited amount.\"); // @audit: 1st sload\n214:        depositedAsset[_provider] -= _amount; // @audit: 2nd sload\n```\n```diff\ndiff --git a/lybra/pools/base/LybraPeUSDVaultBase.sol b/lybra/pools/base/LybraPeUSDVaultBase.sol\nindex 40c0421..b00a331 100644\n--- a/lybra/pools/base/LybraPeUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraPeUSDVaultBase.sol\n@@ -210,8 +210,9 @@ abstract contract LybraPeUSDVaultBase {\n     }\n\n     function _withdraw(address _provider, address _onBehalfOf, uint256 _amount) internal {\n-        require(depositedAsset[_provider] >= _amount, \"Withdraw amount exceeds deposited amount.\");\n-        depositedAsset[_provider] -= _amount;\n+        uint256 _depositedAsset = depositedAsset[_provider];\n+        require(_depositedAsset >= _amount, \"Withdraw amount exceeds deposited amount.\");\n+        depositedAsset[_provider] = _depositedAsset -  _amount;\n         collateralAsset.transfer(_onBehalfOf, _amount);\n         if (getBorrowedOf(_provider) > 0) {\n             _checkHealth(_provider, getAssetPrice());\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L161-L165\n\n### Cache `depositedAsset[provider]` to save 1 SLOAD\n```solidity\nFile: contracts/lybra/pools/base/LybraPeUSDVaultBase.sol\n161:        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider]; // @audit: 1st sload\n162:        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n163:        _repay(msg.sender, provider, peusdAmount);\n164:        uint256 collateralAmount = (((peusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n165:        depositedAsset[provider] -= collateralAmount; // @audit: 2nd sload\n```\n```diff\ndiff --git a/lybra/pools/base/LybraPeUSDVaultBase.sol b/lybra/pools/base/LybraPeUSDVaultBase.sol\nindex 40c0421..d06e459 100644\n--- a/lybra/pools/base/LybraPeUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraPeUSDVaultBase.sol\n@@ -158,11 +158,12 @@ abstract contract LybraPeUSDVaultBase {\n         require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n         require(borrowed[provider] >= peusdAmount, \"peusdAmount cannot surpass providers debt\");\n         uint256 assetPrice = getAssetPrice();\n-        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n+        uint256 _depositedAsset = depositedAsset[provider];\n+        uint256 providerCollateralRatio = (_depositedAsset * assetPrice * 100) / borrowed[provider];\n         require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n         _repay(msg.sender, provider, peusdAmount);\n         uint256 collateralAmount = (((peusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n-        depositedAsset[provider] -= collateralAmount;\n+        depositedAsset[provider] = _depositedAsset - collateralAmount;\n         collateralAsset.transfer(msg.sender, collateralAmount);\n         emit RigidRedemption(msg.sender, provider, peusdAmount, collateralAmount, block.timestamp);\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L127-L136\n\n### Cache `depositedAsset[onBehalfOf]` to save 2 SLOADs\n```solidity\nFile: contracts/lybra/pools/base/LybraPeUSDVaultBase.sol\n127:        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf); // @audit: 1st sload\n128:        require(onBehalfOfCollateralRatio < configurator.getBadCollateralRatio(address(this)), \"Borrowers collateral ratio should below badCollateralRatio\");\n129:\n130:        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\"); // @audit: 2nd sload\n131:        require(PeUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n132:        uint256 peusdAmount = (assetAmount * assetPrice) / 1e18;\n133:\n134:        _repay(provider, onBehalfOf, peusdAmount);\n135:        uint256 reducedAsset = (assetAmount * 11) / 10;\n136:        depositedAsset[onBehalfOf] -= reducedAsset; // @audit: 3rd sload\n```\n```diff\ndiff --git a/lybra/pools/base/LybraPeUSDVaultBase.sol b/lybra/pools/base/LybraPeUSDVaultBase.sol\nindex 40c0421..5b132fd 100644\n--- a/lybra/pools/base/LybraPeUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraPeUSDVaultBase.sol\n@@ -124,16 +124,17 @@ abstract contract LybraPeUSDVaultBase {\n      */\n     function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n         uint256 assetPrice = getAssetPrice();\n-        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf);\n+        uint256 _depositedAsset = depositedAsset[onBehalfOf];\n+        uint256 onBehalfOfCollateralRatio = (_depositedAsset * assetPrice * 100) / getBorrowedOf(onBehalfOf);\n         require(onBehalfOfCollateralRatio < configurator.getBadCollateralRatio(address(this)), \"Borrowers collateral ratio should below badCollateralRatio\");\n\n-        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n+        require(assetAmount * 2 <= _depositedAsset, \"a max of 50% collateral can be liquidated\");\n         require(PeUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n         uint256 peusdAmount = (assetAmount * assetPrice) / 1e18;\n\n         _repay(provider, onBehalfOf, peusdAmount);\n         uint256 reducedAsset = (assetAmount * 11) / 10;\n-        depositedAsset[onBehalfOf] -= reducedAsset;\n+        depositedAsset[onBehalfOf] = _depositedAsset - reducedAsset;\n         uint256 reward2keeper;\n         if (provider == msg.sender) {\n             collateralAsset.transfer(msg.sender, reducedAsset);\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L174-L182\n\n### Cache `poolTotalPeUSDCirculation` to save 1 SLOAD\n```solidity\nFile: contracts/lybra/pools/base/LybraPeUSDVaultBase.sol\n174:        require(poolTotalPeUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\"); // @audit: 1st sload\n175:        _updateFee(_provider);\n176:\n177:        try configurator.refreshMintReward(_provider) {} catch {}\n178:\n179:        borrowed[_provider] += _mintAmount;\n180:\n181:        PeUSD.mint(_onBehalfOf, _mintAmount);\n182:        poolTotalPeUSDCirculation += _mintAmount; // @audit: 2nd sload\n```\n```diff\ndiff --git a/lybra/pools/base/LybraPeUSDVaultBase.sol b/lybra/pools/base/LybraPeUSDVaultBase.sol\nindex 40c0421..91953be 100644\n--- a/lybra/pools/base/LybraPeUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraPeUSDVaultBase.sol\n@@ -171,7 +171,8 @@ abstract contract LybraPeUSDVaultBase {\n      * @dev Refresh LBR reward before adding providers debt. Refresh Lybra generated service fee before adding totalSupply. Check providers collateralRatio cannot below `safeCollateralRatio`after minting.\n      */\n     function _mintPeUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n-        require(poolTotalPeUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n+        uint256 _poolTotalPeUSDCirculation = poolTotalPeUSDCirculation;\n+        require(_poolTotalPeUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n         _updateFee(_provider);\n\n         try configurator.refreshMintReward(_provider) {} catch {}\n@@ -179,7 +180,7 @@ abstract contract LybraPeUSDVaultBase {\n         borrowed[_provider] += _mintAmount;\n\n         PeUSD.mint(_onBehalfOf, _mintAmount);\n-        poolTotalPeUSDCirculation += _mintAmount;\n+        poolTotalPeUSDCirculation = _poolTotalPeUSDCirculation + _mintAmount;\n         _checkHealth(_provider, _assetPrice);\n         emit Mint(_provider, _onBehalfOf, _mintAmount, block.timestamp);\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L260-L266\n\n### Cache `poolTotalEUSDCirculation` to save 1 SLOAD\n```solidity\nFile: contracts/lybra/pools/base/LybraEUSDVaultBase.sol\n260:        require(poolTotalEUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\"); // @audit: 1st sload\n261:        try configurator.refreshMintReward(_provider) {} catch {}\n262:        borrowed[_provider] += _mintAmount;\n263:\n264:        EUSD.mint(_onBehalfOf, _mintAmount);\n265:        _saveReport();\n266:        poolTotalEUSDCirculation += _mintAmount; // @audit: 2nd sload\n```\n```diff\ndiff --git a/lybra/pools/base/LybraEUSDVaultBase.sol b/lybra/pools/base/LybraEUSDVaultBase.sol\nindex 7a8c439..233857c 100644\n--- a/lybra/pools/base/LybraEUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraEUSDVaultBase.sol\n@@ -257,13 +257,14 @@ abstract contract LybraEUSDVaultBase {\n      * The provider must have sufficient borrowing capacity to mint the specified amount.\n      */\n     function _mintEUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n-        require(poolTotalEUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n+        uint256 _poolTotalEUSDCirculation = poolTotalEUSDCirculation;\n+        require(_poolTotalEUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n         try configurator.refreshMintReward(_provider) {} catch {}\n         borrowed[_provider] += _mintAmount;\n\n         EUSD.mint(_onBehalfOf, _mintAmount);\n         _saveReport();\n-        poolTotalEUSDCirculation += _mintAmount;\n+        poolTotalEUSDCirculation = _poolTotalEUSDCirculation + _mintAmount;\n         _checkHealth(_provider, _assetPrice);\n         emit Mint(msg.sender, _onBehalfOf, _mintAmount, block.timestamp);\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L277-L282\n\n### Cache `borrowed[_onBehalfOf]` to save 1 SLOAD\n```solidity\nFile: contracts/lybra/pools/base/LybraEUSDVaultBase.sol\n277:        uint256 amount = borrowed[_onBehalfOf] >= _amount ? _amount : borrowed[_onBehalfOf]; // @audit: 1st sload\n278:\n279:        EUSD.burn(_provider, amount);\n280:        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n281:\n282:        borrowed[_onBehalfOf] -= amount; // @audit: 2nd sload\n```\n```diff\ndiff --git a/lybra/pools/base/LybraEUSDVaultBase.sol b/lybra/pools/base/LybraEUSDVaultBase.sol\nindex 7a8c439..d0daf55 100644\n--- a/lybra/pools/base/LybraEUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraEUSDVaultBase.sol\n@@ -274,12 +274,13 @@ abstract contract LybraEUSDVaultBase {\n      * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalEUSDCirculation.\n      */\n     function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n-        uint256 amount = borrowed[_onBehalfOf] >= _amount ? _amount : borrowed[_onBehalfOf];\n+        uint256 _borrowed = borrowed[_onBehalfOf];\n+        uint256 amount = _borrowed >= _amount ? _amount : _borrowed;\n\n         EUSD.burn(_provider, amount);\n         try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n\n-        borrowed[_onBehalfOf] -= amount;\n+        borrowed[_onBehalfOf] = _borrowed - amount;\n         _saveReport();\n         poolTotalEUSDCirculation -= amount;\n         emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L234-L240\n\n### Cache `borrowed[provider]` and `depositedAsset[provider]` to save 2 SLOADs\n```solidity\nFile: contracts/lybra/pools/base/LybraEUSDVaultBase.sol\n234:        require(borrowed[provider] >= eusdAmount, \"eusdAmount cannot surpass providers debt\"); // @audit: 1st sload\n235:        uint256 assetPrice = getAssetPrice();\n236:        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider]; // @audit: 1st sload & 2nd sload\n237:        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n238:        _repay(msg.sender, provider, eusdAmount);\n239:        uint256 collateralAmount = (((eusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n240:        depositedAsset[provider] -= collateralAmount; // @audit: 2nd sload\n```\n```diff\ndiff --git a/lybra/pools/base/LybraEUSDVaultBase.sol b/lybra/pools/base/LybraEUSDVaultBase.sol\nindex 7a8c439..c5ff16e 100644\n--- a/lybra/pools/base/LybraEUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraEUSDVaultBase.sol\n@@ -231,13 +231,15 @@ abstract contract LybraEUSDVaultBase {\n      */\n     function rigidRedemption(address provider, uint256 eusdAmount) external virtual {\n         require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n-        require(borrowed[provider] >= eusdAmount, \"eusdAmount cannot surpass providers debt\");\n+        uint256 _borrowed = borrowed[provider];\n+        require(_borrowed >= eusdAmount, \"eusdAmount cannot surpass providers debt\");\n         uint256 assetPrice = getAssetPrice();\n-        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n+        uint256 _depositedAsset = depositedAsset[provider];\n+        uint256 providerCollateralRatio = (_depositedAsset * assetPrice * 100) / _borrowed;\n         require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n         _repay(msg.sender, provider, eusdAmount);\n         uint256 collateralAmount = (((eusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n-        depositedAsset[provider] -= collateralAmount;\n+        depositedAsset[provider] = _depositedAsset - collateralAmount;\n         totalDepositedAsset -= collateralAmount;\n         collateralAsset.transfer(msg.sender, collateralAmount);\n         emit RigidRedemption(msg.sender, provider, eusdAmount, collateralAmount, block.timestamp);\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L189-L202\n\n### Cache `totalDepositedAsset` and `depositedAsset[onBehalfOf]` to save 3 SLOADs\n```solidity\nFile: contracts/lybra/pools/base/LybraEUSDVaultBase.sol\n189:        require((totalDepositedAsset * assetPrice * 100) / poolTotalEUSDCirculation < badCollateralRatio, \"overallCollateralRatio should below 150%\"); // @audit: 1st sload\n190:        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf]; // @audit: 1st sload\n191:        require(onBehalfOfCollateralRatio < 125 * 1e18, \"borrowers collateralRatio should below 125%\");\n192:        require(assetAmount <= depositedAsset[onBehalfOf], \"total of collateral can be liquidated at most\"); // @audit: 2nd sload\n193:        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n194:        if (onBehalfOfCollateralRatio >= 1e20) {\n195:            eusdAmount = (eusdAmount * 1e20) / onBehalfOfCollateralRatio;\n196:        }\n197:        require(EUSD.allowance(provider, address(this)) >= eusdAmount, \"provider should authorize to provide liquidation EUSD\");\n198:\n199:        _repay(provider, onBehalfOf, eusdAmount);\n200:\n201:        totalDepositedAsset -= assetAmount; // @audit: 2nd sload\n202:        depositedAsset[onBehalfOf] -= assetAmount; // @audit: 3rd sload\n```\n```diff\ndiff --git a/lybra/pools/base/LybraEUSDVaultBase.sol b/lybra/pools/base/LybraEUSDVaultBase.sol\nindex 7a8c439..36ffa6a 100644\n--- a/lybra/pools/base/LybraEUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraEUSDVaultBase.sol\n@@ -186,10 +186,12 @@ abstract contract LybraEUSDVaultBase {\n      */\n     function superLiquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n         uint256 assetPrice = getAssetPrice();\n-        require((totalDepositedAsset * assetPrice * 100) / poolTotalEUSDCirculation < badCollateralRatio, \"overallCollateralRatio should below 150%\");\n-        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n+        uint256 _totalDepositedAsset = totalDepositedAsset;\n+        require((_totalDepositedAsset * assetPrice * 100) / poolTotalEUSDCirculation < badCollateralRatio, \"overallCollateralRatio should below 150%\");\n+        uint256 _depositedAsset = depositedAsset[onBehalfOf];\n+        uint256 onBehalfOfCollateralRatio = (_depositedAsset * assetPrice * 100) / borrowed[onBehalfOf];\n         require(onBehalfOfCollateralRatio < 125 * 1e18, \"borrowers collateralRatio should below 125%\");\n-        require(assetAmount <= depositedAsset[onBehalfOf], \"total of collateral can be liquidated at most\");\n+        require(assetAmount <= _depositedAsset, \"total of collateral can be liquidated at most\");\n         uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n         if (onBehalfOfCollateralRatio >= 1e20) {\n             eusdAmount = (eusdAmount * 1e20) / onBehalfOfCollateralRatio;\n@@ -198,8 +200,8 @@ abstract contract LybraEUSDVaultBase {\n\n         _repay(provider, onBehalfOf, eusdAmount);\n\n-        totalDepositedAsset -= assetAmount;\n-        depositedAsset[onBehalfOf] -= assetAmount;\n+        totalDepositedAsset = _totalDepositedAsset - assetAmount;\n+        depositedAsset[onBehalfOf] = _depositedAsset -  assetAmount;\n         uint256 reward2keeper;\n         if (msg.sender != provider && onBehalfOfCollateralRatio >= 1e20 + configurator.vaultKeeperRatio(address(this)) * 1e18) {\n             reward2keeper = ((assetAmount * configurator.vaultKeeperRatio(address(this))) * 1e18) / onBehalfOfCollateralRatio;\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L156-L166\n\n### Cache `depositedAsset[onBehalfOf]` to save 2 SLOADs\n```solidity\nFile: contracts/lybra/pools/base/LybraEUSDVaultBase.sol\n156:        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf]; // @audit: 1st sload\n157:        require(onBehalfOfCollateralRatio < badCollateralRatio, \"Borrowers collateral ratio should below badCollateralRatio\");\n158:\n159:        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\"); // @audit: 2nd sload\n160:        require(EUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n161:        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n162:\n163:        _repay(provider, onBehalfOf, eusdAmount);\n164:        uint256 reducedAsset = (assetAmount * 11) / 10;\n165:        totalDepositedAsset -= reducedAsset;\n166:        depositedAsset[onBehalfOf] -= reducedAsset; // @audit: 3rd sload\n```\n```diff\ndiff --git a/lybra/pools/base/LybraEUSDVaultBase.sol b/lybra/pools/base/LybraEUSDVaultBase.sol\nindex 7a8c439..f3fd55b 100644\n--- a/lybra/pools/base/LybraEUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraEUSDVaultBase.sol\n@@ -153,17 +153,18 @@ abstract contract LybraEUSDVaultBase {\n      */\n     function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n         uint256 assetPrice = getAssetPrice();\n-        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n+        uint256 _depositedAsset = depositedAsset[onBehalfOf];\n+        uint256 onBehalfOfCollateralRatio = (_depositedAsset * assetPrice * 100) / borrowed[onBehalfOf];\n         require(onBehalfOfCollateralRatio < badCollateralRatio, \"Borrowers collateral ratio should below badCollateralRatio\");\n\n-        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n+        require(assetAmount * 2 <= _depositedAsset, \"a max of 50% collateral can be liquidated\");\n         require(EUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n         uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n\n         _repay(provider, onBehalfOf, eusdAmount);\n         uint256 reducedAsset = (assetAmount * 11) / 10;\n         totalDepositedAsset -= reducedAsset;\n-        depositedAsset[onBehalfOf] -= reducedAsset;\n+        depositedAsset[onBehalfOf] = _depositedAsset - reducedAsset;\n         uint256 reward2keeper;\n         if (provider == msg.sender) {\n             collateralAsset.transfer(msg.sender, reducedAsset);\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L101-L103\n\n### Cache `depositedAsset[msg.sender]` to save 1 SLOAD\n```solidity\nFile: contracts/lybra/pools/base/LybraEUSDVaultBase.sol\n101:        require(depositedAsset[msg.sender] >= amount, \"Withdraw amount exceeds deposited amount.\"); // @audit: 1st sload\n102:        totalDepositedAsset -= amount;\n103:        depositedAsset[msg.sender] -= amount; // @audit: 2nd sload\n```\n```diff\ndiff --git a/lybra/pools/base/LybraEUSDVaultBase.sol b/lybra/pools/base/LybraEUSDVaultBase.sol\nindex 7a8c439..6a84bd2 100644\n--- a/lybra/pools/base/LybraEUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraEUSDVaultBase.sol\n@@ -98,9 +98,10 @@ abstract contract LybraEUSDVaultBase {\n     function withdraw(address onBehalfOf, uint256 amount) external virtual {\n         require(onBehalfOf != address(0), \"TZA\");\n         require(amount > 0, \"ZERO_WITHDRAW\");\n-        require(depositedAsset[msg.sender] >= amount, \"Withdraw amount exceeds deposited amount.\");\n+        uint256 _depositedAsset = depositedAsset[msg.sender];\n+        require(_depositedAsset >= amount, \"Withdraw amount exceeds deposited amount.\");\n         totalDepositedAsset -= amount;\n-        depositedAsset[msg.sender] -= amount;\n+        depositedAsset[msg.sender] = _depositedAsset - amount;\n\n         uint256 withdrawal = checkWithdrawal(msg.sender, amount);\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L72-L78\n\n### Cache return value from `rewardPerToken()` to save 1 SLOAD\n```solidity\nFile: contracts/lybra/miner/EUSDMiningIncentives.sol\n72:    modifier updateReward(address _account) {\n73:        rewardPerTokenStored = rewardPerToken();\n74:        updatedAt = lastTimeRewardApplicable();\n75:\n76:        if (_account != address(0)) {\n77:            rewards[_account] = earned(_account);\n78:            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n```\n```diff\ndiff --git a/lybra/miner/EUSDMiningIncentives.sol b/lybra/miner/EUSDMiningIncentives.sol\nindex e6c57c8..e58dc2d 100644\n--- a/lybra/miner/EUSDMiningIncentives.sol\n+++ b/lybra/miner/EUSDMiningIncentives.sol\n@@ -70,12 +70,13 @@ contract EUSDMiningIncentives is Ownable {\n     }\n\n     modifier updateReward(address _account) {\n-        rewardPerTokenStored = rewardPerToken();\n+        uint256 _rewardPerTokenStored = rewardPerToken();\n+        rewardPerTokenStored = _rewardPerTokenStored;\n         updatedAt = lastTimeRewardApplicable();\n\n         if (_account != address(0)) {\n             rewards[_account] = earned(_account);\n-            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n+            userRewardPerTokenPaid[_account] = _rewardPerTokenStored;\n             userUpdatedAt[_account] = block.timestamp;\n         }\n         _;\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L311-L317\n\n### Cache `_totalShares` to save 1 SLOAD\n\n*Note: This `view` function is invoked within state-mutating functions*\n```solidity\nFile: contracts/lybra/token/EUSD.sol\n311:    function getMintedEUSDByShares(uint256 _sharesAmount) public view returns (uint256) {\n312:        if (_totalShares == 0) { // @audit: 1st sload\n313:            return 0;\n314:        } else {\n315:            return _sharesAmount.mul(_totalSupply).div(_totalShares); // @audit: 2nd sload\n316:        }\n317:    }\n```\n```diff\ndiff --git a/lybra/token/EUSD.sol b/lybra/token/EUSD.sol\nindex cca5cee..2b5a822 100644\n--- a/lybra/token/EUSD.sol\n+++ b/lybra/token/EUSD.sol\n@@ -309,10 +309,11 @@ contract EUSD is IERC20, Context {\n      * @return the amount of EUSD that corresponds to `_sharesAmount` token shares.\n      */\n     function getMintedEUSDByShares(uint256 _sharesAmount) public view returns (uint256) {\n-        if (_totalShares == 0) {\n+        uint256 _cachedTotalShares = _totalShares;\n+        if (_cachedTotalShares == 0) {\n             return 0;\n         } else {\n-            return _sharesAmount.mul(_totalSupply).div(_totalShares);\n+            return _sharesAmount.mul(_totalSupply).div(_cachedTotalShares);\n         }\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L155-L159\n\n### Cache `time2fullRedemption[user]` and `lastWithdrawTime[user]` to save 2 SLOADs\n\n*Note: This `view` function is invoked within state-mutating functions:*\n```solidity\nFile: contracts/lybra/miner/ProtocolRewardsPool.sol\n155:    function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n156:        if (time2fullRedemption[user] > lastWithdrawTime[user]) { // @audit: 1st sloads\n157:            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]); // @audit: 2nd sloads\n158:        }\n159:    }\n```\n```diff\ndiff --git a/lybra/miner/ProtocolRewardsPool.sol b/lybra/miner/ProtocolRewardsPool.sol\nindex 8fc83d6..363c9e2 100644\n--- a/lybra/miner/ProtocolRewardsPool.sol\n+++ b/lybra/miner/ProtocolRewardsPool.sol\n@@ -153,8 +153,10 @@ contract ProtocolRewardsPool is Ownable {\n     }\n\n     function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n-        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n-            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n+        uint256 _time2fullRedemption = time2fullRedemption[user];\n+        uint256 _lastWithdrawTime = lastWithdrawTime[user];\n+        if (_time2fullRedemption > _lastWithdrawTime) {\n+            amount = block.timestamp > _time2fullRedemption ? unstakeRatio[user] * (_time2fullRedemption - _lastWithdrawTime) : unstakeRatio[user] * (block.timestamp - _lastWithdrawTime);\n         }\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L92-L94\n\n### Cache `time2fullRedemption[msg.sender]` to save 1 SLOAD\n```solidity\nFile: contracts/lybra/miner/ProtocolRewardsPool.sol\n92:        if (time2fullRedemption[msg.sender] > block.timestamp) { // @audit: 1st sload\n93:            total += unstakeRatio[msg.sender] * (time2fullRedemption[msg.sender] - block.timestamp); // @audit: 2nd sload\n94:        }\n```\n```diff\ndiff --git a/lybra/miner/ProtocolRewardsPool.sol b/lybra/miner/ProtocolRewardsPool.sol\nindex 8fc83d6..de2ecf4 100644\n--- a/lybra/miner/ProtocolRewardsPool.sol\n+++ b/lybra/miner/ProtocolRewardsPool.sol\n@@ -89,8 +89,9 @@ contract ProtocolRewardsPool is Ownable {\n         esLBR.burn(msg.sender, amount);\n         withdraw(msg.sender);\n         uint256 total = amount;\n-        if (time2fullRedemption[msg.sender] > block.timestamp) {\n-            total += unstakeRatio[msg.sender] * (time2fullRedemption[msg.sender] - block.timestamp);\n+        uint256 _time2fullRedemption = time2fullRedemption[msg.sender];\n+        if (_time2fullRedemption > block.timestamp) {\n+            total += unstakeRatio[msg.sender] * (_time2fullRedemption - block.timestamp);\n         }\n         unstakeRatio[msg.sender] = total / exitCycle;\n         time2fullRedemption[msg.sender] = block.timestamp + exitCycle;\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/PeUSDMainnetStableVision.sol#L117-L119\n\n### Cache `userConvertInfo[msg.sender].depositedEUSDShares` and `userConvertInfo[msg.sender].mintedPeUSD` to save 2 SLOADs\n```solidity\nFile: contracts/lybra/token/PeUSDMainnetStableVision.sol\n117:        uint256 share = (userConvertInfo[msg.sender].depositedEUSDShares * peusdAmount) / userConvertInfo[msg.sender].mintedPeUSD;\n118:        userConvertInfo[msg.sender].mintedPeUSD -= peusdAmount;\n119:        userConvertInfo[msg.sender].depositedEUSDShares -= share;\n```\n```diff \ndiff --git a/lybra/token/PeUSDMainnetStableVision.sol b/lybra/token/PeUSDMainnetStableVision.sol\nindex a1b2c72..a8f5db2 100644\n--- a/lybra/token/PeUSDMainnetStableVision.sol\n+++ b/lybra/token/PeUSDMainnetStableVision.sol\n@@ -114,9 +114,11 @@ contract PeUSDMainnet is BaseOFTV2, ERC20 {\n     function convertToEUSD(uint256 peusdAmount) external {\n         require(peusdAmount <= userConvertInfo[msg.sender].mintedPeUSD &&peusdAmount > 0, \"PCE\");\n         _burn(msg.sender, peusdAmount);\n-        uint256 share = (userConvertInfo[msg.sender].depositedEUSDShares * peusdAmount) / userConvertInfo[msg.sender].mintedPeUSD;\n-        userConvertInfo[msg.sender].mintedPeUSD -= peusdAmount;\n-        userConvertInfo[msg.sender].depositedEUSDShares -= share;\n+        uint256 _depositedEUSDShares = userConvertInfo[msg.sender].depositedEUSDShares;\n+        uint256 _mintedPeUSD = userConvertInfo[msg.sender].mintedPeUSD;\n+        uint256 share = (_depositedEUSDShares * peusdAmount) / _mintedPeUSD;\n+        userConvertInfo[msg.sender].mintedPeUSD = _mintedPeUSD - peusdAmount;\n+        userConvertInfo[msg.sender].depositedEUSDShares = _depositedEUSDShares - share;\n         EUSD.transferShares(msg.sender, share);\n     }\n```\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/pools/base/LybraPeUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"../../interfaces/IPeUSD.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraPeUSDVaultBase {\n    IPeUSD public immutable PeUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public poolTotalPeUSDCirculation;\n    uint8 immutable vaultType = 1;\n    IPriceFeed immutable etherOracle;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    mapping(address => uint256) feeStored;\n    mapping(address => uint256) feeUpdatedAt;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event WithdrawAsset(address sponsor, address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 LiquidateAssetAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 peusdAmount, uint256 assetAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _peusd, address _etherOracle, address _collateral, address _configurator) {\n        PeUSD = IPeUSD(_peusd);\n        collateralAsset = IERC20(_collateral);\n        configurator = Iconfigurator(_configurator);\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    function totalDepositedAsset() public view returns (uint256) {\n        return collateralAsset.balanceOf(address(this));\n    }\n\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit staked ETH, update the interest distribution, can mint PeUSD directly\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint PeUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 collateral asset.\");\n        uint256 preBalance = collateralAsset.balanceOf(address(this));\n        collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(collateralAsset.balanceOf(address(this)) >= preBalance + assetAmount, \"\");\n\n        depositedAsset[msg.sender] += assetAmount;\n        if (mintAmount > 0) {\n            uint256 assetPrice = getAssetPrice();\n            _mintPeUSD(msg.sender, msg.sender, mintAmount, assetPrice);\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawAsset` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check user’s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _withdraw(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice The mint amount number of PeUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _mintPeUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of PeUSD and payback the amount of minted PeUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using PeUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - assetAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize PeUSD\n     * @dev After liquidation, borrower's debt is reduced by assetAmount * assetPrice, collateral is reduced by the assetAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf);\n        require(onBehalfOfCollateralRatio < configurator.getBadCollateralRatio(address(this)), \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(PeUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 peusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, peusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, peusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `peusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`peusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 peusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n        require(borrowed[provider] >= peusdAmount, \"peusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, peusdAmount);\n        uint256 collateralAmount = (((peusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, peusdAmount, collateralAmount, block.timestamp);\n    }\n\n    /**\n     * @dev Refresh LBR reward before adding providers debt. Refresh Lybra generated service fee before adding totalSupply. Check providers collateralRatio cannot below `safeCollateralRatio`after minting.\n     */\n    function _mintPeUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n        require(poolTotalPeUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n        _updateFee(_provider);\n\n        try configurator.refreshMintReward(_provider) {} catch {}\n\n        borrowed[_provider] += _mintAmount;\n\n        PeUSD.mint(_onBehalfOf, _mintAmount);\n        poolTotalPeUSDCirculation += _mintAmount;\n        _checkHealth(_provider, _assetPrice);\n        emit Mint(_provider, _onBehalfOf, _mintAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount PeUSD to payback minted PeUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalPeUSDCirculation.\n     */\n    function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n        _updateFee(_onBehalfOf);\n        uint256 totalFee = feeStored[_onBehalfOf];\n        uint256 amount = borrowed[_onBehalfOf] + totalFee >= _amount ? _amount : borrowed[_onBehalfOf] + totalFee;\n        if(amount >= totalFee) {\n            feeStored[_onBehalfOf] = 0;\n            PeUSD.transferFrom(_provider, address(configurator), totalFee);\n            PeUSD.burn(_provider, amount - totalFee);\n        } else {\n            feeStored[_onBehalfOf] = totalFee - amount;\n            PeUSD.transferFrom(_provider, address(configurator), amount);\n        }\n        try configurator.distributeRewards() {} catch {}\n        borrowed[_onBehalfOf] -= amount;\n        poolTotalPeUSDCirculation -= amount;\n\n        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n    }\n\n    function _withdraw(address _provider, address _onBehalfOf, uint256 _amount) internal {\n        require(depositedAsset[_provider] >= _amount, \"Withdraw amount exceeds deposited amount.\");\n        depositedAsset[_provider] -= _amount;\n        collateralAsset.transfer(_onBehalfOf, _amount);\n        if (getBorrowedOf(_provider) > 0) {\n            _checkHealth(_provider, getAssetPrice());\n        }\n        emit WithdrawAsset(_provider, address(collateralAsset), _onBehalfOf, _amount, block.timestamp);\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Ratio.\n     */\n    function _checkHealth(address user, uint256 price) internal view {\n        if (((depositedAsset[user] * price * 100) / getBorrowedOf(user)) < configurator.getSafeCollateralRatio(address(this))) \n            revert(\"collateralRatio is Below safeCollateralRatio\");\n    }\n\n    function _updateFee(address user) internal {\n        if (block.timestamp > feeUpdatedAt[user]) {\n            feeStored[user] += _newFee(user);\n            feeUpdatedAt[user] = block.timestamp;\n        }\n    }\n\n    function _newFee(address user) internal view returns (uint256) {\n        return (borrowed[user] * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - feeUpdatedAt[user])) / (86400 * 365) / 10000;\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     */\n    function _etherPrice() internal returns (uint256) {\n        return etherOracle.fetchPrice();\n    }\n\n    /**\n     * @dev Returns the current borrowing amount for the user, including borrowed shares and accumulated fees.\n     * @param user The address of the user.\n     * @return The total borrowing amount for the user.\n     */\n    function getBorrowedOf(address user) public view returns (uint256) {\n        return borrowed[user] + feeStored[user] + _newFee(user);\n    }\n\n    function getPoolTotalPeUSDCirculation() public view returns (uint256) {\n        return poolTotalPeUSDCirculation;\n    }\n\n    function getAsset() external view returns (address) {\n        return address(collateralAsset);\n    }\n\n    function getVaultType() external pure returns (uint8) {\n        return vaultType;\n    }\n\n    function getAssetPrice() public virtual returns (uint256);\n}"
    },
    {
      "filename": "contracts/lybra/pools/base/LybraPeUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"../../interfaces/IPeUSD.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraPeUSDVaultBase {\n    IPeUSD public immutable PeUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public poolTotalPeUSDCirculation;\n    uint8 immutable vaultType = 1;\n    IPriceFeed immutable etherOracle;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    mapping(address => uint256) feeStored;\n    mapping(address => uint256) feeUpdatedAt;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event WithdrawAsset(address sponsor, address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 LiquidateAssetAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 peusdAmount, uint256 assetAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _peusd, address _etherOracle, address _collateral, address _configurator) {\n        PeUSD = IPeUSD(_peusd);\n        collateralAsset = IERC20(_collateral);\n        configurator = Iconfigurator(_configurator);\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    function totalDepositedAsset() public view returns (uint256) {\n        return collateralAsset.balanceOf(address(this));\n    }\n\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit staked ETH, update the interest distribution, can mint PeUSD directly\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint PeUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 collateral asset.\");\n        uint256 preBalance = collateralAsset.balanceOf(address(this));\n        collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(collateralAsset.balanceOf(address(this)) >= preBalance + assetAmount, \"\");\n\n        depositedAsset[msg.sender] += assetAmount;\n        if (mintAmount > 0) {\n            uint256 assetPrice = getAssetPrice();\n            _mintPeUSD(msg.sender, msg.sender, mintAmount, assetPrice);\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawAsset` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check user’s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _withdraw(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice The mint amount number of PeUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _mintPeUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of PeUSD and payback the amount of minted PeUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using PeUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - assetAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize PeUSD\n     * @dev After liquidation, borrower's debt is reduced by assetAmount * assetPrice, collateral is reduced by the assetAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf);\n        require(onBehalfOfCollateralRatio < configurator.getBadCollateralRatio(address(this)), \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(PeUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 peusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, peusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, peusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `peusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`peusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 peusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n        require(borrowed[provider] >= peusdAmount, \"peusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, peusdAmount);\n        uint256 collateralAmount = (((peusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, peusdAmount, collateralAmount, block.timestamp);\n    }\n\n    /**\n     * @dev Refresh LBR reward before adding providers debt. Refresh Lybra generated service fee before adding totalSupply. Check providers collateralRatio cannot below `safeCollateralRatio`after minting.\n     */\n    function _mintPeUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n        require(poolTotalPeUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n        _updateFee(_provider);\n\n        try configurator.refreshMintReward(_provider) {} catch {}\n\n        borrowed[_provider] += _mintAmount;\n\n        PeUSD.mint(_onBehalfOf, _mintAmount);\n        poolTotalPeUSDCirculation += _mintAmount;\n        _checkHealth(_provider, _assetPrice);\n        emit Mint(_provider, _onBehalfOf, _mintAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount PeUSD to payback minted PeUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalPeUSDCirculation.\n     */\n    function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n        _updateFee(_onBehalfOf);\n        uint256 totalFee = feeStored[_onBehalfOf];\n        uint256 amount = borrowed[_onBehalfOf] + totalFee >= _amount ? _amount : borrowed[_onBehalfOf] + totalFee;\n        if(amount >= totalFee) {\n            feeStored[_onBehalfOf] = 0;\n            PeUSD.transferFrom(_provider, address(configurator), totalFee);\n            PeUSD.burn(_provider, amount - totalFee);\n        } else {\n            feeStored[_onBehalfOf] = totalFee - amount;\n            PeUSD.transferFrom(_provider, address(configurator), amount);\n        }\n        try configurator.distributeRewards() {} catch {}\n        borrowed[_onBehalfOf] -= amount;\n        poolTotalPeUSDCirculation -= amount;\n\n        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n    }\n\n    function _withdraw(address _provider, address _onBehalfOf, uint256 _amount) internal {\n        require(depositedAsset[_provider] >= _amount, \"Withdraw amount exceeds deposited amount.\");\n        depositedAsset[_provider] -= _amount;\n        collateralAsset.transfer(_onBehalfOf, _amount);\n        if (getBorrowedOf(_provider) > 0) {\n            _checkHealth(_provider, getAssetPrice());\n        }\n        emit WithdrawAsset(_provider, address(collateralAsset), _onBehalfOf, _amount, block.timestamp);\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Ratio.\n     */\n    function _checkHealth(address user, uint256 price) internal view {\n        if (((depositedAsset[user] * price * 100) / getBorrowedOf(user)) < configurator.getSafeCollateralRatio(address(this))) \n            revert(\"collateralRatio is Below safeCollateralRatio\");\n    }\n\n    function _updateFee(address user) internal {\n        if (block.timestamp > feeUpdatedAt[user]) {\n            feeStored[user] += _newFee(user);\n            feeUpdatedAt[user] = block.timestamp;\n        }\n    }\n\n    function _newFee(address user) internal view returns (uint256) {\n        return (borrowed[user] * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - feeUpdatedAt[user])) / (86400 * 365) / 10000;\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     */\n    function _etherPrice() internal returns (uint256) {\n        return etherOracle.fetchPrice();\n    }\n\n    /**\n     * @dev Returns the current borrowing amount for the user, including borrowed shares and accumulated fees.\n     * @param user The address of the user.\n     * @return The total borrowing amount for the user.\n     */\n    function getBorrowedOf(address user) public view returns (uint256) {\n        return borrowed[user] + feeStored[user] + _newFee(user);\n    }\n\n    function getPoolTotalPeUSDCirculation() public view returns (uint256) {\n        return poolTotalPeUSDCirculation;\n    }\n\n    function getAsset() external view returns (address) {\n        return address(collateralAsset);\n    }\n\n    function getVaultType() external pure returns (uint8) {\n        return vaultType;\n    }\n\n    function getAssetPrice() public virtual returns (uint256);\n}"
    },
    {
      "filename": "contracts/lybra/pools/base/LybraPeUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"../../interfaces/IPeUSD.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraPeUSDVaultBase {\n    IPeUSD public immutable PeUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public poolTotalPeUSDCirculation;\n    uint8 immutable vaultType = 1;\n    IPriceFeed immutable etherOracle;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    mapping(address => uint256) feeStored;\n    mapping(address => uint256) feeUpdatedAt;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event WithdrawAsset(address sponsor, address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 LiquidateAssetAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 peusdAmount, uint256 assetAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _peusd, address _etherOracle, address _collateral, address _configurator) {\n        PeUSD = IPeUSD(_peusd);\n        collateralAsset = IERC20(_collateral);\n        configurator = Iconfigurator(_configurator);\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    function totalDepositedAsset() public view returns (uint256) {\n        return collateralAsset.balanceOf(address(this));\n    }\n\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit staked ETH, update the interest distribution, can mint PeUSD directly\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint PeUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 collateral asset.\");\n        uint256 preBalance = collateralAsset.balanceOf(address(this));\n        collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(collateralAsset.balanceOf(address(this)) >= preBalance + assetAmount, \"\");\n\n        depositedAsset[msg.sender] += assetAmount;\n        if (mintAmount > 0) {\n            uint256 assetPrice = getAssetPrice();\n            _mintPeUSD(msg.sender, msg.sender, mintAmount, assetPrice);\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawAsset` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check user’s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _withdraw(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice The mint amount number of PeUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _mintPeUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of PeUSD and payback the amount of minted PeUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using PeUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - assetAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize PeUSD\n     * @dev After liquidation, borrower's debt is reduced by assetAmount * assetPrice, collateral is reduced by the assetAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf);\n        require(onBehalfOfCollateralRatio < configurator.getBadCollateralRatio(address(this)), \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(PeUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 peusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, peusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, peusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `peusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:"
    }
  ]
}