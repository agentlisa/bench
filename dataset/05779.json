{
  "Title": "[M-05] No deposit cross-chain calls/communication can still originate from a removed branch bridge agent",
  "Content": "\nBridge agents are removed/toggled off to stop communication to/from them (confirmed by sponsor); in case of some situation, such as a bug in protocol or in case of an upgrade to a newer version of the protocol (in case LayerZero decides to upgrade/migrate their messaging library).\n\nAdmin router contracts are able to disable or toggle off anybody's bridge agents due to any reasons through the [removeBranchBridgeAgent()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/CoreRootRouter.sol#L186) function in [CoreRootRouter.sol](https://github.com/code-423n4/2023-09-maia/blob/main/src/CoreRootRouter.sol) contract. But although this toggles off the branch bridge agent in the Branch chain's [BranchPort](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L355), it still allows \"No Deposit\" calls to originate from that deactivated branch bridge agent.\n\n### Proof of Concept\n\nHere is the whole process:\n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/CoreRootRouter.sol#L186>\n\n1. Admin in [CoreRootRouter](https://github.com/code-423n4/2023-09-maia/blob/main/src/CoreRootRouter.sol#L186) decides to remove branch bridge agent through [removeBranchBridgeAgent()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/CoreRootRouter.sol#L186) function\n\n    Here is the execution path of the call:\n\n    1. Root chain to Endpoint (EP):\n    `removeBranchBridgeAgent => callOut => _performCall => send`\n\n    2. EP to Branch chain:\n    `receivePayload => lzReceive => lzReceiveNonBlocking => _execute => executeNoSettlement (Executor) => executeNoSettlement (Router) => _removeBranchBridgeAgent => toggleBridgeAgent (Port)`\n\n    The following state change occurs in function [toggleBridgeAgent()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L355):\n\n - Line 356 - `isBridgeAgent` for `_bridgeAgent` is set to false, thus deactivating it.\n\n```solidity\nFile: BranchPort.sol\n355:     function toggleBridgeAgent(address _bridgeAgent) external override requiresCoreRouter {\n356:         isBridgeAgent[_bridgeAgent] = !isBridgeAgent[_bridgeAgent];\n357: \n358:         emit BridgeAgentToggled(_bridgeAgent);\n359:     }\n```\n\nNote: Over here there is no call made back to the root chain again, which means the synced branch bridge agent is still synced in root (as shown [here](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootBridgeAgent.sol#L1181C1-L1182C107)). But even if it is synced in Root chain, there are no checks or even state variables to track activeness (bool `isActive`) of branch bridge agent on the Root chain end as well. Not related to this POC but good to be aware of.\n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L195>\n\n2. Now, although bridge agent has been deactivated from [BranchPort's state](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L356), it can still be used for no deposit calls/communication when calling function [callOut()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L195). This is because in the function [callOut()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L195), there is no check to see if it the current BranchBridgeAgent (that is deactivated) is active in the [BranchPort](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L547C1-L550C6) through the modifier [requiresBridgeAgent()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L547C1-L550C6). Now let's see how a call can occur through a deactivated branch bridge agent.\n\n3. User calls [callOut()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BaseBranchRouter.sol#L83) to communicate through the branch BridgeAgent (that was deactivated):\n\n```solidity\nFile: BaseBranchRouter.sol\n83:     function callOut(bytes calldata _params, GasParams calldata _gParams) external payable override lock {\n84:         IBridgeAgent(localBridgeAgentAddress).callOut{value: msg.value}(payable(msg.sender), _params, _gParams);\n85:     }\n```\n\n4. Here is the execution path of the call from [callOut()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BaseBranchRouter.sol#L83) function in [BaseBranchRouter](https://github.com/code-423n4/2023-09-maia/blob/main/src/BaseBranchRouter.sol) contract:\n\n    1. Branch chain to EP:\n    `callOut() => callOut (branch bridge agent - that was deactivated) => _performCall => send`\n\n    2. EP to Root chain:\n    `receivePayload => lzReceive => lzReceiveNonBlocking => _execute => executeNoDeposit => execute (Router) => logic` continues based on custom Router's implementation\n\nThere are few important points to note here:\n\n1.  Calls (No deposit calls) can occur through both [callOut()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L195) and [callOutSigned()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L262).\n\n2.  Adding the modifier [requiresBridgeAgent()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L547C1-L550C6) check is critical here, as communication between user's custom Branch chain to Root chain routers is still active.\n\n3.  Incoming calls to [lzReceive()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L578) are not fine from user's custom Root Router, since that still allows no deposit router-router communication through the deactivated branch bridge agent.\n\n4.  Incoming calls to [lzReceive()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L578) are fine from admin [CoreRootRouter](https://github.com/code-423n4/2023-09-maia/blob/main/src/CoreRootRouter.sol#L186), since such calls will be made to manage bridgeAgents, factories, strategy tokens and port strategies in the BranchPort.\n\n5.  Outgoing calls from function [callOutSystem()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L180) are fine since the function is only used to respond back to the root chain when an incoming call from root to branch occurs to manage bridgeAgents, factories, strategy tokens and port strategies.\n\n6.  Preventing outgoing no deposit calls are important because user's custom Root Router can communicate with other chains for various purposes such as bridging of tokens from Arbitrum (Root) to another branch chains like Avalanche, Fantom and many more. This is crucial since the call for bridging between Arbitrum and Avalanche originates from a branch bridge agent that is considered inactive.\n\n### Recommended Mitigation Steps\n\nThe issues here to solve are:\n\n1.  Outgoing \"No deposit\" calls from [callOut()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L195) and [callOutSigned()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L262).\n\n2.  Allowing incoming calls from [CoreRootRouter](https://github.com/code-423n4/2023-09-maia/blob/main/src/CoreRootRouter.sol#L186), but not user's custom Root Router.\n\nSolution for [callOut()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L195) function:\n\nCheck added on Line 202 - same can be applied for [callOutSigned()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L262)):\n\n```solidity\nFile: BranchBridgeAgent.sol\n195:     function callOut(address payable _refundee, bytes calldata _params, GasParams calldata _gParams)\n196:         external\n197:         payable\n198:         override\n199:         lock\n200:     {\n201:         //Perform check to see if this BranchBridgeAgent is active in BranchPort\n202:         require(localPortAddress.isBridgeAgent(address(this)), \"Unrecognized BridgeAgent!\");\n203:\n204:         //Encode Data for cross-chain call.\n205:         bytes memory payload = abi.encodePacked(bytes1(0x01), depositNonce++, _params);\n206:         \n207:         //Perform Call\n208:         _performCall(_refundee, payload, _gParams);\n209:     }\n```\n\nSolution for point 2:\n\nIn user's branch bridge agent, the following check should be added in [Func ID 0x00 No deposit if block](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L599C1-L614C1) in the [lzReceiveNonBlockingFunction](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L587).\n\nCheck added on Line 602:\n\n```solidity\nFile: BranchBridgeAgent.sol\n598:         // DEPOSIT FLAG: 0 (No settlement)\n599:         if (flag == 0x00) {\n600:\n601:             //Perform check to see if this BranchBridgeAgent is active in BranchPort\n602:             require(localPortAddress.isBridgeAgent(address(this)), \"Unrecognized BridgeAgent!\");\n603:\n604:             // Get Settlement Nonce\n605:             nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n606: \n607:             //Check if tx has already been executed\n608:             if (executionState[nonce] != STATUS_READY) revert AlreadyExecutedTransaction();\n609: \n610:             //Try to execute the remote request\n611:             //Flag 0 - BranchBridgeAgentExecutor(bridgeAgentExecutorAddress).executeNoSettlement(localRouterAddress, _payload)\n612:             _execute(\n613:                 nonce,\n614:                 abi.encodeWithSelector(\n615:                     BranchBridgeAgentExecutor.executeNoSettlement.selector, localRouterAddress, _payload\n616:                 )\n617:             );\n```\n\nIn case of the Maia administration contracts, the calls from the root chain CoreRootRouterAddress-CoreRootBridgeagent pair should not be stopped. Therefore, in the administration's corresponding CoreBranchBridgeAgent contract, do not add the above check in order to allow no deposit calls to go through.\n\nThis way when the branch bridge agent is inactive, only the Maia Administration CoreRootRouter can continue execution.\n\n### Assessed type\n\nError\n\n**[0xBugsy (Maia) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-09-maia-findings/issues/564#issuecomment-1764873217):**\n > Despite only affecting functions that don't use token deposits and disagreeing with severity, this is a great finding and we will address it in our codebase.\n\n**[alcueca (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-09-maia-findings/issues/564#issuecomment-1777376380):**\n > There is no loss of funds or denial of service to users. However, part of the protocol (the emergency features) are rendered ineffective. Medium.\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/564#issuecomment-1807197268):**\n > Addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/eea9bbc37328bc8012d667b126d3b4ef4286bf84).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/CoreRootRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC20hTokenRootFactory as IFactory} from \"./interfaces/IERC20hTokenRootFactory.sol\";\nimport {IRootRouter} from \"./interfaces/IRootRouter.sol\";\nimport {\n    DepositParams,\n    DepositMultipleParams,\n    GasParams,\n    IRootBridgeAgent as IBridgeAgent\n} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\n\n/**\n * 2\n * @title  Core Root Router Contract\n * @author MaiaDAO\n * @notice Core Root Router implementation for Root Environment deployment.\n *         This contract is responsible for permissionlessly adding new\n *         tokens or Bridge Agents to the system as well as key governance\n *         enabled system functions (i.e. `toggleBranchBridgeAgentFactory`).\n * @dev    Func IDs for calling these functions through messaging layer:\n *\n *         CROSS-CHAIN MESSAGING FUNCIDs\n *         -----------------------------\n *         FUNC ID      | FUNC NAME\n *         -------------+---------------\n *         0x01         | addGlobalToken\n *         0x02         | addLocalToken\n *         0x03         | setLocalToken\n *         0x04         | syncBranchBridgeAgent\n *\n */\ncontract CoreRootRouter is IRootRouter, Ownable {\n    /*///////////////////////////////////////////////////////////////\n                    CORE ROOT ROUTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Boolean to indicate if the contract is in set up mode.\n    bool internal _setup;\n\n    /// @notice Root Chain Layer Zero Identifier.\n    uint256 public immutable rootChainId;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept\n    ///         managed and supplied to different Port Strategies.\n    address public immutable rootPortAddress;\n\n    /// @notice Bridge Agent to manage remote execution and cross-chain assets.\n    address payable public bridgeAgentAddress;\n\n    /// @notice Bridge Agent Executor Address.\n    address public bridgeAgentExecutorAddress;\n\n    /// @notice ERC20 hToken Root Factory Address.\n    address public hTokenFactoryAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Core Root Router.\n     * @param _rootChainId layer zero root chain id.\n     * @param _rootPortAddress address of the Root Port.\n     */\n    constructor(uint256 _rootChainId, address _rootPortAddress) {\n        rootChainId = _rootChainId;\n        rootPortAddress = _rootPortAddress;\n\n        _initializeOwner(msg.sender);\n        _setup = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function initialize(address _bridgeAgentAddress, address _hTokenFactory) external onlyOwner {\n        require(_setup, \"Contract is already initialized\");\n        _setup = false;\n        bridgeAgentAddress = payable(_bridgeAgentAddress);\n        bridgeAgentExecutorAddress = IBridgeAgent(_bridgeAgentAddress).bridgeAgentExecutorAddress();\n        hTokenFactoryAddress = _hTokenFactory;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add a new Chain (Branch Bridge Agent and respective Router) to a Root Bridge Agent.\n     * @param _branchBridgeAgentFactory Address of the branch Bridge Agent Factory.\n     * @param _newBranchRouter Address of the new branch router.\n     * @param _refundee Address of the excess gas receiver.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function addBranchToBridgeAgent(\n        address _rootBridgeAgent,\n        address _branchBridgeAgentFactory,\n        address _newBranchRouter,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams[2] calldata _gParams\n    ) external payable {\n        // Check if msg.sender is the Bridge Agent Manager\n        if (msg.sender != IPort(rootPortAddress).getBridgeAgentManager(_rootBridgeAgent)) {\n            revert UnauthorizedCallerNotManager();\n        }\n\n        // Check if valid chain\n        if (!IPort(rootPortAddress).isChainId(_dstChainId)) revert InvalidChainId();\n\n        // Check if chain already added to bridge agent\n        if (IBridgeAgent(_rootBridgeAgent).getBranchBridgeAgent(_dstChainId) != address(0)) revert InvalidChainId();\n\n        // Check if Branch Bridge Agent is allowed by Root Bridge Agent\n        if (!IBridgeAgent(_rootBridgeAgent).isBranchBridgeAgentAllowed(_dstChainId)) revert UnauthorizedChainId();\n\n        // Encode CallData\n        bytes memory params = abi.encode(\n            _newBranchRouter,\n            _branchBridgeAgentFactory,\n            _rootBridgeAgent,\n            IBridgeAgent(_rootBridgeAgent).factoryAddress(),\n            _refundee,\n            _gParams[1]\n        );\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x02), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams[0]\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                GOVERNANCE / ADMIN EXTERNAL FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add or Remove a Branch Bridge Agent Factory.\n     * @param _rootBridgeAgentFactory Address of the root Bridge Agent Factory.\n     * @param _branchBridgeAgentFactory Address of the branch Bridge Agent Factory.\n     * @param _refundee Receiver of any leftover execution gas upon reaching the destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function toggleBranchBridgeAgentFactory(\n        address _rootBridgeAgentFactory,\n        address _branchBridgeAgentFactory,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        if (!IPort(rootPortAddress).isBridgeAgentFactory(_rootBridgeAgentFactory)) {\n            revert UnrecognizedBridgeAgentFactory();\n        }\n\n        // Encode CallData\n        bytes memory params = abi.encode(_branchBridgeAgentFactory);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x03), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Remove a Branch Bridge Agent.\n     * @param _branchBridgeAgent Address of the Branch Bridge Agent to be updated.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function removeBranchBridgeAgent(\n        address _branchBridgeAgent,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        //Encode CallData\n        bytes memory params = abi.encode(_branchBridgeAgent);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x04), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Add or Remove a Strategy Token.\n     * @param _underlyingToken Address of the underlying token to be added for use in Branch strategies.\n     * @param _minimumReservesRatio Minimum Branch Port reserves ratio for the underlying token.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function manageStrategyToken(\n        address _underlyingToken,\n        uint256 _minimumReservesRatio,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        // Encode CallData\n        bytes memory params = abi.encode(_underlyingToken, _minimumReservesRatio);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x05), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Add, Remove or update a Port Strategy.\n     * @param _portStrategy Address of the Port Strategy to be added for use in Branch strategies.\n     * @param _underlyingToken Address of the underlying token to be added for use in Branch strategies.\n     * @param _dailyManagementLimit Daily management limit of the given token for the Port Strategy.\n     * @param _isUpdateDailyLimit Boolean to safely indicate if the Port Strategy is being updated and not deactivated.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function managePortStrategy(\n        address _portStrategy,\n        address _underlyingToken,\n        uint256 _dailyManagementLimit,\n        bool _isUpdateDailyLimit,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        // Encode CallData\n        bytes memory params = abi.encode(_portStrategy, _underlyingToken, _dailyManagementLimit, _isUpdateDailyLimit);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x06), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Set the Core Branch Router and Bridge Agent.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _coreBranchRouter Address of the Core Branch Router.\n     * @param _coreBranchBridgeAgent Address of the Core Branch Bridge Agent.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function setCoreBranch(\n        address _refundee,\n        address _coreBranchRouter,\n        address _coreBranchBridgeAgent,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable {\n        // Check caller is root port\n        require(msg.sender == rootPortAddress, \"Only root port can call\");\n\n        // Encode CallData\n        bytes memory params = abi.encode(_coreBranchRouter, _coreBranchBridgeAgent);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x07), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        LAYERZERO FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootRouter\n    function executeResponse(bytes calldata _encodedData, uint16 _srcChainId)\n        external\n        payable\n        override\n        requiresExecutor\n    {\n        // Parse funcId\n        bytes1 funcId = _encodedData[0];\n\n        ///  FUNC ID: 2 (_addLocalToken)\n        if (funcId == 0x02) {\n            (address underlyingAddress, address localAddress, string memory name, string memory symbol, uint8 decimals)\n            = abi.decode(_encodedData[1:], (address, address, string, string, uint8));\n\n            _addLocalToken(underlyingAddress, localAddress, name, symbol, decimals, _srcChainId);\n\n            /// FUNC ID: 3 (_setLocalToken)\n        } else if (funcId == 0x03) {\n            (address globalAddress, address localAddress) = abi.decode(_encodedData[1:], (address, address));\n\n            _setLocalToken(globalAddress, localAddress, _srcChainId);\n\n            /// FUNC ID: 4 (_syncBranchBridgeAgent)\n        } else if (funcId == 0x04) {\n            (address newBranchBridgeAgent, address rootBridgeAgent) = abi.decode(_encodedData[1:], (address, address));\n\n            _syncBranchBridgeAgent(newBranchBridgeAgent, rootBridgeAgent, _srcChainId);\n\n            /// Unrecognized Function Selector\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    /// @inheritdoc IRootRouter\n    function execute(bytes calldata _encodedData, uint16) external payable override requiresExecutor {\n        // Parse funcId\n        bytes1 funcId = _encodedData[0];\n\n        /// FUNC ID: 1 (_addGlobalToken)\n        if (funcId == 0x01) {\n            (address refundee, address globalAddress, uint16 dstChainId, GasParams[2] memory gasParams) =\n                abi.decode(_encodedData[1:], (address, address, uint16, GasParams[2]));\n\n            _addGlobalToken(refundee, globalAddress, dstChainId, gasParams);\n\n            /// Unrecognized Function Selector\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    /// @inheritdoc IRootRouter\n    function executeDepositSingle(bytes memory, DepositParams memory, uint16)\n        external\n        payable\n        override\n        requiresExecutor\n    {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function executeDepositMultiple(bytes calldata, DepositMultipleParams memory, uint16)\n        external\n        payable\n        override\n        requiresExecutor\n    {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function executeSigned(bytes memory, address, uint16) external payable override requiresExecutor {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function executeSignedDepositSingle(bytes memory, DepositParams memory, address, uint16)\n        external\n        payable\n        override\n        requiresExecutor\n    {\n        revert();\n    }\n\n    /// @inheritdoc IRootRouter\n    function executeSignedDepositMultiple(bytes memory, DepositMultipleParams memory, address, uint16)\n        external\n        payable\n        override\n        requiresExecutor\n    {\n        revert();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT INTERNAL FUNCTIONS\n    ////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function to add a global token to a specific chain. Must be called from a branch.\n     *   @param _refundee Address of the excess gas receiver.\n     *   @param _globalAddress global token to be added.\n     *   @param _dstChainId chain to which the Global Token will be added.\n     *   @param _gParams Gas parameters for remote execution.\n     *\n     */\n    function _addGlobalToken(\n        address _refundee,\n        address _globalAddress,\n        uint16 _dstChainId,\n        GasParams[2] memory _gParams\n    ) internal {\n        if (_dstChainId == rootChainId) revert InvalidChainId();\n\n        if (!IPort(rootPortAddress).isGlobalAddress(_globalAddress)) {\n            revert UnrecognizedGlobalToken();\n        }\n\n        // Verify that it does not exist\n        if (IPort(rootPortAddress).isGlobalToken(_globalAddress, _dstChainId)) {\n            revert TokenAlreadyAdded();\n        }\n\n        // Encode CallData\n        bytes memory params = abi.encode(\n            _globalAddress,\n            ERC20(_globalAddress).name(),\n            ERC20(_globalAddress).symbol(),\n            ERC20(_globalAddress).decimals(),\n            _refundee,\n            _gParams[1]\n        );\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x01), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams[0]\n        );\n    }\n\n    /**\n     * @notice Function to add a new local to the global environment. Called from branch chain.\n     *   @param _underlyingAddress the token's underlying/native chain address.\n     *   @param _localAddress the token's address.\n     *   @param _name the token's name.\n     *   @param _symbol the token's symbol.\n     *   @param _decimals the token's decimals.\n     *   @param _srcChainId the token's origin chain Id.\n     *\n     */\n    function _addLocalToken(\n        address _underlyingAddress,\n        address _localAddress,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint16 _srcChainId\n    ) internal {\n        // Verify if the underlying address is already known by the branch or root chain\n        if (IPort(rootPortAddress).isGlobalAddress(_underlyingAddress)) revert TokenAlreadyAdded();\n        if (IPort(rootPortAddress).isLocalToken(_underlyingAddress, _srcChainId)) revert TokenAlreadyAdded();\n        if (IPort(rootPortAddress).isUnderlyingToken(_underlyingAddress, _srcChainId)) revert TokenAlreadyAdded();\n\n        //Create a new global token\n        address newToken = address(IFactory(hTokenFactoryAddress).createToken(_name, _symbol, _decimals));\n\n        // Update Registry\n        IPort(rootPortAddress).setAddresses(\n            newToken, (_srcChainId == rootChainId) ? newToken : _localAddress, _underlyingAddress, _srcChainId\n        );\n    }\n\n    /**\n     * @notice Internal function to set the local token on a specific chain for a global token.\n     *   @param _globalAddress global token to be updated.\n     *   @param _localAddress local token to be added.\n     *   @param _dstChainId local token's chain.\n     *\n     */\n    function _setLocalToken(address _globalAddress, address _localAddress, uint16 _dstChainId) internal {\n        // Verify if the token already added\n        if (IPort(rootPortAddress).isLocalToken(_localAddress, _dstChainId)) revert TokenAlreadyAdded();\n\n        // Set the global token's new branch chain address\n        IPort(rootPortAddress).setLocalAddress(_globalAddress, _localAddress, _dstChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                BRIDGE AGENT MANAGEMENT INTERNAL FUNCTIONS\n    ////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev Internal function sync a Root Bridge Agent with a newly created BRanch Bridge Agent.\n     *   @param _newBranchBridgeAgent new branch bridge agent address\n     *   @param _rootBridgeAgent new branch bridge agent address\n     *   @param _srcChainId branch chain id.\n     *\n     */\n    function _syncBranchBridgeAgent(address _newBranchBridgeAgent, address _rootBridgeAgent, uint256 _srcChainId)\n        internal\n    {\n        IPort(rootPortAddress).syncBranchBridgeAgentWithRoot(_newBranchBridgeAgent, _rootBridgeAgent, _srcChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MODIFIERS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier verifies the caller is the Bridge Agent Executor.\n    modifier requiresExecutor() {\n        if (msg.sender != bridgeAgentExecutorAddress) revert UnrecognizedBridgeAgentExecutor();\n        _;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                ERRORS\n    ///////////////////////////////////////////////////////////////*/\n\n    error InvalidChainId();\n\n    error UnauthorizedChainId();\n\n    error UnauthorizedCallerNotManager();\n\n    error TokenAlreadyAdded();\n\n    error UnrecognizedGlobalToken();\n\n    error UnrecognizedBridgeAgentFactory();\n}"
    },
    {
      "filename": "src/CoreRootRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC20hTokenRootFactory as IFactory} from \"./interfaces/IERC20hTokenRootFactory.sol\";\nimport {IRootRouter} from \"./interfaces/IRootRouter.sol\";\nimport {\n    DepositParams,\n    DepositMultipleParams,\n    GasParams,\n    IRootBridgeAgent as IBridgeAgent\n} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\n\n/**\n * 2\n * @title  Core Root Router Contract\n * @author MaiaDAO\n * @notice Core Root Router implementation for Root Environment deployment.\n *         This contract is responsible for permissionlessly adding new\n *         tokens or Bridge Agents to the system as well as key governance\n *         enabled system functions (i.e. `toggleBranchBridgeAgentFactory`).\n * @dev    Func IDs for calling these functions through messaging layer:\n *\n *         CROSS-CHAIN MESSAGING FUNCIDs\n *         -----------------------------\n *         FUNC ID      | FUNC NAME\n *         -------------+---------------\n *         0x01         | addGlobalToken\n *         0x02         | addLocalToken\n *         0x03         | setLocalToken\n *         0x04         | syncBranchBridgeAgent\n *\n */\ncontract CoreRootRouter is IRootRouter, Ownable {\n    /*///////////////////////////////////////////////////////////////\n                    CORE ROOT ROUTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Boolean to indicate if the contract is in set up mode.\n    bool internal _setup;\n\n    /// @notice Root Chain Layer Zero Identifier.\n    uint256 public immutable rootChainId;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept\n    ///         managed and supplied to different Port Strategies.\n    address public immutable rootPortAddress;\n\n    /// @notice Bridge Agent to manage remote execution and cross-chain assets.\n    address payable public bridgeAgentAddress;\n\n    /// @notice Bridge Agent Executor Address.\n    address public bridgeAgentExecutorAddress;\n\n    /// @notice ERC20 hToken Root Factory Address.\n    address public hTokenFactoryAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Core Root Router.\n     * @param _rootChainId layer zero root chain id.\n     * @param _rootPortAddress address of the Root Port.\n     */\n    constructor(uint256 _rootChainId, address _rootPortAddress) {\n        rootChainId = _rootChainId;\n        rootPortAddress = _rootPortAddress;\n\n        _initializeOwner(msg.sender);\n        _setup = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function initialize(address _bridgeAgentAddress, address _hTokenFactory) external onlyOwner {\n        require(_setup, \"Contract is already initialized\");\n        _setup = false;\n        bridgeAgentAddress = payable(_bridgeAgentAddress);\n        bridgeAgentExecutorAddress = IBridgeAgent(_bridgeAgentAddress).bridgeAgentExecutorAddress();\n        hTokenFactoryAddress = _hTokenFactory;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add a new Chain (Branch Bridge Agent and respective Router) to a Root Bridge Agent.\n     * @param _branchBridgeAgentFactory Address of the branch Bridge Agent Factory.\n     * @param _newBranchRouter Address of the new branch router.\n     * @param _refundee Address of the excess gas receiver.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function addBranchToBridgeAgent(\n        address _rootBridgeAgent,\n        address _branchBridgeAgentFactory,\n        address _newBranchRouter,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams[2] calldata _gParams\n    ) external payable {\n        // Check if msg.sender is the Bridge Agent Manager\n        if (msg.sender != IPort(rootPortAddress).getBridgeAgentManager(_rootBridgeAgent)) {\n            revert UnauthorizedCallerNotManager();\n        }\n\n        // Check if valid chain\n        if (!IPort(rootPortAddress).isChainId(_dstChainId)) revert InvalidChainId();\n\n        // Check if chain already added to bridge agent\n        if (IBridgeAgent(_rootBridgeAgent).getBranchBridgeAgent(_dstChainId) != address(0)) revert InvalidChainId();\n\n        // Check if Branch Bridge Agent is allowed by Root Bridge Agent\n        if (!IBridgeAgent(_rootBridgeAgent).isBranchBridgeAgentAllowed(_dstChainId)) revert UnauthorizedChainId();\n\n        // Encode CallData\n        bytes memory params = abi.encode(\n            _newBranchRouter,\n            _branchBridgeAgentFactory,\n            _rootBridgeAgent,\n            IBridgeAgent(_rootBridgeAgent).factoryAddress(),\n            _refundee,\n            _gParams[1]\n        );\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x02), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams[0]\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                GOVERNANCE / ADMIN EXTERNAL FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add or Remove a Branch Bridge Agent Factory.\n     * @param _rootBridgeAgentFactory Address of the root Bridge Agent Factory.\n     * @param _branchBridgeAgentFactory Address of the branch Bridge Agent Factory.\n     * @param _refundee Receiver of any leftover execution gas upon reaching the destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function toggleBranchBridgeAgentFactory(\n        address _rootBridgeAgentFactory,\n        address _branchBridgeAgentFactory,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        if (!IPort(rootPortAddress).isBridgeAgentFactory(_rootBridgeAgentFactory)) {\n            revert UnrecognizedBridgeAgentFactory();\n        }\n\n        // Encode CallData\n        bytes memory params = abi.encode(_branchBridgeAgentFactory);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x03), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Remove a Branch Bridge Agent.\n     * @param _branchBridgeAgent Address of the Branch Bridge Agent to be updated.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function removeBranchBridgeAgent(\n        address _branchBridgeAgent,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        //Encode CallData\n        bytes memory params = abi.encode(_branchBridgeAgent);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x04), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Add or Remove a Strategy Token.\n     * @param _underlyingToken Address of the underlying token to be added for use in Branch strategies.\n     * @param _minimumReservesRatio Minimum Branch Port reserves ratio for the underlying token.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function manageStrategyToken(\n        address _underlyingToken,\n        uint256 _minimumReservesRatio,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        // Encode CallData\n        bytes memory params = abi.encode(_underlyingToken, _minimumReservesRatio);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x05), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Add, Remove or update a Port Strategy.\n     * @param _portStrategy Address of the Port Strategy to be added for use in Branch strategies.\n     * @param _underlyingToken Address of the underlying token to be added for use in Branch strategies.\n     * @param _dailyManagementLimit Daily management limit of the given token for the Port Strategy.\n     * @param _isUpdateDailyLimit Boolean to safely indicate if the Port Strategy is being updated and not deactivated.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function managePortStrategy(\n        address _portStrategy,\n        address _underlyingToken,\n        uint256 _dailyManagementLimit,\n        bool _isUpdateDailyLimit,\n        address _refundee,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable onlyOwner {\n        // Encode CallData\n        bytes memory params = abi.encode(_portStrategy, _underlyingToken, _dailyManagementLimit, _isUpdateDailyLimit);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x06), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(\n            payable(_refundee), _refundee, _dstChainId, payload, _gParams\n        );\n    }\n\n    /**\n     * @notice Set the Core Branch Router and Bridge Agent.\n     * @param _refundee Receiver of any leftover execution gas upon reaching destination network.\n     * @param _coreBranchRouter Address of the Core Branch Router.\n     * @param _coreBranchBridgeAgent Address of the Core Branch Bridge Agent.\n     * @param _dstChainId Chain Id of the branch chain where the new Bridge Agent will be deployed.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function setCoreBranch(\n        address _refundee,\n        address _coreBranchRouter,\n        address _coreBranchBridgeAgent,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable {\n        // Check caller is root port\n        require(msg.sender == rootPortAddress, \"Only root port can call\");\n\n        // Encode CallData\n        bytes memory params = abi.encode(_coreBranchRouter, _coreBranchBridgeAgent);\n\n        // Pack funcId into data\n        bytes memory payload = abi.encodePacked(bytes1(0x07), params);\n\n        //Add new global token to branch chain\n        IBridgeAgent(bridgeAgentAddress).callOut{value:"
    }
  ]
}