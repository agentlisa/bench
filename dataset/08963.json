{
  "Title": "[M-02] withdrawForETH could be used to drain the WETH in RubiconRouter.sol",
  "Content": "# Lines of code\n\n[RubiconRouter.sol#L475-L492](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L475-L492)\n\n\n# Vulnerability details\n\n## Impact\n\nIn the ```withdrawForETH``` function in ```RubiconRouter.sol```, the ```targetPool``` may be any contract that implements the ```IBathToken``` interface and returns ```wethAddress``` as its underlying token. The ```withdrawnWETH``` amount could be set to the ```RubiconRouter.sol``` contract's WETH balance so that the contract's entire WETH balance is withdrawn, as long as the ```tagetPool``` does not transfer any WETH to ```RubiconRouter.sol```. The caller of the ```withdrawForETH``` function would then receive the withdraw amount.\n\n## Proof of Concept\n\n```\n    function withdrawForETH(uint256 shares, address targetPool)\n        external\n        payable\n        returns (uint256 withdrawnWETH)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(\n            IBathToken(targetPool).balanceOf(msg.sender) >= shares,\n            \"don't own enough shares\"\n        );\n        IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);\n        withdrawnWETH = IBathToken(targetPool).withdraw(shares);\n        WETH9(wethAddress).withdraw(withdrawnWETH);\n\n        //Send back withdrawn native eth to sender\n        msg.sender.transfer(withdrawnWETH);\n    }\n```\n\n1. Let ```shares``` be equal to the contracts WETH balance.\n\n2. The malicious ```targetPool``` contract returns the ```wethAddress``` as the underlying token on [line 480](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L480). \n\n3. ```targetPool``` returns the max uint256 value for its balanceOf function to pass the require condition on [line 483](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L483) for any value of shares.\n\n4. The transferFrom on [line 486](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L486) does not have to do anything and its withdraw function should return the WETH balance of ```RubiconRouter.sol```.\n\n5. The ```RubiconRouter.sol``` contract will then [withdraw ETH](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L488) equal to the ```withdrawWETH``` amount, which should be equal to the contract's WETH balance.\n\n6. The caller of the ```withdrawForETH``` function receives the withdraw ETH without providing any WETH.\n\n\n## Recommended Mitigation Steps:\n\nCheck the contract's WETH balance before the caller is supposed to send the WETH and after the WETH is sent to confirm the contract has received enough WETH from the caller.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-rubicon-contest",
  "Code": [
    {
      "filename": "contracts/RubiconRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Benjamin Hughes - Rubicon\n/// @notice This contract is a router to interact with the low-level functions present in RubiconMarket and Pools\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./RubiconMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./peripheral_contracts/WETH9.sol\"; // @unsupported: ovm\nimport \"./interfaces/IBathToken.sol\";\n\n///@dev this contract is a high-level router that utilizes Rubicon smart contracts to provide\n///@dev added convenience and functionality when interacting with the Rubicon protocol\ncontract RubiconRouter {\n    using SafeMath for uint256;\n\n    address public RubiconMarketAddress;\n\n    address payable public wethAddress;\n\n    bool public started;\n\n    event LogNote(string, uint256);\n\n    event LogSwap(\n        uint256 inputAmount,\n        address inputERC20,\n        uint256 hurdleBuyAmtMin,\n        address targetERC20,\n        bytes32 indexed pair,\n        uint256 realizedFill,\n        address recipient\n    );\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function startErUp(address _theTrap, address payable _weth) external {\n        require(!started);\n        RubiconMarketAddress = _theTrap;\n        wethAddress = _weth;\n        started = true;\n    }\n\n    /// @notice Get the outstanding best N orders from both sides of the order book for a given pair\n    /// @dev The asset/quote pair ordering will affect return values - asset should be the top of the pair: for example, (ETH, USDC, 10) will return (10 best ETH asks, 10 best USDC bids, 10)\n    /// @param asset the ERC20 token that represents the ask/sell side of the order book\n    /// @param quote the ERC20 token that represents the bid/buy side of the order book\n    /// @param topNOrders the depth of the order book the caller would like to query/view for the asset-quote pair\n    /// @dev \"best\" orders are determined by proximity to the midpoint of the pair. Closest to the midpoint is best order.\n    /// @return Fixed arrays (of topNOrders length) in \"best\" order (returned asks/bids[0] is best and asks/bids[topNOrders] is worst) of asks and bids + topNOrders. Each offer array item is: [pay, buy, offerId]\n    function getBookFromPair(\n        ERC20 asset,\n        ERC20 quote,\n        uint256 topNOrders\n    )\n        public\n        view\n        returns (\n            uint256[3][] memory,\n            uint256[3][] memory,\n            uint256\n        )\n    {\n        uint256[3][] memory asks = new uint256[3][](topNOrders);\n        uint256[3][] memory bids = new uint256[3][](topNOrders);\n        address _RubiconMarketAddress = RubiconMarketAddress;\n\n        //1. Get best offer for each asset\n        uint256 bestAskID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            asset,\n            quote\n        );\n        uint256 bestBidID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            quote,\n            asset\n        );\n\n        uint256 lastBid = 0;\n        uint256 lastAsk = 0;\n        //2. Iterate from that offer down the book until topNOrders\n        for (uint256 index = 0; index < topNOrders; index++) {\n            if (index == 0) {\n                lastAsk = bestAskID;\n                lastBid = bestBidID;\n\n                (\n                    uint256 _ask_pay_amt,\n                    ,\n                    uint256 _ask_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestAskID);\n                (\n                    uint256 _bid_pay_amt,\n                    ,\n                    uint256 _bid_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestBidID);\n                asks[index] = [_ask_pay_amt, _ask_buy_amt, bestAskID];\n                bids[index] = [_bid_pay_amt, _bid_buy_amt, bestBidID];\n                continue;\n            }\n            uint256 nextBestAsk = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastAsk);\n            uint256 nextBestBid = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastBid);\n            (uint256 ask_pay_amt, , uint256 ask_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestAsk);\n            (uint256 bid_pay_amt, , uint256 bid_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestBid);\n\n            asks[index] = [ask_pay_amt, ask_buy_amt, nextBestAsk];\n            bids[index] = [bid_pay_amt, bid_buy_amt, nextBestBid];\n            // bids[index] = nextBestBid;\n            lastBid = nextBestBid;\n            lastAsk = nextBestAsk;\n        }\n\n        //3. Return those topNOrders for either side of the order book\n        return (asks, bids, topNOrders);\n    }\n\n    /// @dev this function returns the best offer for a pair's id and info\n    function getBestOfferAndInfo(address asset, address quote)\n        public\n        view\n        returns (\n            uint256, //id\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        address _market = RubiconMarketAddress;\n        uint256 offer = RubiconMarket(_market).getBestOffer(\n            ERC20(asset),\n            ERC20(quote)\n        );\n        (\n            uint256 pay_amt,\n            ERC20 pay_gem,\n            uint256 buy_amt,\n            ERC20 buy_gem\n        ) = RubiconMarket(_market).getOffer(offer);\n        return (offer, pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // function for infinite approvals of Rubicon Market\n    function approveAssetOnMarket(address toApprove) public {\n        // Approve exchange\n        ERC20(toApprove).approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @dev this function takes the same parameters of swap and returns the expected amount\n    function getExpectedSwapFill(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public view returns (uint256 fill_amt) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            uint256 wouldBeFillAmount = RubiconMarket(_market).getBuyAmount(\n                ERC20(output),\n                ERC20(input),\n                _pay\n            );\n            currentAmount = wouldBeFillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // Return the wouldbe resulting swap amount\n        return (currentAmount);\n    }\n\n    /// @dev This function lets a user swap from route[0] -> route[last] at some minimum expected rate\n    /// @dev pay_amt - amount to be swapped away from msg.sender of *first address in path*\n    /// @dev buy_amt_min - target minimum received of *last address in path*\n    function swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public returns (uint256) {\n        //**User must approve this contract first**\n        //transfer needed amount here first\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000)) // Account for expected fee\n        );\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    // Internal function requires that ERC20s are here before execution\n    function _swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS,\n        address to // Recipient of swap outputs!\n    ) internal returns (uint256) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            if (ERC20(input).allowance(address(this), _market) == 0) {\n                approveAssetOnMarket(input);\n            }\n            uint256 fillAmount = RubiconMarket(_market).sellAllAmount(\n                ERC20(input),\n                _pay,\n                ERC20(output),\n                0 //naively assume no fill_amt here for loop purposes?\n            );\n            currentAmount = fillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // send tokens back to sender if not keeping here\n        if (to != address(this)) {\n            ERC20(route[route.length - 1]).transfer(to, currentAmount);\n        }\n\n        emit LogSwap(\n            pay_amt,\n            route[0],\n            buy_amt_min,\n            route[route.length - 1],\n            keccak256(abi.encodePacked(route[0], route[route.length - 1])),\n            currentAmount,\n            to\n        );\n        return currentAmount;\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function swapEntireBalance(\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external returns (uint256) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(route[0]).balanceOf(msg.sender);\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            maxAmount // Account for expected fee\n        );\n        return\n            _swap(\n                maxAmount,\n                maxAmount.sub(buy_amt_min.mul(expectedMarketFeeBPS).div(10000)), //account for fee\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxBuyAllAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender's entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            maxAmount,\n            pay_gem,\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxSellAllAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(\n            pay_gem,\n            maxAmount,\n            buy_gem,\n            min_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    // ** Native ETH Wrapper Functions **\n    /// @dev WETH wrapper functions to obfuscate WETH complexities from ETH holders\n    function buyAllAmountWithETH(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        uint256 max_fill_amount,\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        address _weth = address(wethAddress);\n        uint256 _before = ERC20(_weth).balanceOf(address(this));\n        uint256 max_fill_withFee = max_fill_amount.add(\n            max_fill_amount.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= max_fill_withFee,\n            \"must send as much ETH as max_fill_withFee\"\n        );\n        WETH9(wethAddress).deposit{value: max_fill_withFee}(); // Pay with native ETH -> WETH\n        // An amount in WETH\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, buy_amt);\n\n        uint256 _after = ERC20(_weth).balanceOf(address(this));\n        uint256 delta = _after - _before;\n\n        // Return unspent coins to sender\n        if (delta > 0) {\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n    }\n\n    // Paying ERC20 to buy native ETH\n    function buyAllAmountForETH(\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), max_fill_amount); //transfer pay here\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            ERC20(wethAddress),\n            buy_amt,\n            pay_gem,\n            max_fill_amount\n        );\n        WETH9(wethAddress).withdraw(buy_amt); // Fill in WETH\n        msg.sender.transfer(buy_amt); // Return native ETH\n        // Return unspent coins to sender\n        if (max_fill_amount > fill) {\n            ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);\n        }\n        return fill;\n    }\n\n    // Pay in native ETH\n    function offerWithETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        // ERC20 nativeETH, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external payable returns (uint256) {\n        require(\n            msg.value >= pay_amt,\n            \"didnt send enough native ETH for WETH offer\"\n        );\n        uint256 _before = ERC20(buy_gem).balanceOf(address(this));\n        WETH9(wethAddress).deposit{value: pay_amt}();\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            ERC20(wethAddress),\n            buy_amt,\n            buy_gem,\n            pos\n        );\n        uint256 _after = ERC20(buy_gem).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer\n            ERC20(buy_gem).transfer(msg.sender, _after - _before);\n        }\n        return id;\n    }\n\n    // Pay in native ETH\n    function offerForETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        // ERC20 nativeETH, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external returns (uint256) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n\n        uint256 _before = ERC20(wethAddress).balanceOf(address(this));\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            pos\n        );\n        uint256 _after = ERC20(wethAddress).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer as native ETH\n            uint256 delta = _after - _before;\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n        return id;\n    }\n\n    // Cancel an offer made in WETH\n    function cancelForETH(uint256 id) external returns (bool outcome) {\n        (uint256 pay_amt, ERC20 pay_gem, , ) = RubiconMarket(\n            RubiconMarketAddress\n        ).getOffer(id);\n        require(\n            address(pay_gem) == wethAddress,\n            \"trying to cancel a non WETH order\"\n        );\n        // Cancel order and receive WETH here in amount of pay_amt\n        outcome = RubiconMarket(RubiconMarketAddress).cancel(id);\n        WETH9(wethAddress).withdraw(pay_amt);\n        msg.sender.transfer(pay_amt);\n    }\n\n    // Deposit native ETH -> WETH pool\n    function depositWithETH(uint256 amount, address targetPool)\n        external\n        payable\n        returns (uint256 newShares)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(msg.value >= amount, \"didnt send enough eth\");\n\n        if (target.allowance(address(this), targetPool) == 0) {\n            target.approve(targetPool, amount);\n        }\n\n        WETH9(wethAddress).deposit{value: amount}();\n        newShares = IBathToken(targetPool).deposit(amount);\n        //Send back bathTokens to sender\n        ERC20(targetPool).transfer(msg.sender, newShares);\n    }\n\n    // Withdraw native ETH <- WETH pool\n    function withdrawForETH(uint256 shares, address targetPool)\n        external\n        payable\n        returns (uint256 withdrawnWETH)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(\n            IBathToken(targetPool).balanceOf(msg.sender) >= shares,\n            \"don't own enough shares\"\n        );\n        IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);\n        withdrawnWETH = IBathToken(targetPool).withdraw(shares);\n        WETH9(wethAddress).withdraw(withdrawnWETH);\n\n        //Send back withdrawn native eth to sender\n        msg.sender.transfer(withdrawnWETH);\n    }\n\n    function swapWithETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256) {\n        require(route[0] == wethAddress, \"Initial value in path not WETH\");\n        uint256 amtWithFee = pay_amt.add(\n            pay_amt.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= amtWithFee,\n            \"must send enough native ETH to pay as weth and account for fee\"\n        );\n        WETH9(wethAddress).deposit{value: amtWithFee}();\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    function swapForETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        require(\n            route[route.length - 1] == wethAddress,\n            \"target of swap is not WETH\"\n        );\n        //Transfer tokens here first and account for fee\n        require(\n            ERC20(route[0]).transferFrom(\n                msg.sender,\n                address(this),\n                pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000))\n            ),\n            \"initial ERC20 transfer failed\"\n        );\n        fill = _swap(\n            pay_amt,\n            buy_amt_min,\n            route,\n            expectedMarketFeeBPS,\n            address(this)\n        );\n\n        WETH9(wethAddress).withdraw(fill);\n        // msg.sender.transfer(fill);\n        msg.sender.transfer(fill);\n    }\n}"
    }
  ]
}