{
  "Title": "[G-05] Alter some struct's fields datatype to improve packing",
  "Content": "\n**Files:** `Messaging.sol`, `BaseZkSyncUpgrade.sol`, `IExecutor.sol`\n\n[File: code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L28)\n```solidity\n28: struct ProposedUpgrade {\n29:     L2CanonicalTransaction l2ProtocolUpgradeTx;\n30:     bytes[] factoryDeps;\n31:     bytes32 bootloaderHash;\n32:     bytes32 defaultAccountHash;\n33:     address verifier;\n34:     VerifierParams verifierParams;\n35:     bytes l1ContractsUpgradeCalldata;\n36:     bytes postUpgradeCalldata;\n37:     uint256 upgradeTimestamp;\n38:     uint256 newProtocolVersion;\n39: }\n```\n`newProtocolVersion` is being increases every time upgrade is made. `upgradeTimestamp` contains the timestamp of the upgrade. Both these fields can be `uint128` (instead of `uint256`) to fit into one slot.\n\n[File: code/contracts/ethereum/contracts/common/Messaging.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/Messaging.sol#L098)\n```solidity\n098: struct L2CanonicalTransaction {\n099:     uint256 txType;\n100:     uint256 from;\n101:     uint256 to;\n102:     uint256 gasLimit;\n103:     uint256 gasPerPubdataByteLimit;\n104:     uint256 maxFeePerGas;\n105:     uint256 maxPriorityFeePerGas;\n106:     uint256 paymaster;\n107:     uint256 nonce;\n108:     uint256 value;\n```\n\nBoth `nonce` and `txType` fields can be `uint128 ` to fit into single slot.\nBoth `gasLimit` and `gasPerPubdataByteLimit` can be `uint128` to fit into single slot.\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-interfaces/IExecutor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-interfaces/IExecutor.sol#L83)\n```solidity\n83:     struct StoredBatchInfo {\n84:         uint64 batchNumber;\n85:         bytes32 batchHash;\n86:         uint64 indexRepeatedStorageChanges; \n87:         uint256 numberOfLayer1Txs;\n88:         bytes32 priorityOperationsHash;\n89:         bytes32 l2LogsTreeRoot;\n90:         uint256 timestamp;\n91:         bytes32 commitment;\n92:     }\n```\n`timestamp` field can be `uint64`. Then, it can be moved after `batchNumber` to fit a single slot (`uint64` + `uint64`).\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ZkSyncStateTransitionBase} from \"../state-transition/chain-deps/facets/ZkSyncStateTransitionBase.sol\";\nimport {IMailbox} from \"../state-transition/chain-interfaces/IMailbox.sol\";\nimport {VerifierParams} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {IVerifier} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {L2ContractHelper} from \"../common/libraries/L2ContractHelper.sol\";\nimport {TransactionValidator} from \"../state-transition/libraries/TransactionValidator.sol\";\nimport {MAX_NEW_FACTORY_DEPS, SYSTEM_UPGRADE_L2_TX_TYPE, MAX_ALLOWED_PROTOCOL_VERSION_DELTA} from \"../common/Config.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\n\n/// @notice The struct that represents the upgrade proposal.\n/// @param l2ProtocolUpgradeTx The system upgrade transaction.\n/// @param factoryDeps The list of factory deps for the l2ProtocolUpgradeTx.\n/// @param bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n/// @param defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n/// @param verifier The address of the new verifier. If zero, the verifier will not be updated.\n/// @param verifierParams The new verifier params. If all of its fields are 0, the params will not be updated.\n/// @param l1ContractsUpgradeCalldata Custom calldata for L1 contracts upgrade, it may be interpreted differently\n/// in each upgrade. Usually empty.\n/// @param postUpgradeCalldata Custom calldata for post upgrade hook, it may be interpreted differently in each\n/// upgrade. Usually empty.\n/// @param upgradeTimestamp The timestamp after which the upgrade can be executed.\n/// @param newProtocolVersion The new version number for the protocol after this upgrade. Should be greater than\n/// the previous protocol version.\nstruct ProposedUpgrade {\n    L2CanonicalTransaction l2ProtocolUpgradeTx;\n    bytes[] factoryDeps;\n    bytes32 bootloaderHash;\n    bytes32 defaultAccountHash;\n    address verifier;\n    VerifierParams verifierParams;\n    bytes l1ContractsUpgradeCalldata;\n    bytes postUpgradeCalldata;\n    uint256 upgradeTimestamp;\n    uint256 newProtocolVersion;\n}\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Interface to which all the upgrade implementations should adhere\nabstract contract BaseZkSyncUpgrade is ZkSyncStateTransitionBase {\n    /// @notice Changes the protocol version\n    event NewProtocolVersion(uint256 indexed previousProtocolVersion, uint256 indexed newProtocolVersion);\n\n    /// @notice Сhanges to the bytecode that is used in L2 as a bootloader (start program)\n    event NewL2BootloaderBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Сhanges to the bytecode that is used in L2 as a default account\n    event NewL2DefaultAccountBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Verifier address changed\n    event NewVerifier(address indexed oldVerifier, address indexed newVerifier);\n\n    /// @notice Verifier parameters changed\n    event NewVerifierParams(VerifierParams oldVerifierParams, VerifierParams newVerifierParams);\n\n    /// @notice Notifies about complete upgrade\n    event UpgradeComplete(uint256 indexed newProtocolVersion, bytes32 indexed l2UpgradeTxHash, ProposedUpgrade upgrade);\n\n    /// @notice The main function that will be provided by the upgrade proxy\n    /// @dev This is a virtual function and should be overridden by custom upgrade implementations.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    /// @return txHash The hash of the L2 system contract upgrade transaction.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual returns (bytes32 txHash) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occurred. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n\n        _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash);\n\n        txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n    }\n\n    /// @notice Change default account bytecode hash, that is used on L2\n    /// @param _l2DefaultAccountBytecodeHash The hash of default account L2 bytecode\n    function _setL2DefaultAccountBytecodeHash(bytes32 _l2DefaultAccountBytecodeHash) private {\n        if (_l2DefaultAccountBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2DefaultAccountBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousDefaultAccountBytecodeHash = s.l2DefaultAccountBytecodeHash;\n\n        // Change the default account bytecode hash\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n        emit NewL2DefaultAccountBytecodeHash(previousDefaultAccountBytecodeHash, _l2DefaultAccountBytecodeHash);\n    }\n\n    /// @notice Change bootloader bytecode hash, that is used on L2\n    /// @param _l2BootloaderBytecodeHash The hash of bootloader L2 bytecode\n    function _setL2BootloaderBytecodeHash(bytes32 _l2BootloaderBytecodeHash) private {\n        if (_l2BootloaderBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2BootloaderBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousBootloaderBytecodeHash = s.l2BootloaderBytecodeHash;\n\n        // Change the bootloader bytecode hash\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        emit NewL2BootloaderBytecodeHash(previousBootloaderBytecodeHash, _l2BootloaderBytecodeHash);\n    }\n\n    /// @notice Change the address of the verifier smart contract\n    /// @param _newVerifier Verifier smart contract address\n    function _setVerifier(IVerifier _newVerifier) private {\n        // An upgrade to the verifier must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier will fail. Ensure all commited batches are finalized before the\n        // verifier is upgraded.\n        if (_newVerifier == IVerifier(address(0))) {\n            return;\n        }\n\n        IVerifier oldVerifier = s.verifier;\n        s.verifier = _newVerifier;\n        emit NewVerifier(address(oldVerifier), address(_newVerifier));\n    }\n\n    /// @notice Change the verifier parameters\n    /// @param _newVerifierParams New parameters for the verifier\n    function _setVerifierParams(VerifierParams calldata _newVerifierParams) private {\n        // An upgrade to the verifier params must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier params will fail. Ensure all commited batches are finalized before the\n        // verifier is upgraded.\n        if (\n            _newVerifierParams.recursionNodeLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionLeafLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionCircuitsSetVksHash == bytes32(0)\n        ) {\n            return;\n        }\n\n        VerifierParams memory oldVerifierParams = s.verifierParams;\n        s.verifierParams = _newVerifierParams;\n        emit NewVerifierParams(oldVerifierParams, _newVerifierParams);\n    }\n\n    /// @notice Updates the verifier and the verifier params\n    /// @param _newVerifier The address of the new verifier. If 0, the verifier will not be updated.\n    /// @param _verifierParams The new verifier params. If all of the fields are 0, the params will not be updated.\n    function _upgradeVerifier(address _newVerifier, VerifierParams calldata _verifierParams) internal {\n        _setVerifier(IVerifier(_newVerifier));\n        _setVerifierParams(_verifierParams);\n    }\n\n    /// @notice Updates the bootloader hash and the hash of the default account\n    /// @param _bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n    /// @param _defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n    function _setBaseSystemContracts(bytes32 _bootloaderHash, bytes32 _defaultAccountHash) internal {\n        _setL2BootloaderBytecodeHash(_bootloaderHash);\n        _setL2DefaultAccountBytecodeHash(_defaultAccountHash);\n    }\n\n    /// @notice Sets the hash of the L2 system contract upgrade transaction for the next batch to be committed\n    /// @dev If the transaction is noop (i.e. its type is 0) it does nothing and returns 0.\n    /// @param _l2ProtocolUpgradeTx The L2 system contract upgrade transaction.\n    /// @return System contracts upgrade transaction hash. Zero if no upgrade transaction is set.\n    function _setL2SystemContractUpgrade(\n        L2CanonicalTransaction calldata _l2ProtocolUpgradeTx,\n        bytes[] calldata _factoryDeps,\n        uint256 _newProtocolVersion\n    ) internal returns (bytes32) {\n        // If the type is 0, it is considered as noop and so will not be required to be executed.\n        if (_l2ProtocolUpgradeTx.txType == 0) {\n            return bytes32(0);\n        }\n\n        require(_l2ProtocolUpgradeTx.txType == SYSTEM_UPGRADE_L2_TX_TYPE, \"L2 system upgrade tx type is wrong\");\n\n        bytes memory encodedTransaction = abi.encode(_l2ProtocolUpgradeTx);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            _l2ProtocolUpgradeTx,\n            encodedTransaction,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        TransactionValidator.validateUpgradeTransaction(_l2ProtocolUpgradeTx);\n\n        // We want the hashes of l2 system upgrade transactions to be unique.\n        // This is why we require that the `nonce` field is unique to each upgrade.\n        require(\n            _l2ProtocolUpgradeTx.nonce == _newProtocolVersion,\n            \"The new protocol version should be included in the L2 system upgrade tx\"\n        );\n\n        _verifyFactoryDeps(_factoryDeps, _l2ProtocolUpgradeTx.factoryDeps);\n\n        bytes32 l2ProtocolUpgradeTxHash = keccak256(encodedTransaction);\n\n        s.l2SystemContractsUpgradeTxHash = l2ProtocolUpgradeTxHash;\n\n        return l2ProtocolUpgradeTxHash;\n    }\n\n    /// @notice Verifies that the factory deps correspond to the proper hashes\n    /// @param _factoryDeps The list of factory deps\n    /// @param _expectedHashes The list of expected bytecode hashes\n    function _verifyFactoryDeps(bytes[] calldata _factoryDeps, uint256[] calldata _expectedHashes) private pure {\n        require(_factoryDeps.length == _expectedHashes.length, \"Wrong number of factory deps\");\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"Factory deps can be at most 32\");\n\n        for (uint256 i = 0; i < _factoryDeps.length; ++i) {\n            require(\n                L2ContractHelper.hashL2Bytecode(_factoryDeps[i]) == bytes32(_expectedHashes[i]),\n                \"Wrong factory dep hash\"\n            );\n        }\n    }\n\n    /// @notice Changes the protocol version\n    /// @param _newProtocolVersion The new protocol version\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal virtual {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            _newProtocolVersion > previousProtocolVersion,\n            \"New protocol version is not greater than the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        // Note it is important to keep this check, as otherwise hyperchains might skip upgrades by overwriting\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n\n    /// @notice Placeholder function for custom logic for upgrading L1 contract.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _upgradeL1Contract(bytes calldata _customCallDataForUpgrade) internal virtual {}\n\n    /// @notice placeholder function for custom logic for post-upgrade logic.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _postUpgrade(bytes calldata _customCallDataForUpgrade) internal virtual {}\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/common/Messaging.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\n/// @dev The enum that represents the transaction execution status\n/// @param Failure The transaction execution failed\n/// @param Success The transaction execution succeeded\nenum TxStatus {\n    Failure,\n    Success\n}\n\n/// @dev The log passed from L2\n/// @param l2ShardId The shard identifier, 0 - rollup, 1 - porter\n/// All other values are not used but are reserved for the future\n/// @param isService A boolean flag that is part of the log along with `key`, `value`, and `sender` address.\n/// This field is required formally but does not have any special meaning\n/// @param txNumberInBatch The L2 transaction number in a Batch, in which the log was sent\n/// @param sender The L2 address which sent the log\n/// @param key The 32 bytes of information that was sent in the log\n/// @param value The 32 bytes of information that was sent in the log\n// Both `key` and `value` are arbitrary 32-bytes selected by the log sender\nstruct L2Log {\n    uint8 l2ShardId;\n    bool isService;\n    uint16 txNumberInBatch;\n    address sender;\n    bytes32 key;\n    bytes32 value;\n}\n\n/// @dev An arbitrary length message passed from L2\n/// @notice Under the hood it is `L2Log` sent from the special system L2 contract\n/// @param txNumberInBatch The L2 transaction number in a Batch, in which the message was sent\n/// @param sender The address of the L2 account from which the message was passed\n/// @param data An arbitrary length message\nstruct L2Message {\n    uint16 txNumberInBatch;\n    address sender;\n    bytes data;\n}\n\n/// @dev Internal structure that contains the parameters for the writePriorityOp\n/// internal function.\n/// @param sender The sender's address.\n/// @param txId The id of the priority transaction.\n/// @param l2Value The msg.value of the L2 transaction.\n/// @param contractAddressL2 The address of the contract on L2 to call.\n/// @param expirationTimestamp The timestamp by which the priority operation must be processed by the operator.\n/// @param l2GasLimit The limit of the L2 gas for the L2 transaction\n/// @param l2GasPricePerPubdata The price for a single pubdata byte in L2 gas.\n/// @param valueToMint The amount of ether that should be minted on L2 as the result of this transaction.\n/// @param refundRecipient The recipient of the refund for the transaction on L2. If the transaction fails, then\n/// this address will receive the `l2Value`.\nstruct WritePriorityOpParams {\n    address sender;\n    uint256 txId;\n    uint256 l2Value;\n    address contractAddressL2;\n    uint64 expirationTimestamp;\n    uint256 l2GasLimit;\n    uint256 l2GasPrice;\n    uint256 l2GasPricePerPubdata;\n    uint256 valueToMint;\n    address refundRecipient;\n}\n\n/// @dev Structure that includes all fields of the L2 transaction\n/// @dev The hash of this structure is the \"canonical L2 transaction hash\" and can\n/// be used as a unique identifier of a tx\n/// @param txType The tx type number, depending on which the L2 transaction can be\n/// interpreted differently\n/// @param from The sender's address. `uint256` type for possible address format changes\n/// and maintaining backward compatibility\n/// @param to The recipient's address. `uint256` type for possible address format changes\n/// and maintaining backward compatibility\n/// @param gasLimit The L2 gas limit for L2 transaction. Analog to the `gasLimit` on an\n/// L1 transactions\n/// @param gasPerPubdataByteLimit Maximum number of L2 gas that will cost one byte of pubdata\n/// (every piece of data that will be stored on L1 as calldata)\n/// @param maxFeePerGas The absolute maximum sender willing to pay per unit of L2 gas to get\n/// the transaction included in a Batch. Analog to the EIP-1559 `maxFeePerGas` on an L1 transactions\n/// @param maxPriorityFeePerGas The additional fee that is paid directly to the validator\n/// to incentivize them to include the transaction in a Batch. Analog to the EIP-1559\n/// `maxPriorityFeePerGas` on an L1 transactions\n/// @param paymaster The address of the EIP-4337 paymaster, that will pay fees for the\n/// transaction. `uint256` type for possible address format changes and maintaining backward compatibility\n/// @param nonce The nonce of the transaction. For L1->L2 transactions it is the priority\n/// operation Id\n/// @param value The value to pass with the transaction\n/// @param reserved The fixed-length fields for usage in a future extension of transaction\n/// formats\n/// @param data The calldata that is transmitted for the transaction call\n/// @param signature An abstract set of bytes that are used for transaction authorization\n/// @param factoryDeps The set of L2 bytecode hashes whose preimages were shown on L1\n/// @param paymasterInput The arbitrary-length data that is used as a calldata to the paymaster pre-call\n/// @param reservedDynamic The arbitrary-length field for usage in a future extension of transaction formats\nstruct L2CanonicalTransaction {\n    uint256 txType;\n    uint256 from;\n    uint256 to;\n    uint256 gasLimit;\n    uint256 gasPerPubdataByteLimit;\n    uint256 maxFeePerGas;\n    uint256 maxPriorityFeePerGas;\n    uint256 paymaster;\n    uint256 nonce;\n    uint256 value;\n    // In the future, we might want to add some\n    // new fields to the struct. The `txData` struct\n    // is to be passed to account and any changes to its structure\n    // would mean a breaking change to these accounts. To prevent this,\n    // we should keep some fields as \"reserved\"\n    // It is also recommended that their length is fixed, since\n    // it would allow easier proof integration (in case we will need\n    // some special circuit for preprocessing transactions)\n    uint256[4] reserved;\n    bytes data;\n    bytes signature;\n    uint256[] factoryDeps;\n    bytes paymasterInput;\n    // Reserved dynamic type for the future use-case. Using it should be avoided,\n    // But it is still here, just in case we want to enable some additional functionality\n    bytes reservedDynamic;\n}\n\nstruct BridgehubL2TransactionRequest {\n    address sender;\n    address contractL2;\n    uint256 mintValue;\n    uint256 l2Value;\n    bytes l2Calldata;\n    uint256 l2GasLimit;\n    uint256 l2GasPerPubdataByteLimit;\n    bytes[] factoryDeps;\n    address refundRecipient;\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-interfaces/IExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IZkSyncStateTransitionBase} from \"./IZkSyncStateTransitionBase.sol\";\n\n/// @dev Enum used by L2 System Contracts to differentiate logs.\nenum SystemLogKey {\n    L2_TO_L1_LOGS_TREE_ROOT_KEY,\n    TOTAL_L2_TO_L1_PUBDATA_KEY,\n    STATE_DIFF_HASH_KEY,\n    PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY,\n    PREV_BATCH_HASH_KEY,\n    CHAINED_PRIORITY_TXN_HASH_KEY,\n    NUMBER_OF_LAYER_1_TXS_KEY,\n    BLOB_ONE_HASH_KEY,\n    BLOB_TWO_HASH_KEY,\n    EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY\n}\n\n/// @dev Enum used to determine the source of pubdata. At first we will support calldata and blobs but this can be extended.\nenum PubdataSource {\n    Calldata,\n    Blob\n}\n\nstruct LogProcessingOutput {\n    uint256 numberOfLayer1Txs;\n    bytes32 chainedPriorityTxsHash;\n    bytes32 previousBatchHash;\n    bytes32 pubdataHash;\n    bytes32 stateDiffHash;\n    bytes32 l2LogsTreeRoot;\n    uint256 packedBatchAndL2BlockTimestamp;\n    bytes32 blob1Hash;\n    bytes32 blob2Hash;\n}\n\n/// @dev Offset used to pull Address From Log. Equal to 4 (bytes for isService)\nuint256 constant L2_LOG_ADDRESS_OFFSET = 4;\n\n/// @dev Offset used to pull Key From Log. Equal to 4 (bytes for isService) + 20 (bytes for address)\nuint256 constant L2_LOG_KEY_OFFSET = 24;\n\n/// @dev Offset used to pull Value From Log. Equal to 4 (bytes for isService) + 20 (bytes for address) + 32 (bytes for key)\nuint256 constant L2_LOG_VALUE_OFFSET = 56;\n\n/// @dev BLS Modulus value defined in EIP-4844 and the magic value returned from a successful call to the\n/// point evaluation precompile\nuint256 constant BLS_MODULUS = 52435875175126190479447740508185965837690552500527637822603658699938581184513;\n\n/// @dev Packed pubdata commitments.\n/// @dev Format: list of: opening point (16 bytes) || claimed value (32 bytes) || commitment (48 bytes) || proof (48 bytes)) = 144 bytes\nuint256 constant PUBDATA_COMMITMENT_SIZE = 144;\n\n/// @dev Offset in pubdata commitment of blobs for claimed value\nuint256 constant PUBDATA_COMMITMENT_CLAIMED_VALUE_OFFSET = 16;\n\n/// @dev Offset in pubdata commitment of blobs for kzg commitment\nuint256 constant PUBDATA_COMMITMENT_COMMITMENT_OFFSET = 48;\n\n/// @dev Max number of blobs currently supported\nuint256 constant MAX_NUMBER_OF_BLOBS = 2;\n\n/// @dev The number of blobs that must be present in the commitment to a batch.\n/// It represents the maximal number of blobs that circuits can support and can be larger\n/// than the maximal number of blobs supported by the contract (`MAX_NUMBER_OF_BLOBS`).\nuint256 constant TOTAL_BLOBS_IN_COMMITMENT = 16;\n\n/// @title The interface of the zkSync Executor contract capable of processing events emitted in the zkSync protocol.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IExecutor is IZkSyncStateTransitionBase {\n    /// @notice Rollup batch stored data\n    /// @param batchNumber Rollup batch number\n    /// @param batchHash Hash of L2 batch\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this batch\n    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this batch\n    /// @param timestamp Rollup batch timestamp, have the same format as Ethereum batch constant\n    /// @param commitment Verified input for the zkSync circuit\n    struct StoredBatchInfo {\n        uint64 batchNumber;\n        bytes32 batchHash;\n        uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n\n    /// @notice Data needed to commit new batch\n    /// @param batchNumber Number of the committed batch\n    /// @param timestamp Unix timestamp denoting the start of the batch execution\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param newStateRoot The state root of the full state tree\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this batch\n    /// @param bootloaderHeapInitialContentsHash Hash of the initial contents of the bootloader heap. In practice it serves as the commitment to the transactions in the batch.\n    /// @param eventsQueueStateHash Hash of the events queue state. In practice it serves as the commitment to the events in the batch.\n    /// @param systemLogs concatenation of all L2 -> L1 system logs in the batch\n    /// @param pubdataCommitments Packed pubdata commitments/data.\n    /// @dev pubdataCommitments format: This will always start with a 1 byte pubdataSource flag. Current allowed values are 0 (calldata) or 1 (blobs)\n    ///                             kzg: list of: opening point (16 bytes) || claimed value (32 bytes) || commitment (48 bytes) || proof (48 bytes) = 144 bytes\n    ///                             calldata: pubdataCommitments.length - 1 - 32 bytes of pubdata\n    ///                                       and 32 bytes appended to serve as the blob commitment part for the aux output part of the batch commitment\n    /// @dev For 2 blobs we will be sending 288 bytes of calldata instead of the full amount for pubdata.\n    /// @dev When using calldata, we only need to send one blob commitment since the max number of bytes in calldata fits in a single blob and we can pull the\n    ///     linear hash from the system logs\n    struct CommitBatchInfo {\n        uint64 batchNumber;\n        uint64 timestamp;\n        uint64 indexRepeatedStorageChanges;\n        bytes32 newStateRoot;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 bootloaderHeapInitialContentsHash;\n        bytes32 eventsQueueStateHash;\n        bytes systemLogs;\n        bytes pubdataCommitments;\n    }\n\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\n    struct ProofInput {\n        uint256[] recursiveAggregationInput;\n        uint256[] serializedProof;\n    }\n\n    /// @notice Function called by the operator to commit new batches. It is responsible for:\n    /// - Verifying the correctness of their timestamps.\n    /// - Processing their L2->L1 logs.\n    /// - Storing batch commitments.\n    /// @param _lastCommittedBatchData Stored data of the last committed batch.\n    /// @param _newBatchesData Data of the new batches to be committed.\n    function commitBatches(\n        StoredBatchInfo calldata _lastCommittedBatchData,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) external;\n\n    /// @notice same as `commitBatches` but with the chainId so ValidatorTimelock can sort the inputs.\n    function commitBatchesSharedBridge(\n        uint256 _chainId,\n        StoredBatchInfo calldata _lastCommittedBatchData,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) external;\n\n    /// @notice Batches commitment verification.\n    /// @dev Only verifies batch commitments without any other processing.\n    /// @param _prevBatch Stored data of the last committed batch.\n    /// @param _committedBatches Stored data of the committed batches.\n    /// @param _proof The zero knowledge proof.\n    function proveBatches(\n        StoredBatchInfo calldata _prevBatch,\n        StoredBatchInfo[] calldata _committedBatches,\n        ProofInput calldata _proof\n    ) external;\n\n    /// @notice same as `proveBatches` but with the chainId so ValidatorTimelock can sort the inputs.\n    function proveBatchesSharedBridge(\n        uint256 _chainId,\n        StoredBatchInfo calldata _prevBatch,\n        StoredBatchInfo[] calldata _committedBatches,\n        ProofInput calldata _proof\n    ) external;\n\n    /// @notice The function called by the operator to finalize (execute) batches. It is responsible for:\n    /// - Processing all pending operations (commpleting priority requests).\n    /// - Finalizing this batch (i.e. allowing to withdraw funds from the system)\n    /// @param _batchesData Data of the batches to be executed.\n    function executeBatches(StoredBatchInfo[] calldata _batchesData) external;\n\n    /// @notice same as `executeBatches` but with the chainId so ValidatorTimelock can sort the inputs.\n    function executeBatchesSharedBridge(uint256 _chainId, StoredBatchInfo[] calldata _batchesData) external;\n\n    /// @notice Reverts unexecuted batches\n    /// @param _newLastBatch batch number after which batches should be reverted\n    /// NOTE: Doesn't delete the stored data about batches, but only decreases\n    /// counters that are responsible for the number of batches\n    function revertBatches(uint256 _newLastBatch) external;\n\n    /// @notice same as `revertBatches` but with the chainId so ValidatorTimelock can sort the inputs.\n    function revertBatchesSharedBridge(uint256 _chainId, uint256 _newLastBatch) external;\n\n    /// @notice Event emitted when a batch is committed\n    /// @param batchNumber Number of the batch committed\n    /// @param batchHash Hash of the L2 batch\n    /// @param commitment Calculated input for the zkSync circuit\n    /// @dev It has the name \"BlockCommit\" and not \"BatchCommit\" due to backward compatibility considerations\n    event BlockCommit(uint256 indexed batchNumber, bytes32 indexed batchHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when batches are verified\n    /// @param previousLastVerifiedBatch Batch number of the previous last verified batch\n    /// @param currentLastVerifiedBatch Batch number of the current last verified batch\n    /// @dev It has the name \"BlocksVerification\" and not \"BatchesVerification\" due to backward compatibility considerations\n    event BlocksVerification(uint256 indexed previousLastVerifiedBatch, uint256 indexed currentLastVerifiedBatch);\n\n    /// @notice Event emitted when a batch is executed\n    /// @param batchNumber Number of the batch executed\n    /// @param batchHash Hash of the L2 batch\n    /// @param commitment Verified input for the zkSync circuit\n    /// @dev It has the name \"BlockExecution\" and not \"BatchExecution\" due to backward compatibility considerations\n    event BlockExecution(uint256 indexed batchNumber, bytes32 indexed batchHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when batches are reverted\n    /// @param totalBatchesCommitted Total number of committed batches after the revert\n    /// @param totalBatchesVerified Total number of verified batches after the revert\n    /// @param totalBatchesExecuted Total number of executed batches\n    /// @dev It has the name \"BlocksRevert\" and not \"BatchesRevert\" due to backward compatibility considerations\n    event BlocksRevert(uint256 totalBatchesCommitted, uint256 totalBatchesVerified, uint256 totalBatchesExecuted);\n}"
    }
  ]
}