{
  "Title": "Incorrect event",
  "Content": "##### Description\nIn case of cover, `stETH` doesn't burn \nhttps://github.com/lidofinance/lido-dao/blob/801d3e854efb33ff33a59fe51187e187047a6be2/contracts/0.4.24/StETH.sol#L461\n##### Recommendation\nIt is necessary to exclude the `stETH` amount from the event.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/0.4.24/StETH.sol",
      "content": "// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.4.24;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"@aragon/os/contracts/common/UnstructuredStorage.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath.sol\";\nimport \"./lib/Pausable.sol\";\n\n/**\n * @title Interest-bearing ERC20-like token for Lido Liquid Stacking protocol.\n *\n * This contract is abstract. To make the contract deployable override the\n * `_getTotalPooledEther` function. `Lido.sol` contract inherits StETH and defines\n * the `_getTotalPooledEther` function.\n *\n * StETH balances are dynamic and represent the holder's share in the total amount\n * of Ether controlled by the protocol. Account shares aren't normalized, so the\n * contract also stores the sum of all shares to calculate each account's token balance\n * which equals to:\n *\n *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n *\n * For example, assume that we have:\n *\n *   _getTotalPooledEther() -> 10 ETH\n *   sharesOf(user1) -> 100\n *   sharesOf(user2) -> 400\n *\n * Therefore:\n *\n *   balanceOf(user1) -> 2 tokens which corresponds 2 ETH\n *   balanceOf(user2) -> 8 tokens which corresponds 8 ETH\n *\n * Since balances of all token holders change when the amount of total pooled Ether\n * changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\n * events upon explicit transfer between holders. In contrast, when total amount of\n * pooled Ether increases, no `Transfer` events are generated: doing so would require\n * emitting an event for each token holder and thus running an unbounded loop.\n *\n * The token inherits from `Pausable` and uses `whenNotStopped` modifier for methods\n * which change `shares` or `allowances`. `_stop` and `_resume` functions are overriden\n * in `Lido.sol` and might be called by an account with the `PAUSE_ROLE` assigned by the\n * DAO. This is useful for emergency scenarios, e.g. a protocol bug, where one might want\n * to freeze all token transfers and approvals until the emergency is resolved.\n */\ncontract StETH is IERC20, Pausable {\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren't\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account's token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it's non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION = keccak256(\"lido.StETH.totalShares\");\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed stETH burn event\n     *\n     * @dev Reports simultaneously stETH amount and shares amount.\n     * The stETH amount is calculated before the burning incurred rebase.\n     *\n     * @param account holder of the burnt stETH\n     * @param amount amount of burnt stETH\n     * @param sharesAmount amount of burnt shares\n     */\n    event StETHBurnt(\n        address indexed account,\n        uint256 amount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() public pure returns (string) {\n        return \"Liquid staked Ether 2.0\";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public pure returns (string) {\n        return \"stETH\";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() public view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) public view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) public returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller's\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) public returns (bool) {\n        uint256 currentAllowance = allowances[_sender][msg.sender];\n        require(currentAllowance >= _amount, \"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\");\n\n        _transfer(_sender, _recipient, _amount);\n        _approve(_sender, msg.sender, currentAllowance.sub(_amount));\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     * - the contract must not be paused.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     * - the contract must not be paused.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, \"DECREASED_ALLOWANCE_BELOW_ZERO\");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account's relative share.\n     */\n    function getTotalShares() public view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) public view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        uint256 totalPooledEther = _getTotalPooledEther();\n        if (totalPooledEther == 0) {\n            return 0;\n        } else {\n            return _ethAmount\n                .mul(_getTotalShares())\n                .div(totalPooledEther);\n        }\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        uint256 totalShares = _getTotalShares();\n        if (totalShares == 0) {\n            return 0;\n        } else {\n            return _sharesAmount\n                .mul(_getTotalPooledEther())\n                .div(totalShares);\n        }\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) public returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        emit TransferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        emit Transfer(msg.sender, _recipient, tokensAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calaulating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        emit Transfer(_sender, _recipient, _amount);\n        emit TransferShares(_sender, _recipient, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal whenNotStopped {\n        require(_owner != address(0), \"APPROVE_FROM_ZERO_ADDRESS\");\n        require(_spender != address(0), \"APPROVE_TO_ZERO_ADDRESS\");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address.\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal whenNotStopped {\n        require(_sender != address(0), \"TRANSFER_FROM_THE_ZERO_ADDRESS\");\n        require(_recipient != address(0), \"TRANSFER_TO_THE_ZERO_ADDRESS\");\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, \"TRANSFER_AMOUNT_EXCEEDS_BALANCE\");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn't increase the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal whenNotStopped returns (uint256 newTotalShares) {\n        require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we're not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn't change\n        // as the result. This is equivalent to performing a send from each other token holder's\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n     * @dev This doesn't decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal whenNotStopped returns (uint256 newTotalShares) {\n        require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, \"BURN_AMOUNT_EXCEEDS_BALANCE\");\n\n        uint256 amount = getPooledEthByShares(_sharesAmount);\n        emit StETHBurnt(_account, amount, _sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        // Notice: we're not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn't change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We're emitting StETHBurnt event to provide an explicit rebase log record nonetheless.\n    }\n}"
    }
  ]
}