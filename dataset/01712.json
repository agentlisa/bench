{
  "Title": "Locked BNB in Contract",
  "Content": "There are multiple occurrences in [`SwapRouter.sol`](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/SwapRouter.sol) where ETH can become locked. For instance:\n\n\n* [`swapExactTokensForBNBAndRepay`](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/SwapRouter.sol#L457)\n* [`swapExactTokensForBNBAndRepayAtSupportingFee`](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/SwapRouter.sol#L479)\n* [`swapTokensForExactBNBAndRepay`](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/SwapRouter.sol#L504)\n* [`swapTokensForFullBNBDebtAndRepay`](https://github.com/VenusProtocol/venus-protocol/blob/e5f112ac6f8cb9e5dcf760ad3626c9f3fc43609c/contracts/Swap/SwapRouter.sol#L525)\n\n\nConsider removing the `payable` attribute or adding a withdrawal feature.\n\n\n***Update:** Resolved in [pull request #281](https://github.com/VenusProtocol/venus-protocol/pull/281) at commit [7a8044a](https://github.com/VenusProtocol/venus-protocol/commit/7a8044ae4b5beb5c5f36eef011bc72a541030a43).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Swap/SwapRouter.sol",
      "content": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IPancakeSwapV2Router.sol\";\nimport \"./interfaces/IVtoken.sol\";\nimport \"./RouterHelper.sol\";\nimport \"./interfaces/IVBNB.sol\";\nimport \"./interfaces/IVtoken.sol\";\nimport \"./interfaces/InterfaceComptroller.sol\";\n\n/**\n * @title Venus's Pancake Swap Integration Contract\n * @notice This contracts allows users to swap a token for another one and supply/repay with the latter.\n * @dev For all functions that do not swap native BNB, user must approve this contract with the amount, prior the calling the swap function.\n * @author 0xlucian\n */\n\ncontract SwapRouter is Ownable2Step, RouterHelper, IPancakeSwapV2Router {\n    using SafeERC20 for IERC20;\n\n    address public immutable comptrollerAddress;\n\n    uint256 private constant _NOT_ENTERED = 1;\n\n    uint256 private constant _ENTERED = 2;\n\n    address public vBNBAddress;\n\n    /**\n     * @dev Guard variable for re-entrancy checks\n     */\n    uint256 internal _status;\n\n    // ***************\n    // ** MODIFIERS **\n    // ***************\n    modifier ensure(uint256 deadline) {\n        if (deadline < block.timestamp) {\n            revert SwapDeadlineExpire(deadline, block.timestamp);\n        }\n        _;\n    }\n\n    modifier ensurePath(address[] calldata path) {\n        if (path.length < 2) {\n            revert InvalidPath();\n        }\n        _;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        if (_status == _ENTERED) {\n            revert ReentrantCheck();\n        }\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    /// @notice event emitted on sweep token success\n    event SweepToken(address indexed token, address indexed to, uint256 sweepAmount);\n\n    /// @notice event emitted on vBNBAddress update\n    event VBNBAddressUpdated(address indexed oldAddress, address indexed newAddress);\n\n    // *********************\n    // **** CONSTRUCTOR ****\n    // *********************\n\n    /// @notice Constructor for the implementation contract. Sets immutable variables.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address WBNB_,\n        address factory_,\n        address _comptrollerAddress,\n        address _vBNBAddress\n    ) RouterHelper(WBNB_, factory_) {\n        if (_comptrollerAddress == address(0) || _vBNBAddress == address(0)) {\n            revert ZeroAddress();\n        }\n        comptrollerAddress = _comptrollerAddress;\n        _status = _NOT_ENTERED;\n        vBNBAddress = _vBNBAddress;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WBNB); // only accept BNB via fallback from the WBNB contract\n    }\n\n    // ****************************\n    // **** EXTERNAL FUNCTIONS ****\n    // ****************************\n\n    /**\n     * @notice Setter for the vBNB address.\n     * @param _vBNBAddress Address of the BNB vToken to update.\n     */\n    function setVBNBAddress(address _vBNBAddress) external onlyOwner {\n        if (_vBNBAddress == address(0)) {\n            revert ZeroAddress();\n        }\n\n        _isVTokenListed(_vBNBAddress);\n\n        address oldAddress = vBNBAddress;\n        vBNBAddress = _vBNBAddress;\n\n        emit VBNBAddressUpdated(oldAddress, vBNBAddress);\n    }\n\n    /**\n     * @notice Swap token A for token B and supply to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     */\n    function swapExactTokensForTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), TypesOfTokens.NON_SUPPORTING_FEE);\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap deflationary (a small amount of fee is deducted at the time of transfer of token) token A for token B and supply to a Venus market.\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     */\n    function swapExactTokensForTokensAndSupplyAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), TypesOfTokens.SUPPORTING_FEE);\n        uint256 swapAmount = _checkForAmountOut(lastAsset, balanceBefore, amountOutMin, address(this));\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for another token and supply to a Venus market\n     * @dev The amount to be swapped is obtained from the msg.value, since we are swapping BNB\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapExactBNBForTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactETHForTokens(amountOutMin, path, address(this), TypesOfTokens.NON_SUPPORTING_FEE);\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for another deflationary token (a small amount of fee is deducted at the time of transfer of token) and supply to a Venus market\n     * @dev The amount to be swapped is obtained from the msg.value, since we are swapping BNB\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapExactBNBForTokensAndSupplyAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactETHForTokens(amountOutMin, path, address(this), TypesOfTokens.SUPPORTING_FEE);\n        uint256 swapAmount = _checkForAmountOut(lastAsset, balanceBefore, amountOutMin, address(this));\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap tokens for Exact tokens and supply to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapTokensForExactTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapTokensForExactTokens(amountOut, amountInMax, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for Exact tokens and supply to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapBNBForExactTokensAndSupply(\n        address vTokenAddress,\n        uint256 amountOut,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapETHForExactTokens(amountOut, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _supply(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap token A for token B and repay a borrow from a Venus market\n     * @param vTokenAddress The address of the vToken contract to repay.\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive (and repay)\n     */\n    function swapAndRepay(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), TypesOfTokens.NON_SUPPORTING_FEE);\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap deflationary token (a small amount of fee is deducted at the time of transfer of token) token A for token B and repay a borrow from a Venus market\n     * @param vTokenAddress The address of the vToken contract to repay.\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive (and repay)\n     */\n    function swapAndRepayAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), TypesOfTokens.SUPPORTING_FEE);\n        uint256 swapAmount = _checkForAmountOut(lastAsset, balanceBefore, amountOutMin, address(this));\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for another token and repay a borrow from a Venus market\n     * @dev The amount to be swapped is obtained from the msg.value, since we are swapping BNB\n     * @param vTokenAddress The address of the vToken contract to repay.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered so the swap path tokens are listed first and last asset is the token we receive\n     */\n    function swapExactBNBForTokensAndRepay(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactETHForTokens(amountOutMin, path, address(this), TypesOfTokens.NON_SUPPORTING_FEE);\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for another deflationary token (a small amount of fee is deducted at the time of transfer of token) and repay a borrow from a Venus market\n     * @dev The amount to be swapped is obtained from the msg.value, since we are swapping BNB\n     * @param vTokenAddress The address of the vToken contract to repay.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered so the swap path tokens are listed first and last asset is the token we receive\n     */\n    function swapExactBNBForTokensAndRepayAtSupportingFee(\n        address vTokenAddress,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapExactETHForTokens(amountOutMin, path, address(this), TypesOfTokens.SUPPORTING_FEE);\n        uint256 swapAmount = _checkForAmountOut(lastAsset, balanceBefore, amountOutMin, address(this));\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap tokens for Exact tokens and repay to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapTokensForExactTokensAndRepay(\n        address vTokenAddress,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapTokensForExactTokens(amountOut, amountInMax, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap tokens for full tokens debt and repay to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapTokensForFullTokenDebtAndRepay(\n        address vTokenAddress,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        uint256 amountOut = IVToken(vTokenAddress).borrowBalanceCurrent(msg.sender);\n        _swapTokensForExactTokens(amountOut, amountInMax, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for Exact tokens and repay to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapBNBForExactTokensAndRepay(\n        address vTokenAddress,\n        uint256 amountOut,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        _swapETHForExactTokens(amountOut, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap BNB for Exact tokens and repay to a Venus market\n     * @param vTokenAddress The address of the vToken contract for supplying assets.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapBNBForFullTokenDebtAndRepay(\n        address vTokenAddress,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        _ensureVTokenChecks(vTokenAddress, path[path.length - 1]);\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(address(this));\n        uint256 amountOut = IVToken(vTokenAddress).borrowBalanceCurrent(msg.sender);\n        _swapETHForExactTokens(amountOut, path, address(this));\n        uint256 swapAmount = _getSwapAmount(lastAsset, balanceBefore);\n        _repay(lastAsset, vTokenAddress, swapAmount);\n    }\n\n    /**\n     * @notice Swap Exact tokens for BNB and repay to a Venus market\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapExactTokensForBNBAndRepay(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        uint256 balanceBefore = address(this).balance;\n        _swapExactTokensForETH(amountIn, amountOutMin, path, address(this), TypesOfTokens.NON_SUPPORTING_FEE);\n        uint256 balanceAfter = address(this).balance;\n        uint256 swapAmount = balanceAfter - balanceBefore;\n        IVBNB(vBNBAddress).repayBorrowBehalf{ value: swapAmount }(msg.sender);\n    }\n\n    /**\n     * @notice Swap Exact deflationary tokens (a small amount of fee is deducted at the time of transfer of tokens) for BNB and repay to a Venus market\n     * @param amountIn The amount of tokens to swap.\n     * @param amountOutMin Minimum amount of tokens to receive.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapExactTokensForBNBAndRepayAtSupportingFee(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        uint256 balanceBefore = address(this).balance;\n        _swapExactTokensForETH(amountIn, amountOutMin, path, address(this), TypesOfTokens.SUPPORTING_FEE);\n        uint256 balanceAfter = address(this).balance;\n        uint256 swapAmount = balanceAfter - balanceBefore;\n        if (swapAmount < amountOutMin) {\n            revert SwapAmountLessThanAmountOutMin(swapAmount, amountOutMin);\n        }\n        IVBNB(vBNBAddress).repayBorrowBehalf{ value: swapAmount }(msg.sender);\n    }\n\n    /**\n     * @notice Swap tokens for Exact BNB and repay to a Venus market\n     * @param amountOut The amount of the tokens needs to be as output token.\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapTokensForExactBNBAndRepay(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        uint256 balanceBefore = address(this).balance;\n        _swapTokensForExactETH(amountOut, amountInMax, path, address(this));\n        uint256 balanceAfter = address(this).balance;\n        uint256 swapAmount = balanceAfter - balanceBefore;\n        IVBNB(vBNBAddress).repayBorrowBehalf{ value: swapAmount }(msg.sender);\n    }\n\n    /**\n     * @notice Swap tokens for Exact BNB and repay to a Venus market\n     * @param amountInMax The maximum amount of input tokens that can be taken for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @dev Addresses of underlying assets should be ordered that first asset is the token we are swapping and second asset is the token we receive\n     * @dev In case of swapping native BNB the first asset in path array should be the wBNB address\n     */\n    function swapTokensForFullBNBDebtAndRepay(\n        uint256 amountInMax,\n        address[] calldata path,\n        uint256 deadline\n    ) external payable override nonReentrant ensure(deadline) ensurePath(path) {\n        uint256 balanceBefore = address(this).balance;\n        uint256 amountOut = IVToken(vBNBAddress).borrowBalanceCurrent(msg.sender);\n        _swapTokensForExactETH(amountOut, amountInMax, path, address(this));\n        uint256 balanceAfter = address(this).balance;\n        uint256 swapAmount = balanceAfter - balanceBefore;\n        IVBNB(vBNBAddress).repayBorrowBehalf{ value: swapAmount }(msg.sender);\n    }\n\n    /**\n     * @notice Swaps an exact amount of input tokens for as many output tokens as possible,\n     *         along the route determined by the path. The first element of path is the input token,\n     *         the last is the output token, and any intermediate elements represent intermediate\n     *         pairs to trade through (if, for example, a direct pair does not exist).\n     * @dev msg.sender should have already given the router an allowance of at least amountIn on the input token.\n     * @param amountIn The address of the vToken contract to repay.\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     */\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override nonReentrant ensure(deadline) ensurePath(path) returns (uint256[] memory amounts) {\n        amounts = _swapExactTokensForTokens(amountIn, amountOutMin, path, to, TypesOfTokens.NON_SUPPORTING_FEE);\n    }\n\n    /**\n     * @notice Swaps an exact amount of input tokens for as many output tokens as possible,\n     *         along the route determined by the path. The first element of path is the input token,\n     *         the last is the output token, and any intermediate elements represent intermediate\n     *         pairs to trade through (if, for example, a direct pair does not exist).\n     *         This method to swap deflationary tokens which would require supporting fee.\n     * @dev msg.sender should have already given the router an allowance of at least amountIn on the input token.\n     * @param amountIn The address of the vToken contract to repay.\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     */\n    function swapExactTokensForTokensAtSupportingFee(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override nonReentrant ensure(deadline) ensurePath(path) returns (uint256 swapAmount) {\n        address lastAsset = path[path.length - 1];\n        uint256 balanceBefore = IERC20(lastAsset).balanceOf(to);\n        _swapExactTokensForTokens(amountIn, amountOutMin, path, to, TypesOfTokens.SUPPORTING_FEE);\n        swapAmount = _checkForAmountOut(lastAsset, balanceBefore, amountOutMin, to);\n    }\n\n    /**\n     * @notice Swaps an exact amount of ETH for as many output tokens as possible,\n     *         along the route determined by the path. The first element of path must be WBNB,\n     *         the last is the output token, and any intermediate elements represent\n     *         intermediate pairs to trade through (if, for example, a direct pair does not exist).\n     * @dev amountIn is passed through the msg.value of the transaction\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     */\n    function swapExactBNBForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        override\n        nonReentrant\n        ensure(deadline)\n        ensurePath(path)\n        returns (uint256[] memory amounts)\n    {\n        amounts = _swapExactETHForTokens(amountOutMin, path, to, TypesOfTokens.NON_SUPPORTING_FEE);\n    }\n\n    /**\n     * @notice Swaps an exact amount of ETH for as many output tokens as possible,\n     *         along the route determined by the path. The first element of path must be WBNB,\n     *         the last is the output token, and any intermediate elements represent\n     *         intermediate pairs to trade through (if, for example, a direct pair does not exist).\n     *         This method to swap deflationary tokens which would require supporting fee.\n     * @dev amountIn is passed through the msg.value of the transaction\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path Array with addresses of the underlying assets to be swapped\n     * @param to Recipient of the output tokens.\n     * @param deadline Unix timesta"
    }
  ]
}