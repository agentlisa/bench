{
  "Title": "[M-07] Multisig can execute the same proposal repeatedly",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-07-axelar/blob/aeabaa7086eb35e8614e58b42f0d50728e023881/contracts/cgp/auth/MultisigBase.sol#L44-L77><br>\n<https://github.com/code-423n4/2023-07-axelar/blob/9f642fe854eb11ad9f18fe028e5a8353c258e926/contracts/cgp/governance/Multisig.sol#L30-L36>\n\n### Impact\n\nIn MultisigBase and its use in Multisig, the `onlySigners` modifier will reset the vote count and execute the external call when the vote threshold is met. This means that if many signers send their transactions during the same block, the votes that are executed after the call execution will start a new tally, potentially re-executing the same external call if the votes are enough to meet the threshold again. This is probably low-likelihood for multisigs where the threshold is high relative to the number of signers, but could be quite likely if the threshold is relatively low.\n\nIn the general case, users of Multisig may not be aware of this behavior and have no good way of avoiding this other than off-chain coordination. An accidental double execution could easily lead to a loss of funds.\n\nThis doesn't affect `AxelarServiceGovernance` because of the additional requirement of an interchain message, but it might still leave behind unwanted votes; which reduces the overall security of the governance mechanism.\n\n### Proof of Concept\n\nArguably, [this unit test](https://github.com/code-423n4/2023-07-axelar/blob/aeabaa7086eb35e8614e58b42f0d50728e023881/test/cgp/Multisig.js#L152-L176) is a PoC in itself.\n\nBut the following example might be a better illustration. The following test passes (when based on the explanation above, it shouldn't), and is a modification of the above test but using threshold 1:\n\n```javascript\n    it('executes the same call twice, accidentally', async () => {\n        const targetInterface = new Interface(['function callTarget() external']);\n        const calldata = targetInterface.encodeFunctionData('callTarget');\n        const nativeValue = 1000;\n\n        // Set the threshold to 1\n        await multisig.connect(signer1).rotateSigners(accounts, 1)\n        await multisig.connect(signer2).rotateSigners(accounts, 1)\n\n        // Say these two signers send their vote at the same time:\n        await expect(multisig.connect(signer1).execute(targetContract.address, calldata, nativeValue, { value: nativeValue })).to.emit(\n            targetContract,\n            'TargetCalled',\n        );\n        await expect(multisig.connect(signer2).execute(targetContract.address, calldata, nativeValue, { value: nativeValue })).to.emit(\n            targetContract,\n            'TargetCalled',\n        );\n        // The call was executed twice!\n    });\n```\n\n### Recommended Mitigation Steps\n\nConsider adding an incrementing nonce to each topic, so that repeating the call requires using a new nonce. If the intent is to allow arbitrary-order execution, then using a random or unique topic ID in addition to the topic hash could be used instead (like you did with the `commandId` in AxelarGateway).\n\n### Assessed type\n\nAccess Control\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/116#issuecomment-1715322440):**\n > Referencing the comment in [Issue #333](https://github.com/code-423n4/2023-07-axelar-findings/issues/333#issuecomment-1712145265):\n> \n> > > it is assumed that the signers are trusted\n> > \n> > Isn't the purpose of a multisig *not* to trust individual signers or even N-1 signers, but only trust when N of them sign?\n> > \n> > I would argue that a multisig meets it's purpose if and only if the configured threshold is the absolute minimum number of signers that must be compromised to execute a proposal maliciously. The fact that overvotes can leave a spurious proposal with N-1 votes being sufficient for execution breaks one of the core assumptions when using a multisig.\n> > \n> > (I'd also note [#116](https://github.com/code-423n4/2023-07-axelar-findings/issues/116) and [#245](https://github.com/code-423n4/2023-07-axelar-findings/issues/245) could be considered duplicates. The impact descriptions are slightly different but the underlying issue is the same)\n> \n> After careful consideration, I'd like to change my stance on the validity and severity of the outlined issue of overcounting proposal votes. Let me elaborate on my reasoning:\n> \n> First of all, there's an underlying trust assumption on the used multisig. All signers, initially chosen by the deployer of the multisig contract (`MultisigBase` or the derived `Multisig` contract), are trusted. Rotating signers, i.e., adding/removing signers and changing the threshold (quorum), is also voted on by the existing signers. Thus, assuming the new set of signers (and threshold) is reasonable and trustworthy.\n> \n> However, a multisig is purposefully used to ensure proposals only get executed once the quorum of the signers is reached.\n> \n> Given the outlined issue in the submission, overvoting by signers can occur. For example, if the signing transactions get executed within the same block. Moreover, it can be assumed that the `Multisig.execute` function is intended to be executed multiple times with the same arguments (calldata). For instance, to repeatedly perform certain token transfers on a regular basis. Adding some kind of \"nonce\" or additional data to the arguments to achieve a new and unique proposal (specifically, a unique `topic`) to be voted on is not reasonable as the `Multisig.execute` function does not provide such parameters. Contrary to OpenZeppelin's `Governor` contract, which allows specifying a (unique) proposal description (see [Governor.sol#L268-L289](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/governance/Governor.sol#L268-L289)). Additionally, in OZ's `Governor` contract, casting votes is only possible on pending proposals and reverts otherwise.\n> \n> I consider \"overvoting\" as a bug worth mitigating as it leaves proposals in an inconsistent state, leading to unpredictable outcomes.\n> \n> Given [C4's judging criteria and severity categorization](https://docs.code4rena.com/awarding/judging-criteria/severity-categorization)\n> \n> > 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> \n> I'm considering this submission valid and the chosen Medium severity to be appropriate.\n\n**[deanamiel (Axelar) disputed and commented via duplicate issue #333](https://github.com/code-423n4/2023-07-axelar-findings/issues/333#issuecomment-1715982047):**\n> Perhaps for a generic multi-sig in which signers are not trusted this would be true. However, for the multi-sig that we have designed for our governance purposes, signers will be part of Axelar governance and therefore, will be trusted. It is the signer's responsibility to ensure that a proposal exists before voting on it. We still wish to dispute validity.\n\n**[berndartmueller (judge) commented via duplicate issue #333](https://github.com/code-423n4/2023-07-axelar-findings/issues/333#issuecomment-1716011785):**\n> @deanamiel - I understand your point. Nevertheless, overvoting is possible (even if not done with malicious intent), and it can be fixed to prevent any future, while unlikely, issue.\n> \n>I acknowledge that the sponsor disagrees with the validity. The validity and severity are certainly close to being invalid and QA, respectively. Still, I lean more towards being valid and Medium severity.\n\n**[milapsheth (Axelar) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/116#issuecomment-1801797757):**\n> This was an intentional design decision. It's designed for internal use and will have low usage frequency with a coordinated participation such that this issue is Low impact, but we acknowledge the concern for general use.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/cgp/auth/MultisigBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IMultisigBase } from '../interfaces/IMultisigBase.sol';\n\n/**\n * @title MultisigBase Contract\n * @notice This contract implements a custom multisignature wallet where transactions must be confirmed by a\n * threshold of signers. The signers and threshold may be updated every `epoch`.\n */\ncontract MultisigBase is IMultisigBase {\n    struct Voting {\n        uint256 voteCount;\n        mapping(address => bool) hasVoted;\n    }\n\n    struct Signers {\n        address[] accounts;\n        uint256 threshold;\n        mapping(address => bool) isSigner;\n    }\n\n    Signers public signers;\n    uint256 public signerEpoch;\n    // uint256 is for epoch, bytes32 for vote topic hash\n    mapping(uint256 => mapping(bytes32 => Voting)) public votingPerTopic;\n\n    /**\n     * @notice Contract constructor\n     * @dev Sets the initial list of signers and corresponding threshold.\n     * @param accounts Address array of the signers\n     * @param threshold Signature threshold required to validate a transaction\n     */\n    constructor(address[] memory accounts, uint256 threshold) {\n        _rotateSigners(accounts, threshold);\n    }\n\n    /**\n     * @notice Modifier to ensure the caller is a signer\n     * @dev Keeps track of votes for each operation and resets the vote count if the operation is executed.\n     * @dev Given the early void return, this modifier should be used with care on functions that return data.\n     */\n    modifier onlySigners() {\n        if (!signers.isSigner[msg.sender]) revert NotSigner();\n\n        bytes32 topic = keccak256(msg.data);\n        Voting storage voting = votingPerTopic[signerEpoch][topic];\n\n        // Check that signer has not voted, then record that they have voted.\n        if (voting.hasVoted[msg.sender]) revert AlreadyVoted();\n\n        voting.hasVoted[msg.sender] = true;\n\n        // Determine the new vote count.\n        uint256 voteCount = voting.voteCount + 1;\n\n        // Do not proceed with operation execution if insufficient votes.\n        if (voteCount < signers.threshold) {\n            // Save updated vote count.\n            voting.voteCount = voteCount;\n            return;\n        }\n\n        // Clear vote count and voted booleans.\n        voting.voteCount = 0;\n\n        uint256 count = signers.accounts.length;\n\n        for (uint256 i; i < count; ++i) {\n            voting.hasVoted[signers.accounts[i]] = false;\n        }\n\n        emit MultisigOperationExecuted(topic);\n\n        _;\n    }\n\n    /******************\\\n    |* Public Getters *|\n    \\******************/\n\n    /**\n     * @notice Returns the current signer threshold\n     * @return uint The signer threshold\n     */\n    function signerThreshold() external view override returns (uint256) {\n        return signers.threshold;\n    }\n\n    /**\n     * @notice Returns an array of current signers\n     * @return array of signer addresses\n     */\n    function signerAccounts() external view override returns (address[] memory) {\n        return signers.accounts;\n    }\n\n    /**\n     * @notice Getter to determine if an account is a signer\n     * @return boolean indicating if the account is a signer\n     */\n    function isSigner(address account) external view override returns (bool) {\n        return signers.isSigner[account];\n    }\n\n    /**\n     * @notice Getter to determine if an account has voted on a topic\n     * @return boolean indicating if the account has voted\n     */\n    function hasSignerVoted(address account, bytes32 topic) external view override returns (bool) {\n        return votingPerTopic[signerEpoch][topic].hasVoted[account];\n    }\n\n    /**\n     * @notice Get the number of votes for a topic\n     * @return uint256 indicating the number of votes for a topic\n     */\n    function getSignerVotesCount(bytes32 topic) external view override returns (uint256) {\n        uint256 length = signers.accounts.length;\n        uint256 voteCount;\n        for (uint256 i; i < length; ++i) {\n            if (votingPerTopic[signerEpoch][topic].hasVoted[signers.accounts[i]]) {\n                voteCount++;\n            }\n        }\n\n        return voteCount;\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    /**\n     * @notice Rotate the signers for the multisig\n     * @dev Updates the current set of signers and threshold and increments the `epoch`\n     * @dev This function is protected by the onlySigners modifier\n     * @param newAccounts Address array of the new signers\n     * @param newThreshold The new signature threshold for executing operations\n     */\n    function rotateSigners(address[] memory newAccounts, uint256 newThreshold) external virtual onlySigners {\n        _rotateSigners(newAccounts, newThreshold);\n    }\n\n    /**\n     * @dev Internal function that implements signer rotation logic\n     */\n    function _rotateSigners(address[] memory newAccounts, uint256 newThreshold) internal {\n        uint256 length = signers.accounts.length;\n\n        // Clean up old signers.\n        for (uint256 i; i < length; ++i) {\n            signers.isSigner[signers.accounts[i]] = false;\n        }\n\n        length = newAccounts.length;\n\n        if (newThreshold > length) revert InvalidSigners();\n\n        if (newThreshold == 0) revert InvalidSignerThreshold();\n\n        ++signerEpoch;\n\n        signers.accounts = newAccounts;\n        signers.threshold = newThreshold;\n\n        for (uint256 i; i < length; ++i) {\n            address account = newAccounts[i];\n\n            // Check that the account wasn't already set as a signer for this epoch.\n            if (signers.isSigner[account]) revert DuplicateSigner(account);\n            if (account == address(0)) revert InvalidSigners();\n\n            signers.isSigner[account] = true;\n        }\n\n        emit SignersRotated(newAccounts, newThreshold);\n    }\n}"
    },
    {
      "filename": "contracts/cgp/governance/Multisig.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IMultisig } from '../interfaces/IMultisig.sol';\nimport { MultisigBase } from '../auth/MultisigBase.sol';\nimport { Caller } from '../util/Caller.sol';\n\n/**\n * @title Multisig Contract\n * @notice An extension of MultisigBase that can call functions on any contract.\n */\ncontract Multisig is Caller, MultisigBase, IMultisig {\n    /**\n     * @notice Contract constructor\n     * @dev Sets the initial list of signers and corresponding threshold.\n     * @param accounts Address array of the signers\n     * @param threshold Signature threshold required to validate a transaction\n     */\n    constructor(address[] memory accounts, uint256 threshold) MultisigBase(accounts, threshold) {}\n\n    /**\n     * @notice Executes an external contract call.\n     * @dev Calls a target address with specified calldata and optionally sends value.\n     * This function is protected by the onlySigners modifier.\n     * @param target The address of the contract to call\n     * @param callData The data encoding the function and arguments to call\n     * @param nativeValue The amount of native currency (e.g., ETH) to send along with the call\n     */\n    function execute(\n        address target,\n        bytes calldata callData,\n        uint256 nativeValue\n    ) external payable onlySigners {\n        _call(target, callData, nativeValue);\n    }\n\n    /**\n     * @notice Making contact able to receive native value\n     */\n    receive() external payable {}\n}"
    },
    {
      "filename": "test/cgp/Multisig.js",
      "content": "const chai = require('chai');\nconst { ethers } = require('hardhat');\nconst {\n    utils: { Interface, keccak256 },\n} = ethers;\nconst { expect } = chai;\n\ndescribe('Multisig', () => {\n    let signer1, signer2, signer3;\n    let accounts;\n\n    let multisigFactory;\n    let multisig;\n\n    let targetFactory;\n    let targetContract;\n\n    before(async () => {\n        [signer1, signer2, signer3] = await ethers.getSigners();\n        accounts = [signer1, signer2, signer3].map((signer) => signer.address);\n\n        multisigFactory = await ethers.getContractFactory('Multisig', signer1);\n        targetFactory = await ethers.getContractFactory('Target', signer1);\n    });\n\n    beforeEach(async () => {\n        multisig = await multisigFactory.deploy(accounts, 2).then((d) => d.deployed());\n        targetContract = await targetFactory.deploy().then((d) => d.deployed());\n    });\n\n    it('should initialize the mint limiter with signer accounts and threshold', async () => {\n        const currentThreshold = 2;\n\n        expect(await multisig.signerThreshold()).to.equal(currentThreshold);\n        expect(await multisig.signerAccounts()).to.deep.equal(accounts);\n    });\n\n    it('should revert on execute with insufficient value sent', async () => {\n        const targetInterface = new Interface(['function callTarget() external']);\n        const calldata = targetInterface.encodeFunctionData('callTarget');\n        const nativeValue = 1000;\n\n        await multisig\n            .connect(signer1)\n            .execute(targetContract.address, calldata, nativeValue)\n            .then((tx) => tx.wait());\n\n        await expect(multisig.connect(signer2).execute(targetContract.address, calldata, nativeValue)).to.be.revertedWithCustomError(\n            multisig,\n            'InsufficientBalance',\n        );\n    });\n\n    it('should revert on execute if call to target fails', async () => {\n        // Encode function that does not exist on target\n        const targetInterface = new Interface(['function set() external']);\n        const calldata = targetInterface.encodeFunctionData('set');\n        const nativeValue = 1000;\n\n        await multisig\n            .connect(signer1)\n            .execute(targetContract.address, calldata, nativeValue)\n            .then((tx) => tx.wait());\n\n        await expect(\n            multisig.connect(signer2).execute(targetContract.address, calldata, nativeValue, { value: nativeValue }),\n        ).to.be.revertedWithCustomError(multisig, 'ExecutionFailed');\n    });\n\n    it('should return true if signer has voted on a given topic', async () => {\n        const targetInterface = new Interface(['function callTarget() external']);\n        const calldata = targetInterface.encodeFunctionData('callTarget');\n        const nativeValue = 1000;\n\n        const multiSigInterface = new Interface([\n            'function execute(address target, bytes calldata callData, uint256 nativeValue) external payable',\n        ]);\n        const calldataMultiSig = multiSigInterface.encodeFunctionData('execute', [targetContract.address, calldata, nativeValue]);\n        const calldataMultiSigHash = keccak256(calldataMultiSig);\n\n        await multisig\n            .connect(signer1)\n            .execute(targetContract.address, calldata, nativeValue)\n            .then((tx) => tx.wait());\n\n        expect(await multisig.hasSignerVoted(signer1.address, calldataMultiSigHash)).to.equal(true);\n    });\n\n    it('should return false if a signer has not voted on a given topic', async () => {\n        const targetInterface = new Interface(['function callTarget() external']);\n        const calldata = targetInterface.encodeFunctionData('callTarget');\n        const nativeValue = 1000;\n\n        const multiSigInterface = new Interface([\n            'function execute(address target, bytes calldata callData, uint256 nativeValue) external payable',\n        ]);\n        const calldataMultiSig = multiSigInterface.encodeFunctionData('execute', [targetContract.address, calldata, nativeValue]);\n        const calldataMultiSigHash = keccak256(calldataMultiSig);\n\n        await multisig\n            .connect(signer1)\n            .execute(targetContract.address, calldata, nativeValue)\n            .then((tx) => tx.wait());\n\n        expect(await multisig.hasSignerVoted(signer2.address, calldataMultiSigHash)).to.equal(false);\n    });\n\n    it('should return the correct vote count for a given topic', async () => {\n        const targetInterface = new Interface(['function callTarget() external']);\n        const calldata = targetInterface.encodeFunctionData('callTarget');\n        const nativeValue = 1000;\n\n        const multiSigInterface = new Interface([\n            'function execute(address target, bytes calldata callData, uint256 nativeValue) external payable',\n        ]);\n        const calldataMultiSig = multiSigInterface.encodeFunctionData('execute', [targetContract.address, calldata, nativeValue]);\n        const calldataMultiSigHash = keccak256(calldataMultiSig);\n\n        expect(await multisig.getSignerVotesCount(calldataMultiSigHash)).to.equal(0);\n\n        await multisig\n            .connect(signer1)\n            .execute(targetContract.address, calldata, nativeValue)\n            .then((tx) => tx.wait());\n\n        expect(await multisig.getSignerVotesCount(calldataMultiSigHash)).to.equal(1);\n\n        await expect(multisig.connect(signer2).execute(targetContract.address, calldata, nativeValue, { value: nativeValue })).to.emit(\n            targetContract,\n            'TargetCalled',\n        );\n\n        expect(await multisig.getSignerVotesCount(calldataMultiSigHash)).to.equal(0);\n    });\n\n    it('should execute function on target contract', async () => {\n        const targetInterface = new Interface(['function callTarget() external']);\n        const calldata = targetInterface.encodeFunctionData('callTarget');\n        const nativeValue = 1000;\n\n        await multisig\n            .connect(signer1)\n            .execute(targetContract.address, calldata, nativeValue)\n            .then((tx) => tx.wait());\n\n        await expect(multisig.connect(signer2).execute(targetContract.address, calldata, nativeValue, { value: nativeValue })).to.emit(\n            targetContract,\n            'TargetCalled',\n        );\n    });\n\n    it('should execute function on target contract twice within the same epoch without rotating signers', async () => {\n        const targetInterface = new Interface(['function callTarget() external']);\n        const calldata = targetInterface.encodeFunctionData('callTarget');\n        const nativeValue = 1000;\n\n        await multisig\n            .connect(signer1)\n            .execute(targetContract.address, calldata, nativeValue)\n            .then((tx) => tx.wait());\n\n        await expect(multisig.connect(signer2).execute(targetContract.address, calldata, nativeValue, { value: nativeValue })).to.emit(\n            targetContract,\n            'TargetCalled',\n        );\n\n        await multisig\n            .connect(signer1)\n            .execute(targetContract.address, calldata, nativeValue)\n            .then((tx) => tx.wait());\n\n        await expect(multisig.connect(signer2).execute(targetContract.address, calldata, nativeValue, { value: nativeValue })).to.emit(\n            targetContract,\n            'TargetCalled',\n        );\n    });\n});"
    },
    {
      "filename": "contracts/governance/Governor.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/Governor.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../token/ERC721/IERC721Receiver.sol\";\nimport {IERC1155Receiver} from \"../token/ERC1155/IERC1155Receiver.sol\";\nimport {EIP712} from \"../utils/cryptography/EIP712.sol\";\nimport {SignatureChecker} from \"../utils/cryptography/SignatureChecker.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\nimport {SafeCast} from \"../utils/math/SafeCast.sol\";\nimport {DoubleEndedQueue} from \"../utils/structs/DoubleEndedQueue.sol\";\nimport {Address} from \"../utils/Address.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {Nonces} from \"../utils/Nonces.sol\";\nimport {IGovernor, IERC6372} from \"./IGovernor.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended through various modules.\n *\n * This contract is abstract and requires several functions to be implemented in various modules:\n *\n * - A counting module must implement {quorum}, {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {_getVotes}\n * - Additionally, {votingPeriod} must also be implemented\n */\nabstract contract Governor is Context, ERC165, EIP712, Nonces, IGovernor, IERC721Receiver, IERC1155Receiver {\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\n\n    bytes32 public constant BALLOT_TYPEHASH =\n        keccak256(\"Ballot(uint256 proposalId,uint8 support,address voter,uint256 nonce)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\n            \"ExtendedBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason,bytes params)\"\n        );\n\n    struct ProposalCore {\n        address proposer;\n        uint48 voteStart;\n        uint32 voteDuration;\n        bool executed;\n        bool canceled;\n        uint48 etaSeconds;\n    }\n\n    bytes32 private constant ALL_PROPOSAL_STATES_BITMAP = bytes32((2 ** (uint8(type(ProposalState).max) + 1)) - 1);\n    string private _name;\n\n    mapping(uint256 proposalId => ProposalCore) private _proposals;\n\n    // This queue keeps track of the governor operating on itself. Calls to functions protected by the {onlyGovernance}\n    // modifier needs to be whitelisted in this queue. Whitelisting is set in {execute}, consumed by the\n    // {onlyGovernance} modifier and eventually reset after {_executeOperations} completes. This ensures that the\n    // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n    DoubleEndedQueue.Bytes32Deque private _governanceCall;\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        _checkGovernance();\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    constructor(string memory name_) EIP712(name_, version()) {\n        _name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return\n            interfaceId == type(IGovernor).interfaceId ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-version}.\n     */\n    function version() public view virtual returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(uint256 proposalId) public view virtual returns (ProposalState) {\n        // We read the struct fields into the stack at once so Solidity emits a single SLOAD\n        ProposalCore storage proposal = _proposals[proposalId];\n        bool proposalExecuted = proposal.executed;\n        bool proposalCanceled = proposal.canceled;\n\n        if (proposalExecuted) {\n            return ProposalState.Executed;\n        }\n\n        if (proposalCanceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n\n        uint256 currentTimepoint = clock();\n\n        if (snapshot >= currentTimepoint) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= currentTimepoint) {\n            return ProposalState.Active;\n        } else if (!_quorumReached(proposalId) || !_voteSucceeded(proposalId)) {\n            return ProposalState.Defeated;\n        } else if (proposalEta(proposalId) == 0) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @dev See {IGovernor-proposalThreshold}.\n     */\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256) {\n        return _proposals[proposalId].voteStart;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256) {\n        return _proposals[proposalId].voteStart + _proposals[proposalId].voteDuration;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalProposer}.\n     */\n    function proposalProposer(uint256 proposalId) public view virtual returns (address) {\n        return _proposals[proposalId].proposer;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalEta}.\n     */\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256) {\n        return _proposals[proposalId].etaSeconds;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalNeedsQueuing}.\n     */\n    function proposalNeedsQueuing(uint256) public view virtual returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev Reverts if the `msg.sender` is not the executor. In case the executor is not this contract\n     * itself, the function reverts if `msg.data` is not whitelisted as a result of an {execute}\n     * operation. See {onlyGovernance}.\n     */\n    function _checkGovernance() internal virtual {\n        if (_executor() != _msgSender()) {\n            revert GovernorOnlyExecutor(_msgSender());\n        }\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while (_governanceCall.popFront() != msgDataHash) {}\n        }\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.\n     */\n    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory params\n    ) internal virtual returns (uint256);\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256) {\n        address proposer = _msgSender();\n\n        // check description restriction\n        if (!_isValidDescriptionForProposer(proposer, description)) {\n            revert GovernorRestrictedProposer(proposer);\n        }\n\n        // check proposal threshold\n        uint256 votesThreshold = proposalThreshold();\n        if (votesThreshold > 0) {\n            uint256 proposerVotes = getVotes(proposer, clock() - 1);\n            if (proposerVotes < votesThreshold) {\n                revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);\n            }\n        }\n\n        return _propose(targets, values, calldatas, description, proposer);\n    }\n\n    /**\n     * @dev Internal propose mechanism. Can be overridden to add more logic on proposal creation.\n     *\n     * Emits a {IGovernor-ProposalCreated} event.\n     */\n    function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal virtual returns (uint256 proposalId) {\n        proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n        if (targets.length != values.length || targets.length != calldatas.length || targets.length == 0) {\n            revert GovernorInvalidProposalLength(targets.length, calldatas.length, values.length);\n        }\n        if (_proposals[proposalId].voteStart != 0) {\n            revert GovernorUnexpectedProposalState(proposalId, state(proposalId), bytes32(0));\n        }\n\n        uint256 snapshot = clock() + votingDelay();\n        uint256 duration = votingPeriod();\n\n        ProposalCore storage proposal = _proposals[proposalId];\n        proposal.proposer = proposer;\n        proposal.voteStart = SafeCast.toUint48(snapshot);\n        proposal.voteDuration = SafeCast.toUint32(duration);\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            snapshot + duration,\n            description\n        );\n\n        // Using a named return variable to avoid stack too deep errors\n    }\n\n    /**\n     * @dev See {IGovernor-queue}.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Succeeded));\n\n        uint48 etaSeconds = _queueOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        if (etaSeconds != 0) {\n            _proposals[proposalId].etaSeconds = etaSeconds;\n            emit ProposalQueued(proposalId, etaSeconds);\n        } else {\n            revert GovernorQueueNotImplemented();\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal queuing mechanism. Can be overridden (without a super call) to modify the way queuing is\n     * performed (for example adding a vault/timelock).\n     *\n     * This is empty by default, and must be overridden to implement queuing.\n     *\n     * This function returns a timestamp that describes the expected ETA for execution. If the returned value is 0\n     * (which is the default value), the core will consider queueing did not succeed, and the public {queue} function\n     * will revert.\n     *\n     * NOTE: Calling this function directly will NOT check the current state of the proposal, or emit the\n     * `ProposalQueued` event. Queuing a proposal should be done using {queue}.\n     */\n    function _queueOperations(\n        uint256 /*proposalId*/,\n        address[] memory /*targets*/,\n        uint256[] memory /*values*/,\n        bytes[] memory /*calldatas*/,\n        bytes32 /*descriptionHash*/\n    ) internal virtual returns (uint48) {\n        return 0;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(\n            proposalId,\n            _encodeStateBitmap(ProposalState.Succeeded) | _encodeStateBitmap(ProposalState.Queued)\n        );\n\n        // mark as executed before calls to avoid reentrancy\n        _proposals[proposalId].executed = true;\n\n        // before execute: register governance call in queue.\n        if (_executor() != address(this)) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                if (targets[i] == address(this)) {\n                    _governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n\n        _executeOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        // after execute: cleanup governance call queue.\n        if (_executor() != address(this) && !_governanceCall.empty()) {\n            _governanceCall.clear();\n        }\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden (without a super call) to modify the way execution is\n     * performed (for example adding a vault/timelock).\n     *\n     * NOTE: Calling this function directly will NOT check the current state of the proposal, set the executed flag to\n     * true or emit the `ProposalExecuted` event. Executing a proposal should be done using {execute} or {_execute}.\n     */\n    function _executeOperations(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            Address.verifyCallResult(success, returndata);\n        }\n    }\n\n    /**\n     * @dev See {IGovernor-cancel}.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        // The proposalId will be recomputed in the `_cancel` call further down. However we need the value before we\n        // do the internal call, because we need to check the proposal state BEFORE the internal `_cancel` call\n        // changes it. The `hashProposal` duplication has a cost that is limited, and that we accept.\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        // public cancel restrictions (on top of existing _cancel restrictions).\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Pending));\n        if (_msgSender() != proposalProposer(proposalId)) {\n            revert GovernorOnlyProposer(_msgSender());\n        }\n\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Internal cancel mec"
    }
  ]
}