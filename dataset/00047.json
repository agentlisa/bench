{
  "Title": "M-4: Less rsETH minted than intended in volatile conditions. due to zero slippage when staking ETH to mint rsETH",
  "Content": "# Issue M-4: Less rsETH minted than intended in volatile conditions. due to zero slippage when staking ETH to mint rsETH \n\nSource: https://github.com/sherlock-audit/2024-05-napier-update-judging/issues/26 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nBauchibred, BiasedMerc, Ironsidesec, merlin, zzykxx\n## Summary\nThis issue is not at all related to external admin, but the slippage parameter being zero is the issue. Read the issue flow after below images\n\n## Vulnerability Detail\nThere is a slippage parameter called `minRSETHAmountExpected` in `RSETH_DEPOSIT_POOL.depositETH`.\nAnd `RsETHAdapter._stake` is setting it to 0 when it calls `RSETH_DEPOSIT_POOL.depositETH`.\n\nIts an issue, look at the sudden waves / bumps of rsETH within seconds, and LRT oracle admin will update the price according to the markets in dexes, or else  free arbitrage mints will further cause spiral moves.Or explore the ezETH depeg recently (https://x.com/SudipanSinha/status/1783473266515931284) and LRT x money market impact (https://x.com/SudipanSinha/status/1784107059744792715)\n\n\nClick yellow button on https://www.dextools.io/app/en/ether/pair-explorer/0x059615ebf32c946aaab3d44491f78e4f8e97e1d3\n\n![image](https://github.com/sherlock-audit/2024-05-napier-update-ironsidesec/assets/162350329/a42f8d41-7fa8-43d8-b2d1-3e12f876c4b0)\n\nhttps://app.uniswap.org/explore/pools/ethereum/0x059615EBf32C946aaab3D44491f78e4F8e97e1D3\n\n![image](https://github.com/sherlock-audit/2024-05-napier-update-ironsidesec/assets/162350329/721c378c-7727-43ad-953f-0ff56ba77119)\n\nhttps://matcha.xyz/tokens/ethereum/0xa1290d69c65a6fe4df752f95823fae25cb99e5a7?buyChain=1&buyAddress=0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n\n![image](https://github.com/sherlock-audit/2024-05-napier-update-ironsidesec/assets/162350329/b73d9bc5-d69e-4e2e-9823-21ddf294aa6a)\n\n\n**Issue flow**: \n1. Rebalancer notices ETH to deposit in Kelp DAO's rsETH.\n2. call flows to `RsETHAdapter._stake` --> `RSETH_DEPOSIT_POOL.depositETH` which will deposit eth to mint rsETH at current price.\n3. Its a volatile time, and many transactions are pending, kelp lrt oracle is updated according to latest dex price which has pumped a lot.\n4. Then the napier's `_stake`  transaction goes through, which will mint less rsETH because the price of rsETH went so high\n5. but after few blocks, the price of rsETH again balanced and it dipped to normal, so lrt oracle is updated.\n\nNow, it is a loss to Napier because we minted less tokens at peak price instead of normal current price and they are worth very low in terms of USD or WETH. If we used slippage, then it would have reverted in these cases.\n\nDue to the below reason of price fluctuations, depegs, the slippage should not be set to 0.\n\nAnd it is under the admin control. But during the times of rebalancing, if  depeg happens or in a very volatile sessions, the slippage is necessary. Because the admin might update the latest rsETH/WETH price and we might receive less rsETH as intended.\n\nThis can be resulted to MEV or sandwich attacks to 0 slippage. Although rebalancers use private mempool, the price of rsETH will be volatile in big steps wise jumps as shown in images below. And the latest Renzo  depeg of ezETH shows that slippage should be implemented, or else its a loss to Napier vaults.\n\n\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol#L84\n\n```solidity\nFile: 2024-05-napier-update\\napier-uups-adapters\\src\\adapters\\kelp\\RsETHAdapter.sol\n\n67:     function _stake(uint256 stakeAmount) internal override returns (uint256) {\n...\n81:         // Interact\n82:         IWETH9(Constants.WETH).withdraw(stakeAmount);\n83:         uint256 _rsETHAmt = RSETH.balanceOf(address(this));\n84:   >>>   RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(0, REFERRAL_ID); \n85:         _rsETHAmt = RSETH.balanceOf(address(this)) - _rsETHAmt;\n86: \n...\n90:     }\n\n```\n\nhttps://etherscan.io/address/0x13576cd2b61e601d3e98b5c06ef81896c9bbb369#code#F1#L206\nLine 206 on https://etherscan.deth.net/address/0x13576cd2b61e601d3e98b5c06ef81896c9bbb369\n\n```solidity\n    function depositETH(\n  >>>   uint256 minRSETHAmountExpected,\n        string calldata referralId\n    )\n        external payable  whenNotPaused  nonReentrant\n    {\n        // checks\n >>>    uint256 rsethAmountToMint = _beforeDeposit(LRTConstants.ETH_TOKEN, msg.value, minRSETHAmountExpected);\n\n        // interactions\n        _mintRsETH(rsethAmountToMint);\n        emit ETHDeposit(msg.sender, msg.value, rsethAmountToMint, referralId);\n    }\n\n    function _beforeDeposit(\n        address asset,\n        uint256 depositAmount,\n >>>    uint256 minRSETHAmountExpected\n    )\n        private view returns (uint256 rsethAmountToMint)\n    {\n... SKIP ...\n        rsethAmountToMint = getRsETHAmountToMint(asset, depositAmount);\n\n >>>    if (rsethAmountToMint < minRSETHAmountExpected) {\n            revert MinimumAmountToReceiveNotMet();\n        }\n    }\n    \n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public view  override   returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n  >>>  rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.rsETHPrice();\n    }\n```\n\n## Impact\nLess rsETH was minted than intended in volatile conditions.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol#L84\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol#L84\n\n```diff\n-   function _stake(uint256 stakeAmount) internal override returns (uint256) {\n+   function _stake(uint256 stakeAmount, uint256 minRSETHAmountExpected) internal override returns (uint256) {\n\n... SKIP ...\n\n        // Interact\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _rsETHAmt = RSETH.balanceOf(address(this));\n-       RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(0, REFERRAL_ID); \n+       RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(minRSETHAmountExpected, REFERRAL_ID); \n        _rsETHAmt = RSETH.balanceOf(address(this)) - _rsETHAmt;\n\n        if (_rsETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**PNS** commented:\n>  slippage control is (will be) at the Tranche.issue level and not at the adapter level (following issue #84 in the previous contest)\n\n\n\n**massun-onibakuchi**\n\nIt makes sense but depegging upward is economically unlikely. some protocols seems to set zero slippage. \n\nhttps://github.com/pendle-finance/pendle-core-v2-public/blob/77b3630c82412b580bce6cd4a32f2c385bbb7970/contracts/core/StandardizedYield/implementations/KelpDAO/PendleRsETHSY.sol#L79\n\n[`TrancheRouter`](https://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/metapool-router/lib/v1-pool/src/TrancheRouter.sol#L39) (TrancheRouter calls Tranche) checks how many PT a user should receive\n\namount of PT issued indirectly depends on rsETH price. so, I think TrancheRouter prevents such unexpected slippage.\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol#L107-L109\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/BaseLSTAdapterUpgradeable.sol#L87\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/369",
  "Code": [
    {
      "filename": "napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {ILRTOracle} from \"./interfaces/ILRTOracle.sol\";\nimport {ILRTDepositPool} from \"./interfaces/ILRTDepositPool.sol\";\n\n// libs\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable@4.9.3/token/ERC20/IERC20Upgradeable.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice RsETHAdapter - eRsETH (Napier rsETH Adapter)\n/// @notice rsETH is a Liquid Restaked Token (LRT) issued by Kelp DAO designed\n/// to offer liquidity to illiquid assets deposited into restaking platforms,\n///  such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking\ncontract RsETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice LRTDepositPool\n    ILRTDepositPool constant RSETH_DEPOSIT_POOL = ILRTDepositPool(Constants.RSETH_DEPOSIT_POOL);\n\n    /// @notice LRTOracle\n    ILRTOracle constant RSETH_ORACLE = ILRTOracle(Constants.RSETH_ORACLE);\n\n    /// @notice rsETH\n    IERC20Upgradeable constant RSETH = IERC20Upgradeable(Constants.RSETH);\n\n    /// @notice RSETH referral id\n    string constant REFERRAL_ID = \"Napier-RsETHAdapter\";\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n    error MinAmountToDepositError();\n    error ProtocolPaused();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier rsETH Adapter\", \"eRsETH\");\n    }\n\n    /// @notice Claim withdrawal from Kelp\n    /// @dev Kelp doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Kelp allows ETH, ETHx, stETH or sfrxETH via LRTDepositPool.\n    /// @dev Kelp has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        // Check LRTDepositPool stake limit\n        uint256 stakeLimit = RSETH_DEPOSIT_POOL.getAssetCurrentLimit(Constants.ETH);\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n        // Check LRTDepositPool minAmountToDeposit\n        if (stakeAmount <= RSETH_DEPOSIT_POOL.minAmountToDeposit()) revert MinAmountToDepositError();\n        // Check paused of LRTDepositPool\n        if (RSETH_DEPOSIT_POOL.paused()) revert ProtocolPaused();\n\n        // Interact\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _rsETHAmt = RSETH.balanceOf(address(this));\n        RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(0, REFERRAL_ID);\n        _rsETHAmt = RSETH.balanceOf(address(this)) - _rsETHAmt;\n\n        if (_rsETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n        return $.totalQueueEth + $.bufferEth + (RSETH.balanceOf(address(this)) * RSETH_ORACLE.rsETHPrice()) / 1e18;\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {ILRTOracle} from \"./interfaces/ILRTOracle.sol\";\nimport {ILRTDepositPool} from \"./interfaces/ILRTDepositPool.sol\";\n\n// libs\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable@4.9.3/token/ERC20/IERC20Upgradeable.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice RsETHAdapter - eRsETH (Napier rsETH Adapter)\n/// @notice rsETH is a Liquid Restaked Token (LRT) issued by Kelp DAO designed\n/// to offer liquidity to illiquid assets deposited into restaking platforms,\n///  such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking\ncontract RsETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice LRTDepositPool\n    ILRTDepositPool constant RSETH_DEPOSIT_POOL = ILRTDepositPool(Constants.RSETH_DEPOSIT_POOL);\n\n    /// @notice LRTOracle\n    ILRTOracle constant RSETH_ORACLE = ILRTOracle(Constants.RSETH_ORACLE);\n\n    /// @notice rsETH\n    IERC20Upgradeable constant RSETH = IERC20Upgradeable(Constants.RSETH);\n\n    /// @notice RSETH referral id\n    string constant REFERRAL_ID = \"Napier-RsETHAdapter\";\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n    error MinAmountToDepositError();\n    error ProtocolPaused();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier rsETH Adapter\", \"eRsETH\");\n    }\n\n    /// @notice Claim withdrawal from Kelp\n    /// @dev Kelp doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Kelp allows ETH, ETHx, stETH or sfrxETH via LRTDepositPool.\n    /// @dev Kelp has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        // Check LRTDepositPool stake limit\n        uint256 stakeLimit = RSETH_DEPOSIT_POOL.getAssetCurrentLimit(Constants.ETH);\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n        // Check LRTDepositPool minAmountToDeposit\n        if (stakeAmount <= RSETH_DEPOSIT_POOL.minAmountToDeposit()) revert MinAmountToDepositError();\n        // Check paused of LRTDepositPool\n        if (RSETH_DEPOSIT_POOL.paused()) revert ProtocolPaused();\n\n        // Interact\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _rsETHAmt = RSETH.balanceOf(address(this));\n        RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(0, REFERRAL_ID);\n        _rsETHAmt = RSETH.balanceOf(address(this)) - _rsETHAmt;\n\n        if (_rsETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n        return $.totalQueueEth + $.bufferEth + (RSETH.balanceOf(address(this)) * RSETH_ORACLE.rsETHPrice()) / 1e18;\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {ILRTOracle} from \"./interfaces/ILRTOracle.sol\";\nimport {ILRTDepositPool} from \"./interfaces/ILRTDepositPool.sol\";\n\n// libs\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable@4.9.3/token/ERC20/IERC20Upgradeable.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice RsETHAdapter - eRsETH (Napier rsETH Adapter)\n/// @notice rsETH is a Liquid Restaked Token (LRT) issued by Kelp DAO designed\n/// to offer liquidity to illiquid assets deposited into restaking platforms,\n///  such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking\ncontract RsETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice LRTDepositPool\n    ILRTDepositPool constant RSETH_DEPOSIT_POOL = ILRTDepositPool(Constants.RSETH_DEPOSIT_POOL);\n\n    /// @notice LRTOracle\n    ILRTOracle constant RSETH_ORACLE = ILRTOracle(Constants.RSETH_ORACLE);\n\n    /// @notice rsETH\n    IERC20Upgradeable constant RSETH = IERC20Upgradeable(Constants.RSETH);\n\n    /// @notice RSETH referral id\n    string constant REFERRAL_ID = \"Napier-RsETHAdapter\";\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n    error MinAmountToDepositError();\n    error ProtocolPaused();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier rsETH Adapter\", \"eRsETH\");\n    }\n\n    /// @notice Claim withdrawal from Kelp\n    /// @dev Kelp doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Kelp allows ETH, ETHx, stETH or sfrxETH via LRTDepositPool.\n    /// @dev Kelp has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        // Check LRTDepositPool stake limit\n        uint256 stakeLimit = RSETH_DEPOSIT_POOL.getAssetCurrentLimit(Constants.ETH);\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n        // Check LRTDepositPool minAmountToDeposit\n        if (stakeAmount <= RSETH_DEPOSIT_POOL.minAmountToDeposit()) revert MinAmountToDepositError();\n        // Check paused of LRTDepositPool\n        if (RSETH_DEPOSIT_POOL.paused()) revert ProtocolPaused();\n\n        // Interact\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _rsETHAmt = RSETH.balanceOf(address(this));\n        RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(0, REFERRAL_ID);\n        _rsETHAmt = RSETH.balanceOf(address(this)) - _rsETHAmt;\n\n        if (_rsETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n        return $.totalQueueEth + $.bufferEth + (RSETH.balanceOf(address(this)) * RSETH_ORACLE.rsETHPrice()) / 1e18;\n    }\n}"
    },
    {
      "filename": "contracts/core/StandardizedYield/implementations/KelpDAO/PendleRsETHSY.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"../../SYBase.sol\";\nimport \"../../../../interfaces/IPExchangeRateOracle.sol\";\nimport \"../../../../interfaces/KelpDAO/IKelpDepositPool.sol\";\nimport \"../../../../interfaces/KelpDAO/IKelpLRTConfig.sol\";\nimport \"../../../../interfaces/Stader/IStaderStakeManager.sol\";\n\ncontract PendleRsETHSY is SYBase {\n    using ArrayLib for address[];\n\n    address public immutable rsETH;\n    address public immutable depositPool;\n    address public immutable staderStakeManager;\n    address public lrtConfig;\n\n    address public exchangeRateOracle;\n\n    address public immutable ETHx; // gas saving purpose only\n    address public immutable stETH; // gas saving purpose only\n\n    event SetNewExchangeRateOracle(address oracle);\n\n    constructor(\n        address _rsETH,\n        address _depositPool,\n        address _staderStakeManager,\n        address _exchangeRateOracle,\n        address _ETHx,\n        address _stETH\n    ) SYBase(\"SY Kelp rsETH\", \"SY-rsETH\", _rsETH) {\n        rsETH = _rsETH;\n        depositPool = _depositPool;\n        staderStakeManager = _staderStakeManager;\n        exchangeRateOracle = _exchangeRateOracle;\n        ETHx = _ETHx;\n        stETH = _stETH;\n\n        updateLrtConfigAddress();\n        safeApproveSupportedTokens();\n    }\n\n    function updateLrtConfigAddress() public {\n        lrtConfig = IKelpDepositPool(depositPool).lrtConfig();\n    }\n\n    function safeApproveSupportedTokens() public {\n        address[] memory assets = IKelpLRTConfig(lrtConfig).getSupportedAssetList();\n        for (uint256 i = 0; i < assets.length; ) {\n            _safeApproveInf(assets[i], depositPool);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    DEPOSIT/REDEEM USING BASE TOKENS\n    //////////////////////////////////////////////////////////////*/\n\n    function _deposit(\n        address tokenIn,\n        uint256 amountDeposited\n    ) internal virtual override returns (uint256 amountSharesOut) {\n        if (tokenIn == rsETH) {\n            amountSharesOut = amountDeposited;\n        } else {\n            if (tokenIn == NATIVE) {\n                (tokenIn, amountDeposited) = (\n                    ETHx,\n                    IStaderStakeManager(staderStakeManager).deposit{value: amountDeposited}(address(this))\n                );\n            }\n            uint256 preBalance = _selfBalance(rsETH);\n            IKelpDepositPool(depositPool).depositAsset(\n                tokenIn,\n                amountDeposited,\n                0,\n                \"c05f6902ec7c7434ceb666010c16a63a2e3995aad11f1280855b26402194346b\"\n            );\n            amountSharesOut = _selfBalance(rsETH) - preBalance;\n        }\n    }\n\n    function _redeem(\n        address receiver,\n        address /*tokenOut*/,\n        uint256 amountSharesToRedeem\n    ) internal virtual override returns (uint256) {\n        _transferOut(rsETH, receiver, amountSharesToRedeem);\n        return amountSharesToRedeem;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               EXCHANGE-RATE\n    //////////////////////////////////////////////////////////////*/\n\n    function exchangeRate() public view virtual override returns (uint256) {\n        return IPExchangeRateOracle(exchangeRateOracle).getExchangeRate();\n    }\n\n    function setExchangeRateOracle(address newOracle) external onlyOwner {\n        exchangeRateOracle = newOracle;\n        emit SetNewExchangeRateOracle(newOracle);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                MISC FUNCTIONS FOR METADATA\n    //////////////////////////////////////////////////////////////*/\n\n    function _previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) internal view override returns (uint256 amountSharesOut) {\n        if (tokenIn == rsETH) {\n            return amountTokenToDeposit;\n        }\n        if (tokenIn == NATIVE) {\n            (tokenIn, amountTokenToDeposit) = (\n                ETHx,\n                IStaderStakeManager(staderStakeManager).previewDeposit(amountTokenToDeposit)\n            );\n        }\n        return IKelpDepositPool(depositPool).getRsETHAmountToMint(tokenIn, amountTokenToDeposit);\n    }\n\n    function _previewRedeem(\n        address /*tokenOut*/,\n        uint256 amountSharesToRedeem\n    ) internal pure override returns (uint256 amountTokenOut) {\n        return amountSharesToRedeem;\n    }\n\n    function getTokensIn() public view virtual override returns (address[] memory) {\n        return ArrayLib.create(rsETH, NATIVE).merge(IKelpLRTConfig(lrtConfig).getSupportedAssetList());\n    }\n\n    function getTokensOut() public view virtual override returns (address[] memory) {\n        return ArrayLib.create(rsETH);\n    }\n\n    function isValidTokenIn(address token) public view virtual override returns (bool) {\n        return token == rsETH || token == NATIVE || token == ETHx || token == stETH || _isSupportedToken(token);\n    }\n\n    function isValidTokenOut(address token) public view virtual override returns (bool) {\n        return token == rsETH;\n    }\n\n    function _isSupportedToken(address token) internal view returns (bool) {\n        return IKelpLRTConfig(lrtConfig).isSupportedAsset(token);\n    }\n\n    function assetInfo() external pure returns (AssetType assetType, address assetAddress, uint8 assetDecimals) {\n        return (AssetType.TOKEN, NATIVE, 18);\n    }\n}"
    },
    {
      "filename": "metapool-router/lib/v1-pool/src/TrancheRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/src/interfaces/IWETH9.sol\";\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {ITrancheFactory} from \"@napier/v1-tranche/src/interfaces/ITrancheFactory.sol\";\nimport {ITranche} from \"@napier/v1-tranche/src/interfaces/ITranche.sol\";\nimport {ITrancheRouter} from \"./interfaces/ITrancheRouter.sol\";\n// libraries\nimport {SafeERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\";\nimport {TrancheAddress} from \"./libs/TrancheAddress.sol\";\nimport {Errors} from \"./libs/Errors.sol\";\n// inherits\nimport {PeripheryImmutableState} from \"./base/PeripheryImmutableState.sol\";\nimport {PeripheryPayments} from \"./base/PeripheryPayments.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\nimport {Multicallable} from \"./base/Multicallable.sol\";\n\n/// @notice Periphery contract for interacting with Tranches.\n/// @dev Accept native ETH and ERC20 tokens.\n/// @dev Multicallable is used to batch calls to `unwrapWETH9`.\ncontract TrancheRouter is ITrancheRouter, PeripheryPayments, ReentrancyGuard, Multicallable {\n    using SafeERC20 for IERC20;\n\n    /// @dev Tranches called by this router must be created by this factory\n    ITrancheFactory public immutable trancheFactory;\n\n    bytes32 internal immutable TRANCHE_CREATION_HASH;\n\n    constructor(ITrancheFactory _trancheFactory, IWETH9 _WETH9) PeripheryImmutableState(_WETH9) {\n        trancheFactory = _trancheFactory;\n        TRANCHE_CREATION_HASH = _trancheFactory.TRANCHE_CREATION_HASH();\n    }\n\n    /// @notice deposit an `underlyingAmount` of underlying token into the yield source, receiving PT and YT.\n    /// @dev Accept native ETH.\n    /// @inheritdoc ITrancheRouter\n    function issue(address adapter, uint256 maturity, uint256 underlyingAmount, address to, uint256 minIssuedAmount)\n        external\n        payable\n        nonReentrant\n        returns (uint256)\n    {\n        ITranche tranche =\n            TrancheAddress.computeAddress(adapter, maturity, TRANCHE_CREATION_HASH, address(trancheFactory));\n        IERC20 underlying = IERC20(tranche.underlying());\n\n        // Transfer underlying tokens to this contract\n        // If this contract holds enough ETH, wrap it. Otherwise, transfer from the caller.\n        if (address(underlying) == address(WETH9) && address(this).balance >= underlyingAmount) {\n            WETH9.deposit{value: underlyingAmount}();\n        } else {\n            underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);\n        }\n        // Force approve\n        underlying.forceApprove(address(tranche), underlyingAmount);\n\n        uint256 issued = tranche.issue(to, underlyingAmount);\n        if (issued < minIssuedAmount) revert Errors.RouterInsufficientPyIssue();\n        return issued;\n    }\n\n    /// @notice Withdraws underlying tokens from the caller in exchange for `pyAmount` of PT and YT.\n    /// @notice Approve this contract to spend `pyAmount` of PT.\n    /// @dev If caller want to withdraw ETH, specify `to` as the this contract's address and use `unwrapWETH9` with Multicall.\n    /// @inheritdoc ITrancheRouter\n    function redeemWithYT(address adapter, uint256 maturity, uint256 pyAmount, address to)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        ITranche tranche =\n            TrancheAddress.computeAddress(adapter, maturity, TRANCHE_CREATION_HASH, address(trancheFactory));\n        return tranche.redeemWithYT({from: msg.sender, to: to, pyAmount: pyAmount});\n    }\n\n    /// @notice Approve this contract to spend `principalAmount` of PT.\n    /// @dev If caller want to withdraw ETH, specify `to` as the this contract's address and use `unwrapWETH9` with Multicall.\n    /// @inheritdoc ITrancheRouter\n    function redeem(address adapter, uint256 maturity, uint256 principalAmount, address to)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        ITranche tranche =\n            TrancheAddress.computeAddress(adapter, maturity, TRANCHE_CREATION_HASH, address(trancheFactory));\n        return tranche.redeem({from: msg.sender, to: to, principalAmount: principalAmount});\n    }\n\n    /// @notice Approve this contract to spend `principalAmount` of PT.\n    /// @dev If caller want to withdraw ETH, specify `to` as the this contract's address and use `unwrapWETH9` with Multicall.\n    /// @inheritdoc ITrancheRouter\n    function withdraw(address adapter, uint256 maturity, uint256 underlyingAmount, address to)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        ITranche tranche =\n            TrancheAddress.computeAddress(adapter, maturity, TRANCHE_CREATION_HASH, address(trancheFactory));\n        return tranche.withdraw({from: msg.sender, to: to, underlyingAmount: underlyingAmount});\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {ILRTOracle} from \"./interfaces/ILRTOracle.sol\";\nimport {ILRTDepositPool} from \"./interfaces/ILRTDepositPool.sol\";\n\n// libs\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable@4.9.3/token/ERC20/IERC20Upgradeable.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice RsETHAdapter - eRsETH (Napier rsETH Adapter)\n/// @notice rsETH is a Liquid Restaked Token (LRT) issued by Kelp DAO designed\n/// to offer liquidity to illiquid assets deposited into restaking platforms,\n///  such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking\ncontract RsETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice LRTDepositPool\n    ILRTDepositPool constant RSETH_DEPOSIT_POOL = ILRTDepositPool(Constants.RSETH_DEPOSIT_POOL);\n\n    /// @notice LRTOracle\n    ILRTOracle constant RSETH_ORACLE = ILRTOracle(Constants.RSETH_ORACLE);\n\n    /// @notice rsETH\n    IERC20Upgradeable constant RSETH = IERC20Upgradeable(Constants.RSETH);\n\n    /// @notice RSETH referral id\n    string constant REFERRAL_ID = \"Napier-RsETHAdapter\";\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n    error MinAmountToDepositError();\n    error ProtocolPaused();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier rsETH Adapter\", \"eRsETH\");\n    }\n\n    /// @notice Claim withdrawal from Kelp\n    /// @dev Kelp doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Kelp allows ETH, ETHx, stETH or sfrxETH via LRTDepositPool.\n    /// @dev Kelp has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        // Check LRTDepositPool stake limit\n        uint256 stakeLimit = RSETH_DEPOSIT_POOL.getAssetCurrentLimit(Constants.ETH);\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n        // Check LRTDepositPool minAmountToDeposit\n        if (stakeAmount <= RSETH_DEPOSIT_POOL.minAmountToDeposit()) revert MinAmountToDepositError();\n        // Check paused of LRTDepositPool\n        if (RSETH_DEPOSIT_POOL.paused()) revert ProtocolPaused();\n\n        // Interact\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _rsETHAmt = RSETH.balanceOf(address(this));\n        RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(0, REFERRAL_ID);\n        _rsETHAmt = RSETH.balanceOf(address(this)) - _rsETHAmt;\n\n        if (_rsETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n        return $.totalQueueEth + $.bufferEth + (RSETH.balanceOf(address(this)) * RSETH_ORACLE.rsETHPrice()) / 1e18;\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/BaseLSTAdapterUpgradeable.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {StakeLimitTypes, StakeLimitUtils} from \"@napier/v1-tranche/utils/StakeLimitUtils.sol\";\nimport {LSTAdapterStorage} from \"../Structs.sol\";\nimport {WETH} from \"../Constants.sol\";\n\nimport {BaseLSTVaultUpgradeable} from \"./BaseLSTVaultUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable@4.9.3/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapterUpgradeable is BaseLSTVaultUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeCast for uint256;\n    using StakeLimitTypes for StakeLimitTypes.Uint256Data;\n    using StakeLimitTypes for StakeLimitTypes.Data;\n    using StakeLimitUtils for StakeLimitTypes.Data;\n\n    error WithdrawalPending();\n    error InvalidWithdrawalAmount();\n    error NoPendingWithdrawal();\n\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    event StakingPaused();\n    event StakingUnpaused();\n    event ClaimWithdrawal(uint256 requestId, uint256 queueAmount);\n    event RequestWithdrawal(uint256 requestId, uint256 queueAmount);\n\n    /// @dev Adapter itself is the target token\n    function __BaseLSTAdapter_init(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __BaseLSTVault_init(_owner);\n\n        LSTAdapterStorage storage $ = _getStorage();\n        $.rebalancer = _rebalancer;\n        $.targetBufferPercentage = 0.1 * 1e18; // 10% desired buffer percentage\n\n        // Set the initial stake limit state\n        StakeLimitTypes.Data memory data = StakeLimitTypes.Data({\n            prevStakeBlockNumber: uint32(block.number),\n            prevStakeLimit: 0,\n            maxStakeLimitGrowthBlocks: 0,\n            maxStakeLimit: 0\n        });\n        $.packedStakeLimitData.setStorageStakeLimitStruct(\n            data.setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIEW METHOD\n    ////////////////////////////////////////////////////////\n\n    function totalQueueEth() public view returns (uint256) {\n        return _getStorage().totalQueueEth;\n    }\n\n    function bufferEth() public view returns (uint256) {\n        return _getStorage().bufferEth;\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant onlyTranche returns (uint256, uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 bufferEthCache = $.bufferEth; // cache storage reads\n        uint256 queueEthCache = $.totalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (totalQueueEth + bufferEth + assets - s) / (totalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (totalQueueEth + bufferEth + assets) - (totalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (totalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < b"
    }
  ]
}