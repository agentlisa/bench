{
  "Title": "Invalid aggregate signature [samples]",
  "Content": "The `BLSSignatureAggregator` exposes a mechanism to let the bundler [validate individual signatures](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L123) before constructing the bundle. Successful operations are grouped so the bundler can [combine their signatures](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L143) off-chain and the `EntryPoint` can [validate them together](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L142) on-chain. However, it is possible for an account to construct an operation that will pass the individual-signature check and still fail the combined-signature check.\n\n\nIn particular, if the public key it exposes [during the individual validation](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L126) is different from the one used [during the combined validation](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L60), the two validations will be inconsistent even though the signature is the same. This could occur if the [last 4 words of the `initCode`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L23) do not match the public key (because the `initCode` has additional data, or if they do not use the [expected creation function](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccountFactory.sol#L29)). It could also occur if the [user’s validation function](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L135) (which is not invoked during the individual signature validation) changes the public key that is returned by `getBlsPublicKey`.\n\n\nIf a bundler constructs a bundle with these operations, it will be unable to validate the combined signature and will attribute the fault to the aggregator, which will cause the aggregator to be throttled and user operations with the same aggregator will not be processed.\n\n\nConsider synchronizing the two validation functions so they both use the same public key.\n\n\n***Update:** Resolved in [pull request #195](https://github.com/eth-infinitism/account-abstraction/pull/195) as well as commit [`268f103`](https://github.com/eth-infinitism/account-abstraction/pull/216/commits/268f103597c0406ba2595cf18d3d5a5473b9c7b9) of [pull request #216](https://github.com/eth-infinitism/account-abstraction/pull/216), which were merged at commits [`1cc1c97`](https://github.com/eth-infinitism/account-abstraction/commit/1cc1c97a00131a7922d1ccebd823e81e823b5d9f) and [`1f505c5`](https://github.com/eth-infinitism/account-abstraction/commit/1f505c5889b04a115b1bf09386c0b84cecdad5c4) respectively.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/bls/BLSSignatureAggregator.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4 <0.9.0;\npragma abicoder v2;\n\nimport \"../interfaces/IAggregator.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport {BLSOpen} from  \"./lib/BLSOpen.sol\";\nimport \"./IBLSAccount.sol\";\nimport \"./BLSHelper.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * A BLS-based signature aggregator, to validate aggregated signature of multiple UserOps if BLSAccount\n */\ncontract BLSSignatureAggregator is IAggregator {\n    using UserOperationLib for UserOperation;\n\n    bytes32 public constant BLS_DOMAIN = keccak256(\"eip4337.bls.domain\");\n\n    function getUserOpPublicKey(UserOperation memory userOp) public view returns (uint256[4] memory publicKey) {\n        bytes memory initCode = userOp.initCode;\n        if (initCode.length > 0) {\n            publicKey = getTrailingPublicKey(initCode);\n        } else {\n            return IBLSAccount(userOp.sender).getBlsPublicKey();\n        }\n    }\n\n    /**\n     * return the trailing 4 words of input data\n     */\n    function getTrailingPublicKey(bytes memory data) public pure returns (uint256[4] memory publicKey) {\n        uint len = data.length;\n        require(len > 32 * 4, \"data to short for sig\");\n\n        /* solhint-disable-next-line no-inline-assembly */\n        assembly {\n        // actual buffer starts at data+32, so last 128 bytes start at data+32+len-128 = data+len-96\n            let ofs := sub(add(data, len), 96)\n            mstore(publicKey, mload(ofs))\n            mstore(add(publicKey, 32), mload(add(ofs, 32)))\n            mstore(add(publicKey, 64), mload(add(ofs, 64)))\n            mstore(add(publicKey, 96), mload(add(ofs, 96)))\n        }\n    }\n\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature)\n    external view override {\n        require(signature.length == 64, \"BLS: invalid signature\");\n        (uint256[2] memory blsSignature) = abi.decode(signature, (uint256[2]));\n\n        uint userOpsLen = userOps.length;\n        uint256[4][] memory blsPublicKeys = new uint256[4][](userOpsLen);\n        uint256[2][] memory messages = new uint256[2][](userOpsLen);\n        for (uint256 i = 0; i < userOpsLen; i++) {\n\n            UserOperation memory userOp = userOps[i];\n            IBLSAccount blsAccount = IBLSAccount(userOp.sender);\n\n            blsPublicKeys[i] = blsAccount.getBlsPublicKey{gas : 30000}();\n\n            messages[i] = _userOpToMessage(userOp, keccak256(abi.encode(blsPublicKeys[i])));\n        }\n        require(BLSOpen.verifyMultiple(blsSignature, blsPublicKeys, messages), \"BLS: validateSignatures failed\");\n    }\n\n    /**\n     * get a hash of userOp\n     * NOTE: this hash is not the same as UserOperation.hash()\n     *  (slightly less efficient, since it uses memory userOp)\n     */\n    function internalUserOpHash(UserOperation memory userOp) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                userOp.sender,\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas,\n                keccak256(userOp.paymasterAndData)\n            ));\n    }\n\n    /**\n     * return the BLS \"message\" for the given UserOp.\n     * the account checks the signature over this value  using its public-key\n     */\n    function userOpToMessage(UserOperation memory userOp) public view returns (uint256[2] memory) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _userOpToMessage(userOp, hashPublicKey);\n    }\n\n    function _userOpToMessage(UserOperation memory userOp, bytes32 publicKeyHash) internal view returns (uint256[2] memory) {\n        bytes32 userOpHash = _getUserOpHash(userOp, publicKeyHash);\n        return BLSOpen.hashToPoint(BLS_DOMAIN, abi.encodePacked(userOpHash));\n    }\n\n    //return the public-key hash of a userOp.\n    function _getUserOpPubkeyHash(UserOperation memory userOp) internal view returns (bytes32 hashPublicKey) {\n        return keccak256(abi.encode(getUserOpPublicKey(userOp)));\n    }\n\n    function getUserOpHash(UserOperation memory userOp) public view returns (bytes32) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _getUserOpHash(userOp, hashPublicKey);\n    }\n\n    function _getUserOpHash(UserOperation memory userOp, bytes32 hashPublicKey) internal view returns (bytes32) {\n        return keccak256(abi.encode(internalUserOpHash(userOp), hashPublicKey, address(this), block.chainid));\n    }\n\n    /**\n     * validate signature of a single userOp\n     * This method is called after EntryPoint.simulateUserOperation() returns an aggregator.\n     * First it validates the signature over the userOp. then it return data to be used when creating the handleOps:\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(UserOperation calldata userOp)\n    external view returns (bytes memory sigForUserOp) {\n        uint256[2] memory signature = abi.decode(userOp.signature, (uint256[2]));\n        uint256[4] memory pubkey = getUserOpPublicKey(userOp);\n        uint256[2] memory message = userOpToMessage(userOp);\n\n        require(BLSOpen.verifySingle(signature, pubkey, message), \"BLS: wrong sig\");\n        return \"\";\n    }\n\n    //copied from BLS.sol\n    uint256 public  constant N = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatesSignature the aggregated signature\n     */\n    function aggregateSignatures(UserOperation[] calldata userOps) external pure returns (bytes memory aggregatesSignature) {\n        BLSHelper.XY[] memory points = new BLSHelper.XY[](userOps.length);\n        for (uint i = 0; i < points.length; i++) {\n            (uint x, uint y) = abi.decode(userOps[i].signature, (uint, uint));\n            points[i] = BLSHelper.XY(x, y);\n        }\n        BLSHelper.XY memory sum = BLSHelper.sum(points, N);\n        return abi.encode(sum.x, sum.y);\n    }\n\n    /**\n     * allow staking for this aggregator\n     * there is no limit on stake  or delay, but it is not a problem, since it is a permissionless\n     * signature aggregator, which doesn't support unstaking.\n     */\n    function addStake(IEntryPoint entryPoint, uint32 delay) external payable {\n        entryPoint.addStake{value : msg.value}(delay);\n    }\n}"
    },
    {
      "filename": "contracts/bls/BLSSignatureAggregator.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4 <0.9.0;\npragma abicoder v2;\n\nimport \"../interfaces/IAggregator.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport {BLSOpen} from  \"./lib/BLSOpen.sol\";\nimport \"./IBLSAccount.sol\";\nimport \"./BLSHelper.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * A BLS-based signature aggregator, to validate aggregated signature of multiple UserOps if BLSAccount\n */\ncontract BLSSignatureAggregator is IAggregator {\n    using UserOperationLib for UserOperation;\n\n    bytes32 public constant BLS_DOMAIN = keccak256(\"eip4337.bls.domain\");\n\n    function getUserOpPublicKey(UserOperation memory userOp) public view returns (uint256[4] memory publicKey) {\n        bytes memory initCode = userOp.initCode;\n        if (initCode.length > 0) {\n            publicKey = getTrailingPublicKey(initCode);\n        } else {\n            return IBLSAccount(userOp.sender).getBlsPublicKey();\n        }\n    }\n\n    /**\n     * return the trailing 4 words of input data\n     */\n    function getTrailingPublicKey(bytes memory data) public pure returns (uint256[4] memory publicKey) {\n        uint len = data.length;\n        require(len > 32 * 4, \"data to short for sig\");\n\n        /* solhint-disable-next-line no-inline-assembly */\n        assembly {\n        // actual buffer starts at data+32, so last 128 bytes start at data+32+len-128 = data+len-96\n            let ofs := sub(add(data, len), 96)\n            mstore(publicKey, mload(ofs))\n            mstore(add(publicKey, 32), mload(add(ofs, 32)))\n            mstore(add(publicKey, 64), mload(add(ofs, 64)))\n            mstore(add(publicKey, 96), mload(add(ofs, 96)))\n        }\n    }\n\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature)\n    external view override {\n        require(signature.length == 64, \"BLS: invalid signature\");\n        (uint256[2] memory blsSignature) = abi.decode(signature, (uint256[2]));\n\n        uint userOpsLen = userOps.length;\n        uint256[4][] memory blsPublicKeys = new uint256[4][](userOpsLen);\n        uint256[2][] memory messages = new uint256[2][](userOpsLen);\n        for (uint256 i = 0; i < userOpsLen; i++) {\n\n            UserOperation memory userOp = userOps[i];\n            IBLSAccount blsAccount = IBLSAccount(userOp.sender);\n\n            blsPublicKeys[i] = blsAccount.getBlsPublicKey{gas : 30000}();\n\n            messages[i] = _userOpToMessage(userOp, keccak256(abi.encode(blsPublicKeys[i])));\n        }\n        require(BLSOpen.verifyMultiple(blsSignature, blsPublicKeys, messages), \"BLS: validateSignatures failed\");\n    }\n\n    /**\n     * get a hash of userOp\n     * NOTE: this hash is not the same as UserOperation.hash()\n     *  (slightly less efficient, since it uses memory userOp)\n     */\n    function internalUserOpHash(UserOperation memory userOp) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                userOp.sender,\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas,\n                keccak256(userOp.paymasterAndData)\n            ));\n    }\n\n    /**\n     * return the BLS \"message\" for the given UserOp.\n     * the account checks the signature over this value  using its public-key\n     */\n    function userOpToMessage(UserOperation memory userOp) public view returns (uint256[2] memory) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _userOpToMessage(userOp, hashPublicKey);\n    }\n\n    function _userOpToMessage(UserOperation memory userOp, bytes32 publicKeyHash) internal view returns (uint256[2] memory) {\n        bytes32 userOpHash = _getUserOpHash(userOp, publicKeyHash);\n        return BLSOpen.hashToPoint(BLS_DOMAIN, abi.encodePacked(userOpHash));\n    }\n\n    //return the public-key hash of a userOp.\n    function _getUserOpPubkeyHash(UserOperation memory userOp) internal view returns (bytes32 hashPublicKey) {\n        return keccak256(abi.encode(getUserOpPublicKey(userOp)));\n    }\n\n    function getUserOpHash(UserOperation memory userOp) public view returns (bytes32) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _getUserOpHash(userOp, hashPublicKey);\n    }\n\n    function _getUserOpHash(UserOperation memory userOp, bytes32 hashPublicKey) internal view returns (bytes32) {\n        return keccak256(abi.encode(internalUserOpHash(userOp), hashPublicKey, address(this), block.chainid));\n    }\n\n    /**\n     * validate signature of a single userOp\n     * This method is called after EntryPoint.simulateUserOperation() returns an aggregator.\n     * First it validates the signature over the userOp. then it return data to be used when creating the handleOps:\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(UserOperation calldata userOp)\n    external view returns (bytes memory sigForUserOp) {\n        uint256[2] memory signature = abi.decode(userOp.signature, (uint256[2]));\n        uint256[4] memory pubkey = getUserOpPublicKey(userOp);\n        uint256[2] memory message = userOpToMessage(userOp);\n\n        require(BLSOpen.verifySingle(signature, pubkey, message), \"BLS: wrong sig\");\n        return \"\";\n    }\n\n    //copied from BLS.sol\n    uint256 public  constant N = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatesSignature the aggregated signature\n     */\n    function aggregateSignatures(UserOperation[] calldata userOps) external pure returns (bytes memory aggregatesSignature) {\n        BLSHelper.XY[] memory points = new BLSHelper.XY[](userOps.length);\n        for (uint i = 0; i < points.length; i++) {\n            (uint x, uint y) = abi.decode(userOps[i].signature, (uint, uint));\n            points[i] = BLSHelper.XY(x, y);\n        }\n        BLSHelper.XY memory sum = BLSHelper.sum(points, N);\n        return abi.encode(sum.x, sum.y);\n    }\n\n    /**\n     * allow staking for this aggregator\n     * there is no limit on stake  or delay, but it is not a problem, since it is a permissionless\n     * signature aggregator, which doesn't support unstaking.\n     */\n    function addStake(IEntryPoint entryPoint, uint32 delay) external payable {\n        entryPoint.addStake{value : msg.value}(delay);\n    }\n}"
    }
  ]
}