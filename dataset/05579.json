{
  "Title": "[M-11] Test addresses and incorrect interface in code prevent integration with UniswapV3 and Camelot",
  "Content": "\nTesting addresses for Camelot and UniswapV3 factories are still used in the code:\n\n[CamelotRelayer.sol#L20](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/oracles/CamelotRelayer.sol#L20)\n\n```solidity\n  address internal constant _CAMELOT_FACTORY = GOERLI_CAMELOT_V3_FACTORY;\n```\n\n[UniV3Relayer.sol#L18](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/oracles/UniV3Relayer.sol#L18)\n\n```solidity\n  address internal constant _UNI_V3_FACTORY = GOERLI_UNISWAP_V3_FACTORY;\n```\n\nAdditionally, the correct interface to get the `camelotPair` is commented out:\n\n[CamelotRelayer.sol#L41-L42](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/oracles/CamelotRelayer.sol#L41-L42)\n\n```solidity\n    // camelotPair = ICamelotFactory(_CAMELOT_FACTORY).getPair(_baseToken, _quoteToken);\n    camelotPair = IAlgebraFactory(_CAMELOT_FACTORY).poolByPair(_baseToken, _quoteToken);\n```\n\n### Impact\n\nIt will prevent integration with UniswapV3 and Camelot.\n\n### Recommended Mitigation Steps\n\nMake the changes necessary to be compatible with Arbitrum One.\n\n**[MiloTruck (Judge) commented](https://github.com/code-423n4/2023-10-opendollar-findings/issues/187#issuecomment-1790139769):**\n > While the protocol team is most likely aware of this and these addresses are probably set to testnet ones currently for testing purposes, it is an undeniable fact that if the current code was to be deployed without any modifications, the `CamelotRelayer` and `UniV3Relayer` contracts would not function as expected.\n> \n> As such, I believe medium severity is appropriate.\n\n**[pi0neerpat (OpenDollar) commented](https://github.com/code-423n4/2023-10-opendollar-findings/issues/187#issuecomment-1805211162):**\n > The problem stated is that the Camelot and Uniswap factory addresses set in the Registry are set to Goerli addresses, not Mainnet. In production, we will swap Goerli addresses for Mainnet. Perhaps there is a better way to manage this than manually changing the constant variable in the Registry, however the recommendation does provide a helpful suggestion.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/oracles/CamelotRelayer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {IBaseOracle} from '@interfaces/oracles/IBaseOracle.sol';\nimport {ICamelotRelayer} from '@interfaces/oracles/ICamelotRelayer.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\n// import {ICamelotFactory} from '@camelot/interfaces/ICamelotFactory.sol';\nimport {IAlgebraFactory} from '@interfaces/factories/IAlgebraFactory.sol';\nimport {ICamelotPair} from '@camelot/interfaces/ICamelotPair.sol';\nimport {OracleLibrary} from '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport {CAMELOT_V3_FACTORY, GOERLI_CAMELOT_V3_FACTORY} from '@script/Registry.s.sol';\n\n/**\n * @title  CamelotRelayer\n * @notice This contracts consults a CamelotRelayer TWAP and transforms the result into a standard IBaseOracle feed\n * @dev    The quote obtained from the pool query is transformed into an 18 decimals format\n */\ncontract CamelotRelayer is IBaseOracle, ICamelotRelayer {\n  // --- Registry ---\n  address internal constant _CAMELOT_FACTORY = GOERLI_CAMELOT_V3_FACTORY;\n\n  /// @inheritdoc ICamelotRelayer\n  address public camelotPair;\n  /// @inheritdoc ICamelotRelayer\n  address public baseToken;\n  /// @inheritdoc ICamelotRelayer\n  address public quoteToken;\n\n  // --- Data ---\n  /// @inheritdoc IBaseOracle\n  string public symbol;\n\n  /// @inheritdoc ICamelotRelayer\n  uint128 public baseAmount;\n  /// @inheritdoc ICamelotRelayer\n  uint256 public multiplier;\n  /// @inheritdoc ICamelotRelayer\n  uint32 public quotePeriod;\n\n  constructor(address _baseToken, address _quoteToken, uint32 _quotePeriod) {\n    // camelotPair = ICamelotFactory(_CAMELOT_FACTORY).getPair(_baseToken, _quoteToken);\n    camelotPair = IAlgebraFactory(_CAMELOT_FACTORY).poolByPair(_baseToken, _quoteToken);\n    if (camelotPair == address(0)) revert CamelotRelayer_InvalidPool();\n\n    address _token0 = ICamelotPair(camelotPair).token0();\n    address _token1 = ICamelotPair(camelotPair).token1();\n\n    // The factory validates that both token0 and token1 are desired baseToken and quoteTokens\n    if (_token0 == _baseToken) {\n      baseToken = _token0;\n      quoteToken = _token1;\n    } else {\n      baseToken = _token1;\n      quoteToken = _token0;\n    }\n\n    baseAmount = uint128(10 ** IERC20Metadata(_baseToken).decimals());\n    multiplier = 18 - IERC20Metadata(_quoteToken).decimals();\n    quotePeriod = _quotePeriod;\n\n    symbol = string(abi.encodePacked(IERC20Metadata(_baseToken).symbol(), ' / ', IERC20Metadata(_quoteToken).symbol()));\n  }\n\n  /**\n   * @dev    Method will return invalid if the pool doesn't have enough history\n   * @inheritdoc IBaseOracle\n   */\n  function getResultWithValidity() external view returns (uint256 _result, bool _validity) {\n    // If the pool doesn't have enough history return false\n    if (OracleLibrary.getOldestObservationSecondsAgo(camelotPair) < quotePeriod) {\n      return (0, false);\n    }\n    // Consult the query with a TWAP period of quotePeriod\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(camelotPair, quotePeriod);\n    // Calculate the quote amount\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    // Process the quote result to 18 decimal quote\n    _result = _parseResult(_quoteAmount);\n    _validity = true;\n  }\n\n  /**\n   * @dev    This method may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n   * @inheritdoc IBaseOracle\n   */\n  function read() external view returns (uint256 _result) {\n    // This call may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(camelotPair, quotePeriod);\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    _result = _parseResult(_quoteAmount);\n  }\n\n  function _parseResult(uint256 _quoteResult) internal view returns (uint256 _result) {\n    return _quoteResult * 10 ** multiplier;\n  }\n}"
    },
    {
      "filename": "src/contracts/oracles/UniV3Relayer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {IBaseOracle} from '@interfaces/oracles/IBaseOracle.sol';\nimport {IUniV3Relayer} from '@interfaces/oracles/IUniV3Relayer.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IUniswapV3Factory} from '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport {OracleLibrary, IUniswapV3Pool} from '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport {UNISWAP_V3_FACTORY, GOERLI_UNISWAP_V3_FACTORY} from '@script/Registry.s.sol';\n\n/**\n * @title  UniV3Relayer\n * @notice This contracts consults a UniswapV3Pool TWAP and transforms the result into a standard IBaseOracle feed\n * @dev    The quote obtained from the pool query is transformed into an 18 decimals format\n */\ncontract UniV3Relayer is IBaseOracle, IUniV3Relayer {\n  // --- Registry ---\n  address internal constant _UNI_V3_FACTORY = GOERLI_UNISWAP_V3_FACTORY;\n\n  /// @inheritdoc IUniV3Relayer\n  address public uniV3Pool;\n  /// @inheritdoc IUniV3Relayer\n  address public baseToken;\n  /// @inheritdoc IUniV3Relayer\n  address public quoteToken;\n\n  // --- Data ---\n\n  /// @inheritdoc IBaseOracle\n  string public symbol;\n\n  /// @inheritdoc IUniV3Relayer\n  uint128 public baseAmount;\n  /// @inheritdoc IUniV3Relayer\n  uint256 public multiplier;\n  /// @inheritdoc IUniV3Relayer\n  uint32 public quotePeriod;\n\n  // --- Init ---\n\n  /**\n   * @param  _baseToken Address of the base token used to consult the quote\n   * @param  _quoteToken Address of the token used as a quote reference\n   * @param  _feeTier Fee tier of the pool used to consult the quote\n   * @param  _quotePeriod Length in seconds of the TWAP used to consult the pool\n   */\n  constructor(address _baseToken, address _quoteToken, uint24 _feeTier, uint32 _quotePeriod) {\n    uniV3Pool = IUniswapV3Factory(_UNI_V3_FACTORY).getPool(_baseToken, _quoteToken, _feeTier);\n    if (uniV3Pool == address(0)) revert UniV3Relayer_InvalidPool();\n\n    address _token0 = IUniswapV3Pool(uniV3Pool).token0();\n    address _token1 = IUniswapV3Pool(uniV3Pool).token1();\n\n    // The factory validates that both token0 and token1 are desired baseToken and quoteTokens\n    if (_token0 == _baseToken) {\n      baseToken = _token0;\n      quoteToken = _token1;\n    } else {\n      baseToken = _token1;\n      quoteToken = _token0;\n    }\n\n    baseAmount = uint128(10 ** IERC20Metadata(_baseToken).decimals());\n    multiplier = 18 - IERC20Metadata(_quoteToken).decimals();\n    quotePeriod = _quotePeriod;\n\n    symbol = string(abi.encodePacked(IERC20Metadata(_baseToken).symbol(), ' / ', IERC20Metadata(_quoteToken).symbol()));\n  }\n\n  /**\n   * @dev    Method will return invalid if the pool doesn't have enough history\n   * @inheritdoc IBaseOracle\n   */\n  function getResultWithValidity() external view returns (uint256 _result, bool _validity) {\n    // If the pool doesn't have enough history return false\n    if (OracleLibrary.getOldestObservationSecondsAgo(uniV3Pool) < quotePeriod) {\n      return (0, false);\n    }\n    // Consult the query with a TWAP period of quotePeriod\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(uniV3Pool, quotePeriod);\n    // Calculate the quote amount\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    // Process the quote result to 18 decimal quote\n    _result = _parseResult(_quoteAmount);\n    _validity = true;\n  }\n\n  /**\n   * @dev    This method may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n   * @inheritdoc IBaseOracle\n   */\n  function read() external view returns (uint256 _result) {\n    // This call may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(uniV3Pool, quotePeriod);\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    _result = _parseResult(_quoteAmount);\n  }\n\n  /// @notice Parses the result from the aggregator into 18 decimals format\n  function _parseResult(uint256 _quoteResult) internal view returns (uint256 _result) {\n    return _quoteResult * 10 ** multiplier;\n  }\n}"
    },
    {
      "filename": "src/contracts/oracles/CamelotRelayer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {IBaseOracle} from '@interfaces/oracles/IBaseOracle.sol';\nimport {ICamelotRelayer} from '@interfaces/oracles/ICamelotRelayer.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\n// import {ICamelotFactory} from '@camelot/interfaces/ICamelotFactory.sol';\nimport {IAlgebraFactory} from '@interfaces/factories/IAlgebraFactory.sol';\nimport {ICamelotPair} from '@camelot/interfaces/ICamelotPair.sol';\nimport {OracleLibrary} from '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport {CAMELOT_V3_FACTORY, GOERLI_CAMELOT_V3_FACTORY} from '@script/Registry.s.sol';\n\n/**\n * @title  CamelotRelayer\n * @notice This contracts consults a CamelotRelayer TWAP and transforms the result into a standard IBaseOracle feed\n * @dev    The quote obtained from the pool query is transformed into an 18 decimals format\n */\ncontract CamelotRelayer is IBaseOracle, ICamelotRelayer {\n  // --- Registry ---\n  address internal constant _CAMELOT_FACTORY = GOERLI_CAMELOT_V3_FACTORY;\n\n  /// @inheritdoc ICamelotRelayer\n  address public camelotPair;\n  /// @inheritdoc ICamelotRelayer\n  address public baseToken;\n  /// @inheritdoc ICamelotRelayer\n  address public quoteToken;\n\n  // --- Data ---\n  /// @inheritdoc IBaseOracle\n  string public symbol;\n\n  /// @inheritdoc ICamelotRelayer\n  uint128 public baseAmount;\n  /// @inheritdoc ICamelotRelayer\n  uint256 public multiplier;\n  /// @inheritdoc ICamelotRelayer\n  uint32 public quotePeriod;\n\n  constructor(address _baseToken, address _quoteToken, uint32 _quotePeriod) {\n    // camelotPair = ICamelotFactory(_CAMELOT_FACTORY).getPair(_baseToken, _quoteToken);\n    camelotPair = IAlgebraFactory(_CAMELOT_FACTORY).poolByPair(_baseToken, _quoteToken);\n    if (camelotPair == address(0)) revert CamelotRelayer_InvalidPool();\n\n    address _token0 = ICamelotPair(camelotPair).token0();\n    address _token1 = ICamelotPair(camelotPair).token1();\n\n    // The factory validates that both token0 and token1 are desired baseToken and quoteTokens\n    if (_token0 == _baseToken) {\n      baseToken = _token0;\n      quoteToken = _token1;\n    } else {\n      baseToken = _token1;\n      quoteToken = _token0;\n    }\n\n    baseAmount = uint128(10 ** IERC20Metadata(_baseToken).decimals());\n    multiplier = 18 - IERC20Metadata(_quoteToken).decimals();\n    quotePeriod = _quotePeriod;\n\n    symbol = string(abi.encodePacked(IERC20Metadata(_baseToken).symbol(), ' / ', IERC20Metadata(_quoteToken).symbol()));\n  }\n\n  /**\n   * @dev    Method will return invalid if the pool doesn't have enough history\n   * @inheritdoc IBaseOracle\n   */\n  function getResultWithValidity() external view returns (uint256 _result, bool _validity) {\n    // If the pool doesn't have enough history return false\n    if (OracleLibrary.getOldestObservationSecondsAgo(camelotPair) < quotePeriod) {\n      return (0, false);\n    }\n    // Consult the query with a TWAP period of quotePeriod\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(camelotPair, quotePeriod);\n    // Calculate the quote amount\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    // Process the quote result to 18 decimal quote\n    _result = _parseResult(_quoteAmount);\n    _validity = true;\n  }\n\n  /**\n   * @dev    This method may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n   * @inheritdoc IBaseOracle\n   */\n  function read() external view returns (uint256 _result) {\n    // This call may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(camelotPair, quotePeriod);\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    _result = _parseResult(_quoteAmount);\n  }\n\n  function _parseResult(uint256 _quoteResult) internal view returns (uint256 _result) {\n    return _quoteResult * 10 ** multiplier;\n  }\n}"
    }
  ]
}