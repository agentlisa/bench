{
  "Title": "[M01] The selectedApplications array is not enforced",
  "Content": "The [`currentList` and `previousList` arrays in the `selectedApplications` struct](https://github.com/propsproject/props-token-distribution/blob/e5ce0b2df1fbe108458d86820da578db56ac28d1/contracts/token/PropsRewardsLib.sol#L42-L43) are controlled by the `controller` and are used to set the list of applications that are able to receive rewards. However, these arrays are never checked when rewards are being distributed. It is possible for validators to distribute rewards to applications that are not included in the `selectedApplications` arrays. Consider requiring that all applications are included in the appropriate array in the `selectedApplications` struct for a `rewardsHash` to be valid.\n\n\n*Update: Fixed in [9ab4ec4](https://github.com/propsproject/props-token-distribution/commit/9ab4ec461759c4a5753f25a45d45d5c1a55c3ad2). A check was added to the `_rewardsHashIsValid` function enforcing that an application is in the appropriate array in the `selectedApplications` struct.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/token/PropsRewardsLib.sol",
      "content": "pragma solidity ^0.4.24;\n\nimport \"openzeppelin-eth/contracts/math/SafeMath.sol\";\n\n/**\n * @title Props Rewards Library\n * @dev Library to manage application and validators and parameters\n **/\nlibrary PropsRewardsLib {\n    using SafeMath for uint256;\n    /*\n    *  Events\n    */\n\n    /*\n    *  Storage\n    */\n\n    // The various parameters used by the contract\n    enum ParameterName { ApplicationRewardsPercent, ApplicationRewardsMaxVariationPercent, ValidatorMajorityPercent, ValidatorRewardsPercent}\n    enum RewardedEntityType { Application, Validator }\n\n    // Represents a parameter current, previous and time of change\n    struct Parameter {\n        uint256 currentValue;                   // current value in Pphm valid after timestamp\n        uint256 previousValue;                  // previous value in Pphm for use before timestamp\n        uint256 rewardsDay;                     // timestamp of when the value was updated\n    }\n    // Represents application details\n    struct RewardedEntity {\n        bytes32 name;                           // Application name\n        address rewardsAddress;                 // address where rewards will be minted to\n        address sidechainAddress;               // address used on the sidechain\n        bool isInitializedState;                // A way to check if there's something in the map and whether it is already added to the list\n        RewardedEntityType entityType;          // Type of rewarded entity\n    }\n\n    // Represents validators current and previous lists\n    struct RewardedEntityList {\n        mapping (address => bool) current;\n        mapping (address => bool) previous;\n        address[] currentList;\n        address[] previousList;\n        uint256 rewardsDay;\n    }\n\n    // Represents daily rewards submissions and confirmations\n    struct DailyRewards {\n        mapping (bytes32 => Submission) submissions;\n        bytes32[] submittedRewardsHashes;\n        uint256 totalSupply;\n        bytes32 lastConfirmedRewardsHash;\n        uint256 lastRewardsDay;\n    }\n\n    struct Submission {\n        mapping (address => bool) validators;\n        address[] validatorsList;\n        uint256 confirmations;\n        uint256 finalized;\n        bool isInitializedState;               // A way to check if there's something in the map and whether it is already added to the list\n    }\n\n\n    // represent the storage structures\n    struct Data {\n        // applications data\n        mapping (address => RewardedEntity) applications;\n        address[] applicationsList;\n        // validators data\n        mapping (address => RewardedEntity) validators;\n        address[] validatorsList;\n        // adjustable parameters data\n        mapping (uint256 => Parameter) parameters; // uint256 is the parameter enum index\n        // the participating validators\n        RewardedEntityList selectedValidators;\n        // the participating applications\n        RewardedEntityList selectedApplications;\n        // daily rewards submission data\n        DailyRewards dailyRewards;\n        uint256 minSecondsBetweenDays;\n        uint256 rewardsStartTimestamp;\n        uint256 maxTotalSupply;\n        uint256 lastRewardsDay;\n    }\n    /*\n    *  Modifiers\n    */\n    modifier onlyOneRewardsHashPerValidator(Data storage _self, bytes32 _rewardsHash) {\n        require(\n            !_self.dailyRewards.submissions[_rewardsHash].validators[msg.sender],\n            \"Must be one submission per validator\"\n        );\n         _;\n    }\n\n    modifier onlyExistingApplications(Data storage _self, address[] _entities) {\n        for (uint256 i = 0; i < _entities.length; i++) {\n            require(\n                _self.applications[_entities[i]].isInitializedState,\n                \"Application must exist\"\n            );\n        }\n        _;\n    }\n\n    modifier onlyExistingValidators(Data storage _self, address[] _entities) {\n        for (uint256 i = 0; i < _entities.length; i++) {\n            require(\n                _self.validators[_entities[i]].isInitializedState,\n                \"Validator must exist\"\n            );\n        }\n        _;\n    }\n\n    modifier onlySelectedValidators(Data storage _self, uint256 _rewardsDay) {\n        if (_getSelectedRewardedEntityListType(_self.selectedValidators, _rewardsDay) == 0) {\n            require (\n                _self.selectedValidators.current[msg.sender],\n                \"Must be a current selected validator\"\n            );\n        } else {\n            require (\n                _self.selectedValidators.previous[msg.sender],\n                \"Must be a previous selected validator\"\n            );\n        }\n        _;\n    }\n\n    modifier onlyValidRewardsDay(Data storage _self, uint256 _rewardsDay) {\n        require(\n            _currentRewardsDay(_self) > _rewardsDay && _rewardsDay > _self.lastRewardsDay,\n            \"Must be for a previous day but after the last rewards day\"\n        );\n         _;\n    }\n\n    modifier onlyValidFutureRewardsDay(Data storage _self, uint256 _rewardsDay) {\n        require(\n            _rewardsDay >= _currentRewardsDay(_self),\n            \"Must be future rewardsDay\"\n        );\n         _;\n    }\n\n    modifier onlyValidAddresses(address _rewardsAddress, address _sidechainAddress) {\n        require(\n            _rewardsAddress != address(0) &&\n            _sidechainAddress != address(0),\n            \"Must have valid rewards and sidechain addresses\"\n        );\n        _;\n    }\n\n    /**\n    * @dev The function is called by validators with the calculation of the daily rewards\n    * @param _self Data pointer to storage\n    * @param _rewardsDay uint256 the rewards day\n    * @param _rewardsHash bytes32 hash of the rewards data\n    * @param _allValidators bool should the calculation be based on all the validators or just those which submitted\n    */\n    function calculateValidatorRewards(\n        Data storage _self,\n        uint256 _rewardsDay,\n        bytes32 _rewardsHash,\n        bool _allValidators\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 numOfValidators;\n        if (_self.dailyRewards.submissions[_rewardsHash].finalized == 1)\n        {\n            if (_allValidators) {\n                numOfValidators = _requiredValidatorsForValidatorsRewards(_self, _rewardsDay);\n                if (numOfValidators > _self.dailyRewards.submissions[_rewardsHash].confirmations) return 0;\n            } else {\n                numOfValidators = _self.dailyRewards.submissions[_rewardsHash].confirmations;\n            }\n            uint256 rewardsPerValidator = _getValidatorRewardsDailyAmountPerValidator(_self, _rewardsDay, numOfValidators);\n            return rewardsPerValidator;\n        }\n        return 0;\n    }\n\n    /**\n    * @dev The function is called by validators with the calculation of the daily rewards\n    * @param _self Data pointer to storage\n    * @param _rewardsDay uint256 the rewards day\n    * @param _rewardsHash bytes32 hash of the rewards data\n    * @param _applications address[] array of application addresses getting the daily reward\n    * @param _amounts uint256[] array of amounts each app should get\n    * @param _currentTotalSupply uint256 current total supply\n    */\n    function calculateApplicationRewards(\n        Data storage _self,\n        uint256 _rewardsDay,\n        bytes32 _rewardsHash,\n        address[] _applications,\n        uint256[] _amounts,\n        uint256 _currentTotalSupply\n    )\n        public\n        onlyValidRewardsDay(_self, _rewardsDay)\n        onlyOneRewardsHashPerValidator(_self, _rewardsHash)\n        onlySelectedValidators(_self, _rewardsDay)\n        returns (uint256)\n    {\n        require(\n                _rewardsHashIsValid(_rewardsDay, _rewardsHash, _applications, _amounts),\n                \"Rewards Hash is invalid\"\n        );\n        if (!_self.dailyRewards.submissions[_rewardsHash].isInitializedState) {\n            _self.dailyRewards.submissions[_rewardsHash].isInitializedState = true;\n            _self.dailyRewards.submittedRewardsHashes.push(_rewardsHash);\n        }\n        _self.dailyRewards.submissions[_rewardsHash].validators[msg.sender] = true;\n        _self.dailyRewards.submissions[_rewardsHash].validatorsList.push(msg.sender);\n        _self.dailyRewards.submissions[_rewardsHash].confirmations++;\n\n        if (_self.dailyRewards.submissions[_rewardsHash].confirmations == _requiredValidatorsForAppRewards(_self, _rewardsDay)) {\n            uint256 sum = _validateSubmittedData(_self, _applications, _amounts);\n            require(\n                sum <= _getMaxAppRewardsDailyAmount(_self, _rewardsDay, _currentTotalSupply),\n                \"Rewards data is invalid - exceed daily variation\"\n            );\n            _finalizeDailyApplicationRewards(_self, _rewardsDay, _rewardsHash, _currentTotalSupply);\n            return sum;\n        }\n        return 0;\n    }\n\n    /**\n    * @dev Finalizes the state, rewards Hash, total supply and block timestamp for the day\n    * @param _self Data pointer to storage\n    * @param _rewardsDay uint256 the rewards day\n    * @param _rewardsHash bytes32 the daily rewards hash\n    * @param _currentTotalSupply uint256 the current total supply\n    */\n    function _finalizeDailyApplicationRewards(Data storage _self, uint256 _rewardsDay, bytes32 _rewardsHash, uint256 _currentTotalSupply)\n        public\n        returns (bool)\n    {\n        _self.dailyRewards.totalSupply = _currentTotalSupply;\n        _self.dailyRewards.lastConfirmedRewardsHash = _rewardsHash;\n        _self.dailyRewards.lastRewardsDay = _rewardsDay;\n        _self.dailyRewards.submissions[_rewardsHash].finalized = 1;\n        return true;\n    }\n\n    /**\n    * @dev Get parameter's value\n    * @param _self Data pointer to storage\n    * @param _name ParameterName name of the parameter\n    * @param _rewardsDay uint256 the rewards day\n    */\n    function getParameterValue(\n        Data storage _self,\n        ParameterName _name,\n        uint256 _rewardsDay\n    )\n        public\n        view\n        returns (uint256)\n    {\n        if (_rewardsDay >= _self.parameters[uint256(_name)].rewardsDay) {\n            return _self.parameters[uint256(_name)].currentValue;\n        } else {\n            return _self.parameters[uint256(_name)].previousValue;\n        }\n    }\n\n    /**\n    * @dev Allows the controller/owner to update rewards parameters\n    * @param _self Data pointer to storage\n    * @param _name ParameterName name of the parameter\n    * @param _value uint256 new value for the parameter\n    * @param _rewardsDay uint256 the rewards day\n    */\n    function updateParameter(\n        Data storage _self,\n        ParameterName _name,\n        uint256 _value,\n        uint256 _rewardsDay\n    )\n        public\n        onlyValidFutureRewardsDay(_self, _rewardsDay)\n        returns (bool)\n    {\n        if (_rewardsDay <= _self.parameters[uint256(_name)].rewardsDay) {\n           _self.parameters[uint256(_name)].currentValue = _value;\n           _self.parameters[uint256(_name)].rewardsDay = _rewardsDay;\n        } else {\n            _self.parameters[uint256(_name)].previousValue = _self.parameters[uint256(_name)].currentValue;\n            _self.parameters[uint256(_name)].currentValue = _value;\n           _self.parameters[uint256(_name)].rewardsDay = _rewardsDay;\n        }\n        return true;\n    }\n\n    /**\n    * @dev Allows an application to add/update its details\n    * @param _self Data pointer to storage\n    * @param _entityType RewardedEntityType either application (0) or validator (1)\n    * @param _name bytes32 name of the app\n    * @param _rewardsAddress address an address for the app to receive the rewards\n    * @param _sidechainAddress address the address used for using the sidechain\n    */\n    function updateEntity(\n        Data storage _self,\n        RewardedEntityType _entityType,\n        bytes32 _name,\n        address _rewardsAddress,\n        address _sidechainAddress\n    )\n        public\n        onlyValidAddresses(_rewardsAddress, _sidechainAddress)\n        returns (bool)\n    {\n        if (_entityType == RewardedEntityType.Application) {\n            updateApplication(_self, _name, _rewardsAddress, _sidechainAddress);\n        } else {\n            updateValidator(_self, _name, _rewardsAddress, _sidechainAddress);\n        }\n        return true;\n    }\n\n    /**\n    * @dev Allows an application to add/update its details\n    * @param _self Data pointer to storage\n    * @param _name bytes32 name of the app\n    * @param _rewardsAddress address an address for the app to receive the rewards\n    * @param _sidechainAddress address the address used for using the sidechain\n    */\n    function updateApplication(\n        Data storage _self,\n        bytes32 _name,\n        address _rewardsAddress,\n        address _sidechainAddress\n    )\n        public\n        returns (uint256)\n    {\n        _self.applications[msg.sender].name = _name;\n        _self.applications[msg.sender].rewardsAddress = _rewardsAddress;\n        _self.applications[msg.sender].sidechainAddress = _sidechainAddress;\n        if (!_self.applications[msg.sender].isInitializedState) {\n            _self.applicationsList.push(msg.sender);\n            _self.applications[msg.sender].isInitializedState = true;\n            _self.applications[msg.sender].entityType = RewardedEntityType.Application;\n        }\n        return uint256(RewardedEntityType.Application);\n    }\n\n    /**\n    * @dev Allows a validator to add/update its details\n    * @param _self Data pointer to storage\n    * @param _name bytes32 name of the validator\n    * @param _rewardsAddress address an address for the validator to receive the rewards\n    * @param _sidechainAddress address the address used for using the sidechain\n    */\n    function updateValidator(\n        Data storage _self,\n        bytes32 _name,\n        address _rewardsAddress,\n        address _sidechainAddress\n    )\n        public\n        returns (uint256)\n    {\n        _self.validators[msg.sender].name = _name;\n        _self.validators[msg.sender].rewardsAddress = _rewardsAddress;\n        _self.validators[msg.sender].sidechainAddress = _sidechainAddress;\n        if (!_self.validators[msg.sender].isInitializedState) {\n            _self.validatorsList.push(msg.sender);\n            _self.validators[msg.sender].isInitializedState = true;\n            _self.validators[msg.sender].entityType = RewardedEntityType.Validator;\n        }\n        return uint256(RewardedEntityType.Validator);\n    }\n\n    /**\n    * @dev Set new validators list\n    * @param _self Data pointer to storage\n    * @param _rewardsDay uint256 the rewards day from which the list should be active\n    * @param _validators address[] array of validators\n    */\n    function setValidators(\n        Data storage _self,\n        uint256 _rewardsDay,\n        address[] _validators\n    )\n        public\n        onlyValidFutureRewardsDay(_self, _rewardsDay)\n        onlyExistingValidators(_self, _validators)\n        returns (bool)\n    {\n        // no need to update the previous if its' the first time or second update in the same day\n        if (_rewardsDay > _self.selectedValidators.rewardsDay && _self.selectedValidators.currentList.length > 0)\n            _updatePreviousEntityList(_self.selectedValidators);\n\n        _updateCurrentEntityList(_self.selectedValidators, _validators);\n        _self.selectedValidators.rewardsDay = _rewardsDay;\n        return true;\n    }\n\n   /**\n    * @dev Set new applications list\n    * @param _self Data pointer to storage\n    * @param _rewardsDay uint256 the rewards day from which the list should be active\n    * @param _applications address[] array of applications\n    */\n    function setApplications(\n        Data storage _self,\n        uint256 _rewardsDay,\n        address[] _applications\n    )\n        public\n        onlyValidFutureRewardsDay(_self, _rewardsDay)\n        onlyExistingApplications(_self, _applications)\n        returns (bool)\n    {\n\n        if (_rewardsDay > _self.selectedApplications.rewardsDay && _self.selectedApplications.currentList.length > 0)\n                _updatePreviousEntityList(_self.selectedApplications);\n        _updateCurrentEntityList(_self.selectedApplications, _applications);\n        _self.selectedApplications.rewardsDay = _rewardsDay;\n        return true;\n    }\n\n    /**\n    * @dev Get applications or validators list\n    * @param _self Data pointer to storage\n    * @param _entityType RewardedEntityType either application (0) or validator (1)\n    * @param _rewardsDay uint256 the rewards day to determine which list to get\n    */\n    function getEntities(\n        Data storage _self,\n        RewardedEntityType _entityType,\n        uint256 _rewardsDay\n    )\n        public\n        view\n        returns (address[])\n    {\n        if (_entityType == RewardedEntityType.Application) {\n            if (_getSelectedRewardedEntityListType(_self.selectedApplications, _rewardsDay) == 0) {\n                return _self.selectedApplications.currentList;\n            } else {\n                return _self.selectedApplications.previousList;\n            }\n        } else {\n            if (_getSelectedRewardedEntityListType(_self.selectedValidators, _rewardsDay) == 0) {\n                return _self.selectedValidators.currentList;\n            } else {\n                return _self.selectedValidators.previousList;\n            }\n        }\n    }\n\n    /**\n    * @dev Get which entity list to use. Current = 0, previous = 1\n    * @param _rewardedEntitylist RewardedEntityList pointer to storage\n    * @param _rewardsDay uint256 the rewards day to determine which list to get\n    */\n    function _getSelectedRewardedEntityListType(RewardedEntityList _rewardedEntitylist, uint256 _rewardsDay)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_rewardsDay >= _rewardedEntitylist.rewardsDay) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n\n    /**\n    * @dev Checks how many validators are needed for app rewards\n    * @param _self Data pointer to storage\n    * @param _rewardsDay uint256 the rewards day\n    * @param _currentTotalSupply uint256 current total supply\n    */\n    function _getMaxAppRewardsDailyAmount(\n        Data storage _self,\n        uint256 _rewardsDay,\n        uint256 _currentTotalSupply\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return ((_self.maxTotalSupply.sub(_currentTotalSupply)).mul(\n        getParameterValue(_self, ParameterName.ApplicationRewardsPercent, _rewardsDay)).mul(\n        getParameterValue(_self, ParameterName.ApplicationRewardsMaxVariationPercent, _rewardsDay))).div(1e16);\n    }\n\n\n    /**\n    * @dev Checks how many validators are needed for app rewards\n    * @param _self Data pointer to storage\n    * @param _rewardsDay uint256 the rewards day\n    * @param _numOfValidators uint256 number of validators\n    */\n    function _getValidatorRewardsDailyAmountPerValidator(\n        Data storage _self,\n        uint256 _rewardsDay,\n        uint256 _numOfValidators\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return (((_self.maxTotalSupply.sub(_self.dailyRewards.totalSupply)).mul(\n        getParameterValue(_self, ParameterName.ValidatorRewardsPercent, _rewardsDay))).div(1e8)).div(_numOfValidators);\n    }\n\n    /**\n    * @dev Checks if app daily rewards amount is valid\n    * @param _self Data pointer to storage\n    * @param _applications address[] array of application addresses getting the daily rewards\n    * @param _amounts uint256[] array of amounts each app should get\n    */\n    function _validateSubmittedData(\n        Data storage _self,\n        address[] _applications,\n        uint256[] _amounts\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 sum;\n        bool valid = true;\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            sum = sum.add(_amounts[i]);\n            if (!_self.applications[_applications[i]].isInitializedState) valid = false;\n        }\n        require(\n                sum > 0 && valid,\n                \"Sum zero or none existing app submitted\"\n        );\n        return sum;\n    }\n\n    /**\n    * @dev Checks if submitted data matches rewards hash\n    * @param _rewardsDay uint256 the rewards day\n    * @param _rewardsHash bytes32 hash of the rewards data\n    * @param _applications address[] array of application addresses getting the daily rewards\n    * @param _amounts uint256[] array of amounts each app should get\n    */\n    function _rewardsHashIsValid(\n        uint256 _rewardsDay,\n        bytes32 _rewardsHash,\n        address[] _applications,\n        uint256[] _amounts\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return\n            _applications.length > 0 &&\n            _applications.length == _amounts.length &&\n            keccak256(abi.encodePacked(_rewardsDay, _applications.length, _amounts.length, _applications, _amounts)) == _rewardsHash;\n    }\n\n    /**\n    * @dev Checks how many validators are needed for app rewards\n    * @param _self Data pointer to storage\n    * @param _rewardsDay uint256 the rewards day\n    */\n    function _requiredValidatorsForValidatorsRewards(Data storage _self, uint256 _rewardsDay)\n        public\n        view\n        returns (uint256)\n    {\n        if (_getSelectedRewardedEntityListType(_self.selectedValidators, _rewardsDay) == 0) {\n            return _self.selectedValidators.currentList.length;\n        } else {\n            return _self.selectedValidators.previousList.length;\n        }\n    }\n\n    /**\n    * @dev Checks how many validators are needed for app rewards\n    * @param _self Data pointer to storage\n    * @param _rewardsDay uint256 the rewards day\n    */\n    function _requiredValidatorsForAppRewards(Data storage _self, uint256 _rewardsDay)\n        public\n        view\n        returns (uint256)\n    {\n        if (_getSelectedRewardedEntityListType(_self.selectedValidators, _rewardsDay) == 0) {\n            return ((_self.selectedValidators.currentList.length.mul(getParameterValue(_self, ParameterName.ValidatorMajorityPercent, _rewardsDay))).div(1e8)).add(1);\n        } else {\n            return ((_self.selectedValidators.previousList.length.mul(getParameterValue(_self, ParameterName.ValidatorMajorityPercent, _rewardsDay))).div(1e8)).add(1);\n        }\n    }\n\n    /**\n    * @dev Get rewards day from block.timestamp\n    * @param _self Data pointer to storage\n    */\n    function _currentRewardsDay(Data storage _self)\n        public\n        view\n        returns (uint256)\n    {\n        //the the start time - floor timestamp to previous midnight divided by seconds in a day will give the rewards day number\n       if (_self.minSecondsBetweenDays > 0) {\n            return (block.timestamp.sub(_self.rewardsStartTimestamp)).div(_self.minSecondsBetweenDays).add(1);\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n    * @dev Update current daily applications list.\n    * If new, push.\n    * If same size, replace\n    * If different size, delete, and then push.\n    * @param _rewardedEntitylist RewardedEntityList pointer to storage\n    * @param _entities address[] array of entities\n    */\n    //_updateCurrentEntityList(_rewardedEntitylist, _entities,_rewardedEntityType),\n    function _updateCurrentEntityList(\n        RewardedEntityList storage _rewardedEntitylist,\n        address[] _entities\n    )\n        internal\n        returns (bool)\n    {\n        bool emptyCurrentList = _rewardedEntitylist.currentList.length == 0;\n        if (!emptyCurrentList && _rewardedEntitylist.currentList.length != _entities.length) {\n            _deleteCurrentEntityList(_rewardedEntitylist);\n            emptyCurrentList = true;\n        }\n\n        for (uint256 i = 0; i < _entities.length; i++) {\n            if (emptyCurrentList) {\n                _rewardedEntitylist.currentList.push(_entities[i]);\n            } else {\n                _rewardedEntitylist.currentList[i] = _entities[i];\n            }\n            _rewardedEntitylist.current[_entities[i]] = true;\n        }\n        return true;\n    }\n\n    /**\n    * @dev Update previous daily list\n    * @param _rewardedEntitylist RewardedEntityList pointer to storage\n    */\n    function _updatePreviousEntityList(RewardedEntityList storage _rewardedEntitylist)\n        internal\n        returns (bool)\n    {\n        bool emptyPreviousList = _rewardedEntitylist.previousList.length == 0;\n        if (\n            !emptyPreviousList &&\n            _rewardedEntitylist.previousList.length != _rewardedEntitylist.currentList.length\n        ) {\n            _deletePreviousEntityList(_rewardedEntitylist);\n            emptyPreviousList = true;\n        }\n        for (uint256 i = 0; i < _rewardedEntitylist.currentList.length; i++) {\n            if (emptyPreviousList) {\n                _rewardedEntitylist.previousList.push(_rewardedEntitylist.currentList[i]);\n            } else {\n                _rewardedEntitylist.previousList[i] = _rewardedEntitylist.currentList[i];\n            }\n            _rewardedEntitylist.previous[_rewardedEntitylist.currentList[i]] = true;\n        }\n        return true;\n    }\n\n    /**\n    * @dev Delete existing values from the current list\n    * @param _rewardedEntitylist RewardedEntityList pointer to storage\n    */\n    function _deleteCurrentEntityList(RewardedEntityList storage _rewardedEntitylist)\n        internal\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _rewardedEntitylist.currentList.length ; i++) {\n             delete _rewardedEntitylist.current[_rewardedEntitylist.currentList[i]];\n        }\n        delete  _rewardedEntitylist.currentList;\n        return true;\n    }\n\n    /**\n    * @dev Delete existing values from the previous applications list\n    * @param _rewardedEntitylist RewardedEntityList pointer to storage\n    */\n    function _deletePreviousEntityList(RewardedEntityList storage _rewardedEntitylist)\n        internal\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _rewardedEntitylist.previousList.length ; i++) {\n            delete _rewardedEntitylist.previous[_rewardedEntitylist.previousList[i]];\n        }\n        delete _rewardedEntitylist.previousList;\n        return true;\n    }\n\n    /**\n    * @dev Deletes rewards day submission data\n    * @param _self Data pointer to storage\n    */\n    function _resetDailyRewards(\n        Data storage _self\n    )\n        public\n        returns (bool)\n    {\n         _self.lastRewardsDay = _self.dailyRewards.lastRewardsDay;\n        bytes32[] memory rewardsHashes = _self.dailyRewards.submittedRewardsHashes;\n        for (uint256 i = 0; i < rewardsHashes.length; i++) {\n            for (uint256 j = 0; j < _self.dailyRewards.submissions[rewardsHashes[i]].validatorsList.length; j++) {\n                delete(\n                    _self.dailyRewards.submissions[rewardsHashes[i]].validators[_self.dailyRewards.submissions[rewardsHashes[i]].validatorsList[j]]\n                );\n            }\n            delete _self.dailyRewards.submissions[rewardsHashes[i]].validatorsList;\n            _self.dailyRewards.submissions[rewardsHashes[i]].confirmations = 0;\n            _self.dailyRewards.submissions[rewardsHashes[i]].finalized = 0;\n            _self.dailyRewards.submissions[rewardsHashes[i]].isInitializedState = false;\n        }\n        delete _self.dailyRewards.submittedRewardsHashes;\n    }\n}"
    }
  ]
}