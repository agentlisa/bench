{
  "Title": "Erroneous docstrings in codebase",
  "Content": "A first instance of this issue can be found at the [inline documentation provided before the](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsTimeBasedTransfers.sol#L7) [`PropsTimeBasedTransfers`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsTimeBasedTransfers.sol#L7) [contract declaration](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsTimeBasedTransfers.sol#L7), where the current docstrings correspond to the [`PropsSidechainCompatible`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsSidechainCompatible.sol#L10) [contract](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsSidechainCompatible.sol#L10). Similarly, contract [`ERC865`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865.sol#L6) [docstrings](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865.sol#L6) correspond to the `ERC865Token` contract.\n\n\nMoreover, there are [references](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsToken.sol#L12) in the `PropsToken` contract docstrings to an integration with the [TPL protocol](https://tplprotocol.org/) that is not currently implemented in the token. Additionally, in this same contract, the [docstrings state that the](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsToken.sol#L11) [`PropsToken`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsToken.sol#L11) [is pausable](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsToken.sol#L11), but no such behavior was found in the code’s logic.\n\n\nIf the PROPS token is based on the ZEP token implemented by the [ZeppelinOS](https://zeppelinos.org/) team, as [docstrings in](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsToken.sol#L11) [`PropsToken`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsToken.sol#L11) [highlight](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/PropsToken.sol#L11), please consider including a link referencing the [ZEP token’s public code](https://github.com/zeppelinos/zos-vouching/blob/master/contracts/ZEPToken.sol).\n\n\nFurthermore, [an inline comment](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L17) in the `ERC865Token` contract mistakenly describes the `signatures` mapping as a data structure to hold nonces, while it is actually used to store signatures.\n\n\nAs inaccurate docstrings may confuse users, developers and auditors alike, consider fixing all instances of this issue.\n\n\n***Update:*** *Partially fixed. The* [*docstring of the*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/IERC865.sol#L7) [*`IERC865`*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/IERC865.sol#L7) [*contract*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/IERC865.sol#L7) *is still wrong.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/token/PropsTimeBasedTransfers.sol",
      "content": "pragma solidity ^0.4.24;\n\nimport \"zos-lib/contracts/Initializable.sol\";\nimport \"openzeppelin-eth/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Props Sidechain Compatible\n * @dev Added a settle function and events\n **/\ncontract PropsTimeBasedTransfers is ERC20 {\n    \n    uint public transfersStartTime;\n    address public canTransferBeforeStartTime;\n\n    /**\n    * @notice The initializer function, with transfers start time `transfersStartTime`\n    * and `canTransferBeforeStartTime` address which is exempt from start time restrictions\n    * @param start uint Timestamp of when transfers can start\n    * @param account uint256 address exempt from the start date check    \n    */\n    function initialize(\n        uint start,\n        address account\n    )\n        public\n        initializer\n    {\n        transfersStartTime = start;\n        canTransferBeforeStartTime = account;\n    }\n\n    function canTransfer(address account) public view returns (bool) {\n        return (now > transfersStartTime || account==canTransferBeforeStartTime);\n    }\n\n    function transfer(\n        address to,\n        uint256 value\n    )\n    public    \n    returns (bool)\n    {\n        require(\n            canTransfer(msg.sender),\n            \"Transfers are not yet active\"\n        );\n        return super.transfer(to, value);        \n    }\n\n    function transferFrom(\n    address from,\n    address to,\n    uint256 value\n    )\n    public    \n    returns (bool)\n    {\n        require(\n            canTransfer(msg.sender),\n            \"Transfers are not yet active\"\n        );\n        return super.transferFrom(from, to, value);        \n    }    \n}"
    },
    {
      "filename": "contracts/token/PropsToken.sol",
      "content": "pragma solidity ^0.4.24;\n\nimport \"zos-lib/contracts/Initializable.sol\";\nimport \"openzeppelin-eth/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"./PropsSidechainCompatible.sol\";\nimport \"./PropsTimeBasedTransfers.sol\";\nimport \"./ERC865Token.sol\";\n\n/**\n * @title PROPSToken\n * @dev PROPS token contract (based of ZEPToken by openzeppelin), a detailed ERC20 including pausable functionality.\n * The TPLToken integration causes tokens to only be transferrable to addresses\n * which have the validRecipient attribute in the jurisdiction.\n */\ncontract PropsToken is Initializable, ERC20Detailed, PropsSidechainCompatible, ERC865Token, PropsTimeBasedTransfers {\n\n  /**\n   * @dev Initializer function. Called only once when a proxy for the contract is created.\n   * @param _holder Address that will receive it's initial supply and be able to transfer before transfers start time\n   * @param _transfersStartTime Timestamp from which transfers are allowed   \n   */\n  function initialize(\n    address _holder,\n    uint _transfersStartTime\n  )\n    initializer\n    public\n  {\n    uint8 decimals = 18;\n    uint256 totalSupply = 0.6 * 1e9 * (10 ** uint256(decimals));\n    \n    ERC20Detailed.initialize(\"DEV_Token\", \"DEV_TOKEN\", decimals);\n    PropsTimeBasedTransfers.initialize(_transfersStartTime, _holder);    \n    _mint(_holder, totalSupply);\n  }\n\n}"
    },
    {
      "filename": "contracts/token/PropsToken.sol",
      "content": "pragma solidity ^0.4.24;\n\nimport \"zos-lib/contracts/Initializable.sol\";\nimport \"openzeppelin-eth/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"./PropsSidechainCompatible.sol\";\nimport \"./PropsTimeBasedTransfers.sol\";\nimport \"./ERC865Token.sol\";\n\n/**\n * @title PROPSToken\n * @dev PROPS token contract (based of ZEPToken by openzeppelin), a detailed ERC20 including pausable functionality.\n * The TPLToken integration causes tokens to only be transferrable to addresses\n * which have the validRecipient attribute in the jurisdiction.\n */\ncontract PropsToken is Initializable, ERC20Detailed, PropsSidechainCompatible, ERC865Token, PropsTimeBasedTransfers {\n\n  /**\n   * @dev Initializer function. Called only once when a proxy for the contract is created.\n   * @param _holder Address that will receive it's initial supply and be able to transfer before transfers start time\n   * @param _transfersStartTime Timestamp from which transfers are allowed   \n   */\n  function initialize(\n    address _holder,\n    uint _transfersStartTime\n  )\n    initializer\n    public\n  {\n    uint8 decimals = 18;\n    uint256 totalSupply = 0.6 * 1e9 * (10 ** uint256(decimals));\n    \n    ERC20Detailed.initialize(\"DEV_Token\", \"DEV_TOKEN\", decimals);\n    PropsTimeBasedTransfers.initialize(_transfersStartTime, _holder);    \n    _mint(_holder, totalSupply);\n  }\n\n}"
    },
    {
      "filename": "contracts/token/ERC865Token.sol",
      "content": "pragma solidity ^0.4.24;\n\n// import \"zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\";\n// import \"openzeppelin-eth/contracts/token/ERC20/ERC20.sol\";\nimport \"./ERC865.sol\";\n\n/**\n * @title ERC865Token Token\n *\n * ERC865Token allows users paying transfers in tokens instead of gas\n * https://github.com/ethereum/EIPs/issues/865\n *\n */\n\ncontract ERC865Token is ERC865 {\n\n    /* Nonces of transfers performed */\n    mapping(bytes => bool) signatures;\n\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    event ApprovalPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    /**\n     * @notice Submit a presigned transfer\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSigned(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {        \n        require(_to != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = transferPreSignedHashing(address(this), _to, _value, _fee, _nonce);\n\n        address from = recover(hashedTx, _signature);     \n        require(from != address(0));\n        _transfer(from, _to, _value);\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_value).sub(_fee);\n        // _balances[_to] = _balances[_to].add(_value);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Transfer(from, _to, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Submit a presigned approval\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = approvePreSignedHashing(address(this), _spender, _value, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, _value);\n        // _allowed[from][_spender] = _value;\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Increase the amount of tokens that an owner allowed to a spender.\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseApprovalPreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, allowance(from, _spender).add(_addedValue));\n        // _allowed[from][_spender] = _allowed[from][_spender].add(_addedValue);\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _allowed[from][_spender]);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @notice Decrease the amount of tokens that an owner allowed to a spender.\n     * @param _signature bytes The signature, issued by the owner\n     * @param _spender address The address which will spend the funds.\n     * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function decreaseApprovalPreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n\n        uint oldValue = allowance(from, _spender);\n        if (_subtractedValue > oldValue) {\n            _approve(from, _spender, 0);\n            // _allowed[from][_spender] = 0;\n        } else {\n            _approve(from, _spender, allowance(from,_spender).sub(_subtractedValue));\n            // _allowed[from][_spender] = oldValue.sub(_subtractedValue);\n        }\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _subtractedValue);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another\n     * @param _signature bytes The signature, issued by the spender.\n     * @param _from address The address which you want to send tokens from.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferFromPreSigned(\n        bytes _signature,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = transferFromPreSignedHashing(address(this), _from, _to, _value, _fee, _nonce);\n\n        address spender = recover(hashedTx, _signature);\n        require(spender != address(0));\n\n        _transfer(_from, _to, _value);\n        // _balances[_from] = _balances[_from].sub(_value);\n        // _balances[_to] = _balances[_to].add(_value);\n        _approve(_from, spender, allowance(_from, spender).sub(_value));\n        // _allowed[_from][spender] = _allowed[_from][spender].sub(_value);\n        _transfer(spender, msg.sender, _fee);\n        // _balances[spender] = _balances[spender].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Transfer(_from, _to, _value);\n        // Transfer(spender, msg.sender, _fee);\n        return true;\n    }\n\n\n    /**\n     * @notice Hash (keccak256) of the payload used by transferPreSigned\n     * @param _token address The address of the token.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSignedHashing(\n        address _token,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"48664c16\": transferPreSignedHashing(address,address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x48664c16), _token, _to, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by approvePreSigned\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"f7ac9c2e\": approvePreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by increaseApprovalPreSigned\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseApprovalPreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"a45f71ff\": increaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xa45f71ff), _token, _spender, _addedValue, _fee, _nonce));\n    }\n\n     /**\n      * @notice Hash (keccak256) of the payload used by decreaseApprovalPreSigned\n      * @param _token address The address of the token\n      * @param _spender address The address which will spend the funds.\n      * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\n      * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n      * @param _nonce uint256 Presigned transaction number.\n      */\n    function decreaseApprovalPreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"59388d78\": decreaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x59388d78), _token, _spender, _subtractedValue, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by transferFromPreSigned\n     * @param _token address The address of the token\n     * @param _from address The address which you want to send tokens from.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferFromPreSignedHashing(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"b7656dc5\": transferFromPreSignedHashing(address,address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xb7656dc5), _token, _from, _to, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Recover signer address from a message by using his signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes sig) public pure returns (address) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n\n      //Check the signature length\n      if (sig.length != 65) {\n        return (address(0));\n      }\n\n      // Divide the signature in r, s and v variables\n      assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n      }\n\n    //   // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n    //    if (v < 27) {\n    //         v += 27;\n    //    }\n\n      // If the version is correct return the signer address\n      if (v != 27 && v != 28) {\n        return (address(0));\n      } else {\n        return ecrecover(hash, v, r, s);\n      }\n    }\n\n}"
    },
    {
      "filename": "contracts/token/IERC865.sol",
      "content": "pragma solidity ^0.4.24;\n\nimport \"zos-lib/contracts/Initializable.sol\";\nimport \"openzeppelin-eth/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title ERC865Token Token\n *\n * ERC865Token allows users paying transfers in tokens instead of gas\n * https://github.com/ethereum/EIPs/issues/865\n *\n */\n\ncontract IERC865 is Initializable, ERC20 {\n\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    event ApprovalPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n\n    function transferPreSigned(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool);\n\n    function approvePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool);\n\n    function increaseAllowancePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool);\n\n    function decreaseAllowancePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool);\n\n    function transferFromPreSigned(\n        bytes _signature,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool);\n}"
    }
  ]
}