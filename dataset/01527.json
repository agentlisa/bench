{
  "Title": "M-2: Because of rounding issues, users may not be able to withdraw airdrop tokens if their claim has been adjust()'ed upwards",
  "Content": "# Issue M-2: Because of rounding issues, users may not be able to withdraw airdrop tokens if their claim has been adjust()'ed upwards \n\nSource: https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/56 \n\n## Found by \njkoppel\n## Summary\n\nIn order for a user to withdraw their claim, they must have enough voting tokens. However, because of rounding issues, if their voting shares are granted in multiple stages, namely by the owner adjust()-ing their share upwards,  they will not have enough.\n\n## Vulnerability Detail\n\n1. Owner creates airdrop and grants a user a claim of 1000 tokens. The voting factor is 5, and the fractionDenominator is set to 10000.\n2. User initializes their distribution record. They are minted 1000*5/10000 = 0 voting tokens.\n3. Owner adjusts everyone's claim up to 1000. Each user is minted another 1000*5/10000=0 voting tokens.\n4. User fully vests\n5. User cannot withdraw anything because, in order to withdraw, they must burn 2000*5/10000= 1 voting token.\n\n## Impact\n\nUnless all grants and positive adjust()'s are for exact multiples of fractionDenominator, users will be prevented from withdrawing after an upwards adjustment.\n\nNote that many comments give example values of 10000 for fraction denominator and 15000 for voteFactor. Since the intention is to use `voteFactor`'s which are not multiples of fractionDenonimator, rounding issues will occur.\n\n## Code Snippet\n\nRounding in tokensToVotes\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/AdvancedDistributor.sol#L73\n\n```solidity\n  function tokensToVotes(uint256 tokenAmount) private view returns (uint256) {\n    return (tokenAmount * voteFactor) / fractionDenominator;\n  }\n```\n\n_inititializeDistributionRecord and adjust() both use  `tokensToVotes` to mint\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/AdvancedDistributor.sol#L84C1-L85C1\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/AdvancedDistributor.sol#L126\n\n\ntokensToVotes is again used to burn when executing a claim\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/AdvancedDistributor.sol#L87\n\n```solidity\n\n  function _executeClaim(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override returns (uint256 _claimed) {\n    _claimed = super._executeClaim(beneficiary, totalAmount);\n\n    // reduce voting power through ERC20Votes extension\n    _burn(beneficiary, tokensToVotes(_claimed));\n  }\n\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBase votes on share of unclaimed tokens and not on a separate token.\n\n\n\n## Discussion\n\n**cr-walker**\n\nGood catch.\n\nSolution: we'll burn the minimum of the expected quantity and current balance to get around these rounding issues.\n\n**cr-walker**\n\nFixed by https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/56\n\n**dot-pengun**\n\nEscalate\n\nThis issue occurs when the admin sets the `voteFactor` to very low or which are not multiples. In several test files that the `voteFactor` is set to `2n * 10n ** 18n`, `2n * 10n ** 4n`, etc. (this is also mentioned in the issue above), so I believe the issue is essentially an admin error.\n\nAlso resolution in #41 resolves this issue.(https://github.com/SoftDAO/contracts/pull/9/commits/0cd8ff408632eabfc363da43255ffd4d2a8bd73e)\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This issue occurs when the admin sets the `voteFactor` to very low or which are not multiples. In several test files that the `voteFactor` is set to `2n * 10n ** 18n`, `2n * 10n ** 4n`, etc. (this is also mentioned in the issue above), so I believe the issue is essentially an admin error.\n> \n> Also resolution in #41 resolves this issue.(https://github.com/SoftDAO/contracts/pull/9/commits/0cd8ff408632eabfc363da43255ffd4d2a8bd73e)\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**jkoppel**\n\ndot-penguin points out some interesting information about the test values. But, as I'll explain below, I think relying on such information is at odds with the purpose of this entire contest.\n\nWhile the example scenario used a low number, the issue appears with any value of voteFactor which is not an exact multiple of fractionDenominator. Comments suggest in multiple places (e.g.: https://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/TrancheVestingSale_2_0.sol#L31 ) the values of 15000 for voteFactor and 10000 for fractionDenominator, which would exhibit this issue.\n\nIf you call this invalid admin error, then any bug that occurs in some settings but not all is also admin error. This bug is present for the overwhelming majority of possible settings of voteFactor, and there is nothing to indicate that only multiples should be used.\n\nThe purpose of audits is to catch bugs not already found. Saying \"the tests didn't use values that found the bug\" is not a reason for non-validity.\n\nIt is irrelevant that there is a larger design change that fixes both this and other issues.\n\n**dot-pengun**\n\nI agree that this is a vulnerability, I just think the definition of admin input validation in sherlock's docs is vague. \nI'm not sure if input validation is just for rug pulls or if it also includes things that can harm the protocol like this.\n\n>Admin Input/call validation:  Protocol admin is considered to be trusted in most cases, hence issues where\nAdmin incorrectly enters an input parameter. \nExample: Make sure interestPerMin > 1 ether as it is an important parameter.  This is not a valid issue.\n\n**jkoppel**\n\nAs I mentioned in the Discord, this is a contest where, for every single issue reported, I can see an argument by which that issue should be invalid. (For example, because of the Sweepable functionality, admin can manually fix any issue of funds getting stuck.) I agree that Sherlock's docs should be more clear about this --- and they have become better in my moderate amount of time on the platform. But in the past, errors like this have been deemed valid.\n\nI have a software verification background, and I think there's a pretty simple definition that can apply here: \n\n1.  Each function makes a promise: if you pass in inputs that satisfy its precondition, then some desired outcome will occur\n2. If a user calls a function in a way that doesn't satisfy its preconditions, nothing bad should happen\n3. If an admin calls a function in a way that doesn't satisfy its preconditions, all bets are off\n4. If an admin calls a function in a way that **does** satisfy its preconditions, no unintended bad effects should occur.\n\nSo the relevant question is: is \"voteFactor must be a perfect multiple of fractionDenominator\" in the communicated precondition for the various constructors? I think it's hard to argue yes, given that the example value violates that property.\n\n**Czar102**\n\nPlease note that it's `tokenAmount * voteFactor` that needs to be a multiply of `fractionDenominator`. Hence, the values provided in the comment, i.e. `voteFactor` is 15000, it does not cause the bug right away. The admin just needs to set all claim amounts to an even number, then `voteFactor * tokenAmount` will always be a multiple of 30000 at the end of the vesting, making it divisible by the `fractionDenominator`. Auditors were free to assume that nothing is broken, as long as the admin inputs all pairs `(tokenAmount, voteFactor)` (`voteFactor` is constant), which is a question of admin input validation and comments do not give any example suggesting the admin could want to input invalid values here.\n\n**jkoppel**\n\nConsider a TranchVestingSale or PriceTierVestingSale airdrop where users control the initial amount granted.\n\nUser buys 1337 tokens.\n\nAdmin calls `adjust(user, 5000)`. \n\nBut this causes the bug in question.\n\nActually, the admin should have called `adjust(user, 5000 - (getDistributionRecord(user).total % 2))`.\n\nIf calling `adjust(user, 5000)` is indeed considered an invalid input despite there being nothing in the docs or comments suggesting that calling  `adjust(user, 5000)` may cause trapped funds, then this would be indeed an invalid issue.\n\nBut I suspect that most would not be willing to bite that bullet.\n\n**dot-pengun**\n\nI think this issue is not fundamentally caused by `voteFactor` not being a multiple of `fractionDenominator`, but rather by poor handling on `adjust`.\nIn other words, it happens because `initializeDistributionRecord` is not performed correctly after the adjustment.\nTherefore, the protocol team fixed #41, and the revised [commit](https://github.com/SoftDAO/contracts/commit/0cd8ff408632eabfc363da43255ffd4d2a8bd73e) shows that the issue is gone.\n\n**Czar102**\n\nIf the user buys 1337 tokens, they get 2005 votes. Adjusting by 5000 should give the user 7500 more votes. Hence, the user has 7505, which is exactly what they need to withdraw all the amount. If the adjusted amount was positive and odd, the argument would make sense. Nice find.\n\nThe admin can still call `adjust(user, -1)`, `adjust(user, -1)`, `adjust(user, 2)` to resolve this. Hence, it is only gas that the admin loses, there is no fund loss or irreversible state change.\n\n**jkoppel**\n\nThanks for working out my example more @Czar102. Yes, I did screw up. The argument to adjust() needs to be odd. So I can amend my statement: one would have to bite the bullet that `adjust(user, amountToGiveToManyUsers / n)` is invalid input, and so is `adjust(user, someBaseAmount * 2 / 3)`, with the correct version being  `adjust(user, amountToGiveToManyUsers / n - (getDistributionRecord(user).total % 2))`. This is not quite as large as a bullet to bite, but still a huge toothache if one does.\n\nRe: @dot-pengun \nYes, the logic in the fix to #41  is a good approach. adjust() is completely independent of initializeDistributionRecord(), so one solution is to apply the same fix here.\n\nIt is true that the admin can work around the issue if they understand it.  But that argument also applies to literally every other issue in this contest.\n\n**KuTuGu**\n\nEscalate\nI want to emphasize that the precision of ERC20 tokens and votes is 18 decimals. The warden is wrong in the example mentioned above, the true value should be `1000e18 * 5 / 10000`, not `1000 * 5 / 10000`.\nFor the dust value of 1000, tokensToVotes are 0, but this is meaningless because the tokenAmount itself is dust.\nIn addition, if tokenAmount = 1.11...1e18, although there is a precision error in division, the error is only 1wei, which can be ignored.\nSo I think the issue is low.\n\n \n\n**sherlock-admin2**\n\n> Escalate\n> I want to emphasize that the precision of ERC20 tokens and votes is 18 decimals. The warden is wrong in the example mentioned above, the true value should be `1000e18 * 5 / 10000`, not `1000 * 5 / 10000`.\n> For the dust value of 1000, tokensToVotes are 0, but this is meaningless because the tokenAmount itself is dust.\n> In addition, if tokenAmount = 1.11...1e18, although there is a precision error in division, the error is only 1wei, which can be ignored.\n> So I think the issue is low.\n> \n>  \n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**jkoppel**\n\n@KuTuGu  What is the true value you are referring to?\n\nI explained  why calling `adjust(user, someBaseAmount * 2 / 3)` on a fully-vested user would cause a user to become unable to withdraw 100%  of their funds. Can you find some flaw in this reasoning? Are you saying that 100% of a user's claimable token is \"dust?\"\n\n**KuTuGu**\n\nI'm saying that tokens have 1e18 decimals, 1000 tokens are 1000e18, not 1000, it doesn't have a result of 0 when calculating tokensToVotes, and since fractionDenominator is a multiple of 10, there is no precision error here\n\n \n\n**jkoppel**\n\nSorry, I'm confused.  I don't understand how that is relevant to the issue.\n\nLet's be super-specific. Here's a Chisel session mimicking the tracking of vote tokens:\n\n1. User gets x=1000e18 / 3 tokens\n\n`uint256 x = 1000e18/3;`\n\n2. User gets z=x*voteFactor/fractionDenominator voting tokens\n\n`uint256 z = x * 15000 / 10000;`\n\n3. Admin calls adjust `adjust(user, 1000e18/3)`\n\n`x += 1000e18 / 3;`\n`z += (1000e18 / 3) * 15000 / 10000;`\n\n4. User fully vests\n\n5. User tries to claim, burning all vote tokens\n\n```\nz -= x*votingFactor / fractionDenominator;\n\nTraces:\n  [3204] 0xBd770416a3345F91E4B34576cb804a576fa48EB1::run()\n    └─ ← \"Arithmetic over/underflow\"\n```\n\nAre you saying this is not the math used to mint and  burn voting shares, or that an arithmetic underflow when withdrawing is not a problem?\n\n**KuTuGu**\n\nAs I said before, there is an error in division, but it is only 1wei and there is no significant loss\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../contracts/claim/BasicDistributor.sol\";\n\ncontract MToken is ERC20 {\n    constructor() ERC20(\"\", \"\") {}\n}\n\ncontract CounterTest is Test {\n    MToken public token;\n    BasicDistributor public distributor;\n    uint256 constant amount = 1000 ether;\n    address constant user = address(0xdead);\n\n    function setUp() public {\n        address[] memory recipients = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        recipients[0] = user;\n        amounts[0] = amount / 3;\n        token = new MToken();\n        distributor = new BasicDistributor(token, amount / 3, \"\", 1.5e18, recipients, amounts);\n        deal(address(token), address(distributor), amount);\n    }\n\n    function testRoundIssue() public {\n        assertEq(distributor.getClaimableAmount(user), amount / 3);\n        assertEq(token.balanceOf(user), 0);\n        distributor.adjust(user, int256(amount / 3 * 2));\n        assertEq(distributor.getClaimableAmount(user), amount / 3 * 3);\n        assertEq(token.balanceOf(user), 0);\n        distributor.claim(user);\n        assertEq(distributor.getClaimableAmount(user), 0);\n        assertEq(token.balanceOf(user), amount / 3 * 3);\n        assertEq(amount * 3 / 3 - token.balanceOf(user), 1);\n    }\n}\n```\n\n**jkoppel**\n\n@KuTuGu  Cool! That test behaves exactly as I expect! Now let's try something actually related to this issue.\n\nFor a little bit of context, this issue:\n\n1. Causes claim attempts to revert\n2. Requires that tokenAmount*votingFactor is not perfectly divisible by fractionDenominator.   \n3. Involves a rounding error in voting tokens, not the claimed token\n\nThe scenario I wrote above:\n\n1. Uses a votingFactor of 15000, which is the one suggested by documentation\n2. Requires distributing an odd number of tokens to the user, and then adjusting by an odd number of tokens.\n\nAnd this test:\n\n1. Does not look at voting tokens\n2. Does not check anything related to reversion\n3. Uses a votingFactor 10^14 times higher than the one proposed, one which is a perfect multiple of votingFactor\n4. Does not adjust by an odd number of tokens\n\nIt turns out that, if you run a test completely unrelated to the proposed issue, it will fail to exhibit the issue!\n\nBut it did successfully show that (amount/3)+(amount/3 * 2) == amount-1. There are also simpler tests of this.\n\nNow let's modify it to actually relate to the issue:\n\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../contracts/claim/BasicDistributor.sol\";\n\ncontract MToken is ERC20 {\n    constructor() ERC20(\"\", \"\") {}\n}\n\ncontract CounterTest is Test {\n    MToken public token;\n    BasicDistributor public distributor;\n    uint256 constant amount = 1000 ether;\n    address constant user = address(0xdead);\n\n    function setUp() public {\n        address[] memory recipients = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        recipients[0] = user;\n        amounts[0] = amount / 3;\n        token = new MToken();\n        distributor = new BasicDistributor(token, amount / 3, \"\", 15000, recipients, amounts);\n        deal(address(token), address(distributor), amount);\n    }\n\n    function testRoundIssue() public {\n        distributor.adjust(user, int256(amount / 3));\n        distributor.claim(user);\n    }\n}\n```\n\n\nResult:\n\n```\n\nRunning 1 test for contracts/contracts/ContractTest.sol:CounterTest\n[FAIL. Reason: ERC20: burn amount exceeds balance] testRoundIssue() (gas: 77926)\nTest result: FAILED. 0 passed; 1 failed; finished in 2.63ms\n\nFailing tests:\nEncountered 1 failing test in contracts/contracts/ContractTest.sol:CounterTest\n[FAIL. Reason: ERC20: burn amount exceeds balance] testRoundIssue() (gas: 77926)\n```\n\nIn contrast, if you adjust by `1+amount/3` instead, then it does not revert.\n\nSo, as you can see, a very innocuous call to `adjust` renders the user unable to claim anything. This issue is valid.\n\n**KuTuGu**\n\nSorry I confused the hard-coded parameter fractionDenominator for ContinuousVesting and BasicDistributor.\nYou are correct, each adjust may produce 1wei error, resulting in failure to withdraw money.\n\n**hrishibhat**\n\n@jkoppel @dot-pengun \nFirstly thank you for the points around admin input error. I can see how the rule can be ambiguous at times, and an improvement on the same is pending. \n\nAbout this issue, to summarize this seems to be creating temporary dos for user claims which can correct by the owner using adjust?\n\n**jkoppel**\n\nNo, that's not an accurate summary. \n\nThe summary is that a very innocuous call to `adjust` creates a DOS for user claims, period.\n\nThe admin can fix this problem by sweeping the tokens back and distributing them manually, or by a very unintuitive sequence of admin calls which amounts to using another exploit to undo this bug. \n\nNote that all other DOS vulnerabilities can be worked around in a similar manner: #55, #141,  and #14. #141 in particular has a very easy workaround: instead of calling `setTotal(newTotal)`, call `setTotal(claimed); setTotal(newTotal)`\n\nAdmins are also able to work around the issue for #188, #143, #130, and #41.\n\n**SilentYuki**\n\n> In contrast, if you adjust by `1+amount/3` instead, then it does not revert.\n\nAs mentioned the rounding error can be prevented and depends mainly on the inputted value by the admin.\n\n> So, as you can see, a very innocuous call to adjust renders the user unable to claim anything. This issue is valid.\n\nEven if admin makes false call to adjust and rounding error occurs, the DoS is only temporarily as admin can re-adjust to fix the issue.\n\n**jkoppel**\n\n> Even if admin makes false call to adjust and rounding error occurs, the DoS is only temporarily as admin can re-adjust to fix the issue.\n\nYes, and similar is true of #55, #141, #14, #188, #143, #130, and #41.  I don't see a way to mark this invalid without also marking all 7 of those other issues as invalid. Further, in this case, the proposed workaround using `adjust()` only works by exploiting buggy logic in the code.\n\n**hrishibhat**\n\n@jkoppel thanks for the context. So the way I see it, there is an error this would be an issue if `voteFactor` was set too low or not a multiple of fractionDenominator, and this value is not something that can be changed to fix this issue. correct? also there is no way to know what the best `voteFactor` would be as it could vary from case to case. \n\n\n**jkoppel**\n\nCorrect, this is an issue if `voteFactor` is not an exact multiple of `fractionDenominator`. The protocol clearly intends to allow many different values for `voteFactor`. The docs suggest a value of 15000 for voteFactor and 10000 for fractionDenominator, which does enable the vulnerability.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this issue a valid medium based on the comments above:\nhttps://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/56#issuecomment-1684238186\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [dot-pengun](https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/56/#issuecomment-1667060396): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/100",
  "Code": [
    {
      "filename": "contracts/contracts/claim/abstract/AdvancedDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport { ERC20Votes, ERC20Permit, ERC20 } from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { Distributor, DistributionRecord, IERC20 } from './Distributor.sol';\nimport { IAdjustable } from '../../interfaces/IAdjustable.sol';\nimport { IVoting } from '../../interfaces/IVoting.sol';\nimport { Sweepable } from '../../utilities/Sweepable.sol';\nimport { FairQueue } from '../../utilities/FairQueue.sol';\n\n/**\n * @title AdvancedDistributor\n * @notice Distributes tokens to beneficiaries with voting-while-vesting and administrative controls.\n * The contract owner can control these distribution parameters:\n * - the merkle root determining all distribution details\n * - adjustments to specific distributions\n * - the token being distributed\n * - the total amount to distribute\n * - the metadata URI\n * - the voting power of undistributed tokens\n * - the recipient of swept funds\n *\n * This contract also allows owners to perform several other admin functions\n * - updating the contract owner\n * - sweeping tokens and native currency to a recipient\n *\n * This contract tracks beneficiary voting power through an internal ERC20Votes token that cannot be transferred. The\n * beneficiary must delegate to an address to use this voting power. Their voting power decreases when the token is claimed.\n *\n * @dev Updates to the contract must follow these constraints:\n * - If a merkle root update alters the total token quantity to distribute across all users, also adjust the total value.\n *   The DistributionRecord for each beneficiary updated in the merkle root will be incorrect until a claim is executed.\n * - If the total changes, make sure to add or withdraw tokens being distributed to match the new total.\n */\nabstract contract AdvancedDistributor is\n  Ownable,\n  Sweepable,\n  ERC20Votes,\n  Distributor,\n  IAdjustable,\n  IVoting,\n  FairQueue\n{\n  using SafeERC20 for IERC20;\n\n  uint256 private voteFactor;\n\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri,\n    uint256 _voteFactor,\n    uint256 _fractionDenominator,\n    uint160 maxDelayTime,\n    uint160 salt\n  )\n    Distributor(_token, _total, _uri, _fractionDenominator)\n    ERC20Permit('Internal vote tracker')\n    ERC20('Internal vote tracker', 'IVT')\n    Sweepable(payable(msg.sender))\n    FairQueue(maxDelayTime, salt)\n  {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * convert a token quantity to a vote quantity\n   */\n  function tokensToVotes(uint256 tokenAmount) private view returns (uint256) {\n    return (tokenAmount * voteFactor) / fractionDenominator;\n  }\n\n  function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    // add voting power through ERC20Votes extension\n    _mint(beneficiary, tokensToVotes(totalAmount));\n  }\n\n  function _executeClaim(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override returns (uint256 _claimed) {\n    _claimed = super._executeClaim(beneficiary, totalAmount);\n\n    // reduce voting power through ERC20Votes extension\n    _burn(beneficiary, tokensToVotes(_claimed));\n  }\n\n  /**\n   * @dev Adjust the quantity claimable by a user, overriding the value in the distribution record.\n   *\n   * Note: If used in combination with merkle proofs, adjustments to a beneficiary's total could be\n   * reset by anyone to the value in the merkle leaf at any time. Update the merkle root instead.\n   *\n   * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n   */\n  function adjust(address beneficiary, int256 amount) external onlyOwner {\n    DistributionRecord memory distributionRecord = records[beneficiary];\n    require(distributionRecord.initialized, 'must initialize before adjusting');\n\n    uint256 diff = uint256(amount > 0 ? amount : -amount);\n    require(diff < type(uint120).max, 'adjustment > max uint120');\n\n    if (amount < 0) {\n      // decreasing claimable tokens\n      require(total >= diff, 'decrease greater than distributor total');\n      require(distributionRecord.total >= diff, 'decrease greater than distributionRecord total');\n      total -= diff;\n      records[beneficiary].total -= uint120(diff);\n      token.safeTransfer(owner(), diff);\n      // reduce voting power\n      _burn(beneficiary, tokensToVotes(diff));\n    } else {\n      // increasing claimable tokens\n      total += diff;\n      records[beneficiary].total += uint120(diff);\n      // increase voting pwoer\n      _mint(beneficiary, tokensToVotes(diff));\n    }\n\n    emit Adjust(beneficiary, amount);\n  }\n\n\n  function _setToken(IERC20 _token) internal virtual {\n    require(address(_token) != address(0), 'token is address(0)');\n    token = _token;\n    emit SetToken(token);\n  }\n\n  // Set the token being distributed\n  function setToken(IERC20 _token) external virtual onlyOwner {\n    _setToken(_token);\n  }\n\n  function _setTotal(uint256 _total) internal virtual {\n    total = _total;\n    emit SetTotal(total);\n  }\n\n  // Set the total to distribute\n  function setTotal(uint256 _total) external virtual onlyOwner {\n    _setTotal(_total);\n  }\n\n  // Set the distributor metadata URI\n  function setUri(string memory _uri) external onlyOwner {\n    uri = _uri;\n    emit SetUri(uri);\n  }\n\n  // set the recipient of swept funds\n  function setSweepRecipient(address payable _recipient) external onlyOwner {\n    _setSweepRecipient(_recipient);\n  }\n\n  function getTotalVotes() external view returns (uint256) {\n    // supply of internal token used to track voting power\n    return totalSupply();\n  }\n\n  function getVoteFactor(address) external view returns (uint256) {\n    return voteFactor;\n  }\n\n  /**\n\t* @notice Set the voting power of undistributed tokens\n\t* @param _voteFactor The voting power multiplier as a fraction of fractionDenominator\n\t* @dev The vote factor can be any integer. If voteFactor / fractionDenominator == 1,\n\t* one unclaimed token provides one vote. If voteFactor / fractionDenominator == 2, one\n\t* unclaimed token counts as two votes.\n\t*/\n  function setVoteFactor(uint256 _voteFactor) external onlyOwner {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * @dev the internal token used only for tracking voting power cannot be transferred\n   */\n  function _approve(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n\n  /**\n   * @dev the internal token used only f\tor tracking voting power cannot be transferred\n   */\n  function _transfer(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/abstract/AdvancedDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport { ERC20Votes, ERC20Permit, ERC20 } from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { Distributor, DistributionRecord, IERC20 } from './Distributor.sol';\nimport { IAdjustable } from '../../interfaces/IAdjustable.sol';\nimport { IVoting } from '../../interfaces/IVoting.sol';\nimport { Sweepable } from '../../utilities/Sweepable.sol';\nimport { FairQueue } from '../../utilities/FairQueue.sol';\n\n/**\n * @title AdvancedDistributor\n * @notice Distributes tokens to beneficiaries with voting-while-vesting and administrative controls.\n * The contract owner can control these distribution parameters:\n * - the merkle root determining all distribution details\n * - adjustments to specific distributions\n * - the token being distributed\n * - the total amount to distribute\n * - the metadata URI\n * - the voting power of undistributed tokens\n * - the recipient of swept funds\n *\n * This contract also allows owners to perform several other admin functions\n * - updating the contract owner\n * - sweeping tokens and native currency to a recipient\n *\n * This contract tracks beneficiary voting power through an internal ERC20Votes token that cannot be transferred. The\n * beneficiary must delegate to an address to use this voting power. Their voting power decreases when the token is claimed.\n *\n * @dev Updates to the contract must follow these constraints:\n * - If a merkle root update alters the total token quantity to distribute across all users, also adjust the total value.\n *   The DistributionRecord for each beneficiary updated in the merkle root will be incorrect until a claim is executed.\n * - If the total changes, make sure to add or withdraw tokens being distributed to match the new total.\n */\nabstract contract AdvancedDistributor is\n  Ownable,\n  Sweepable,\n  ERC20Votes,\n  Distributor,\n  IAdjustable,\n  IVoting,\n  FairQueue\n{\n  using SafeERC20 for IERC20;\n\n  uint256 private voteFactor;\n\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri,\n    uint256 _voteFactor,\n    uint256 _fractionDenominator,\n    uint160 maxDelayTime,\n    uint160 salt\n  )\n    Distributor(_token, _total, _uri, _fractionDenominator)\n    ERC20Permit('Internal vote tracker')\n    ERC20('Internal vote tracker', 'IVT')\n    Sweepable(payable(msg.sender))\n    FairQueue(maxDelayTime, salt)\n  {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * convert a token quantity to a vote quantity\n   */\n  function tokensToVotes(uint256 tokenAmount) private view returns (uint256) {\n    return (tokenAmount * voteFactor) / fractionDenominator;\n  }\n\n  function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    // add voting power through ERC20Votes extension\n    _mint(beneficiary, tokensToVotes(totalAmount));\n  }\n\n  function _executeClaim(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override returns (uint256 _claimed) {\n    _claimed = super._executeClaim(beneficiary, totalAmount);\n\n    // reduce voting power through ERC20Votes extension\n    _burn(beneficiary, tokensToVotes(_claimed));\n  }\n\n  /**\n   * @dev Adjust the quantity claimable by a user, overriding the value in the distribution record.\n   *\n   * Note: If used in combination with merkle proofs, adjustments to a beneficiary's total could be\n   * reset by anyone to the value in the merkle leaf at any time. Update the merkle root instead.\n   *\n   * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n   */\n  function adjust(address beneficiary, int256 amount) external onlyOwner {\n    DistributionRecord memory distributionRecord = records[beneficiary];\n    require(distributionRecord.initialized, 'must initialize before adjusting');\n\n    uint256 diff = uint256(amount > 0 ? amount : -amount);\n    require(diff < type(uint120).max, 'adjustment > max uint120');\n\n    if (amount < 0) {\n      // decreasing claimable tokens\n      require(total >= diff, 'decrease greater than distributor total');\n      require(distributionRecord.total >= diff, 'decrease greater than distributionRecord total');\n      total -= diff;\n      records[beneficiary].total -= uint120(diff);\n      token.safeTransfer(owner(), diff);\n      // reduce voting power\n      _burn(beneficiary, tokensToVotes(diff));\n    } else {\n      // increasing claimable tokens\n      total += diff;\n      records[beneficiary].total += uint120(diff);\n      // increase voting pwoer\n      _mint(beneficiary, tokensToVotes(diff));\n    }\n\n    emit Adjust(beneficiary, amount);\n  }\n\n\n  function _setToken(IERC20 _token) internal virtual {\n    require(address(_token) != address(0), 'token is address(0)');\n    token = _token;\n    emit SetToken(token);\n  }\n\n  // Set the token being distributed\n  function setToken(IERC20 _token) external virtual onlyOwner {\n    _setToken(_token);\n  }\n\n  function _setTotal(uint256 _total) internal virtual {\n    total = _total;\n    emit SetTotal(total);\n  }\n\n  // Set the total to distribute\n  function setTotal(uint256 _total) external virtual onlyOwner {\n    _setTotal(_total);\n  }\n\n  // Set the distributor metadata URI\n  function setUri(string memory _uri) external onlyOwner {\n    uri = _uri;\n    emit SetUri(uri);\n  }\n\n  // set the recipient of swept funds\n  function setSweepRecipient(address payable _recipient) external onlyOwner {\n    _setSweepRecipient(_recipient);\n  }\n\n  function getTotalVotes() external view returns (uint256) {\n    // supply of internal token used to track voting power\n    return totalSupply();\n  }\n\n  function getVoteFactor(address) external view returns (uint256) {\n    return voteFactor;\n  }\n\n  /**\n\t* @notice Set the voting power of undistributed tokens\n\t* @param _voteFactor The voting power multiplier as a fraction of fractionDenominator\n\t* @dev The vote factor can be any integer. If voteFactor / fractionDenominator == 1,\n\t* one unclaimed token provides one vote. If voteFactor / fractionDenominator == 2, one\n\t* unclaimed token counts as two votes.\n\t*/\n  function setVoteFactor(uint256 _voteFactor) external onlyOwner {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * @dev the internal token used only for tracking voting power cannot be transferred\n   */\n  function _approve(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n\n  /**\n   * @dev the internal token used only f\tor tracking voting power cannot be transferred\n   */\n  function _transfer(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/abstract/AdvancedDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport { ERC20Votes, ERC20Permit, ERC20 } from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { Distributor, DistributionRecord, IERC20 } from './Distributor.sol';\nimport { IAdjustable } from '../../interfaces/IAdjustable.sol';\nimport { IVoting } from '../../interfaces/IVoting.sol';\nimport { Sweepable } from '../../utilities/Sweepable.sol';\nimport { FairQueue } from '../../utilities/FairQueue.sol';\n\n/**\n * @title AdvancedDistributor\n * @notice Distributes tokens to beneficiaries with voting-while-vesting and administrative controls.\n * The contract owner can control these distribution parameters:\n * - the merkle root determining all distribution details\n * - adjustments to specific distributions\n * - the token being distributed\n * - the total amount to distribute\n * - the metadata URI\n * - the voting power of undistributed tokens\n * - the recipient of swept funds\n *\n * This contract also allows owners to perform several other admin functions\n * - updating the contract owner\n * - sweeping tokens and native currency to a recipient\n *\n * This contract tracks beneficiary voting power through an internal ERC20Votes token that cannot be transferred. The\n * beneficiary must delegate to an address to use this voting power. Their voting power decreases when the token is claimed.\n *\n * @dev Updates to the contract must follow these constraints:\n * - If a merkle root update alters the total token quantity to distribute across all users, also adjust the total value.\n *   The DistributionRecord for each beneficiary updated in the merkle root will be incorrect until a claim is executed.\n * - If the total changes, make sure to add or withdraw tokens being distributed to match the new total.\n */\nabstract contract AdvancedDistributor is\n  Ownable,\n  Sweepable,\n  ERC20Votes,\n  Distributor,\n  IAdjustable,\n  IVoting,\n  FairQueue\n{\n  using SafeERC20 for IERC20;\n\n  uint256 private voteFactor;\n\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri,\n    uint256 _voteFactor,\n    uint256 _fractionDenominator,\n    uint160 maxDelayTime,\n    uint160 salt\n  )\n    Distributor(_token, _total, _uri, _fractionDenominator)\n    ERC20Permit('Internal vote tracker')\n    ERC20('Internal vote tracker', 'IVT')\n    Sweepable(payable(msg.sender))\n    FairQueue(maxDelayTime, salt)\n  {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * convert a token quantity to a vote quantity\n   */\n  function tokensToVotes(uint256 tokenAmount) private view returns (uint256) {\n    return (tokenAmount * voteFactor) / fractionDenominator;\n  }\n\n  function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    // add voting power through ERC20Votes extension\n    _mint(beneficiary, tokensToVotes(totalAmount));\n  }\n\n  function _executeClaim(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override returns (uint256 _claimed) {\n    _claimed = super._executeClaim(beneficiary, totalAmount);\n\n    // reduce voting power through ERC20Votes extension\n    _burn(beneficiary, tokensToVotes(_claimed));\n  }\n\n  /**\n   * @dev Adjust the quantity claimable by a user, overriding the value in the distribution record.\n   *\n   * Note: If used in combination with merkle proofs, adjustments to a beneficiary's total could be\n   * reset by anyone to the value in the merkle leaf at any time. Update the merkle root instead.\n   *\n   * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n   */\n  function adjust(address beneficiary, int256 amount) external onlyOwner {\n    DistributionRecord memory distributionRecord = records[beneficiary];\n    require(distributionRecord.initialized, 'must initialize before adjusting');\n\n    uint256 diff = uint256(amount > 0 ? amount : -amount);\n    require(diff < type(uint120).max, 'adjustment > max uint120');\n\n    if (amount < 0) {\n      // decreasing claimable tokens\n      require(total >= diff, 'decrease greater than distributor total');\n      require(distributionRecord.total >= diff, 'decrease greater than distributionRecord total');\n      total -= diff;\n      records[beneficiary].total -= uint120(diff);\n      token.safeTransfer(owner(), diff);\n      // reduce voting power\n      _burn(beneficiary, tokensToVotes(diff));\n    } else {\n      // increasing claimable tokens\n      total += diff;\n      records[beneficiary].total += uint120(diff);\n      // increase voting pwoer\n      _mint(beneficiary, tokensToVotes(diff));\n    }\n\n    emit Adjust(beneficiary, amount);\n  }\n\n\n  function _setToken(IERC20 _token) internal virtual {\n    require(address(_token) != address(0), 'token is address(0)');\n    token = _token;\n    emit SetToken(token);\n  }\n\n  // Set the token being distributed\n  function setToken(IERC20 _token) external virtual onlyOwner {\n    _setToken(_token);\n  }\n\n  function _setTotal(uint256 _total) internal virtual {\n    total = _total;\n    emit SetTotal(total);\n  }\n\n  // Set the total to distribute\n  function setTotal(uint256 _total) external virtual onlyOwner {\n    _setTotal(_total);\n  }\n\n  // Set the distributor metadata URI\n  function setUri(string memory _uri) external onlyOwner {\n    uri = _uri;\n    emit SetUri(uri);\n  }\n\n  // set the recipient of swept funds\n  function setSweepRecipient(address payable _recipient) external onlyOwner {\n    _setSweepRecipient(_recipient);\n  }\n\n  function getTotalVotes() external view returns (uint256) {\n    // supply of internal token used to track voting power\n    return totalSupply();\n  }\n\n  function getVoteFactor(address) external view returns (uint256) {\n    return voteFactor;\n  }\n\n  /**\n\t* @notice Set the voting power of undistributed tokens\n\t* @param _voteFactor The voting power multiplier as a fraction of fractionDenominator\n\t* @dev The vote factor can be any integer. If voteFactor / fractionDenominator == 1,\n\t* one unclaimed token provides one vote. If voteFactor / fractionDenominator == 2, one\n\t* unclaimed token counts as two votes.\n\t*/\n  function setVoteFactor(uint256 _voteFactor) external onlyOwner {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * @dev the internal token used only for tracking voting power cannot be transferred\n   */\n  function _approve(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n\n  /**\n   * @dev the internal token used only f\tor tracking voting power cannot be transferred\n   */\n  function _transfer(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/abstract/AdvancedDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport { ERC20Votes, ERC20Permit, ERC20 } from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { Distributor, DistributionRecord, IERC20 } from './Distributor.sol';\nimport { IAdjustable } from '../../interfaces/IAdjustable.sol';\nimport { IVoting } from '../../interfaces/IVoting.sol';\nimport { Sweepable } from '../../utilities/Sweepable.sol';\nimport { FairQueue } from '../../utilities/FairQueue.sol';\n\n/**\n * @title AdvancedDistributor\n * @notice Distributes tokens to beneficiaries with voting-while-vesting and administrative controls.\n * The contract owner can control these distribution parameters:\n * - the merkle root determining all distribution details\n * - adjustments to specific distributions\n * - the token being distributed\n * - the total amount to distribute\n * - the metadata URI\n * - the voting power of undistributed tokens\n * - the recipient of swept funds\n *\n * This contract also allows owners to perform several other admin functions\n * - updating the contract owner\n * - sweeping tokens and native currency to a recipient\n *\n * This contract tracks beneficiary voting power through an internal ERC20Votes token that cannot be transferred. The\n * beneficiary must delegate to an address to use this voting power. Their voting power decreases when the token is claimed.\n *\n * @dev Updates to the contract must follow these constraints:\n * - If a merkle root update alters the total token quantity to distribute across all users, also adjust the total value.\n *   The DistributionRecord for each beneficiary updated in the merkle root will be incorrect until a claim is executed.\n * - If the total changes, make sure to add or withdraw tokens being distributed to match the new total.\n */\nabstract contract AdvancedDistributor is\n  Ownable,\n  Sweepable,\n  ERC20Votes,\n  Distributor,\n  IAdjustable,\n  IVoting,\n  FairQueue\n{\n  using SafeERC20 for IERC20;\n\n  uint256 private voteFactor;\n\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri,\n    uint256 _voteFactor,\n    uint256 _fractionDenominator,\n    uint160 maxDelayTime,\n    uint160 salt\n  )\n    Distributor(_token, _total, _uri, _fractionDenominator)\n    ERC20Permit('Internal vote tracker')\n    ERC20('Internal vote tracker', 'IVT')\n    Sweepable(payable(msg.sender))\n    FairQueue(maxDelayTime, salt)\n  {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * convert a token quantity to a vote quantity\n   */\n  function tokensToVotes(uint256 tokenAmount) private view returns (uint256) {\n    return (tokenAmount * voteFactor) / fractionDenominator;\n  }\n\n  function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    // add voting power through ERC20Votes extension\n    _mint(beneficiary, tokensToVotes(totalAmount));\n  }\n\n  function _executeClaim(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override returns (uint256 _claimed) {\n    _claimed = super._executeClaim(beneficiary, totalAmount);\n\n    // reduce voting power through ERC20Votes extension\n    _burn(beneficiary, tokensToVotes(_claimed));\n  }\n\n  /**\n   * @dev Adjust the quantity claimable by a user, overriding the value in the distribution record.\n   *\n   * Note: If used in combination with merkle proofs, adjustments to a beneficiary's total could be\n   * reset by anyone to the value in the merkle leaf at any time. Update the merkle root instead.\n   *\n   * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n   */\n  function adjust(address beneficiary, int256 amount) external onlyOwner {\n    DistributionRecord memory distributionRecord = records[beneficiary];\n    require(distributionRecord.initialized, 'must initialize before adjusting');\n\n    uint256 diff = uint256(amount > 0 ? amount : -amount);\n    require(diff < type(uint120).max, 'adjustment > max uint120');\n\n    if (amount < 0) {\n      // decreasing claimable tokens\n      require(total >= diff, 'decrease greater than distributor total');\n      require(distributionRecord.total >= diff, 'decrease greater than distributionRecord total');\n      total -= diff;\n      records[beneficiary].total -= uint120(diff);\n      token.safeTransfer(owner(), diff);\n      // reduce voting power\n      _burn(beneficiary, tokensToVotes(diff));\n    } else {\n      // increasing claimable tokens\n      total += diff;\n      records[beneficiary].total += uint120(diff);\n      // increase voting pwoer\n      _mint(beneficiary, tokensToVotes(diff));\n    }\n\n    emit Adjust(beneficiary, amount);\n  }\n\n\n  function _setToken(IERC20 _token) internal virtual {\n    require(address(_token) != address(0), 'token is address(0)');\n    token = _token;\n    emit SetToken(token);\n  }\n\n  // Set the token being distributed\n  function setToken(IERC20 _token) external virtual onlyOwner {\n    _setToken(_token);\n  }\n\n  function _setTotal(uint256 _total) internal virtual {\n    total = _total;\n    emit SetTotal(total);\n  }\n\n  // Set the total to distribute\n  function setTotal(uint256 _total) external virtual onlyOwner {\n    _setTotal(_total);\n  }\n\n  // Set the distributor metadata URI\n  function setUri(string memory _uri) external onlyOwner {\n    uri = _uri;\n    emit SetUri(uri);\n  }\n\n  // set the recipient of swept funds\n  function setSweepRecipient(address payable _recipient) external onlyOwner {\n    _setSweepRecipient(_recipient);\n  }\n\n  function getTotalVotes() external view returns (uint256) {\n    // supply of internal token used to track voting power\n    return totalSupply();\n  }\n\n  function getVoteFactor(address) external view returns (uint256) {\n    return voteFactor;\n  }\n\n  /**\n\t* @notice Set the voting power of undistributed tokens\n\t* @param _voteFactor The voting power multiplier as a fraction of fractionDenominator\n\t* @dev The vote factor can be any integer. If voteFactor / fractionDenominator == 1,\n\t* one unclaimed token provides one vote. If voteFactor / fractionDenominator == 2, one\n\t* unclaimed token counts as two votes.\n\t*/\n  function setVoteFactor(uint256 _voteFactor) external onlyOwner {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * @dev the internal token used only for tracking voting power cannot be transferred\n   */\n  function _approve(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n\n  /**\n   * @dev the internal token used only f\tor tracking voting power cannot be transferred\n   */\n  function _transfer(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/TrancheVestingSale_2_0.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { DistributionRecord } from '../interfaces/IDistributor.sol';\nimport { TrancheVesting, Tranche } from './abstract/TrancheVesting.sol';\nimport { MerkleSet } from './abstract/MerkleSet.sol';\nimport { FlatPriceSale } from '../sale/v2/FlatPriceSale.sol';\n\ncontract TrancheVestingSale_2_0 is TrancheVesting {\n  FlatPriceSale public immutable sale;\n  uint256 public immutable price;\n  uint8 public immutable soldTokenDecimals;\n\n  modifier validSaleParticipant(address beneficiary) {\n    require(sale.buyerTotal(beneficiary) != 0, 'no purchases found');\n\n    _;\n  }\n\n  constructor(\n    FlatPriceSale _sale, // where the purchase occurred\n    IERC20 _token, // the purchased token\n    uint8 _soldTokenDecimals, // the number of decimals used by the purchased token\n    // the price of the purchased token denominated in the sale's base currency with 8 decimals\n    // e.g. if the sale was selling $FOO at $0.55 per token, price = 55000000\n    uint256 _price,\n    Tranche[] memory tranches, // vesting tranches\n    uint256 voteWeightBips, // the factor for voting power (e.g. 15000 means users have a 50% voting bonus for unclaimed tokens)\n    string memory _uri // information on the sale (e.g. merkle proofs)\n  )\n    TrancheVesting(\n      _token,\n      (_sale.total() * 10 ** _soldTokenDecimals) / _price,\n      _uri,\n      voteWeightBips,\n      tranches,\n      0, // no delay\n      0 // no salt\n    )\n  {\n    require(address(_sale) != address(0), 'TVS_2_0_D: sale is address(0)');\n\n    // previously deployed v2.0 sales did not implement the isOver() method\n    (, , , , , , uint256 endTime, , ) = _sale.config();\n    require(endTime < block.timestamp, 'TVS_2_0_D: sale not over yet');\n    require(_price != 0, 'TVS_2_0_D: price is 0');\n\n    sale = _sale;\n    soldTokenDecimals = _soldTokenDecimals;\n    price = _price;\n  }\n\n  function NAME() external pure virtual override returns (string memory) {\n    return 'TrancheVestingSale_2_0';\n  }\n\n  // File specific version - starts at 1, increments on every solidity diff\n  function VERSION() external pure virtual override returns (uint256) {\n    return 5;\n  }\n\n  function getPurchasedAmount(address buyer) public view returns (uint256) {\n    /**\n    Get the quantity purchased from the sale and convert it to native tokens\n  \n    Example: if a user buys $1.11 of a FOO token worth $0.50 each, the purchased amount will be 2.22 FOO\n    - buyer total: 111000000 ($1.11 with 8 decimals)\n    - decimals: 6 (the token being purchased has 6 decimals)\n    - price: 50000000 ($0.50 with 8 decimals)\n\n    Calculation: 111000000 * 1000000 / 50000000\n\n    Returns purchased amount: 2220000 (2.22 with 6 decimals)\n    */\n    return (sale.buyerTotal(buyer) * (10 ** soldTokenDecimals)) / price;\n  }\n\n  function initializeDistributionRecord(\n    address beneficiary // the address that will receive tokens\n  ) external validSaleParticipant(beneficiary) {\n    _initializeDistributionRecord(beneficiary, getPurchasedAmount(beneficiary));\n  }\n\n  function claim(\n    address beneficiary // the address that will receive tokens\n  ) external validSaleParticipant(beneficiary) nonReentrant {\n    uint256 purchasedAmount = getPurchasedAmount(beneficiary);\n    // effects\n    uint256 claimedAmount = _executeClaim(beneficiary, purchasedAmount);\n    // interactions\n    _settleClaim(beneficiary, claimedAmount);\n  }\n\n  function getDistributionRecord(\n    address beneficiary\n  ) external view virtual override returns (DistributionRecord memory) {\n    DistributionRecord memory record = records[beneficiary];\n\n    // workaround prior to initialization\n    if (!record.initialized) {\n      record.total = uint120(getPurchasedAmount(beneficiary));\n    }\n    return record;\n  }\n\n  // get the number of tokens currently claimable by a specific user\n  function getClaimableAmount(address beneficiary) public view override returns (uint256) {\n    if (records[beneficiary].initialized) return super.getClaimableAmount(beneficiary);\n\n    // we can get the claimable amount prior to initialization\n    return\n      (getPurchasedAmount(beneficiary) * getVestedFraction(beneficiary, block.timestamp)) /\n      fractionDenominator;\n  }\n}"
    }
  ]
}