{
  "Title": "[M-07] Users can end up buying and paying for a different Tray than the one they were trying to acquire",
  "Content": "\nTrays and their tiles are the building blocks for fusing a Namespace NFT. The tiles in a tray are generated based on a hash of the previous mint.\n\nUsers will need specific tiles to be able to create the name they want, so it is of utter importance for them to get the trays they want with their corresponding tiles. The users should be able to precompute this, [as the documentation states](https://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-namespace-protocol/README.md#tray):\n\n\"The 7 tiles per tray are then generated according to a deterministic algorithm. A user can therefore precompute which trays he will get.\"\n\n### Impact\n\nUsers can pay the corresponding `$NOTE` tokens to buy a tray with some specific tiles, buy end up obtaining a completely different one with tiles they don't expect.\n\nThis can happen due to normal usage of the platform, with some user sending a transaction with more gas. Or by a malicious user frontrunning the transaction.\n\nOn any case the user ends up with an NFT he didn't want instead of reverting the transaction, and saving their `$NOTE` tokens.\n\n### Proof of Concept\n\nThere is no check on the `buy()` function to make sure that the user will actually buy the tray he wanted, thus possibly obtaining another one.\n\nThe tiles are calculated based on a hash. That hash is generated each time a new mint is produced, and it is based on the last one.\n\nIf the transaction is frontrunned, the user will get a new hash, and thus new tiles data for his tray.\n\n```solidity\nFile: canto-namespace-protocol/src/Tray.sol\n\n148:     /// @notice Buy a specifiable amount of trays\n149:     /// @param _amount Amount of trays to buy\n150:     function buy(uint256 _amount) external {\n151:         uint256 startingTrayId = _nextTokenId();\n152:         if (prelaunchMinted == type(uint256).max) {\n153:             // Still in prelaunch phase\n154:             if (msg.sender != owner) revert OnlyOwnerCanMintPreLaunch();\n155:             if (startingTrayId + _amount - 1 > PRE_LAUNCH_MINT_CAP) revert MintExceedsPreLaunchAmount();\n156:         } else {\n157:             SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, _amount * trayPrice);\n158:         }\n159:         for (uint256 i; i < _amount; ++i) {\n160:             TileData[TILES_PER_TRAY] memory trayTiledata;\n161:             for (uint256 j; j < TILES_PER_TRAY; ++j) {\n162:                 lastHash = keccak256(abi.encode(lastHash)); // @audit-info hash is calculated based on the last one\n163:                 trayTiledata[j] = _drawing(uint256(lastHash)); // @audit-info tiles data is calculated based on the hash\n164:             }\n165:             tiles[startingTrayId + i] = trayTiledata;\n166:         }\n167:         _mint(msg.sender, _amount); // We do not use _safeMint on purpose here to disallow callbacks and save gas\n168:     }\n```\n\n[Link to code](https://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-namespace-protocol/src/Tray.sol#L148-L168)\n\n### Recommended Mitigation Steps\n\nCheck the hash for the last minted Tray NFT, to make sure it is the same the user used to precalculate the next tiles.\n\nOn the case the transaction is frontrunned, the expected hash will be different and the transaction will revert, saving the user from spending the `$NOTE` tokens.\n\n```diff\n// File: canto-namespace-protocol/src/Tray.sol\n\n    /// @notice Buy a specifiable amount of trays\n    /// @param _amount Amount of trays to buy\n-    function buy(uint256 _amount) external {\n+    function buy(uint256 _amount, bytes32 _lastHash) external {\n+       require(_lastHash == lastHash, \"Hashes must be the same\");\n        uint256 startingTrayId = _nextTokenId();\n        if (prelaunchMinted == type(uint256).max) {\n            // Still in prelaunch phase\n            if (msg.sender != owner) revert OnlyOwnerCanMintPreLaunch();\n            if (startingTrayId + _amount - 1 > PRE_LAUNCH_MINT_CAP) revert MintExceedsPreLaunchAmount();\n        } else {\n            SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, _amount * trayPrice);\n        }\n        for (uint256 i; i < _amount; ++i) {\n            TileData[TILES_PER_TRAY] memory trayTiledata;\n            for (uint256 j; j < TILES_PER_TRAY; ++j) {\n                lastHash = keccak256(abi.encode(lastHash));\n                trayTiledata[j] = _drawing(uint256(lastHash));\n            }\n            tiles[startingTrayId + i] = trayTiledata;\n        }\n        _mint(msg.sender, _amount); // We do not use _safeMint on purpose here to disallow callbacks and save gas\n    }\n```\n\n**[OpenCoreCH (Canto Identity) acknowledged](https://github.com/code-423n4/2023-03-canto-identity-findings/issues/130#issuecomment-1489301818)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2023-03-canto-identity-findings/issues/130#issuecomment-1501902794):**\n > While this could be treated as a duplicate of [`#121`](https://github.com/code-423n4/2023-03-canto-identity-findings/issues/121), I like how the warden has provided a remediation which would protect users from being front-run and receiving an unexpected ID.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-03-canto-identity-subprotocols-contest",
  "Code": [
    {
      "filename": "canto-namespace-protocol/README.md",
      "content": "# Canto Namespace Protocol\n\nCanto Namespace Protocol is a subprotocol for the Canto Identity Protocol that enables users to mint names with tiles that are contained in trays. Trays can be minted for a fee or traded on the secondary market.\n\n## Tray\nA tray is represented as an ERC721 token (NFT). Each tray contains 7 tiles (see below). A user calls `buy` and passes in an `amount` to buy the specified amount of trays. Each tray has a fixed price. The 7 tiles per tray are then generated according to a deterministic algorithm. A user can therefore precompute which trays he will get.\n\nAn image for every tray is dynamically generated. Two example trays are shown here:\n![Example Tray 1](./docs/sample_tray1.svg)\n\n![Example Tray 2](./docs/sample_tray2.svg)\n\nThere is a prelaunch phase where trays can be minted for distribution to the community. However, these trays can only be used (transferred or fused) during the prelaunch phase and become useless afterwards. \n\n## Tile\nA tile is one character in a specific font. Different fonts have different probabilities to appear in a tile. The fonts are:\n| **Font Class** | **Name**        | **Shares** | **Characters** |\n|----------------|-----------------|------------|----------------|\n| 0              | Emoji*           | 32         | âœ¨âœ…â—âš¡â˜•â­âŒâš½â“â°â­•âš«âš¾â˜”âšªâœ‹âœŠğŸ˜‚ğŸ¤£ğŸ˜­ğŸ˜˜ğŸ¥°ğŸ˜ğŸ˜ŠğŸ‰ğŸ˜ğŸ’•ğŸ¥ºğŸ˜…ğŸ”¥ğŸ™„ğŸ˜†ğŸ¤—ğŸ˜‰ğŸ‚ğŸ¤”ğŸ™‚ğŸ˜³ğŸ¥³ğŸ˜ğŸ’œğŸ˜”ğŸ’–ğŸ‘€ğŸ˜‹ğŸ˜ğŸ˜¢ğŸ’—ğŸ˜©ğŸ’¯ğŸŒ¹ğŸ’ğŸˆğŸ’™ğŸ˜ƒğŸ˜¡ğŸ’ğŸ˜œğŸ™ˆğŸ˜„ğŸ¤¤ğŸ¤ªğŸ˜€ğŸ’‹ğŸ’€ğŸ’”ğŸ˜ŒğŸ’“ğŸ¤©ğŸ™ƒğŸ˜¬ğŸ˜±ğŸ˜´ğŸ¤­ğŸ˜ğŸŒğŸ˜’ğŸ˜‡ğŸŒ¸ğŸ˜ˆğŸ¶ğŸŠğŸ¥µğŸ˜ğŸ’šğŸ–¤ğŸ’°ğŸ˜šğŸ‘‘ğŸğŸ’¥ğŸ˜‘ğŸ¥´ğŸ’©ğŸ¤®ğŸ˜¤ğŸ¤¢ğŸŒŸğŸ˜¥ğŸŒˆğŸ’›ğŸ˜ğŸ˜«ğŸ˜²ğŸ”´ğŸŒ»ğŸ¤¯ğŸ¤¬ğŸ˜•ğŸ€ğŸ’¦ğŸ¦‹ğŸ¤¨ğŸŒºğŸ˜¹ğŸŒ·ğŸ’ğŸ’¤ğŸ°ğŸ˜“ğŸ’˜ğŸ»ğŸ˜ŸğŸ˜£ğŸ§ğŸ˜ ğŸ¤ ğŸ˜»ğŸŒ™ğŸ˜›ğŸ™ŠğŸ§¡ğŸ¤¡ğŸ¤«ğŸŒ¼ğŸ¥‚ğŸ˜·ğŸ¤“ğŸ¥¶ğŸ˜¶ğŸ˜–ğŸµğŸ˜™ğŸ†ğŸ¤‘ğŸ˜—ğŸ¶ğŸ“ğŸ‘…ğŸ‘„ğŸŒ¿ğŸš¨ğŸ“£ğŸ‘ğŸƒğŸ˜®ğŸ’ğŸ“¢ğŸŒ±ğŸ™ğŸ·ğŸ˜ªğŸŒšğŸ†ğŸ’ğŸ’‰ğŸ’¢ğŸ›’ğŸ˜¸ğŸ¾ğŸš€ğŸ¯ğŸºğŸ“ŒğŸ“·ğŸ’¨ğŸ•ğŸ ğŸ“¸ğŸ‡ğŸš©ğŸ˜°ğŸŒŠğŸ•ğŸ’«ğŸ˜µğŸ¤ğŸ¡ğŸ¥€ğŸ¤§ğŸ¾ğŸ°ğŸğŸ˜¯ğŸ’ŒğŸ’¸ğŸ§ğŸ˜ºğŸ’§ğŸ’£ğŸ¤ğŸğŸ·ğŸ¥ğŸ“ğŸ€ğŸ¥‡ğŸŒğŸ”«ğŸ±ğŸ£ğŸ§ğŸ’ŸğŸ‘¹ğŸ’ğŸ¼ğŸ’¡ğŸ˜½ğŸŠğŸ˜¨ğŸ«ğŸ§¢ğŸ¤•ğŸš«ğŸ¼ğŸ»ğŸ“²ğŸ‘»ğŸ‘¿ğŸŒ®ğŸ­ğŸŸğŸ¸ğŸğŸˆğŸ”µğŸ”ªğŸ˜§ğŸŒ„ğŸ˜¾ğŸ“±ğŸ‡ğŸŒ´ğŸ¢ğŸŒƒğŸ‘½ğŸŒğŸ“ºğŸ””ğŸŒ…ğŸ¦„ğŸ¥ğŸ‹ğŸ¥šğŸ’²ğŸ“šğŸ”ğŸ¸ğŸ¥ƒğŸ˜¿ğŸš—ğŸŒğŸ”ŠğŸ¦…ğŸš¿ğŸ¦†ğŸ‰ğŸ¬ğŸ§¸ğŸ¨ğŸ“ğŸ“©ğŸ’µğŸ’­ğŸŒğŸ¿ğŸ§¿ğŸ€ğŸğŸŒ³ğŸ™‰ğŸ˜¦ğŸ¹ğŸ¦ğŸ›‘ğŸ”ğŸ‚ğŸ’ğŸªğŸ™€ğŸ—ğŸŒ ğŸ¬ğŸŒµğŸ„ğŸğŸ©ğŸ¦ğŸ“ğŸ…ğŸğŸ’¬ğŸ¥¤ğŸ˜¼ğŸŒ¾ğŸ§€ğŸ®ğŸ§ ğŸŒğŸ”ğŸŒ‰ğŸ¤’ğŸ‘—ğŸŒ²ğŸœğŸ¦ğŸ¯ğŸ…ğŸ¼ğŸ’„ğŸ‘ºğŸ”ğŸ†ğŸ¨ğŸğŸ‡ğŸ¦œğŸ‘ğŸ™ğŸ¦ğŸ”—ğŸ“–ğŸ”¹ğŸ¥“ğŸ¥’ğŸ¸ğŸ‘ğŸ™ğŸ¤¦ğŸ¤·ğŸ‘ğŸ‘ŒğŸ’ªğŸ‘‰ğŸ¤ğŸ™ŒğŸ‘‡ğŸ™‹ğŸ‘ˆğŸ‘‹ğŸ–•ğŸ’ƒğŸ‘ŠğŸƒğŸ¤˜ğŸ¤ğŸ¤™ğŸš¶ğŸ’…ğŸ¤ŸğŸ‘ğŸ™‡ğŸ‘¶ğŸ¤²ğŸ‘†ğŸ•ºğŸ’ğŸ™…ğŸ§šğŸ¤¸ğŸ‘ğŸ¤šğŸ‘¼ğŸ‘§ğŸ¤œğŸ¤°ğŸ§˜ğŸ™†ğŸ‘¸ğŸ‘¦ğŸ›ŒğŸ¤›ğŸ‘®â¤ï¸â˜ºï¸â™¥ï¸â£ï¸âœŒï¸â˜€ï¸â˜¹ï¸â€¼ï¸â˜ ï¸â¡ï¸âš ï¸âœ”ï¸â˜ï¸â¬‡ï¸â„ï¸â‰ï¸â˜ï¸âœï¸â˜˜ï¸âœˆï¸â–¶ï¸âœï¸â¬…ï¸â˜ï¸â˜‘ï¸â™»ï¸ğŸ‘ï¸ğŸ–ï¸ğŸ—£ï¸ğŸŒ§ï¸ğŸ•Šï¸ğŸµï¸ğŸ–ï¸ğŸ‡ºğŸ‡¸ğŸ‡§ğŸ‡·ğŸ‡ºğŸ‡²ğŸ³ï¸â€ğŸŒˆ |\n| 1              | Basic           | 32         | abcdefghijklmnopqrstuvwxyz0123456789 |\n| 2              | Script          | 16         | ğ’¶ğ’·ğ’¸ğ’¹ğ‘’ğ’»ğ‘”ğ’½ğ’¾ğ’¿ğ“€ğ“ğ“‚ğ“ƒğ‘œğ“…ğ“†ğ“‡ğ“ˆğ“‰ğ“Šğ“‹ğ“Œğ“ğ“ğ“ |\n| 3              | Script Bold     | 8          | ğ“ªğ“«ğ“¬ğ“­ğ“®ğ“¯ğ“°ğ“±ğ“²ğ“³ğ“´ğ“µğ“¶ğ“·ğ“¸ğ“¹ğ“ºğ“»ğ“¼ğ“½ğ“¾ğ“¿ğ”€ğ”ğ”‚ğ”ƒ |\n| 4              | Olde            | 8          | ğ”ğ”Ÿğ” ğ”¡ğ”¢ğ”£ğ”¤ğ”¥ğ”¦ğ”§ğ”¨ğ”©ğ”ªğ”«ğ”¬ğ”­ğ”®ğ”¯ğ”°ğ”±ğ”²ğ”³ğ”´ğ”µğ”¶ğ”· |\n| 5              | Olde Bold       | 4          | ğ–†ğ–‡ğ–ˆğ–‰ğ–Šğ–‹ğ–Œğ–ğ–ğ–ğ–ğ–‘ğ–’ğ–“ğ–”ğ–•ğ––ğ–—ğ–˜ğ–™ğ–šğ–›ğ–œğ–ğ–ğ–Ÿ |\n| 6              | Squiggle        | 4          | Î±á‚¦ÆˆÔƒÒ½ÏÉ Ô‹Î¹ÊÆ™Ê…É±É³ÏƒÏÏ™É¾Ê‚ÆšÏ…Ê‹É¯xáƒ§È¥ |\n| 7              | <br>Zalgo**<br><br>           | 2          | aÌ·ÌÍ’Ì‡Ì…Ì‰ÌŒÌ¢ÌÌ«Ì­bÌ¸Ì†Í‹Ì‚Ì„Ì¿Í„Ì„Í„Ì“Ì²Ì¡Ì¡ÌªÌ™Í‡cÌ¶Í˜ÌÌÌÍ€Ì«Ì±dÌ·ÌÌ¾Ì³ÌŸÌ®Ì¼Í™Ì«Ì¬Ì«ÍÍeÌ¸ÌƒÌ‹ÍÍœfÌ´Í˜Í„Ì­Í•Ì¬ÌªÍ‰ÌgÌ´Ì’Í”Ì¤ÍÌ¤Ì«Ì¢Ì¥Ì Ì¥ÌºhÌ´Ì‚Í’ÍÍ›Ì©ÍˆÍ•Ì¦Ì°Ì¢Í“Ì¨ÌºiÌ´ÍƒÍ ÍŠÌšÍŠÍ–Í™Í…Ì³Ì»Ì¨jÌ¶ÍÌÌ¿ÌˆÍ™Í–Í‰ÌªkÌ·ÍŠÌÍŠÍ‘Ì‚Ì¾ÌÍÍ’ÌƒÌ°Í‰ÍlÌ¸Ì‹Ì¾Ì§Ì¥Ì¬Í‰Ì³Í–mÌ¶Í’ÍÌ€Í„Ì¿Ì³Í…Í–Ì¨Ì«Ì«Ì—Ì§nÌ¸Í€Ì›Í’ÌÌ‘Í™Ì²ÌºoÌµÌ‘Í‘Í ÌŒÌÌ„Ì‘Ì‚ÍÍÌºÌ˜Ì¬Ì­Ì˜pÌ·Ì”Í‘Ì‹ÌŒÌ¾Ì¿Ì¬Í‡ÌÌ¡qÌ¶ÌŠÍ—Ì‚ÌˆÌ„ÍŠÌ’Ì¡Í…Ì¼Ì™Ì²Ì³Ì°ÍˆrÌ·ÌŒÌ›Ì°sÌ¶ÍŠÌ‹ÍÍ„Ì‘ÍÌŒÌ’ÍŒÌ³Ì²Ì¼tÌµÌ†Ì¾Í˜ÌŒÍŒÍ…uÌ·Ì”ÍœÌ¥Ì«Ì¹vÌ¶Í ÍÌ…ÌÌ»Ì¤Ì¥wÌ·ÌÍ‚ÌšÍŠÍ’Í Í‹ÍÌÍ•Ì©Ì¤Ì¬Ì¢Ì®Ì™ÌªÍˆÌ²xÌ¶Í‹Í’ÌŠÍÌÌ ÌºÌ»Ì±yÌµÍÌƒÍ„Í˜Ì¥ÌŸÌ­Ì¯Ì«Ì²Í…Ì¢zÌ´Í˜ÍŒÍ‹ÍÌ‹Í’Ì¿Ì¾Ì‡ÌÍ™Ì–|\n| 8              | Blocks          | 2          | ğŸ„°ğŸ„±ğŸ„²ğŸ„³ğŸ„´ğŸ„µğŸ„¶ğŸ„·ğŸ„¸ğŸ„¹ğŸ„ºğŸ„»ğŸ„¼ğŸ„½ğŸ„¾ğŸ„¿ğŸ…€ğŸ…ğŸ…‚ğŸ…ƒğŸ…„ğŸ……ğŸ…†ğŸ…‡ğŸ…ˆğŸ…‰ |\n| 9              | Blocks Inverted | 1          | ğŸ…°ğŸ…±ğŸ…²ğŸ…³ğŸ…´ğŸ…µğŸ…¶ğŸ…·ğŸ…¸ğŸ…¹ğŸ…ºğŸ…»ğŸ…¼ğŸ…½ğŸ…¾ğŸ…¿ğŸ†€ğŸ†ğŸ†‚ğŸ†ƒğŸ†„ğŸ†…ğŸ††ğŸ†‡ğŸ†ˆğŸ†‰ |\n\n*For emojis that support skin tone modifiers, these can be specified when fusing. For instance, ğŸ‘ becomes ğŸ‘ğŸ¿ when the skin tone modifier 5 is passed. The following skin tone modifiers are supported:\n| **Value** | **Modifier**        |\n|-----------|---------------------|\n| 0         | Yellow, no modifier |\n| 1         | ğŸ»                   |\n| 2         | ğŸ¼                   |\n| 3         | ğŸ½                   |\n| 4         | ğŸ¾                   |\n| 5         | ğŸ¿                   |\n\n\n**Note that the Zalgo distortions are individually generated for every tile. The number of characters is therefore much higher, as every character can appear with different distortions.\n\n## Namespace\nDifferent tiles can be fused to a namespace NFT. For instance, you can fuse the name ğ’¸ğ“ªğ”«ğ–™ğŸ…¾ if you own trays with these characters (in these fonts). Afterwards, the name ğ’¸ğ“ªğ”«ğ–™ğŸ…¾ will resolve to the fused namespace NFT. For namespaces, an image is also generated dynamically on-chain, e.g.:\n![Example Name](./docs/sample_name.svg)\n\n### Fusing\nTo fuse a namespace NFT, the user specifies the trays and the tiles (offsets) within the trays to use. Note that the whole tray is always burned, even if you only use some tiles of a tray.\nFor some emojis, the user can specify a skin tone modifier which will be applied.\n\nA fusing fee that is proportial to the length of the name is charged."
    },
    {
      "filename": "canto-namespace-protocol/src/Tray.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721A} from \"erc721a/ERC721A.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"./Utils.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Tray is ERC721A, Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of tiles that are in one tray\n    uint256 private constant TILES_PER_TRAY = 7;\n\n    /// @notice Sum of the odds for all fonts\n    uint256 private constant SUM_ODDS = 109;\n\n    /// @notice Number of characters for emojis\n    uint256 private constant NUM_CHARS_EMOJIS = 420;\n\n    /// @notice Number of characters for letters\n    uint256 private constant NUM_CHARS_LETTERS = 26;\n\n    /// @notice Number of characters for letters and numbers\n    uint256 private constant NUM_CHARS_LETTERS_NUMBERS = 36;\n\n    /// @notice Maximum number of trays that can be minted pre-launch (by the owner)\n    uint256 private constant PRE_LAUNCH_MINT_CAP = 1_000;\n\n    /// @notice Price of one tray in $NOTE\n    uint256 public immutable trayPrice;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Wallet that receives the revenue\n    address private revenueAddress;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public note;\n\n    /// @notice Reference to the Namespace NFT contract\n    address public immutable namespaceNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Font and character index of a tile\n    struct TileData {\n        /// @notice Allowed values between 0 (emoji) and 9 (font5 rare)\n        uint8 fontClass;\n        /// @notice For Emojis (font class 0) between 0..NUM_CHARS_EMOJIS - 1, otherwise between 0..NUM_CHARS_LETTERS - 1\n        uint16 characterIndex;\n        /// @notice For generative fonts with randomness (Zalgo), we generate and fix this on minting. For some emojis, it can be set by the user to influence the skin color\n        uint8 characterModifier;\n    }\n\n    /// @notice Stores the content of a tray, i.e. all tiles\n    mapping(uint256 => TileData[TILES_PER_TRAY]) private tiles;\n\n    ///Â @notice Last hash that was used to generate a tray\n    bytes32 public lastHash;\n\n    /// @notice Set to the number of minted NFTs after the prelaunch has ended\n    uint256 private prelaunchMinted = type(uint256).max;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event RevenueAddressUpdated(address indexed oldRevenueAddress, address indexed newRevenueAddress);\n    event NoteAddressUpdate(address indexed oldNoteAddress, address indexed newNoteAddress);\n    event PrelaunchEnded();\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error CallerNotAllowedToBurn();\n    error TrayNotMinted(uint256 tokenID);\n    error OnlyOwnerCanMintPreLaunch();\n    error MintExceedsPreLaunchAmount();\n    error PrelaunchTrayCannotBeUsedAfterPrelaunch(uint256 startTokenId);\n    error PrelaunchAlreadyEnded();\n\n    /// @notice Sets the initial hash, tray price, and the revenue address\n    /// @param _initHash Hash to initialize the system with. Will determine the generation sequence of the trays\n    /// @param _trayPrice Price of one tray in $NOTE\n    /// @param _revenueAddress Adress to send the revenue to\n    /// @param _note Address of the $NOTE token\n    /// @param _namespaceNFT Address of the Namespace NFT\n    constructor(\n        bytes32 _initHash,\n        uint256 _trayPrice,\n        address _revenueAddress,\n        address _note,\n        address _namespaceNFT\n    ) ERC721A(\"Namespace Tray\", \"NSTRAY\") Owned(msg.sender) {\n        lastHash = _initHash;\n        trayPrice = _trayPrice;\n        revenueAddress = _revenueAddress;\n        note = ERC20(_note);\n        namespaceNFT = _namespaceNFT;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (!_exists(_id)) revert TrayNotMinted(_id);\n        uint256 numPrelaunchMinted = prelaunchMinted;\n        if (numPrelaunchMinted != type(uint256).max) {\n            // Prelaunch trays become invalid after the phase has ended\n            if (_id <= numPrelaunchMinted) revert PrelaunchTrayCannotBeUsedAfterPrelaunch(_id);\n        }\n        // Need to do an explicit copy here, implicit one not supported\n        TileData[TILES_PER_TRAY] storage storedNftTiles = tiles[_id];\n        TileData[] memory nftTiles = new TileData[](TILES_PER_TRAY);\n        for (uint256 i; i < TILES_PER_TRAY; ++i) {\n            nftTiles[i] = storedNftTiles[i];\n        }\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"Tray #',\n                        LibString.toString(_id),\n                        '\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(Utils.generateSVG(nftTiles, true))),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Buy a specifiable amount of trays\n    /// @param _amount Amount of trays to buy\n    function buy(uint256 _amount) external {\n        uint256 startingTrayId = _nextTokenId();\n        if (prelaunchMinted == type(uint256).max) {\n            // Still in prelaunch phase\n            if (msg.sender != owner) revert OnlyOwnerCanMintPreLaunch();\n            if (startingTrayId + _amount - 1 > PRE_LAUNCH_MINT_CAP) revert MintExceedsPreLaunchAmount();\n        } else {\n            SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, _amount * trayPrice);\n        }\n        for (uint256 i; i < _amount; ++i) {\n            TileData[TILES_PER_TRAY] memory trayTiledata;\n            for (uint256 j; j < TILES_PER_TRAY; ++j) {\n                lastHash = keccak256(abi.encode(lastHash));\n                trayTiledata[j] = _drawing(uint256(lastHash));\n            }\n            tiles[startingTrayId + i] = trayTiledata;\n        }\n        _mint(msg.sender, _amount); // We do not use _safeMint on purpose here to disallow callbacks and save gas\n    }\n\n    /// @notice Burn a specified tray\n    /// @dev Callable by the owner, an authorized address, or the Namespace NFT (when fusing)\n    /// @param _id Tray ID\n    function burn(uint256 _id) external {\n        address trayOwner = ownerOf(_id);\n        if (\n            namespaceNFT != msg.sender &&\n            trayOwner != msg.sender &&\n            getApproved(_id) != msg.sender &&\n            !isApprovedForAll(trayOwner, msg.sender)\n        ) revert CallerNotAllowedToBurn();\n        if (msg.sender == namespaceNFT) {\n            // Disallow fusing for prelaunch trays after phase has ended\n            uint256 numPrelaunchMinted = prelaunchMinted;\n            if (numPrelaunchMinted != type(uint256).max && _id <= numPrelaunchMinted)\n                revert PrelaunchTrayCannotBeUsedAfterPrelaunch(_id);\n        }\n        delete tiles[_id];\n        _burn(_id);\n    }\n\n    /// @notice Get the information about one tile\n    /// @dev Reverts for non-existing tray ID\n    /// @param _trayId Tray to query\n    /// @param _tileOffset Offset of the tile within the query, needs to be between 0 .. TILES_PER_TRAY - 1\n    function getTile(uint256 _trayId, uint8 _tileOffset) external view returns (TileData memory tileData) {\n        if (!_exists(_trayId)) revert TrayNotMinted(_trayId);\n        tileData = tiles[_trayId][_tileOffset];\n    }\n\n    /// @notice Query all tiles of a tray\n    /// @dev Reverts for non-existing tray ID\n    /// @param _trayId Tray to query\n    function getTiles(uint256 _trayId) external view returns (TileData[TILES_PER_TRAY] memory tileData) {\n        if (!_exists(_trayId)) revert TrayNotMinted(_trayId);\n        tileData = tiles[_trayId];\n    }\n\n    /// @notice Change the address of the $NOTE token\n    /// @param _newNoteAddress New address to use\n    function changeNoteAddress(address _newNoteAddress) external onlyOwner {\n        address currentNoteAddress = address(note);\n        note = ERC20(_newNoteAddress);\n        emit NoteAddressUpdate(currentNoteAddress, _newNoteAddress);\n    }\n\n    /// @notice Change the revenue address\n    /// @param _newRevenueAddress New address to use\n    function changeRevenueAddress(address _newRevenueAddress) external onlyOwner {\n        address currentRevenueAddress = revenueAddress;\n        revenueAddress = _newRevenueAddress;\n        emit RevenueAddressUpdated(currentRevenueAddress, _newRevenueAddress);\n    }\n\n    /// @notice End the prelaunch phase and start the public mint\n    function endPrelaunchPhase() external onlyOwner {\n        if (prelaunchMinted != type(uint256).max) revert PrelaunchAlreadyEnded();\n        prelaunchMinted = _nextTokenId() - 1;\n        emit PrelaunchEnded();\n    }\n\n    function _beforeTokenTransfers(\n        address, /* from*/\n        address to,\n        uint256 startTokenId,\n        uint256 /* quantity*/\n    ) internal view override {\n        uint256 numPrelaunchMinted = prelaunchMinted;\n        if (numPrelaunchMinted != type(uint256).max) {\n            // We do not allow any transfers of the prelaunch trays after the phase has ended\n            if (startTokenId <= numPrelaunchMinted && to != address(0))\n                revert PrelaunchTrayCannotBeUsedAfterPrelaunch(startTokenId);\n        }\n    }\n\n    function _drawing(uint256 _seed) private pure returns (TileData memory tileData) {\n        uint256 res = _seed % SUM_ODDS;\n        uint256 charRandValue = Utils.iteratePRNG(_seed); // Iterate PRNG to not have any biasedness / correlation between random numbers\n        if (res < 32) {\n            // Class is 0 in that case\n            tileData.characterIndex = uint16(charRandValue % NUM_CHARS_EMOJIS);\n        } else {\n            tileData.characterIndex = uint16(charRandValue % NUM_CHARS_LETTERS);\n            if (res < 64) {\n                tileData.fontClass = 1;\n                tileData.characterIndex = uint16(charRandValue % NUM_CHARS_LETTERS_NUMBERS);\n            } else if (res < 80) {\n                tileData.fontClass = 2;\n            } else if (res < 96) {\n                tileData.fontClass = 3 + uint8((res - 80) / 8);\n            } else if (res < 104) {\n                tileData.fontClass = 5 + uint8((res - 96) / 4);\n            } else if (res < 108) {\n                tileData.fontClass = 7 + uint8((res - 104) / 2);\n                if (tileData.fontClass == 7) {\n                    // Set seed for Zalgo to ensure same characters will be always generated for this tile\n                    uint256 zalgoSeed = Utils.iteratePRNG(_seed);\n                    tileData.characterModifier = uint8(zalgoSeed % 256);\n                }\n            } else {\n                tileData.fontClass = 9;\n            }\n        }\n    }\n\n    /// @dev Overridden function of ERC721A to start minting at 1\n    function _startTokenId() internal pure override returns (uint256) {\n        return 1;\n    }\n}"
    }
  ]
}