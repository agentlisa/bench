{
  "Title": "M-12: `FlashRolloverLoan_G5` will fail for `LenderCommitmentGroup_Smart` due to `CollateralManager` pulling collateral from `FlashRolloverLoan_G5`",
  "Content": "# Issue M-12: `FlashRolloverLoan_G5` will fail for `LenderCommitmentGroup_Smart` due to `CollateralManager` pulling collateral from `FlashRolloverLoan_G5` \n\nSource: https://github.com/sherlock-audit/2024-04-teller-finance-judging/issues/138 \n\n## Found by \n0x73696d616f, 0xadrii, bughuntoor, merlin\n## Summary\n\n`FlashRolloverLoan_G5` calls `SmartCommitmentForwarder::acceptCommitmentWithRecipient()`, which will have `CollateralManager` commiting tokens from `FlashRolloverLoan_G5`, which will revert as it does not approve it nor have the funds.\n\n## Vulnerability Detail\n\nThe issue lies in the fact that `FlashRolloverLoan_G5` assumes `SmartCommitmentForwarder` gets the borrower from the [last 20 bytes](https://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/FlashRolloverLoan_G5.sol#L303), but it sets the `borrower` to [msg.sender](https://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/SmartCommitmentForwarder.sol#L106) instead.\n\nThus, in `SmartCommitmentForwarder::acceptCommitmentWithRecipient()`, `TellerV2::submitBid()` is called with the borrower being `FlashRolloverLoan_G5`, which will end up having the `CollateralManager` [pulling](https://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol#L334-L336) collateral from `FlashRolloverLoan_G5`, which will fail, as it does not deal with this.\n\n## Impact\n\n`FlashRolloverLoan_G5` will never work for `LenderCommitmentGroup_Smart` loans.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/FlashRolloverLoan_G5.sol#L303\nhttps://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/SmartCommitmentForwarder.sol#L106\n\n## Tool used\n\nManual Review\n\nVscode\n\n## Recommendation\n\nIn `FlashRolloverLoan_G5::_acceptCommitment()` pull the collateral from the borrower and approve the `CollateralManager`.\n\n\n\n## Discussion\n\n**ethereumdegen**\n\nI believe the fix is described in #31  and the SCF contract just has to inherit ExtensionsContextUpgradeable\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/teller-protocol/teller-protocol-v2-audit-2024/pull/35\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/295",
  "Code": [
    {
      "filename": "teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/FlashRolloverLoan_G5.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Interfaces\nimport \"../../interfaces/ITellerV2.sol\";\nimport \"../../interfaces/IProtocolFee.sol\";\nimport \"../../interfaces/ITellerV2Storage.sol\";\nimport \"../../interfaces/IMarketRegistry.sol\";\nimport \"../../interfaces/ILenderCommitmentForwarder.sol\";\nimport \"../../interfaces/ISmartCommitmentForwarder.sol\";\nimport \"../../interfaces/IFlashRolloverLoan_G4.sol\";\nimport \"../../libraries/NumbersLib.sol\";\n\nimport { IPool } from \"../../interfaces/aave/IPool.sol\";\nimport { IFlashLoanSimpleReceiver } from \"../../interfaces/aave/IFlashLoanSimpleReceiver.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/aave/IPoolAddressesProvider.sol\";\n\ncontract FlashRolloverLoan_G5 is IFlashLoanSimpleReceiver, IFlashRolloverLoan_G4 {\n    using AddressUpgradeable for address;\n    using NumbersLib for uint256;\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    ITellerV2 public immutable TELLER_V2;\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    \n\n    address public immutable POOL_ADDRESSES_PROVIDER;\n\n    event RolloverLoanComplete(\n        address borrower,\n        uint256 originalLoanId,\n        uint256 newLoanId,\n        uint256 fundsRemaining\n    );\n\n    struct AcceptCommitmentArgs {\n        uint256 commitmentId;\n        address smartCommitmentAddress;  //if this is not address(0), we will use this ! leave empty if not used. \n        uint256 principalAmount;\n        uint256 collateralAmount;\n        uint256 collateralTokenId;\n        address collateralTokenAddress;\n        uint16 interestRate;\n        uint32 loanDuration;\n        bytes32[] merkleProof; //empty array if not used\n    }\n\n    /**\n     *\n     * @notice Initializes the FlashRolloverLoan with necessary contract addresses.\n     *\n     * @dev Using a custom OpenZeppelin upgrades tag. Ensure the constructor logic is safe for upgrades.\n     *\n     * @param _tellerV2 The address of the TellerV2 contract.\n     * @param _lenderCommitmentForwarder The address of the LenderCommitmentForwarder contract.\n     * @param _poolAddressesProvider The address of the PoolAddressesProvider.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _tellerV2,\n        address _poolAddressesProvider\n    ) {\n        TELLER_V2 = ITellerV2(_tellerV2);\n        POOL_ADDRESSES_PROVIDER = _poolAddressesProvider;\n    }\n\n    modifier onlyFlashLoanPool() {\n        require(\n            msg.sender == address(POOL()),\n            \"FlashRolloverLoan: Must be called by FlashLoanPool\"\n        );\n\n        _;\n    }\n\n    /**\n     *\n     * @notice Allows the borrower to rollover their existing loan using a flash loan mechanism.\n     *         The borrower might also provide an additional amount during the rollover.\n     *\n     * @dev The function first verifies that the caller is the borrower of the loan.\n     *      It then optionally transfers the additional amount specified by the borrower.\n     *      A flash loan is then taken from the pool to facilitate the rollover and\n     *      a callback is executed for further operations.\n     *\n     * @param _loanId Identifier of the existing loan to be rolled over.\n     * @param _flashLoanAmount Amount of flash loan to be borrowed for the rollover.\n     * @param _borrowerAmount Additional amount that the borrower may want to add during rollover.\n     * @param _acceptCommitmentArgs Commitment arguments that might be necessary for internal operations.\n     * \n     */\n    function rolloverLoanWithFlash(\n        address _lenderCommitmentForwarder,\n        uint256 _loanId,\n        uint256 _flashLoanAmount,\n        uint256 _borrowerAmount, //an additional amount borrower may have to add\n        AcceptCommitmentArgs calldata _acceptCommitmentArgs\n    ) external   {\n        address borrower = TELLER_V2.getLoanBorrower(_loanId);\n        require(borrower == msg.sender, \"CommitmentRolloverLoan: not borrower\");\n\n        // Get lending token and balance before\n        address lendingToken = TELLER_V2.getLoanLendingToken(_loanId);\n\n        if (_borrowerAmount > 0) {\n            IERC20(lendingToken).transferFrom(\n                borrower,\n                address(this),\n                _borrowerAmount\n            );\n        }\n\n        // Call 'Flash' on the vault to borrow funds and call tellerV2FlashCallback\n        // This ultimately calls executeOperation\n        IPool(POOL()).flashLoanSimple(\n            address(this),\n            lendingToken,\n            _flashLoanAmount,\n            abi.encode(\n                RolloverCallbackArgs({\n                    lenderCommitmentForwarder :_lenderCommitmentForwarder,\n                    loanId: _loanId,\n                    borrower: borrower,\n                    borrowerAmount: _borrowerAmount,\n                    acceptCommitmentArgs: abi.encode(_acceptCommitmentArgs)\n                })\n            ),\n            0 //referral code\n        );\n    }\n\n    /**\n     *\n     * @notice Callback function that is triggered by Aave during the flash loan process.\n     *         This function handles the logic to use the borrowed funds to rollover the loan,\n     *         make necessary repayments, and manage the loan commitments.\n     *\n     * @dev The function ensures the initiator is this contract, decodes the data provided by\n     *      the flash loan call, repays the original loan in full, accepts new loan commitments,\n     *      approves the repayment for the flash loan and then handles any remaining funds.\n     *      This function should only be called by the FlashLoanPool as ensured by the `onlyFlashLoanPool` modifier.\n     *\n     * @param _flashToken The token in which the flash loan is borrowed.\n     * @param _flashAmount The amount of tokens borrowed via the flash loan.\n     * @param _flashFees The fees associated with the flash loan to be repaid to Aave.\n     * @param _initiator The address initiating the flash loan (must be this contract).\n     * @param _data Encoded data containing necessary information for loan rollover.\n     *\n     * @return Returns true if the operation was successful.\n     */\n    function executeOperation(\n        address _flashToken,\n        uint256 _flashAmount,\n        uint256 _flashFees,\n        address _initiator,\n        bytes calldata _data\n    ) external virtual onlyFlashLoanPool returns (bool) {\n        require(\n            _initiator == address(this),\n            \"This contract must be the initiator\"\n        );\n\n        RolloverCallbackArgs memory _rolloverArgs = abi.decode(\n            _data,\n            (RolloverCallbackArgs)\n        );\n\n        uint256 repaymentAmount = _repayLoanFull(\n            _rolloverArgs.loanId,\n            _flashToken,\n            _flashAmount\n        );\n\n        AcceptCommitmentArgs memory acceptCommitmentArgs = abi.decode(\n            _rolloverArgs.acceptCommitmentArgs,\n            (AcceptCommitmentArgs)\n        );\n\n        // Accept commitment and receive funds to this contract\n\n        (uint256 newLoanId, uint256 acceptCommitmentAmount) = _acceptCommitment(\n            _rolloverArgs.lenderCommitmentForwarder,\n            _rolloverArgs.borrower,\n            _flashToken,\n            acceptCommitmentArgs\n        );\n\n        //approve the repayment for the flash loan\n        IERC20Upgradeable(_flashToken).approve(\n            address(POOL()),\n            _flashAmount + _flashFees\n        );\n\n        uint256 fundsRemaining = acceptCommitmentAmount +\n            _rolloverArgs.borrowerAmount -\n            repaymentAmount -\n            _flashFees;\n\n        if (fundsRemaining > 0) {\n            IERC20Upgradeable(_flashToken).transfer(\n                _rolloverArgs.borrower,\n                fundsRemaining\n            );\n        }\n\n        emit RolloverLoanComplete(\n            _rolloverArgs.borrower,\n            _rolloverArgs.loanId,\n            newLoanId,\n            fundsRemaining\n        );\n\n        return true;\n    }\n\n    /**\n     *\n     *\n     * @notice Internal function that repays a loan in full on behalf of this contract.\n     *\n     * @dev The function first calculates the funds held by the contract before repayment, then approves\n     *      the repayment amount to the TellerV2 contract and finally repays the loan in full.\n     *\n     * @param _bidId Identifier of the loan to be repaid.\n     * @param _principalToken The token in which the loan was originated.\n     * @param _repayAmount The amount to be repaid.\n     *\n     * @return repayAmount_ The actual amount that was used for repayment.\n     */\n    function _repayLoanFull(\n        uint256 _bidId,\n        address _principalToken,\n        uint256 _repayAmount\n    ) internal returns (uint256 repayAmount_) {\n        uint256 fundsBeforeRepayment = IERC20Upgradeable(_principalToken)\n            .balanceOf(address(this));\n\n        IERC20Upgradeable(_principalToken).approve(\n            address(TELLER_V2),\n            _repayAmount\n        );\n        TELLER_V2.repayLoanFull(_bidId);\n\n        uint256 fundsAfterRepayment = IERC20Upgradeable(_principalToken)\n            .balanceOf(address(this));\n\n        repayAmount_ = fundsBeforeRepayment - fundsAfterRepayment;\n    }\n\n    /**\n     *\n     *\n     * @notice Accepts a loan commitment using either a Merkle proof or standard method.\n     *\n     * @dev The function first checks if a Merkle proof is provided, based on which it calls the relevant\n     *      `acceptCommitment` function in the LenderCommitmentForwarder contract.\n     *\n     * @param borrower The address of the borrower for whom the commitment is being accepted.\n     * @param principalToken The token in which the loan is being accepted.\n     * @param _commitmentArgs The arguments necessary for accepting the commitment.\n     *\n     * @return bidId_ Identifier of the accepted loan.\n     * @return acceptCommitmentAmount_ The amount received from accepting the commitment.\n     */\n    function _acceptCommitment(\n        address lenderCommitmentForwarder,\n        address borrower,\n        address principalToken,\n        AcceptCommitmentArgs memory _commitmentArgs\n    )\n        internal\n        virtual\n        returns (uint256 bidId_, uint256 acceptCommitmentAmount_)\n    {\n        uint256 fundsBeforeAcceptCommitment = IERC20Upgradeable(principalToken)\n            .balanceOf(address(this));\n\n\n\n        if (_commitmentArgs.smartCommitmentAddress != address(0)) {\n\n             bytes memory responseData = address(lenderCommitmentForwarder)\n                    .functionCall(\n                        abi.encodePacked(\n                            abi.encodeWithSelector(\n                                ISmartCommitmentForwarder\n                                    .acceptSmartCommitmentWithRecipient\n                                    .selector,\n                                _commitmentArgs.smartCommitmentAddress,\n                                _commitmentArgs.principalAmount,\n                                _commitmentArgs.collateralAmount,\n                                _commitmentArgs.collateralTokenId,\n                                _commitmentArgs.collateralTokenAddress,\n                                address(this),\n                                _commitmentArgs.interestRate,\n                                _commitmentArgs.loanDuration\n                            ),\n                            borrower //cant be msg.sender because of the flash flow\n                        )\n                    );\n\n                (bidId_) = abi.decode(responseData, (uint256));\n\n\n        }else { \n\n            bool usingMerkleProof = _commitmentArgs.merkleProof.length > 0;\n\n            if (usingMerkleProof) {\n                bytes memory responseData = address(lenderCommitmentForwarder)\n                    .functionCall(\n                        abi.encodePacked(\n                            abi.encodeWithSelector(\n                                ILenderCommitmentForwarder\n                                    .acceptCommitmentWithRecipientAndProof\n                                    .selector,\n                                _commitmentArgs.commitmentId,\n                                _commitmentArgs.principalAmount,\n                                _commitmentArgs.collateralAmount,\n                                _commitmentArgs.collateralTokenId,\n                                _commitmentArgs.collateralTokenAddress,\n                                address(this),\n                                _commitmentArgs.interestRate,\n                                _commitmentArgs.loanDuration,\n                                _commitmentArgs.merkleProof\n                            ),\n                            borrower //cant be msg.sender because of the flash flow\n                        )\n                    );\n\n                (bidId_) = abi.decode(responseData, (uint256));\n            } else {\n                bytes memory responseData = address(lenderCommitmentForwarder)\n                    .functionCall(\n                        abi.encodePacked(\n                            abi.encodeWithSelector(\n                                ILenderCommitmentForwarder\n                                    .acceptCommitmentWithRecipient\n                                    .selector,\n                                _commitmentArgs.commitmentId,\n                                _commitmentArgs.principalAmount,\n                                _commitmentArgs.collateralAmount,\n                                _commitmentArgs.collateralTokenId,\n                                _commitmentArgs.collateralTokenAddress,\n                                address(this),\n                                _commitmentArgs.interestRate,\n                                _commitmentArgs.loanDuration\n                            ),\n                            borrower //cant be msg.sender because of the flash flow\n                        )\n                    );\n\n                (bidId_) = abi.decode(responseData, (uint256));\n            }\n\n        }\n\n        uint256 fundsAfterAcceptCommitment = IERC20Upgradeable(principalToken)\n            .balanceOf(address(this));\n        acceptCommitmentAmount_ =\n            fundsAfterAcceptCommitment -\n            fundsBeforeAcceptCommitment;\n    }\n\n    function ADDRESSES_PROVIDER() public view returns (IPoolAddressesProvider) {\n        return IPoolAddressesProvider(POOL_ADDRESSES_PROVIDER);\n    }\n\n    function POOL() public view returns (IPool) {\n        return IPool(ADDRESSES_PROVIDER().getPool());\n    }\n\n    /**\n     * @notice Calculates the amount for loan rollover, determining if the borrower owes or receives funds.\n     * @param _loanId The ID of the loan to calculate the rollover amount for.\n     * @param _commitmentArgs Arguments for the commitment.\n     * @param _timestamp The timestamp for when the calculation is executed.\n    \n     */\n    function calculateRolloverAmount(\n        address _lenderCommitmentForwarder,\n        uint256 _loanId,\n        AcceptCommitmentArgs calldata _commitmentArgs,\n        uint16 _flashloanPremiumPct,\n        uint256 _timestamp\n    ) external view returns (uint256 _flashAmount, int256 _borrowerAmount) {\n        Payment memory repayAmountOwed = TELLER_V2.calculateAmountOwed(\n            _loanId,\n            _timestamp\n        );\n\n        uint256 _marketId = _getMarketIdForCommitment(_lenderCommitmentForwarder,\n            _commitmentArgs.commitmentId\n        );\n        uint16 marketFeePct = _getMarketFeePct(_marketId);\n        uint16 protocolFeePct = _getProtocolFeePct();\n\n        uint256 commitmentPrincipalRequested = _commitmentArgs.principalAmount;\n        uint256 amountToMarketplace = commitmentPrincipalRequested.percent(\n            marketFeePct\n        );\n        uint256 amountToProtocol = commitmentPrincipalRequested.percent(\n            protocolFeePct\n        );\n\n        uint256 commitmentPrincipalReceived = commitmentPrincipalRequested -\n            amountToMarketplace -\n            amountToProtocol;\n\n        // by default, we will flash exactly what we need to do relayLoanFull\n        uint256 repayFullAmount = repayAmountOwed.principal +\n            repayAmountOwed.interest;\n\n        _flashAmount = repayFullAmount;\n        uint256 _flashLoanFee = _flashAmount.percent(_flashloanPremiumPct);\n\n        _borrowerAmount =\n            int256(commitmentPrincipalReceived) -\n            int256(repayFullAmount) -\n            int256(_flashLoanFee);\n    }\n\n    /**\n     * @notice Retrieves the market ID associated with a given commitment.\n     * @param _commitmentId The ID of the commitment for which to fetch the market ID.\n     * @return The ID of the market associated with the provided commitment.\n     */\n    function _getMarketIdForCommitment(address _lenderCommitmentForwarder, uint256 _commitmentId)\n        internal\n        view\n        returns (uint256)\n    {\n        return ILenderCommitmentForwarder(_lenderCommitmentForwarder).getCommitmentMarketId(_commitmentId);\n    }\n\n    /**\n     * @notice Fetches the marketplace fee percentage for a given market ID.\n     * @param _marketId The ID of the market for which to fetch the fee percentage.\n     * @return The marketplace fee percentage for the provided market ID.\n     */\n    function _getMarketFeePct(uint256 _marketId)\n        internal\n        view\n        returns (uint16)\n    {\n        address _marketRegistryAddress = ITellerV2Storage(address(TELLER_V2))\n            .marketRegistry();\n\n        return\n            IMarketRegistry(_marketRegistryAddress).getMarketplaceFee(\n                _marketId\n            );\n    }\n\n    /**\n     * @notice Fetches the protocol fee percentage from the Teller V2 protocol.\n     * @return The protocol fee percentage as defined in the Teller V2 protocol.\n     */\n    function _getProtocolFeePct() internal view returns (uint16) {\n        return IProtocolFee(address(TELLER_V2)).protocolFee();\n    }\n}"
    },
    {
      "filename": "teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"./ProtocolFee.sol\";\nimport \"./TellerV2Storage.sol\";\nimport \"./TellerV2Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\n// Interfaces\nimport \"./interfaces/IMarketRegistry.sol\";\nimport \"./interfaces/IReputationManager.sol\";\nimport \"./interfaces/ITellerV2.sol\";\nimport { Collateral } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\nimport \"./interfaces/IEscrowVault.sol\";\n\nimport { ILoanRepaymentCallbacks } from \"./interfaces/ILoanRepaymentCallbacks.sol\";\nimport \"./interfaces/ILoanRepaymentListener.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./libraries/NumbersLib.sol\";\n\nimport { V2Calculations, PaymentCycleType } from \"./libraries/V2Calculations.sol\";\n\n/* Errors */\n/**\n * @notice This error is reverted when the action isn't allowed\n * @param bidId The id of the bid.\n * @param action The action string (i.e: 'repayLoan', 'cancelBid', 'etc)\n * @param message The message string to return to the user explaining why the tx was reverted\n */\nerror ActionNotAllowed(uint256 bidId, string action, string message);\n\n/**\n * @notice This error is reverted when repayment amount is less than the required minimum\n * @param bidId The id of the bid the borrower is attempting to repay.\n * @param payment The payment made by the borrower\n * @param minimumOwed The minimum owed value\n */\nerror PaymentNotMinimum(uint256 bidId, uint256 payment, uint256 minimumOwed);\n\ncontract TellerV2 is\n    ITellerV2,\n    ILoanRepaymentCallbacks,\n    OwnableUpgradeable,\n    ProtocolFee,\n    PausableUpgradeable,\n    TellerV2Storage,\n    TellerV2Context\n{\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using NumbersLib for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    //the first 20 bytes of keccak256(\"lender manager\")\n    address constant USING_LENDER_MANAGER =\n        0x84D409EeD89F6558fE3646397146232665788bF8;\n\n    /** Events */\n\n    /**\n     * @notice This event is emitted when a new bid is submitted.\n     * @param bidId The id of the bid submitted.\n     * @param borrower The address of the bid borrower.\n     * @param metadataURI URI for additional bid information as part of loan bid.\n     */\n    event SubmittedBid(\n        uint256 indexed bidId,\n        address indexed borrower,\n        address receiver,\n        bytes32 indexed metadataURI\n    );\n\n    /**\n     * @notice This event is emitted when a bid has been accepted by a lender.\n     * @param bidId The id of the bid accepted.\n     * @param lender The address of the accepted bid lender.\n     */\n    event AcceptedBid(uint256 indexed bidId, address indexed lender);\n\n    /**\n     * @notice This event is emitted when a previously submitted bid has been cancelled.\n     * @param bidId The id of the cancelled bid.\n     */\n    event CancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when market owner has cancelled a pending bid in their market.\n     * @param bidId The id of the bid funded.\n     *\n     * Note: The `CancelledBid` event will also be emitted.\n     */\n    event MarketOwnerCancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a payment is made towards an active loan.\n     * @param bidId The id of the bid/loan to which the payment was made.\n     */\n    event LoanRepayment(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanRepaid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been closed by a lender to claim collateral.\n     * @param bidId The id of the bid accepted.\n     */\n    event LoanClosed(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanLiquidated(uint256 indexed bidId, address indexed liquidator);\n\n    /**\n     * @notice This event is emitted when a fee has been paid related to a bid.\n     * @param bidId The id of the bid.\n     * @param feeType The name of the fee being paid.\n     * @param amount The amount of the fee being paid.\n     */\n    event FeePaid(\n        uint256 indexed bidId,\n        string indexed feeType,\n        uint256 indexed amount\n    );\n\n    /** Modifiers */\n\n    /**\n     * @notice This modifier is used to check if the state of a bid is pending, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier pendingBid(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.PENDING) {\n            revert ActionNotAllowed(_bidId, _action, \"Bid must be pending\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to check if the state of a loan has been accepted, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier acceptedLoan(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.ACCEPTED) {\n            revert ActionNotAllowed(_bidId, _action, \"Loan must be accepted\");\n        }\n\n        _;\n    }\n\n    /** Constant Variables **/\n\n    uint8 public constant CURRENT_CODE_VERSION = 10;\n\n    uint32 public constant LIQUIDATION_DELAY = 86400; //ONE DAY IN SECONDS\n\n    /** Constructor **/\n\n    constructor(address trustedForwarder) TellerV2Context(trustedForwarder) {}\n\n    /** External Functions **/\n\n    /**\n     * @notice Initializes the proxy.\n     * @param _protocolFee The fee collected by the protocol for loan processing.\n     * @param _marketRegistry The address of the market registry contract for the protocol.\n     * @param _reputationManager The address of the reputation manager contract.\n     * @param _lenderCommitmentForwarder The address of the lender commitment forwarder contract.\n     * @param _collateralManager The address of the collateral manager contracts.\n     * @param _lenderManager The address of the lender manager contract for loans on the protocol.\n     */\n    function initialize(\n        uint16 _protocolFee,\n        address _marketRegistry,\n        address _reputationManager,\n        address _lenderCommitmentForwarder,\n        address _collateralManager,\n        address _lenderManager,\n        address _escrowVault\n    ) external initializer {\n        __ProtocolFee_init(_protocolFee);\n\n        __Pausable_init();\n\n        require(\n            _lenderCommitmentForwarder.isContract(),\n            \"LenderCommitmentForwarder must be a contract\"\n        );\n        lenderCommitmentForwarder = _lenderCommitmentForwarder;\n\n        require(\n            _marketRegistry.isContract(),\n            \"MarketRegistry must be a contract\"\n        );\n        marketRegistry = IMarketRegistry(_marketRegistry);\n\n        require(\n            _reputationManager.isContract(),\n            \"ReputationManager must be a contract\"\n        );\n        reputationManager = IReputationManager(_reputationManager);\n\n        require(\n            _collateralManager.isContract(),\n            \"CollateralManager must be a contract\"\n        );\n        collateralManager = ICollateralManager(_collateralManager);\n\n        _setLenderManager(_lenderManager);\n        _setEscrowVault(_escrowVault);\n    }\n\n    /* function setEscrowVault(address _escrowVault) external reinitializer(9) {\n        _setEscrowVault(_escrowVault);\n    }\n    */\n\n    function _setLenderManager(address _lenderManager)\n        internal\n        onlyInitializing\n    {\n        require(\n            _lenderManager.isContract(),\n            \"LenderManager must be a contract\"\n        );\n        lenderManager = ILenderManager(_lenderManager);\n    }\n\n    function _setEscrowVault(address _escrowVault) internal onlyInitializing {\n        require(_escrowVault.isContract(), \"EscrowVault must be a contract\");\n        escrowVault = IEscrowVault(_escrowVault);\n    }\n\n    /**\n     * @notice Gets the metadataURI for a bidId.\n     * @param _bidId The id of the bid to return the metadataURI for\n     * @return metadataURI_ The metadataURI for the bid, as a string.\n     */\n    function getMetadataURI(uint256 _bidId)\n        public\n        view\n        returns (string memory metadataURI_)\n    {\n        // Check uri mapping first\n        metadataURI_ = uris[_bidId];\n        // If the URI is not present in the mapping\n        if (\n            keccak256(abi.encodePacked(metadataURI_)) ==\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 // hardcoded constant of keccak256('')\n        ) {\n            // Return deprecated bytes32 uri as a string\n            uint256 convertedURI = uint256(bids[_bidId]._metadataURI);\n            metadataURI_ = StringsUpgradeable.toHexString(convertedURI, 32);\n        }\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan without Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan with Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     * @param _collateralInfo Additional information about the collateral asset.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver,\n        Collateral[] calldata _collateralInfo\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n\n        bool validation = collateralManager.commitCollateral(\n            bidId_,\n            _collateralInfo\n        );\n\n        require(\n            validation == true,\n            \"Collateral balance could not be validated\"\n        );\n    }\n\n    function _submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) internal virtual returns (uint256 bidId_) {\n        address sender = _msgSenderForMarket(_marketplaceId);\n\n        (bool isVerified, ) = marketRegistry.isVerifiedBorrower(\n            _marketplaceId,\n            sender\n        );\n\n        require(isVerified, \"Not verified borrower\");\n\n        require(\n            marketRegistry.isMarketOpen(_marketplaceId),\n            \"Market is not open\"\n        );\n\n        // Set response bid ID.\n        bidId_ = bidId;\n\n        // Create and store our bid into the mapping\n        Bid storage bid = bids[bidId];\n        bid.borrower = sender;\n        bid.receiver = _receiver != address(0) ? _receiver : bid.borrower;\n        bid.marketplaceId = _marketplaceId;\n        bid.loanDetails.lendingToken = IERC20(_lendingToken);\n        bid.loanDetails.principal = _principal;\n        bid.loanDetails.loanDuration = _duration;\n        bid.loanDetails.timestamp = uint32(block.timestamp);\n\n        // Set payment cycle type based on market setting (custom or monthly)\n        (bid.terms.paymentCycle, bidPaymentCycleType[bidId]) = marketRegistry\n            .getPaymentCycle(_marketplaceId);\n\n        bid.terms.APR = _APR;\n\n        bidDefaultDuration[bidId] = marketRegistry.getPaymentDefaultDuration(\n            _marketplaceId\n        );\n\n        bidExpirationTime[bidId] = marketRegistry.getBidExpirationTime(\n            _marketplaceId\n        );\n\n        bid.paymentType = marketRegistry.getPaymentType(_marketplaceId);\n\n        bid.terms.paymentCycleAmount = V2Calculations\n            .calculatePaymentCycleAmount(\n                bid.paymentType,\n                bidPaymentCycleType[bidId],\n                _principal,\n                _duration,\n                bid.terms.paymentCycle,\n                _APR\n            );\n\n        uris[bidId] = _metadataURI;\n        bid.state = BidState.PENDING;\n\n        emit SubmittedBid(\n            bidId,\n            bid.borrower,\n            bid.receiver,\n            keccak256(abi.encodePacked(_metadataURI))\n        );\n\n        // Store bid inside borrower bids mapping\n        borrowerBids[bid.borrower].push(bidId);\n\n        // Increment bid id counter\n        bidId++;\n    }\n\n    /**\n     * @notice Function for a borrower to cancel their pending bid."
    }
  ]
}