{
  "Title": "M-1: Validator cannot set new address if more than 300 unstakes in it's array",
  "Content": "# Issue M-1: Validator cannot set new address if more than 300 unstakes in it's array \n\nSource: https://github.com/sherlock-audit/2023-11-covalent-judging/issues/25 \n\n## Found by \nPUSH0, SadBase, alexbabits, bitsurfer, nobody2018, thank\\_you, yujin718\n## Summary\nIf a validator has more than 300 accumulated unstakes associated with it, then it cannot set a new address for itself. The only way to decrease the length of the `Unstaking` array is through the `setValidatorAddress()` function, but will revert if it's array is longer than 300 entries. A malicious delegator could stake 1,000 tokens, and then unstake 301 times with small amounts to fill up the unstaking array, and there is no way to remove those entries from the array. Every time `_unstake()` is called, it pushes another entry to it's array for that validator.\n\nA malicious validator could also set it's new address to another validator, forcing a merge of information to the victim validator. The malicious validator can do this even when it's disabled with 0 tokens. So it could get to 300 length, and then send all those unstakes into another victim validators unstaking array. This is the same kind of attack vector, but should be noted that validators can assign their address to other validators, effectively creating a forceful merging of them.\n\nThe README.md suggests there is a mechanism to counteract this: \"In case if there are more than 300 unstakings, there is an option to transfer the address without unstakings.\" But there appears to be no function in scope that can transfer the address of the validator without unstakings, or any other function that can reduce the unstakings array at all.\n\n## Vulnerability Detail\nSee Summary\n\n## Impact\nValidator can be permanently stuck with same address if there are too many entries in it's `Unstaking` array.\n\n## Code Snippet\nValidator & Unstaking Structs: https://github.com/sherlock-audit/2023-11-covalent/blob/main/cqt-staking/contracts/OperationalStaking.sol#L35-#L51\n`setValidatorAddress()` length check: https://github.com/sherlock-audit/2023-11-covalent/blob/main/cqt-staking/contracts/OperationalStaking.sol#L702\ndeletion of array inside `setValidatorAddress()`: https://github.com/sherlock-audit/2023-11-covalent/blob/main/cqt-staking/contracts/OperationalStaking.sol#L707\n\n## Tool used\nManual Review\n\n## Recommendation\nConsider having a way to set a new address without unstakings, or allow for smaller batches to be transferred during an address change if there are too many.\nConsider disallowing validators from changing their address to other validators.\n\n\n\n\n## Discussion\n\n**sudeepdino008**\n\nThis is interesting. I do have few questions though\n\n> \nA malicious validator could also set it's new address to another validator, forcing a merge of information to the victim validator. The malicious validator can do this even when it's disabled with 0 tokens. So it could get to 300 length, and then send all those unstakes into another victim validators unstaking array. This is the same kind of attack vector, but should be noted that validators can assign their address to other validators, effectively creating a forceful merging of them.\n\n\nHow is setValidatorAddress operates within a `Validator` storage struct, which is retrieved from a query `_validators[validatorId]`. So each validatorId maintains its own unstakings etc. Even if a malicious validator sets its validator address to another validator, the new unstakings are maintained within the current validatorId's Validator instance (which is different from the victim validatorId and therefore victim's Validator instance and its unstakings).\n\nFurthermore setting the newAddress to an existing validator address would typically mean that the attacker doesn't own private key of the victim validator. This would cause loss of funds for the attacker, as the validator needs the private key corresponding to its address to retrieve the funds via redeeum or transferUnstakedOut etc.\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid:  there is no function for that unstaking if its more than 300 in the array; medium(1)\n\n\n\n**noslav**\n\npartially fixed by \n[ignore 0 amount unstakings and require unstaking length < 300 - sa46,](https://github.com/covalenthq/cqt-staking/pull/125/commits/63dae4a54c022b8d16e1df6467d98f2b998a1365)\n\n**nevillehuang**\n\n@sudeepdino008 @noslav \n\n- What is the purpose of setValidatorAddress()? Is it simply to a feature to allow current validator to operate with another address (given they would have to call themselves, so I believe this does not cater to a private key loss scenario)\n- Can the validator still perform regular functionalities such as redeeming rewards, commissions submit proofs with no issue? \n\nIf above scenarios are true, I believe this issue is low severity\n\n**noslav**\n\n> @sudeepdino008 @noslav\n> \n> * What is the purpose of setValidatorAddress()? Is it simply to a feature to allow current validator to operate with another address (given they would have to call themselves, so I believe this does not cater to a private key loss scenario)\n> * Can the validator still perform regular functionalities such as redeeming rewards, commissions submit proofs with no issue?\n> \n> If above scenarios are true, I believe this issue is low severity\n\n@nevillehuang This is indeed true, the function does not cater to the private key loss scenario but rather a private key leak scenario where an unknown entity has taken hold of the private key, the action required is for the original owner entity to quickly switch the validator staking address to another address they control to thereby save the stake also from being stolen. This function now has the check that it's not another existing address in the system that belongs to a delegator or a validator. \n\nIn the case of a complete loss of private key, the validator is responsible for any such full loss and has to deal with the \"not your keys not your crypto\" essentially having no recourse to `_unstake` `_stake` or `_redeemRewards` with the same address\n\n**sherlock-admin**\n\n> Escalate\n> \n> this issue should be Invalid.\n> \n> This is already a known issue by the team, and was described in the readMe\n> > When changing its address a validator cannot transfer unstakings if there are more than 300 of them. This is to ensure the contract does not revert from too much gas used. In case if there are more than 300 unstakings, there is an option to transfer the address without unstakings.\n> \n> https://github.com/sherlock-audit/2023-11-covalent/blob/main/cqt-staking/README.md\n> \n> scroll down to the `Staking Explained` section to find it.\n\nYou've deleted an escalation for this issue.\n\n**midori-fuse**\n\nI disagree with the escalation.\n\nThe first part (cannot transfer unstakings) is known, but the \"In case if there are more than 300 unstakings...\" part is not. Report #67 proves that it is not possible even for an admin to transfer the validator address without unstakings, so the quoted README part actually confirms that a core contract functionality is broken.\n\n**ArnieGod**\n\n@midori-fuse i agree with you removing escalation.\n\n**ArnieGod**\n\n@midori-fuse escalation removed thanks for pointing out my misjudgment. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/127",
  "Code": [
    {
      "filename": "cqt-staking/contracts/OperationalStaking.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\ncontract OperationalStaking is OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant DIVIDER = 10 ** 18; // 18 decimals used for scaling rates\n    uint128 public constant REWARD_REDEEM_THRESHOLD = 10 ** 8; // minimum number of tokens that can be redeemed\n    uint128 public constant DEFAULT_VALIDATOR_ENABLE_MIN_STAKE = 35000 * 10 ** 18; // minimum number of self-staked tokens for a validator to become / stay enabled\n    uint128 public constant DEFAULT_DELEGATOR_MIN_STAKE = 10 ** 18; // stake/unstake operations are invalid if they put you below this threshold (except unstaking to 0)\n\n    IERC20Upgradeable public CQT;\n    uint128 public rewardPool; // how many tokens are allocated for rewards\n    uint128 public validatorCoolDown; // how many blocks until validator unstaking is unlocked\n    uint128 public delegatorCoolDown; // how many blocks until delegator unstaking is unlocked\n    uint128 public maxCapMultiplier; // *see readme\n    uint128 public validatorMaxStake; // how many tokens validators can stake at most\n    address public stakingManager;\n    uint128 public validatorsN; // number of validators, used to get validator ids\n    mapping(uint128 => Validator) internal _validators; // id -> validator instance\n\n    uint128 public validatorEnableMinStake; // minimum number of self-staked tokens for a validator to become / stay enabled\n    uint128 public delegatorMinStake; // stake/unstake operations are invalid if they put you below this threshold (except unstaking to 0)\n\n    bool private _unpaused;\n\n    struct Staking {\n        uint128 shares; // # of validator shares that the delegator owns\n        uint128 staked; // # of CQT that a delegator delegated originally through stake() transaction\n    }\n\n    struct Unstaking {\n        uint128 coolDownEnd; // epoch when unstaking can be redeemed\n        uint128 amount; // # of unstaked CQT\n    }\n\n    struct Validator {\n        uint128 commissionAvailableToRedeem;\n        uint128 exchangeRate; // validator exchange rate\n        address _address; // wallet address of the operator which is mapped to the validator instance\n        uint128 delegated; // track amount of tokens delegated\n        uint128 totalShares; // total number of validator shares\n        uint128 commissionRate;\n        uint256 disabledAtBlock;\n        mapping(address => Staking) stakings;\n        mapping(address => Unstaking[]) unstakings;\n        bool frozen;\n    }\n\n    event InitializedSemantics(\n        address cqt,\n        uint128 validatorCoolDown,\n        uint128 delegatorCoolDown,\n        uint128 maxCapMultiplier,\n        uint128 validatorMaxStake,\n        uint128 validatorEnableMinStake,\n        uint128 delegatorMinStake\n    );\n\n    event RewardTokensDeposited(uint128 amount);\n\n    event ValidatorAdded(uint128 indexed id, uint128 commissionRate, address indexed validator);\n\n    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);\n\n    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakeId);\n\n    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n\n    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 indexed unstakeId, uint128 amount);\n\n    event AllocatedTokensTaken(uint128 amount);\n\n    event RewardFailedDueLowPool(uint128 indexed validatorId, uint128 amount);\n\n    event RewardFailedDueZeroStake(uint128 indexed validatorId, uint128 amount);\n\n    event RewardFailedDueValidatorDisabled(uint128 indexed validatorId, uint128 amount);\n\n    event RewardFailedDueValidatorFrozen(uint128 indexed validatorId, uint128 amount);\n\n    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n\n    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n\n    event StakingManagerChanged(address indexed operationalManager);\n\n    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 amount);\n\n    event ValidatorMaxCapChanged(uint128 amount);\n\n    event ValidatorEnableMinStakeChanged(uint128 amount);\n\n    event DelegatorMinStakeChanged(uint128 amount);\n\n    event ValidatorUnstakeCooldownChanged(uint128 amount);\n\n    event DelegatorUnstakeCooldownChanged(uint128 amount);\n\n    event ValidatorDisabled(uint128 indexed validatorId, uint256 blockNumber);\n\n    event Redelegated(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n\n    event MaxCapMultiplierChanged(uint128 newMaxCapMultiplier);\n\n    event ValidatorEnabled(uint128 indexed validatorId);\n\n    event ValidatorAddressChanged(uint128 indexed validatorId, address indexed newAddress);\n\n    event Paused(address account);\n\n    event Unpaused(address account);\n\n    event ValidatorFrozen(uint128 indexed validatorId, string reason);\n\n    event ValidatorUnfrozen(uint128 indexed validatorId);\n\n    event RewardsDisbursed(uint128 indexed rewardId);\n\n    modifier onlyStakingManager() {\n        require(stakingManager == msg.sender, \"Caller is not stakingManager\");\n        _;\n    }\n\n    modifier onlyStakingManagerOrOwner() {\n        require(msg.sender == stakingManager || msg.sender == owner(), \"Caller is not stakingManager or owner\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(_unpaused, \"paused\");\n        _;\n    }\n\n    function initialize(address cqt, uint128 dCoolDown, uint128 vCoolDown, uint128 maxCapM, uint128 vMaxStake) external initializer {\n        __Ownable_init();\n        validatorCoolDown = vCoolDown; // 180*6857 = ~ 6 months\n        delegatorCoolDown = dCoolDown; //  28*6857 = ~ 28 days\n        maxCapMultiplier = maxCapM;\n        validatorMaxStake = vMaxStake;\n\n        validatorEnableMinStake = DEFAULT_VALIDATOR_ENABLE_MIN_STAKE;\n        delegatorMinStake = DEFAULT_DELEGATOR_MIN_STAKE;\n\n        _unpaused = true;\n\n        CQT = IERC20Upgradeable(cqt);\n        emit InitializedSemantics(cqt, vCoolDown, dCoolDown, maxCapM, vMaxStake, validatorEnableMinStake, delegatorMinStake);\n    }\n\n    function setStakingManagerAddress(address newAddress) external onlyOwner {\n        require(newAddress != address(0), \"Invalid address\");\n        stakingManager = newAddress;\n        emit StakingManagerChanged(newAddress);\n    }\n\n    /*\n     * Transfer CQT from the owner to the contract for reward allocation\n     */\n    function depositRewardTokens(uint128 amount) external onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        unchecked {\n            rewardPool += amount;\n        }\n        _transferToContract(msg.sender, amount);\n        emit RewardTokensDeposited(amount);\n    }\n\n    /*\n     * Transfer reward CQT from the contract to the owner\n     */\n    function takeOutRewardTokens(uint128 amount) external onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        require(amount <= rewardPool, \"Reward pool is too small\");\n        unchecked {\n            rewardPool -= amount;\n        }\n        emit AllocatedTokensTaken(amount);\n        _transferFromContract(msg.sender, amount);\n    }\n\n    /*\n     * Updates validator max cap multiplier that determines how many tokens can be delegated\n     */\n    function setMaxCapMultiplier(uint128 newMaxCapMultiplier) external onlyOwner {\n        require(newMaxCapMultiplier > 0, \"Must be greater than 0\");\n        maxCapMultiplier = newMaxCapMultiplier;\n        emit MaxCapMultiplierChanged(newMaxCapMultiplier);\n    }\n\n    /*\n     * Updates maximum number of tokens that a validator can stake\n     */\n    function setValidatorMaxStake(uint128 maxStake) external onlyOwner {\n        require(maxStake > 0, \"Provided max stake is 0\");\n        validatorMaxStake = maxStake;\n        emit ValidatorMaxCapChanged(maxStake);\n    }\n\n    /*\n     * Updates minimum number of tokens that a validator must self-stake before enabling\n     */\n    function setValidatorEnableMinStake(uint128 minStake) public onlyOwner {\n        require(minStake <= validatorMaxStake, \"minStake cannot be greater than validatorMaxStake\");\n        validatorEnableMinStake = minStake;\n        emit ValidatorEnableMinStakeChanged(minStake);\n    }\n\n    /*\n     * Updates minimum valid position threshold for per-delegator stake\n     */\n    function setDelegatorMinStake(uint128 minStake) public onlyOwner {\n        require(minStake <= validatorMaxStake, \"minStake cannot be greater than validatorMaxStake\");\n        delegatorMinStake = minStake;\n        emit DelegatorMinStakeChanged(minStake);\n    }\n\n    /*\n     * Updates the validator cool down period (in blocks)\n     * Note: this doesn't effect the existing unstakes\n     */\n    function setValidatorCoolDown(uint128 coolDown) external onlyOwner {\n        validatorCoolDown = coolDown;\n        emit ValidatorUnstakeCooldownChanged(coolDown);\n    }\n\n    /*\n     * Updates the delegator cool down period (in blocks)\n     * Note: this doesn't effect the existing unstakes\n     */\n    function setDelegatorCoolDown(uint128 coolDown) external onlyOwner {\n        delegatorCoolDown = coolDown;\n        emit DelegatorUnstakeCooldownChanged(coolDown);\n    }\n\n    /*\n     * Adds new validator instance\n     */\n    function addValidator(address validator, uint128 commissionRate) external onlyStakingManager whenNotPaused returns (uint256 id) {\n        require(commissionRate < DIVIDER, \"Rate must be less than 100%\");\n        require(validator != address(0), \"Validator address is 0\");\n        Validator storage v = _validators[validatorsN]; // use current number of validators for the id of a new validator instance\n        v._address = validator;\n        v.exchangeRate = uint128(DIVIDER); // make it 1:1 initially\n        v.commissionRate = commissionRate;\n        v.disabledAtBlock = 1; // set it to 1 to indicate that the validator is disabled\n\n        emit ValidatorAdded(validatorsN, commissionRate, validator);\n        unchecked {\n            validatorsN += 1;\n        }\n\n        return validatorsN - 1;\n    }\n\n    /*\n     * Reward emission\n     */\n    function rewardValidators(uint128 rewardId, uint128[] calldata ids, uint128[] calldata amounts) external onlyStakingManager whenNotPaused {\n        require(ids.length == amounts.length, \"Given ids and amounts arrays must be of the same length\");\n        uint128 newRewardPool = rewardPool;\n        uint128 amount;\n        uint128 validatorId;\n        uint128 commissionPaid;\n\n        for (uint256 j = 0; j < ids.length; j++) {\n            amount = amounts[j];\n            validatorId = ids[j];\n\n            // make sure there are enough tokens in the reward pool\n            if (newRewardPool < amount) {\n                emit RewardFailedDueLowPool(validatorId, amount);\n                continue;\n            }\n\n            Validator storage v = _validators[validatorId];\n\n            if (v.frozen) {\n                emit RewardFailedDueValidatorFrozen(validatorId, amount);\n                continue;\n            }\n\n            if (v.disabledAtBlock != 0) {\n                // validator became disabled (due to e.g. unstaking past base stake)\n                // between proof submission and finalization\n                emit RewardFailedDueValidatorDisabled(validatorId, amount);\n                continue;\n            }\n\n            if (v.totalShares == 0) {\n                // mathematically undefined -- no exchangeRate can turn zero into nonzero\n                // (this condition is only possible in testing with minValidatorEnableStake == 0;\n                //  in prod, validators with zero stake will always be disabled and so will trigger\n                //  the above check, not this one)\n                emit RewardFailedDueZeroStake(validatorId, amount);\n                continue;\n            }\n\n            commissionPaid = uint128((uint256(amount) * uint256(v.commissionRate)) / DIVIDER);\n\n            // distribute the tokens by increasing the exchange rate\n            // div by zero impossible due to check above\n            // (and in fact, presuming minValidatorEnableStake >= DIVIDER, v.totalShares will\n            //  always be >= DIVIDER while validator is enabled)\n            v.exchangeRate += uint128((uint256(amount - commissionPaid) * uint256(DIVIDER)) / v.totalShares);\n\n            // commission is not compounded\n            // commisison is distributed under the validator instance\n            v.commissionAvailableToRedeem += commissionPaid;\n\n            newRewardPool -= amount;\n        }\n\n        rewardPool = newRewardPool; // can never access these tokens anymore, reserved for validator rewards\n        emit RewardsDisbursed(rewardId);\n    }\n\n    /*\n     * Disables validator instance starting from the given block\n     */\n    function disableValidator(uint128 validatorId) external onlyStakingManagerOrOwner {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        _validators[validatorId].disabledAtBlock = block.number;\n        emit ValidatorDisabled(validatorId, block.number);\n    }\n\n    /*\n     * Enables validator instance by setting the disabledAtBlock to 0\n     */\n    function enableValidator(uint128 validatorId) external onlyStakingManagerOrOwner {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = _validators[validatorId];\n\n        if (v.disabledAtBlock == 0) {\n            // if validator is already enabled, succeed quietly\n            return;\n        }\n\n        uint128 staked = _sharesToTokens(v.stakings[v._address].shares, v.exchangeRate);\n\n        require(staked >= validatorEnableMinStake, \"Validator is insufficiently staked\");\n\n        v.disabledAtBlock = 0;\n        emit ValidatorEnabled(validatorId);\n    }\n\n    /*\n     * Determines whether a validator is currently able to be used by operators\n     */\n    function isValidatorEnabled(uint128 validatorId) external view returns (bool) {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        return _validators[validatorId].disabledAtBlock == 0;\n    }\n\n    /*\n     * Updates validator comission rate\n     * Commission rate is a number between 0 and 10^18 (0%-100%)\n     */\n    function setValidatorCommissionRate(uint128 validatorId, uint128 amount) external onlyOwner {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(amount < DIVIDER, \"Rate must be less than 100%\");\n        _validators[validatorId].commissionRate = amount;\n        emit ValidatorCommissionRateChanged(validatorId, amount);\n    }\n\n    /*\n     * Used to transfer CQT from delegators, validators, and the owner to the contract\n     */\n    function _transferToContract(address from, uint128 amount) internal {\n        CQT.safeTransferFrom(from, address(this), amount);\n    }\n\n    /*\n     * Used to transfer CQT from contract, for reward redemption or transferring out unstaked tokens\n     */\n    function _transferFromContract(address to, uint128 amount) internal {\n        CQT.safeTransfer(to, amount);\n    }\n\n    /*\n     * Used to convert validator shares to CQT\n     */\n    function _sharesToTokens(uint128 sharesN, uint128 rate) internal pure returns (uint128) {\n        return uint128((uint256(sharesN) * uint256(rate)) / DIVIDER);\n    }\n\n    /*\n     * Used to convert CQT to validator shares\n     */\n    function _tokensToShares(uint128 amount, uint128 rate) internal pure returns (uint128) {\n        return uint128((uint256(amount) * DIVIDER) / uint256(rate));\n    }\n\n    /*\n     * Delegates tokens under the provided validator\n     */\n    function stake(uint128 validatorId, uint128 amount) external whenNotPaused {\n        _stake(validatorId, amount, true);\n    }\n\n    /*\n     * withTransfer is set to false when delegators recover unstaked or redelegated tokens.\n     * These tokens are already in the contract.\n     */\n    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(amount >= REWARD_REDEEM_THRESHOLD, \"Stake amount is too small\");\n        Validator storage v = _validators[validatorId];\n        bool isValidator = msg.sender == v._address;\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        // validators should be able to stake if they are disabled.\n        if (!isValidator) require(v.disabledAtBlock == 0, \"Validator is disabled\");\n\n        Staking storage s = v.stakings[msg.sender];\n\n        uint128 newStaked = s.staked + amount;\n\n        require(newStaked >= delegatorMinStake, \"Cannot stake to a position less than delegatorMinStake\");\n\n        uint128 sharesAdd = _tokensToShares(amount, v.exchangeRate);\n\n        if (isValidator) {\n            // compares with newStaked to ignore compounded rewards\n            require(newStaked <= validatorMaxStake, \"Validator max stake exceeded\");\n        } else {\n            // cannot stake more than validator delegation max cap\n            uint128 delegationMaxCap = v.stakings[v._address].staked * maxCapMultiplier;\n            uint128 newDelegated = v.delegated + amount;\n            require(newDelegated <= delegationMaxCap, \"Validator max delegation exceeded\");\n            v.delegated = newDelegated;\n        }\n\n        // \"buy/mint\" shares\n        v.totalShares += sharesAdd;\n        s.shares += sharesAdd;\n\n        // keep track of staked tokens\n        s.staked = newStaked;\n        if (withTransfer) _transferToContract(msg.sender, amount);\n        emit Staked(validatorId, msg.sender, amount);\n    }\n\n    /*\n     * Undelegates all staked tokens from the provided validator\n     */\n    function unstakeAll(uint128 validatorId) external whenNotPaused {\n        _unstake(validatorId, 0); // pass 0 to request full amount\n    }\n\n    /*\n     * Undelegates some number of tokens from the provided validator\n     */\n    function unstake(uint128 validatorId, uint128 amount) external whenNotPaused {\n        require(amount > 0, \"Amount is 0\");\n        _unstake(validatorId, amount);\n    }\n\n    /*\n     * Undelegates tokens from the provided validator\n     */\n    function _unstake(uint128 validatorId, uint128 amount) internal {\n        require(validatorId < validatorsN, \"Invalid validator\");\n\n        Validator storage v = _validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        require(amount <= s.staked, \"Cannot unstake amount greater than current stake\");\n\n        bool isUnstakingAll = amount == 0 || amount == s.staked;\n        uint128 effectiveAmount = isUnstakingAll ? s.staked : amount;\n        uint128 newStaked = s.staked - effectiveAmount;\n\n        if (isUnstakingAll) {\n            // enforce precondition for later math that effectiveAmount is always nonzero\n            require(effectiveAmount > 0, \"Already fully unstaked\");\n        } else {\n            // to prevent buildup of Unstaking[] elements, do not allow user to repeatedly unstake trivial amounts\n            // (but do allow removal of a trivial amount if it is the entire remaining stake)\n            require(effectiveAmount >= REWARD_REDEEM_THRESHOLD, \"Unstake amount is too small\");\n\n            // to prevent \"spam\" delegations, and runaway exchangeRate inflation from all-but-dust self-stake unstaking,\n            // disallow unstaking that would result in a new stake below delegatorMinStake\n            // (with the exception of an unstaking that takes the stake exactly to zero)\n            require(newStaked >= delegatorMinStake, \"Cannot unstake to a position below delegatorMinStake (except to zero)\");\n        }\n\n        bool isValidator = msg.sender == v._address;\n        if (isValidator && v.disabledAtBlock == 0) {\n            // validators will have to disable themselves if they want to unstake tokens below delegation max cap\n            uint128 newValidatorMaxCap = newStaked * maxCapMultiplier;\n            require(v.delegated <= newValidatorMaxCap, \"Cannot decrease delegation max-cap below current delegation while validator is enabled\");\n        }\n        if (!isValidator) {\n            v.delegated -= effectiveAmount;\n        }\n\n        uint128 sharesToRemove = _tokensToShares(effectiveAmount, v.exchangeRate);\n\n        // sometimes, due to conversion inconsistencies, sharesToRemove might end up larger than s.shares;\n        // so we clamp sharesToRemove to s.shares (the redeemer unstakes trivially more tokens in this case)\n        if (sharesToRemove > s.shares) sharesToRemove = s.shares;\n\n        // sanity check: sharesToRemove should never be zero while amount is nonzero, as this would enable\n        // infinite draining of funds\n        require(sharesToRemove > 0, \"Underflow error\");\n\n        unchecked {\n            s.shares -= sharesToRemove;\n        }\n        v.totalShares -= sharesToRemove;\n\n        // remove staked tokens\n        s.staked = newStaked;\n\n        // disable validator if they unstaked to below their required self-stake\n        if (isValidator && validatorEnableMinStake > 0 && v.disabledAtBlock == 0 && s.staked < validatorEnableMinStake) {\n            uint256 disabledAtBlock = block.number;\n            v.disabledAtBlock = disabledAtBlock;\n            emit ValidatorDisabled(validatorId, disabledAtBlock);\n        }\n\n        // create unstaking instance\n        uint128 coolDownEnd = uint128(v.disabledAtBlock != 0 ? v.disabledAtBlock : block.number);\n        unchecked {\n            coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown);\n        }\n        uint128 unstakeId = uint128(v.unstakings[msg.sender].length);\n        v.unstakings[msg.sender].push(Unstaking(coolDownEnd, effectiveAmount));\n        emit Unstaked(validatorId, msg.sender, effectiveAmount, unstakeId);\n    }\n\n    /*\n     * Restakes unstaked tokens (with the same validator)\n     */\n    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) external whenNotPaused {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(_validators[validatorId].unstakings[msg.sender].length > unstakingId, \"Unstaking does not exist\");\n        Unstaking storage us = _validators[validatorId].unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        unchecked {\n            us.amount -= amount;\n        }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0) us.coolDownEnd = 0;\n        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);\n        _stake(validatorId, amount, false);\n    }\n\n    /*\n     * Transfers out unlocked unstaked tokens back to the delegator\n     */\n    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) external whenNotPaused {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(_validators[validatorId].unstakings[msg.sender].length > unstakingId, \"Unstaking does not exist\");\n        Unstaking storage us = _validators[validatorId].unstakings[msg.sender][unstakingId];\n        require(uint128(block.number) > us.coolDownEnd, \"Cooldown period has not ended\");\n        require(us.amount >= amount, \"Amount is too high\");\n        unchecked {\n            us.amount -= amount;\n        }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0) us.coolDownEnd = 0;\n        emit UnstakeRedeemed(validatorId, msg.sender, unstakingId, amount);\n        _transferFromContract(msg.sender, amount);\n    }\n\n    /*\n     * Redeems all available rewards\n     */\n    function redeemAllRewards(uint128 validatorId, address beneficiary) external whenNotPaused {\n        _redeemRewards(validatorId, beneficiary, 0); // pass 0 to request full amount\n    }\n\n    /*\n     * Redeems partial rewards\n     */\n    function redeemRewards(uint128 validatorId, address beneficiary, uint128 amount) external whenNotPaused {\n        require(amount > 0, \"Amount is 0\");\n        _redeemRewards(validatorId, beneficiary, amount);\n    }\n\n    function _redeemRewards(uint128 validatorId, address beneficiary, uint128 amount) internal {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(beneficiary != address(0x0), \"Invalid beneficiary\");\n        Validator storage v = _validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        // how many tokens a delegator/validator has in total on the contract\n        // include earned commission if the delegator is the validator\n        uint128 totalValue = _sharesToTokens(s.shares, v.exchangeRate);\n\n        // how many tokens a delegator/validator has \"unlocked\", free to be redeemed\n        // (i.e. not staked or in unstaking cooldown)\n        uint128 totalUnlockedValue = (totalValue < s.staked) ? 0 : (totalValue - s.staked);\n\n        bool isRedeemingAll = (amount == 0 || amount == totalUnlockedValue); // amount is 0 when it's requested to redeem all rewards\n\n        // make sure rewards exist\n        // (note that this still works in the case where we're redeeming all! always doing this check saves a branch op)\n        require(amount <= totalUnlockedValue, \"Cannot redeem amount greater than held, unstaked rewards\");\n\n        uint128 effectiveAmount = isRedeemingAll ? totalUnlockedValue : amount;\n\n        // can only redeem above redeem threshold\n        require(effectiveAmount >= REWARD_REDEEM_THRESHOLD, \"Requested amount must be higher than redeem threshold\");\n\n        uint128 sharesToBurn = _tokensToShares(effectiveAmount, v.exchangeRate);\n\n        // sometimes, due to conversion inconsistencies, sharesToBurn might end up larger than s.shares;\n        // so we clamp sharesToBurn to s.shares (the redeemer gets trivially more value out in this case)\n        if (sharesToBurn > s.shares) sharesToBurn = s.shares;\n\n        // sanity check: sharesToBurn should never be zero while effectiveAmount is nonzero, as this\n        // would enable infinite draining of funds\n        require(sharesToBurn > 0, \"Underflow error\");\n\n        unchecked {\n            v.totalShares -= sharesToBurn;\n        }\n        unchecked {\n            s.shares -= sharesToBurn;\n        }\n\n        emit RewardRedeemed(validatorId, beneficiary, effectiveAmount);\n        _transferFromContract(beneficiary, effectiveAmount);\n    }\n\n    function redeemCommission(uint128 validatorId, address beneficiary, uint128 amount) public whenNotPaused {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(beneficiary != address(0x0), \"Invalid beneficiary\");\n        Validator storage v = _validators[validatorId];\n        require(v._address == msg.sender, \"The sender is not the validator\");\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        require(v.commissionAvailableToRedeem > 0, \"No commission available to redeem\");\n        require(amount > 0, \"The requested amount is 0\");\n        require(amount <= v.commissionAvailableToRedeem, \"Requested amount is higher than commission available to redeem\");\n        unchecked {\n            v.commissionAvailableToRedeem -= amount;\n        }\n\n        _transferFromContract(beneficiary, amount);\n        emit CommissionRewardRedeemed(validatorId, beneficiary, amount);\n    }\n\n    function redeemAllCommission(uint128 validatorId, address beneficiary) external whenNotPaused {\n        redeemCommission(validatorId, beneficiary, _validators[validatorId].commissionAvailableToRedeem);\n    }\n\n    /*\n     * Redelegates tokens to another validator if a validator got disabled.\n     * First the tokens need to be unstaked\n     */\n    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) external whenNotPaused {\n        require(oldValidatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = _validators[oldValidatorId];\n\n        // assets of delegators cannot be moved while validator is frozen\n        require(!v.frozen, \"Validator is frozen\");\n\n        require(v.disabledAtBlock != 0, \"Validator is not disabled\");\n        require(v._address != msg.sender, \"Validator cannot redelegate\");\n        require(v.unstakings[msg.sender].length > unstakingId, \"Unstaking does not exist\");\n        Unstaking storage us = v.unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        // stake tokens back to the contract using new validator, set withTransfer to false since the tokens are already in the contract\n        unchecked {\n            us.amount -= amount;\n        }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0) us.coolDownEnd = 0;\n        emit Redelegated(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);\n        _stake(newValidatorId, amount, false);\n    }\n\n    /*\n     * Changes the validator staking address, this will transfer validator staking data and optionally unstakings\n     */\n    function setValidatorAddress(uint128 validatorId, address newAddress) external whenNotPaused {\n        Validator storage v = _validators[validatorId];\n        require(msg.sender == v._address, \"Sender is not the validator\");\n        require(v._address != newAddress, \"The new address cannot be equal to the current validator address\");\n        require(newAddress != address(0), \"Invalid validator address\");\n        require(!v.frozen, \"Validator is frozen\");\n\n        v.stakings[newAddress].shares += v.stakings[msg.sender].shares;\n        v.stakings[newAddress].staked += v.stakings[msg.sender].staked;\n        delete v.stakings[msg.sender];\n\n        Unstaking[] storage oldUnstakings = v.unstakings[msg.sender];\n        uint256 length = oldUnstakings.length;\n        require(length <= 300, \"Cannot transfer more than 300 unstakings\");\n        Unstaking[] storage newUnstakings = v.unstakings[newAddress];\n        for (uint128 i = 0; i < length; ++i) {\n            newUnstakings.push(oldUnstakings[i]);\n        }\n        delete v.unstakings[msg.sender];\n\n        v._address = newAddress;\n        emit ValidatorAddressChanged(validatorId, newAddress);\n    }\n\n    /*\n     * Gets metadata\n     */\n    function getMetadata()\n        external\n        view\n        returns (\n            address CQTaddress,\n            address _stakingManager,\n            uint128 _validatorsN,\n            uint128 _rewardPool,\n            uint128 _validatorCoolDown,\n            uint128 _delegatorCoolDown,\n            uint128 _maxCapMultiplier,\n            uint128 _validatorMaxStake,\n            uint128 _validatorEnableMinStake,\n            uint128 _delegatorMinStake\n        )\n    {\n        return (\n            address(CQT),\n            stakingManager,\n            validatorsN,\n            rewardPool,\n            validatorCoolDown,\n            delegatorCoolDown,\n            maxCapMultiplier,\n            validatorMaxStake,\n            validatorEnableMinStake,\n            delegatorMinStake\n        );\n    }\n\n    /*\n     * Returns validator metadata with how many tokens were staked and delegated excluding compounded rewards\n     */\n    function getValidatorMetadata(uint128 validatorId) public view returns (address _address, uint128 staked, uint128 delegated, uint128 commissionRate, uint256 disabledAtBlock) {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = _validators[validatorId];\n        return (v._address, v.stakings[v._address].staked, v.delegated, v.commissionRate, v.disabledAtBlock);\n    }\n\n    /*\n     * Returns metadata for each validator\n     */\n    function getAllValidatorsMetadata()\n        external\n        view\n        returns (address[] memory addresses, uint128[] memory staked, uint128[] memory delegated, uint128[] memory commissionRates, uint256[] memory disabledAtBlocks)\n    {\n        return getValidatorsMetadata(0, validatorsN);\n    }\n\n    /*\n     * Returns metadata for validators whose ids are between startId and endId exclusively\n     */\n    function getValidatorsMetadata(\n        uint128 startId,\n        uint128 endId\n    ) public view returns (address[] memory addresses, uint128[] memory staked, uint128[] memory delegated, uint128[] memory commissionRates, uint256[] memory disabledAtBlocks) {\n        require(endId <= validatorsN, \"Invalid end id\");\n        require(startId < endId, \"Start id must be less than end id\");\n\n        uint128 n = endI"
    }
  ]
}