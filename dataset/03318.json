{
  "Title": "`merkleProof` length not checked",
  "Content": "##### Description\n`merkleProof` length is not checked:\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/core/AccountMining.sol#L64\n##### Recommendation\nWe recommend adding a check that `merkleProof.length > 0`.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/AccountMining.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport {AddressProvider} from \"./AddressProvider.sol\";\nimport {AccountFactory} from \"./AccountFactory.sol\";\nimport {IMerkleDistributor} from \"../interfaces/IMerkleDistributor.sol\";\n\n/// @dev Account Mining contract, based on https://github.com/Uniswap/merkle-distributor\n/// It's needed only during Account Mining phase before protocol will be launched\ncontract AccountMining is IMerkleDistributor {\n    address public immutable override token;\n    uint256 public immutable amount;\n    bytes32 public immutable override merkleRoot;\n    AccountFactory public immutable accountFactory;\n\n    // This is a packed array of booleans.\n    mapping(uint256 => uint256) private claimedBitMap;\n\n    constructor(\n        address token_,\n        bytes32 merkleRoot_,\n        uint256 amount_,\n        AddressProvider addressProvider\n    ) {\n        token = token_;\n        merkleRoot = merkleRoot_;\n        amount = amount_;\n        accountFactory = AccountFactory(addressProvider.getAccountFactory());\n    }\n\n    function isClaimed(uint256 index) public view override returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] =\n            claimedBitMap[claimedWordIndex] |\n            (1 << claimedBitIndex);\n    }\n\n    function claim(\n        uint256 index,\n        uint256 salt,\n        bytes32[] calldata merkleProof\n    ) external override {\n        require(\n            !isClaimed(index),\n            \"MerkleDistributor: Account is already mined.\"\n        );\n\n        address account = msg.sender;\n\n        // Verify the merkle proof.\n        bytes32 node = keccak256(abi.encodePacked(index, account, salt));\n        require(\n            MerkleProof.verify(merkleProof, merkleRoot, node),\n            \"MerkleDistributor: Invalid proof.\"\n        );\n\n        // Mark it claimed and send the token.\n        _setClaimed(index);\n        require(\n            IERC20(token).transfer(account, amount),\n            \"MerkleDistributor: Transfer failed.\"\n        );\n\n        accountFactory.mineCreditAccount();\n        emit Claimed(index, account);\n    }\n}"
    }
  ]
}