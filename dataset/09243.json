{
  "Title": "[N-19] Use allowlist/denylist rather than blacklist/whitelist",
  "Content": "\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts-full/AlchemicTokenV1.sol   #1\n\n110:   function setBlacklist(address minter) external onlySentinel {\n```\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV1.sol#L110>\n\n**[0xfoobar (Alchemix) commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/228#issuecomment-1140785384):**\n > Incredibly comprehensive, great writeup\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-alchemix",
  "Code": [
    {
      "filename": "contracts-full/AlchemicTokenV1.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}"
    }
  ]
}