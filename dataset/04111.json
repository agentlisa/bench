{
  "Title": "Uninitialized `availableLiquidity` in Loan Size Calculation.",
  "Content": "##### Description\n\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/libraries/logic/ValidationLogic.sol#L200\n\nThe `vars.availableLiquidity` field is not initialized before usage.\n\n```solidity\n//calculate the max available loan size in stable rate mode as a percentage of the\n//available liquidity\nuint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(maxStableLoanPercent);\n```\n##### Recommendation\nProper initialization should be added.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/logic/ValidationLogic.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {GenericLogic} from './GenericLogic.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {Helpers} from '../helpers/Helpers.sol';\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements functions to validate specific action on the protocol.\n */\nlibrary ValidationLogic {\n  using ReserveLogic for ReserveLogic.ReserveData;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20 for IERC20;\n  using ReserveConfiguration for ReserveConfiguration.Map;\n  using UserConfiguration for UserConfiguration.Map;\n\n  /**\n   * @dev validates a deposit.\n   * @param reserve the reserve state on which the user is depositing\n   * @param amount the amount to be deposited\n   */\n  function validateDeposit(ReserveLogic.ReserveData storage reserve, uint256 amount) external view {\n    (bool isActive, bool isFreezed, , ) = reserve.configuration.getFlags();\n\n    require(amount > 0, Errors.AMOUNT_NOT_GREATER_THAN_0);\n    require(isActive, Errors.NO_ACTIVE_RESERVE);\n    require(!isFreezed, Errors.NO_UNFREEZED_RESERVE);\n  }\n\n  /**\n   * @dev validates a withdraw action.\n   * @param reserveAddress the address of the reserve\n   * @param amount the amount to be withdrawn\n   * @param userBalance the balance of the user\n   */\n  function validateWithdraw(\n    address reserveAddress,\n    uint256 amount,\n    uint256 userBalance,\n    mapping(address => ReserveLogic.ReserveData) storage reservesData,\n    UserConfiguration.Map storage userConfig,\n    address[] calldata reserves,\n    address oracle\n  ) external view {\n    require(amount > 0, Errors.AMOUNT_NOT_GREATER_THAN_0);\n\n    require(amount <= userBalance, Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    require(\n      GenericLogic.balanceDecreaseAllowed(\n        reserveAddress,\n        msg.sender,\n        userBalance,\n        reservesData,\n        userConfig,\n        reserves,\n        oracle\n      ),\n      Errors.TRANSFER_NOT_ALLOWED\n    );\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 principalBorrowBalance;\n    uint256 currentLtv;\n    uint256 currentLiquidationThreshold;\n    uint256 requestedBorrowAmountETH;\n    uint256 amountOfCollateralNeededETH;\n    uint256 userCollateralBalanceETH;\n    uint256 userBorrowBalanceETH;\n    uint256 borrowBalanceIncrease;\n    uint256 currentReserveStableRate;\n    uint256 availableLiquidity;\n    uint256 finalUserBorrowRate;\n    uint256 healthFactor;\n    ReserveLogic.InterestRateMode rateMode;\n    bool healthFactorBelowThreshold;\n    bool isActive;\n    bool isFreezed;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n  }\n\n  /**\n   * @dev validates a borrow.\n   * @param reserve the reserve state from which the user is borrowing\n   * @param userAddress the address of the user\n   * @param amount the amount to be borrowed\n   * @param amountInETH the amount to be borrowed, in ETH\n   * @param interestRateMode the interest rate mode at which the user is borrowing\n   * @param maxStableLoanPercent the max amount of the liquidity that can be borrowed at stable rate, in percentage\n   * @param reservesData the state of all the reserves\n   * @param userConfig the state of the user for the specific reserve\n   * @param reserves the addresses of all the active reserves\n   * @param oracle the price oracle\n   */\n\n  function validateBorrow(\n    ReserveLogic.ReserveData storage reserve,\n    address userAddress,\n    uint256 amount,\n    uint256 amountInETH,\n    uint256 interestRateMode,\n    uint256 maxStableLoanPercent,\n    mapping(address => ReserveLogic.ReserveData) storage reservesData,\n    UserConfiguration.Map storage userConfig,\n    address[] calldata reserves,\n    address oracle\n  ) external view {\n    ValidateBorrowLocalVars memory vars;\n\n    (\n      vars.isActive,\n      vars.isFreezed,\n      vars.borrowingEnabled,\n      vars.stableRateBorrowingEnabled\n    ) = reserve.configuration.getFlags();\n\n    require(vars.isActive, Errors.NO_ACTIVE_RESERVE);\n    require(!vars.isFreezed, Errors.NO_UNFREEZED_RESERVE);\n\n    require(vars.borrowingEnabled, Errors.BORROWING_NOT_ENABLED);\n\n    //validate interest rate mode\n    require(\n      uint256(ReserveLogic.InterestRateMode.VARIABLE) == interestRateMode ||\n        uint256(ReserveLogic.InterestRateMode.STABLE) == interestRateMode,\n      Errors.INVALID_INTEREST_RATE_MODE_SELECTED\n    );\n\n    (\n      vars.userCollateralBalanceETH,\n      vars.userBorrowBalanceETH,\n      vars.currentLtv,\n      vars.currentLiquidationThreshold,\n      vars.healthFactor\n    ) = GenericLogic.calculateUserAccountData(\n      userAddress,\n      reservesData,\n      userConfig,\n      reserves,\n      oracle\n    );\n\n    require(vars.userCollateralBalanceETH > 0, Errors.COLLATERAL_BALANCE_IS_0);\n\n    require(\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    vars.amountOfCollateralNeededETH = vars.userBorrowBalanceETH.add(amountInETH).percentDiv(\n      vars.currentLtv\n    ); //LTV is calculated in percentage\n\n    require(\n      vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\n      Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW\n    );\n\n    /**\n     * Following conditions need to be met if the user is borrowing at a stable rate:\n     * 1. Reserve must be enabled for stable rate borrowing\n     * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\n     *    they are borrowing, to prevent abuses.\n     * 3. Users will be able to borrow only a relatively small, configurable amount of the total\n     *    liquidity\n     **/\n\n    if (vars.rateMode == ReserveLogic.InterestRateMode.STABLE) {\n      //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\n\n      require(vars.stableRateBorrowingEnabled, Errors.STABLE_BORROWING_NOT_ENABLED);\n\n      require(\n        !userConfig.isUsingAsCollateral(reserve.id) ||\n          reserve.configuration.getLtv() == 0 ||\n          amount > IERC20(reserve.aTokenAddress).balanceOf(userAddress),\n        Errors.CALLATERAL_SAME_AS_BORROWING_CURRENCY\n      );\n\n      //calculate the max available loan size in stable rate mode as a percentage of the\n      //available liquidity\n      uint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(maxStableLoanPercent);\n\n      require(amount <= maxLoanSizeStable, Errors.AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE);\n    }\n  }\n\n  /**\n   * @dev validates a repay.\n   * @param reserve the reserve state from which the user is repaying\n   * @param amountSent the amount sent for the repayment. Can be an actual value or uint(-1)\n   * @param onBehalfOf the address of the user msg.sender is repaying for\n   * @param stableDebt the borrow balance of the user\n   * @param variableDebt the borrow balance of the user\n   */\n  function validateRepay(\n    ReserveLogic.ReserveData storage reserve,\n    uint256 amountSent,\n    ReserveLogic.InterestRateMode rateMode,\n    address onBehalfOf,\n    uint256 stableDebt,\n    uint256 variableDebt\n  ) external view {\n    bool isActive = reserve.configuration.getActive();\n\n    require(isActive, Errors.NO_ACTIVE_RESERVE);\n\n    require(amountSent > 0, Errors.AMOUNT_NOT_GREATER_THAN_0);\n\n    require(\n      (stableDebt > 0 &&\n        ReserveLogic.InterestRateMode(rateMode) == ReserveLogic.InterestRateMode.STABLE) ||\n        (variableDebt > 0 &&\n          ReserveLogic.InterestRateMode(rateMode) == ReserveLogic.InterestRateMode.VARIABLE),\n      Errors.NO_DEBT_OF_SELECTED_TYPE\n    );\n\n    require(\n      amountSent != uint256(-1) || msg.sender == onBehalfOf,\n      Errors.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\n    );\n  }\n\n  /**\n   * @dev validates a swap of borrow rate mode.\n   * @param reserve the reserve state on which the user is swapping the rate\n   * @param userConfig the user reserves configuration\n   * @param stableBorrowBalance the stable borrow balance of the user\n   * @param variableBorrowBalance the stable borrow balance of the user\n   * @param currentRateMode the rate mode of the borrow\n   */\n  function validateSwapRateMode(\n    ReserveLogic.ReserveData storage reserve,\n    UserConfiguration.Map storage userConfig,\n    uint256 stableBorrowBalance,\n    uint256 variableBorrowBalance,\n    ReserveLogic.InterestRateMode currentRateMode\n  ) external view {\n    (bool isActive, bool isFreezed, , bool stableRateEnabled) = reserve.configuration.getFlags();\n\n    require(isActive, Errors.NO_ACTIVE_RESERVE);\n    require(!isFreezed, Errors.NO_UNFREEZED_RESERVE);\n\n    if (currentRateMode == ReserveLogic.InterestRateMode.STABLE) {\n      require(stableBorrowBalance > 0, Errors.NO_STABLE_RATE_LOAN_IN_RESERVE);\n    } else if (currentRateMode == ReserveLogic.InterestRateMode.VARIABLE) {\n      require(variableBorrowBalance > 0, Errors.NO_VARIABLE_RATE_LOAN_IN_RESERVE);\n      /**\n       * user wants to swap to stable, before swapping we need to ensure that\n       * 1. stable borrow rate is enabled on the reserve\n       * 2. user is not trying to abuse the reserve by depositing\n       * more collateral than he is borrowing, artificially lowering\n       * the interest rate, borrowing at variable, and switching to stable\n       **/\n      require(stableRateEnabled, Errors.STABLE_BORROWING_NOT_ENABLED);\n\n      require(\n        !userConfig.isUsingAsCollateral(reserve.id) ||\n          reserve.configuration.getLtv() == 0 ||\n          stableBorrowBalance.add(variableBorrowBalance) >\n          IERC20(reserve.aTokenAddress).balanceOf(msg.sender),\n        Errors.CALLATERAL_SAME_AS_BORROWING_CURRENCY\n      );\n    } else {\n      revert(Errors.INVALID_INTEREST_RATE_MODE_SELECTED);\n    }\n  }\n\n  /**\n   * @dev validates the choice of a user of setting (or not) an asset as collateral\n   * @param reserve the state of the reserve that the user is enabling or disabling as collateral\n   * @param reserveAddress the address of the reserve\n   * @param reservesData the data of all the reserves\n   * @param userConfig the state of the user for the specific reserve\n   * @param reserves the addresses of all the active reserves\n   * @param oracle the price oracle\n   */\n  function validateSetUseReserveAsCollateral(\n    ReserveLogic.ReserveData storage reserve,\n    address reserveAddress,\n    mapping(address => ReserveLogic.ReserveData) storage reservesData,\n    UserConfiguration.Map storage userConfig,\n    address[] calldata reserves,\n    address oracle\n  ) external view {\n    uint256 underlyingBalance = IERC20(reserve.aTokenAddress).balanceOf(msg.sender);\n\n    require(underlyingBalance > 0, Errors.UNDERLYING_BALANCE_NOT_GREATER_THAN_0);\n\n    require(\n      GenericLogic.balanceDecreaseAllowed(\n        reserveAddress,\n        msg.sender,\n        underlyingBalance,\n        reservesData,\n        userConfig,\n        reserves,\n        oracle\n      ),\n      Errors.DEPOSIT_ALREADY_IN_USE\n    );\n  }\n\n  /**\n   * @dev validates a flashloan action\n   * @param mode the flashloan mode (0 = classic flashloan, 1 = open a stable rate loan, 2 = open a variable rate loan)\n   * @param premium the premium paid on the flashloan\n   **/\n  function validateFlashloan(uint256 mode, uint256 premium) internal pure {\n    require(premium > 0, Errors.REQUESTED_AMOUNT_TOO_SMALL);\n    require(mode <= uint256(ReserveLogic.InterestRateMode.VARIABLE), Errors.INVALID_FLASHLOAN_MODE);\n  }\n\n  /**\n   * @dev Validates the liquidationCall() action\n   * @param collateralReserve The reserve data of the collateral\n   * @param principalReserve The reserve data of the principal\n   * @param userConfig The user configuration\n   * @param userHealthFactor The user's health factor\n   * @param userStableDebt Total stable debt balance of the user\n   * @param userVariableDebt Total variable debt balance of the user\n   **/\n  function validateLiquidationCall(\n    ReserveLogic.ReserveData storage collateralReserve,\n    ReserveLogic.ReserveData storage principalReserve,\n    UserConfiguration.Map storage userConfig,\n    uint256 userHealthFactor,\n    uint256 userStableDebt,\n    uint256 userVariableDebt\n  ) internal view returns (uint256, string memory) {\n    if (\n      !collateralReserve.configuration.getActive() || !principalReserve.configuration.getActive()\n    ) {\n      return (uint256(Errors.CollateralManagerErrors.NO_ACTIVE_RESERVE), Errors.NO_ACTIVE_RESERVE);\n    }\n\n    if (userHealthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD) {\n      return (\n        uint256(Errors.CollateralManagerErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),\n        Errors.HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n      );\n    }\n\n    bool isCollateralEnabled = collateralReserve.configuration.getLiquidationThreshold() > 0 &&\n      userConfig.isUsingAsCollateral(collateralReserve.id);\n\n    //if collateral isn't enabled as collateral by user, it cannot be liquidated\n    if (!isCollateralEnabled) {\n      return (\n        uint256(Errors.CollateralManagerErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),\n        Errors.COLLATERAL_CANNOT_BE_LIQUIDATED\n      );\n    }\n\n    if (userStableDebt == 0 && userVariableDebt == 0) {\n      return (\n        uint256(Errors.CollateralManagerErrors.CURRRENCY_NOT_BORROWED),\n        Errors.SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\n      );\n    }\n\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.NO_ERRORS);\n  }\n\n  /**\n   * @dev Validates the repayWithCollateral() action\n   * @param collateralReserve The reserve data of the collateral\n   * @param principalReserve The reserve data of the principal\n   * @param userConfig The user configuration\n   * @param user The address of the user\n   * @param userHealthFactor The user's health factor\n   * @param userStableDebt Total stable debt balance of the user\n   * @param userVariableDebt Total variable debt balance of the user\n   **/\n  function validateRepayWithCollateral(\n    ReserveLogic.ReserveData storage collateralReserve,\n    ReserveLogic.ReserveData storage principalReserve,\n    UserConfiguration.Map storage userConfig,\n    address user,\n    uint256 userHealthFactor,\n    uint256 userStableDebt,\n    uint256 userVariableDebt\n  ) internal view returns (uint256, string memory) {\n    if (\n      !collateralReserve.configuration.getActive() || !principalReserve.configuration.getActive()\n    ) {\n      return (uint256(Errors.CollateralManagerErrors.NO_ACTIVE_RESERVE), Errors.NO_ACTIVE_RESERVE);\n    }\n\n    if (\n      msg.sender != user && userHealthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD\n    ) {\n      return (\n        uint256(Errors.CollateralManagerErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),\n        Errors.HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n      );\n    }\n\n    if (msg.sender != user) {\n      bool isCollateralEnabled = collateralReserve.configuration.getLiquidationThreshold() > 0 &&\n        userConfig.isUsingAsCollateral(collateralReserve.id);\n\n      //if collateral isn't enabled as collateral by user, it cannot be liquidated\n      if (!isCollateralEnabled) {\n        return (\n          uint256(Errors.CollateralManagerErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),\n          Errors.COLLATERAL_CANNOT_BE_LIQUIDATED\n        );\n      }\n    }\n\n    if (userStableDebt == 0 && userVariableDebt == 0) {\n      return (\n        uint256(Errors.CollateralManagerErrors.CURRRENCY_NOT_BORROWED),\n        Errors.SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\n      );\n    }\n\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.NO_ERRORS);\n  }\n\n  /**\n   * @dev Validates the swapLiquidity() action\n   * @param fromReserve The reserve data of the asset to swap from\n   * @param toReserve The reserve data of the asset to swap to\n   * @param fromAsset Address of the asset to swap from\n   * @param toAsset Address of the asset to swap to\n   **/\n  function validateSwapLiquidity(\n    ReserveLogic.ReserveData storage fromReserve,\n    ReserveLogic.ReserveData storage toReserve,\n    address fromAsset,\n    address toAsset\n  ) internal view returns (uint256, string memory) {\n    if (fromAsset == toAsset) {\n      return (\n        uint256(Errors.CollateralManagerErrors.INVALID_EQUAL_ASSETS_TO_SWAP),\n        Errors.INVALID_EQUAL_ASSETS_TO_SWAP\n      );\n    }\n\n    (bool isToActive, bool isToFreezed, , ) = toReserve.configuration.getFlags();\n    if (!fromReserve.configuration.getActive() || !isToActive) {\n      return (uint256(Errors.CollateralManagerErrors.NO_ACTIVE_RESERVE), Errors.NO_ACTIVE_RESERVE);\n    }\n    if (isToFreezed) {\n      return (\n        uint256(Errors.CollateralManagerErrors.NO_UNFREEZED_RESERVE),\n        Errors.NO_UNFREEZED_RESERVE\n      );\n    }\n\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.NO_ERRORS);\n  }\n}"
    }
  ]
}