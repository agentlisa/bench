{
  "Title": "[M-05] Early user can call issue() and then melt() to increase basketsNeeded to supply ratio to its maximum value and then melt() won’t work and contract features like issue() won’t work",
  "Content": "# Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L563-L573\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L801-L814\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L219\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L70-L84\n\n\n# Vulnerability details\n\n## Impact\nFunction `melt()` melt a quantity of RToken from the caller's account, increasing the basket rate. basket rate should be between `1e9` and `1e27` and function `requireValidBUExchangeRate()` checks that if it's not in interval the the code would revert. the call to `requireValidBUExchangeRate()` happens in the function `mint()`, `melt()` and `setBasketsNeeded()` which are used in `issue()` and `handoutExcessAssets()` and `compromiseBasketsNeeded()` which are used in multiple functionality of the systems. early malicious user can call `issue(1e18)` and `melt(1e18 - 1)` and then set the ratio between baskets needed and total supply to `1e27` and then any new action that increase the ratio would fail. because during the `issue()` code calls `melt()` so the issue() would fail for sure and other functionalities can increase the ratio because of the ratio too because of the rounding error which result in revert. so by exploiting this attacker can make RToken to be in broken state and most of the functionalities of the system would stop working.\n\n## Proof of Concept\nThis is `melt()` code:\n```\n    function melt(uint256 amtRToken) external notPausedOrFrozen {\n        _burn(_msgSender(), amtRToken);\n        emit Melted(amtRToken);\n        requireValidBUExchangeRate();\n    }\n```\nAs you can see it allows anyone to burn their RToken balance. This is `requireValidBUExchangeRate()` code:\n```\n    function requireValidBUExchangeRate() private view {\n        uint256 supply = totalSupply();\n        if (supply == 0) return;\n\n        // Note: These are D18s, even though they are uint256s. This is because\n        // we cannot assume we stay inside our valid range here, as that is what\n        // we are checking in the first place\n        uint256 low = (FIX_ONE_256 * basketsNeeded) / supply; // D18{BU/rTok}\n        uint256 high = (FIX_ONE_256 * basketsNeeded + (supply - 1)) / supply; // D18{BU/rTok}\n\n        // 1e9 = FIX_ONE / 1e9; 1e27 = FIX_ONE * 1e9\n        require(uint192(low) >= 1e9 && uint192(high) <= 1e27, \"BU rate out of range\");\n    }\n```\nAs you can see it checks and makes sure that  the BU to RToken exchange rate to be in [1e-9, 1e9]. so Attacker can perform this steps:\n1. add `1e18` RToken as first issuer by calling `issue()`\n2. call `melt()` and burn `1e18 - 1` of his RTokens.\n3. not `basketsNeeded` would be `1e18` and `totalSupply()` of RTokens would be `1` and the BU to RToken exchange rate would be its maximum value `1e27` and `requireValidBUExchangeRate()` won't allow increasing the ratio.\n4. now calls to `melt()` would revert and because `issue()` calls to `furnace.melt()` which calls `RToken.melt()` so all calls to `issue()` would revert. other functionality which result in calling `mint()`, `melt()` and `setBasketsNeeded()` if they increase the ratio would fail too. as there is rounding error when converting RToken amount to basket amount so burning and minting new RTokens and increase the ratio too because of those rounding errors and those logics would revert. (`handoutExcessAssets()` would revert because it mint revenue RToken and update `basketsNeeded` and it calculates new basket amount based on RToken amounts and rounds down so it would increase the BU to RToken ratio which cause code to revert in `mint()`) (`redeem()` would increase the ratio simillar to `handoutExcessAssets()` because of rounding down)\n5. the attacker doesn't need to be first issuer just he needs to be one of the early issuers and by performing the attack and also if the ratio gets to higher value of the maximum allowed the protocol won't work properly as it documented the supported rage for variables to work properly.\n\nso attacker can make protocol logics to be broken and then RToken won't be useless and attacker can perform this attack to any newly deployed RToken.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\ndon't allow everyone to melt their tokens or don't allow melting if totalSupply() become very small.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-reserve-contest",
  "Code": [
    {
      "filename": "contracts/p1/RToken.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\n// solhint-disable-next-line max-line-length\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../interfaces/IRToken.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"../libraries/RedemptionBattery.sol\";\nimport \"./mixins/Component.sol\";\nimport \"./mixins/RewardableLib.sol\";\nimport \"../vendor/ERC20PermitUpgradeable.sol\";\n\n// MIN_BLOCK_ISSUANCE_LIMIT: {rTok/block} 10k whole RTok\nuint192 constant MIN_BLOCK_ISSUANCE_LIMIT = 10_000 * FIX_ONE;\n\n// MAX_ISSUANCE_RATE: 100%\nuint192 constant MAX_ISSUANCE_RATE = FIX_ONE; // {1}\n\n/**\n * @title RTokenP1\n * An ERC20 with an elastic supply and governable exchange rate to basket units.\n */\ncontract RTokenP1 is ComponentP1, ERC20PermitUpgradeable, IRToken {\n    using RedemptionBatteryLib for RedemptionBatteryLib.Battery;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// The mandate describes what goals its governors should try to achieve. By succinctly\n    /// explaining the RToken’s purpose and what the RToken is intended to do, it provides common\n    /// ground for the governors to decide upon priorities and how to weigh tradeoffs.\n    ///\n    /// Example Mandates:\n    ///\n    /// - Capital preservation first. Spending power preservation second. Permissionless\n    ///     access third.\n    /// - Capital preservation above all else. All revenues fund the over-collateralization pool.\n    /// - Risk-neutral pursuit of profit for token holders.\n    ///     Maximize (gross revenue - payments for over-collateralization and governance).\n    /// - This RToken holds only FooCoin, to provide a trade for hedging against its\n    ///     possible collapse.\n    ///\n    /// The mandate may also be a URI to a longer body of text, presumably on IPFS or some other\n    /// immutable data store.\n    string public mandate;\n\n    // ==== Governance Params ====\n\n    // D18{1} fraction of supply that may be issued per block\n    // Always, issuanceRate <= MAX_ISSUANCE_RATE = FIX_ONE\n    uint192 public issuanceRate;\n\n    // the following governance parameters exist inside the Battery struct:\n    //      battery.redemptionRateFloor\n    //      battery.scalingRedemptionRate\n\n    // ==== End Governance Params ====\n\n    // ==== Peer components ====\n    IAssetRegistry private assetRegistry;\n    IBasketHandler private basketHandler;\n    IBackingManager private backingManager;\n    IFurnace private furnace;\n\n    // The number of baskets that backingManager must hold\n    // in order for this RToken to be fully collateralized.\n    // The exchange rate for issuance and redemption is totalSupply()/basketsNeeded {BU}/{qRTok}.\n    uint192 public basketsNeeded; // D18{BU}\n\n    // ==== Slow Issuance State====\n\n    // When all pending issuances will have vested.\n    uint192 private allVestAt; // D18{fractional block number}\n\n    // Enforce a fixed issuanceRate throughout the entire block by caching it.\n    // Both of these MUST only be modified by whenFinished()\n    uint192 private lastIssRate; // D18{rTok/block}\n    uint256 private lastIssRateBlock; // {block number}\n\n    // IssueItem: One edge of an issuance\n    struct IssueItem {\n        uint192 when; // D18{fractional block number}\n        uint256 amtRToken; // {qRTok} Total amount of RTokens that have vested by `when`\n        uint192 amtBaskets; // D18{BU} Total amount of baskets that should back those RTokens\n        uint256[] deposits; // {qTok}, Total amounts of basket collateral deposited for vesting\n    }\n\n    struct IssueQueue {\n        uint256 basketNonce; // The nonce of the basket this queue models deposits against\n        address[] tokens; // Addresses of the erc20 tokens modelled by deposits in this queue\n        uint256 left; // [left, right) is the span of currently-valid items\n        uint256 right; //\n        IssueItem[] items; // The actual items (The issuance \"fenceposts\")\n    }\n\n    mapping(address => IssueQueue) public issueQueues;\n\n    // Redemption throttle\n    RedemptionBatteryLib.Battery private battery;\n\n    // {ERC20: {qTok} owed to Recipients}\n    // During reward sweeping, we sweep token balances - liabilities\n    mapping(IERC20 => uint256) private liabilities;\n\n    // For an initialized IssueQueue queue:\n    //     queue.right >= left\n    //     queue.right == left  iff  there are no more pending issuances in this queue\n    //\n    // The short way to describe this is that IssueQueue stores _cumulative_ issuances, not raw\n    // issuances, and so any particular issuance is actually the _difference_ between two adjaacent\n    // TotalIssue items in an IssueQueue.\n    //\n    // The way to keep an IssueQueue striaght in your head is to think of each TotalIssue item as a\n    // \"fencepost\" in the queue of actual issuances. The true issuances are the spans between the\n    // TotalIssue items. For example, if:\n    //    queue.items[queue.left].amtRToken == 1000 , and\n    //    queue.items[queue.right - 1].amtRToken == 6000,\n    // then the issuance \"between\" them is 5000 RTokens. If we waited long enough and then called\n    // vest() on that account, we'd vest 5000 RTokens *to* that account.\n    //\n    // You can vestUpTo an IssueItem queue[i] if\n    //   left < i <= right, and\n    //   block.number >= queue[i].when.toUint()\n    //\n    // We define a (partial) ordering on IssueItems: item1 < item2 iff the following all hold:\n    //   item1.when < item2.when\n    //   item1.amtRToken < item2.amtRToken\n    //   item1.amtBaskets < item2.amtBaskets\n    //   for all valid indices i, item1.deposits[i] < item2.deposits[i]\n    //\n    // And, in fact, item2 - item1 is then well-defined (and also piecewise).\n    //\n    // We'll also define lastItem(addr) as a function of contract state:\n    //     if queue.right == 0 then IssueItem.zero else queue.items[queue.right]\n    //     where queue = issueQueues[addr]\n    //\n    // ==== Invariants ====\n    // For any queue in value(issueQueues):\n    //   if 0 <= i < j <= queue.right, then item[i] < item[j]\n    //   queue.items[queue.right] <= allVestAt\n    //\n    // If queue.left < queue.right, then:\n    // - all the issue() calls it models happened while basketHandler.nonce() was queue.basketNonce\n    // - queue.tokens = erc20s for each of those issuances, where (erc20s, _) = basket.quote()\n    //     so, queue.tokens was the bskt token list when basketHandler.nonce() was queue.basketNonce\n    // - for each item in queue.items: queue.tokens.length == item.deposits.length\n\n    function init(\n        IMain main_,\n        string calldata name_,\n        string calldata symbol_,\n        string calldata mandate_,\n        uint192 issuanceRate_,\n        uint192 scalingRedemptionRate_,\n        uint256 redemptionRateFloor_\n    ) external initializer {\n        require(bytes(name_).length > 0, \"name empty\");\n        require(bytes(symbol_).length > 0, \"symbol empty\");\n        require(bytes(mandate_).length > 0, \"mandate empty\");\n        __Component_init(main_);\n        __ERC20_init(name_, symbol_);\n        __ERC20Permit_init(name_);\n\n        assetRegistry = main_.assetRegistry();\n        basketHandler = main_.basketHandler();\n        backingManager = main_.backingManager();\n        furnace = main_.furnace();\n\n        mandate = mandate_;\n        setIssuanceRate(issuanceRate_);\n        setScalingRedemptionRate(scalingRedemptionRate_);\n        setRedemptionRateFloor(redemptionRateFloor_);\n    }\n\n    /// Begin a time-delayed issuance of RToken for basket collateral\n    /// @param amtRToken {qTok} The quantity of RToken to issue\n    /// @custom:interaction nearly CEI, but see comments around handling of refunds\n    function issue(uint256 amtRToken) external {\n        issue(_msgSender(), amtRToken);\n    }\n\n    /// Begin a time-delayed issuance of RToken for basket collateral\n    /// @param recipient The address to receive the issued RTokens\n    /// @param amtRToken {qTok} The quantity of RToken to issue\n    /// @return mintedAmount {qTok} The amount of RTokens minted (instantly issued)\n    /// @custom:interaction nearly CEI, but see comments around handling of refunds\n    function issue(address recipient, uint256 amtRToken)\n        public\n        notPausedOrFrozen\n        returns (uint256)\n    {\n        require(amtRToken > 0, \"Cannot issue zero\");\n\n        // == Refresh ==\n        assetRegistry.refresh();\n\n        address issuer = _msgSender(); // OK to save: it can't be changed in reentrant runs\n\n        uint48 basketNonce = basketHandler.nonce();\n        IssueQueue storage queue = issueQueues[recipient];\n\n        // Refund issuances against old baskets\n        if (queue.basketNonce > 0 && queue.basketNonce != basketNonce) {\n            // == Interaction ==\n            // This violates simple CEI, so we have to renew any potential transient state!\n            refundSpan(recipient, queue.left, queue.right);\n\n            // Refresh collateral after interaction\n            assetRegistry.refresh();\n\n            // Refresh local values after potential reentrant changes to contract state.\n            basketNonce = basketHandler.nonce();\n            queue = issueQueues[recipient];\n        }\n\n        // == Checks-effects block ==\n        CollateralStatus status = basketHandler.status();\n        require(status == CollateralStatus.SOUND, \"basket unsound\");\n\n        furnace.melt();\n\n        // AT THIS POINT:\n        //   all contract invariants hold\n        //   furnace melting is up-to-date\n        //   asset states are up-to-date\n        //   queue.basketNonce = basketHandler.nonce()\n\n        // Compute the whole issuance span. We want to accumulate the issuance:\n        // iss = {when: vestingEnd' - vestingEnd, amtRToken, amtBaskets, deposits}\n\n        // amtBaskets: the BU change to be recorded by this issuance\n        // D18{BU} = D18{BU} * {qRTok} / {qRTok}\n        // Downcast is safe because an actual quantity of qBUs fits in uint192\n        uint192 amtBaskets = uint192(\n            totalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken\n        );\n\n        (address[] memory erc20s, uint256[] memory deposits) = basketHandler.quote(\n            amtBaskets,\n            CEIL\n        );\n\n        // Add amtRToken's worth of issuance delay to allVestAt\n        uint192 vestingEnd = whenFinished(amtRToken); // D18{block number}\n\n        // ==== If the issuance can fit in this block, and nothing is blocking it, then\n        // just do a \"quick issuance\" of iss instead of putting the issuance in the queue:\n        // effects and actions if we go this way are the combined actions to create and vest iss:\n        //   basketsNeeded += iss.amtBaskets\n        //   mint(recipient, iss.amtRToken)\n        //   for each token index i, erc20s[i].transferFrom(issuer, backingManager, iss.deposits[i])\n        if (\n            // D18{blocks} <= D18{1} * {blocks}\n            vestingEnd <= FIX_ONE_256 * block.number &&\n            queue.left == queue.right &&\n            status == CollateralStatus.SOUND\n        ) {\n            // Fixlib optimization:\n            // D18{BU} = D18{BU} + D18{BU}; uint192(+) is the same as Fix.plus\n            uint192 newBasketsNeeded = basketsNeeded + amtBaskets;\n            emit BasketsNeededChanged(basketsNeeded, newBasketsNeeded);\n            basketsNeeded = newBasketsNeeded;\n\n            // Note: We don't need to update the prev queue entry because queue.left = queue.right\n            emit Issuance(recipient, amtRToken, amtBaskets);\n\n            // == Interactions then return: transfer tokens ==\n            // Complete issuance\n            _mint(recipient, amtRToken);\n\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                    issuer,\n                    address(backingManager),\n                    deposits[i]\n                );\n            }\n\n            // All RTokens instantly issued\n            return amtRToken;\n        }\n\n        // ==== Otherwise, we're going to create and enqueue the issuance \"iss\":\n        // effects and actions down this route are:\n        //   lastItem'(recipient) = lastItem(recipient) + iss\n        //   for each token index i, erc20s[i].transferFrom(issuer, this, iss.deposits[i])\n        // Append issuance to queue (whether that needs a new allocation with push() or not)\n        IssueItem storage curr = (queue.right < queue.items.length)\n            ? queue.items[queue.right]\n            : queue.items.push();\n        curr.when = vestingEnd;\n\n        uint256 basketSize = erc20s.length; // gas optimization\n\n        // Accumulate\n        if (queue.right > 0) {\n            IssueItem storage prev = queue.items[queue.right - 1];\n            curr.amtRToken = prev.amtRToken + amtRToken;\n\n            // D18{BU} = D18{BU} + D18{BU}; uint192(+) is the same as Fix.plus\n            curr.amtBaskets = prev.amtBaskets + amtBaskets;\n\n            curr.deposits = new uint256[](deposits.length);\n            for (uint256 i = 0; i < basketSize; ++i) {\n                curr.deposits[i] = prev.deposits[i] + deposits[i];\n            }\n        } else {\n            // queue.right == 0\n            curr.amtRToken = amtRToken;\n            curr.amtBaskets = amtBaskets;\n            curr.deposits = deposits;\n        }\n\n        // overwrite intentionally: we may have stale values in `tokens` and `basketNonce`\n        queue.basketNonce = basketNonce;\n        queue.tokens = erc20s;\n        queue.right++;\n\n        emit IssuanceStarted(\n            recipient,\n            queue.right - 1,\n            amtRToken,\n            amtBaskets,\n            erc20s,\n            deposits,\n            vestingEnd\n        );\n\n        // Increment liabilities\n        for (uint256 i = 0; i < basketSize; ++i) {\n            liabilities[IERC20(erc20s[i])] += deposits[i];\n        }\n\n        // == Interactions: accept collateral ==\n        for (uint256 i = 0; i < basketSize; ++i) {\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(issuer, address(this), deposits[i]);\n        }\n\n        // No RTokens instantly issued\n        return 0;\n    }\n\n    /// Add amtRToken's worth of issuance delay to allVestAt, and return the resulting finish time.\n    /// @return finished D18{block} The new value of allVestAt\n    function whenFinished(uint256 amtRToken) private returns (uint192 finished) {\n        // Calculate the issuance rate (if this is the first issuance in the block)\n        if (lastIssRateBlock < block.number) {\n            lastIssRateBlock = block.number;\n\n            // D18{rTok/block} = D18{1/block} * D18{rTok} / D18{1}\n            // uint192 downcast is safe, max value representations are 1e18 * 1e48 / 1e18\n            lastIssRate = uint192((issuanceRate * totalSupply()) / FIX_ONE);\n            // uint192(<) is equivalent to Fix.lt\n            if (lastIssRate < MIN_BLOCK_ISSUANCE_LIMIT) lastIssRate = MIN_BLOCK_ISSUANCE_LIMIT;\n        }\n\n        // make `before` be the fractional-block when this issuance should start;\n        // before = max(allVestAt, block.number - 1)\n        uint192 before = allVestAt; // D18{block number}\n        // uint192 downcast is safe: block numbers are smaller than 1e38\n        uint192 nowStart = uint192(FIX_ONE * (block.number - 1)); // D18{block} = D18{1} * {block}\n        if (nowStart > before) before = nowStart;\n\n        // finished: D18{block} = D18{block} + D18{1} * D18{RTok} / D18{rtok/block}\n        // uint192() downcast here is safe because:\n        //   lastIssRate is at least 1e24 (from MIN_ISS_RATE), and\n        //   amtRToken is at most 1e48, so\n        //   what's downcast is at most (1e18 * 1e48 / 1e24) = 1e38 < 2^192-1\n        finished = before + uint192((FIX_ONE_256 * amtRToken + (lastIssRate - 1)) / lastIssRate);\n        allVestAt = finished;\n    }\n\n    /// Vest all available issuance for the account\n    /// Callable by anyone!\n    /// @param account The address of the account to vest issuances for\n    /// @custom:completion\n    /// @custom:interaction CEI\n    // Thin wrapper over refundSpan() and vestUpTo(); see those for correctness analysis\n    function vest(address account, uint256 endId) external notPausedOrFrozen {\n        // == Keepers ==\n        main.assetRegistry().refresh();\n\n        // == Checks ==\n        CollateralStatus status = basketHandler.status();\n        require(status == CollateralStatus.SOUND, \"basket unsound\");\n\n        IssueQueue storage queue = issueQueues[account];\n        uint48 basketNonce = basketHandler.nonce();\n\n        // == Interactions ==\n        // ensure that the queue models issuances against the current basket, not previous baskets;\n        // refund all old issuances if there are any\n        if (queue.basketNonce != basketNonce) {\n            refundSpan(account, queue.left, queue.right);\n        } else {\n            vestUpTo(account, endId);\n        }\n    }\n\n    /// Cancel some vesting issuance(s)\n    /// Only callable by the account owner\n    /// If earliest == true, cancel id if id < endId\n    /// If earliest == false, cancel id if endId <= id\n    /// @param endId The issuance index to cancel through\n    /// @param earliest If true, cancel earliest issuances; else, cancel latest issuances\n    /// @custom:interaction CEI\n    function cancel(uint256 endId, bool earliest) external notFrozen {\n        address account = _msgSender();\n        IssueQueue storage queue = issueQueues[account];\n\n        require(queue.left <= endId && endId <= queue.right, \"out of range\");\n\n        // == Interactions ==\n        if (earliest) {\n            refundSpan(account, queue.left, endId);\n        } else {\n            refundSpan(account, endId, queue.right);\n        }\n    }\n\n    /// Redeem RToken for basket collateral\n    /// @param amount {qTok} The quantity {qRToken} of RToken to redeem\n    /// @custom:action\n    /// @custom:interaction CEI\n    // checks:\n    //   balanceOf(caller) >= amount\n    //   basket is not DISABLED\n    //\n    // effects:\n    //   (so totalSupply -= amount and balanceOf(caller) -= amount)\n    //   basketsNeeded' / totalSupply' >== basketsNeeded / totalSupply\n    //\n    // actions:\n    //   let erc20s = basketHandler.erc20s()\n    //   burn(caller, amount)\n    //   for each token in erc20s:\n    //     let tokenAmt = (amount * basketsNeeded / totalSupply) baskets of support for token\n    //     let prorataAmt = (amount / totalSupply) * token.balanceOf(backingManager)\n    //     do token.transferFrom(backingManager, caller, min(tokenAmt, prorataAmt))\n    function redeem(uint256 amount) external notFrozen {\n        require(amount > 0, \"Cannot redeem zero\");\n\n        // == Refresh ==\n        main.assetRegistry().refresh();\n\n        // == Checks and Effects ==\n        address redeemer = _msgSender();\n        // Allow redemption during IFFY + UNPRICED\n        require(basketHandler.status() != CollateralStatus.DISABLED, \"collateral default\");\n\n        // Failure to melt results in a lower redemption price, so we can allow it when paused\n        // solhint-disable-next-line no-empty-blocks\n        try main.furnace().melt() {} catch {}\n\n        uint192 basketsNeeded_ = basketsNeeded; // gas optimization\n\n        // ==== Get basket redemption ====\n        // i.e, set (erc20s, amounts) = basketHandler.quote(amount * basketsNeeded / totalSupply)\n\n        // D18{BU} = D18{BU} * {qRTok} / {qRTok}\n        // downcast is safe: amount < totalSupply and basketsNeeded_ < 1e57 < 2^190 (just barely)\n        uint256 supply = totalSupply();\n        uint192 baskets = uint192(mulDiv256(basketsNeeded_, amount, supply));\n        emit Redemption(redeemer, amount, baskets);\n\n        (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);\n\n        // ==== Prorate redemption ====\n        // i.e, set amounts = min(amounts, balances * amount / totalSupply)\n        //   where balances[i] = erc20s[i].balanceOf(this)\n\n        uint256 erc20length = erc20s.length;\n\n        // D18{1} = D18 * {qRTok} / {qRTok}\n        // downcast is safe: amount <= balanceOf(redeemer) <= totalSupply(), so prorate < 1e18\n        uint192 prorate = uint192((FIX_ONE_256 * amount) / supply);\n\n        // Bound each withdrawal by the prorata share, in case we're currently under-collateralized\n        for (uint256 i = 0; i < erc20length; ++i) {\n            // {qTok}\n            uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));\n\n            // gas-optimization: only do the full mulDiv256 if prorate is 0\n            uint256 prorata = (prorate > 0)\n                ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18\n                : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}\n\n            if (prorata < amounts[i]) amounts[i] = prorata;\n        }\n\n        // Revert if redemption exceeds battery capacity\n        battery.discharge(supply, amount); // reverts on over-redemption\n\n        basketsNeeded = basketsNeeded_ - baskets;\n        emit BasketsNeededChanged(basketsNeeded_, basketsNeeded);\n\n        // == Interactions ==\n        // Accept and burn RToken, reverts if not enough balance to burn\n        _burn(redeemer, amount);\n\n        bool allZero = true;\n        for (uint256 i = 0; i < erc20length; ++i) {\n            if (amounts[i] == 0) continue;\n            if (allZero) allZero = false;\n\n            // Send withdrawal\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                address(backingManager),\n                redeemer,\n                amounts[i]\n            );\n        }\n\n        if (allZero) revert(\"Empty redemption\");\n    }\n\n    // === Rewards ===\n\n    /// Claim rewards for all ERC20s\n    /// @custom:interaction\n    function claimRewards() external {\n        requireNotPausedOrFrozen();\n        RewardableLibP1.claimRewards(assetRegistry);\n    }\n\n    /// Claim rewards for one ERC20\n    /// @custom:interaction\n    function claimRewardsSingle(IERC20 erc20) external {\n        requireNotPausedOrFrozen();\n        RewardableLibP1.claimRewardsSingle(assetRegistry.toAsset(erc20));\n    }\n\n    /// Sweep all token balances in excess of liabilities to the BackingManager\n    /// @custom:interaction\n    function sweepRewards() external {\n        requireNotPausedOrFrozen();\n        RewardableLibP1.sweepRewards(liabilities, assetRegistry, backingManager);\n    }\n\n    /// Sweep an ERC20's rewards in excess of liabilities to the BackingManager\n    /// @custom:interaction\n    function sweepRewardsSingle(IERC20 erc20) external {\n        requireNotPausedOrFrozen();\n        RewardableLibP1.sweepRewardsSingle(liabilities, erc20, assetRegistry, backingManager);\n    }\n\n    // ====\n\n    /// Mint a quantity of RToken to the `recipient`, decreasing the basket rate\n    /// @param recipient The recipient of the newly minted RToken\n    /// @param amtRToken {qRTok} The amtRToken to be minted\n    /// @custom:protected\n    // checks: unpaused; unfrozen; caller is backingManager\n    // effects:\n    //   bal'[recipient] = bal[recipient] + amtRToken\n    //   totalSupply' = totalSupply + amtRToken\n    function mint(address recipient, uint256 amtRToken) external {\n        requireNotPausedOrFrozen();\n        require(_msgSender() == address(backingManager), \"not backing manager\");\n        _mint(recipient, amtRToken);\n        requireValidBUExchangeRate();\n    }\n\n    /// Melt a quantity of RToken from the caller's account, increasing the basket rate\n    /// @param amtRToken {qRTok} The amtRToken to be melted\n    // checks: not paused or frozen\n    // effects:\n    //   bal'[caller] = bal[caller] - amtRToken\n    //   totalSupply' = totalSupply - amtRToken\n    function melt(uint256 amtRToken) external notPausedOrFrozen {\n        _burn(_msgSender(), amtRToken);\n        emit Melted(amtRToken);\n        requireValidBUExchangeRate();\n    }\n\n    /// An affordance of last resort for Main in order to ensure re-capitalization\n    /// @custom:protected\n    // checks: unpaused; unfrozen; caller is backingManager\n    // effects: basketsNeeded' = basketsNeeded_\n    function setBasketsNeeded(uint192 basketsNeeded_) external {\n        requireNotPausedOrFrozen();\n        require(_msgSender() == address(backingManager), \"not backing manager\");\n        emit BasketsNeededChanged(basketsNeeded, basketsNeeded_);\n        basketsNeeded = basketsNeeded_;\n        requireValidBUExchangeRate();\n    }\n\n    /// @param val {1/block}\n    /// @custom:governance\n    function setIssuanceRate(uint192 val) public governance {\n        require(val > 0 && val <= MAX_ISSUANCE_RATE, \"invalid issuanceRate\");\n        emit IssuanceRateSet(issuanceRate, val);\n        issuanceRate = val;\n    }\n\n    /// @return {1/hour} The max redemption charging rate\n    function scalingRedemptionRate() external view returns (uint192) {\n        return battery.scalingRedemptionRate;\n    }\n\n    /// @param val {1/hour}\n    /// @custom:governance\n    function setScalingRedemptionRate(uint192 val) public governance {\n        require(val <= FIX_ONE, \"invalid fraction\");\n        emit ScalingRedemptionRateSet(battery.scalingRedemptionRate, val);\n        battery.scalingRedemptionRate = val;\n    }\n\n    /// @return {qRTok/hour} The min redemption charging rate, in {qRTok}\n    function redemptionRateFloor() external view returns (uint256) {\n        return battery.redemptionRateFloor;\n    }\n\n    /// @param val {qRTok/hour}\n    /// @custom:governance\n    function setRedemptionRateFloor(uint256 val) public governance {\n        emit RedemptionRateFloorSet(battery.redemptionRateFloor, val);\n        battery.redemptionRateFloor = val;\n    }\n\n    /// @dev This function is only here because solidity can't autogenerate our getter\n    function issueItem(address account, uint256 index) external view returns (IssueItem memory) {\n        IssueQueue storage item = issueQueues[account];\n        require(index >= item.left && index < item.right, \"out of range\");\n        return item.items[index];\n    }\n\n    /// @return {qRTok} The maximum redemption that can be performed in the current block\n    function redemptionLimit() external view returns (uint256) {\n        return battery.currentCharge(totalSupply());\n    }\n\n    /// @return left The index of the left sides of the issuance queue for the account\n    /// @return right The index of the right sides of the issuance queue for the account\n    function queueBounds(address account) external view returns (uint256 left, uint256 right) {\n        return (issueQueues[account].left, issueQueues[account].right);\n    }\n\n    // ==== private ====\n    /// Refund all deposits in the span [left, right)\n    /// @custom:interaction\n\n    // Precisely: if right > left, then:\n    //\n    //   let iss = item(right) - item(left)\n    //     where item(0) = the zero item\n    //         | item(n) = issueQueues[account].items[n-1]\n    //\n    //   (effect) ELIMINATE ISSUANCE SPAN: Set queue.left and queue.right so that:\n    //     [queue'.left, queue'.right) intersect [left, right) == empty set\n    //     [queue'.left, queue'.right) union [left, right) == [queue.left, queue.right)\n    //     If [queue'.left, queue'.right) == empty set, then queue'.left == queue'.right == 0\n    //\n    //   (action) REFUND DEPOSITS: For i in [0, iss.deposits.length):\n    //     issueQueues[account].erc20s[i].transfer(account, iss.deposits[i])\n    function refundSpan(\n        address account,\n        uint256 left,\n        uint256 right\n    ) private {\n        if (left >= right) return; // refund an empty span\n\n        IssueQueue storage queue = issueQueues[account];\n\n        // compute total deposits to refund\n        uint256 tokensLen = queue.tokens.length;\n        uint256[] memory amt = new uint256[](tokensLen);\n        uint256 amtRToken; // {qRTok}\n        IssueItem storage rightItem = queue.items[right - 1];\n\n        // compute item(right-1) - item(left-1)\n        // we could dedup this logic for the zero item, but it would take more SLOADS\n        if (left == 0) {\n            amtRToken = rightItem.amtRToken;\n            for (uint256 i = 0; i < tokensLen; ++i) {\n                amt[i] = rightItem.deposits[i];\n\n                // Decrement liabilities\n                liabilities[IERC20(queue.tokens[i])] -= amt[i];\n            }\n        } else {\n            IssueItem storage leftItem = queue.items[left - 1];\n            amtRToken = rightItem.amtRToken - leftItem.amtRToken;\n            for (uint256 i = 0; i < tokensLen; ++i) {\n                amt[i] = rightItem.deposits[i] - leftItem.deposits[i];\n\n                // Decrement liabilities\n                liabilities[IERC20(queue.tokens[i])] -= amt[i];\n            }\n        }\n\n        if (queue.left == left && right == queue.right) {\n            // empty entire queue\n            queue.left = 0;\n            queue.right = 0;\n        } else if (queue.left == left && right < queue.right) {\n            queue.left = right; // remove span from beginning\n        } else if (queue.left < left && right == queue.right) {\n            queue.right = left; // refund span from end\n        } else {\n            // untestable:\n            //      All calls to refundSpan() use valid values for left and right.\n            //      queue.left <= left && right <= queue.right.\n            //      Any call to refundSpan() passes queue.left for left,\n            //      OR passes queue.right for right, OR both.\n            revert(\"Bad refundSpan\");\n        } // error: can't remove [left,right) from the queue, and leave just one interval\n\n        emit IssuancesCanceled(account, left, right, amtRToken);\n\n        // == Interactions ==\n        for (uint256 i = 0; i < queue.tokens.length; ++i) {\n            IERC20Upgradeable(queue.tokens[i]).safeTransfer(account, amt[i]);\n        }\n    }\n\n    /// Vest all RToken issuance in queue = queues[account], from queue.left to < endId\n    /// Fixes up queue.left and queue.right\n    /// @custom:interaction\n    // let iss = item(endId) - item(queue.left)\n    //     where item(0) = the zero item\n    //         | item(n) = issueQueues[account].items[n-1]\n    //\n    // checks:\n    //   queue.left <= endId <= queue.right\n    //   item(endId).when <= block.number + 1\n    //\n    //\n    //   (effect) ELIMINATE ISSUANCE SPAN: Set queue.left so that:\n    //     [queue'.left, queue'.right) intersect [queue.left, endId) == empty set\n    //     [queue'.left, queue'.right) union [queue.left, endId) == [queue.left, queue.right)\n    //     If [queue'.left, queue'.right) == empty set, then queue'.left == queue'.right == 0\n    //\n    //   (effect + action) COMPLETE ISSUANCE of iss:\n    //     for i in [0, iss.deposits.length):\n    //       issueQueues[account].erc20s[i].transfer(backingManager, iss.deposits[i]\n    //     _mint(account, iss.amtRToken)\n    function vestUpTo(address account, uint256 endId) private {\n        IssueQueue storage queue = issueQueues[account];\n        if (queue.left == endId) return;\n\n        require(queue.left <= endId && endId <= queue.right, \"out of range\");\n\n        // Vest the span up to `endId`.\n        uint256 amtRToken;\n        uint192 amtBaskets;\n        IssueItem storage rightItem = queue.items[endId - 1];\n        require(rightItem.when <= FIX_ONE_256 * block.number, \"issuance not ready\");\n\n        uint256 tokensLen = queue.tokens.length;\n        uint256[] memory amtDeposits = new uint256[](tokensLen);\n\n        // compute item(right - 1) - item(left - 1)\n        // we could dedup this logic for the zero item, but it would take more SLOADS\n        if (queue.left == 0) {\n            amtRToken = rightItem.amtRToken;\n            amtBaskets = rightItem.amtBaskets;\n            for (uint256 i = 0; i < tokensLen; ++i) {\n                amtDeposits[i] = rightItem.deposits[i];\n\n                // Decrement liabilities\n                liabilities[IERC20(queue.tokens[i])] -= amtDeposits[i];\n            }\n        } else {\n            IssueItem storage leftItem = queue.items[queue.left - 1];\n            amtRToken = rightItem.amtRToken - leftItem.amtRToken;\n            amtBaskets = rightItem.amtBaskets - leftItem.amtBaskets;\n            for (uint256 i = 0; i < tokensLen; ++i) {\n                amtDeposits[i] = rightItem.deposits[i] - leftItem.deposits[i];\n\n                // Decrement liabilities\n                liabilities[IERC20(queue.tokens[i])] -= amtDeposits[i];\n            }\n        }\n\n        emit BasketsNeededChanged(basketsNeeded, basketsNeeded + amtBaskets);\n        // uint192(+) is safe for Fix.plus()\n        basketsNeeded = basketsNeeded + amtBaskets;\n\n        emit Issuance(account, amtRToken, amtBaskets);\n        emit IssuancesCompleted(account, queue.left, endId, amtRToken);\n\n        if (endId == queue.right) {\n            // empty the queue - left is implicitly queue.left already\n            queue.left ="
    }
  ]
}