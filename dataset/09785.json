{
  "Title": "[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/WhitelistPeriodManager.sol#L178-L184\nhttps://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/WhitelistPeriodManager.sol#L115-L125\n\n\n# Vulnerability details\n\n## Impact\n\nThe `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is removed from the `isExcludedAddress` mapping. While this affects the enforcement of the cap limits and the `getMaxCommunityLpPositon()` function, the worst impact this has is that the address cannot have liquidity removed / transferred due to subtraction overflow.\n\nIn particular, users can be prevented from withdrawing their staked LP tokens from the liquidity farming contract should it become non-excluded.\n\n## Proof of Concept\n\n- Assume liquidity farming address `0xA` is excluded\n- Bob stakes his LP token\n- Liquidity farming contract is no longer to be excluded: `setIsExcludedAddressStatus([0xA, false])`\n- Bob attempts to withdraw liquidity â†’ reverts because `totalLiquidityByLp[USDC][0xA] = 0`, resulting in subtraction overflow.\n\n```jsx\n// insert test case in Withdraw test block of LiquidityFarming.tests.ts\nit.only('will brick withdrawals by no longer excluding farming contract', async () => {\n  await farmingContract.deposit(1, bob.address);\n  await wlpm.setIsExcludedAddressStatus([farmingContract.address], [false]);\n  await farmingContract.connect(bob).withdraw(1, bob.address);\n});\n\n// results in\n// Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)\n```\n\n## Recommended Mitigation Steps\n\nThe simplest way is to prevent exclusion removals.\n\n```jsx\nfunction setIsExcludedAddresses(address[] memory _addresses) external onlyOwner {\n  for (uint256 i = 0; i < _addresses.length; ++i) {\n    isExcludedAddress[_addresses[i]] = true;\n    // emit event\n    emit AddressExcluded(_addresses[i]);\n  }\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-biconomy-hyphen-20-contest",
  "Code": [
    {
      "filename": "contracts/hyphen/WhitelistPeriodManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\nimport \"./interfaces/ITokenManager.sol\";\nimport \"./interfaces/ILPToken.sol\";\n\ncontract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {\n    ILiquidityProviders private liquidityProviders;\n    ITokenManager private tokenManager;\n    ILPToken private lpToken;\n    bool public areWhiteListRestrictionsEnabled;\n\n    /* LP Status */\n    // EOA? -> status, stores addresses that we want to ignore, like staking contracts.\n    mapping(address => bool) public isExcludedAddress;\n    // Token -> TVL\n    mapping(address => uint256) private totalLiquidity;\n    // Token -> TVL\n    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;\n\n    /* Caps */\n    // Token Address -> Limit\n    mapping(address => uint256) public perTokenTotalCap;\n    // Token Address -> Limit\n    mapping(address => uint256) public perTokenWalletCap;\n\n    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);\n    event TotalCapUpdated(address indexed token, uint256 totalCap);\n    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);\n    event WhiteListStatusUpdated(bool status);\n\n    modifier onlyLiquidityPool() {\n        require(_msgSender() == address(liquidityProviders), \"ERR__UNAUTHORIZED\");\n        _;\n    }\n\n    modifier onlyLpNft() {\n        require(_msgSender() == address(lpToken), \"ERR__UNAUTHORIZED\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(_isSupportedToken(tokenAddress), \"Token not supported\");\n        _;\n    }\n\n    /**\n     * @dev initalizes the contract, acts as constructor\n     * @param _trustedForwarder address of trusted forwarder\n     */\n    function initialize(\n        address _trustedForwarder,\n        address _liquidityProviders,\n        address _tokenManager,\n        address _lpToken,\n        address _pauser\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        areWhiteListRestrictionsEnabled = true;\n        _setLiquidityProviders(_liquidityProviders);\n        _setTokenManager(_tokenManager);\n        _setLpToken(_lpToken);\n    }\n\n    function _isSupportedToken(address _token) internal view returns (bool) {\n        return tokenManager.getTokensInfo(_token).supportedToken;\n    }\n\n    /**\n     * @dev Internal Function which checks for various caps before allowing LP to add liqudity\n     */\n    function _beforeLiquidityAddition(\n        address _lp,\n        address _token,\n        uint256 _amount\n    ) internal {\n        if (isExcludedAddress[_lp]) {\n            return;\n        }\n        // Per Token Total Cap or PTTC\n        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), \"ERR__LIQUIDITY_EXCEEDS_PTTC\");\n        require(\n            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),\n            \"ERR__LIQUIDITY_EXCEEDS_PTWC\"\n        );\n        totalLiquidity[_token] += _amount;\n        totalLiquidityByLp[_token][_lp] += _amount;\n    }\n\n    /**\n     * @dev External Function which checks for various caps before allowing LP to add liqudity. Only callable by LiquidityPoolManager\n     */\n    function beforeLiquidityAddition(\n        address _lp,\n        address _token,\n        uint256 _amount\n    ) external onlyLiquidityPool whenNotPaused {\n        _beforeLiquidityAddition(_lp, _token, _amount);\n    }\n\n    /**\n     * @dev Internal Function which checks for various caps before allowing LP to remove liqudity\n     */\n    function _beforeLiquidityRemoval(\n        address _lp,\n        address _token,\n        uint256 _amount\n    ) internal {\n        if (isExcludedAddress[_lp]) {\n            return;\n        }\n        totalLiquidityByLp[_token][_lp] -= _amount;\n        totalLiquidity[_token] -= _amount;\n    }\n\n    /**\n     * @dev External Function which checks for various caps before allowing LP to remove liqudity. Only callable by LiquidityPoolManager\n     */\n    function beforeLiquidityRemoval(\n        address _lp,\n        address _token,\n        uint256 _amount\n    ) external onlyLiquidityPool whenNotPaused {\n        _beforeLiquidityRemoval(_lp, _token, _amount);\n    }\n\n    /**\n     * @dev External Function which checks for various caps before allowing LP to transfer their LpNFT. Only callable by LpNFT contract\n     */\n    function beforeLiquidityTransfer(\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount\n    ) external onlyLpNft whenNotPaused {\n        // Release limit from  _from\n        _beforeLiquidityRemoval(_from, _token, _amount);\n\n        // Block limit of _to\n        _beforeLiquidityAddition(_to, _token, _amount);\n    }\n\n    function _setTokenManager(address _tokenManager) internal {\n        tokenManager = ITokenManager(_tokenManager);\n    }\n\n    function setTokenManager(address _tokenManager) external onlyOwner {\n        _setTokenManager(_tokenManager);\n    }\n\n    function _setLiquidityProviders(address _liquidityProviders) internal {\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n    }\n\n    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {\n        _setLiquidityProviders(_liquidityProviders);\n    }\n\n    function _setLpToken(address _lpToken) internal {\n        lpToken = ILPToken(_lpToken);\n    }\n\n    function setLpToken(address _lpToken) external onlyOwner {\n        _setLpToken(_lpToken);\n    }\n\n    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {\n        require(_addresses.length == _status.length, \"ERR__LENGTH_MISMATCH\");\n        for (uint256 i = 0; i < _addresses.length; ++i) {\n            isExcludedAddress[_addresses[i]] = _status[i];\n            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);\n        }\n    }\n\n    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {\n        require(totalLiquidity[_token] <= _totalCap, \"ERR__TOTAL_CAP_LESS_THAN_SL\");\n        require(_totalCap >= perTokenWalletCap[_token], \"ERR__TOTAL_CAP_LT_PTWC\");\n        if (perTokenTotalCap[_token] != _totalCap) {\n            perTokenTotalCap[_token] = _totalCap;\n            emit TotalCapUpdated(_token, _totalCap);\n        }\n    }\n\n    /**\n     * @dev Special care must be taken when calling this function\n     *      There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it\n     *      should be >= max lp provided by an lp.\n     *      Checking this on chain will probably require implementing a bbst, which needs more bandwidth\n     *      Call the view function getMaxCommunityLpPositon() separately before changing this value\n     */\n    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {\n        require(_perTokenWalletCap <= perTokenTotalCap[_token], \"ERR__PWC_GT_PTTC\");\n        if (perTokenWalletCap[_token] != _perTokenWalletCap) {\n            perTokenWalletCap[_token] = _perTokenWalletCap;\n            emit PerTokenWalletCap(_token, _perTokenWalletCap);\n        }\n    }\n\n    function setCap(\n        address _token,\n        uint256 _totalCap,\n        uint256 _perTokenWalletCap\n    ) public onlyOwner {\n        setTotalCap(_token, _totalCap);\n        setPerTokenWalletCap(_token, _perTokenWalletCap);\n    }\n\n    function setCaps(\n        address[] memory _tokens,\n        uint256[] memory _totalCaps,\n        uint256[] memory _perTokenWalletCaps\n    ) external onlyOwner {\n        require(\n            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,\n            \"ERR__LENGTH_MISMACH\"\n        );\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);\n        }\n    }\n\n    /**\n     * @dev Enables (or disables) reverts if liquidity exceeds caps.\n     *      Even if this is disabled, the contract will continue to track LP's positions\n     */\n    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {\n        areWhiteListRestrictionsEnabled = _status;\n        emit WhiteListStatusUpdated(_status);\n    }\n\n    /**\n     * @dev Returns the maximum amount a single community LP has provided\n     */\n    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {\n        uint256 totalSupply = lpToken.totalSupply();\n        uint256 maxLp = 0;\n        for (uint256 i = 1; i <= totalSupply; ++i) {\n            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];\n            if (liquidity > maxLp) {\n                maxLp = liquidity;\n            }\n        }\n        return maxLp;\n    }\n\n    /**\n     * @dev returns the value of if (areWhiteListEnabled) then (_cond)\n     */\n    function ifEnabled(bool _cond) private view returns (bool) {\n        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);\n    }\n\n    /**\n     * @dev Meta-Transaction Helper, returns msgSender\n     */\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    /**\n     * @dev Meta-Transaction Helper, returns msgData\n     */\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n}"
    },
    {
      "filename": "contracts/hyphen/WhitelistPeriodManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\nimport \"./interfaces/ITokenManager.sol\";\nimport \"./interfaces/ILPToken.sol\";\n\ncontract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {\n    ILiquidityProviders private liquidityProviders;\n    ITokenManager private tokenManager;\n    ILPToken private lpToken;\n    bool public areWhiteListRestrictionsEnabled;\n\n    /* LP Status */\n    // EOA? -> status, stores addresses that we want to ignore, like staking contracts.\n    mapping(address => bool) public isExcludedAddress;\n    // Token -> TVL\n    mapping(address => uint256) private totalLiquidity;\n    // Token -> TVL\n    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;\n\n    /* Caps */\n    // Token Address -> Limit\n    mapping(address => uint256) public perTokenTotalCap;\n    // Token Address -> Limit\n    mapping(address => uint256) public perTokenWalletCap;\n\n    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);\n    event TotalCapUpdated(address indexed token, uint256 totalCap);\n    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);\n    event WhiteListStatusUpdated(bool status);\n\n    modifier onlyLiquidityPool() {\n        require(_msgSender() == address(liquidityProviders), \"ERR__UNAUTHORIZED\");\n        _;\n    }\n\n    modifier onlyLpNft() {\n        require(_msgSender() == address(lpToken), \"ERR__UNAUTHORIZED\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(_isSupportedToken(tokenAddress), \"Token not supported\");\n        _;\n    }\n\n    /**\n     * @dev initalizes the contract, acts as constructor\n     * @param _trustedForwarder address of trusted forwarder\n     */\n    function initialize(\n        address _trustedForwarder,\n        address _liquidityProviders,\n        address _tokenManager,\n        address _lpToken,\n        address _pauser\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        areWhiteListRestrictionsEnabled = true;\n        _setLiquidityProviders(_liquidityProviders);\n        _setTokenManager(_tokenManager);\n        _setLpToken(_lpToken);\n    }\n\n    function _isSupportedToken(address _token) internal view returns (bool) {\n        return tokenManager.getTokensInfo(_token).supportedToken;\n    }\n\n    /**\n     * @dev Internal Function which checks for various caps before allowing LP to add liqudity\n     */\n    function _beforeLiquidityAddition(\n        address _lp,\n        address _token,\n        uint256 _amount\n    ) internal {\n        if (isExcludedAddress[_lp]) {\n            return;\n        }\n        // Per Token Total Cap or PTTC\n        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), \"ERR__LIQUIDITY_EXCEEDS_PTTC\");\n        require(\n            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),\n            \"ERR__LIQUIDITY_EXCEEDS_PTWC\"\n        );\n        totalLiquidity[_token] += _amount;\n        totalLiquidityByLp[_token][_lp] += _amount;\n    }\n\n    /**\n     * @dev External Function which checks for various caps before allowing LP to add liqudity. Only callable by LiquidityPoolManager\n     */\n    function beforeLiquidityAddition(\n        address _lp,\n        address _token,\n        uint256 _amount\n    ) external onlyLiquidityPool whenNotPaused {\n        _beforeLiquidityAddition(_lp, _token, _amount);\n    }\n\n    /**\n     * @dev Internal Function which checks for various caps before allowing LP to remove liqudity\n     */\n    function _beforeLiquidityRemoval(\n        address _lp,\n        address _token,\n        uint256 _amount\n    ) internal {\n        if (isExcludedAddress[_lp]) {\n            return;\n        }\n        totalLiquidityByLp[_token][_lp] -= _amount;\n        totalLiquidity[_token] -= _amount;\n    }\n\n    /**\n     * @dev External Function which checks for various caps before allowing LP to remove liqudity. Only callable by LiquidityPoolManager\n     */\n    function beforeLiquidityRemoval(\n        address _lp,\n        address _token,\n        uint256 _amount\n    ) external onlyLiquidityPool whenNotPaused {\n        _beforeLiquidityRemoval(_lp, _token, _amount);\n    }\n\n    /**\n     * @dev External Function which checks for various caps before allowing LP to transfer their LpNFT. Only callable by LpNFT contract\n     */\n    function beforeLiquidityTransfer(\n        address _from,\n        address _to,\n        address _token,\n        uint256 _amount\n    ) external onlyLpNft whenNotPaused {\n        // Release limit from  _from\n        _beforeLiquidityRemoval(_from, _token, _amount);\n\n        // Block limit of _to\n        _beforeLiquidityAddition(_to, _token, _amount);\n    }\n\n    function _setTokenManager(address _tokenManager) internal {\n        tokenManager = ITokenManager(_tokenManager);\n    }\n\n    function setTokenManager(address _tokenManager) external onlyOwner {\n        _setTokenManager(_tokenManager);\n    }\n\n    function _setLiquidityProviders(address _liquidityProviders) internal {\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n    }\n\n    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {\n        _setLiquidityProviders(_liquidityProviders);\n    }\n\n    function _setLpToken(address _lpToken) internal {\n        lpToken = ILPToken(_lpToken);\n    }\n\n    function setLpToken(address _lpToken) external onlyOwner {\n        _setLpToken(_lpToken);\n    }\n\n    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {\n        require(_addresses.length == _status.length, \"ERR__LENGTH_MISMATCH\");\n        for (uint256 i = 0; i < _addresses.length; ++i) {\n            isExcludedAddress[_addresses[i]] = _status[i];\n            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);\n        }\n    }\n\n    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {\n        require(totalLiquidity[_token] <= _totalCap, \"ERR__TOTAL_CAP_LESS_THAN_SL\");\n        require(_totalCap >= perTokenWalletCap[_token], \"ERR__TOTAL_CAP_LT_PTWC\");\n        if (perTokenTotalCap[_token] != _totalCap) {\n            perTokenTotalCap[_token] = _totalCap;\n            emit TotalCapUpdated(_token, _totalCap);\n        }\n    }\n\n    /**\n     * @dev Special care must be taken when calling this function\n     *      There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it\n     *      should be >= max lp provided by an lp.\n     *      Checking this on chain will probably require implementing a bbst, which needs more bandwidth\n     *      Call the view function getMaxCommunityLpPositon() separately before changing this value\n     */\n    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {\n        require(_perTokenWalletCap <= perTokenTotalCap[_token], \"ERR__PWC_GT_PTTC\");\n        if (perTokenWalletCap[_token] != _perTokenWalletCap) {\n            perTokenWalletCap[_token] = _perTokenWalletCap;\n            emit PerTokenWalletCap(_token, _perTokenWalletCap);\n        }\n    }\n\n    function setCap(\n        address _token,\n        uint256 _totalCap,\n        uint256 _perTokenWalletCap\n    ) public onlyOwner {\n        setTotalCap(_token, _totalCap);\n        setPerTokenWalletCap(_token, _perTokenWalletCap);\n    }\n\n    function setCaps(\n        address[] memory _tokens,\n        uint256[] memory _totalCaps,\n        uint256[] memory _perTokenWalletCaps\n    ) external onlyOwner {\n        require(\n            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,\n            \"ERR__LENGTH_MISMACH\"\n        );\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);\n        }\n    }\n\n    /**\n     * @dev Enables (or disables) reverts if liquidity exceeds caps.\n     *      Even if this is disabled, the contract will continue to track LP's positions\n     */\n    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {\n        areWhiteListRestrictionsEnabled = _status;\n        emit WhiteListStatusUpdated(_status);\n    }\n\n    /**\n     * @dev Returns the maximum amount a single community LP has provided\n     */\n    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {\n        uint256 totalSupply = lpToken.totalSupply();\n        uint256 maxLp = 0;\n        for (uint256 i = 1; i <= totalSupply; ++i) {\n            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];\n            if (liquidity > maxLp) {\n                maxLp = liquidity;\n            }\n        }\n        return maxLp;\n    }\n\n    /**\n     * @dev returns the value of if (areWhiteListEnabled) then (_cond)\n     */\n    function ifEnabled(bool _cond) private view returns (bool) {\n        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);\n    }\n\n    /**\n     * @dev Meta-Transaction Helper, returns msgSender\n     */\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    /**\n     * @dev Meta-Transaction Helper, returns msgData\n     */\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n}"
    }
  ]
}