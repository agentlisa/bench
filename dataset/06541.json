{
  "Title": "[13] `require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\")` CAN BE REFACTORED INTO A MODIFIER TO BE USED IN CORRESPONDING FUNCTIONS",
  "Content": "`require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\")` is executed in both of the `SystemConfig.initialize` and `SystemConfig.setGasLimit` functions. For better code organization and maintainability, please consider refactoring, such as a `require` statement, into a modifier to be used in these functions.\n\nhttps://github.com/ethereum-optimism/optimism/blob/4a01d2750ea10ad1109ff643faea2d8cfb28013f/packages/contracts-bedrock/contracts/L1/SystemConfig.sol#L125-L143\n```solidity\n    function initialize(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner,\n        ResourceMetering.ResourceConfig memory _config\n    ) public initializer {\n        __Ownable_init();\n        transferOwnership(_owner);\n        overhead = _overhead;\n        scalar = _scalar;\n        batcherHash = _batcherHash;\n        gasLimit = _gasLimit;\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n        _setResourceConfig(_config);\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n    }\n```\n\nhttps://github.com/ethereum-optimism/optimism/blob/4a01d2750ea10ad1109ff643faea2d8cfb28013f/packages/contracts-bedrock/contracts/L1/SystemConfig.sol#L218-L224\n```solidity\n    function setGasLimit(uint64 _gasLimit) external onlyOwner {\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n        gasLimit = _gasLimit;\n\n        bytes memory data = abi.encode(_gasLimit);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_LIMIT, data);\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-base",
  "Code": [
    {
      "filename": "packages/contracts-bedrock/contracts/L1/SystemConfig.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\n\n/**\n * @title SystemConfig\n * @notice The SystemConfig contract is used to manage configuration of an Optimism network. All\n *         configuration is stored on L1 and picked up by L2 as part of the derviation of the L2\n *         chain.\n */\ncontract SystemConfig is OwnableUpgradeable, Semver {\n    /**\n     * @notice Enum representing different types of updates.\n     *\n     * @custom:value BATCHER              Represents an update to the batcher hash.\n     * @custom:value GAS_CONFIG           Represents an update to txn fee config on L2.\n     * @custom:value GAS_LIMIT            Represents an update to gas limit on L2.\n     * @custom:value UNSAFE_BLOCK_SIGNER  Represents an update to the signer key for unsafe\n     *                                    block distrubution.\n     */\n    enum UpdateType {\n        BATCHER,\n        GAS_CONFIG,\n        GAS_LIMIT,\n        UNSAFE_BLOCK_SIGNER\n    }\n\n    /**\n     * @notice Version identifier, used for upgrades.\n     */\n    uint256 public constant VERSION = 0;\n\n    /**\n     * @notice Storage slot that the unsafe block signer is stored at. Storing it at this\n     *         deterministic storage slot allows for decoupling the storage layout from the way\n     *         that `solc` lays out storage. The `op-node` uses a storage proof to fetch this value.\n     */\n    bytes32 public constant UNSAFE_BLOCK_SIGNER_SLOT = keccak256(\"systemconfig.unsafeblocksigner\");\n\n    /**\n     * @notice Fixed L2 gas overhead. Used as part of the L2 fee calculation.\n     */\n    uint256 public overhead;\n\n    /**\n     * @notice Dynamic L2 gas overhead. Used as part of the L2 fee calculation.\n     */\n    uint256 public scalar;\n\n    /**\n     * @notice Identifier for the batcher. For version 1 of this configuration, this is represented\n     *         as an address left-padded with zeros to 32 bytes.\n     */\n    bytes32 public batcherHash;\n\n    /**\n     * @notice L2 block gas limit.\n     */\n    uint64 public gasLimit;\n\n    /**\n     * @notice The configuration for the deposit fee market. Used by the OptimismPortal\n     *         to meter the cost of buying L2 gas on L1. Set as internal and wrapped with a getter\n     *         so that the struct is returned instead of a tuple.\n     */\n    ResourceMetering.ResourceConfig internal _resourceConfig;\n\n    /**\n     * @notice Emitted when configuration is updated\n     *\n     * @param version    SystemConfig version.\n     * @param updateType Type of update.\n     * @param data       Encoded update data.\n     */\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\n\n    /**\n     * @custom:semver 1.3.0\n     *\n     * @param _owner             Initial owner of the contract.\n     * @param _overhead          Initial overhead value.\n     * @param _scalar            Initial scalar value.\n     * @param _batcherHash       Initial batcher hash.\n     * @param _gasLimit          Initial gas limit.\n     * @param _unsafeBlockSigner Initial unsafe block signer address.\n     * @param _config            Initial resource config.\n     */\n    constructor(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner,\n        ResourceMetering.ResourceConfig memory _config\n    ) Semver(1, 3, 0) {\n        initialize({\n            _owner: _owner,\n            _overhead: _overhead,\n            _scalar: _scalar,\n            _batcherHash: _batcherHash,\n            _gasLimit: _gasLimit,\n            _unsafeBlockSigner: _unsafeBlockSigner,\n            _config: _config\n        });\n    }\n\n    /**\n     * @notice Initializer. The resource config must be set before the\n     *         require check.\n     *\n     * @param _owner             Initial owner of the contract.\n     * @param _overhead          Initial overhead value.\n     * @param _scalar            Initial scalar value.\n     * @param _batcherHash       Initial batcher hash.\n     * @param _gasLimit          Initial gas limit.\n     * @param _unsafeBlockSigner Initial unsafe block signer address.\n     * @param _config            Initial ResourceConfig.\n     */\n    function initialize(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner,\n        ResourceMetering.ResourceConfig memory _config\n    ) public initializer {\n        __Ownable_init();\n        transferOwnership(_owner);\n        overhead = _overhead;\n        scalar = _scalar;\n        batcherHash = _batcherHash;\n        gasLimit = _gasLimit;\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n        _setResourceConfig(_config);\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n    }\n\n    /**\n     * @notice Returns the minimum L2 gas limit that can be safely set for the system to\n     *         operate. The L2 gas limit must be larger than or equal to the amount of\n     *         gas that is allocated for deposits per block plus the amount of gas that\n     *         is allocated for the system transaction.\n     *         This function is used to determine if changes to parameters are safe.\n     *\n     * @return uint64\n     */\n    function minimumGasLimit() public view returns (uint64) {\n        return uint64(_resourceConfig.maxResourceLimit) + uint64(_resourceConfig.systemTxMaxGas);\n    }\n\n    /**\n     * @notice High level getter for the unsafe block signer address. Unsafe blocks can be\n     *         propagated across the p2p network if they are signed by the key corresponding to\n     *         this address.\n     *\n     * @return Address of the unsafe block signer.\n     */\n    // solhint-disable-next-line ordering\n    function unsafeBlockSigner() external view returns (address) {\n        address addr;\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            addr := sload(slot)\n        }\n        return addr;\n    }\n\n    /**\n     * @notice Updates the unsafe block signer address.\n     *\n     * @param _unsafeBlockSigner New unsafe block signer address.\n     */\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external onlyOwner {\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n\n        bytes memory data = abi.encode(_unsafeBlockSigner);\n        emit ConfigUpdate(VERSION, UpdateType.UNSAFE_BLOCK_SIGNER, data);\n    }\n\n    /**\n     * @notice Updates the batcher hash.\n     *\n     * @param _batcherHash New batcher hash.\n     */\n    function setBatcherHash(bytes32 _batcherHash) external onlyOwner {\n        batcherHash = _batcherHash;\n\n        bytes memory data = abi.encode(_batcherHash);\n        emit ConfigUpdate(VERSION, UpdateType.BATCHER, data);\n    }\n\n    /**\n     * @notice Updates gas config.\n     *\n     * @param _overhead New overhead value.\n     * @param _scalar   New scalar value.\n     */\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external onlyOwner {\n        overhead = _overhead;\n        scalar = _scalar;\n\n        bytes memory data = abi.encode(_overhead, _scalar);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_CONFIG, data);\n    }\n\n    /**\n     * @notice Updates the L2 gas limit.\n     *\n     * @param _gasLimit New gas limit.\n     */\n    function setGasLimit(uint64 _gasLimit) external onlyOwner {\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n        gasLimit = _gasLimit;\n\n        bytes memory data = abi.encode(_gasLimit);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_LIMIT, data);\n    }\n\n    /**\n     * @notice Low level setter for the unsafe block signer address. This function exists to\n     *         deduplicate code around storing the unsafeBlockSigner address in storage.\n     *\n     * @param _unsafeBlockSigner New unsafeBlockSigner value.\n     */\n    function _setUnsafeBlockSigner(address _unsafeBlockSigner) internal {\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            sstore(slot, _unsafeBlockSigner)\n        }\n    }\n\n    /**\n     * @notice A getter for the resource config. Ensures that the struct is\n     *         returned instead of a tuple.\n     *\n     * @return ResourceConfig\n     */\n    function resourceConfig() external view returns (ResourceMetering.ResourceConfig memory) {\n        return _resourceConfig;\n    }\n\n    /**\n     * @notice An external setter for the resource config. In the future, this\n     *         method may emit an event that the `op-node` picks up for when the\n     *         resource config is changed.\n     *\n     * @param _config The new resource config values.\n     */\n    function setResourceConfig(ResourceMetering.ResourceConfig memory _config) external onlyOwner {\n        _setResourceConfig(_config);\n    }\n\n    /**\n     * @notice An internal setter for the resource config. Ensures that the\n     *         config is sane before storing it by checking for invariants.\n     *\n     * @param _config The new resource config.\n     */\n    function _setResourceConfig(ResourceMetering.ResourceConfig memory _config) internal {\n        // Min base fee must be less than or equal to max base fee.\n        require(\n            _config.minimumBaseFee <= _config.maximumBaseFee,\n            \"SystemConfig: min base fee must be less than max base\"\n        );\n        // Base fee change denominator must be greater than 1.\n        require(\n            _config.baseFeeMaxChangeDenominator > 1,\n            \"SystemConfig: denominator must be larger than 1\"\n        );\n        // Max resource limit plus system tx gas must be less than or equal to the L2 gas limit.\n        // The gas limit must be increased before these values can be increased.\n        require(\n            _config.maxResourceLimit + _config.systemTxMaxGas <= gasLimit,\n            \"SystemConfig: gas limit too low\"\n        );\n        // Elasticity multiplier must be greater than 0.\n        require(\n            _config.elasticityMultiplier > 0,\n            \"SystemConfig: elasticity multiplier cannot be 0\"\n        );\n        // No precision loss when computing target resource limit.\n        require(\n            ((_config.maxResourceLimit / _config.elasticityMultiplier) *\n                _config.elasticityMultiplier) == _config.maxResourceLimit,\n            \"SystemConfig: precision loss with target resource limit\"\n        );\n\n        _resourceConfig = _config;\n    }\n}"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/L1/SystemConfig.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\n\n/**\n * @title SystemConfig\n * @notice The SystemConfig contract is used to manage configuration of an Optimism network. All\n *         configuration is stored on L1 and picked up by L2 as part of the derviation of the L2\n *         chain.\n */\ncontract SystemConfig is OwnableUpgradeable, Semver {\n    /**\n     * @notice Enum representing different types of updates.\n     *\n     * @custom:value BATCHER              Represents an update to the batcher hash.\n     * @custom:value GAS_CONFIG           Represents an update to txn fee config on L2.\n     * @custom:value GAS_LIMIT            Represents an update to gas limit on L2.\n     * @custom:value UNSAFE_BLOCK_SIGNER  Represents an update to the signer key for unsafe\n     *                                    block distrubution.\n     */\n    enum UpdateType {\n        BATCHER,\n        GAS_CONFIG,\n        GAS_LIMIT,\n        UNSAFE_BLOCK_SIGNER\n    }\n\n    /**\n     * @notice Version identifier, used for upgrades.\n     */\n    uint256 public constant VERSION = 0;\n\n    /**\n     * @notice Storage slot that the unsafe block signer is stored at. Storing it at this\n     *         deterministic storage slot allows for decoupling the storage layout from the way\n     *         that `solc` lays out storage. The `op-node` uses a storage proof to fetch this value.\n     */\n    bytes32 public constant UNSAFE_BLOCK_SIGNER_SLOT = keccak256(\"systemconfig.unsafeblocksigner\");\n\n    /**\n     * @notice Fixed L2 gas overhead. Used as part of the L2 fee calculation.\n     */\n    uint256 public overhead;\n\n    /**\n     * @notice Dynamic L2 gas overhead. Used as part of the L2 fee calculation.\n     */\n    uint256 public scalar;\n\n    /**\n     * @notice Identifier for the batcher. For version 1 of this configuration, this is represented\n     *         as an address left-padded with zeros to 32 bytes.\n     */\n    bytes32 public batcherHash;\n\n    /**\n     * @notice L2 block gas limit.\n     */\n    uint64 public gasLimit;\n\n    /**\n     * @notice The configuration for the deposit fee market. Used by the OptimismPortal\n     *         to meter the cost of buying L2 gas on L1. Set as internal and wrapped with a getter\n     *         so that the struct is returned instead of a tuple.\n     */\n    ResourceMetering.ResourceConfig internal _resourceConfig;\n\n    /**\n     * @notice Emitted when configuration is updated\n     *\n     * @param version    SystemConfig version.\n     * @param updateType Type of update.\n     * @param data       Encoded update data.\n     */\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\n\n    /**\n     * @custom:semver 1.3.0\n     *\n     * @param _owner             Initial owner of the contract.\n     * @param _overhead          Initial overhead value.\n     * @param _scalar            Initial scalar value.\n     * @param _batcherHash       Initial batcher hash.\n     * @param _gasLimit          Initial gas limit.\n     * @param _unsafeBlockSigner Initial unsafe block signer address.\n     * @param _config            Initial resource config.\n     */\n    constructor(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner,\n        ResourceMetering.ResourceConfig memory _config\n    ) Semver(1, 3, 0) {\n        initialize({\n            _owner: _owner,\n            _overhead: _overhead,\n            _scalar: _scalar,\n            _batcherHash: _batcherHash,\n            _gasLimit: _gasLimit,\n            _unsafeBlockSigner: _unsafeBlockSigner,\n            _config: _config\n        });\n    }\n\n    /**\n     * @notice Initializer. The resource config must be set before the\n     *         require check.\n     *\n     * @param _owner             Initial owner of the contract.\n     * @param _overhead          Initial overhead value.\n     * @param _scalar            Initial scalar value.\n     * @param _batcherHash       Initial batcher hash.\n     * @param _gasLimit          Initial gas limit.\n     * @param _unsafeBlockSigner Initial unsafe block signer address.\n     * @param _config            Initial ResourceConfig.\n     */\n    function initialize(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner,\n        ResourceMetering.ResourceConfig memory _config\n    ) public initializer {\n        __Ownable_init();\n        transferOwnership(_owner);\n        overhead = _overhead;\n        scalar = _scalar;\n        batcherHash = _batcherHash;\n        gasLimit = _gasLimit;\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n        _setResourceConfig(_config);\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n    }\n\n    /**\n     * @notice Returns the minimum L2 gas limit that can be safely set for the system to\n     *         operate. The L2 gas limit must be larger than or equal to the amount of\n     *         gas that is allocated for deposits per block plus the amount of gas that\n     *         is allocated for the system transaction.\n     *         This function is used to determine if changes to parameters are safe.\n     *\n     * @return uint64\n     */\n    function minimumGasLimit() public view returns (uint64) {\n        return uint64(_resourceConfig.maxResourceLimit) + uint64(_resourceConfig.systemTxMaxGas);\n    }\n\n    /**\n     * @notice High level getter for the unsafe block signer address. Unsafe blocks can be\n     *         propagated across the p2p network if they are signed by the key corresponding to\n     *         this address.\n     *\n     * @return Address of the unsafe block signer.\n     */\n    // solhint-disable-next-line ordering\n    function unsafeBlockSigner() external view returns (address) {\n        address addr;\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            addr := sload(slot)\n        }\n        return addr;\n    }\n\n    /**\n     * @notice Updates the unsafe block signer address.\n     *\n     * @param _unsafeBlockSigner New unsafe block signer address.\n     */\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external onlyOwner {\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n\n        bytes memory data = abi.encode(_unsafeBlockSigner);\n        emit ConfigUpdate(VERSION, UpdateType.UNSAFE_BLOCK_SIGNER, data);\n    }\n\n    /**\n     * @notice Updates the batcher hash.\n     *\n     * @param _batcherHash New batcher hash.\n     */\n    function setBatcherHash(bytes32 _batcherHash) external onlyOwner {\n        batcherHash = _batcherHash;\n\n        bytes memory data = abi.encode(_batcherHash);\n        emit ConfigUpdate(VERSION, UpdateType.BATCHER, data);\n    }\n\n    /**\n     * @notice Updates gas config.\n     *\n     * @param _overhead New overhead value.\n     * @param _scalar   New scalar value.\n     */\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external onlyOwner {\n        overhead = _overhead;\n        scalar = _scalar;\n\n        bytes memory data = abi.encode(_overhead, _scalar);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_CONFIG, data);\n    }\n\n    /**\n     * @notice Updates the L2 gas limit.\n     *\n     * @param _gasLimit New gas limit.\n     */\n    function setGasLimit(uint64 _gasLimit) external onlyOwner {\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n        gasLimit = _gasLimit;\n\n        bytes memory data = abi.encode(_gasLimit);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_LIMIT, data);\n    }\n\n    /**\n     * @notice Low level setter for the unsafe block signer address. This function exists to\n     *         deduplicate code around storing the unsafeBlockSigner address in storage.\n     *\n     * @param _unsafeBlockSigner New unsafeBlockSigner value.\n     */\n    function _setUnsafeBlockSigner(address _unsafeBlockSigner) internal {\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            sstore(slot, _unsafeBlockSigner)\n        }\n    }\n\n    /**\n     * @notice A getter for the resource config. Ensures that the struct is\n     *         returned instead of a tuple.\n     *\n     * @return ResourceConfig\n     */\n    function resourceConfig() external view returns (ResourceMetering.ResourceConfig memory) {\n        return _resourceConfig;\n    }\n\n    /**\n     * @notice An external setter for the resource config. In the future, this\n     *         method may emit an event that the `op-node` picks up for when the\n     *         resource config is changed.\n     *\n     * @param _config The new resource config values.\n     */\n    function setResourceConfig(ResourceMetering.ResourceConfig memory _config) external onlyOwner {\n        _setResourceConfig(_config);\n    }\n\n    /**\n     * @notice An internal setter for the resource config. Ensures that the\n     *         config is sane before storing it by checking for invariants.\n     *\n     * @param _config The new resource config.\n     */\n    function _setResourceConfig(ResourceMetering.ResourceConfig memory _config) internal {\n        // Min base fee must be less than or equal to max base fee.\n        require(\n            _config.minimumBaseFee <= _config.maximumBaseFee,\n            \"SystemConfig: min base fee must be less than max base\"\n        );\n        // Base fee change denominator must be greater than 1.\n        require(\n            _config.baseFeeMaxChangeDenominator > 1,\n            \"SystemConfig: denominator must be larger than 1\"\n        );\n        // Max resource limit plus system tx gas must be less than or equal to the L2 gas limit.\n        // The gas limit must be increased before these values can be increased.\n        require(\n            _config.maxResourceLimit + _config.systemTxMaxGas <= gasLimit,\n            \"SystemConfig: gas limit too low\"\n        );\n        // Elasticity multiplier must be greater than 0.\n        require(\n            _config.elasticityMultiplier > 0,\n            \"SystemConfig: elasticity multiplier cannot be 0\"\n        );\n        // No precision loss when computing target resource limit.\n        require(\n            ((_config.maxResourceLimit / _config.elasticityMultiplier) *\n                _config.elasticityMultiplier) == _config.maxResourceLimit,\n            \"SystemConfig: precision loss with target resource limit\"\n        );\n\n        _resourceConfig = _config;\n    }\n}"
    }
  ]
}