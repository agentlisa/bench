{
  "Title": "[H-03] Denial of Service by wrong `BatchRequests.removeAddress` logic",
  "Content": "_Submitted by 0x1f8b, also found by rfa, berndartmueller, BowTiedWardens, csanuragjain, Lambda, neumo, and StErMi_\n\n**Note: issues #[283](https://github.com/code-423n4/2022-06-yieldy-findings/issues/283), [115](https://github.com/code-423n4/2022-06-yieldy-findings/issues/115), [82](https://github.com/code-423n4/2022-06-yieldy-findings/issues/82), [89](https://github.com/code-423n4/2022-06-yieldy-findings/issues/89), [61](https://github.com/code-423n4/2022-06-yieldy-findings/issues/61), and [241](https://github.com/code-423n4/2022-06-yieldy-findings/issues/241) were originally broken out as a separate medium issue. Approximately 1 week after judging and awarding were finalized, the judging team re-assessed that these should have all been grouped under H-03. Accordingly, the 6 warden names have been added as submitters above.**\n\n<https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L93>\n\n<https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L57>\n\n<https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L37>\n\n### Impact\n\nThe `BatchRequests.removeAddress` logic is wrong and it will produce a denial of service.\n\n### Proof of Concept\n\nRemoving the element from the array is done using the `delete` statement, but this is not the proper way to remove an entry from an array, it will just set that position to `address(0)`.\n\nAppend dummy data:\n\n*   `addAddress('0x0000000000000000000000000000000000000001')`\n*   `addAddress('0x0000000000000000000000000000000000000002')`\n*   `addAddress('0x0000000000000000000000000000000000000003')`\n*   `getAddresses()` => `address[]: 0x0000000000000000000000000000000000000001,0x0000000000000000000000000000000000000002,0x0000000000000000000000000000000000000003`\n\nRemove address:\n\n*   `removeAddress(0x0000000000000000000000000000000000000002)` (or `0x0000000000000000000000000000000000000003`)\n*   `getAddresses()` => `address[]: 0x0000000000000000000000000000000000000001,0x0000000000000000000000000000000000000000,0x0000000000000000000000000000000000000003`\n\nService is denied because it will try to call `canBatchContracts`  to `address(0)`.\n\n### Recommended Mitigation Steps\n\n*   To remove an entry in an array you have to use `pop` and move the last element to the removed entry position.\n\n**[0xean (Yieldy) confirmed and resolved](https://github.com/code-423n4/2022-06-yieldy-findings/issues/38)** \n\n**[JasoonS (judge) commented](https://github.com/code-423n4/2022-06-yieldy-findings/issues/38#issuecomment-1199272074):**\n > Agree this is high, if the team (owner) didn't know this they could cause some issues for sure.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-06-yieldy-contest",
  "Code": [
    {
      "filename": "src/contracts/BatchRequests.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../structs/Batch.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BatchRequests is Ownable {\n    address[] public contracts;\n\n    /**\n        @notice sendWithdrawalRequests on all addresses in contracts\n     */\n    function sendWithdrawalRequests() external {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (\n                contracts[i] != address(0) &&\n                IStaking(contracts[i]).canBatchTransactions()\n            ) {\n                IStaking(contracts[i]).sendWithdrawalRequests();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n        @notice shows which contracts can batch\n        @return (address, bool)[]\n     */\n    function canBatchContracts() external view returns (Batch[] memory) {\n        uint256 contractsLength = contracts.length;\n        Batch[] memory batch = new Batch[](contractsLength);\n        for (uint256 i; i < contractsLength; ) {\n            bool canBatch = IStaking(contracts[i]).canBatchTransactions();\n            batch[i] = Batch(contracts[i], canBatch);\n            unchecked {\n                ++i;\n            }\n        }\n        return batch;\n    }\n\n    /**\n        @notice shows if contracts can batch by index\n        @return (address, bool)\n     */\n    function canBatchContractByIndex(uint256 _index)\n        external\n        view\n        returns (address, bool)\n    {\n        return (\n            contracts[_index],\n            IStaking(contracts[_index]).canBatchTransactions()\n        );\n    }\n\n    /**\n        @notice get address in contracts by index\n        @return address\n     */\n    function getAddressByIndex(uint256 _index) external view returns (address) {\n        return contracts[_index];\n    }\n\n    /**\n        @notice get addresses in contracts\n        @return address[]\n     */\n    function getAddresses() external view returns (address[] memory) {\n        return contracts;\n    }\n\n    /**\n        @notice add address to contracts array\n        @param _address - address to add\n     */\n    function addAddress(address _address) external onlyOwner {\n        contracts.push(_address);\n    }\n\n    /**\n        @notice remove address to contracts array\n        @param _address - address to remove\n     */\n    function removeAddress(address _address) external onlyOwner {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (contracts[i] == _address) {\n                delete contracts[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/contracts/BatchRequests.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../structs/Batch.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BatchRequests is Ownable {\n    address[] public contracts;\n\n    /**\n        @notice sendWithdrawalRequests on all addresses in contracts\n     */\n    function sendWithdrawalRequests() external {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (\n                contracts[i] != address(0) &&\n                IStaking(contracts[i]).canBatchTransactions()\n            ) {\n                IStaking(contracts[i]).sendWithdrawalRequests();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n        @notice shows which contracts can batch\n        @return (address, bool)[]\n     */\n    function canBatchContracts() external view returns (Batch[] memory) {\n        uint256 contractsLength = contracts.length;\n        Batch[] memory batch = new Batch[](contractsLength);\n        for (uint256 i; i < contractsLength; ) {\n            bool canBatch = IStaking(contracts[i]).canBatchTransactions();\n            batch[i] = Batch(contracts[i], canBatch);\n            unchecked {\n                ++i;\n            }\n        }\n        return batch;\n    }\n\n    /**\n        @notice shows if contracts can batch by index\n        @return (address, bool)\n     */\n    function canBatchContractByIndex(uint256 _index)\n        external\n        view\n        returns (address, bool)\n    {\n        return (\n            contracts[_index],\n            IStaking(contracts[_index]).canBatchTransactions()\n        );\n    }\n\n    /**\n        @notice get address in contracts by index\n        @return address\n     */\n    function getAddressByIndex(uint256 _index) external view returns (address) {\n        return contracts[_index];\n    }\n\n    /**\n        @notice get addresses in contracts\n        @return address[]\n     */\n    function getAddresses() external view returns (address[] memory) {\n        return contracts;\n    }\n\n    /**\n        @notice add address to contracts array\n        @param _address - address to add\n     */\n    function addAddress(address _address) external onlyOwner {\n        contracts.push(_address);\n    }\n\n    /**\n        @notice remove address to contracts array\n        @param _address - address to remove\n     */\n    function removeAddress(address _address) external onlyOwner {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (contracts[i] == _address) {\n                delete contracts[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/contracts/BatchRequests.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../structs/Batch.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BatchRequests is Ownable {\n    address[] public contracts;\n\n    /**\n        @notice sendWithdrawalRequests on all addresses in contracts\n     */\n    function sendWithdrawalRequests() external {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (\n                contracts[i] != address(0) &&\n                IStaking(contracts[i]).canBatchTransactions()\n            ) {\n                IStaking(contracts[i]).sendWithdrawalRequests();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n        @notice shows which contracts can batch\n        @return (address, bool)[]\n     */\n    function canBatchContracts() external view returns (Batch[] memory) {\n        uint256 contractsLength = contracts.length;\n        Batch[] memory batch = new Batch[](contractsLength);\n        for (uint256 i; i < contractsLength; ) {\n            bool canBatch = IStaking(contracts[i]).canBatchTransactions();\n            batch[i] = Batch(contracts[i], canBatch);\n            unchecked {\n                ++i;\n            }\n        }\n        return batch;\n    }\n\n    /**\n        @notice shows if contracts can batch by index\n        @return (address, bool)\n     */\n    function canBatchContractByIndex(uint256 _index)\n        external\n        view\n        returns (address, bool)\n    {\n        return (\n            contracts[_index],\n            IStaking(contracts[_index]).canBatchTransactions()\n        );\n    }\n\n    /**\n        @notice get address in contracts by index\n        @return address\n     */\n    function getAddressByIndex(uint256 _index) external view returns (address) {\n        return contracts[_index];\n    }\n\n    /**\n        @notice get addresses in contracts\n        @return address[]\n     */\n    function getAddresses() external view returns (address[] memory) {\n        return contracts;\n    }\n\n    /**\n        @notice add address to contracts array\n        @param _address - address to add\n     */\n    function addAddress(address _address) external onlyOwner {\n        contracts.push(_address);\n    }\n\n    /**\n        @notice remove address to contracts array\n        @param _address - address to remove\n     */\n    function removeAddress(address _address) external onlyOwner {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (contracts[i] == _address) {\n                delete contracts[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    }
  ]
}