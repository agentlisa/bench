{
  "Title": "[M-06] wrong out of range check",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/main/contracts/MerkleIdentity.sol#L124\nhttps://github.com/code-423n4/2022-05-factorydao/blob/main/contracts/MerkleIdentity.sol#L98\n\n\n# Vulnerability details\n\n```\nrequire(merkleIndex <= numTrees, 'merkleIndex out of range');\n```\nThis line checks that the index is valid.\nHowever, the trees start at index 1, therefore index 0 should fail this check, but it doesn't.\n\n\n## Recommended Mitigation Steps\nchange to:\n```\nrequire(merkleIndex <= numTrees && merkleIndex > 0, 'merkleIndex out of range');\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-factorydao-contest",
  "Code": [
    {
      "filename": "contracts/MerkleIdentity.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IVoterID.sol\";\nimport \"../interfaces/IPriceGate.sol\";\nimport \"../interfaces/IEligibility.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A generalized NFT minting system using merkle trees to pre-commit to metadata posted to ipfs\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissioned, it requires a treeAdder key to add trees\n/// @dev Merkle trees are used at this layer to prove the correctness of metadata added to newly minted NFTs\n/// @dev A single NFT contract may have many merkle trees with the same or different roots added here\n/// @dev Each tree added has a price gate (specifies price schedule) and an eligibility gate (specifies eligibility criteria)\n/// @dev Double minting of the same NFT is prevented by the NFT contract (VoterID)\ncontract MerkleIdentity {\n    using MerkleLib for bytes32;\n\n    // this represents a mint of a single NFT contract with a fixed price gate and eligibility gate\n    struct MerkleTree {\n        bytes32 metadataMerkleRoot;  // root of merkle tree whose leaves are uri strings to be assigned to minted NFTs\n        bytes32 ipfsHash; // ipfs hash of complete uri dataset, as redundancy so that merkle proof remain computable\n        address nftAddress; // address of NFT contract to be minted\n        address priceGateAddress;  // address price gate contract\n        address eligibilityAddress;  // address of eligibility gate contract\n        uint eligibilityIndex; // enables re-use of eligibility contracts\n        uint priceIndex; // enables re-use of price gate contracts\n    }\n\n    // array-like mapping of index to MerkleTree structs\n    mapping (uint => MerkleTree) public merkleTrees;\n    // count the trees\n    uint public numTrees;\n\n    // management key used to set ipfs hashes and treeAdder addresses\n    address public management;\n    // treeAdder is address that can add trees, separated from management to prevent switching it to a broken contract\n    address public treeAdder;\n\n    // every time a merkle tree is added\n    event MerkleTreeAdded(uint indexed index, address indexed nftAddress);\n\n    // simple call gate\n    modifier managementOnly() {\n        require (msg.sender == management, 'Only management may call this');\n        _;\n    }\n\n    /// @notice Whoever deploys the contract sets the two privileged keys\n    /// @param _mgmt key that will initially be both management and treeAdder\n    constructor(address _mgmt) {\n        management = _mgmt;\n        treeAdder = _mgmt;\n    }\n\n    /// @notice Change the management key\n    /// @dev Only the current management key can change this\n    /// @param newMgmt the new management key\n    function setManagement(address newMgmt) external managementOnly {\n        management = newMgmt;\n    }\n\n    /// @notice Change the treeAdder key\n    /// @dev Only the current management key can call this\n    /// @param newAdder new addres that will be able to add trees, old address will not be able to\n    function setTreeAdder(address newAdder) external managementOnly {\n        treeAdder = newAdder;\n    }\n\n    /// @notice Set the ipfs hash of a specific tree\n    /// @dev Only the current management key can call this\n    /// @param merkleIndex which merkle tree are we talking about?\n    /// @param hash the new ipfs hash summarizing this dataset, written as bytes32 omitting the first 2 bytes \"Qm\"\n    function setIpfsHash(uint merkleIndex, bytes32 hash) external managementOnly {\n        MerkleTree storage tree = merkleTrees[merkleIndex];\n        tree.ipfsHash = hash;\n    }\n\n    /// @notice Create a new merkle tree, opening a mint to an existing contract\n    /// @dev Only treeAdder can call this\n    /// @param metadataMerkleRoot merkle root of the complete metadata set represented as mintable by this tree\n    /// @param ipfsHash ipfs hash of complete dataset (note that you can post hash here without posting to network aka \"submarining\"\n    /// @param nftAddress address of NFT contract to be minted (must conform to IVoterID interface)\n    /// @param priceGateAddress address of price gate contract (must conform to IPriceGate interface)\n    /// @param eligibilityAddress address of eligibility gate contract (must conform to IEligibility interface)\n    /// @param eligibilityIndex index passed to eligibility gate, which in general will have many gates, to select which parameters\n    /// @param priceIndex index passed to price gate to select which parameters to use\n    function addMerkleTree(\n        bytes32 metadataMerkleRoot,\n        bytes32 ipfsHash,\n        address nftAddress,\n        address priceGateAddress,\n        address eligibilityAddress,\n        uint eligibilityIndex,\n        uint priceIndex) external {\n        require(msg.sender == treeAdder, 'Only treeAdder can add trees');\n        MerkleTree storage tree = merkleTrees[++numTrees];\n        tree.metadataMerkleRoot = metadataMerkleRoot;\n        tree.ipfsHash = ipfsHash;\n        tree.nftAddress = nftAddress;\n        tree.priceGateAddress = priceGateAddress;\n        tree.eligibilityAddress = eligibilityAddress;\n        tree.eligibilityIndex = eligibilityIndex;\n        tree.priceIndex = priceIndex;\n        emit MerkleTreeAdded(numTrees, nftAddress);\n    }\n\n    /// @notice Mint a new NFT\n    /// @dev Anyone may call this, but they must pass thru the two gates\n    /// @param merkleIndex which merkle tree are we withdrawing the NFT from?\n    /// @param tokenId the id number of the NFT to be minted, this data is bound to the uri in each leaf of the metadata merkle tree\n    /// @param uri the metadata uri that will be associated with the minted NFT\n    /// @param addressProof merkle proof proving the presence of msg.sender's address in an eligibility merkle tree\n    /// @param metadataProof sequence of hashes from leaf hash (tokenID, uri) to merkle root, proving data validity\n    function withdraw(uint merkleIndex, uint tokenId, string memory uri, bytes32[] memory addressProof, bytes32[] memory metadataProof) external payable {\n        MerkleTree storage tree = merkleTrees[merkleIndex];\n        IVoterID id = IVoterID(tree.nftAddress);\n\n        // mint an identity first, this keeps the token-collision gas cost down\n        id.createIdentityFor(msg.sender, tokenId, uri);\n\n        // check that the merkle index is real\n        require(merkleIndex <= numTrees, 'merkleIndex out of range');\n\n        // verify that the metadata is real\n        require(verifyMetadata(tree.metadataMerkleRoot, tokenId, uri, metadataProof), \"The metadata proof could not be verified\");\n\n        // check eligibility of address\n        IEligibility(tree.eligibilityAddress).passThruGate(tree.eligibilityIndex, msg.sender, addressProof);\n\n        // check that the price is right\n        IPriceGate(tree.priceGateAddress).passThruGate{value: msg.value}(tree.priceIndex, msg.sender);\n\n    }\n\n    /// @notice Get the current price for minting an NFT from a particular tree\n    /// @dev This does not take tokenId as an argument, if you want different tokenIds to have different prices, use different trees\n    /// @return ethCost the cost in wei of minting an NFT (could represent token cost if price gate takes tokens)\n    function getPrice(uint merkleIndex) public view returns (uint) {\n        MerkleTree memory tree = merkleTrees[merkleIndex];\n        uint ethCost = IPriceGate(tree.priceGateAddress).getCost(tree.priceIndex);\n        return ethCost;\n    }\n\n    /// @notice Is the given address eligibile to mint from the given tree\n    /// @dev If the eligibility gate does not use merkle trees, the proof can be left empty or used for anything else\n    /// @param merkleIndex which tree are we talking about?\n    /// @param recipient the address about which we are querying eligibility\n    /// @param proof merkle proof linking recipient to eligibility merkle root\n    /// @return eligibility true if recipient is currently eligible\n    function isEligible(uint merkleIndex, address recipient, bytes32[] memory proof) public view returns (bool) {\n        MerkleTree memory tree = merkleTrees[merkleIndex];\n        return IEligibility(tree.eligibilityAddress).isEligible(tree.eligibilityIndex, recipient, proof);\n    }\n\n    /// @notice Is the provided metadata included in tree?\n    /// @dev This is public for interfaces, called internally by withdraw function\n    /// @param root merkle root (proof destination)\n    /// @param tokenId index of NFT being queried\n    /// @param uri intended uri of NFT being minted\n    /// @param proof sequence of hashes linking leaf data to merkle root\n    function verifyMetadata(bytes32 root, uint tokenId, string memory uri, bytes32[] memory proof) public pure returns (bool) {\n        bytes32 leaf = keccak256(abi.encode(tokenId, uri));\n        return root.verifyProof(leaf, proof);\n    }\n\n}"
    },
    {
      "filename": "contracts/MerkleIdentity.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IVoterID.sol\";\nimport \"../interfaces/IPriceGate.sol\";\nimport \"../interfaces/IEligibility.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A generalized NFT minting system using merkle trees to pre-commit to metadata posted to ipfs\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissioned, it requires a treeAdder key to add trees\n/// @dev Merkle trees are used at this layer to prove the correctness of metadata added to newly minted NFTs\n/// @dev A single NFT contract may have many merkle trees with the same or different roots added here\n/// @dev Each tree added has a price gate (specifies price schedule) and an eligibility gate (specifies eligibility criteria)\n/// @dev Double minting of the same NFT is prevented by the NFT contract (VoterID)\ncontract MerkleIdentity {\n    using MerkleLib for bytes32;\n\n    // this represents a mint of a single NFT contract with a fixed price gate and eligibility gate\n    struct MerkleTree {\n        bytes32 metadataMerkleRoot;  // root of merkle tree whose leaves are uri strings to be assigned to minted NFTs\n        bytes32 ipfsHash; // ipfs hash of complete uri dataset, as redundancy so that merkle proof remain computable\n        address nftAddress; // address of NFT contract to be minted\n        address priceGateAddress;  // address price gate contract\n        address eligibilityAddress;  // address of eligibility gate contract\n        uint eligibilityIndex; // enables re-use of eligibility contracts\n        uint priceIndex; // enables re-use of price gate contracts\n    }\n\n    // array-like mapping of index to MerkleTree structs\n    mapping (uint => MerkleTree) public merkleTrees;\n    // count the trees\n    uint public numTrees;\n\n    // management key used to set ipfs hashes and treeAdder addresses\n    address public management;\n    // treeAdder is address that can add trees, separated from management to prevent switching it to a broken contract\n    address public treeAdder;\n\n    // every time a merkle tree is added\n    event MerkleTreeAdded(uint indexed index, address indexed nftAddress);\n\n    // simple call gate\n    modifier managementOnly() {\n        require (msg.sender == management, 'Only management may call this');\n        _;\n    }\n\n    /// @notice Whoever deploys the contract sets the two privileged keys\n    /// @param _mgmt key that will initially be both management and treeAdder\n    constructor(address _mgmt) {\n        management = _mgmt;\n        treeAdder = _mgmt;\n    }\n\n    /// @notice Change the management key\n    /// @dev Only the current management key can change this\n    /// @param newMgmt the new management key\n    function setManagement(address newMgmt) external managementOnly {\n        management = newMgmt;\n    }\n\n    /// @notice Change the treeAdder key\n    /// @dev Only the current management key can call this\n    /// @param newAdder new addres that will be able to add trees, old address will not be able to\n    function setTreeAdder(address newAdder) external managementOnly {\n        treeAdder = newAdder;\n    }\n\n    /// @notice Set the ipfs hash of a specific tree\n    /// @dev Only the current management key can call this\n    /// @param merkleIndex which merkle tree are we talking about?\n    /// @param hash the new ipfs hash summarizing this dataset, written as bytes32 omitting the first 2 bytes \"Qm\"\n    function setIpfsHash(uint merkleIndex, bytes32 hash) external managementOnly {\n        MerkleTree storage tree = merkleTrees[merkleIndex];\n        tree.ipfsHash = hash;\n    }\n\n    /// @notice Create a new merkle tree, opening a mint to an existing contract\n    /// @dev Only treeAdder can call this\n    /// @param metadataMerkleRoot merkle root of the complete metadata set represented as mintable by this tree\n    /// @param ipfsHash ipfs hash of complete dataset (note that you can post hash here without posting to network aka \"submarining\"\n    /// @param nftAddress address of NFT contract to be minted (must conform to IVoterID interface)\n    /// @param priceGateAddress address of price gate contract (must conform to IPriceGate interface)\n    /// @param eligibilityAddress address of eligibility gate contract (must conform to IEligibility interface)\n    /// @param eligibilityIndex index passed to eligibility gate, which in general will have many gates, to select which parameters\n    /// @param priceIndex index passed to price gate to select which parameters to use\n    function addMerkleTree(\n        bytes32 metadataMerkleRoot,\n        bytes32 ipfsHash,\n        address nftAddress,\n        address priceGateAddress,\n        address eligibilityAddress,\n        uint eligibilityIndex,\n        uint priceIndex) external {\n        require(msg.sender == treeAdder, 'Only treeAdder can add trees');\n        MerkleTree storage tree = merkleTrees[++numTrees];\n        tree.metadataMerkleRoot = metadataMerkleRoot;\n        tree.ipfsHash = ipfsHash;\n        tree.nftAddress = nftAddress;\n        tree.priceGateAddress = priceGateAddress;\n        tree.eligibilityAddress = eligibilityAddress;\n        tree.eligibilityIndex = eligibilityIndex;\n        tree.priceIndex = priceIndex;\n        emit MerkleTreeAdded(numTrees, nftAddress);\n    }\n\n    /// @notice Mint a new NFT\n    /// @dev Anyone may call this, but they must pass thru the two gates\n    /// @param merkleIndex which merkle tree are we withdrawing the NFT from?\n    /// @param tokenId the id number of the NFT to be minted, this data is bound to the uri in each leaf of the metadata merkle tree\n    /// @param uri the metadata uri that will be associated with the minted NFT\n    /// @param addressProof merkle proof proving the presence of msg.sender's address in an eligibility merkle tree\n    /// @param metadataProof sequence of hashes from leaf hash (tokenID, uri) to merkle root, proving data validity\n    function withdraw(uint merkleIndex, uint tokenId, string memory uri, bytes32[] memory addressProof, bytes32[] memory metadataProof) external payable {\n        MerkleTree storage tree = merkleTrees[merkleIndex];\n        IVoterID id = IVoterID(tree.nftAddress);\n\n        // mint an identity first, this keeps the token-collision gas cost down\n        id.createIdentityFor(msg.sender, tokenId, uri);\n\n        // check that the merkle index is real\n        require(merkleIndex <= numTrees, 'merkleIndex out of range');\n\n        // verify that the metadata is real\n        require(verifyMetadata(tree.metadataMerkleRoot, tokenId, uri, metadataProof), \"The metadata proof could not be verified\");\n\n        // check eligibility of address\n        IEligibility(tree.eligibilityAddress).passThruGate(tree.eligibilityIndex, msg.sender, addressProof);\n\n        // check that the price is right\n        IPriceGate(tree.priceGateAddress).passThruGate{value: msg.value}(tree.priceIndex, msg.sender);\n\n    }\n\n    /// @notice Get the current price for minting an NFT from a particular tree\n    /// @dev This does not take tokenId as an argument, if you want different tokenIds to have different prices, use different trees\n    /// @return ethCost the cost in wei of minting an NFT (could represent token cost if price gate takes tokens)\n    function getPrice(uint merkleIndex) public view returns (uint) {\n        MerkleTree memory tree = merkleTrees[merkleIndex];\n        uint ethCost = IPriceGate(tree.priceGateAddress).getCost(tree.priceIndex);\n        return ethCost;\n    }\n\n    /// @notice Is the given address eligibile to mint from the given tree\n    /// @dev If the eligibility gate does not use merkle trees, the proof can be left empty or used for anything else\n    /// @param merkleIndex which tree are we talking about?\n    /// @param recipient the address about which we are querying eligibility\n    /// @param proof merkle proof linking recipient to eligibility merkle root\n    /// @return eligibility true if recipient is currently eligible\n    function isEligible(uint merkleIndex, address recipient, bytes32[] memory proof) public view returns (bool) {\n        MerkleTree memory tree = merkleTrees[merkleIndex];\n        return IEligibility(tree.eligibilityAddress).isEligible(tree.eligibilityIndex, recipient, proof);\n    }\n\n    /// @notice Is the provided metadata included in tree?\n    /// @dev This is public for interfaces, called internally by withdraw function\n    /// @param root merkle root (proof destination)\n    /// @param tokenId index of NFT being queried\n    /// @param uri intended uri of NFT being minted\n    /// @param proof sequence of hashes linking leaf data to merkle root\n    function verifyMetadata(bytes32 root, uint tokenId, string memory uri, bytes32[] memory proof) public pure returns (bool) {\n        bytes32 leaf = keccak256(abi.encode(tokenId, uri));\n        return root.verifyProof(leaf, proof);\n    }\n\n}"
    }
  ]
}