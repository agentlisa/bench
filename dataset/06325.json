{
  "Title": "[G-07] Use Assembly To Check ForÂ `address(0)`",
  "Content": "\nIt's generally more gas-efficient to use assembly to check for a zero address (`address(0)`) than to use the `==` operator.\n\nThe reason for this is that the `==` operator generates additional instructions in the EVM bytecode, which can increase the gas cost of your contract. By using assembly, you can perform the zero address check more efficiently and reduce the overall gas cost of your contract.\n\nHere's an example of how you can use assembly to check for a zero address:\n\n```\ncontract MyContract {\n    function isZeroAddress(address addr) public pure returns (bool) {\n        uint256 addrInt = uint256(addr);\n        \n        assembly {\n            // Load the zero address into memory\n            let zero := mload(0x00)\n            \n            // Compare the address to the zero address\n            let isZero := eq(addrInt, zero)\n            \n            // Return the result\n            mstore(0x00, isZero)\n            return(0, 0x20)\n        }\n    }\n}\n```\nIn the above example, we have a function `isZeroAddress` that takes an address as input and returns a boolean value, indicating whether the address is equal to the zero address. Inside the function, we convert the address to an integer using `uint256(addr)`, and then use `assembly` to compare the integer to the zero address.\n\nBy using `assembly` to perform the zero address check, we can make our code more gas-efficient and reduce the overall cost of our contract. It's important to note that `assembly` can be more difficult to read and maintain than Solidity code, so it should be used with caution and only when necessary\n\n<details>\n\n```solidity\nFile: /ERC725/blob/v5.1.0/implementations/contracts/ERC725.sol\n28   newOwner != address(0),\n```\nhttps://github.com/ERC725Alliance/ERC725/blob/v5.1.0/implementations/contracts/ERC725.sol#L28\n\n```solidity\nFile: /ERC725/blob/v5.1.0/implementations/contracts/ERC725InitAbstract\n28   newOwner != address(0),\n```\nhttps://github.com/ERC725Alliance/ERC725/blob/v5.1.0/implementations/contracts/ERC725InitAbstract.sol\n\n```solidity\nFile: /ERC725/blob/v5.1.0/implementations/contracts/ERC725X.sol\n22    newOwner != address(0),\n```\nhttps://github.com/ERC725Alliance/ERC725/blob/v5.1.0/implementations/contracts/ERC725X.sol#L22\n\n```solidity\nFile: /ERC725/blob/v5.1.0/implementations/contracts/ERC725XCore.sol\n89   if (target != address(0))\n\n96   if (target != address(0))\n\n296  if (contractAddress == address(0)) {\n```\nhttps://github.com/ERC725Alliance/ERC725/blob/v5.1.0/implementations/contracts/ERC725XCore.sol#L89\n\n```solidity\nFile: /ERC725/blob/v5.1.0/implementations/contracts/ERC725XInitAbstract.sol\n21    newOwner != address(0),\n```\nhttps://github.com/ERC725Alliance/ERC725/blob/v5.1.0/implementations/contracts/ERC725XInitAbstract.sol#L21\n\n```solidity\nFile: /ERC725/blob/v5.1.0/implementations/contracts/ERC725Y.sol\n23    newOwner != address(0),\n```\nhttps://github.com/ERC725Alliance/ERC725/blob/v5.1.0/implementations/contracts/ERC725Y.sol#L23\n\n```solidity\nFile: /ERC725/blob/v5.1.0/implementations/contracts/ERC725YInitAbstract.sol\n21    newOwner != address(0),\n```\nhttps://github.com/ERC725Alliance/ERC725/blob/v5.1.0/implementations/contracts/ERC725YInitAbstract.sol#L21\n\n```solidity\nFile: /contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol\n801   if (msg.sig == bytes4(0) && extension == address(0)) return;\n\n804   if (extension == address(0))\n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol#L801\n\n```solidity\n19   if (target_ == address(0)) revert InvalidLSP6Target();\n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP6KeyManager/LSP6KeyManager.sol#L19\n\n```solidity\nFile: /contracts/LSP6KeyManager/LSP6KeyManagerInitAbstract.sol\n21    if (target_ == address(0)) revert InvalidLSP6Target();\n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP6KeyManager/LSP6KeyManagerInitAbstract.sol#L21\n\n```solidity\nFile: /contracts/LSP7DigitalAsset/LSP7DigitalAssetCore.sol\n268   if (operator == address(0)) {\n\n300   if (to == address(0)) {\n\n343   if (from == address(0)) {\n\n406   if (from == address(0) || to == address(0)) {            \n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP7DigitalAsset/LSP7DigitalAssetCore.sol#L268\n\n```solidity\nFile: /contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8Enumerable.sol\n36   if (from == address(0)) {\n\n40   } else if (to == address(0)) {    \n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8Enumerable.sol#L36\n\n```solidity\nFile: /contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8EnumerableInitAbstract.sol\n38    if (from == address(0)) {\n\n42    } else if (to == address(0)) {    \n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8EnumerableInitAbstract.sol#L38\n\n```solidity\nFile: /contracts/LSP8IdentifiableDigitalAsset/LSP8IdentifiableDigitalAssetCore.sol\n84   if (tokenOwner == address(0)) {\n\n115  if (operator == address(0)) {\n\n139  if (operator == address(0)) {\n\n319  if (to == address(0)) {\n\n410  if (to == address(0)) {                \n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP8IdentifiableDigitalAsset/LSP8IdentifiableDigitalAssetCore.sol#L84\n\n```solidity\nFile: \n50   if (erc165Extension == address(0)) return false;\n\n91   if (extension == address(0))\n```\nhttps://github.com/code-423n4/2023-06-lukso/tree/main/contracts/LSP17ContractExtension/LSP17Extendable.sol#L50\n\n```solidity\nFile: /ERC725/blob/v5.1.0/implementations/contracts/custom/OwnableUnset.sol\n51    newOwner != address(0),\n```\nhttps://github.com/ERC725Alliance/ERC725/blob/v5.1.0/implementations/contracts/custom/OwnableUnset.sol#L51\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "implementations/contracts/ERC725.sol",
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n// modules\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {OwnableUnset} from \"./custom/OwnableUnset.sol\";\nimport {ERC725XCore} from \"./ERC725XCore.sol\";\nimport {ERC725YCore} from \"./ERC725YCore.sol\";\n\n// constants\nimport {_INTERFACEID_ERC725X, _INTERFACEID_ERC725Y} from \"./constants.sol\";\n\n/**\n * @title ERC725 bundle\n * @author Fabian Vogelsteller <fabian@lukso.network>\n * @dev Bundles ERC725X and ERC725Y together into one smart contract\n */\ncontract ERC725 is ERC725XCore, ERC725YCore {\n    /**\n     * @notice Sets the owner of the contract\n     * @param newOwner the owner of the contract\n     */\n    constructor(address newOwner) {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        OwnableUnset._setOwner(newOwner);\n    }\n\n    // NOTE this implementation has not by default: receive() external payable {}\n\n    /**\n     * @inheritdoc ERC165\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC725XCore, ERC725YCore)\n        returns (bool)\n    {\n        return\n            interfaceId == _INTERFACEID_ERC725X ||\n            interfaceId == _INTERFACEID_ERC725Y ||\n            super.supportsInterface(interfaceId);\n    }\n}"
    },
    {
      "filename": "implementations/contracts/ERC725X.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// modules\nimport {OwnableUnset} from \"./custom/OwnableUnset.sol\";\nimport {ERC725XCore} from \"./ERC725XCore.sol\";\n\n/**\n * @title ERC725 X executor\n * @author Fabian Vogelsteller <fabian@lukso.network>\n * @dev Implementation of a contract module which provides the ability to call arbitrary functions at any other smart contract and itself,\n * including using `delegatecall`, `staticcall` as well creating contracts using `create` and `create2`\n * This is the basis for a smart contract based account system, but could also be used as a proxy account system\n */\ncontract ERC725X is ERC725XCore {\n    /**\n     * @notice Sets the owner of the contract\n     * @param newOwner the owner of the contract\n     */\n    constructor(address newOwner) {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        OwnableUnset._setOwner(newOwner);\n    }\n}"
    },
    {
      "filename": "implementations/contracts/ERC725XCore.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC725X} from \"./interfaces/IERC725X.sol\";\n\n// libraries\nimport {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\n// modules\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {OwnableUnset} from \"./custom/OwnableUnset.sol\";\n\n// constants\nimport {\n    _INTERFACEID_ERC725X,\n    OPERATION_0_CALL,\n    OPERATION_1_CREATE,\n    OPERATION_2_CREATE2,\n    OPERATION_3_STATICCALL,\n    OPERATION_4_DELEGATECALL\n} from \"./constants.sol\";\n\nimport \"./errors.sol\";\n\n/**\n * @title Core implementation of ERC725X executor\n * @author Fabian Vogelsteller <fabian@lukso.network>\n * @dev Implementation of a contract module which provides the ability to call arbitrary functions at any other smart contract and itself,\n * including using `delegatecall`, `staticcall` as well creating contracts using `create` and `create2`\n * This is the basis for a smart contract based account system, but could also be used as a proxy account system\n */\nabstract contract ERC725XCore is OwnableUnset, ERC165, IERC725X {\n    /**\n     * @inheritdoc IERC725X\n     */\n    function execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) public payable virtual override onlyOwner returns (bytes memory) {\n        return _execute(operationType, target, value, data);\n    }\n\n    /**\n     * @inheritdoc IERC725X\n     */\n    function executeBatch(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) public payable virtual override onlyOwner returns (bytes[] memory) {\n        return _executeBatch(operationsType, targets, values, datas);\n    }\n\n    /**\n     * @inheritdoc ERC165\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == _INTERFACEID_ERC725X || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev check the `operationType` provided and perform the associated low-level opcode.\n     * see `IERC725X.execute(uint256,address,uint256,bytes)`.\n     */\n    function _execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) internal virtual returns (bytes memory) {\n        // CALL\n        if (operationType == OPERATION_0_CALL) {\n            return _executeCall(target, value, data);\n        }\n\n        // Deploy with CREATE\n        if (operationType == OPERATION_1_CREATE) {\n            if (target != address(0)) revert ERC725X_CreateOperationsRequireEmptyRecipientAddress();\n            return _deployCreate(value, data);\n        }\n\n        // Deploy with CREATE2\n        if (operationType == OPERATION_2_CREATE2) {\n            if (target != address(0)) revert ERC725X_CreateOperationsRequireEmptyRecipientAddress();\n            return _deployCreate2(value, data);\n        }\n\n        // STATICCALL\n        if (operationType == OPERATION_3_STATICCALL) {\n            if (value != 0) revert ERC725X_MsgValueDisallowedInStaticCall();\n            return _executeStaticCall(target, data);\n        }\n\n        // DELEGATECALL\n        //\n        // WARNING! delegatecall is a dangerous operation type! use with EXTRA CAUTION\n        //\n        // delegate allows to call another deployed contract and use its functions\n        // to update the state of the current calling contract.\n        //\n        // this can lead to unexpected behaviour on the contract storage, such as:\n        // - updating any state variables (even if these are protected)\n        // - update the contract owner\n        // - run selfdestruct in the context of this contract\n        //\n        if (operationType == OPERATION_4_DELEGATECALL) {\n            if (value != 0) revert ERC725X_MsgValueDisallowedInDelegateCall();\n            return _executeDelegateCall(target, data);\n        }\n\n        revert ERC725X_UnknownOperationType(operationType);\n    }\n\n    /**\n     * @dev same as `_execute` but for batch execution\n     * see `IERC725X,execute(uint256[],address[],uint256[],bytes[])`\n     */\n    function _executeBatch(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) internal virtual returns (bytes[] memory) {\n        if (\n            operationsType.length != targets.length ||\n            (targets.length != values.length || values.length != datas.length)\n        ) {\n            revert ERC725X_ExecuteParametersLengthMismatch();\n        }\n\n        if (operationsType.length == 0) {\n            revert ERC725X_ExecuteParametersEmptyArray();\n        }\n\n        bytes[] memory result = new bytes[](operationsType.length);\n\n        for (uint256 i = 0; i < operationsType.length; ) {\n            result[i] = _execute(operationsType[i], targets[i], values[i], datas[i]);\n\n            // Increment the iterator in unchecked block to save gas\n            unchecked {\n                ++i;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev perform low-level call (operation type = 0)\n     * @param target The address on which call is executed\n     * @param value The value to be sent with the call\n     * @param data The data to be sent with the call\n     * @return result The data from the call\n     */\n    function _executeCall(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        if (address(this).balance < value) {\n            revert ERC725X_InsufficientBalance(address(this).balance, value);\n        }\n\n        emit Executed(OPERATION_0_CALL, target, value, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: value}(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev perform low-level staticcall (operation type = 3)\n     * @param target The address on which staticcall is executed\n     * @param data The data to be sent with the staticcall\n     * @return result The data returned from the staticcall\n     */\n    function _executeStaticCall(\n        address target,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        emit Executed(OPERATION_3_STATICCALL, target, 0, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.staticcall(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev perform low-level delegatecall (operation type = 4)\n     * @param target The address on which delegatecall is executed\n     * @param data The data to be sent with the delegatecall\n     * @return result The data returned from the delegatecall\n     */\n    function _executeDelegateCall(\n        address target,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        emit Executed(OPERATION_4_DELEGATECALL, target, 0, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.delegatecall(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev deploy a contract using the CREATE opcode (operation type = 1)\n     * @param value The value to be sent to the contract created\n     * @param creationCode The contract creation bytecode to deploy appended with the constructor argument(s)\n     * @return newContract The address of the contract created as bytes\n     */\n    function _deployCreate(\n        uint256 value,\n        bytes memory creationCode\n    ) internal virtual returns (bytes memory newContract) {\n        if (address(this).balance < value) {\n            revert ERC725X_InsufficientBalance(address(this).balance, value);\n        }\n\n        if (creationCode.length == 0) {\n            revert ERC725X_NoContractBytecodeProvided();\n        }\n\n        address contractAddress;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractAddress := create(value, add(creationCode, 0x20), mload(creationCode))\n        }\n\n        if (contractAddress == address(0)) {\n            revert ERC725X_ContractDeploymentFailed();\n        }\n\n        newContract = abi.encodePacked(contractAddress);\n        emit ContractCreated(OPERATION_1_CREATE, contractAddress, value, bytes32(0));\n    }\n\n    /**\n     * @dev deploy a contract using the CREATE2 opcode (operation type = 2)\n     * @param value The value to be sent to the contract created\n     * @param creationCode The contract creation bytecode to deploy appended with the constructor argument(s) and a bytes32 salt\n     * @return newContract The address of the contract created as bytes\n     */\n    function _deployCreate2(\n        uint256 value,\n        bytes memory creationCode\n    ) internal virtual returns (bytes memory newContract) {\n        if (creationCode.length == 0) {\n            revert ERC725X_NoContractBytecodeProvided();\n        }\n\n        bytes32 salt = BytesLib.toBytes32(creationCode, creationCode.length - 32);\n        bytes memory bytecode = BytesLib.slice(creationCode, 0, creationCode.length - 32);\n        address contractAddress = Create2.deploy(value, salt, bytecode);\n\n        newContract = abi.encodePacked(contractAddress);\n        emit ContractCreated(OPERATION_2_CREATE2, contractAddress, value, salt);\n    }\n}"
    },
    {
      "filename": "implementations/contracts/ERC725XInitAbstract.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// modules\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUnset} from \"./custom/OwnableUnset.sol\";\nimport {ERC725XCore} from \"./ERC725XCore.sol\";\n\n/**\n * @title Inheritable Proxy Implementation of ERC725 X Executor\n * @author Fabian Vogelsteller <fabian@lukso.network>\n * @dev Implementation of a contract module which provides the ability to call arbitrary functions at any other smart contract and itself,\n * including using `delegatecall`, `staticcall` as well creating contracts using `create` and `create2`\n * This is the basis for a smart contract based account system, but could also be used as a proxy account system\n */\nabstract contract ERC725XInitAbstract is Initializable, ERC725XCore {\n    function _initialize(address newOwner)\n        internal\n        virtual\n        onlyInitializing\n    {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        OwnableUnset._setOwner(newOwner);\n    }\n}"
    },
    {
      "filename": "implementations/contracts/ERC725Y.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// modules\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {OwnableUnset} from \"./custom/OwnableUnset.sol\";\nimport {ERC725YCore} from \"./ERC725YCore.sol\";\n\n/**\n * @title ERC725Y General data key/value store\n * @author Fabian Vogelsteller <fabian@lukso.network>\n * @dev Contract module which provides the ability to set arbitrary data key/value pairs that can be changed over time\n * It is intended to standardise certain data key/value pairs to allow automated read and writes\n * from/to the contract storage\n */\ncontract ERC725Y is ERC725YCore {\n    /**\n     * @notice Sets the owner of the contract\n     * @param newOwner the owner of the contract\n     */\n    constructor(address newOwner) {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        OwnableUnset._setOwner(newOwner);\n    }\n}"
    },
    {
      "filename": "implementations/contracts/ERC725YInitAbstract.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// modules\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUnset} from \"./custom/OwnableUnset.sol\";\nimport {ERC725YCore} from \"./ERC725YCore.sol\";\n\n/**\n * @title Inheritable Proxy Implementation of ERC725Y General data key/value store\n * @author Fabian Vogelsteller <fabian@lukso.network>\n * @dev Contract module which provides the ability to set arbitrary data key/value pairs that can be changed over time\n * It is intended to standardise certain data key/value pairs to allow automated read and writes\n * from/to the contract storage\n */\nabstract contract ERC725YInitAbstract is Initializable, ERC725YCore {\n    function _initialize(address newOwner)\n        internal\n        virtual\n        onlyInitializing\n    {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        OwnableUnset._setOwner(newOwner);\n    }\n}"
    },
    {
      "filename": "implementations/contracts/custom/OwnableUnset.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OwnableUnset\n * @dev modified version of OpenZeppelin implementation, where:\n * - _setOwner(address) function is internal, so this function can be used in constructor\n * of contracts implementation (instead of using transferOwnership(address)\n * - the contract does not inherit from Context contract\n */\nabstract contract OwnableUnset {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Changes the owner if `newOwner` and oldOwner are different\n     * This pattern is useful in inheritance.\n     */\n    function _setOwner(address newOwner) internal virtual {\n        if (newOwner != owner()) {\n            address oldOwner = _owner;\n            _owner = newOwner;\n            emit OwnershipTransferred(oldOwner, newOwner);\n        }\n    }\n}"
    }
  ]
}