{
  "Title": "M-18: ChainlinkAdapterOracle use BTC/USD chainlink oracle to price WBTC which is problematic if WBTC depegs",
  "Content": "# Issue M-18: ChainlinkAdapterOracle use BTC/USD chainlink oracle to price WBTC which is problematic if WBTC depegs \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/9 \n\n## Found by \n0x52\n\n## Summary\n\nThe chainlink BTC/USD oracle is used to price WBTC ([docs](https://docs.blueberry.garden/lending-protocol/price-oracle#price-feed-alternative)). WBTC is basically a bridged asset and if the bridge is compromised/fails then WBTC will depeg and will no longer be equivalent to BTC. This will lead to large amounts of borrowing against an asset that is now effectively worthless. Since the protocol still values it via BTC/USD the protocol will not only be stuck with the bad debt caused by the currently outstanding loans but they will also continue to give out bad loans and increase the amount of bad debt further\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nProtocol will take on a large amount of bad debt should WBTC bridge become compromised and WBTC depegs\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/ChainlinkAdapterOracle.sol#L47-L59\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI would recommend using a double oracle setup. Use both the Chainlink and another on-chain liquidity base oracle (i.e. UniV3 TWAP). If the price of the on-chain liquidity oracle drops below a certain threshold of the Chainlink oracles (i.e. 2% lower), any borrowing should be immediately halted. The chainlink oracle will prevent price manipulation and the liquidity oracle will safeguard against the asset depegging.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/oracle/ChainlinkAdapterOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BaseAdapter.sol\";\nimport \"../utils/BlueBerryErrors.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/chainlink/IFeedRegistry.sol\";\n\ncontract ChainlinkAdapterOracle is IBaseOracle, BaseAdapter {\n    using SafeCast for int256;\n\n    // Chainlink denominations\n    // (source: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Denominations.sol)\n    IFeedRegistry public registry;\n    address public constant USD = address(840);\n\n    /// @dev Mapping from original token to remapped token for price querying (e.g. WBTC -> BTC, renBTC -> BTC)\n    mapping(address => address) public remappedTokens;\n\n    event SetRegistry(address registry);\n    event SetTokenRemapping(\n        address indexed token,\n        address indexed remappedToken\n    );\n\n    constructor(IFeedRegistry registry_) {\n        if (address(registry_) == address(0)) revert ZERO_ADDRESS();\n\n        registry = registry_;\n    }\n\n    /// @dev Set chainlink feed registry source\n    /// @param _registry Chainlink feed registry source\n    function setFeedRegistry(IFeedRegistry _registry) external onlyOwner {\n        if (address(_registry) == address(0)) revert ZERO_ADDRESS();\n        registry = _registry;\n        emit SetRegistry(address(_registry));\n    }\n\n    /// @dev Set token remapping\n    /// @param _tokens List of tokens to set remapping\n    /// @param _remappedTokens List of tokens to set remapping to\n    /// @notice Token decimals of the original and remapped tokens should be the same\n    function setTokenRemappings(\n        address[] calldata _tokens,\n        address[] calldata _remappedTokens\n    ) external onlyOwner {\n        if (_remappedTokens.length != _tokens.length)\n            revert INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < _tokens.length; idx++) {\n            if (_remappedTokens[idx] == address(0)) revert ZERO_ADDRESS();\n            if (_tokens[idx] == address(0)) revert ZERO_ADDRESS();\n            remappedTokens[_tokens[idx]] = _remappedTokens[idx];\n            emit SetTokenRemapping(_tokens[idx], _remappedTokens[idx]);\n        }\n    }\n\n    /**\n     * @notice Returns the USD based price of given token, price value has 18 decimals\n     * @param _token Token address to get price of\n     * @return price USD price of token in 18 decimal\n     */\n    function getPrice(address _token) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[_token];\n        if (token == address(0)) token = _token;\n\n        uint256 maxDelayTime = maxDelayTimes[token];\n        if (maxDelayTime == 0) revert NO_MAX_DELAY(_token);\n\n        // try to get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n\n        return (answer.toUint256() * 1e18) / 10**decimals;\n    }\n}"
    }
  ]
}