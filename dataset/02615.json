{
  "Title": "Refund can be over-credited in a negative yield event",
  "Content": "Deposits added to the queue are [point in time](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/libs/DepositQueueLib.sol#L22) stETH balance amounts. The stETH token balance rebases regularly to account for yield, and in the event of [slashing](https://docs.lido.fi/guides/steth-integration-guide/#risks), may be subject to a negative yield. In the event that a stETH token rebase is negative between the time a user deposits and calls for a [refund](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L334-L346), the vault will over credit the user by the rebase difference.\n\n\nConsider handling the deposits in the queue in [shares](https://docs.lido.fi/guides/steth-integration-guide/#steth-internals-share-mechanics) instead of balances to account for rebase changes on refunds.\n\n\n***Update:** Acknowledged, will not fix. Pods Finance team’s statement:*\n\n\n\n> *Although we agree with the issue, we won’t prioritize it right now because of timing. In case of a slashing event, we can refund the vault, transferring funds directly to the contract.*\n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libs/DepositQueueLib.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nlibrary DepositQueueLib {\n    struct DepositEntry {\n        address owner;\n        uint256 amount;\n    }\n\n    struct DepositQueue {\n        address[] list;\n        mapping(address => uint256) cache;\n        uint256 totalDeposited;\n    }\n\n    function push(DepositQueue storage queue, DepositEntry memory deposit) internal {\n        if (queue.cache[deposit.owner] == 0 && deposit.amount > 0) {\n            queue.list.push(deposit.owner);\n        }\n\n        queue.cache[deposit.owner] += deposit.amount;\n        queue.totalDeposited += deposit.amount;\n    }\n\n    function remove(\n        DepositQueue storage queue,\n        uint256 startIndex,\n        uint256 endIndex\n    ) internal {\n        if (endIndex > startIndex) {\n            address[] memory newList = new address[](queue.list.length - (endIndex - startIndex));\n            uint256 i = 0;\n            uint256 totalDeposited = queue.totalDeposited;\n\n            // Copying the skipped interval to the new array\n            while (i < startIndex) {\n                newList[i] = queue.list[i];\n                i++;\n            }\n\n            // Remove the interval from the cache\n            while (startIndex < endIndex) {\n                // No need to check, it can't go below 0\n                unchecked {\n                    totalDeposited -= queue.cache[queue.list[startIndex]];\n                }\n                queue.cache[queue.list[startIndex]] = 0;\n                startIndex++;\n            }\n\n            // Copying the rest of the list with the remaining entries\n            while (endIndex < queue.list.length) {\n                newList[i++] = queue.list[endIndex++];\n            }\n\n            queue.list = newList;\n            queue.totalDeposited = totalDeposited;\n        }\n    }\n\n    function get(DepositQueue storage queue, uint256 index) internal view returns (DepositEntry memory depositEntry) {\n        if (index < queue.list.length) {\n            address owner = queue.list[index];\n            depositEntry.owner = owner;\n            depositEntry.amount = queue.cache[owner];\n        }\n    }\n\n    function balanceOf(DepositQueue storage queue, address owner) internal view returns (uint256) {\n        return queue.cache[owner];\n    }\n\n    function size(DepositQueue storage queue) internal view returns (uint256) {\n        return queue.list.length;\n    }\n}"
    }
  ]
}