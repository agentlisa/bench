{
  "Title": "[M-02] _harvestCore() roi calculation error",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperStrategyGranarySupplyOnly.sol#L141\n\n\n# Vulnerability details\n\n## Impact\n_harvestCore() roi calculation error,may double\n\n## Proof of Concept\nThe _harvestCore() will calculate the roi and repayment values\nThe implementation code is as follows:\n```solidity\n    function _harvestCore(uint256 _debt) internal override returns (int256 roi, uint256 repayment) {\n        _claimRewards();\n        uint256 numSteps = steps.length;\n        for (uint256 i = 0; i < numSteps; i = i.uncheckedInc()) {\n            address[2] storage step = steps[i];\n            IERC20Upgradeable startToken = IERC20Upgradeable(step[0]);\n            uint256 amount = startToken.balanceOf(address(this));\n            if (amount == 0) {\n                continue;\n            }\n            _swapVelo(step[0], step[1], amount, VELO_ROUTER);\n        }\n\n        uint256 allocated = IVault(vault).strategies(address(this)).allocated;\n        uint256 totalAssets = balanceOf();\n        uint256 toFree = _debt;\n\n        if (totalAssets > allocated) {\n            uint256 profit = totalAssets - allocated;\n            toFree += profit;\n            roi = int256(profit);\n        } else if (totalAssets < allocated) {\n            roi = -int256(allocated - totalAssets);\n        }\n\n        (uint256 amountFreed, uint256 loss) = _liquidatePosition(toFree);\n        repayment = MathUpgradeable.min(_debt, amountFreed);\n        roi -= int256(loss);//<------这个地方可能会导致重复\n    }\n```\nThe last line may cause double counting of losses\nFor example, the current:\nvault.allocated = 9\nvault.strategy.allocBPS = 9000\nstrategy.totalAssets = 9\n\nSuppose that after some time, strategy loses 2, then:\nstrategy.totalAssets = 9 - 2 = 7\nAlso the administrator sets vault.strategy.allocBPS = 0\n\nThis executes harvest()->_harvestCore(9) to get\nroi = 4\nrepayment = 7\n\nThe actual loss of 2, but roi = 4 (double), test code as follows:\n\nadd to test/starter-test.js 'Vault Tests'\n\n```solidity\n    it.only('test_roi', async function () {\n      const {vault, strategy, wantHolder, strategist} = await loadFixture(deployVaultAndStrategyAndGetSigners);\n      const depositAmount = toWantUnit('10');\n      await vault.connect(wantHolder)['deposit(uint256)'](depositAmount);\n      await strategy.harvest();\n\n      const balanceOf = await strategy.balanceOf();\n      console.log(`strategy balanceOf: ${balanceOf}`);\n      // allocated = 9\n      // 1.loss 2, left 7\n      await strategy.lossFortest(toWantUnit('2'));\n      // 2.modify bps=>0\n      await vault.connect(strategist).updateStrategyAllocBPS(strategy.address, 0);\n      // 3.so debt = 9\n      await strategy.harvest();\n\n      const {allocated, losses, allocBPS} = await vault.strategies(strategy.address);\n      console.log(`losses: ${losses}`);\n      console.log(`allocated: ${allocated}`);\n      console.log(`allocBPS: ${allocBPS}`);\n    });\n\n```\nadd to ReaperStrategyGranarySupplyOnly.sol\n```solidity\n    function lossFortest(uint256 amout) external{\n        ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).withdraw(address(want), amout, address(1));        \n    }\n```\n\n```console\n$ npx hardhat test test/starter-test.js\n\n  Vaults\n    Vault Tests\nstrategy balanceOf: 900000000\nlosses: 400000000     <--------will double\nallocated: 0\nallocBPS: 0\n```\n\nThe last vault's allocated is correct, but the loss is wrong\nStatistics and bpsChange of _reportLoss() will be wrong\n\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\n\nremove ` roi -= int256(loss);`",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Vault/contracts/ReaperStrategyGranarySupplyOnly.sol",
      "content": "// SPDX-License-Identifier: BUSL1.1\n\npragma solidity ^0.8.0;\n\nimport \"./abstract/ReaperBaseStrategyv4.sol\";\nimport \"./interfaces/IAToken.sol\";\nimport \"./interfaces/IAaveProtocolDataProvider.sol\";\nimport \"./interfaces/ILendingPool.sol\";\nimport \"./interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"./interfaces/IRewardsController.sol\";\nimport \"./libraries/ReaperMathUtils.sol\";\nimport \"./mixins/VeloSolidMixin.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\n/**\n * @dev This strategy will deposit a token on Granary to maximize yield\n */\ncontract ReaperStrategyGranarySupplyOnly is ReaperBaseStrategyv4, VeloSolidMixin {\n    using ReaperMathUtils for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // 3rd-party contract addresses\n    address public constant VELO_ROUTER = 0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9;\n    ILendingPoolAddressesProvider public constant ADDRESSES_PROVIDER =\n        ILendingPoolAddressesProvider(0xdDE5dC81e40799750B92079723Da2acAF9e1C6D6);\n    IAaveProtocolDataProvider public constant DATA_PROVIDER =\n        IAaveProtocolDataProvider(0x9546F673eF71Ff666ae66d01Fd6E7C6Dae5a9995);\n    IRewardsController public constant REWARDER = IRewardsController(0x6A0406B8103Ec68EE9A713A073C7bD587c5e04aD);\n\n    // this strategy's configurable tokens\n    IAToken public gWant;\n\n    // Misc constants\n    uint16 private constant LENDER_REFERRAL_CODE_NONE = 0;\n\n    /**\n     * @dev Tokens Used:\n     * {rewardClaimingTokens} - Array containing gWant, used for claiming rewards\n     */\n    address[] public rewardClaimingTokens;\n\n    /**\n     * We break down the harvest logic into the following operations:\n     * 1. Claiming rewards\n     * 2. A series of swaps as required\n     * 3. Creating more of the strategy's underlying token, if necessary.\n     *\n     * #1 and #3 are specific to each protocol.\n     * #2 however is mostly the same across all strats. So to make things more generic, we\n     * will execute #2 by iterating through a series of pre-defined \"steps\".\n     *\n     * This array holds all the swapping operations in sequence.\n     * {ADMIN} role or higher will be able to set this array.\n     */\n    address[2][] public steps;\n\n    /**\n     * @dev Initializes the strategy. Sets parameters, saves routes, and gives allowances.\n     * @notice see documentation for each variable above its respective declaration.\n     */\n    function initialize(\n        address _vault,\n        address[] memory _strategists,\n        address[] memory _multisigRoles,\n        IAToken _gWant\n    ) public initializer {\n        gWant = _gWant;\n        want = _gWant.UNDERLYING_ASSET_ADDRESS();\n        __ReaperBaseStrategy_init(_vault, want, _strategists, _multisigRoles);\n        rewardClaimingTokens = [address(_gWant)];\n    }\n\n    function _adjustPosition(uint256 _debt) internal override {\n        if (emergencyExit) {\n            return;\n        }\n\n        uint256 wantBalance = balanceOfWant();\n        if (wantBalance > _debt) {\n            uint256 toReinvest = wantBalance - _debt;\n            _deposit(toReinvest);\n        }\n    }\n\n    function _liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 liquidatedAmount, uint256 loss)\n    {\n        uint256 wantBal = balanceOfWant();\n        if (wantBal < _amountNeeded) {\n            _withdraw(_amountNeeded - wantBal);\n            liquidatedAmount = balanceOfWant();\n        } else {\n            liquidatedAmount = _amountNeeded;\n        }\n\n        if (_amountNeeded > liquidatedAmount) {\n            loss = _amountNeeded - liquidatedAmount;\n        }\n    }\n\n    function _liquidateAllPositions() internal override returns (uint256 amountFreed) {\n        _withdrawUnderlying(balanceOfPool());\n        return balanceOfWant();\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and swapping rewards\n     *      to produce more want.\n     * @notice Assumes the deposit will take care of resupplying excess want.\n     */\n    function _harvestCore(uint256 _debt) internal override returns (int256 roi, uint256 repayment) {\n        _claimRewards();\n        uint256 numSteps = steps.length;\n        for (uint256 i = 0; i < numSteps; i = i.uncheckedInc()) {\n            address[2] storage step = steps[i];\n            IERC20Upgradeable startToken = IERC20Upgradeable(step[0]);\n            uint256 amount = startToken.balanceOf(address(this));\n            if (amount == 0) {\n                continue;\n            }\n            _swapVelo(step[0], step[1], amount, VELO_ROUTER);\n        }\n\n        uint256 allocated = IVault(vault).strategies(address(this)).allocated;\n        uint256 totalAssets = balanceOf();\n        uint256 toFree = _debt;\n\n        if (totalAssets > allocated) {\n            uint256 profit = totalAssets - allocated;\n            toFree += profit;\n            roi = int256(profit);\n        } else if (totalAssets < allocated) {\n            roi = -int256(allocated - totalAssets);\n        }\n\n        (uint256 amountFreed, uint256 loss) = _liquidatePosition(toFree);\n        repayment = MathUpgradeable.min(_debt, amountFreed);\n        roi -= int256(loss);\n    }\n\n    /**\n     * Only {STRATEGIST} or higher roles may update the swap path for a token.\n     */\n    function updateVeloSwapPath(\n        address _tokenIn,\n        address _tokenOut,\n        address[] calldata _path\n    ) external override {\n        _atLeastRole(STRATEGIST);\n        _updateVeloSwapPath(_tokenIn, _tokenOut, _path);\n    }\n\n    /**\n     * Only {ADMIN} or higher roles may set the array\n     * of steps executed as part of harvest.\n     */\n    function setHarvestSteps(address[2][] calldata _newSteps) external {\n        _atLeastRole(ADMIN);\n        delete steps;\n\n        uint256 numSteps = _newSteps.length;\n        for (uint256 i = 0; i < numSteps; i = i.uncheckedInc()) {\n            address[2] memory step = _newSteps[i];\n            require(step[0] != address(0));\n            require(step[1] != address(0));\n            steps.push(step);\n        }\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     */\n    function _deposit(uint256 toReinvest) internal {\n        if (toReinvest != 0) {\n            address lendingPoolAddress = ADDRESSES_PROVIDER.getLendingPool();\n            IERC20Upgradeable(want).safeIncreaseAllowance(lendingPoolAddress, toReinvest);\n            ILendingPool(lendingPoolAddress).deposit(want, toReinvest, address(this), LENDER_REFERRAL_CODE_NONE);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds from external contracts and brings them back to this contract.\n     */\n    function _withdraw(uint256 _amount) internal {\n        if (_amount != 0) {\n            _withdrawUnderlying(_amount);\n        }\n    }\n\n    /**\n     * @dev Attempts to Withdraw {_withdrawAmount} from pool. Withdraws max amount that can be\n     *      safely withdrawn if {_withdrawAmount} is too high.\n     */\n    function _withdrawUnderlying(uint256 _withdrawAmount) internal {\n        uint256 withdrawable = balanceOfPool();\n        _withdrawAmount = MathUpgradeable.min(_withdrawAmount, withdrawable);\n        ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).withdraw(address(want), _withdrawAmount, address(this));\n    }\n\n    /**\n     * @dev Claim rewards for supply.\n     */\n    function _claimRewards() internal {\n        IRewardsController(REWARDER).claimAllRewardsToSelf(rewardClaimingTokens);\n    }\n\n    /**\n     * @dev Attempts to safely withdraw {_amount} from the pool.\n     */\n    function authorizedWithdrawUnderlying(uint256 _amount) external {\n        _atLeastRole(STRATEGIST);\n        _withdrawUnderlying(_amount);\n    }\n\n    /**\n     * @dev Function to calculate the total {want} held by the strat.\n     * It takes into account both the funds in hand, plus the funds in the lendingPool.\n     */\n    function balanceOf() public view override returns (uint256) {\n        return balanceOfPool() + balanceOfWant();\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20Upgradeable(want).balanceOf(address(this));\n    }\n\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 supply, , , , , , , , ) = IAaveProtocolDataProvider(DATA_PROVIDER).getUserReserveData(\n            address(want),\n            address(this)\n        );\n        return supply;\n    }\n}"
    }
  ]
}