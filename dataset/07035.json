{
  "Title": "[L-04] Consider requiring strings `.length != 0`",
  "Content": "\nSeveral strings in the system are assigned once, without the ability to change it later on. Consider requiring that these are non-zero length to help ensure these have been assigned as expected.\n\n* [SubprotocolRegistry.register](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L84) accepts a `_name` parameter of any length. Although only one entry could be registered with an empty name, it may be odd or unexpected to have a subprotocol with an empty string.\n* [CidNFT.costructor](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L122) accepts a `_baseURI` parameter of any length which is then immutable. If this were not assigned then `tokenURI` would not work as expected.\n* [`name` and `symbol` in `CidNFT.constructor`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L126) are allowed to be empty in the solmate constructor, may consider adding 0 length checks for these as well.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-01-canto-identity-protocol-contest",
  "Code": [
    {
      "filename": "src/SubprotocolRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"./CidSubprotocolNFT.sol\";\n\n/// @title Subprotocol Registry\n/// @notice Enables registration of new subprotocols\ncontract SubprotocolRegistry {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee for registering a new subprotocol (100 $NOTE)\n    uint256 public constant REGISTER_FEE = 100 * 10**18;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public immutable note;\n\n    /// @notice Wallet that receives fees paid when registering\n    address public immutable cidFeeWallet;\n\n    /// @notice Data that is associated with a subprotocol.\n    /// @dev Data types are chosen such that all data fits in one slot\n    struct SubprotocolData {\n        /// @notice Owner (registrant) of the subprotocol\n        address owner;\n        /// @notice Optional cost in NOTE to add an NFT\n        /// @dev Maximum value is (2^96 - 1) / 10^18 =~ 80 billion. Zero for no fee\n        uint96 fee;\n        address nftAddress;\n        bool ordered;\n        bool primary;\n        bool active;\n    }\n\n    /// @notice Mapping (name => data) that contains all registered subprotocols\n    mapping(string => SubprotocolData) private subprotocols;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event SubprotocolRegistered(\n        address indexed registrar,\n        string indexed name,\n        address indexed nftAddress,\n        bool ordered,\n        bool primary,\n        bool active,\n        uint96 fee\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error SubprotocolAlreadyExists(string name, address owner);\n    error NoTypeSpecified(string name);\n    error NotASubprotocolNFT(address nftAddress);\n\n    /// @notice Sets the reference to the $NOTE contract\n    /// @param _noteContract Address of the $NOTE contract\n    /// @param _cidFeeWallet Address of the wallet that receives the fees\n    constructor(address _noteContract, address _cidFeeWallet) {\n        note = ERC20(_noteContract);\n        cidFeeWallet = _cidFeeWallet;\n    }\n\n    /// @notice Register a new subprotocol. There is a 100 $NOTE fee when registering\n    /// @dev The options ordered, primary, active are not mutually exclusive. In practice, only one will be set for most subprotocols,\n    /// but if a subprotocol for instance supports int keys (mapped to one value) and a list of active NFTs, ordered and active is true.\n    /// @param _ordered Ordering allows integers to be used as map keys, to one and only one value\n    /// @param _primary Primary maps string keys to zero or one value\n    /// @param _active Subprotocols that have a list of a active NFTs\n    /// @param _name Name of the subprotocol, has to be unique\n    /// @param _nftAddress Address of the subprotocol NFT. Has to adhere to the CidSubprotocolNFT interface\n    /// @param _fee Fee (in $NOTE) for minting a new token of the subprotocol. Set to 0 if there is no fee. 10% is subtracted from this fee as a CID fee\n    function register(\n        bool _ordered,\n        bool _primary,\n        bool _active,\n        address _nftAddress,\n        string calldata _name,\n        uint96 _fee\n    ) external {\n        SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, REGISTER_FEE);\n        if (!(_ordered || _primary || _active)) revert NoTypeSpecified(_name);\n        SubprotocolData memory subprotocolData = subprotocols[_name];\n        if (subprotocolData.owner != address(0)) revert SubprotocolAlreadyExists(_name, subprotocolData.owner);\n        subprotocolData.owner = msg.sender;\n        subprotocolData.fee = _fee;\n        if (!ERC721(_nftAddress).supportsInterface(type(CidSubprotocolNFT).interfaceId))\n            revert NotASubprotocolNFT(_nftAddress);\n        subprotocolData.nftAddress = _nftAddress;\n        subprotocolData.ordered = _ordered;\n        subprotocolData.primary = _primary;\n        subprotocolData.active = _active;\n        subprotocols[_name] = subprotocolData;\n        emit SubprotocolRegistered(msg.sender, _name, _nftAddress, _ordered, _primary, _active, _fee);\n    }\n\n    /// @notice Getter function to retrieve subprotocol data\n    /// @param _name Name of the subprotocol to query\n    /// @return subprotocolData stored under _name. owner will be set to address(0) if subprotocol does not exist\n    function getSubprotocol(string calldata _name) external view returns (SubprotocolData memory) {\n        return subprotocols[_name];\n    }\n}"
    },
    {
      "filename": "src/CidNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"./SubprotocolRegistry.sol\";\n\n/// @title Canto Identity Protocol NFT\n/// @notice CID NFTs are at the heart of the CID protocol. All key/values of subprotocols are associated with them.\ncontract CidNFT is ERC721, ERC721TokenReceiver {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee (in BPS) that is charged for every mint (as a percentage of the mint fee). Fixed at 10%.\n    uint256 public constant CID_FEE_BPS = 1_000;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Wallet that receives CID fees\n    address public immutable cidFeeWallet;\n\n    /// @notice Reference to the NOTE TOKEN\n    ERC20 public immutable note;\n\n    /// @notice Reference to the subprotocol registry\n    SubprotocolRegistry public immutable subprotocolRegistry;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Base URI of the NFT\n    string public baseURI;\n\n    /// @notice Array of uint256 values (NFT IDs) with additional position information NFT ID => (array pos. + 1)\n    struct IndexedArray {\n        uint256[] values;\n        mapping(uint256 => uint256) positions;\n    }\n\n    /// @notice Data that is associated with a CID NFT -> subprotocol combination\n    struct SubprotocolData {\n        /// @notice Mapping for ordered type\n        mapping(uint256 => uint256) ordered;\n        /// @notice Value for primary type\n        uint256 primary;\n        /// @notice List for active type\n        IndexedArray active;\n    }\n\n    /// @notice The different types of associations between CID NFTs and subprotocol NFTs\n    enum AssociationType {\n        /// @notice key => NFT mapping\n        ORDERED,\n        /// @notice Zero or one NFT\n        PRIMARY,\n        /// @notice List of NFTs\n        ACTIVE\n    }\n\n    /// @notice Counter of the minted NFTs\n    /// @dev Used to assign a new unique ID. The first ID that is assigned is 1, ID 0 is never minted.\n    uint256 public numMinted;\n\n    /// @notice Stores the references to subprotocol NFTs. Mapping nftID => subprotocol name => subprotocol data\n    mapping(uint256 => mapping(string => SubprotocolData)) internal cidData;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event OrderedDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataAdded(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 subprotocolNFTID,\n        uint256 arrayIndex\n    );\n    event OrderedDataRemoved(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error AddCallAfterMintingFailed(uint256 index);\n    error SubprotocolDoesNotExist(string subprotocolName);\n    error NFTIDZeroDisallowedForSubprotocols();\n    error AssociationTypeNotSupportedForSubprotocol(AssociationType associationType, string subprotocolName);\n    error NotAuthorizedForCIDNFT(address caller, uint256 cidNFTID, address cidNFTOwner);\n    error NotAuthorizedForSubprotocolNFT(address caller, uint256 subprotocolNFTID);\n    error ActiveArrayAlreadyContainsID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);\n    error OrderedValueNotSet(uint256 cidNFTID, string subprotocolName, uint256 key);\n    error PrimaryValueNotSet(uint256 cidNFTID, string subprotocolName);\n    error ActiveArrayDoesNotContainID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToRemove);\n\n    /// @notice Sets the name, symbol, baseURI, and the address of the auction factory\n    /// @param _name Name of the NFT\n    /// @param _symbol Symbol of the NFT\n    /// @param _baseURI NFT base URI. {id}.json is appended to this URI\n    /// @param _cidFeeWallet Address of the wallet that receives the fees\n    /// @param _noteContract Address of the $NOTE contract\n    /// @param _subprotocolRegistry Address of the subprotocol registry\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _baseURI,\n        address _cidFeeWallet,\n        address _noteContract,\n        address _subprotocolRegistry\n    ) ERC721(_name, _symbol) {\n        baseURI = _baseURI;\n        cidFeeWallet = _cidFeeWallet;\n        note = ERC20(_noteContract);\n        subprotocolRegistry = SubprotocolRegistry(_subprotocolRegistry);\n    }\n\n    /// @notice Get the token URI for the provided ID\n    /// @param _id ID to retrieve the URI for\n    /// @return tokenURI The URI of the queried token (path to a JSON file)\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (ownerOf[_id] == address(0))\n            // According to ERC721, this revert for non-existing tokens is required\n            revert TokenNotMinted(_id);\n        return string(abi.encodePacked(baseURI, _id, \".json\"));\n    }\n\n    /// @notice Mint a new CID NFT\n    /// @dev An address can mint multiple CID NFTs, but it can only set one as associated with it in the AddressRegistry\n    /// @param _addList An optional list of encoded parameters for add to add subprotocol NFTs directly after minting.\n    /// The parameters should not include the function selector itself, the function select for add is always prepended.\n    function mint(bytes[] calldata _addList) external {\n        _mint(msg.sender, ++numMinted); // We do not use _safeMint here on purpose. If a contract calls this method, he expects to get an NFT back\n        bytes4 addSelector = this.add.selector;\n        for (uint256 i = 0; i < _addList.length; ++i) {\n            (\n                bool success, /*bytes memory result*/\n\n            ) = address(this).delegatecall(abi.encodePacked(addSelector, _addList[i]));\n            if (!success) revert AddCallAfterMintingFailed(i);\n        }\n    }\n\n    /// @notice Add a new entry for the given subprotocol to the provided CID NFT\n    /// @param _cidNFTID ID of the CID NFT to add the data to\n    /// @param _subprotocolName Name of the subprotocol where the data will be added. Has to exist.\n    /// @param _key Key to set. This value is only relevant for the AssociationType ORDERED (where a mapping int => nft ID is stored)\n    /// @param _nftIDToAdd The ID of the NFT to add\n    /// @param _type Association type (see AssociationType struct) to use for this data\n    function add(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key,\n        uint256 _nftIDToAdd,\n        AssociationType _type\n    ) external {\n        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(\n            _subprotocolName\n        );\n        address subprotocolOwner = subprotocolData.owner;\n        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);\n        address cidNFTOwner = ownerOf[_cidNFTID];\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n        if (_nftIDToAdd == 0) revert NFTIDZeroDisallowedForSubprotocols(); // ID 0 is disallowed in subprotocols\n\n        // The CID Protocol safeguards the NFTs of subprotocols. Note that these NFTs are usually pointers to other data / NFTs (e.g., to an image NFT for profile pictures)\n        ERC721 nftToAdd = ERC721(subprotocolData.nftAddress);\n        nftToAdd.safeTransferFrom(msg.sender, address(this), _nftIDToAdd);\n        // Charge fee (subprotocol & CID fee) if configured\n        uint96 subprotocolFee = subprotocolData.fee;\n        if (subprotocolFee != 0) {\n            uint256 cidFee = (subprotocolFee * CID_FEE_BPS) / 10_000;\n            SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, cidFee);\n            SafeTransferLib.safeTransferFrom(note, msg.sender, subprotocolOwner, subprotocolFee - cidFee);\n        }\n        if (_type == AssociationType.ORDERED) {\n            if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].ordered[_key] != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, _key, 0, _type);\n            }\n            cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;\n            emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\n        } else if (_type == AssociationType.PRIMARY) {\n            if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].primary != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, 0, 0, _type);\n            }\n            cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;\n            emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);\n        } else if (_type == AssociationType.ACTIVE) {\n            if (!subprotocolData.active) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;\n            uint256 lengthBeforeAddition = activeData.values.length;\n            if (lengthBeforeAddition == 0) {\n                uint256[] memory nftIDsToAdd = new uint256[](1);\n                nftIDsToAdd[0] = _nftIDToAdd;\n                activeData.values = nftIDsToAdd;\n                activeData.positions[_nftIDToAdd] = 1; // Array index + 1\n            } else {\n                // Check for duplicates\n                if (activeData.positions[_nftIDToAdd] != 0)\n                    revert ActiveArrayAlreadyContainsID(_cidNFTID, _subprotocolName, _nftIDToAdd);\n                activeData.values.push(_nftIDToAdd);\n                activeData.positions[_nftIDToAdd] = lengthBeforeAddition + 1;\n            }\n            emit ActiveDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd, lengthBeforeAddition);\n        }\n    }\n\n    /// @notice Remove / unset a key for the given CID NFT and subprotocol\n    /// @param _cidNFTID ID of the CID NFT to remove the data from\n    /// @param _subprotocolName Name of the subprotocol where the data will be removed. Has to exist.\n    /// @param _key Key to unset. This value is only relevant for the AssociationType ORDERED\n    /// @param _nftIDToRemove The ID of the NFT to remove. Only needed for the AssociationType ACTIVE\n    /// @param _type Association type (see AssociationType struct) to remove this data from\n    function remove(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key,\n        uint256 _nftIDToRemove,\n        AssociationType _type\n    ) public {\n        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(\n            _subprotocolName\n        );\n        address subprotocolOwner = subprotocolData.owner;\n        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);\n        address cidNFTOwner = ownerOf[_cidNFTID];\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n\n        ERC721 nftToRemove = ERC721(subprotocolData.nftAddress);\n        if (_type == AssociationType.ORDERED) {\n            // We do not have to check if ordered is supported by the subprotocol. If not, the value will not be unset (which is checked below)\n            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].ordered[_key];\n            if (currNFTID == 0)\n                // This check is technically not necessary (because the NFT transfer would fail), but we include it to have more meaningful errors\n                revert OrderedValueNotSet(_cidNFTID, _subprotocolName, _key);\n            delete cidData[_cidNFTID][_subprotocolName].ordered[_key];\n            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);\n            emit OrderedDataRemoved(_cidNFTID, _subprotocolName, _key, _nftIDToRemove);\n        } else if (_type == AssociationType.PRIMARY) {\n            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].primary;\n            if (currNFTID == 0) revert PrimaryValueNotSet(_cidNFTID, _subprotocolName);\n            delete cidData[_cidNFTID][_subprotocolName].primary;\n            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);\n            emit PrimaryDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);\n        } else if (_type == AssociationType.ACTIVE) {\n            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;\n            uint256 arrayPosition = activeData.positions[_nftIDToRemove]; // Index + 1, 0 if non-existant\n            if (arrayPosition == 0) revert ActiveArrayDoesNotContainID(_cidNFTID, _subprotocolName, _nftIDToRemove);\n            uint256 arrayLength = activeData.values.length;\n            // Swap only necessary if not already the last element\n            if (arrayPosition != arrayLength) {\n                uint256 befSwapLastNFTID = activeData.values[arrayLength - 1];\n                activeData.values[arrayPosition - 1] = befSwapLastNFTID;\n                activeData.positions[befSwapLastNFTID] = arrayPosition;\n            }\n            activeData.values.pop();\n            activeData.positions[_nftIDToRemove] = 0;\n            nftToRemove.safeTransferFrom(address(this), msg.sender, _nftIDToRemove);\n            emit ActiveDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);\n        }\n    }\n\n    /// @notice Get the ordered data that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @param _key Key to query\n    /// @return subprotocolNFTID The ID of the NFT at the queried key. 0 if it does not exist\n    function getOrderedData(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key\n    ) external view returns (uint256 subprotocolNFTID) {\n        subprotocolNFTID = cidData[_cidNFTID][_subprotocolName].ordered[_key];\n    }\n\n    /// @notice Get the primary data that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @return subprotocolNFTID The ID of the primary NFT at the queried subprotocl / CID NFT. 0 if it does not exist\n    function getPrimaryData(uint256 _cidNFTID, string calldata _subprotocolName)\n        external\n        view\n        returns (uint256 subprotocolNFTID)\n    {\n        subprotocolNFTID = cidData[_cidNFTID][_subprotocolName].primary;\n    }\n\n    /// @notice Get the active data list that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @return subprotocolNFTIDs The ID of the primary NFT at the queried subprotocl / CID NFT. 0 if it does not exist\n    function getActiveData(uint256 _cidNFTID, string calldata _subprotocolName)\n        external\n        view\n        returns (uint256[] memory subprotocolNFTIDs)\n    {\n        subprotocolNFTIDs = cidData[_cidNFTID][_subprotocolName].active.values;\n    }\n\n    /// @notice Check if a provided NFT ID is included in the active data list that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @return nftIncluded True if the NFT ID is in the list\n    function activeDataIncludesNFT(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _nftIDToCheck\n    ) external view returns (bool nftIncluded) {\n        nftIncluded = cidData[_cidNFTID][_subprotocolName].active.positions[_nftIDToCheck] != 0;\n    }\n\n    function onERC721Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}"
    },
    {
      "filename": "src/CidNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"./SubprotocolRegistry.sol\";\n\n/// @title Canto Identity Protocol NFT\n/// @notice CID NFTs are at the heart of the CID protocol. All key/values of subprotocols are associated with them.\ncontract CidNFT is ERC721, ERC721TokenReceiver {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee (in BPS) that is charged for every mint (as a percentage of the mint fee). Fixed at 10%.\n    uint256 public constant CID_FEE_BPS = 1_000;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Wallet that receives CID fees\n    address public immutable cidFeeWallet;\n\n    /// @notice Reference to the NOTE TOKEN\n    ERC20 public immutable note;\n\n    /// @notice Reference to the subprotocol registry\n    SubprotocolRegistry public immutable subprotocolRegistry;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Base URI of the NFT\n    string public baseURI;\n\n    /// @notice Array of uint256 values (NFT IDs) with additional position information NFT ID => (array pos. + 1)\n    struct IndexedArray {\n        uint256[] values;\n        mapping(uint256 => uint256) positions;\n    }\n\n    /// @notice Data that is associated with a CID NFT -> subprotocol combination\n    struct SubprotocolData {\n        /// @notice Mapping for ordered type\n        mapping(uint256 => uint256) ordered;\n        /// @notice Value for primary type\n        uint256 primary;\n        /// @notice List for active type\n        IndexedArray active;\n    }\n\n    /// @notice The different types of associations between CID NFTs and subprotocol NFTs\n    enum AssociationType {\n        /// @notice key => NFT mapping\n        ORDERED,\n        /// @notice Zero or one NFT\n        PRIMARY,\n        /// @notice List of NFTs\n        ACTIVE\n    }\n\n    /// @notice Counter of the minted NFTs\n    /// @dev Used to assign a new unique ID. The first ID that is assigned is 1, ID 0 is never minted.\n    uint256 public numMinted;\n\n    /// @notice Stores the references to subprotocol NFTs. Mapping nftID => subprotocol name => subprotocol data\n    mapping(uint256 => mapping(string => SubprotocolData)) internal cidData;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event OrderedDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataAdded(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 subprotocolNFTID,\n        uint256 arrayIndex\n    );\n    event OrderedDataRemoved(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error AddCallAfterMintingFailed(uint256 index);\n    error SubprotocolDoesNotExist(string subprotocolName);\n    error NFTIDZeroDisallowedForSubprotocols();\n    error AssociationTypeNotSupportedForSubprotocol(AssociationType associationType, string subprotocolName);\n    error NotAuthorizedForCIDNFT(address caller, uint256 cidNFTID, address cidNFTOwner);\n    error NotAuthorizedForSubprotocolNFT(address caller, uint256 subprotocolNFTID);\n    error ActiveArrayAlreadyContainsID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);\n    error OrderedValueNotSet(uint256 cidNFTID, string subprotocolName, uint256 key);\n    error PrimaryValueNotSet(uint256 cidNFTID, string subprotocolName);\n    error ActiveArrayDoesNotContainID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToRemove);\n\n    /// @notice Sets the name, symbol, baseURI, and the address of the auction factory\n    /// @param _name Name of the NFT\n    /// @param _symbol Symbol of the NFT\n    /// @param _baseURI NFT base URI. {id}.json is appended to this URI\n    /// @param _cidFeeWallet Address of the wallet that receives the fees\n    /// @param _noteContract Address of the $NOTE contract\n    /// @param _subprotocolRegistry Address of the subprotocol registry\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _baseURI,\n        address _cidFeeWallet,\n        address _noteContract,\n        address _subprotocolRegistry\n    ) ERC721(_name, _symbol) {\n        baseURI = _baseURI;\n        cidFeeWallet = _cidFeeWallet;\n        note = ERC20(_noteContract);\n        subprotocolRegistry = SubprotocolRegistry(_subprotocolRegistry);\n    }\n\n    /// @notice Get the token URI for the provided ID\n    /// @param _id ID to retrieve the URI for\n    /// @return tokenURI The URI of the queried token (path to a JSON file)\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (ownerOf[_id] == address(0))\n            // According to ERC721, this revert for non-existing tokens is required\n            revert TokenNotMinted(_id);\n        return string(abi.encodePacked(baseURI, _id, \".json\"));\n    }\n\n    /// @notice Mint a new CID NFT\n    /// @dev An address can mint multiple CID NFTs, but it can only set one as associated with it in the AddressRegistry\n    /// @param _addList An optional list of encoded parameters for add to add subprotocol NFTs directly after minting.\n    /// The parameters should not include the function selector itself, the function select for add is always prepended.\n    function mint(bytes[] calldata _addList) external {\n        _mint(msg.sender, ++numMinted); // We do not use _safeMint here on purpose. If a contract calls this method, he expects to get an NFT back\n        bytes4 addSelector = this.add.selector;\n        for (uint256 i = 0; i < _addList.length; ++i) {\n            (\n                bool success, /*bytes memory result*/\n\n            ) = address(this).delegatecall(abi.encodePacked(addSelector, _addList[i]));\n            if (!success) revert AddCallAfterMintingFailed(i);\n        }\n    }\n\n    /// @notice Add a new entry for the given subprotocol to the provided CID NFT\n    /// @param _cidNFTID ID of the CID NFT to add the data to\n    /// @param _subprotocolName Name of the subprotocol where the data will be added. Has to exist.\n    /// @param _key Key to set. This value is only relevant for the AssociationType ORDERED (where a mapping int => nft ID is stored)\n    /// @param _nftIDToAdd The ID of the NFT to add\n    /// @param _type Association type (see AssociationType struct) to use for this data\n    function add(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key,\n        uint256 _nftIDToAdd,\n        AssociationType _type\n    ) external {\n        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(\n            _subprotocolName\n        );\n        address subprotocolOwner = subprotocolData.owner;\n        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);\n        address cidNFTOwner = ownerOf[_cidNFTID];\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n        if (_nftIDToAdd == 0) revert NFTIDZeroDisallowedForSubprotocols(); // ID 0 is disallowed in subprotocols\n\n        // The CID Protocol safeguards the NFTs of subprotocols. Note that these NFTs are usually pointers to other data / NFTs (e.g., to an image NFT for profile pictures)\n        ERC721 nftToAdd = ERC721(subprotocolData.nftAddress);\n        nftToAdd.safeTransferFrom(msg.sender, address(this), _nftIDToAdd);\n        // Charge fee (subprotocol & CID fee) if configured\n        uint96 subprotocolFee = subprotocolData.fee;\n        if (subprotocolFee != 0) {\n            uint256 cidFee = (subprotocolFee * CID_FEE_BPS) / 10_000;\n            SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, cidFee);\n            SafeTransferLib.safeTransferFrom(note, msg.sender, subprotocolOwner, subprotocolFee - cidFee);\n        }\n        if (_type == AssociationType.ORDERED) {\n            if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].ordered[_key] != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, _key, 0, _type);\n            }\n            cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;\n            emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\n        } else if (_type == AssociationType.PRIMARY) {\n            if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].primary != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, 0, 0, _type);\n            }\n            cidData["
    }
  ]
}