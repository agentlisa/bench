{
  "Title": "M-2: when issuer set new winner by calling setTierWinner() code should reset invoice and supporting documents for that tier",
  "Content": "# Issue M-2: when issuer set new winner by calling setTierWinner() code should reset invoice and supporting documents for that tier \n\nSource: https://github.com/sherlock-audit/2023-02-openq-judging/issues/297 \n\n## Found by \nunforgiven\n\n## Summary\nif invoice or supporting documents are required to receive the winning prize then tier winner should provide them. bounty issuer or oracle would set invoice and supporting document status of a tier by calling `setInvoiceComplete()` and `setSupportingDocumentsComplete()`. bounty issuer can set tier winners by calling `setTierWinner()` but code won't reset the status of the invoice and supporting documents when tier winner changes. a malicious winner can bypass invoice and supporting document check by this issue.\n\n## Vulnerability Detail\nif bounty issuer set invoice and supporting documents as required for the bounty winners in the tiered bounty, then tier winner should provide those and bounty issuer or off-chain oracle would set the status of the invoice and documents for that tier. but if issuer wants to change a tier winner and calls `setTierWinner()` code would changes the tier winner but won't reset the status of the invoice and supporting documents for the new winner. This is the `setTierWinner()` code in OpenQV1 and TieredBountyCore:\n```solidity\n    function setTierWinner(\n        string calldata _bountyId,\n        uint256 _tier,\n        string calldata _winner\n    ) external {\n        IBounty bounty = getBounty(_bountyId);\n        require(msg.sender == bounty.issuer(), Errors.CALLER_NOT_ISSUER);\n        bounty.setTierWinner(_winner, _tier);\n\n        emit TierWinnerSelected(\n            address(bounty),\n            bounty.getTierWinners(),\n            new bytes(0),\n            VERSION_1\n        );\n    }\n\n    function setTierWinner(string memory _winner, uint256 _tier)\n        external\n        onlyOpenQ\n    {\n        tierWinners[_tier] = _winner;\n    }\n```\nAs you can see code only sets the `tierWinner[tier]` and won't reset `invoiceComplete[tier]` or `supportingDocumentsComplete[tier]` to false. This would cause an issue when issuer wants to change the tier winner. these are the steps that makes the issue:\n1. UserA creates tiered Bounty1 and set invoice and supporting documents as required for winners to claim their funds.\n2. UserA would set User1 as winner of tier 1 and User1 completed the invoice and oracle would set `invoiceComplete[1] = true`.\n3. UserA would change tier winner to User2 because User1 didn't complete supporting documents phase. now User2 is winner of tier 1 and `invoiceComplete[1]` is true and User2 only required to complete supporting documents and User2 would receive the win prize without completing the invoice phase.\n\n## Impact\nmalicious winner can bypass invoice and supporting document check when they are required if he is replace as another person to be winner of a tier.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/TieredBountyCore.sol#L59-L64\n\n## Tool used\nManual Review\n\n## Recommendation\nset status of the `invoiceComplete[tier]` or `supportingDocumentsComplete[tier]` to false in `setTierWinner()` function.\n\n## Discussion\n\n**0xunforgiven**\n\nEscalate for 31 USDC\n\nmy issue is not duplicate of #425.\n\nissue #425 is: \"array lists `invoiceCompleteClaimIds[]` and `supportingDocumentsCompleteClaimIds[]` can contain claimIds that are incomplete\". that is about those array list containing extra values and the issue has no serious impact because code checks mappings to check invoice and docuements status.\n\nmy issue explains that when a tier winner gets changed (Bounty issuer change tier1 winner from User1 to User2 for any reason) code doesn't reset the values in the mappings `invoiceComplete[tier1]` or `supportingDocumentsComplete[tier1]`. so values in those mappings would shoe wrong values for the new tier1 winner. the POC shows how the issue happens:\n\n> 1. UserA creates tiered Bounty1 and set invoice and supporting documents as required for winners to claim their funds.\n> 2. UserA would set User1 as winner of tier 1 and User1 completed the invoice and oracle would set invoiceComplete[1] = true.\n> 3. UserA would change tier winner to User2 because User1 didn't complete supporting documents phase. now User2 is winner of tier 1 and invoiceComplete[1] is true and User2 only required to complete supporting documents and User2 would receive the win prize without completing the invoice phase.\n\n\n**sherlock-admin**\n\n > Escalate for 31 USDC\n> \n> my issue is not duplicate of #425.\n> \n> issue #425 is: \"array lists `invoiceCompleteClaimIds[]` and `supportingDocumentsCompleteClaimIds[]` can contain claimIds that are incomplete\". that is about those array list containing extra values and the issue has no serious impact because code checks mappings to check invoice and docuements status.\n> \n> my issue explains that when a tier winner gets changed (Bounty issuer change tier1 winner from User1 to User2 for any reason) code doesn't reset the values in the mappings `invoiceComplete[tier1]` or `supportingDocumentsComplete[tier1]`. so values in those mappings would shoe wrong values for the new tier1 winner. the POC shows how the issue happens:\n> \n> > 1. UserA creates tiered Bounty1 and set invoice and supporting documents as required for winners to claim their funds.\n> > 2. UserA would set User1 as winner of tier 1 and User1 completed the invoice and oracle would set invoiceComplete[1] = true.\n> > 3. UserA would change tier winner to User2 because User1 didn't complete supporting documents phase. now User2 is winner of tier 1 and invoiceComplete[1] is true and User2 only required to complete supporting documents and User2 would receive the win prize without completing the invoice phase.\n> \n\nYou've created a valid escalation for 31 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nNot a valid duplicate of #425 and a valid issue \n`_eligibleToClaimAtomicBounty` would end up validating a user without completing the invoice phase as shown. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Not a valid duplicate of #425 and a valid issue \n> `_eligibleToClaimAtomicBounty` would end up validating a user without completing the invoice phase as shown. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/39",
  "Code": [
    {
      "filename": "contracts/Bounty/Implementations/TieredBountyCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/TieredBountyStorageCore.sol';\n\n/// @title TieredBountyCore\n/// @author FlacoJones\n/// @notice Shared methods common to all tiered bounty types (tier meaning multiple payout levels, e.g. 1st, 2nd, 3rd)\n/// @dev TieredBountyCore -> TieredBountyStorageCore -> BountyCore -> BountyStorageCore -> Core Dependencies (OZ + Custom)\nabstract contract TieredBountyCore is TieredBountyStorageCore {\n    /// @notice Receives an NFT for this contract\n    /// @param _sender Sender of the NFT\n    /// @param _tokenAddress NFT token address\n    /// @param _tokenId NFT token id\n    /// @param _expiration How long before this deposit becomes refundable\n    /// @param _data ABI encoded data (unused in this case)\n    /// @return bytes32 the deposit id\n    function receiveNft(\n        address _sender,\n        address _tokenAddress,\n        uint256 _tokenId,\n        uint256 _expiration,\n        bytes calldata _data\n    ) external override onlyDepositManager nonReentrant returns (bytes32) {\n        require(\n            nftDeposits.length < nftDepositLimit,\n            Errors.NFT_DEPOSIT_LIMIT_REACHED\n        );\n        require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);\n        _receiveNft(_tokenAddress, _sender, _tokenId);\n\n        bytes32 depositId = _generateDepositId();\n\n        funder[depositId] = _sender;\n        tokenAddress[depositId] = _tokenAddress;\n        depositTime[depositId] = block.timestamp;\n        tokenId[depositId] = _tokenId;\n        expiration[depositId] = _expiration;\n        isNFT[depositId] = true;\n\n        uint256 _tier = abi.decode(_data, (uint256));\n        tier[depositId] = _tier;\n\n        deposits.push(depositId);\n        nftDeposits.push(depositId);\n\n        return depositId;\n    }\n\n    /// @notice Sets tierClaimed to true for the given tier\n    /// @param _tier The tier being claimed\n    function setTierClaimed(uint256 _tier) external onlyClaimManager {\n        tierClaimed[_tier] = true;\n    }\n\n    /// @notice Sets a winner for a particular tier\n    /// @param _tier The tier they won\n    /// @param _winner The external UUID (e.g. an OpenQ User UUID) that won this tier\n    function setTierWinner(string memory _winner, uint256 _tier)\n        external\n        onlyOpenQ\n    {\n        tierWinners[_tier] = _winner;\n    }\n\n    /// @notice Whether or not invoice has been completed\n    /// @param _data ABI encoded data\n    /// @dev see IBountyCore.setInvoiceComplete.(_data) for _data ABI encoding schema\n    function setInvoiceComplete(bytes calldata _data) external onlyOpenQ {\n        (uint256 _tier, bool _invoiceComplete) = abi.decode(\n            _data,\n            (uint256, bool)\n        );\n        invoiceComplete[_tier] = _invoiceComplete;\n    }\n\n    /// @notice Whether or not supporting documents have been completed\n    /// @param _data ABI encoded data\n    /// @dev see IBountyCore.setSupportingDocumentsComplete.(_data) for _data ABI encoding schema\n    function setSupportingDocumentsComplete(bytes calldata _data)\n        external\n        onlyOpenQ\n    {\n        (uint256 _tier, bool _supportingDocumentsComplete) = abi.decode(\n            _data,\n            (uint256, bool)\n        );\n        supportingDocumentsComplete[_tier] = _supportingDocumentsComplete;\n    }\n\n    /// @notice Returns an array for the payoutSchedule\n    /// @return payoutSchedule An array containing the percentage to pay to [1st, 2nd, etc.] place\n    function getPayoutSchedule() external view returns (uint256[] memory) {\n        return payoutSchedule;\n    }\n\n    /// @notice Returns array of winners\n    /// @return An array of the external ids (e.g. OpenQ User UUIDs) of the tier winners\n    function getTierWinners() external view returns (string[] memory) {\n        return tierWinners;\n    }\n\n    /// @notice Returns array of invoice complete\n    /// @return An array of the booleans for each tier, true or false for if invoices have been completed for that tier\n    /// @dev We return from all IBountyCore.getSupportingDocumentsComplete() as bytes to accomodate different return types\n    /// @dev _data (bool[])\n    /// @dev _data (invoiceComplete)\n    function getInvoiceComplete() external view returns (bytes memory) {\n        return abi.encode(invoiceComplete);\n    }\n\n    /// @notice Returns array of supporting documents complete\n    /// @return An array of the booleans for each tier, true or false for if supporting documents have been completed for that tier\n    /// @dev We return from all IBountyCore.getSupportingDocumentsComplete() as bytes to accomodate different return types\n    /// @dev _data (bool[])\n    /// @dev _data (supportingDocumentsComplete)\n    function getSupportingDocumentsComplete()\n        external\n        view\n        returns (bytes memory)\n    {\n        return abi.encode(supportingDocumentsComplete);\n    }\n}"
    }
  ]
}