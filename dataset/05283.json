{
  "Title": "[04] Users currently need to approve tokens to the Gates instead of the Abbot",
  "Content": "\nAccording to the [documentation](https://demo-35.gitbook.io/untitled/smart-contracts/gate-module):\n\n> As the Gate is an internal-facing module, users will not be able to, and are **not expected to**, interact with the Gate directly.\n\nUsers are expected to handle their troves using the `abbot` module which indirectly interacts with the `gate` modules for each asset via the `sentinel` module:\n\n *Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2024-01-opus-findings/issues/85).*\n\nHowever, a user still needs to know the address of a respective `gate` and give token approval to the `gate` instead of the `abbot` module, because the `gate` [pulls the assets from the user](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/gate.cairo#L137-L150) on deposit:\n```cairo\nfn enter(ref self: ContractState, user: ContractAddress, trove_id: u64, asset_amt: u128) -> Wad {\n    ...\n\n    let success: bool = self.asset.read().transfer_from(user, get_contract_address(), asset_amt.into());\n    assert(success, 'GA: Asset transfer failed');\n\n    ...\n}\n```\n\n### Impact\n\nComplicated UX that partially counters the documentation.\n\n### Recommendation\n\nThe user should only have to give token approvals to the `abbot` module which pulls the assets from the user and subsequently forwards them to the respective `gate`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-opus",
  "Code": [
    {
      "filename": "src/core/gate.cairo",
      "content": "#[starknet::contract]\nmod gate {\n    use opus::interfaces::IERC20::{IERC20Dispatcher, IERC20DispatcherTrait};\n    use opus::interfaces::IGate::IGate;\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::utils::math::{fixed_point_to_wad, pow};\n    use starknet::{ContractAddress, get_caller_address, get_contract_address};\n    use wadray::{Wad, WadZeroable, WAD_DECIMALS, WAD_ONE};\n\n    // As the Gate is similar to a ERC-4626 vault, it therefore faces a similar issue whereby\n    // the first depositor can artificially inflate a share price by depositing the smallest\n    // unit of an asset and then sending assets to the contract directly. This is addressed\n    // in the Sentinel, which enforces a minimum deposit before a yang and its Gate can be\n    // added to the Shrine.\n\n    #[storage]\n    struct Storage {\n        // the Shrine associated with this Gate\n        shrine: IShrineDispatcher,\n        // the ERC-20 asset that is the underlying asset of this Gate's yang\n        asset: IERC20Dispatcher,\n        // the address of the Sentinel associated with this Gate\n        // Also the only authorized caller of Gate\n        sentinel: ContractAddress,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        Enter: Enter,\n        Exit: Exit,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Enter {\n        #[key]\n        user: ContractAddress,\n        #[key]\n        trove_id: u64,\n        asset_amt: u128,\n        yang_amt: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Exit {\n        #[key]\n        user: ContractAddress,\n        #[key]\n        trove_id: u64,\n        asset_amt: u128,\n        yang_amt: Wad\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState, shrine: ContractAddress, asset: ContractAddress, sentinel: ContractAddress\n    ) {\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n        self.asset.write(IERC20Dispatcher { contract_address: asset });\n        self.sentinel.write(sentinel);\n    }\n\n    //\n    // External Gate functions\n    //\n\n    #[abi(embed_v0)]\n    impl IGateImpl of IGate<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_shrine(self: @ContractState) -> ContractAddress {\n            self.shrine.read().contract_address\n        }\n\n        fn get_sentinel(self: @ContractState) -> ContractAddress {\n            self.sentinel.read()\n        }\n\n        fn get_asset(self: @ContractState) -> ContractAddress {\n            self.asset.read().contract_address\n        }\n\n        fn get_total_assets(self: @ContractState) -> u128 {\n            get_total_assets_helper(self.asset.read())\n        }\n\n        fn get_total_yang(self: @ContractState) -> Wad {\n            self.get_total_yang_helper(self.asset.read().contract_address)\n        }\n\n        // Returns the amount of assets in Wad that corresponds to per Wad unit of yang.\n        // If the asset's decimals is less than `WAD_DECIMALS`, the amount is scaled up accordingly.\n        // Note that if there is no yang yet, this function will still return a positive value\n        // based on the asset amount being at parity with yang (with scaling where necessary). This is\n        // so that the yang price can be properly calculated by the oracle even if no assets have been\n        // deposited yet.\n        fn get_asset_amt_per_yang(self: @ContractState) -> Wad {\n            let amt: u128 = self.convert_to_assets_helper(WAD_ONE.into());\n            let decimals: u8 = self.asset.read().decimals();\n\n            if decimals == WAD_DECIMALS {\n                return amt.into();\n            }\n\n            fixed_point_to_wad(amt, decimals)\n        }\n\n        // This can be used to simulate the effects of `enter` at the current on-chain conditions.\n        // `asset_amt` is denoted in the asset's decimals.\n        fn convert_to_yang(self: @ContractState, asset_amt: u128) -> Wad {\n            self.convert_to_yang_helper(asset_amt)\n        }\n\n        // This can be used to simulate the effects of `exit` at the current on-chain conditions.\n        // The return value is denoted in the asset's decimals.\n        fn convert_to_assets(self: @ContractState, yang_amt: Wad) -> u128 {\n            self.convert_to_assets_helper(yang_amt)\n        }\n\n        //\n        // Core Functions - External\n        //\n\n        // Transfers the stipulated amount of assets, in the asset's decimals, from the given\n        // user to the Gate and returns the corresponding yang amount in Wad.\n        // `asset_amt` is denominated in the decimals of the asset.\n        fn enter(ref self: ContractState, user: ContractAddress, trove_id: u64, asset_amt: u128) -> Wad {\n            self.assert_sentinel();\n\n            let yang_amt: Wad = self.convert_to_yang_helper(asset_amt);\n            if yang_amt.is_zero() {\n                return WadZeroable::zero();\n            }\n\n            let success: bool = self.asset.read().transfer_from(user, get_contract_address(), asset_amt.into());\n            assert(success, 'GA: Asset transfer failed');\n            self.emit(Enter { user, trove_id, asset_amt, yang_amt });\n\n            yang_amt\n        }\n\n        // Transfers such amount of assets, in the asset's decimals, corresponding to the\n        // stipulated yang amount to the given user.\n        // The return value is denominated in the decimals of the asset.\n        fn exit(ref self: ContractState, user: ContractAddress, trove_id: u64, yang_amt: Wad) -> u128 {\n            self.assert_sentinel();\n\n            let asset_amt: u128 = self.convert_to_assets_helper(yang_amt);\n            if asset_amt.is_zero() {\n                return 0;\n            }\n\n            let success: bool = self.asset.read().transfer(user, asset_amt.into());\n            assert(success, 'GA: Asset transfer failed');\n\n            self.emit(Exit { user, trove_id, asset_amt, yang_amt });\n\n            asset_amt\n        }\n    }\n\n    //\n    // Internal Gate functions\n    //\n\n    #[generate_trait]\n    impl GateHelpers of GateHelpersTrait {\n        #[inline(always)]\n        fn assert_sentinel(self: @ContractState) {\n            assert(get_caller_address() == self.sentinel.read(), 'GA: Caller is not authorized');\n        }\n\n        #[inline(always)]\n        fn get_total_yang_helper(self: @ContractState, asset: ContractAddress) -> Wad {\n            self.shrine.read().get_yang_total(asset)\n        }\n\n        // Helper function to calculate the amount of assets corresponding to the given\n        // amount of yang.\n        // Return value is denominated in the decimals of the asset.\n        fn convert_to_assets_helper(self: @ContractState, yang_amt: Wad) -> u128 {\n            let asset: IERC20Dispatcher = self.asset.read();\n            let total_yang: Wad = self.get_total_yang_helper(asset.contract_address);\n\n            if total_yang.is_zero() {\n                let decimals: u8 = asset.decimals();\n                // Scale `yang_amt` down by the difference to match the decimal\n                // precision of the asset. If asset is of `Wad` precision, then\n                // the same value is returned\n                yang_amt.val / pow(10_u128, WAD_DECIMALS - decimals)\n            } else {\n                ((yang_amt * get_total_assets_helper(asset).into()) / total_yang).val\n            }\n        }\n\n        // Helper function to calculate the amount of yang corresponding to the given\n        // amount of assets.\n        // `asset_amt` is denominated in the decimals of the asset.\n        fn convert_to_yang_helper(self: @ContractState, asset_amt: u128) -> Wad {\n            let asset: IERC20Dispatcher = self.asset.read();\n            let total_yang: Wad = self.get_total_yang_helper(asset.contract_address);\n\n            if total_yang.is_zero() {\n                let decimals: u8 = asset.decimals();\n                // Otherwise, scale `asset_amt` up by the difference to match `Wad`\n                // precision of yang. If asset is of `Wad` precision, then the same\n                // value is returned\n                fixed_point_to_wad(asset_amt, decimals)\n            } else {\n                (asset_amt.into() * total_yang) / get_total_assets_helper(asset).into()\n            }\n        }\n    }\n\n    //\n    // Internal functions for Gate that do not access Gate's storage\n    //\n\n    #[inline(always)]\n    fn get_total_assets_helper(asset: IERC20Dispatcher) -> u128 {\n        asset.balance_of(get_contract_address()).try_into().unwrap()\n    }\n}"
    }
  ]
}