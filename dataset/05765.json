{
  "Title": "[H-03] Incorrect decimal usage in score calculation leads to reduced user reward earnings",
  "Content": "\nUsers earned rewards are calculated incorrectly because of the incorrect decimals value used to calculate user's `score` and markets `sumOfMembersScore`, which impacts the `delta` that is added to market's `rewardIndex` when `Prime.accrueInterest` function is called.\n\n### Proof of Concept\n\nAll users rewards are calculated with the following formula:\n\n    rewards = (rewardIndex - userRewardIndex) * scoreOfUser;\n\nThis means that for user to earn rewards, market's `rewardIndex` needs to periodically increase.\n \n\n`markets[vToken].rewardIndex` is updated (increased), when `Prime.accrueInterest` is called.\n\n[`Prime.sol:L583-L588`](https://github.com/code-423n4/2023-09-venus/blob/b11d9ef9db8237678567e66759003138f2368d23/contracts/Tokens/Prime/Prime.sol#L583-L588)\n\n```solidity\n    uint256 delta;\n    if (markets[vToken].sumOfMembersScore > 0) {\n        delta = ((distributionIncome * EXP_SCALE) / markets[vToken].sumOfMembersScore);\n    }\n\n    markets[vToken].rewardIndex = markets[vToken].rewardIndex + delta;\n```\n\nFrom the code snippet above it is assumed that `markets[vToken].sumOfMembersScore` is precision of 18 decimals.\n\nTo ensure that user's `score` and markets `sumOfMemberScore` are correctly calculated, in [`Prime._calculateScore`](https://github.com/code-423n4/2023-09-venus/blob/b11d9ef9db8237678567e66759003138f2368d23/contracts/Tokens/Prime/Prime.sol#L647-L664) function `capital` is adjusted to 18 decimals. After that `capital` is used in `Scores.calculateScore` function.\nNote: `capital` precision from [`_capitalForScore`](https://github.com/code-423n4/2023-09-venus/blob/b11d9ef9db8237678567e66759003138f2368d23/contracts/Tokens/Prime/Prime.sol#L872-L897) function is in precision of **underlying token decimals**.\n\n[`Prime.sol:660-L663`](https://github.com/code-423n4/2023-09-venus/blob/b11d9ef9db8237678567e66759003138f2368d23/contracts/Tokens/Prime/Prime.sol#L660-L663)\n\n```solidity\n    (uint256 capital, , ) = _capitalForScore(xvsBalanceForScore, borrow, supply, market);\n    capital = capital * (10 ** (18 - vToken.decimals()));\n\n    return Scores.calculateScore(xvsBalanceForScore, capital, alphaNumerator, alphaDenominator);\n```\nThe mistake is made when `vToken.decimals()` is used instead of `vToken.underlying().decimals()`.\n \nTo prove that this is the case, here are vTokens deployed on Binance Smart chain, their decimals and underlying token decimals:\n\n| vToken                                                                        | vToken decimals | Underlying token decimals |\n| ----------------------------------------------------------------------------- | --------------- | ------------------------- |\n| [vUSDC](https://bscscan.com/token/0xecA88125a5ADbe82614ffC12D0DB554E2e2867C8) | 8               | 18                        |\n| [vETH](https://bscscan.com/token/0xf508fcd89b8bd15579dc79a6827cb4686a3592c8)  | 8               | 18                        |\n| [vBNB](https://bscscan.com/token/0xa07c5b74c9b40447a954e1466938b865b6bbea36)  | 8               | 18                        |\n| [vBTC](https://bscscan.com/token/0x882c173bc7ff3b7786ca16dfed3dfffb9ee7847b)  | 8               | 18                        |\n| [vUSDT](https://bscscan.com/token/0xfd5840cd36d94d7229439859c0112a4185bc0255) | 8               | 18                        |\n\nSince `vToken.decimals()` is used, this means the precision of `capital` is `18 + (18 - 8) = 28` decimals instead of 18 decimals, which makes the `score` calculation from [`Score.calculateScore`](https://github.com/code-423n4/2023-09-venus/blob/b11d9ef9db8237678567e66759003138f2368d23/contracts/Tokens/Prime/libs/Scores.sol#L22-L69) function incorrect, since the function expects `capital` to be in precision of 18 decimals.\n\nAs a result, `delta` for market's `rewardIndex` is incorrectly calculated and it can be 0 even though it shouldn't be, which means that users will not accrue any rewards.\n\n### Update current test with correct decimals for vTokens\n\nDevelopers have made a mistake when writing the tests for `Prime.sol` - in the tests they have set vToken decimals to 18 instead of 8, which makes the tests pass, but on the Binance Smart Chain all of the vToken decimals are 8.\n\nIf the decimal value of vToken is set to 8 in the tests, then the tests will fail.\n\nChange the `vusdt`, `veth` and `vbnb` decimals to 8 and run:\n\n```bash\nnpx hardhat test tests/hardhat/Prime/*.ts tests/hardhat/integration/index.ts\n```\n\nThis will make the current tests fail.\n\n### PoC Test\n\nHere is a test where it shows, that `rewardIndex` is still 0 after `Prime.accrueInterest` is called, even though it should be > 0.\n\n<details>\n<summary>PoC test</summary>\n\nTo run the following test:\n\n1.  Create `PoC.ts` file under the `tests/hardhat/Prime` path.\n2.  Copy the code below and paste it into the `PoC.ts` file.\n3.  Run `npx hardhat test tests/hardhat/Prime/PoC.ts`\n\n```typescript\nimport { FakeContract, MockContract, smock } from \"@defi-wonderland/smock\";\nimport { loadFixture, mine } from \"@nomicfoundation/hardhat-network-helpers\";\nimport chai from \"chai\";\nimport { BigNumber, Signer } from \"ethers\";\nimport { ethers, upgrades } from \"hardhat\";\n\nimport { convertToUnit } from \"../../../helpers/utils\";\nimport {\n  BEP20Harness,\n  ComptrollerLens,\n  ComptrollerLens__factory,\n  ComptrollerMock,\n  ComptrollerMock__factory,\n  IAccessControlManager,\n  IProtocolShareReserve,\n  InterestRateModelHarness,\n  PrimeLiquidityProvider,\n  PrimeScenario,\n  ResilientOracleInterface,\n  VBep20Harness,\n  XVS,\n  XVSStore,\n  XVSVault,\n  XVSVaultScenario,\n} from \"../../../typechain\";\n\nconst { expect } = chai;\nchai.use(smock.matchers);\n\nexport const bigNumber18 = BigNumber.from(\"1000000000000000000\"); // 1e18\nexport const bigNumber16 = BigNumber.from(\"10000000000000000\"); // 1e16\nexport const vTokenDecimals = BigNumber.from(8);\n\ntype SetupProtocolFixture = {\n  oracle: FakeContract<ResilientOracleInterface>;\n  accessControl: FakeContract<IAccessControlManager>;\n  comptrollerLens: MockContract<ComptrollerLens>;\n  comptroller: MockContract<ComptrollerMock>;\n  usdt: BEP20Harness;\n  vusdt: VBep20Harness;\n  eth: BEP20Harness;\n  veth: VBep20Harness;\n  xvsVault: XVSVaultScenario;\n  xvs: XVS;\n  xvsStore: XVSStore;\n  prime: PrimeScenario;\n  protocolShareReserve: FakeContract<IProtocolShareReserve>;\n  primeLiquidityProvider: PrimeLiquidityProvider;\n};\n\nasync function deployProtocol(): Promise<SetupProtocolFixture> {\n  const [wallet, user1, user2, user3] = await ethers.getSigners();\n\n  const oracle = await smock.fake<ResilientOracleInterface>(\"ResilientOracleInterface\");\n  const protocolShareReserve = await smock.fake<IProtocolShareReserve>(\"IProtocolShareReserve\");\n  const accessControl = await smock.fake<IAccessControlManager>(\"AccessControlManager\");\n  accessControl.isAllowedToCall.returns(true);\n  const ComptrollerLensFactory = await smock.mock<ComptrollerLens__factory>(\"ComptrollerLens\");\n  const ComptrollerFactory = await smock.mock<ComptrollerMock__factory>(\"ComptrollerMock\");\n  const comptroller = await ComptrollerFactory.deploy();\n  const comptrollerLens = await ComptrollerLensFactory.deploy();\n  await comptroller._setAccessControl(accessControl.address);\n  await comptroller._setComptrollerLens(comptrollerLens.address);\n  await comptroller._setPriceOracle(oracle.address);\n  await comptroller._setLiquidationIncentive(convertToUnit(\"1\", 18));\n  await protocolShareReserve.MAX_PERCENT.returns(\"100\");\n\n  const tokenFactory = await ethers.getContractFactory(\"BEP20Harness\");\n  const usdt = (await tokenFactory.deploy(\n    bigNumber18.mul(100000000),\n    \"usdt\",\n    BigNumber.from(18),\n    \"BEP20 usdt\",\n  )) as BEP20Harness;\n\n  const eth = (await tokenFactory.deploy(\n    bigNumber18.mul(100000000),\n    \"eth\",\n    BigNumber.from(18),\n    \"BEP20 eth\",\n  )) as BEP20Harness;\n\n  const wbnb = (await tokenFactory.deploy(\n    bigNumber18.mul(100000000),\n    \"wbnb\",\n    BigNumber.from(18),\n    \"BEP20 wbnb\",\n  )) as BEP20Harness;\n\n  const interestRateModelHarnessFactory = await ethers.getContractFactory(\"InterestRateModelHarness\");\n  const InterestRateModelHarness = (await interestRateModelHarnessFactory.deploy(\n    BigNumber.from(18).mul(5),\n  )) as InterestRateModelHarness;\n\n  const vTokenFactory = await ethers.getContractFactory(\"VBep20Harness\");\n  const vusdt = (await vTokenFactory.deploy(\n    usdt.address,\n    comptroller.address,\n    InterestRateModelHarness.address,\n    bigNumber18,\n    \"VToken usdt\",\n    \"vusdt\",\n    vTokenDecimals,\n    wallet.address,\n  )) as VBep20Harness;\n  const veth = (await vTokenFactory.deploy(\n    eth.address,\n    comptroller.address,\n    InterestRateModelHarness.address,\n    bigNumber18,\n    \"VToken eth\",\n    \"veth\",\n    vTokenDecimals,\n    wallet.address,\n  )) as VBep20Harness;\n  const vbnb = (await vTokenFactory.deploy(\n    wbnb.address,\n    comptroller.address,\n    InterestRateModelHarness.address,\n    bigNumber18,\n    \"VToken bnb\",\n    \"vbnb\",\n    vTokenDecimals,\n    wallet.address,\n  )) as VBep20Harness;\n\n  //0.2 reserve factor\n  await veth._setReserveFactor(bigNumber16.mul(20));\n  await vusdt._setReserveFactor(bigNumber16.mul(20));\n\n  oracle.getUnderlyingPrice.returns((vToken: string) => {\n    if (vToken == vusdt.address) {\n      return convertToUnit(1, 18);\n    } else if (vToken == veth.address) {\n      return convertToUnit(1200, 18);\n    }\n  });\n\n  oracle.getPrice.returns((token: string) => {\n    if (token == xvs.address) {\n      return convertToUnit(3, 18);\n    }\n  });\n\n  const half = convertToUnit(\"0.5\", 18);\n  await comptroller._supportMarket(vusdt.address);\n  await comptroller._setCollateralFactor(vusdt.address, half);\n  await comptroller._supportMarket(veth.address);\n  await comptroller._setCollateralFactor(veth.address, half);\n\n  await eth.transfer(user1.address, bigNumber18.mul(100));\n  await usdt.transfer(user2.address, bigNumber18.mul(10000));\n\n  await comptroller._setMarketSupplyCaps([vusdt.address, veth.address], [bigNumber18.mul(10000), bigNumber18.mul(100)]);\n\n  await comptroller._setMarketBorrowCaps([vusdt.address, veth.address], [bigNumber18.mul(10000), bigNumber18.mul(100)]);\n\n  const xvsFactory = await ethers.getContractFactory(\"XVS\");\n  const xvs: XVS = (await xvsFactory.deploy(wallet.address)) as XVS;\n\n  const xvsStoreFactory = await ethers.getContractFactory(\"XVSStore\");\n  const xvsStore: XVSStore = (await xvsStoreFactory.deploy()) as XVSStore;\n\n  const xvsVaultFactory = await ethers.getContractFactory(\"XVSVaultScenario\");\n  const xvsVault: XVSVaultScenario = (await xvsVaultFactory.deploy()) as XVSVaultScenario;\n\n  await xvsStore.setNewOwner(xvsVault.address);\n  await xvsVault.setXvsStore(xvs.address, xvsStore.address);\n  await xvsVault.setAccessControl(accessControl.address);\n\n  await xvs.transfer(xvsStore.address, bigNumber18.mul(1000));\n  await xvs.transfer(user1.address, bigNumber18.mul(1000000));\n  await xvs.transfer(user2.address, bigNumber18.mul(1000000));\n  await xvs.transfer(user3.address, bigNumber18.mul(1000000));\n\n  await xvsStore.setRewardToken(xvs.address, true);\n\n  const lockPeriod = 300;\n  const allocPoint = 100;\n  const poolId = 0;\n  const rewardPerBlock = bigNumber18.mul(1);\n  await xvsVault.add(xvs.address, allocPoint, xvs.address, rewardPerBlock, lockPeriod);\n\n  const primeLiquidityProviderFactory = await ethers.getContractFactory(\"PrimeLiquidityProvider\");\n  const primeLiquidityProvider = await upgrades.deployProxy(\n    primeLiquidityProviderFactory,\n    [accessControl.address, [xvs.address, usdt.address, eth.address], [10, 10, 10]],\n    {},\n  );\n\n  const primeFactory = await ethers.getContractFactory(\"PrimeScenario\");\n  const prime: PrimeScenario = await upgrades.deployProxy(\n    primeFactory,\n    [\n      xvsVault.address,\n      xvs.address,\n      0,\n      1,\n      2,\n      accessControl.address,\n      protocolShareReserve.address,\n      primeLiquidityProvider.address,\n      comptroller.address,\n      oracle.address,\n      10,\n    ],\n    {\n      constructorArgs: [wbnb.address, vbnb.address, 10512000],\n      unsafeAllow: [\"constructor\"],\n    },\n  );\n\n  await xvsVault.setPrimeToken(prime.address, xvs.address, poolId);\n  await prime.setLimit(1000, 1000);\n  await prime.addMarket(vusdt.address, bigNumber18.mul(\"1\"), bigNumber18.mul(\"1\"));\n  await prime.addMarket(veth.address, bigNumber18.mul(\"1\"), bigNumber18.mul(\"1\"));\n  await comptroller._setPrimeToken(prime.address);\n  await prime.togglePause();\n\n  return {\n    oracle,\n    comptroller,\n    comptrollerLens,\n    accessControl,\n    usdt,\n    vusdt,\n    eth,\n    veth,\n    xvsVault,\n    xvs,\n    xvsStore,\n    prime,\n    protocolShareReserve,\n    primeLiquidityProvider,\n  };\n}\n\ndescribe(\"PoC\", () => {\n  let deployer: Signer;\n  let user1: Signer;\n  let user2: Signer;\n  let user3: Signer;\n  let comptroller: MockContract<ComptrollerMock>;\n  let prime: PrimeScenario;\n  let vusdt: VBep20Harness;\n  let veth: VBep20Harness;\n  let usdt: BEP20Harness;\n  let eth: BEP20Harness;\n  let xvsVault: XVSVault;\n  let xvs: XVS;\n  let oracle: FakeContract<ResilientOracleInterface>;\n  let protocolShareReserve: FakeContract<IProtocolShareReserve>;\n  let primeLiquidityProvider: PrimeLiquidityProvider;\n  let vbnb: VBep20Harness;\n  let bnb: BEP20Harness;\n\n  before(async () => {\n    [deployer, user1, user2, user3] = await ethers.getSigners();\n    ({\n      comptroller,\n      prime,\n      vusdt,\n      veth,\n      usdt,\n      eth,\n      xvsVault,\n      xvs,\n      oracle,\n      protocolShareReserve,\n      primeLiquidityProvider,\n    } = await loadFixture(deployProtocol));\n\n    await protocolShareReserve.getUnreleasedFunds.returns(\"0\");\n    await protocolShareReserve.getPercentageDistribution.returns(\"100\");\n\n    await xvs.connect(user1).approve(xvsVault.address, bigNumber18.mul(10000));\n    await xvsVault.connect(user1).deposit(xvs.address, 0, bigNumber18.mul(10000));\n    await mine(90 * 24 * 60 * 60);\n    await prime.connect(user1).claim();\n\n    await xvs.connect(user2).approve(xvsVault.address, bigNumber18.mul(100));\n    await xvsVault.connect(user2).deposit(xvs.address, 0, bigNumber18.mul(100));\n\n    await eth.connect(user1).approve(veth.address, bigNumber18.mul(90));\n    await veth.connect(user1).mint(bigNumber18.mul(90));\n\n    await usdt.connect(user2).approve(vusdt.address, bigNumber18.mul(9000));\n    await vusdt.connect(user2).mint(bigNumber18.mul(9000));\n\n    await comptroller.connect(user1).enterMarkets([vusdt.address, veth.address]);\n\n    await comptroller.connect(user2).enterMarkets([vusdt.address, veth.address]);\n\n    await vusdt.connect(user1).borrow(bigNumber18.mul(5));\n    await veth.connect(user2).borrow(bigNumber18.mul(1));\n\n    const tokenFactory = await ethers.getContractFactory(\"BEP20Harness\");\n    bnb = (await tokenFactory.deploy(\n      bigNumber18.mul(100000000),\n      \"bnb\",\n      BigNumber.from(18),\n      \"BEP20 bnb\",\n    )) as BEP20Harness;\n\n    const interestRateModelHarnessFactory = await ethers.getContractFactory(\"InterestRateModelHarness\");\n    const InterestRateModelHarness = (await interestRateModelHarnessFactory.deploy(\n      BigNumber.from(18).mul(5),\n    )) as InterestRateModelHarness;\n\n    const vTokenFactory = await ethers.getContractFactory(\"VBep20Harness\");\n    vbnb = (await vTokenFactory.deploy(\n      bnb.address,\n      comptroller.address,\n      InterestRateModelHarness.address,\n      bigNumber18,\n      \"VToken bnb\",\n      \"vbnb\",\n      BigNumber.from(8),\n      deployer.getAddress(),\n    )) as VBep20Harness;\n\n    await vbnb._setReserveFactor(bigNumber16.mul(20));\n    await primeLiquidityProvider.initializeTokens([bnb.address]);\n\n    oracle.getUnderlyingPrice.returns((vToken: string) => {\n      if (vToken == vusdt.address) {\n        return convertToUnit(1, 18);\n      } else if (vToken == veth.address) {\n        return convertToUnit(1200, 18);\n      } else if (vToken == vbnb.address) {\n        return convertToUnit(300, 18);\n      }\n    });\n\n    oracle.getPrice.returns((token: string) => {\n      if (token == xvs.address) {\n        return convertToUnit(3, 18);\n      }\n    });\n\n    const half = convertToUnit(\"0.5\", 8);\n    await comptroller._supportMarket(vbnb.address);\n    await comptroller._setCollateralFactor(vbnb.address, half);\n\n    bnb.transfer(user3.getAddress(), bigNumber18.mul(100));\n\n    await comptroller._setMarketSupplyCaps([vbnb.address], [bigNumber18.mul(100)]);\n    await comptroller._setMarketBorrowCaps([vbnb.address], [bigNumber18.mul(100)]);\n\n    await bnb.connect(user3).approve(vbnb.address, bigNumber18.mul(90));\n    await vbnb.connect(user3).mint(bigNumber18.mul(90));\n\n    await vbnb.connect(user2).borrow(bigNumber18.mul(1));\n\n    await comptroller._setPrimeToken(prime.address);\n  });\n\n  it(\"PoC\", async () => {\n    const bob = user3;\n    // Bob deposits XVS in the vault\n    await xvs.connect(bob).approve(xvsVault.address, bigNumber18.mul(2000));\n    await xvsVault.connect(bob).deposit(xvs.address, 0, bigNumber18.mul(2000));\n    await prime.issue(false, [bob.getAddress()]);\n    await prime.addMarket(vbnb.address, bigNumber18.mul(1), bigNumber18.mul(1));\n\n    // Bob mints vBNB/deposits BNB. This calls Prime.accrueInterestAndUpdateScore\n    await bnb.connect(bob).approve(vbnb.address, bigNumber18.mul(90));\n    await vbnb.connect(bob).mint(bigNumber18.mul(1));\n\n    let market = await prime.markets(vbnb.address);\n\n    // Expect that market.sumOfMembersScore is not 0. This means that the score was updated\n    expect(market.sumOfMembersScore).to.not.equal(0);\n\n    // We make the PSR.getUnreleasedFunds to return 103683. This lets Prime contract know that\n    // there are unreleased funds and rewardIndex should be updated.\n    await protocolShareReserve.getUnreleasedFunds.returns(103683);\n\n    // Call accrueInterest manually.\n    //\n    // Since there are unreleased funds AND the sumOfMembersScore !== 0,\n    // the reward index should be updated.\n    await prime.accrueInterest(vbnb.address);\n    market = await prime.markets(vbnb.address);\n\n    // The reward index should be > 0, but it is not updated.\n    expect(market.rewardIndex).to.equal(0);\n  });\n});\n```\n</details>\n\n### Recommended Mitigation Steps\n\nMake sure that underlying token decimals are used instead of vToken decimals when calculating `capital` in `Prime._calculateScore` function.\n\n```solidity\n    (uint256 capital, , ) = _capitalForScore(xvsBalanceForScore, borrow, supply, market);\n    capital = capital * (10 ** (18 - IERC20Upgradeable(_getUnderlying(market)).decimals()));\n```\n\n**[chechu (Venus) confirmed via duplicate issue 588 and commented](https://github.com/code-423n4/2023-09-venus-findings/issues/588):**\n > Fixed. See [here](https://github.com/VenusProtocol/venus-protocol/commit/f1fecacada4bb5d7e4b8cad5b6ca498f2d0d16be) and [here](https://github.com/VenusProtocol/venus-protocol/commit/8ac02bc898607d775969694469e012bfbcf1a3cc)\n\n**[0xDjango (Judge) commented](https://github.com/code-423n4/2023-09-venus-findings/issues/122#issuecomment-1793594920):**\n > Agree with high severity as the core mechanic of interest calculation is incorrect.\n\n***\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-09-venus",
  "Code": [
    {
      "filename": "contracts/Tokens/Prime/Prime.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { SafeERC20Upgradeable, IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { MaxLoopsLimitHelper } from \"@venusprotocol/isolated-pools/contracts/MaxLoopsLimitHelper.sol\";\n\nimport { PrimeStorageV1 } from \"./PrimeStorage.sol\";\nimport { Scores } from \"./libs/Scores.sol\";\n\nimport { IPrimeLiquidityProvider } from \"./Interfaces/IPrimeLiquidityProvider.sol\";\nimport { IXVSVault } from \"./Interfaces/IXVSVault.sol\";\nimport { IVToken } from \"./Interfaces/IVToken.sol\";\nimport { IProtocolShareReserve } from \"./Interfaces/IProtocolShareReserve.sol\";\nimport { IIncomeDestination } from \"./Interfaces/IIncomeDestination.sol\";\nimport { InterfaceComptroller } from \"./Interfaces/InterfaceComptroller.sol\";\n\nerror MarketNotSupported();\nerror InvalidLimit();\nerror IneligibleToClaim();\nerror WaitMoreTime();\nerror UserHasNoPrimeToken();\nerror InvalidCaller();\nerror InvalidComptroller();\nerror NoScoreUpdatesRequired();\nerror MarketAlreadyExists();\nerror InvalidAddress();\nerror InvalidBlocksPerYear();\nerror InvalidAlphaArguments();\nerror InvalidVToken();\n\n/// @custom:security-contact https://github.com/VenusProtocol/venus-protocol\ncontract Prime is IIncomeDestination, AccessControlledV8, PausableUpgradeable, MaxLoopsLimitHelper, PrimeStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice total blocks per year\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint256 public immutable BLOCKS_PER_YEAR;\n\n    /// @notice address of WBNB contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable WBNB;\n\n    /// @notice address of VBNB contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable VBNB;\n\n    /// @notice Emitted when prime token is minted\n    event Mint(address indexed user, bool isIrrevocable);\n\n    /// @notice Emitted when prime token is burned\n    event Burn(address indexed user);\n\n    /// @notice Emitted asset state is update by protocol share reserve\n    event UpdatedAssetsState(address indexed comptroller, address indexed asset);\n\n    /// @notice Emitted when a market is added to prime program\n    event MarketAdded(address indexed market, uint256 indexed supplyMultiplier, uint256 indexed borrowMultiplier);\n\n    /// @notice Emitted when mint limits are updated\n    event MintLimitsUpdated(\n        uint256 indexed oldIrrevocableLimit,\n        uint256 indexed oldRevocableLimit,\n        uint256 indexed newIrrevocableLimit,\n        uint256 newRevocableLimit\n    );\n\n    /// @notice Emitted when user score is updated\n    event UserScoreUpdated(address indexed user);\n\n    /// @notice Emitted when alpha is updated\n    event AlphaUpdated(\n        uint128 indexed oldNumerator,\n        uint128 indexed oldDenominator,\n        uint128 indexed newNumerator,\n        uint128 newDenominator\n    );\n\n    /// @notice Emitted when multiplier is updated\n    event MultiplierUpdated(\n        address indexed market,\n        uint256 indexed oldSupplyMultiplier,\n        uint256 indexed oldBorrowMultiplier,\n        uint256 newSupplyMultiplier,\n        uint256 newBorrowMultiplier\n    );\n\n    /// @notice Emitted when interest is claimed\n    event InterestClaimed(address indexed user, address indexed market, uint256 amount);\n\n    /// @notice Emitted when revocable token is upgraded to irrevocable token\n    event TokenUpgraded(address indexed user);\n\n    /**\n     * @notice Prime constructor\n     * @param _wbnb Address of WBNB\n     * @param _vbnb Address of VBNB\n     * @param _blocksPerYear total blocks per year\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _wbnb, address _vbnb, uint256 _blocksPerYear) {\n        if (_wbnb == address(0)) revert InvalidAddress();\n        if (_vbnb == address(0)) revert InvalidAddress();\n        if (_blocksPerYear == 0) revert InvalidBlocksPerYear();\n        WBNB = _wbnb;\n        VBNB = _vbnb;\n        BLOCKS_PER_YEAR = _blocksPerYear;\n\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Prime initializer\n     * @param _xvsVault Address of XVSVault\n     * @param _xvsVaultRewardToken Address of XVSVault reward token\n     * @param _xvsVaultPoolId Pool id of XVSVault\n     * @param _alphaNumerator numerator of alpha. If alpha is 0.5 then numerator is 1\n     * @param _alphaDenominator denominator of alpha. If alpha is 0.5 then denominator is 2\n     * @param _accessControlManager Address of AccessControlManager\n     * @param _protocolShareReserve Address of ProtocolShareReserve\n     * @param _primeLiquidityProvider Address of PrimeLiquidityProvider\n     * @param _comptroller Address of Comptroller\n     * @param _oracle Address of Oracle\n     * @param _loopsLimit Maximum number of loops allowed in a single transaction\n     */\n    function initialize(\n        address _xvsVault,\n        address _xvsVaultRewardToken,\n        uint256 _xvsVaultPoolId,\n        uint128 _alphaNumerator,\n        uint128 _alphaDenominator,\n        address _accessControlManager,\n        address _protocolShareReserve,\n        address _primeLiquidityProvider,\n        address _comptroller,\n        address _oracle,\n        uint256 _loopsLimit\n    ) external virtual initializer {\n        if (_xvsVault == address(0)) revert InvalidAddress();\n        if (_xvsVaultRewardToken == address(0)) revert InvalidAddress();\n        if (_protocolShareReserve == address(0)) revert InvalidAddress();\n        if (_comptroller == address(0)) revert InvalidAddress();\n        if (_oracle == address(0)) revert InvalidAddress();\n        if (_primeLiquidityProvider == address(0)) revert InvalidAddress();\n        _checkAlphaArguments(_alphaNumerator, _alphaDenominator);\n\n        alphaNumerator = _alphaNumerator;\n        alphaDenominator = _alphaDenominator;\n        xvsVaultRewardToken = _xvsVaultRewardToken;\n        xvsVaultPoolId = _xvsVaultPoolId;\n        xvsVault = _xvsVault;\n        nextScoreUpdateRoundId = 0;\n        protocolShareReserve = _protocolShareReserve;\n        primeLiquidityProvider = _primeLiquidityProvider;\n        comptroller = _comptroller;\n        oracle = ResilientOracleInterface(_oracle);\n\n        __AccessControlled_init(_accessControlManager);\n        __Pausable_init();\n        _setMaxLoopsLimit(_loopsLimit);\n\n        _pause();\n    }\n\n    /**\n     * @notice Returns boosted pending interest accrued for a user for all markets\n     * @param user the account for which to get the accrued interests\n     * @return pendingInterests the number of underlying tokens accrued by the user for all markets\n     */\n    function getPendingInterests(address user) external returns (PendingInterest[] memory pendingInterests) {\n        address[] storage _allMarkets = allMarkets;\n        PendingInterest[] memory pendingInterests = new PendingInterest[](_allMarkets.length);\n\n        for (uint256 i = 0; i < _allMarkets.length; ) {\n            address market = _allMarkets[i];\n            uint256 interestAccrued = getInterestAccrued(market, user);\n            uint256 accrued = interests[market][user].accrued;\n\n            pendingInterests[i] = PendingInterest({\n                market: IVToken(market).underlying(),\n                amount: interestAccrued + accrued\n            });\n\n            unchecked {\n                i++;\n            }\n        }\n\n        return pendingInterests;\n    }\n\n    /**\n     * @notice Update total score of multiple users and market\n     * @param users accounts for which we need to update score\n     */\n    function updateScores(address[] memory users) external {\n        if (pendingScoreUpdates == 0) revert NoScoreUpdatesRequired();\n        if (nextScoreUpdateRoundId == 0) revert NoScoreUpdatesRequired();\n\n        for (uint256 i = 0; i < users.length; ) {\n            address user = users[i];\n\n            if (!tokens[user].exists) revert UserHasNoPrimeToken();\n            if (isScoreUpdated[nextScoreUpdateRoundId][user]) continue;\n\n            address[] storage _allMarkets = allMarkets;\n            for (uint256 j = 0; j < _allMarkets.length; ) {\n                address market = _allMarkets[j];\n                _executeBoost(user, market);\n                _updateScore(user, market);\n\n                unchecked {\n                    j++;\n                }\n            }\n\n            pendingScoreUpdates--;\n            isScoreUpdated[nextScoreUpdateRoundId][user] = true;\n\n            unchecked {\n                i++;\n            }\n\n            emit UserScoreUpdated(user);\n        }\n    }\n\n    /**\n     * @notice Update value of alpha\n     * @param _alphaNumerator numerator of alpha. If alpha is 0.5 then numerator is 1\n     * @param _alphaDenominator denominator of alpha. If alpha is 0.5 then denominator is 2\n     */\n    function updateAlpha(uint128 _alphaNumerator, uint128 _alphaDenominator) external {\n        _checkAccessAllowed(\"updateAlpha(uint128,uint128)\");\n        _checkAlphaArguments(_alphaNumerator, _alphaDenominator);\n\n        emit AlphaUpdated(alphaNumerator, alphaDenominator, _alphaNumerator, _alphaDenominator);\n\n        alphaNumerator = _alphaNumerator;\n        alphaDenominator = _alphaDenominator;\n\n        for (uint256 i = 0; i < allMarkets.length; ) {\n            accrueInterest(allMarkets[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        _startScoreUpdateRound();\n    }\n\n    /**\n     * @notice Update multipliers for a market\n     * @param market address of the market vToken\n     * @param supplyMultiplier new supply multiplier for the market, scaled by 1e18\n     * @param borrowMultiplier new borrow multiplier for the market, scaled by 1e18\n     */\n    function updateMultipliers(address market, uint256 supplyMultiplier, uint256 borrowMultiplier) external {\n        _checkAccessAllowed(\"updateMultipliers(address,uint256,uint256)\");\n        if (!markets[market].exists) revert MarketNotSupported();\n\n        accrueInterest(market);\n\n        emit MultiplierUpdated(\n            market,\n            markets[market].supplyMultiplier,\n            markets[market].borrowMultiplier,\n            supplyMultiplier,\n            borrowMultiplier\n        );\n        markets[market].supplyMultiplier = supplyMultiplier;\n        markets[market].borrowMultiplier = borrowMultiplier;\n\n        _startScoreUpdateRound();\n    }\n\n    /**\n     * @notice Add a market to prime program\n     * @param vToken address of the market vToken\n     * @param supplyMultiplier the multiplier for supply cap. It should be converted to 1e18\n     * @param borrowMultiplier the multiplier for borrow cap. It should be converted to 1e18\n     */\n    function addMarket(address vToken, uint256 supplyMultiplier, uint256 borrowMultiplier) external {\n        _checkAccessAllowed(\"addMarket(address,uint256,uint256)\");\n        if (markets[vToken].exists) revert MarketAlreadyExists();\n\n        bool isMarketExist = InterfaceComptroller(comptroller).markets(vToken);\n        if (!isMarketExist) revert InvalidVToken();\n\n        markets[vToken].rewardIndex = 0;\n        markets[vToken].supplyMultiplier = supplyMultiplier;\n        markets[vToken].borrowMultiplier = borrowMultiplier;\n        markets[vToken].sumOfMembersScore = 0;\n        markets[vToken].exists = true;\n\n        vTokenForAsset[_getUnderlying(vToken)] = vToken;\n\n        allMarkets.push(vToken);\n        _startScoreUpdateRound();\n\n        _ensureMaxLoops(allMarkets.length);\n\n        emit MarketAdded(vToken, supplyMultiplier, borrowMultiplier);\n    }\n\n    /**\n     * @notice Set limits for total tokens that can be minted\n     * @param _irrevocableLimit total number of irrevocable tokens that can be minted\n     * @param _revocableLimit total number of revocable tokens that can be minted\n     */\n    function setLimit(uint256 _irrevocableLimit, uint256 _revocableLimit) external {\n        _checkAccessAllowed(\"setLimit(uint256,uint256)\");\n        if (_irrevocableLimit < totalIrrevocable || _revocableLimit < totalRevocable) revert InvalidLimit();\n\n        emit MintLimitsUpdated(irrevocableLimit, revocableLimit, _irrevocableLimit, _revocableLimit);\n\n        revocableLimit = _revocableLimit;\n        irrevocableLimit = _irrevocableLimit;\n    }\n\n    /**\n     * @notice Directly issue prime tokens to users\n     * @param isIrrevocable are the tokens being issued\n     * @param users list of address to issue tokens to\n     */\n    function issue(bool isIrrevocable, address[] calldata users) external {\n        _checkAccessAllowed(\"issue(bool,address[])\");\n\n        if (isIrrevocable) {\n            for (uint256 i = 0; i < users.length; ) {\n                Token storage userToken = tokens[users[i]];\n                if (userToken.exists && !userToken.isIrrevocable) {\n                    _upgrade(users[i]);\n                } else {\n                    _mint(true, users[i]);\n                    _initializeMarkets(users[i]);\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < users.length; ) {\n                _mint(false, users[i]);\n                _initializeMarkets(users[i]);\n                delete stakedAt[users[i]];\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Executed by XVSVault whenever user's XVSVault balance changes\n     * @param user the account address whose balance was updated\n     */\n    function xvsUpdated(address user) external {\n        uint256 totalStaked = _xvsBalanceOfUser(user);\n        bool isAccountEligible = isEligible(totalStaked);\n\n        if (tokens[user].exists && !isAccountEligible) {\n            if (tokens[user].isIrrevocable) {\n                _accrueInterestAndUpdateScore(user);\n            } else {\n                _burn(user);\n            }\n        } else if (!isAccountEligible && !tokens[user].exists && stakedAt[user] > 0) {\n            stakedAt[user] = 0;\n        } else if (stakedAt[user] == 0 && isAccountEligible && !tokens[user].exists) {\n            stakedAt[user] = block.timestamp;\n        } else if (tokens[user].exists && isAccountEligible) {\n            _accrueInterestAndUpdateScore(user);\n        }\n    }\n\n    /**\n     * @notice accrues interes and updates score for an user for a specific market\n     * @param user the account address for which to accrue interest and update score\n     * @param market the market for which to accrue interest and update score\n     */\n    function accrueInterestAndUpdateScore(address user, address market) external {\n        _executeBoost(user, market);\n        _updateScore(user, market);\n    }\n\n    /**\n     * @notice For claiming prime token when staking period is completed\n     */\n    function claim() external {\n        if (stakedAt[msg.sender] == 0) revert IneligibleToClaim();\n        if (block.timestamp - stakedAt[msg.sender] < STAKING_PERIOD) revert WaitMoreTime();\n\n        stakedAt[msg.sender] = 0;\n\n        _mint(false, msg.sender);\n        _initializeMarkets(msg.sender);\n    }\n\n    /**\n     * @notice For burning any prime token\n     * @param user the account address for which the prime token will be burned\n     */\n    function burn(address user) external {\n        _checkAccessAllowed(\"burn(address)\");\n        _burn(user);\n    }\n\n    /**\n     * @notice To pause or unpause claiming of interest\n     */\n    function togglePause() external {\n        _checkAccessAllowed(\"togglePause()\");\n        if (paused()) {\n            _unpause();\n        } else {\n            _pause();\n        }\n    }\n\n    /**\n     * @notice For user to claim boosted yield\n     * @param vToken the market for which claim the accrued interest\n     * @return amount the amount of tokens transferred to the user\n     */\n    function claimInterest(address vToken) external whenNotPaused returns (uint256) {\n        return _claimInterest(vToken, msg.sender);\n    }\n\n    /**\n     * @notice For user to claim boosted yield\n     * @param vToken the market for which claim the accrued interest\n     * @param user the user for which claim the accrued interest\n     * @return amount the amount of tokens transferred to the user\n     */\n    function claimInterest(address vToken, address user) external whenNotPaused returns (uint256) {\n        return _claimInterest(vToken, user);\n    }\n\n    /**\n     * @notice Callback by ProtocolShareReserve to update assets state when funds are released to this contract\n     * @param _comptroller The address of the Comptroller whose income is distributed\n     * @param asset The address of the asset whose income is distributed\n     */\n    function updateAssetsState(address _comptroller, address asset) external {\n        if (msg.sender != protocolShareReserve) revert InvalidCaller();\n        if (comptroller != _comptroller) revert InvalidComptroller();\n\n        address vToken = vTokenForAsset[asset];\n        if (vToken == address(0)) revert MarketNotSupported();\n\n        IVToken market = IVToken(vToken);\n        unreleasedPSRIncome[_getUnderlying(address(market))] = 0;\n\n        emit UpdatedAssetsState(comptroller, asset);\n    }\n\n    /**\n     * @notice Retrieves an array of all available markets\n     * @return an array of addresses representing all available markets\n     */\n    function getAllMarkets() external view returns (address[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice fetch the numbers of seconds remaining for staking period to complete\n     * @param user the account address for which we are checking the remaining time\n     * @return timeRemaining the number of seconds the user needs to wait to claim prime token\n     */\n    function claimTimeRemaining(address user) external view returns (uint256) {\n        if (stakedAt[user] == 0) return STAKING_PERIOD;\n\n        uint256 totalTimeStaked = block.timestamp - stakedAt[user];\n        if (totalTimeStaked < STAKING_PERIOD) {\n            return STAKING_PERIOD - totalTimeStaked;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns supply and borrow APR for user for a given market\n     * @param market the market for which to fetch the APR\n     * @param user the account for which to get the APR\n     * @return supplyAPR supply APR of the user in BPS\n     * @return borrowAPR borrow APR of the user in BPS\n     */\n    function calculateAPR(address market, address user) external view returns (uint256 supplyAPR, uint256 borrowAPR) {\n        IVToken vToken = IVToken(market);\n        uint256 borrow = vToken.borrowBalanceStored(user);\n        uint256 exchangeRate = vToken.exchangeRateStored();\n        uint256 balanceOfAccount = vToken.balanceOf(user);\n        uint256 supply = (exchangeRate * balanceOfAccount) / EXP_SCALE;\n\n        uint256 userScore = interests[market][user].score;\n        uint256 totalScore = markets[market].sumOfMembersScore;\n\n        uint256 xvsBalanceForScore = _xvsBalanceForScore(_xvsBalanceOfUser(user));\n        (, uint256 cappedSupply, uint256 cappedBorrow) = _capitalForScore(\n            xvsBalanceForScore,\n            borrow,\n            supply,\n            address(vToken)\n        );\n\n        return _calculateUserAPR(market, supply, borrow, cappedSupply, cappedBorrow, userScore, totalScore);\n    }\n\n    /**\n     * @notice Returns supply and borrow APR for estimated supply, borrow and XVS staked\n     * @param market the market for which to fetch the APR\n     * @param user the account for which to get the APR\n     * @param borrow hypothetical borrow amount\n     * @param supply hypothetical supply amount\n     * @param xvsStaked hypothetical staked XVS amount\n     * @return supplyAPR supply APR of the user in BPS\n     * @return borrowAPR borrow APR of the user in BPS\n     */\n    function estimateAPR(\n        address market,\n        address user,\n        uint256 borrow,\n        uint256 supply,\n        uint256 xvsStaked\n    ) external view returns (uint256 supplyAPR, uint256 borrowAPR) {\n        uint256 totalScore = markets[market].sumOfMembersScore - interests[market][user].score;\n\n        uint256 xvsBalanceForScore = _xvsBalanceForScore(xvsStaked);\n        (uint256 capital, uint256 cappedSupply, uint256 cappedBorrow) = _capitalForScore(\n            xvsBalanceForScore,\n            borrow,\n            supply,\n            market\n        );\n        uint256 userScore = Scores.calculateScore(xvsBalanceForScore, capital, alphaNumerator, alphaDenominator);\n\n        totalScore = totalScore + userScore;\n\n        return _calculateUserAPR(market, supply, borrow, cappedSupply, cappedBorrow, userScore, totalScore);\n    }\n\n    /**\n     * @notice Distributes income from market since last distribution\n     * @param vToken the market for which to distribute the income\n     */\n    function accrueInterest(address vToken) public {\n        if (!markets[vToken].exists) revert MarketNotSupported();\n\n        address underlying = _getUnderlying(vToken);\n\n        IPrimeLiquidityProvider _primeLiquidityProvider = IPrimeLiquidityProvider(primeLiquidityProvider);\n\n        uint256 totalIncomeUnreleased = IProtocolShareReserve(protocolShareReserve).getUnreleasedFunds(\n            comptroller,\n            IProtocolShareReserve.Schema.SPREAD_PRIME_CORE,\n            address(this),\n            underlying\n        );\n\n        uint256 distributionIncome = totalIncomeUnreleased - unreleasedPSRIncome[underlying];\n\n        _primeLiquidityProvider.accrueTokens(underlying);\n        uint256 totalAccruedInPLP = _primeLiquidityProvider.tokenAmountAccrued(underlying);\n        uint256 unreleasedPLPAccruedInterest = totalAccruedInPLP - unreleasedPLPIncome[underlying];\n\n        distributionIncome += unreleasedPLPAccruedInterest;\n\n        if (distributionIncome == 0) {\n            return;\n        }\n\n        unreleasedPSRIncome[underlying] = totalIncomeUnreleased;\n        unreleasedPLPIncome[underlying] = totalAccruedInPLP;\n\n        uint256 delta;\n        if (markets[vToken].sumOfMembersScore > 0) {\n            delta = ((distributionIncome * EXP_SCALE) / markets[vToken].sumOfMembersScore);\n        }\n\n        markets[vToken].rewardIndex = markets[vToken].rewardIndex + delta;\n    }\n\n    /**\n     * @notice Returns boosted interest accrued for a user\n     * @param vToken the market for which to fetch the accrued interest\n     * @param user the account for which to get the accrued interest\n     * @return interestAccrued the number of underlying tokens accrued by the user since the last accrual\n     */\n    function getInterestAccrued(address vToken, address user) public returns (uint256) {\n        accrueInterest(vToken);\n\n        return _interestAccrued(vToken, user);\n    }\n\n    /**\n     * @notice accrues interes and updates score of all markets for an user\n     * @param user the account address for which to accrue interest and update score\n     */\n    function _accrueInterestAndUpdateScore(address user) internal {\n        address[] storage _allMarkets = allMarkets;\n        for (uint256 i = 0; i < _allMarkets.length; ) {\n            _executeBoost(user, _allMarkets[i]);\n            _updateScore(user, _allMarkets[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * @notice Initializes all the markets for the user when a prime token is minted\n     * @param account the account address for which markets needs to be initialized\n     */\n    function _initializeMarkets(address account) internal {\n        address[] storage _allMarkets = allMarkets;\n        for (uint256 i = 0; i < _allMarkets.length; ) {\n            address market = _allMarkets[i];\n            accrueInterest(market);\n\n            interests[market][account].rewardIndex = markets[market].rewardIndex;\n\n            uint256 score = _calculateScore(market, account);\n            interests[market][account].score = score;\n            markets[market].sumOfMembersScore = markets[market].sumOfMembersScore + score;\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * @notice calculate the current score of user\n     * @param market the market for which to calculate the score\n     * @param user the account for which to calculate the score\n     * @return score the score of the user\n     */\n    function _calculateScore(address market, address user) internal returns (uint256) {\n        uint256 xvsBalanceForScore = _xvsBalanceForScore(_xvsBalanceOfUser(user));\n\n        IVToken vToken = IVToken(market);\n        uint256 borrow = vToken.borrowBalanceStored(user);\n        uint256 exchangeRate = vToken.exchangeRateStored();\n        uint256 balanceOfAccount = vToken.balanceOf(user);\n        uint256 supply = (exchangeRate * balanceOfAccount) / EXP_SCALE;\n\n        address xvsToken = IXVSVault(xvsVault).xvsAddress();\n        oracle.updateAssetPrice(xvsToken);\n        oracle.updatePrice(market);\n\n        (uint256 capital, , ) = _capitalForScore(xvsBalanceForScore, borrow, supply, market);\n        capital = capital * (10 ** (18 - vToken.decimals()));\n\n        return Scores.calculateScore(xvsBalanceForScore, capital, alphaNumerator, alphaDenominator);\n    }\n\n    /**\n     * @notice To transfer the accrued interest to user\n     * @param vToken the market for which to claim\n     * @param user the account for which to get the accrued interest\n     * @return amount the amount of tokens transferred to the user\n     */\n    function _claimInterest(address vToken, address user) internal returns (uint256) {\n        uint256 amount = getInterestAccrued(vToken, user);\n        amount += interests[vToken][user].accrued;\n\n        interests[vToken][user].rewardIndex = markets[vToken].rewardIndex;\n        interests[vToken][user].accrued = 0;\n\n        address underlying = _getUnderlying(vToken);\n        IERC20Upgradeable asset = IERC20Upgradeable(underlying);\n\n        if (amount > asset.balanceOf(address(this))) {\n            address[] memory assets = new address[](1);\n            assets[0] = address(asset);\n            IProtocolShareReserve(protocolShareReserve).releaseFunds(comptroller, assets);\n            if (amount > asset.balanceOf(address(this))) {\n                IPrimeLiquidityProvider(primeLiquidityProvider).releaseFunds(address(asset));\n                unreleasedPLPIncome[underlying] = 0;\n            }\n        }\n\n        asset.safeTransfer(user, amount);\n\n        emit InterestClaimed(user, vToken, amount);\n\n        return amount;\n    }\n\n    /**\n     * @notice Used to mint a new prime token\n     * @param isIrrevocable is the tokens being issued is irrevocable\n     * @param user token owner\n     */\n    function _mint(bool isIrrevocable, address user) internal {\n        if (tokens[user].exists) revert IneligibleToClaim();\n\n        tokens[user].exists = true;\n        tokens[user].isIrrevocable = isIrrevocable;\n\n        if (isIrrevocable) {\n            totalIrrevocable++;\n        } else {\n            totalRevocable++;\n        }\n\n        if (totalIrrevocable > irrevocableLimit || totalRevocable > revocableLimit) revert InvalidLimit();\n\n        emit Mint(user, isIrrevocable);\n    }\n\n    /**\n     * @notice Used to burn a new prime token\n     * @param user owner whose prime token to burn\n     */\n    function _burn(address user) internal {\n        if (!tokens[user].exists) revert UserHasNoPrimeToken();\n\n        address[] storage _allMarkets = allMarkets;\n\n        for (uint256 i = 0; i < _allMarkets.length; ) {\n            _executeBoost(user, _allMarkets[i]);\n\n            markets[_allMarkets[i]].sumOfMembersScore =\n                markets[_allMarkets[i]].sumOfMembersScore -\n                interests[_allMarkets[i]][user].score;\n            interests[_allMarkets[i]][user].score = 0;\n            interests[_allMarkets[i]][user].rewardIndex = 0;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        if (tokens[user].isIrrevocable) {\n            totalIrrevocable--;\n        } else {\n            totalRevocable--;\n        }\n\n        tokens[user].exists = false;\n        tokens[user].isIrrevocable = false;\n\n        _updateRoundAfterTokenBurned(user);\n\n        emit Burn(user);\n    }\n\n    /**\n     * @notice Used to upgrade an token\n     * @param user owner whose prime token to upgrade\n     */\n    function _upgrade(address user) internal {\n        Token storage userToken = tokens[user];\n\n        userToken.isIrrevocable = true;\n        totalIrrevocable++;\n        totalRevocable--;\n\n        if (totalIrrevocable > irrevocableLimit) revert InvalidLimit();\n\n        emit TokenUpgraded(user);\n    }\n\n    /**\n     * @notice Accrue rewards for the user. Must be called by Comptroller before changing account's borrow or supply balance.\n     * @param user account for which we need to accrue rewards\n     * @param vToken the market for which we need to accrue rewards\n     */\n    function _executeBoost(address user, address vToken) internal {\n        if (!markets[vToken].exists || !tokens[user].exists) {\n            return;\n        }\n\n        accrueInterest(vToken);\n        interests[vToken][user].accrued += _interestAccrued(vToken, user);\n        interests[vToken][user].rewardIndex = markets[vToken].rewardIndex;\n    }\n\n    /**\n     * @notice Update total score of user and market. Must be called after changing account's borrow or supply balance.\n     * @param user account for which we need to update score\n     * @param market the market for which we need to score\n     */\n    function _updateScore(address user, address market) internal {\n        if (!markets[market].exists || !tokens[user].exists) {\n            return;\n        }\n\n        uint256 score = _calculateScore(market, user);\n        markets[market].sumOfMembersScore = markets[market].sumOfMembersScore - interests[market][user].score + score;\n        interests[market][user].score = score;\n    }\n\n    /**\n     * @notice Verify new alpha arguments\n     * @param _alphaNumerator numerator of alpha. If alpha is 0.5 then numerator is 1\n     * @param _alphaDenominator denominator of alpha. If alpha is 0.5 then denominator is 2\n     */\n    function _checkAlphaArguments(uint128 _alphaNumerator, uint128 _alphaDenominator) internal {\n        if (_alphaDenominator == 0 || _alphaNumerator > _alphaDenominator) {\n            revert InvalidAlphaArguments();\n        }\n    }\n\n    /**\n     * @notice starts round to update scores of a particular or all markets\n     */\n    function _startScoreUpdateRound() internal {\n        nextScoreUpdateRoundId++;\n        totalScoreUpdatesRequired = totalIrrevocable + totalRevocable;\n        pendingScoreUpdates = totalScoreUpdatesRequired;\n    }\n\n    /**\n     * @notice update the required score updates when token is burned before round is completed\n     */\n    function _updateRoundAfterTokenBurned(address user) internal {\n        if (totalScoreUpdatesRequired > 0) totalScoreUpdatesRequired--;\n\n        if (pendingScoreUpdates > 0 && !isScoreUpdated[nextScoreUpdateRoundId][user]) {\n            pendingScoreUpdates--;\n        }\n    }\n\n    /**\n     * @notice fetch the current XVS balance of user in the XVSVault\n     * @param user the account address\n     * @return xvsBalance the XVS balance of user\n     */\n    function _xvsBalanceOfUser(address user) internal view returns (uint256) {\n        (uint256 xvs, , uint256 pendingWithdrawals) = IXVSVault(xvsVault).getUserInfo(\n            xvsVaultRewardToken,\n            xvsVaultPoolId,\n            user\n        );\n        return (xvs - pendingWithdrawals);\n    }\n\n    /**\n     * @notice calculate the current XVS balance that will be used in calculation of score\n     * @param xvs the actual XVS balance of user\n     * @return xvsBalanceForScore the XVS balance to use in score\n     */\n    function _xvsBalanceForScore(uint256 xvs) internal view returns (uint256) {\n        if (xvs > MAXIMUM_XVS_CAP) {\n            return MAXIMUM_XVS_CAP;\n        } else {\n            return xvs;\n        }\n    }\n\n    /**\n     * @notice calculate the capital for calculation of score\n     * @param xvs the actual XVS balance of user\n     * @param borrow the borrow balance of user\n     * @param supply the supply balance of user\n     * @param market the market vToken address\n     * @return capital the capital to use in calculation of score\n     * @return cappedSupply the capped supply of user\n     * @return cappedBorrow the capped borrow of use"
    }
  ]
}