{
  "Title": "Inconsistency of Reentrancy Guard",
  "Content": "The [`ScrollMessengerBase`](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/libraries/ScrollMessengerBase.sol#L54-L66) and [`ScrollGatewayBase`](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/libraries/gateway/ScrollGatewayBase.sol#L42-L54) contracts implement a `nonReentrant` modifier. Instead, consider utilizing the [ReentrancyGuardUpgradeable contract](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.9/contracts/security/ReentrancyGuardUpgradeable.sol) of the OpenZeppelin library which is a dependency in use. The reimplementation of such safety mechanisms is generally discouraged. In addition, this is inconsistent with other contracts such as [`EnforcedTxGateway`](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/gateways/EnforcedTxGateway.sol#L15), which does, in fact, use OpenZeppelin's reentrancy guard. In both cases, make sure to initialize the contracts properly if they are used for upgradeable contracts.\n\n\n***Update:** Resolved in [pull request #698](https://github.com/scroll-tech/scroll/pull/698) at commit [a798e4d](https://github.com/scroll-tech/scroll/pull/698/commits/a798e4d52524ddc388e48f9b24d437ee0b3ad85d).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/libraries/ScrollMessengerBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {ScrollConstants} from \"./constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"./IScrollMessenger.sol\";\n\n// solhint-disable var-name-mixedcase\n\nabstract contract ScrollMessengerBase is OwnableUpgradeable, IScrollMessenger {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates fee vault contract.\n    /// @param _oldFeeVault The address of old fee vault contract.\n    /// @param _newFeeVault The address of new fee vault contract.\n    event UpdateFeeVault(address _oldFeeVault, address _newFeeVault);\n\n    /*************\n     * Constants *\n     *************/\n\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/security/ReentrancyGuard.sol\n    uint256 internal constant _NOT_ENTERED = 1;\n    uint256 internal constant _ENTERED = 2;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice See {IScrollMessenger-xDomainMessageSender}\n    address public override xDomainMessageSender;\n\n    /// @notice The address of counterpart ScrollMessenger contract in L1/L2.\n    address public counterpart;\n\n    /// @notice The address of fee vault, collecting cross domain messaging fee.\n    address public feeVault;\n\n    // @note move to ScrollMessengerBase in next big refactor\n    /// @dev The status of for non-reentrant check.\n    uint256 private _lock_status;\n\n    /// @dev The storage slots for future usage.\n    uint256[46] private __gap;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_lock_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _lock_status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _lock_status = _NOT_ENTERED;\n    }\n\n    modifier notInExecution() {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            \"Message is already in execution\"\n        );\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function _initialize(address _counterpart, address _feeVault) internal {\n        OwnableUpgradeable.__Ownable_init();\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        counterpart = _counterpart;\n        feeVault = _feeVault;\n    }\n\n    // make sure only owner can send ether to messenger to avoid possible user fund loss.\n    receive() external payable onlyOwner {}\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update fee vault contract.\n    /// @dev This function can only called by contract owner.\n    /// @param _newFeeVault The address of new fee vault contract.\n    function updateFeeVault(address _newFeeVault) external onlyOwner {\n        address _oldFeeVault = feeVault;\n\n        feeVault = _newFeeVault;\n        emit UpdateFeeVault(_oldFeeVault, _newFeeVault);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to generate the correct cross domain calldata for a message.\n    /// @param _sender Message sender address.\n    /// @param _target Target contract address.\n    /// @param _value The amount of ETH pass to the target.\n    /// @param _messageNonce Nonce for the provided message.\n    /// @param _message Message to send to the target.\n    /// @return ABI encoded cross domain calldata.\n    function _encodeXDomainCalldata(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(address,address,uint256,uint256,bytes)\",\n                _sender,\n                _target,\n                _value,\n                _messageNonce,\n                _message\n            );\n    }\n}"
    }
  ]
}