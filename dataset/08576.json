{
  "Title": "[M-03] Use a safe transfer helper library for ERC20 transfers",
  "Content": "# Lines of code\n\nhttps://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBERC20PaymentTerminal.sol#L81-L89\n\n\n# Vulnerability details\n\n`JBERC20PaymentTerminal#_transferFrom` calls `IERC20#transfer` and `transferFrom` directly. There are two issues with using this interface directly:\n\n1) `JBERC20PaymentTerminal#_transferFrom` function does not check the return value of these calls. Tokens that return `false` rather than revert to indicate failed transfers may silently fail rather than reverting as expected.\n\n2) Since the IERC20 interface requires a boolean return value, attempting to transfer ERC20s with [missing return values](https://github.com/d-xo/weird-erc20#missing-return-values) will revert. This means Juicebox payment terminals cannot support a number of popular ERC20s, including USDT and BNB.\n\n[`JBERC20PaymentTerminal#_transferFrom`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBERC20PaymentTerminal.sol#L81-L89):\n\n```solidity\n  function _transferFrom(\n    address _from,\n    address payable _to,\n    uint256 _amount\n  ) internal override {\n    _from == address(this)\n      ? IERC20(token).transfer(_to, _amount)\n      : IERC20(token).transferFrom(_from, _to, _amount);\n  }\n```\n\n**Impact:** \nJuicebox payment terminals may issue project tokens to users even though their incoming token transfer failed. Juicebox payment terminals cannot support USDT, BNB, and other popular (but nonstandard) ERC20s.\n\n**Recommendation:**\nUse a safe transfer library like OpenZeppelin [SafeERC20](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20) to ensure consistent handling of ERC20 return values and abstract over [inconsistent ERC20](https://github.com/d-xo/weird-erc20) implementations.\n\nAdditionally, since payment terminals are meant to support a variety of ERC20s, consider writing simulation tests that make token transfers using payment terminals for the most popular and most unusual ERC20s.\n\n(Note also that the out of scope `JBETHERC20ProjectPayer` and `JBETHERC20SplitsPayer` contracts also call `IERC20#transfer` and `transferFrom` without a helper!)\n\nSee the following Forge test, which simulates an attempted USDT transfer. (Run this in fork mode using the `--fork-url` flag).\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport './helpers/TestBaseWorkflow.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\naddress constant USDT_ADDRESS = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n\ncontract TestWeirdERC20 is TestBaseWorkflow {\n  using SafeERC20 for IERC20Metadata;\n\n  JBController controller;\n  JBProjectMetadata _projectMetadata;\n  JBFundingCycleData _data;\n  JBFundingCycleMetadata _metadata;\n  JBGroupedSplits[] _groupedSplits;\n  JBFundAccessConstraints[] _fundAccessConstraints;\n  IJBPaymentTerminal[] _terminals;\n  JBTokenStore _tokenStore;\n  JBERC20PaymentTerminal _tetherTerminal;\n\n  IERC20Metadata usdt = IERC20Metadata(USDT_ADDRESS);\n  address _projectOwner;\n\n  uint256 WEIGHT = 1000 * 10**18;\n\n  function setUp() public override {\n    super.setUp();\n\n    _projectOwner = multisig();\n\n    _tokenStore = jbTokenStore();\n\n    controller = jbController();\n\n    _projectMetadata = JBProjectMetadata({content: 'myIPFSHash', domain: 1});\n\n    _data = JBFundingCycleData({\n      duration: 14,\n      weight: WEIGHT,\n      discountRate: 450000000,\n      ballot: IJBFundingCycleBallot(address(0))\n    });\n\n    _metadata = JBFundingCycleMetadata({\n      global: JBGlobalFundingCycleMetadata({allowSetTerminals: false, allowSetController: false}),\n      reservedRate: 5000, //50%\n      redemptionRate: 5000, //50%\n      ballotRedemptionRate: 0,\n      pausePay: false,\n      pauseDistributions: false,\n      pauseRedeem: false,\n      pauseBurn: false,\n      allowMinting: false,\n      allowChangeToken: false,\n      allowTerminalMigration: false,\n      allowControllerMigration: false,\n      holdFees: false,\n      useTotalOverflowForRedemptions: false,\n      useDataSourceForPay: false,\n      useDataSourceForRedeem: false,\n      dataSource: address(0)\n    });\n\n    _tetherTerminal = new JBERC20PaymentTerminal(\n      usdt,\n      jbLibraries().ETH(), // currency\n      jbLibraries().ETH(), // base weight currency\n      1, // JBSplitsGroupe\n      jbOperatorStore(),\n      jbProjects(),\n      jbDirectory(),\n      jbSplitsStore(),\n      jbPrices(),\n      jbPaymentTerminalStore(),\n      multisig()\n    );\n    evm.label(address(_tetherTerminal), 'TetherTerminal');\n\n    _terminals.push(_tetherTerminal);\n  }\n\n  function testTetherPaymentsRevert() public {\n    JBERC20PaymentTerminal terminal = _tetherTerminal;\n\n    _fundAccessConstraints.push(\n      JBFundAccessConstraints({\n        terminal: terminal,\n        token: address(USDT_ADDRESS),\n        distributionLimit: 10 * 10**18,\n        overflowAllowance: 5 * 10**18,\n        distributionLimitCurrency: jbLibraries().ETH(),\n        overflowAllowanceCurrency: jbLibraries().ETH()\n      })\n    );\n\n    uint256 projectId = controller.launchProjectFor(\n      _projectOwner,\n      _projectMetadata,\n      _data,\n      _metadata,\n      block.timestamp,\n      _groupedSplits,\n      _fundAccessConstraints,\n      _terminals,\n      ''\n    );\n\n    address caller = msg.sender;\n    evm.label(caller, 'caller');\n    deal(address(usdt), caller, 20 * 10**18);\n\n    evm.prank(caller);\n    usdt.safeApprove(address(terminal), 20 * 10**18);\n    evm.prank(caller);\n    terminal.pay(\n      projectId,\n      20 * 10**18,\n      address(usdt),\n      msg.sender,\n      0,\n      false,\n      'Forge test',\n      new bytes(0)\n    );\n  }\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-juicebox-v2-contest",
  "Code": [
    {
      "filename": "contracts/JBERC20PaymentTerminal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport './abstract/JBPayoutRedemptionPaymentTerminal.sol';\n\n/** \n  @notice \n  Manages the inflows and outflows of an ERC-20 token.\n\n  @dev\n  Adheres to -\n  IJBProjectPayer:  General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JBPayoutRedemptionPaymentTerminal: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n*/\ncontract JBERC20PaymentTerminal is JBPayoutRedemptionPaymentTerminal {\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  /**\n    @param _token The token that this terminal manages.\n    @param _currency The currency that this terminal's token adheres to for price feeds.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _payoutSplitsGroup The group that denotes payout splits from this terminal in the splits store.\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _splitsStore A contract that stores splits for each project.\n    @param _prices A contract that exposes price feeds.\n    @param _store A contract that stores the terminal's data.\n    @param _owner The address that will own this contract.\n  */\n  constructor(\n    IERC20Metadata _token,\n    uint256 _currency,\n    uint256 _baseWeightCurrency,\n    uint256 _payoutSplitsGroup,\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBSplitsStore _splitsStore,\n    IJBPrices _prices,\n    IJBSingleTokenPaymentTerminalStore _store,\n    address _owner\n  )\n    JBPayoutRedemptionPaymentTerminal(\n      address(_token),\n      _token.decimals(),\n      _currency,\n      _baseWeightCurrency,\n      _payoutSplitsGroup,\n      _operatorStore,\n      _projects,\n      _directory,\n      _splitsStore,\n      _prices,\n      _store,\n      _owner\n    )\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  //*********************************************************************//\n  // ---------------------- internal transactions ---------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Transfers tokens.\n\n    @param _from The address from which the transfer should originate.\n    @param _to The address to which the transfer should go.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  */\n  function _transferFrom(\n    address _from,\n    address payable _to,\n    uint256 _amount\n  ) internal override {\n    _from == address(this)\n      ? IERC20(token).transfer(_to, _amount)\n      : IERC20(token).transferFrom(_from, _to, _amount);\n  }\n\n  /** \n    @notice\n    Logic to be triggered before transferring tokens from this terminal.\n\n    @param _to The address to which the transfer is going.\n    @param _amount The amount of the transfer, as a fixed point number with the same number of decimals as this terminal.\n  */\n  function _beforeTransferTo(address _to, uint256 _amount) internal override {\n    IERC20(token).approve(_to, _amount);\n  }\n}"
    }
  ]
}