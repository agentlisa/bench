{
  "Title": "[M-08] Treating of BLOCK_TIME as permanent will cause serious economic flaws in the oracle when block times change",
  "Content": "\nPumps receive the chain BLOCK_TIME in the constructor. In every update, it is used to calculate the `blocksPassed` variable, which determines what is the maximum change in price (done in `_capReserve()`).\n\nThe issue is that BLOCK_TIME is an immutable variable in the pump, which is immutable in the Well, meaning it is basically set in stone and can only be changed through a Well redeploy and liquidity migration (very long cycle).\nHowever, BLOCK_TIME actually changes every now and then, especially in L2s.For example, the recent Bedrock upgrade in Optimism completely [changed](https://community.optimism.io/docs/developers/bedrock/differences/#the-evm) the block time generation. It is very clear this will happen many times over the course of Basin's lifetime.\n\nWhen a wrong BLOCK_TIME is used, the `_capReserve()` function will either limit price changes too strictly, or too permissively. In the too strict case, this would cause larger and large deviations between the oracle pricing and the real market prices, leading to large arb opportunities. In the too permissive case, the function will not cap changes like it is meant to, making the oracle more manipulatable than the economic model used when deploying the pump.\n\n### Impact\n\nTreating of BLOCK_TIME as permanent will cause serious economic flaws in the oracle when block times change.\n\n### Recommended Mitigation Steps\n\nThe BLOCK_TIME should be changeable, given a long enough freeze period where LPs can withdraw their tokens if they are unsatisfied with the change.\n\n**[publiuss (Basin) confirmed and commented](https://github.com/code-423n4/2023-07-basin-findings/issues/176#issuecomment-1689103893):**\n > This issue was addressed by (1) changing the variable name from `BLOCK_TIME` to `CAP_INTERVAL` and (2) rounding up when calculating `capInterval` (See [here](https://github.com/BeanstalkFarms/Basin/blob/91233a22005986aa7c9f3b0c67393842cd8a8e4d/src/pumps/MultiFlowPump.sol#L109).)\n> \n> \n> (1) By changing the name it is clear that this parameter does not have to be the block time. (2) By rounding up, the system protects itself against the case where the chain block chain is greater than `CAP_INTERVAL` capExponent will always be non-zero when time has passed. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/pumps/MultiFlowPump.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IMultiFlowPumpErrors} from \"src/interfaces/pumps/IMultiFlowPumpErrors.sol\";\nimport {IWell} from \"src/interfaces/IWell.sol\";\nimport {IInstantaneousPump} from \"src/interfaces/pumps/IInstantaneousPump.sol\";\nimport {ICumulativePump} from \"src/interfaces/pumps/ICumulativePump.sol\";\nimport {ABDKMathQuad} from \"src/libraries/ABDKMathQuad.sol\";\nimport {LibBytes16} from \"src/libraries/LibBytes16.sol\";\nimport {LibLastReserveBytes} from \"src/libraries/LibLastReserveBytes.sol\";\n\n/**\n * @title MultiFlowPump\n * @author Publius\n * @notice Stores a geometric EMA and cumulative geometric SMA for each reserve.\n * @dev A Pump designed for use in Beanstalk with 2 tokens.\n *\n * This Pump has 3 main features:\n *  1. Multi-block MEV resistence reserves\n *  2. MEV-resistant Geometric EMA intended for instantaneous reserve queries\n *  3. MEV-resistant Cumulative Geometric intended for SMA reserve queries\n *\n * Note: If an `update` call is made with a reserve of 0, the Geometric mean oracles will be set to 0.\n * Each Well is responsible for ensuring that an `update` call cannot be made with a reserve of 0.\n */\ncontract MultiFlowPump is IPump, IMultiFlowPumpErrors, IInstantaneousPump, ICumulativePump {\n    using LibLastReserveBytes for bytes32;\n    using LibBytes16 for bytes32;\n    using ABDKMathQuad for bytes16;\n    using ABDKMathQuad for uint256;\n\n    bytes16 private immutable LOG_MAX_INCREASE;\n    bytes16 private immutable LOG_MAX_DECREASE;\n    bytes16 private immutable ALPHA;\n    uint256 private immutable CAP_INTERVAL;\n\n    struct PumpState {\n        uint40 lastTimestamp;\n        bytes16[] lastReserves;\n        bytes16[] emaReserves;\n        bytes16[] cumulativeReserves;\n    }\n\n    /**\n     * @param _maxPercentIncrease The maximum percent increase allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _maxPercentDecrease The maximum percent decrease allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _capInterval How often to increase the magnitude of the cap on the change in reserve in seconds.\n     * @param _alpha The geometric EMA constant. Must be in quadruple precision format (See {ABDKMathQuad}).\n     *\n     * @dev The Pump will not flow and should definitely be considered invalid if the following constraints are not met:\n     * - 0% < _maxPercentIncrease\n     * - 0% < _maxPercentDecrease <= 100%\n     * - 0 < ALPHA <= 1\n     * - _capInterval > 0\n     * The above constraints are not checked in the constructor for gas efficiency reasons.\n     * When evaluating the manipulation resistance of an instance of a Multi Flow Pump for use as an oracle, stricter\n     * constraints should be used.\n     */\n    constructor(bytes16 _maxPercentIncrease, bytes16 _maxPercentDecrease, uint256 _capInterval, bytes16 _alpha) {\n        LOG_MAX_INCREASE = ABDKMathQuad.ONE.add(_maxPercentIncrease).log_2();\n        LOG_MAX_DECREASE = ABDKMathQuad.ONE.sub(_maxPercentDecrease).log_2();\n        CAP_INTERVAL = _capInterval;\n        ALPHA = _alpha;\n    }\n\n    //////////////////// PUMP ////////////////////\n\n    function update(uint256[] calldata reserves, bytes calldata) external {\n        uint256 numberOfReserves = reserves.length;\n        PumpState memory pumpState;\n\n        // All reserves are stored starting at the msg.sender address slot in storage.\n        bytes32 slot = _getSlotForAddress(msg.sender);\n\n        // Read: Last Timestamp & Last Reserves\n        (, pumpState.lastTimestamp, pumpState.lastReserves) = slot.readLastReserves();\n\n        // If the last timestamp is 0, then the pump has never been used before.\n        if (pumpState.lastTimestamp == 0) {\n            _init(slot, uint40(block.timestamp), reserves);\n            return;\n        }\n\n        // Read: Cumulative & EMA Reserves\n        // Start at the slot after `pumpState.lastReserves`\n        uint256 numSlots = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.emaReserves = slot.readBytes16(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.cumulativeReserves = slot.readBytes16(numberOfReserves);\n\n        bytes16 alphaN;\n        bytes16 deltaTimestampBytes;\n        bytes16 capExponent;\n        // Isolate in brackets to prevent stack too deep errors\n        {\n            uint256 deltaTimestamp = _getDeltaTimestamp(pumpState.lastTimestamp);\n            // If no time has passed, don't update the pump reserves.\n            if (deltaTimestamp == 0) return;\n            alphaN = ALPHA.powu(deltaTimestamp);\n            deltaTimestampBytes = deltaTimestamp.fromUInt();\n            // Round up in case CAP_INTERVAL > block.timestamp.\n            capExponent = ((deltaTimestamp - 1) / CAP_INTERVAL + 1).fromUInt();\n        }\n\n        uint256 _reserve;\n        for (uint256 i; i < numberOfReserves; ++i) {\n            // Use a minimum of 1 for reserve. Geometric means will be set to 0 if a reserve is 0.\n            _reserve = reserves[i];\n            pumpState.lastReserves[i] =\n                _capReserve(pumpState.lastReserves[i], (_reserve > 0 ? _reserve : 1).fromUIntToLog2(), capExponent);\n            pumpState.emaReserves[i] =\n                pumpState.lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(pumpState.emaReserves[i].mul(alphaN));\n            pumpState.cumulativeReserves[i] =\n                pumpState.cumulativeReserves[i].add(pumpState.lastReserves[i].mul(deltaTimestampBytes));\n        }\n\n        // Write: Cumulative & EMA Reserves\n        // Order matters: work backwards to avoid using a new memory var to count up\n        slot.storeBytes16(pumpState.cumulativeReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n        slot.storeBytes16(pumpState.emaReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(uint40(block.timestamp), pumpState.lastReserves);\n    }\n\n    /**\n     * @dev On first update for a particular Well, initialize oracle with\n     * reserves data.\n     */\n    function _init(bytes32 slot, uint40 lastTimestamp, uint256[] memory reserves) internal {\n        uint256 numberOfReserves = reserves.length;\n        bytes16[] memory byteReserves = new bytes16[](numberOfReserves);\n\n        // Skip {_capReserve} since we have no prior reference\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            uint256 _reserve = reserves[i];\n            if (_reserve == 0) return;\n            byteReserves[i] = _reserve.fromUIntToLog2();\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(lastTimestamp, byteReserves);\n\n        // Write: EMA Reserves\n        // Start at the slot after `byteReserves`\n        uint256 numSlots = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        slot.storeBytes16(byteReserves); // EMA Reserves\n    }\n\n    //////////////////// LAST RESERVES ////////////////////\n\n    function readLastReserves(address well) public view returns (uint256[] memory reserves) {\n        (uint8 numberOfReserves,, bytes16[] memory bytesReserves) = _getSlotForAddress(well).readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = bytesReserves[i].pow_2ToUInt();\n        }\n    }\n\n    /**\n     * @dev Adds a cap to the reserve value to prevent extreme changes.\n     *\n     *  Linear space:\n     *     max reserve = (last reserve) * ((1 + MAX_PERCENT_CHANGE_PER_BLOCK) ^ capExponent)\n     *\n     *  Log space:\n     *     log2(max reserve) = log2(last reserve) + capExponent*log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     `bytes16 lastReserve`      <- log2(last reserve)\n     *     `bytes16 capExponent`      <- cap exponent\n     *     `bytes16 LOG_MAX_INCREASE` <- log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     âˆ´ `maxReserve = lastReserve + capExponent*LOG_MAX_INCREASE`\n     *\n     */\n    function _capReserve(\n        bytes16 lastReserve,\n        bytes16 reserve,\n        bytes16 capExponent\n    ) internal view returns (bytes16 cappedReserve) {\n        // Reserve decreasing (lastReserve > reserve)\n        if (lastReserve.cmp(reserve) == 1) {\n            bytes16 minReserve = lastReserve.add(capExponent.mul(LOG_MAX_DECREASE));\n            // if reserve < minimum reserve, set reserve to minimum reserve\n            if (minReserve.cmp(reserve) == 1) reserve = minReserve;\n        }\n        // Reserve increasing or staying the same (lastReserve <= reserve)\n        else {\n            bytes16 maxReserve = lastReserve.add(capExponent.mul(LOG_MAX_INCREASE));\n            // If reserve > maximum reserve, set reserve to maximum reserve\n            if (reserve.cmp(maxReserve) == 1) reserve = maxReserve;\n        }\n        cappedReserve = reserve;\n    }\n\n    //////////////////// EMA RESERVES ////////////////////\n\n    function readLastInstantaneousReserves(address well) external view returns (uint256[] memory emaReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory byteReserves = slot.readBytes16(numberOfReserves);\n        emaReserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            emaReserves[i] = byteReserves[i].pow_2ToUInt();\n        }\n    }\n\n    function readInstantaneousReserves(\n        address well,\n        bytes memory\n    ) external view returns (uint256[] memory emaReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory lastEmaReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        emaReserves = new uint256[](numberOfReserves);\n        // If no time has passed, return last EMA reserves.\n        if (deltaTimestamp == 0) {\n            for (uint256 i; i < numberOfReserves; ++i) {\n                emaReserves[i] = lastEmaReserves[i].pow_2ToUInt();\n            }\n            return emaReserves;\n        }\n        bytes16 capExponent = ((deltaTimestamp - 1) / CAP_INTERVAL + 1).fromUInt();\n        bytes16 alphaN = ALPHA.powu(deltaTimestamp);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), capExponent);\n            emaReserves[i] =\n                lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(lastEmaReserves[i].mul(alphaN)).pow_2ToUInt();\n        }\n    }\n\n    //////////////////// CUMULATIVE RESERVES ////////////////////\n\n    /**\n     * @notice Read the latest cumulative reserves of `well`.\n     */\n    function readLastCumulativeReserves(address well) external view returns (bytes16[] memory cumulativeReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        cumulativeReserves = slot.readBytes16(numberOfReserves);\n    }\n\n    function readCumulativeReserves(\n        address well,\n        bytes memory\n    ) external view returns (bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    function _readCumulativeReserves(address well) internal view returns (bytes16[] memory cumulativeReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        cumulativeReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        // If no time has passed, return last cumulative reserves.\n        if (deltaTimestamp == 0) {\n            return cumulativeReserves;\n        }\n        bytes16 deltaTimestampBytes = deltaTimestamp.fromUInt();\n        bytes16 capExponent = ((deltaTimestamp - 1) / CAP_INTERVAL + 1).fromUInt();\n        // Currently, there is so support for overflow.\n        for (uint256 i; i < cumulativeReserves.length; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), capExponent);\n            cumulativeReserves[i] = cumulativeReserves[i].add(lastReserves[i].mul(deltaTimestampBytes));\n        }\n    }\n\n    function readTwaReserves(\n        address well,\n        bytes calldata startCumulativeReserves,\n        uint256 startTimestamp,\n        bytes memory\n    ) public view returns (uint256[] memory twaReserves, bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        bytes16[] memory byteStartCumulativeReserves = abi.decode(startCumulativeReserves, (bytes16[]));\n        twaReserves = new uint256[](byteCumulativeReserves.length);\n\n        // Overflow is desired on `startTimestamp`, so SafeCast is not used.\n        bytes16 deltaTimestamp = _getDeltaTimestamp(uint40(startTimestamp)).fromUInt();\n        if (deltaTimestamp == bytes16(0)) {\n            revert NoTimePassed();\n        }\n        for (uint256 i; i < byteCumulativeReserves.length; ++i) {\n            // Currently, there is no support for overflow.\n            twaReserves[i] =\n                (byteCumulativeReserves[i].sub(byteStartCumulativeReserves[i])).div(deltaTimestamp).pow_2ToUInt();\n        }\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    //////////////////// HELPERS ////////////////////\n\n    /**\n     * @dev Convert an `address` into a `bytes32` by zero padding the right 12 bytes.\n     */\n    function _getSlotForAddress(address addressValue) internal pure returns (bytes32 _slot) {\n        _slot = bytes32(bytes20(addressValue)); // Because right padded, no collision on adjacent\n    }\n\n    /**\n     * @dev Get the starting byte of the slot that contains the `n`th element of an array.\n     */\n    function _getSlotsOffset(uint256 numberOfReserves) internal pure returns (uint256 _slotsOffset) {\n        _slotsOffset = ((numberOfReserves - 1) / 2 + 1) << 5;\n    }\n\n    /**\n     * @dev Get the delta between the current and provided timestamp as a `uint256`.\n     */\n    function _getDeltaTimestamp(uint40 lastTimestamp) internal view returns (uint256 _deltaTimestamp) {\n        return uint256(uint40(block.timestamp) - lastTimestamp);\n    }\n}"
    }
  ]
}