{
  "Title": "[L-04] Incompatibility With Rebasing/Deflationary/Inflationary tokens",
  "Content": "<h2 id=\"l-04-incompatibility-with-rebasingdeflationaryinflationary-tokens\" style=\"position:relative;\"><a href=\"#l-04-incompatibility-with-rebasingdeflationaryinflationary-tokens\" aria-label=\"l 04 incompatibility with rebasingdeflationaryinflationary tokens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-04] Incompatibility With Rebasing/Deflationary/Inflationary tokens</h2>\n<p>The protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.</p>\n<h3 id=\"proof-of-concept-20\" style=\"position:relative;\"><a href=\"#proof-of-concept-20\" aria-label=\"proof of concept 20 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<p>Navigate to the following contracts:</p>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L155\">https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L155</a><br></li>\n<li><a href=\"https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L29\">https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L29</a><br></li>\n</ul>\n<h3 id=\"recommended-mitigation-steps-22\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-22\" aria-label=\"recommended mitigation steps 22 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<ul>\n<li>Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation</li>\n<li>Add support in contracts for such tokens before accepting user-supplied tokens</li>\n<li>Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they donâ€™t want to lose them.</li>\n</ul>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/MarginAccount.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { HubbleBase } from \"./legos/HubbleBase.sol\";\nimport {\n    ERC20Detailed,\n    IClearingHouse,\n    IInsuranceFund,\n    IOracle,\n    IRegistry,\n    IMarginAccount,\n    IERC20FlexibleSupply\n} from \"./Interfaces.sol\";\n\n/**\n* @title This contract is used for posting margin (collateral), realizing PnL etc.\n* @notice Most notable operations include addMargin, removeMargin and liquidations\n*/\ncontract MarginAccount is IMarginAccount, HubbleBase {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    // Hubble vUSD is necessitated to be the first whitelisted collateral\n    uint constant VUSD_IDX = 0;\n\n    // used for all usd based values\n    uint constant PRECISION = 1e6;\n\n    error NOT_LIQUIDATABLE(IMarginAccount.LiquidationStatus);\n\n    /**\n    * @dev This is only used to group variables to avoid a solidity stack too deep error\n    *   incentivePerDollar How many $ liquidator gets for each $ they repay e.g. they might get $1.05 for every $1 liquidation. >= PRECISION\n    *   repayAble The maximum debt that can be settled for an account undergoing a liquidation\n    *   priceCollateral Most recent oracle price (chainlink) of the collateral that is being seized for an account undergoing a liquidation\n    *   decimals Decimals for the collateral being seized\n    */\n    struct LiquidationBuffer {\n        LiquidationStatus status;\n        uint8 decimals;\n        uint incentivePerDollar;\n        uint repayAble;\n        uint priceCollateral;\n    }\n\n    /* ****************** */\n    /*       Storage      */\n    /* ****************** */\n\n    IClearingHouse public clearingHouse;\n    IOracle public oracle;\n    IInsuranceFund public insuranceFund;\n    IERC20FlexibleSupply public vusd;\n    uint public credit;\n\n    /// @notice Array of supported collateral\n    Collateral[] public supportedCollateral;\n\n    /**\n    * @notice How many $ liquidator gets for each $ they repay e.g. they might get $1.05 for every $1 liquidation\n    * @dev In the above scenario, this value will be %0.05 i.e. 5 cents incentive per dollar repayed\n    */\n    uint public liquidationIncentive;\n\n    /**\n    * @notice Maps index in supportedCollateral => trader => balance\n    * @dev equivalent to margin(uint idx, address user)\n    */\n    mapping(uint => mapping(address => int)) override public margin;\n\n    uint256[50] private __gap;\n\n    /* ****************** */\n    /*       Events       */\n    /* ****************** */\n\n    /// @notice Emitted when user adds margin for any of the supported collaterals\n    event MarginAdded(address indexed trader, uint256 indexed idx, uint amount, uint256 timestamp);\n\n    /// @notice Emitted when user removes margin for any of the supported collaterals\n    event MarginRemoved(address indexed trader, uint256 indexed idx, uint256 amount, uint256 timestamp);\n\n    /**\n    * @notice Mutates trader's vUSD balance\n    * @param trader Account who is realizing PnL\n    * @param realizedPnl Increase or decrease trader's vUSD balace by. +ve/-ve value means vUSD is added/removed respectively from trader's margin\n    */\n    event PnLRealized(address indexed trader, int256 realizedPnl, uint256 timestamp);\n\n    /**\n    * @notice Emitted when a trader's margin account is liquidated i.e. their vUSD debt is repayed in exchange for their collateral\n    * @param trader Trader whose margin account was liquidated\n    * @param idx Index of the collateral that was seized during the liquidation\n    * @param seizeAmount Amount of the collateral that was seized during the liquidation\n    * @param repayAmount The debt that was repayed\n    */\n    event MarginAccountLiquidated(address indexed trader, uint indexed idx, uint seizeAmount, uint repayAmount, uint256 timestamp);\n\n    /**\n    * @notice Emitted when funds from insurance fund are tasked to settle system's bad debt\n    * @param trader Account for which the bad debt was settled\n    * @param seized Collateral amounts that were seized\n    * @param repayAmount Debt that was settled. it's exactly equal to -vUSD when vUSD < 0\n    */\n    event SettledBadDebt(address indexed trader, uint[] seized, uint repayAmount, uint256 timestamp);\n\n    modifier onlyClearingHouse() {\n        require(_msgSender() == address(clearingHouse), \"Only clearingHouse\");\n        _;\n    }\n\n    constructor(address _trustedForwarder) HubbleBase(_trustedForwarder) {}\n\n    function initialize(\n        address _governance,\n        address _vusd\n    ) external initializer {\n        _setGovernace(_governance);\n        _addCollateral(_vusd, PRECISION); // weight = 1 * PRECISION\n        vusd = IERC20FlexibleSupply(_vusd);\n    }\n\n    /* ****************** */\n    /*       Margin       */\n    /* ****************** */\n\n    /**\n    * @notice Post margin\n    * @param idx Index of the supported collateral\n    * @param amount Amount to deposit (scaled same as the asset)\n    */\n    function addMargin(uint idx, uint amount) override external whenNotPaused {\n        addMarginFor(idx, amount, _msgSender());\n    }\n\n    /**\n    * @notice Post margin for another account\n    * @param idx Index of the supported collateral\n    * @param amount Amount to deposit (scaled same as the asset)\n    * @param to Account to post margin for\n    */\n    function addMarginFor(uint idx, uint amount, address to) override public whenNotPaused {\n        require(amount > 0, \"Add non-zero margin\");\n        // will revert for idx >= supportedCollateral.length\n        if (idx == VUSD_IDX) {\n            _transferInVusd(_msgSender(), amount);\n        } else {\n            supportedCollateral[idx].token.safeTransferFrom(_msgSender(), address(this), amount);\n        }\n        margin[idx][to] += amount.toInt256();\n        emit MarginAdded(to, idx, amount, _blockTimestamp());\n    }\n\n    /**\n    * @notice Withdraw margin.\n    *   Collateral can not be withdrawn if vUSD balance is < 0.\n    * @dev If the contract has insufficient vUSD balance, a loan is taken from the vUSD contract.\n    * @param idx Index of the supported collateral\n    * @param amount Amount to withdraw (scaled same as the asset)\n    */\n    function removeMargin(uint idx, uint256 amount) override external whenNotPaused {\n        address trader = _msgSender();\n\n        // credit funding payments\n        clearingHouse.updatePositions(trader);\n\n        require(margin[VUSD_IDX][trader] >= 0, \"Cannot remove margin when vusd balance is negative\");\n        require(margin[idx][trader] >= amount.toInt256(), \"Insufficient balance\");\n\n        margin[idx][trader] -= amount.toInt256();\n\n        // Check minimum margin requirement after withdrawal\n        require(clearingHouse.isAboveMinAllowableMargin(trader), \"MA.removeMargin.Below_MM\");\n\n        if (idx == VUSD_IDX) {\n            _transferOutVusd(trader, amount);\n        } else {\n            supportedCollateral[idx].token.safeTransfer(trader, amount);\n        }\n        emit MarginRemoved(trader, idx, amount, _blockTimestamp());\n    }\n\n    /**\n    * @notice Invoked to realize PnL, credit/debit funding payments, pay trade and liquidation fee\n    * @dev Will only make a change to VUSD balance.\n    *   only clearingHouse is authorized to call.\n    * @param trader Account to realize PnL for\n    * @param realizedPnl Amount to credit/debit\n    */\n    function realizePnL(address trader, int256 realizedPnl)\n        override\n        external\n        onlyClearingHouse\n    {\n        // -ve PnL will reduce balance\n        if (realizedPnl != 0) {\n            margin[VUSD_IDX][trader] += realizedPnl;\n            emit PnLRealized(trader, realizedPnl, _blockTimestamp());\n        }\n    }\n\n    function transferOutVusd(address recipient, uint amount)\n        override\n        external\n        onlyClearingHouse\n    {\n        _transferOutVusd(recipient, amount);\n    }\n\n    /* ****************** */\n    /*    Liquidations    */\n    /* ****************** */\n\n    /**\n    * @notice Determines if a trader's margin account can be liquidated now\n    * @param trader Account to check liquidation status for\n    * @param includeFunding whether to include funding payments before checking liquidation status\n    * @return _isLiquidatable Whether the account can be liquidated; reason if not\n    * @return repayAmount Trader's debt i.e. the max amount that they can be liquidated for\n    * @return incentivePerDollar How many $ liquidator gets for each $ they repay\n    *   e.g. they might get $1.05 for every $1 that is repayed.\n    */\n    function isLiquidatable(address trader, bool includeFunding)\n        override\n        public\n        view\n        returns(IMarginAccount.LiquidationStatus _isLiquidatable, uint repayAmount, uint incentivePerDollar)\n    {\n        int vusdBal = margin[VUSD_IDX][trader];\n        if (includeFunding) {\n            vusdBal -= clearingHouse.getTotalFunding(trader);\n        }\n        if (vusdBal >= 0) { // nothing to liquidate\n            return (IMarginAccount.LiquidationStatus.NO_DEBT, 0, 0);\n        }\n\n        (uint256 notionalPosition,) = clearingHouse.getTotalNotionalPositionAndUnrealizedPnl(trader);\n        if (notionalPosition != 0) { // Liquidate positions before liquidating margin account\n            return (IMarginAccount.LiquidationStatus.OPEN_POSITIONS, 0, 0);\n        }\n\n        (int256 weighted, int256 spot) = weightedAndSpotCollateral(trader);\n        if (weighted >= 0) {\n            return (IMarginAccount.LiquidationStatus.ABOVE_THRESHOLD, 0, 0);\n        }\n\n        // _isLiquidatable = IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE;\n        repayAmount = (-vusdBal).toUint256();\n        incentivePerDollar = PRECISION; // get atleast $1 worth of collateral for every $1 paid\n\n        if (spot > 0) {\n            /**\n                Liquidation scenario B, where Cw < |vUSD| < Cusd\n                => Cw - |vUSD| < 0\n                => Cw + vUSD (=weighted) < 0; since vUSD < 0\n                Max possible liquidationIncentive (for repaying |vUSD|) is Cusd\n            */\n            incentivePerDollar += _min(\n                liquidationIncentive, // incentivePerDollar = PRECISION + liquidationIncentive <= 1.1\n                // divide up all the extra dollars in proportion to repay amount\n                // note that spot value here is inclusive of the -ve vUSD value\n                spot.toUint256() * PRECISION / repayAmount\n            );\n        } /* else {\n            Since the protocol is already in deficit we don't have any money to give out as liquidationIncentive\n            Liquidation scenario C, where Cusd <= |vUSD|\n            => Cusd - |vUSD| <= 0\n            => Cusd + vUSD (=spot) <= 0; since vUSD < 0\n\n            @todo consider providing some incentive from insurance fund to execute a liquidation in this scenario.\n            That fee is basically provided so that insurance fund has to settle a lower bad debt and seize lesser amount of assets.\n            (because seized assets then need to sold/auctioned off, so that's extra work)\n        } */\n    }\n\n    /**\n    * @notice Liquidate a trader while mentioning the exact repay amount while capping \"slippage\" on the seized collateral\n    *   This maybe be considered as a \"swapExactInput\" operation.\n    *   It's required that trader has no open positions.\n    * @param trader Account to liquidate\n    * @param repay Amount to repay\n    * @param idx Index of the collateral to seize\n    * @param minSeizeAmount Min collateral output amount\n    */\n    function liquidateExactRepay(address trader, uint repay, uint idx, uint minSeizeAmount) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n        if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            revert NOT_LIQUIDATABLE(buffer.status);\n        }\n        _liquidateExactRepay(buffer, trader, repay, idx, minSeizeAmount);\n    }\n\n    /**\n    * @notice Liquidate a trader while mentioning the exact collateral amount to be seized while capping \"slippage\" on the repay amount.\n    *   This maybe be considered as a \"swapExactOutput\" operation.\n    *   It's required that trader has no open positions.\n    * @param trader Account to liquidate\n    * @param maxRepay Max vUSD input amount\n    * @param idx Index of the collateral to seize\n    * @param seize Exact collateral amount desired to be seized\n    */\n    function liquidateExactSeize(address trader, uint maxRepay, uint idx, uint seize) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n        if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            revert NOT_LIQUIDATABLE(buffer.status);\n        }\n        _liquidateExactSeize(buffer, trader, maxRepay, idx, seize);\n    }\n\n    /**\n    * @notice Either seize all available collateral\n    *   OR settle debt completely with (most likely) left over collateral.\n    *   It's required that trader has no open positions.\n    *   Seized collateral at it's current oracle price should be acceptable to the liquidator.\n    * @param trader Account to liquidate\n    * @param maxRepay Max vUSD input amount\n    * @param idxs Indices of the collateral to seize\n    */\n    function liquidateFlexible(address trader, uint maxRepay, uint[] calldata idxs) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        uint repayed;\n        for (uint i = 0; i < idxs.length; i++) {\n            LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idxs[i]);\n            // revert only if trader has open positions, otherwise fail silently\n            if (buffer.status == IMarginAccount.LiquidationStatus.OPEN_POSITIONS) {\n                revert NOT_LIQUIDATABLE(buffer.status);\n            }\n            if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n                break;\n            }\n            repayed = _liquidateFlexible(trader, maxRepay, idxs[i]);\n            maxRepay -= repayed;\n        }\n    }\n\n    /**\n    * @notice Invoke a bad debt settlement using the insurance fund.\n    *   It's required that trader has no open positions when settling bad debt.\n    * @dev Debt is said to be bad when the spot value of user's collateral is not enough to cover their -ve vUSD balance\n    *   Since there are no open positions, debit/credit funding payments is not required.\n    * @param trader Account for which the bad debt needs to be settled\n    */\n    function settleBadDebt(address trader) external whenNotPaused {\n        (uint256 notionalPosition,) = clearingHouse.getTotalNotionalPositionAndUnrealizedPnl(trader);\n        require(notionalPosition == 0, \"Liquidate positions before settling bad debt\");\n\n        // The spot value of their collateral minus their vUSD obligation is a negative value\n        require(getSpotCollateralValue(trader) < 0, \"Above bad debt threshold\");\n\n        int vusdBal = margin[VUSD_IDX][trader];\n\n        // this check is not strictly required because getSpotCollateralValue(trader) < 0 is a stronger assertion\n        require(vusdBal < 0, \"Nothing to repay\");\n\n        uint badDebt = (-vusdBal).toUint256();\n        Collateral[] memory assets = supportedCollateral;\n\n        // This pulls the obligation\n        insuranceFund.seizeBadDebt(badDebt);\n        margin[VUSD_IDX][trader] = 0;\n\n        // Insurance fund gets all the available collateral\n        uint[] memory seized = new uint[](assets.length);\n        for (uint i = 1 /* skip vusd */; i < assets.length; i++) {\n            int amount = margin[i][trader];\n            if (amount > 0) {\n                margin[i][trader] = 0;\n                assets[i].token.safeTransfer(address(insuranceFund), amount.toUint256());\n                seized[i] = amount.toUint256();\n            }\n        }\n        emit SettledBadDebt(trader, seized, badDebt, _blockTimestamp());\n    }\n\n    /* ********************* */\n    /* Liquidations Internal */\n    /* ********************* */\n\n    /**\n    * @dev This function wil either seize all available collateral of type idx\n    * OR settle debt completely with (most likely) left over collateral\n    * @return Debt repayed <= repayble i.e. user's max debt\n    */\n    function _liquidateFlexible(address trader, uint maxRepay, uint idx) internal whenNotPaused returns(uint /* repayed */) {\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n\n        // Q. Can user's margin cover the entire debt?\n        uint repay = _seizeToRepay(buffer, margin[idx][trader].toUint256());\n\n        // A.1 Yes, it can cover the entire debt. Settle repayAble\n        if (repay >= buffer.repayAble) {\n            _liquidateExactRepay(\n                buffer,\n                trader,\n                buffer.repayAble, // exact repay amount\n                idx,\n                0 // minSeizeAmount=0 implies accept whatever the oracle price is\n            );\n            return buffer.repayAble; // repayed exactly repayAble and 0 is left to repay now\n        }\n\n        // A.2 No, collateral can not cover the entire debt. Seize all of it.\n        return _liquidateExactSeize(\n            buffer,\n            trader,\n            maxRepay,\n            idx,\n            margin[idx][trader].toUint256()\n        );\n    }\n\n    function _liquidateExactRepay(\n        LiquidationBuffer memory buffer,\n        address trader,\n        uint repay,\n        uint idx,\n        uint minSeizeAmount\n    )\n        internal\n        returns (uint seized)\n    {\n        // determine the seizable collateral amount on the basis of the most recent chainlink price feed\n        seized = _min(\n            _scaleDecimals(repay * buffer.incentivePerDollar, buffer.decimals - 6) / buffer.priceCollateral,\n            // can't seize more than available\n            // this also protects the liquidator in the scenario that they were front-run and only a small seize isn't worth it for them\n            margin[idx][trader].toUint256()\n        );\n        require(seized >= minSeizeAmount, \"Not seizing enough\");\n        _executeLiquidation(trader, repay, idx, seized, buffer.repayAble);\n    }\n\n    function _liquidateExactSeize(\n        LiquidationBuffer memory buffer,\n        address trader,\n        uint maxRepay,\n        uint idx,\n        uint seize\n    )\n        internal\n        returns (uint repay)\n    {\n        repay = _seizeToRepay(buffer, seize);\n        require(repay <= maxRepay, \"Need to repay more to seize that much\");\n        _executeLiquidation(trader, repay, idx, seize, buffer.repayAble);\n    }\n\n    /**\n    * @dev reverts if margin account is not liquidatable\n    */\n    function _getLiquidationInfo(address trader, uint idx) internal view returns (LiquidationBuffer memory buffer) {\n        require(idx > VUSD_IDX && idx < supportedCollateral.length, \"collateral not seizable\");\n        (buffer.status, buffer.repayAble, buffer.incentivePerDollar) = isLiquidatable(trader, false);\n        if (buffer.status == IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            Collateral memory coll = supportedCollateral[idx];\n            buffer.priceCollateral = oracle.getUnderlyingPrice(address(coll.token)).toUint256();\n            buffer.decimals = coll.decimals;\n        }\n    }\n\n    /**\n    * @dev Peform the actual liquidation.\n    *   1. Pull the repay amount from liquidator's account and credit trader's VUSD margin\n    *   2. Debit the seize amount and transfer to liquidator\n    * @return The debt that is leftover to be paid\n    */\n    function _executeLiquidation(address trader, uint repay, uint idx, uint seize, uint repayAble)\n        internal\n        returns (uint /* left over repayable */)\n    {\n        if (repay == 0 || seize == 0) { // provides more flexibility, so prefer not reverting\n            return repayAble;\n        }\n\n        _transferInVusd(_msgSender(), repay);\n        margin[VUSD_IDX][trader] += repay.toInt256();\n\n        margin[idx][trader] -= seize.toInt256();\n        supportedCollateral[idx].token.safeTransfer(_msgSender(), seize);\n\n        emit MarginAccountLiquidated(trader, idx, seize, repay, _blockTimestamp());\n        return repayAble - repay; // will ensure that the liquidator isn't repaying more than user's debt (and seizing a bigger amount of their collateral)\n    }\n\n    function _seizeToRepay(LiquidationBuffer memory buffer, uint seize) internal pure returns (uint repay) {\n        repay = seize * buffer.priceCollateral / (10 ** buffer.decimals);\n        if (buffer.incentivePerDollar > 0) {\n            repay = repay * PRECISION / buffer.incentivePerDollar;\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    function getSpotCollateralValue(address trader) override public view returns(int256 spot) {\n        (,spot) = weightedAndSpotCollateral(trader);\n    }\n\n    function getNormalizedMargin(address trader) override public view returns(int256 weighted) {\n        (weighted,) = weightedAndSpotCollateral(trader);\n    }\n\n    function weightedAndSpotCollateral(address trader)\n        public\n        view\n        returns (int256 weighted, int256 spot)\n    {\n        Collateral[] memory assets = supportedCollateral;\n        Collateral memory _collateral;\n\n        for (uint i = 0; i < assets.length; i++) {\n            _collateral = assets[i];\n\n            int numerator = margin[i][trader] * oracle.getUnderlyingPrice(address(assets[i].token));\n            uint denomDecimals = _collateral.decimals;\n\n            spot += (numerator / int(10 ** denomDecimals));\n            weighted += (numerator * _collateral.weight.toInt256() / int(10 ** (denomDecimals + 6)));\n        }\n    }\n\n    /* ****************** */\n    /*     UI Helpers     */\n    /* ****************** */\n\n    function supportedAssets() external view override returns (Collateral[] memory) {\n        return supportedCollateral;\n    }\n\n    function supportedAssetsLen() override external view returns (uint) {\n        return supportedCollateral.length;\n    }\n\n    /* ****************** */\n    /*    Misc Internal   */\n    /* ****************** */\n\n    function _addCollateral(address _coin, uint _weight) internal {\n        require(_weight <= PRECISION, \"weight > 1e6\");\n\n        Collateral[] memory _collaterals = supportedCollateral;\n        for (uint i = 0; i < _collaterals.length; i++) {\n            require(address(_collaterals[i].token) != _coin, \"collateral exists\");\n        }\n        supportedCollateral.push(\n            Collateral({\n                token: IERC20(_coin),\n                weight: _weight,\n                decimals: ERC20Detailed(_coin).decimals() // will fail if .decimals() is not defined on the contract\n            })\n        );\n    }\n\n    function _scaleDecimals(uint256 amount, uint8 decimals) internal pure returns(uint256) {\n        return amount * (10 ** decimals);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _transferInVusd(address from, uint amount) internal {\n        IERC20(address(vusd)).safeTransferFrom(from, address(this), amount);\n        if (credit > 0) {\n            uint toBurn = Math.min(vusd.balanceOf(address(this)), credit);\n            credit -= toBurn;\n            vusd.burn(toBurn);\n        }\n    }\n\n    function _transferOutVusd(address recipient, uint amount) internal {\n        uint bal = vusd.balanceOf(address(this));\n        if (bal < amount) {\n            // Say there are 2 traders, Alice and Bob.\n            // Alice has a profitable position and realizes their PnL in form of vusd margin.\n            // But bob has not yet realized their -ve PnL.\n            // In that case we'll take a credit from vusd contract, which will eventually be returned when Bob pays their debt back.\n            uint _credit = amount - bal;\n            credit += _credit;\n            vusd.mint(address(this), _credit);\n        }\n        IERC20(address(vusd)).safeTransfer(recipient, amount);\n    }\n\n    /* ****************** */\n    /*     Governance     */\n    /* ****************** */\n\n    function syncDeps(address _registry, uint _liquidationIncentive) public onlyGovernance {\n        // protecting against setting a very high liquidation incentive. Max 10%\n        require(_liquidationIncentive <= PRECISION / 10, \"MA.syncDeps.LI_GT_10_percent\");\n        IRegistry registry = IRegistry(_registry);\n        require(registry.marginAccount() == address(this), \"Incorrect setup\");\n\n        clearingHouse = IClearingHouse(registry.clearingHouse());\n        oracle = IOracle(registry.oracle());\n        insuranceFund = IInsuranceFund(registry.insuranceFund());\n        liquidationIncentive = _liquidationIncentive;\n    }\n\n    function whitelistCollateral(address _coin, uint _weight) external onlyGovernance {\n        _addCollateral(_coin, _weight);\n    }\n\n    // function to change weight of an asset\n    function changeCollateralWeight(uint idx, uint _weight) external onlyGovernance {\n        require(_weight <= PRECISION, \"weight > 1e6\");\n        require(idx < supportedCollateral.length, \"Collateral not supported\");\n        supportedCollateral[idx].weight = _weight;\n    }\n}"
    },
    {
      "filename": "contracts/MarginAccountHelper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { VUSD } from \"./VUSD.sol\";\nimport { IMarginAccount } from \"./Interfaces.sol\";\n\ncontract MarginAccountHelper {\n    using SafeERC20 for IERC20;\n\n    uint constant VUSD_IDX = 0;\n\n    IMarginAccount marginAccount;\n    VUSD vusd;\n    IERC20 public reserveToken;\n\n    constructor(address _marginAccount, address _vusd) {\n        marginAccount = IMarginAccount(_marginAccount);\n        vusd = VUSD(_vusd);\n        reserveToken = vusd.reserveToken();\n\n        reserveToken.safeApprove(address(_vusd), type(uint).max);\n        IERC20(_vusd).safeApprove(address(_marginAccount), type(uint).max);\n    }\n\n    function addVUSDMarginWithReserve(uint256 amount) external {\n        reserveToken.safeTransferFrom(msg.sender, address(this), amount);\n        vusd.mintWithReserve(address(this), amount);\n        marginAccount.addMarginFor(VUSD_IDX, amount, msg.sender);\n    }\n}"
    }
  ]
}