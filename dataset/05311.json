{
  "Title": "[R-01] - `Accumulator._insert()` might result in memory collision in future code",
  "Content": "This function expands the size of the `rentalAssets` memory variable, assuming there's no memory that's currently used afterwards.\nThis is true under current code, but worth keeping an eye on it for future code changes or upgrades - if there's another memory variable after `rentalAssets` when this function is called it'd override it, causing severe issues.\n\n[Code](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L81-L83)\n```solidity\n            // Update the free memory pointer so that memory is safe\n            // once we stop doing dynamic memory array inserts\n            mstore(0x40, add(newItemPosition, 0x40))\n```\n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/330#issuecomment-1908959716):**\n > L1- Acknowledged.<br>\n> L2- Acknowledged.<br>\n> L3- Disputed, this is expected behavior.<br>\n> L4- Confirmed.<br>\n> L5- Acknowledged, hook implementations considered out of scope.<br>\n> L6- Disputed, policies can only be enabled or disabled. in this instance, a second stop policy would be created for users to opt-in to.<br>\n> \n> R1- Acknowleged.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/packages/Accumulator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {RentalId, RentalAssetUpdate} from \"@src/libraries/RentalStructs.sol\";\n\n/**\n * @title Accumulator\n * @notice Package that implements functionality for managing dynamically allocated data\n *         struct arrays directly in memory. The rationale for this was the need for an\n *         array of structs where the total size is not known at instantiation.\n */\nabstract contract Accumulator {\n    /**\n     * @dev Accumulates an intermediary representation of a dynamic array of\n     *      `RentalAssetUpdate` structs.\n     *\n     * In memory, the format of `rentalAssets` will be as follows:\n     *\n     * 0x00: Length of the intermediary representation bytes data\n     * 0x20: Number of `RentalAssetUpdate` elements stored\n     * 0x40: `rentalId` of the first element\n     * 0x60: `amount` of the first element\n     * 0x80: `rentalId` of the second element\n     * 0xa0: `amount` of the second element\n     * 0xc0: ...\n     *\n     * @param rentalAssets      Bytes value which will accumulate `RentalAssetUpdate`\n     *                          structs.\n     * @param rentalId          Rental ID to include in the next `RentalAssetUpdate`.\n     * @param rentalAssetAmount Amount to include in the next `RentalAssetUpdate`.\n     */\n    function _insert(\n        bytes memory rentalAssets,\n        RentalId rentalId,\n        uint256 rentalAssetAmount\n    ) internal pure {\n        // Place the rental ID on the stack.\n        bytes32 _rentalId = RentalId.unwrap(rentalId);\n\n        assembly {\n            // This is the first time inserting into this bytes data.\n            if eq(mload(rentalAssets), 0) {\n                // Create some space for the initial element length word.\n                mstore(rentalAssets, 0x20)\n\n                // Zero out the number of elements.\n                mstore(add(0x20, rentalAssets), 0x00)\n            }\n\n            // Calculate the new size of the bytes data by adding\n            // the size of a `RentalAssetUpdate` struct.\n            let newByteDataSize := add(mload(rentalAssets), 0x40)\n\n            // Get the pointer for where the element data begins.\n            let rentalAssetElementPtr := add(rentalAssets, 0x20)\n\n            // Increase the number of rental elements by one.\n            let elements := add(mload(rentalAssetElementPtr), 1)\n\n            // Calculate the position for the new rental ID.\n            // To do this, calculate the total length of the element portion, then\n            // subtract by the initial offset. In this case, the offset is the 32-byte\n            // word (0x20) which contains the length of the array.\n            let newItemPosition := add(\n                rentalAssetElementPtr,\n                sub(mul(elements, 0x40), 0x20)\n            )\n\n            // Store the new byte data size\n            mstore(rentalAssets, newByteDataSize)\n\n            // Store the new number of elements\n            mstore(rentalAssetElementPtr, elements)\n\n            // Store the rental ID\n            mstore(newItemPosition, _rentalId)\n\n            // Store the amount in the adjacent 32-byte word\n            mstore(add(newItemPosition, 0x20), rentalAssetAmount)\n\n            // Update the free memory pointer so that memory is safe\n            // once we stop doing dynamic memory array inserts\n            mstore(0x40, add(newItemPosition, 0x40))\n        }\n    }\n\n    /**\n     * @dev Converts an intermediary dynamic array of `RentalAssetUpdate` into a\n     *      conventional Solidity array.\n     *\n     * @param rentalAssetUpdates Bytes data that represents an array of\n     *                           `RentalAssetUpdate` structs.\n     *\n     * @return updates Solidity representation of a `RentalAssetUpdate` array.\n     */\n    function _convertToStatic(\n        bytes memory rentalAssetUpdates\n    ) internal pure returns (RentalAssetUpdate[] memory updates) {\n        // Pointer to the rental asset update data.\n        bytes32 rentalAssetUpdatePointer;\n\n        // Load the length of the rental asset update items.\n        uint256 rentalAssetUpdateLength;\n        assembly {\n            // Get a pointer to the number of elements in the bytes data.\n            // With the 0x20 offset, we would be loading the length of the entire\n            // byte string, but we want the element length which starts one\n            // word to the right.\n            rentalAssetUpdatePointer := add(0x20, rentalAssetUpdates)\n\n            // Load the number of elements.\n            rentalAssetUpdateLength := mload(rentalAssetUpdatePointer)\n        }\n\n        // Instantiate the update array.\n        updates = new RentalAssetUpdate[](rentalAssetUpdateLength);\n\n        // Iterate through each item in the byte data, and add it as\n        // an entry to the array.\n        for (uint256 i = 0; i < rentalAssetUpdateLength; ++i) {\n            // Define the placeholders.\n            RentalId rentalId;\n            uint256 amount;\n\n            // Extract the current element from the byte data.\n            assembly {\n                // Determine element offset by multiplying the length of a\n                // RentalAssetUpdate struct (0x40) by the current index, then\n                // add a word to make sure the next word is accessed because the\n                // offset defaults to being set to the length pointer.\n                let currentElementOffset := add(0x20, mul(i, 0x40))\n\n                // Load the rental ID starting at the data pointer.\n                rentalId := mload(add(rentalAssetUpdatePointer, currentElementOffset))\n\n                // Load the amount at the data pointer adjacent to it.\n                amount := mload(\n                    add(0x20, add(rentalAssetUpdatePointer, currentElementOffset))\n                )\n            }\n\n            // Set the items\n            updates[i] = RentalAssetUpdate(rentalId, amount);\n        }\n    }\n}"
    }
  ]
}