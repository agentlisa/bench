{
  "Title": "[L06] Proxy ownership fragility",
  "Content": "After deploying an `InitializableProxy`, the `ProxyCloneFactory` [transfers ownership of the proxy to itself](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/ProxyCloneFactory.sol#L58). This potentially allows the proxy to invoke its own administration functions. Since the proxyâ€™s functionality is determined by its logic contract, whether this is possible or desirable depends on the particular use case and implementation, but that may not be obvious when constructing the logic contract. In particular, implementations that permit arbitrary function calls may accidentally introduce this behavior. Consider documenting this possibility in the [`deploy` function](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/ProxyCloneFactory.sol#L49) comments so that proxy users are aware of the risk.\n\n\n**Update:** *Fixed in commit [222644b](https://github.com/celo-org/celo-monorepo/commit/222644b692f54632a52e6850c8cf1911dbb4238e).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/ProxyCloneFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./InitializableProxy.sol\";\n\n/**\n * @title A factory for deploying EIP-1167 clones of upgradable Proxy contracts.\n */\ncontract ProxyCloneFactory is Ownable {\n  // The address of the Proxy implementation to clone.\n  address public proxyImplementationAddress;\n  event ProxyCloneCreated(address proxyClone);\n\n  /**\n   * @notice Sets the address of the Proxy implementation to clone.\n   * @param _proxyImplementationAddress The address of the Proxy implementation to clone.\n   */\n  function setImplementationAddress(address _proxyImplementationAddress) external onlyOwner {\n    proxyImplementationAddress = _proxyImplementationAddress;\n  }\n\n  // TODO: Upgrade solc version and import from open-zeppelin instead.\n  /**\n   * @notice Creates an EIP-1167 style clone of the specified `_proxyImplementationAddress`.\n   * @param _proxyImplementationAddress The address of the Proxy implementation to clone.\n   * @return The address of the clone.\n   * @dev Copied from open-zeppelin.\n   */\n  function clone(address _proxyImplementationAddress) internal returns (address instance) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(ptr, 0x14), shl(0x60, _proxyImplementationAddress))\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      instance := create(0, ptr, 0x37)\n    }\n    require(instance != address(0), \"ERC1167: create failed\");\n  }\n\n  /**\n   * @notice Creates an EIP-1167 style clone of a Proxy contract, points the Proxy to an\n   *         implementation and initializes it.\n   * @param implementation The address to point the Proxy to.\n   * @param initCallData The function to call on the implementation and the corresponding args.\n   */\n  function deploy(address implementation, bytes calldata initCallData) external {\n    // Cast to prevent compiler from complaining about the output of clone() not being payable.\n    InitializableProxy proxyClone = InitializableProxy(\n      address(uint160(clone(proxyImplementationAddress)))\n    );\n    proxyClone._initialize(address(this));\n    proxyClone._setAndInitializeImplementation(implementation, initCallData);\n    // TODO(asa): In the current version of Komenci we transfer proxy ownership to the user.\n    // Need to decide which to do.\n    proxyClone._transferOwnership(address(proxyClone));\n    emit ProxyCloneCreated(address(proxyClone));\n  }\n}"
    }
  ]
}