{
  "Title": "[G-11] Duplicated require()/revert() checks should be refactored to a modifier or function",
  "Content": "This saves deployment gas.\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CCash.sol#L151-L154\n```solidity\nFile: /contracts/lending/tokens/cCash/CCash.sol\n151:    require(\n152:      msg.sender == admin,\n153:      \"cErc20::sweepToken: only admin can sweep tokens\"\n154:    );\n```\n\nThe above check is also repeated on [Line 269](https://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CCash.sol#L269-L272)\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CErc20.sol#L151-L154\n```solidity\nFile: /contracts/lending/tokens/cToken/CErc20.sol\n151:    require(\n152:      msg.sender == admin,\n153:      \"cErc20::sweepToken: only admin can sweep tokens\"\n154:    );\n```\n\nRepeated on the following:\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CErc20.sol#L269-L272\n\n**Other instances**<br>\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CCashDelegate.sol#L30-L33\n```solidity\nFile: /contracts/lending/tokens/cCash/CCashDelegate.sol\n30:    require(\n31:      msg.sender == admin,\n32:      \"only the admin may call _becomeImplementation\"\n33:    );\n\n45:    require(\n46:      msg.sender == admin,\n47:      \"only the admin may call _resignImplementation\"\n48:    );\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenDelegate.sol#L30-L33\n```solidity\nFile: /contracts/lending/tokens/cToken/CTokenDelegate.sol\n30:    require(\n31:      msg.sender == admin,\n32:      \"only the admin may call _becomeImplementation\"\n33:    );\n\n45:    require(\n46:      msg.sender == admin,\n47:      \"only the admin may call _resignImplementation\"\n48:    );\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L44\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n44:    require(msg.sender == admin, \"only admin may initialize the market\");\n```\nWe can have a modifier that checks that the msg.sender is the admin. Unless we really need to have different error messages we could generalize the errors for all functions that expect to be called by an admin. \n\nThe above check or a variation of it is found on the following lines\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L1064-L1066\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n1064:    if (msg.sender != admin) {\n1065:      revert SetPendingAdminOwnerCheck();\n1066:    }\n\n\n1116:    if (msg.sender != admin) {\n1117:      revert SetComptrollerOwnerCheck();\n1118:    }\n\n\n1155:    if (msg.sender != admin) {\n1156:      revert SetReserveFactorAdminCheck();\n1157:    }\n\n1258:    if (msg.sender != admin) {\n1259:      revert ReduceReservesAdminCheck();\n1260:    }\n\n1321:    if (msg.sender != admin) {\n1322:      revert SetInterestRateModelOwnerCheck();\n1323:    }\n\n1357:    require(msg.sender == admin, \"Only admin can set KYC requirement group\");\n\n1379:    require(msg.sender == admin, \"Only admin can set KYC registry\");\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenModified.sol#L44\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n\n44:    require(msg.sender == admin, \"only admin may initialize the market\");\n\n1064:    if (msg.sender != admin) {\n1065:      revert SetPendingAdminOwnerCheck();\n1066:    }\n\n1116:    if (msg.sender != admin) {\n1117:      revert SetComptrollerOwnerCheck();\n1118:    }\n\n1155:    if (msg.sender != admin) {\n1156:      revert SetReserveFactorAdminCheck();\n1157:    }\n\n1261:    if (msg.sender != admin) {\n1262:      revert ReduceReservesAdminCheck();\n1263:    }\n\n1324:    if (msg.sender != admin) {\n1325:      revert SetInterestRateModelOwnerCheck();\n1326:    }\n\n1360:    require(msg.sender == admin, \"Only admin can set KYC requirement group\");\n\n1382:    require(msg.sender == admin, \"Only admin can set KYC registry\");\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-ondo-finance-contest",
  "Code": [
    {
      "filename": "contracts/lending/tokens/cCash/CCash.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CTokenCash.sol\";\n\ninterface CompLike {\n  function delegate(address delegatee) external;\n}\n\n/**\n * @title Ondo's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev Compatible with CTokenCash contract\n * @author Compound + Ondo\n */\ncontract CCash is CTokenCash, CErc20Interface {\n  /**\n   * @notice Initialize the new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param decimals_ ERC-20 decimal precision of this token\n   * @param kycRegistry_ KYC Registry contract address\n   * @param kycRequirementGroup_ KYC Requirement group to check KYC status\n   *                             against\n   */\n  function initialize(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address kycRegistry_,\n    uint kycRequirementGroup_\n  ) public {\n    // CToken initialize does the bulk of the work\n    super.initialize(\n      comptroller_,\n      interestRateModel_,\n      initialExchangeRateMantissa_,\n      name_,\n      symbol_,\n      decimals_,\n      kycRegistry_,\n      kycRequirementGroup_\n    );\n\n    // Set underlying and sanity check it\n    underlying = underlying_;\n    EIP20Interface(underlying).totalSupply();\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint mintAmount) external override returns (uint) {\n    mintInternal(mintAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint redeemTokens) external override returns (uint) {\n    redeemInternal(redeemTokens);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(\n    uint redeemAmount\n  ) external override returns (uint) {\n    redeemUnderlyingInternal(redeemAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint borrowAmount) external override returns (uint) {\n    borrowInternal(borrowAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrow(uint repayAmount) external override returns (uint) {\n    repayBorrowInternal(repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrowBehalf(\n    address borrower,\n    uint repayAmount\n  ) external override returns (uint) {\n    repayBorrowBehalfInternal(borrower, repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function liquidateBorrow(\n    address borrower,\n    uint repayAmount,\n    CTokenInterface cTokenCollateral\n  ) external override returns (uint) {\n    liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n   * @param token The address of the ERC-20 token to sweep\n   */\n  function sweepToken(EIP20NonStandardInterface token) external override {\n    require(\n      msg.sender == admin,\n      \"cErc20::sweepToken: only admin can sweep tokens\"\n    );\n    require(\n      address(token) != underlying,\n      \"cErc20::sweepToken: can not sweep underlying token\"\n    );\n    uint256 balance = token.balanceOf(address(this));\n    token.transfer(admin, balance);\n  }\n\n  /**\n   * @notice The sender adds to reserves.\n   * @param addAmount The amount fo underlying token to add as reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReserves(uint addAmount) external override returns (uint) {\n    return _addReservesInternal(addAmount);\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashPrior() internal view virtual override returns (uint) {\n    EIP20Interface token = EIP20Interface(underlying);\n    return token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n   *      This will revert due to insufficient balance or insufficient allowance.\n   *      This function returns the actual amount received,\n   *      which may be less than `amount` if there is a fee attached to the transfer.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferIn(\n    address from,\n    uint amount\n  ) internal virtual override returns (uint) {\n    // Read from storage once\n    address underlying_ = underlying;\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\n    uint balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));\n    token.transferFrom(from, address(this), amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of override external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n    // Calculate the amount that was *actually* transferred\n    uint balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));\n    return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n   *      it is >= amount, this should not revert in normal conditions.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferOut(\n    address payable to,\n    uint amount\n  ) internal virtual override {\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n    token.transfer(to, amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of override external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n  }\n\n  /**\n   * @notice Admin call to delegate the votes of the COMP-like underlying\n   * @param compLikeDelegatee The address to delegate votes to\n   * @dev CTokens whose underlying are not CompLike should revert here\n   */\n  function _delegateCompLikeTo(address compLikeDelegatee) external {\n    require(\n      msg.sender == admin,\n      \"only the admin may set the comp-like delegate\"\n    );\n    CompLike(underlying).delegate(compLikeDelegatee);\n  }\n}"
    },
    {
      "filename": "contracts/lending/tokens/cCash/CCash.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CTokenCash.sol\";\n\ninterface CompLike {\n  function delegate(address delegatee) external;\n}\n\n/**\n * @title Ondo's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev Compatible with CTokenCash contract\n * @author Compound + Ondo\n */\ncontract CCash is CTokenCash, CErc20Interface {\n  /**\n   * @notice Initialize the new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param decimals_ ERC-20 decimal precision of this token\n   * @param kycRegistry_ KYC Registry contract address\n   * @param kycRequirementGroup_ KYC Requirement group to check KYC status\n   *                             against\n   */\n  function initialize(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address kycRegistry_,\n    uint kycRequirementGroup_\n  ) public {\n    // CToken initialize does the bulk of the work\n    super.initialize(\n      comptroller_,\n      interestRateModel_,\n      initialExchangeRateMantissa_,\n      name_,\n      symbol_,\n      decimals_,\n      kycRegistry_,\n      kycRequirementGroup_\n    );\n\n    // Set underlying and sanity check it\n    underlying = underlying_;\n    EIP20Interface(underlying).totalSupply();\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint mintAmount) external override returns (uint) {\n    mintInternal(mintAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint redeemTokens) external override returns (uint) {\n    redeemInternal(redeemTokens);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(\n    uint redeemAmount\n  ) external override returns (uint) {\n    redeemUnderlyingInternal(redeemAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint borrowAmount) external override returns (uint) {\n    borrowInternal(borrowAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrow(uint repayAmount) external override returns (uint) {\n    repayBorrowInternal(repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrowBehalf(\n    address borrower,\n    uint repayAmount\n  ) external override returns (uint) {\n    repayBorrowBehalfInternal(borrower, repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function liquidateBorrow(\n    address borrower,\n    uint repayAmount,\n    CTokenInterface cTokenCollateral\n  ) external override returns (uint) {\n    liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n   * @param token The address of the ERC-20 token to sweep\n   */\n  function sweepToken(EIP20NonStandardInterface token) external override {\n    require(\n      msg.sender == admin,\n      \"cErc20::sweepToken: only admin can sweep tokens\"\n    );\n    require(\n      address(token) != underlying,\n      \"cErc20::sweepToken: can not sweep underlying token\"\n    );\n    uint256 balance = token.balanceOf(address(this));\n    token.transfer(admin, balance);\n  }\n\n  /**\n   * @notice The sender adds to reserves.\n   * @param addAmount The amount fo underlying token to add as reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReserves(uint addAmount) external override returns (uint) {\n    return _addReservesInternal(addAmount);\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashPrior() internal view virtual override returns (uint) {\n    EIP20Interface token = EIP20Interface(underlying);\n    return token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n   *      This will revert due to insufficient balance or insufficient allowance.\n   *      This function returns the actual amount received,\n   *      which may be less than `amount` if there is a fee attached to the transfer.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferIn(\n    address from,\n    uint amount\n  ) internal virtual override returns (uint) {\n    // Read from storage once\n    address underlying_ = underlying;\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\n    uint balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));\n    token.transferFrom(from, address(this), amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of override external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n    // Calculate the amount that was *actually* transferred\n    uint balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));\n    return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n   *      it is >= amount, this should not revert in normal conditions.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferOut(\n    address payable to,\n    uint amount\n  ) internal virtual override {\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n    token.transfer(to, amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of override external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n  }\n\n  /**\n   * @notice Admin call to delegate the votes of the COMP-like underlying\n   * @param compLikeDelegatee The address to delegate votes to\n   * @dev CTokens whose underlying are not CompLike should revert here\n   */\n  function _delegateCompLikeTo(address compLikeDelegatee) external {\n    require(\n      msg.sender == admin,\n      \"only the admin may set the comp-like delegate\"\n    );\n    CompLike(underlying).delegate(compLikeDelegatee);\n  }\n}"
    },
    {
      "filename": "contracts/lending/tokens/cToken/CErc20.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CTokenModified.sol\";\n\ninterface CompLike {\n  function delegate(address delegatee) external;\n}\n\n/**\n * @title Ondo's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev Compatible with CTokenModified contract\n * @author Compound + Ondo\n */\ncontract CErc20 is CTokenModified, CErc20Interface {\n  /**\n   * @notice Initialize the new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param decimals_ ERC-20 decimal precision of this token\n   * @param kycRegistry_ KYC Registry contract address\n   * @param kycRequirementGroup_ KYC Requirement group to check KYC status\n   *                             against\n   */\n  function initialize(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address kycRegistry_,\n    uint kycRequirementGroup_\n  ) public {\n    // CToken initialize does the bulk of the work\n    super.initialize(\n      comptroller_,\n      interestRateModel_,\n      initialExchangeRateMantissa_,\n      name_,\n      symbol_,\n      decimals_,\n      kycRegistry_,\n      kycRequirementGroup_\n    );\n\n    // Set underlying and sanity check it\n    underlying = underlying_;\n    EIP20Interface(underlying).totalSupply();\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint mintAmount) external override returns (uint) {\n    mintInternal(mintAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint redeemTokens) external override returns (uint) {\n    redeemInternal(redeemTokens);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(\n    uint redeemAmount\n  ) external override returns (uint) {\n    redeemUnderlyingInternal(redeemAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint borrowAmount) external override returns (uint) {\n    borrowInternal(borrowAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrow(uint repayAmount) external override returns (uint) {\n    repayBorrowInternal(repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrowBehalf(\n    address borrower,\n    uint repayAmount\n  ) external override returns (uint) {\n    repayBorrowBehalfInternal(borrower, repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function liquidateBorrow(\n    address borrower,\n    uint repayAmount,\n    CTokenInterface cTokenCollateral\n  ) external override returns (uint) {\n    liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n   * @param token The address of the ERC-20 token to sweep\n   */\n  function sweepToken(EIP20NonStandardInterface token) external override {\n    require(\n      msg.sender == admin,\n      \"cErc20::sweepToken: only admin can sweep tokens\"\n    );\n    require(\n      address(token) != underlying,\n      \"cErc20::sweepToken: can not sweep underlying token\"\n    );\n    uint256 balance = token.balanceOf(address(this));\n    token.transfer(admin, balance);\n  }\n\n  /**\n   * @notice The sender adds to reserves.\n   * @param addAmount The amount fo underlying token to add as reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReserves(uint addAmount) external override returns (uint) {\n    return _addReservesInternal(addAmount);\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashPrior() internal view virtual override returns (uint) {\n    EIP20Interface token = EIP20Interface(underlying);\n    return token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n   *      This will revert due to insufficient balance or insufficient allowance.\n   *      This function returns the actual amount received,\n   *      which may be less than `amount` if there is a fee attached to the transfer.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferIn(\n    address from,\n    uint amount\n  ) internal virtual override returns (uint) {\n    // Read from storage once\n    address underlying_ = underlying;\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\n    uint balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));\n    token.transferFrom(from, address(this), amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of override external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n    // Calculate the amount that was *actually* transferred\n    uint balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));\n    return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n   *      it is >= amount, this should not revert in normal conditions.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferOut(\n    address payable to,\n    uint amount\n  ) internal virtual override {\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n    token.transfer(to, amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of override external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n  }\n\n  /**\n   * @notice Admin call to delegate the votes of the COMP-like underlying\n   * @param compLikeDelegatee The address to delegate votes to\n   * @dev CTokens whose underlying are not CompLike should revert here\n   */\n  function _delegateCompLikeTo(address compLikeDelegatee) external {\n    require(\n      msg.sender == admin,\n      \"only the admin may set the comp-like delegate\"\n    );\n    CompLike(underlying).delegate(compLikeDelegatee);\n  }\n}"
    },
    {
      "filename": "contracts/lending/tokens/cToken/CErc20.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CTokenModified.sol\";\n\ninterface CompLike {\n  function delegate(address delegatee) external;\n}\n\n/**\n * @title Ondo's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev Compatible with CTokenModified contract\n * @author Compound + Ondo\n */\ncontract CErc20 is CTokenModified, CErc20Interface {\n  /**\n   * @notice Initialize the new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param decimals_ ERC-20 decimal precision of this token\n   * @param kycRegistry_ KYC Registry contract address\n   * @param kycRequirementGroup_ KYC Requirement group to check KYC status\n   *                             against\n   */\n  function initialize(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address kycRegistry_,\n    uint kycRequirementGroup_\n  ) public {\n    // CToken initialize does the bulk of the work\n    super.initialize(\n      comptroller_,\n      interestRateModel_,\n      initialExchangeRateMantissa_,\n      name_,\n      symbol_,\n      decimals_,\n      kycRegistry_,\n      kycRequirementGroup_\n    );\n\n    // Set underlying and sanity check it\n    underlying = underlying_;\n    EIP20Interface(underlying).totalSupply();\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint mintAmount) external override returns (uint) {\n    mintInternal(mintAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint redeemTokens) external override returns (uint)"
    }
  ]
}