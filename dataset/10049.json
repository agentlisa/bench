{
  "Title": "[M-03] It is possible to “uninitialize” ERC20Facet contract",
  "Content": "<h2 id=\"m-03-it-is-possible-to-uninitialize-erc20facet-contract\" style=\"position:relative;\"><a href=\"#m-03-it-is-possible-to-uninitialize-erc20facet-contract\" aria-label=\"m 03 it is possible to uninitialize erc20facet contract permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"View%20on%20GitHub\">[M-03] It is possible to “uninitialize” <code>ERC20Facet</code> contract</a></h2>\n<p><em>Submitted by Czar102</em></p>\n<h4 id=\"impact-3\" style=\"position:relative;\"><a href=\"#impact-3\" aria-label=\"impact 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The initialization status is defined by the <a href=\"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/ERC20/ERC20Facet.sol#L25-L28\">name and symbol</a>. It is possible it set them back to an empty string, uninitializing the contract and letting the <code>initialize(..)</code> function be called again. This way, the owner may, for example, hide minting additional tokens. Or, after accidentally setting name and symbol to empty strings, anyone can take control over the contract and mint any number of tokens.</p>\n<p>In general, it shouldn’t be possible to initialize more than once.</p>\n<h4 id=\"recommended-mitigation-steps-4\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-4\" aria-label=\"recommended mitigation steps 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Consider adding empty string checks in <code>setName(...)</code> and <code>setSymbol(...)</code> functions.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-12-amun-findings/issues/276\">loki-sama (Amun) confirmed</a></strong> </p>\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2021-12-amun-contest",
  "Code": [
    {
      "filename": "contracts/basket/contracts/facets/ERC20/ERC20Facet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.5;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@pie-dao/diamond/contracts/libraries/LibDiamond.sol\";\n\nimport \"../../interfaces/IERC20Facet.sol\";\nimport \"./LibERC20Storage.sol\";\nimport \"./LibERC20.sol\";\nimport \"../shared/Access/CallProtection.sol\";\n\ncontract ERC20Facet is IERC20, IERC20Facet, CallProtection {\n    using SafeMath for uint256;\n\n    function initialize(\n        uint256 _initialSupply,\n        string memory _name,\n        string memory _symbol\n    ) external override {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        LibERC20Storage.ERC20Storage storage es =\n            LibERC20Storage.erc20Storage();\n\n        require(\n            bytes(es.name).length == 0 && bytes(es.symbol).length == 0,\n            \"ALREADY_INITIALIZED\"\n        );\n\n        require(\n            bytes(_name).length != 0 && bytes(_symbol).length != 0,\n            \"INVALID_PARAMS\"\n        );\n\n        require(msg.sender == ds.contractOwner, \"Must own the contract.\");\n\n        LibERC20.mint(msg.sender, _initialSupply);\n\n        es.name = _name;\n        es.symbol = _symbol;\n    }\n\n    function name() external view override returns (string memory) {\n        return LibERC20Storage.erc20Storage().name;\n    }\n\n    function setName(string calldata _name) external override protectedCall {\n        LibERC20Storage.erc20Storage().name = _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return LibERC20Storage.erc20Storage().symbol;\n    }\n\n    function setSymbol(string calldata _symbol)\n        external\n        override\n        protectedCall\n    {\n        LibERC20Storage.erc20Storage().symbol = _symbol;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n\n    function mint(address _receiver, uint256 _amount)\n        external\n        override\n        protectedCall\n    {\n        LibERC20.mint(_receiver, _amount);\n    }\n\n    function burn(address _from, uint256 _amount)\n        external\n        override\n        protectedCall\n    {\n        LibERC20.burn(_from, _amount);\n    }\n\n    function approve(address _spender, uint256 _amount)\n        external\n        override\n        returns (bool)\n    {\n        require(_spender != address(0), \"SPENDER_INVALID\");\n        LibERC20Storage.erc20Storage().allowances[msg.sender][\n            _spender\n        ] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function increaseApproval(address _spender, uint256 _amount)\n        external\n        override\n        returns (bool)\n    {\n        require(_spender != address(0), \"SPENDER_INVALID\");\n        LibERC20Storage.ERC20Storage storage es =\n            LibERC20Storage.erc20Storage();\n        es.allowances[msg.sender][_spender] = es.allowances[msg.sender][\n            _spender\n        ]\n            .add(_amount);\n        emit Approval(\n            msg.sender,\n            _spender,\n            es.allowances[msg.sender][_spender]\n        );\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint256 _amount)\n        external\n        override\n        returns (bool)\n    {\n        require(_spender != address(0), \"SPENDER_INVALID\");\n        LibERC20Storage.ERC20Storage storage es =\n            LibERC20Storage.erc20Storage();\n        uint256 oldValue = es.allowances[msg.sender][_spender];\n        if (_amount > oldValue) {\n            es.allowances[msg.sender][_spender] = 0;\n        } else {\n            es.allowances[msg.sender][_spender] = oldValue.sub(_amount);\n        }\n        emit Approval(\n            msg.sender,\n            _spender,\n            es.allowances[msg.sender][_spender]\n        );\n        return true;\n    }\n\n    function transfer(address _to, uint256 _amount)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external override returns (bool) {\n        LibERC20Storage.ERC20Storage storage es =\n            LibERC20Storage.erc20Storage();\n        require(_from != address(0), \"FROM_INVALID\");\n\n        // Update approval if not set to max uint256\n        if (es.allowances[_from][msg.sender] != uint256(-1)) {\n            uint256 newApproval = es.allowances[_from][msg.sender].sub(_amount);\n            es.allowances[_from][msg.sender] = newApproval;\n            emit Approval(_from, msg.sender, newApproval);\n        }\n\n        _transfer(_from, _to, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return LibERC20Storage.erc20Storage().allowances[_owner][_spender];\n    }\n\n    function balanceOf(address _of) external view override returns (uint256) {\n        return LibERC20Storage.erc20Storage().balances[_of];\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return LibERC20Storage.erc20Storage().totalSupply;\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        LibERC20Storage.ERC20Storage storage es =\n            LibERC20Storage.erc20Storage();\n\n        es.balances[_from] = es.balances[_from].sub(_amount);\n        es.balances[_to] = es.balances[_to].add(_amount);\n\n        emit Transfer(_from, _to, _amount);\n    }\n}"
    }
  ]
}