{
  "Title": "Modiﬁcations make the safeApprove function unsafe",
  "Content": "Type:   Undeﬁned   Behavior\nTarget:    YVaultMarket.sol ,    CompoundERC20Market.sol ,    BProtocolMarket.sol,\nHarvestMarket.sol\n\nDiﬃculty:   Medium\nDescription\nThe   protocol   uses   a   modiﬁed   version   of   OpenZeppelin’s    SafeERC20.sol .   The\nSafeERC20.safeApprove    function   provides   some   protection   against   the    approve\nfront-running   attack ,   as   it   permits   an   allowance   to    be   set   only   to   zero   or   from   zero .   Certain\ntokens,   like    USDT ,   also   provide   this   protection.   However,   the   88mph   protocol   does   not\nhandle   approval   operations   in   this   way;   rather,   allowances   need   to   be   increased   by   a\nspeciﬁc   value,   regardless   of   the   current   value.   To   allow   the   use   of   tokens   like    USDT ,   which\nare   not   compatible   with   this   system,   the   88mph   team   modiﬁed   the    safeApprove    function.\nThe   modiﬁed    safeApprove    function   does   not   oﬀer   protection   against   the    approve\nfront-running   attack.\nThe    safeApprove    function   has   been    deprecated   by   OpenZeppelin .\n/**\n@dev   Modified   from   openzeppelin.   Instead   of   reverting   when   the   allowance   is   non-zero\nand   value\nis   non-zero,   we   first   set   the   allowance   to   0   and   then   call   approve(spender,   value).\nThis   provides   support   for   non-standard   tokens   such   as   USDT   that   revert   in   this\nscenario.\n*/\nfunction   safeApprove(\nIERC20   token,\naddress   spender,\nuint256   value\n)   internal   {\nif   ((token.allowance(address(this),   spender))   >   0)   {\n_callOptionalReturn(\ntoken,\nabi.encodeWithSelector(token.approve.selector,   spender,   0)\n);\n}\n_callOptionalReturn(\ntoken,\nabi.encodeWithSelector(token.approve.selector,   spender,   value)\n);\n}\n©   2021   Trail   of   Bits\n88mph   v3   Assessment   |   31\nFigure   13.1:   Modiﬁed    SafeERC20.sol#L43-63\nAll   uses   of    safeApprove    within   the   protocol   are   immediately   followed   by   a   call   to\ntransferFrom ,   making   front-running   impossible.   Therefore,   the   severity   of   this   issue   is\ninformational.\nHowever,   the   existence   of   a   function   called    safeApprove    that   does   not   match   the   expected\nsemantics   of   OpenZeppelin’s   standard    safeApprove    is   problematic.\nExploit   Scenario\nDeveloper   Alice   uses    safeApprove ,   assuming   it   is   safe   and   provides   some   protection\nagainst   the    approve    front-running   attack .   However,   the   function   is   not   safe,   and   users   are\nvulnerable   to   the    approve    front-running   attack.\nRecommendations\nShort   term,   remove   the   modiﬁed    libs/SafeERC20.sol    and   import\n@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol    instead.   Replace\nsafeApprove    with   a   custom   function   with   a   descriptive   name,   like\nunsafeApproveSupportingNonStandardTokens ,   and   properly   document   its   security\nimplications   and   the   reasoning   behind   its   use.\nLong   term,   read   the   references   below   to   better   understand   the    approve    front-running\nattack,   and   ensure   that   it   is   mitigated   throughout   the   codebase.\nReferences\n● ERC20   API:   An   Attack   Vector   on   Approve/TransferFrom   Methods\n● https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve\n©   2021   Trail   of   Bits\n88mph   v3   Assessment   |   32",
  "Impact": "LOW",
  "Source": "https://github.com/trailofbits/publications/blob/master/reviews/88mph.pdf",
  "Code": [
    {
      "filename": "EIPS/eip-20.md",
      "content": "---\neip: 20\ncategory: ERC\nstatus: Moved\n---\n\nThis file was moved to https://github.com/ethereum/ercs/blob/master/ERCS/erc-20.md"
    }
  ]
}