{
  "Title": "Block Container Does Not Enforce Whitelist",
  "Content": "In the `L1BlockContainer` contract, the `importBlockHeader` function can [be called by anyone if the whitelist address has not been initialized](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/predeploys/L1BlockContainer.sol#L121).\n\n\nThe block container contract is used to check the state root when doing an inclusion proof in the [`verifyMessage{Inclusion|Execution}Status` function](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/L2ScrollMessenger.sol#L115-L183). Hence, an attacker can determine which messages are seen as sent or executed on L1. Although the attacker cannot relay or retry any message on L2 because they are not the L1ScrollMessenger address, they can overwrite the state root to [make retry messages fail](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/L2ScrollMessenger.sol#L244-L247).\n\n\nConsider preventing the `importBlockHeader` function to be called if the `whitelist` address is zero.\n\n\n***Update:** Resolved in [pull request #651](https://github.com/scroll-tech/scroll/pull/651) at commit [6959d82](https://github.com/scroll-tech/scroll/pull/651/commits/6959d82372df0ff48ce1bdcdbffbb55138e14639).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L2/predeploys/L1BlockContainer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IL1BlockContainer} from \"./IL1BlockContainer.sol\";\nimport {IL1GasPriceOracle} from \"./IL1GasPriceOracle.sol\";\n\nimport {OwnableBase} from \"../../libraries/common/OwnableBase.sol\";\nimport {IWhitelist} from \"../../libraries/common/IWhitelist.sol\";\nimport {ScrollPredeploy} from \"../../libraries/constants/ScrollPredeploy.sol\";\n\n/// @title L1BlockContainer\n/// @notice This contract will maintain the list of blocks proposed in L1.\ncontract L1BlockContainer is OwnableBase, IL1BlockContainer {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates whitelist contract.\n    /// @param _oldWhitelist The address of old whitelist contract.\n    /// @param _newWhitelist The address of new whitelist contract.\n    event UpdateWhitelist(address _oldWhitelist, address _newWhitelist);\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @dev Compiler will pack this into single `uint256`.\n    struct BlockMetadata {\n        // The block height.\n        uint64 height;\n        // The block timestamp.\n        uint64 timestamp;\n        // The base fee in the block.\n        uint128 baseFee;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of whitelist contract.\n    IWhitelist public whitelist;\n\n    /// @inheritdoc IL1BlockContainer\n    bytes32 public override latestBlockHash;\n\n    /// @notice Mapping from block hash to corresponding state root.\n    mapping(bytes32 => bytes32) public stateRoot;\n\n    /// @notice Mapping from block hash to corresponding block metadata,\n    /// including timestamp and height.\n    mapping(bytes32 => BlockMetadata) public metadata;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _owner) {\n        _transferOwnership(_owner);\n    }\n\n    function initialize(\n        bytes32 _startBlockHash,\n        uint64 _startBlockHeight,\n        uint64 _startBlockTimestamp,\n        uint128 _startBlockBaseFee,\n        bytes32 _startStateRoot\n    ) external onlyOwner {\n        require(latestBlockHash == bytes32(0), \"already initialized\");\n\n        latestBlockHash = _startBlockHash;\n        stateRoot[_startBlockHash] = _startStateRoot;\n        metadata[_startBlockHash] = BlockMetadata(_startBlockHeight, _startBlockTimestamp, _startBlockBaseFee);\n\n        emit ImportBlock(_startBlockHash, _startBlockHeight, _startBlockTimestamp, _startBlockBaseFee, _startStateRoot);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1BlockContainer\n    function latestBaseFee() external view override returns (uint256) {\n        return metadata[latestBlockHash].baseFee;\n    }\n\n    /// @inheritdoc IL1BlockContainer\n    function latestBlockNumber() external view override returns (uint256) {\n        return metadata[latestBlockHash].height;\n    }\n\n    /// @inheritdoc IL1BlockContainer\n    function latestBlockTimestamp() external view override returns (uint256) {\n        return metadata[latestBlockHash].timestamp;\n    }\n\n    /// @inheritdoc IL1BlockContainer\n    function getStateRoot(bytes32 _blockHash) external view returns (bytes32) {\n        return stateRoot[_blockHash];\n    }\n\n    /// @inheritdoc IL1BlockContainer\n    function getBlockTimestamp(bytes32 _blockHash) external view returns (uint256) {\n        return metadata[_blockHash].timestamp;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1BlockContainer\n    function importBlockHeader(\n        bytes32 _blockHash,\n        bytes calldata _blockHeaderRLP,\n        bool _updateGasPriceOracle\n    ) external {\n        {\n            IWhitelist _whitelist = whitelist;\n            require(\n                address(_whitelist) == address(0) || _whitelist.isSenderAllowed(msg.sender),\n                \"Not whitelisted sender\"\n            );\n        }\n\n        // The encoding order in block header is\n        // 1. ParentHash: 32 bytes\n        // 2. UncleHash: 32 bytes\n        // 3. Coinbase: 20 bytes\n        // 4. StateRoot: 32 bytes\n        // 5. TransactionsRoot: 32 bytes\n        // 6. ReceiptsRoot: 32 bytes\n        // 7. LogsBloom: 256 bytes\n        // 8. Difficulty: uint\n        // 9. BlockHeight: uint\n        // 10. GasLimit: uint64\n        // 11. GasUsed: uint64\n        // 12. BlockTimestamp: uint64\n        // 13. ExtraData: several bytes\n        // 14. MixHash: 32 bytes\n        // 15. BlockNonce: 8 bytes\n        // 16. BaseFee: uint // optional\n        bytes32 _parentHash;\n        bytes32 _stateRoot;\n        uint64 _height;\n        uint64 _timestamp;\n        uint128 _baseFee;\n\n        assembly {\n            // reverts with error `msg`.\n            // make sure the length of error string <= 32\n            function revertWith(msg) {\n                // keccak(\"Error(string)\")\n                mstore(0x00, shl(224, 0x08c379a0))\n                mstore(0x04, 0x20) // str.offset\n                mstore(0x44, msg)\n                let msgLen\n                for {\n\n                } msg {\n\n                } {\n                    msg := shl(8, msg)\n                    msgLen := add(msgLen, 1)\n                }\n                mstore(0x24, msgLen) // str.length\n                revert(0x00, 0x64)\n            }\n            // reverts with `msg` when condition is not matched.\n            // make sure the length of error string <= 32\n            function require(cond, msg) {\n                if iszero(cond) {\n                    revertWith(msg)\n                }\n            }\n            // returns the calldata offset of the value and the length in bytes\n            // for the RLP encoded data item at `ptr`. used in `decodeFlat`\n            function decodeValue(ptr) -> dataLen, valueOffset {\n                let b0 := byte(0, calldataload(ptr))\n\n                // 0x00 - 0x7f, single byte\n                if lt(b0, 0x80) {\n                    // for a single byte whose value is in the [0x00, 0x7f] range,\n                    // that byte is its own RLP encoding.\n                    dataLen := 1\n                    valueOffset := ptr\n                    leave\n                }\n\n                // 0x80 - 0xb7, short string/bytes, length <= 55\n                if lt(b0, 0xb8) {\n                    // the RLP encoding consists of a single byte with value 0x80\n                    // plus the length of the string followed by the string.\n                    dataLen := sub(b0, 0x80)\n                    valueOffset := add(ptr, 1)\n                    leave\n                }\n\n                // 0xb8 - 0xbf, long string/bytes, length > 55\n                if lt(b0, 0xc0) {\n                    // the RLP encoding consists of a single byte with value 0xb7\n                    // plus the length in bytes of the length of the string in binary form,\n                    // followed by the length of the string, followed by the string.\n                    let lengthBytes := sub(b0, 0xb7)\n                    if gt(lengthBytes, 4) {\n                        invalid()\n                    }\n\n                    // load the extended length\n                    valueOffset := add(ptr, 1)\n                    let extendedLen := calldataload(valueOffset)\n                    let bits := sub(256, mul(lengthBytes, 8))\n                    extendedLen := shr(bits, extendedLen)\n\n                    dataLen := extendedLen\n                    valueOffset := add(valueOffset, lengthBytes)\n                    leave\n                }\n\n                revertWith(\"Not value\")\n            }\n\n            let ptr := _blockHeaderRLP.offset\n            let headerPayloadLength\n            {\n                let b0 := byte(0, calldataload(ptr))\n                // the input should be a long list\n                if lt(b0, 0xf8) {\n                    invalid()\n                }\n                let lengthBytes := sub(b0, 0xf7)\n                if gt(lengthBytes, 32) {\n                    invalid()\n                }\n                // load the extended length\n                ptr := add(ptr, 1)\n                headerPayloadLength := calldataload(ptr)\n                let bits := sub(256, mul(lengthBytes, 8))\n                // compute payload length: extended length + length bytes + 1\n                headerPayloadLength := shr(bits, headerPayloadLength)\n                headerPayloadLength := add(headerPayloadLength, lengthBytes)\n                headerPayloadLength := add(headerPayloadLength, 1)\n                ptr := add(ptr, lengthBytes)\n            }\n\n            let memPtr := mload(0x40)\n            calldatacopy(memPtr, _blockHeaderRLP.offset, headerPayloadLength)\n            let _computedBlockHash := keccak256(memPtr, headerPayloadLength)\n            require(eq(_blockHash, _computedBlockHash), \"Block hash mismatch\")\n\n            // load 16 vaules\n            for {\n                let i := 0\n            } lt(i, 16) {\n                i := add(i, 1)\n            } {\n                let len, offset := decodeValue(ptr)\n                // the value we care must have at most 32 bytes\n                if lt(len, 33) {\n                    let bits := mul(sub(32, len), 8)\n                    let value := calldataload(offset)\n                    value := shr(bits, value)\n                    mstore(memPtr, value)\n                }\n                memPtr := add(memPtr, 0x20)\n                ptr := add(len, offset)\n            }\n            require(eq(ptr, add(_blockHeaderRLP.offset, _blockHeaderRLP.length)), \"Header RLP length mismatch\")\n\n            memPtr := mload(0x40)\n            // load parent hash, 1-st entry\n            _parentHash := mload(memPtr)\n            // load state root, 4-th entry\n            _stateRoot := mload(add(memPtr, 0x60))\n            // load block height, 9-th entry\n            _height := mload(add(memPtr, 0x100))\n            // load block timestamp, 12-th entry\n            _timestamp := mload(add(memPtr, 0x160))\n            // load base fee, 16-th entry\n            _baseFee := mload(add(memPtr, 0x1e0))\n        }\n        require(stateRoot[_parentHash] != bytes32(0), \"Parent not imported\");\n        BlockMetadata memory _parentMetadata = metadata[_parentHash];\n        require(_parentMetadata.height + 1 == _height, \"Block height mismatch\");\n        require(_parentMetadata.timestamp <= _timestamp, \"Parent block has larger timestamp\");\n\n        latestBlockHash = _blockHash;\n        stateRoot[_blockHash] = _stateRoot;\n        metadata[_blockHash] = BlockMetadata(_height, _timestamp, _baseFee);\n\n        emit ImportBlock(_blockHash, _height, _timestamp, _baseFee, _stateRoot);\n\n        if (_updateGasPriceOracle) {\n            IL1GasPriceOracle(ScrollPredeploy.L1_GAS_PRICE_ORACLE).setL1BaseFee(_baseFee);\n        }\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update whitelist contract.\n    /// @dev This function can only called by contract owner.\n    /// @param _newWhitelist The address of new whitelist contract.\n    function updateWhitelist(address _newWhitelist) external onlyOwner {\n        address _oldWhitelist = address(whitelist);\n\n        whitelist = IWhitelist(_newWhitelist);\n        emit UpdateWhitelist(_oldWhitelist, _newWhitelist);\n    }\n}"
    },
    {
      "filename": "contracts/src/L2/L2ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IL2ScrollMessenger} from \"./IL2ScrollMessenger.sol\";\nimport {L2MessageQueue} from \"./predeploys/L2MessageQueue.sol\";\nimport {IL1BlockContainer} from \"./predeploys/IL1BlockContainer.sol\";\nimport {IL1GasPriceOracle} from \"./predeploys/IL1GasPriceOracle.sol\";\n\nimport {PatriciaMerkleTrieVerifier} from \"../libraries/verifier/PatriciaMerkleTrieVerifier.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {AddressAliasHelper} from \"../libraries/common/AddressAliasHelper.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\n\n/// @title L2ScrollMessenger\n/// @notice The `L2ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 2 to layer 1;\n/// 2. relay messages from layer 1 layer 2;\n/// 3. drop expired message due to sequencer problems.\n///\n/// @dev It should be a predeployed contract in layer 2 and should hold infinite amount\n/// of Ether (Specifically, `uint256(-1)`), which can be initialized in Genesis Block.\ncontract L2ScrollMessenger is ScrollMessengerBase, PausableUpgradeable, IL2ScrollMessenger {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can fail in L2 is updated.\n    /// @param maxFailedExecutionTimes The new maximum number of times each message can fail in L2.\n    event UpdateMaxFailedExecutionTimes(uint256 maxFailedExecutionTimes);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The contract contains the list of L1 blocks.\n    address public immutable blockContainer;\n\n    /// @notice The address of L2MessageQueue.\n    address public immutable gasOracle;\n\n    /// @notice The address of L2MessageQueue.\n    address public immutable messageQueue;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L2 message hash to sent status.\n    mapping(bytes32 => bool) public isL2MessageSent;\n\n    /// @notice Mapping from L1 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL1MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to the number of failure times.\n    mapping(bytes32 => uint256) public l1MessageFailedTimes;\n\n    /// @notice The maximum number of times each L1 message can fail on L2.\n    uint256 public maxFailedExecutionTimes;\n\n    // @note move to ScrollMessengerBase in next big refactor\n    /// @dev The status of for non-reentrant check.\n    uint256 private _lock_status;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_lock_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _lock_status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _lock_status = _NOT_ENTERED;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _blockContainer,\n        address _gasOracle,\n        address _messageQueue\n    ) {\n        blockContainer = _blockContainer;\n        gasOracle = _gasOracle;\n        messageQueue = _messageQueue;\n    }\n\n    function initialize(address _counterpart, address _feeVault) external initializer {\n        PausableUpgradeable.__Pausable_init();\n        ScrollMessengerBase._initialize(_counterpart, _feeVault);\n\n        maxFailedExecutionTimes = 3;\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Check whether the l1 message is included in the corresponding L1 block.\n    /// @param _blockHash The block hash where the message should in.\n    /// @param _msgHash The hash of the message to check.\n    /// @param _proof The encoded storage proof from eth_getProof.\n    /// @return bool Return true is the message is included in L1, otherwise return false.\n    function verifyMessageInclusionStatus(\n        bytes32 _blockHash,\n        bytes32 _msgHash,\n        bytes calldata _proof\n    ) public view returns (bool) {\n        bytes32 _expectedStateRoot = IL1BlockContainer(blockContainer).getStateRoot(_blockHash);\n        require(_expectedStateRoot != bytes32(0), \"Block is not imported\");\n\n        bytes32 _storageKey;\n        // `mapping(bytes32 => bool) public isL1MessageSent` is the 105-nd slot of contract `L1ScrollMessenger`.\n        // + 50 from `OwnableUpgradeable`\n        // + 4 from `ScrollMessengerBase`\n        // + 50 from `PausableUpgradeable`\n        // + 2-nd in `L1ScrollMessenger`\n        assembly {\n            mstore(0x00, _msgHash)\n            mstore(0x20, 105)\n            _storageKey := keccak256(0x00, 0x40)\n        }\n\n        (bytes32 _computedStateRoot, bytes32 _storageValue) = PatriciaMerkleTrieVerifier.verifyPatriciaProof(\n            counterpart,\n            _storageKey,\n            _proof\n        );\n        require(_computedStateRoot == _expectedStateRoot, \"State roots mismatch\");\n\n        return uint256(_storageValue) == 1;\n    }\n\n    /// @notice Check whether the message is executed in the corresponding L1 block.\n    /// @param _blockHash The block hash where the message should in.\n    /// @param _msgHash The hash of the message to check.\n    /// @param _proof The encoded storage proof from eth_getProof.\n    /// @return bool Return true is the message is executed in L1, otherwise return false.\n    function verifyMessageExecutionStatus(\n        bytes32 _blockHash,\n        bytes32 _msgHash,\n        bytes calldata _proof\n    ) external view returns (bool) {\n        bytes32 _expectedStateRoot = IL1BlockContainer(blockContainer).getStateRoot(_blockHash);\n        require(_expectedStateRoot != bytes32(0), \"Block not imported\");\n\n        bytes32 _storageKey;\n        // `mapping(bytes32 => bool) public isL2MessageExecuted` is the 106-th slot of contract `L1ScrollMessenger`.\n        // + 50 from `OwnableUpgradeable`\n        // + 4 from `ScrollMessengerBase`\n        // + 50 from `PausableUpgradeable`\n        // + 3-rd in `L1ScrollMessenger`\n        assembly {\n            mstore(0x00, _msgHash)\n            mstore(0x20, 106)\n            _storageKey := keccak256(0x00, 0x40)\n        }\n\n        (bytes32 _computedStateRoot, bytes32 _storageValue) = PatriciaMerkleTrieVerifier.verifyPatriciaProof(\n            counterpart,\n            _storageKey,\n            _proof\n        );\n        require(_computedStateRoot == _expectedStateRoot, \"State root mismatch\");\n\n        return uint256(_storageValue) == 1;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit);\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ScrollMessenger\n    function relayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message\n    ) external override whenNotPaused {\n        // It is impossible to deploy a contract with the same address, reentrance is prevented in nature.\n        require(AddressAliasHelper.undoL1ToL2Alias(msg.sender) == counterpart, \"Caller is not L1ScrollMessenger\");\n\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n\n        require(!isL1MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        _executeMessage(_from, _to, _value, _message, _xDomainCalldataHash);\n    }\n\n    /// @inheritdoc IL2ScrollMessenger\n    function retryMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L1MessageProof calldata _proof\n    ) external override whenNotPaused {\n        // anti reentrance\n        require(xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER, \"Already in execution\");\n\n        // check message status\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL1MessageExecuted[_xDomainCalldataHash], \"Message successfully executed\");\n        require(l1MessageFailedTimes[_xDomainCalldataHash] > 0, \"Message not relayed before\");\n\n        require(\n            verifyMessageInclusionStatus(_proof.blockHash, _xDomainCalldataHash, _proof.stateRootProof),\n            \"Message not included\"\n        );\n\n        _executeMessage(_from, _to, _value, _message, _xDomainCalldataHash);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// @notice Update max failed execution times.\n    /// @dev This function can only called by contract owner.\n    /// @param _maxFailedExecutionTimes The new max failed execution times.\n    function updateMaxFailedExecutionTimes(uint256 _maxFailedExecutionTimes) external onlyOwner {\n        maxFailedExecutionTimes = _maxFailedExecutionTimes;\n\n        emit UpdateMaxFailedExecutionTimes(_maxFailedExecutionTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to send cross domain message.\n    /// @param _to The address of account who receive the message.\n    /// @param _value The amount of ether passed when call target contract.\n    /// @param _message The content of the message.\n    /// @param _gasLimit Optional gas limit to complete the message relay on corresponding chain.\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(msg.value == _value, \"msg.value mismatch\");\n\n        uint256 _nonce = L2MessageQueue(messageQueue).nextMessageIndex();\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(msg.sender, _to, _value, _nonce, _message));\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(!isL2MessageSent[_xDomainCalldataHash], \"Duplicated message\");\n        isL2MessageSent[_xDomainCalldataHash] = true;\n\n        L2MessageQueue(messageQueue).appendMessage(_xDomainCalldataHash);\n\n        emit SentMessage(msg.sender, _to, _value, _nonce, _gasLimit, _message);\n    }\n\n    /// @dev Internal function to execute a L1 => L2 message.\n    /// @param _from The address of the sender of the message.\n    /// @param _to The address of the recipient of the message.\n    /// @param _value The msg.value passed to the message call.\n    /// @param _message The content of the message.\n    /// @param _xDomainCalldataHash The hash of the message.\n    function _executeMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        bytes32 _xDomainCalldataHash\n    ) internal {\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, \"Forbid to call message queue\");\n        require(_to != address(this), \"Forbid to call self\");\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL1MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            unchecked {\n                uint256 _failedTimes = l1MessageFailedTimes[_xDomainCalldataHash] + 1;\n                require(_failedTimes <= maxFailedExecutionTimes, \"Exceed maximum failure times\");\n                l1MessageFailedTimes[_xDomainCalldataHash] = _failedTimes;\n            }\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n}"
    }
  ]
}