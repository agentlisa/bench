{
  "Title": "[M-02] Use of `payable.transfer()` Might Render ETH Impossible to Withdraw",
  "Content": "\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L105>\n\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L85-L86>\n\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/FixedPrice.sol#L109>\n\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEdition.sol#L92>\n\n### Impact\n\nThe protocol uses Solidity’s `transfer()` when transferring ETH to the recipients. This has some notable shortcomings when the recipient is a smart contract, which can render ETH impossible to transfer. Specifically, the transfer will inevitably fail when the smart contract:\n\n*   does not implement a payable fallback function, or\n*   implements a payable fallback function which would incur more than 2300 gas units, or\n*   implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.\n\n### Proof of Concept\n\n[File: LPDA.sol](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol)\n\n    85:            ISaleFactory(factory).feeReceiver().transfer(fee);\n    86:            temp.saleReceiver.transfer(totalSale - fee);\n\n    105:        payable(msg.sender).transfer(owed);\n\n[File: FixedPrice.sol#L109](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/FixedPrice.sol#L109)\n\n    109:        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n\n[File: OpenEdition.sol#L92](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/OpenEdition.sol#L92)\n\n    92:        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n\nIssues pertaining to the use of `transfer()` in the code blocks above may be referenced further via:\n\n*   [CONSENSYS Diligence's article](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)\n*   [OpenZeppelin news & events](https://blog.openzeppelin.com/reentrancy-after-istanbul/)\n\n### Recommended Mitigation Steps\n\nUsing `call` with its returned boolean checked in combination with re-entrancy guard is highly recommended after December 2019.\n\nFor instance, [line 105](https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L105) in `LPDA.sol` may be refactored as follows:\n\n    - payable(msg.sender).transfer(owed);\n    + (bool success, ) = payable(msg.sender).call{ value: owed }('');\n    + require(success, \" Transfer of ETH Failed\");\n\nAlternatively, `Address.sendValue()` available in [OpenZeppelin Contract’s Address library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L44-L65) can be used to transfer the Ether without being limited to 2300 gas units.\n\nAnd again, in either of the above measures adopted, the risks of re-entrancy stemming from the use of this function can be mitigated by tightly following the “Check-effects-interactions” pattern and/or using [OpenZeppelin Contract’s ReentrancyGuard contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol#L43-L54).\n\n**[mehtaculous (Escher) confirmed and commented](https://github.com/code-423n4/2022-12-escher-findings/issues/99#issuecomment-1363200529):**\n > Agree with severity. Solution would be to attempt to transfer ETH, and if that is unsuccessful, transfer WETH instead.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-escher-contest",
  "Code": [
    {
      "filename": "src/minters/LPDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}"
    },
    {
      "filename": "src/minters/LPDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}"
    },
    {
      "filename": "src/minters/FixedPrice.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}"
    },
    {
      "filename": "src/minters/OpenEdition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract OpenEdition is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint72 price;\n        uint24 currentId;\n        address edition;\n        // slot 2\n        uint96 startTime;\n        address payable saleReceiver;\n        // slot 3\n        uint96 endTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(\n            type(uint72).max,\n            type(uint24).max,\n            address(0),\n            type(uint96).max,\n            payable(0),\n            type(uint96).max\n        );\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint24 amount = uint24(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        require(block.timestamp < temp.endTime, \"TOO LATE\");\n        require(amount * sale.price == msg.value, \"WRONG PRICE\");\n        uint24 newId = amount + temp.currentId;\n\n        for (uint24 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice finish an open edition and payout the artist\n    function finalize() public {\n        Sale memory temp = sale;\n        require(block.timestamp >= temp.endTime, \"TOO SOON\");\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        _end(temp);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice how much time is left in the sale\n    function timeLeft() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? sale.endTime - block.timestamp : 0;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    function available() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? type(uint24).max : 0;\n    }\n\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        selfdestruct(_sale.saleReceiver);\n    }\n}"
    },
    {
      "filename": "src/minters/FixedPrice.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}"
    },
    {
      "filename": "src/minters/OpenEdition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract OpenEdition is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint72 price;\n        uint24 currentId;\n        address edition;\n        // slot 2\n        uint96 startTime;\n        address payable saleReceiver;\n        // slot 3\n        uint96 endTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(\n            type(uint72).max,\n            type(uint24).max,\n            address(0),\n            type(uint96).max,\n            payable(0),\n            type(uint96).max\n        );\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint24 amount = uint24(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        require(block.timestamp < temp.endTime, \"TOO LATE\");\n        require(amount * sale.price == msg.value, \"WRONG PRICE\");\n        uint24 newId = amount + temp.currentId;\n\n        for (uint24 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice finish an open edition and payout the artist\n    function finalize() public {\n        Sale memory temp = sale;\n        require(block.timestamp >= temp.endTime, \"TOO SOON\");\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        _end(temp);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice how much time is left in the sale\n    function timeLeft() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? sale.endTime - block.timestamp : 0;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    function available() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? type(uint24).max : 0;\n    }\n\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        selfdestruct(_sale.saleReceiver);\n    }\n}"
    },
    {
      "filename": "src/minters/LPDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}"
    },
    {
      "filename": "contracts/utils/Address.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-c"
    }
  ]
}