{
  "Title": "[M-03] Malicious relayer could exploit sponsor vaults",
  "Content": "_Submitted by 0x52, also found by csanuragjain_\n\n[SponsorVault.sol#L234-L263](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/SponsorVault.sol#L234-L263)<br>\n\nSponsor vaults drained.\n\n### Proof of Concept\n\n`reimburseRelayerFees` uses SponsorVault funds to repay users the fees they pay to relayers. A malicious relayer could create a large number of transactions with the max reimbursed relay fee specified in SponsorVault between chains for which they relay all of them. They would receive back the relay fee from the SponsorVault and they would also get the relay fee they paid themselves.\n\n### Recommended Mitigation Steps\n\nI don't see any way to mitigate this without substantial changes to the functionality of SponsorVault. Teams deploying SponsorVaults should be informed of potential misuse and set reimburse limits accordingly.\n\n**[LayneHaber (Connext) disputed and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/234#issuecomment-1165737269):**\n > I'm not sure I agree with this as an issue -- the relayers are whitelisted (to prevent generalized front-running, and limiting relayers to reliable relay networks).\n> \n> Usually any dusting systems like the `reimburseRelayerFees` do not have sybil resistance (unless you connect your socials or something similar), and this is something we will have to advertise to the people who create and fund the vault.\n> \n> NOTE: inspiration for this feature was taken from existing nomad dusting, which has the same potential shortcomings, see [here](https://github.com/nomad-xyz/monorepo/blob/efc3f4ccf31dbcb4aa50cad197d469d511fafe86/packages/contracts-bridge/contracts/BridgeRouter.sol#L312-L326). Generally, chains have been willing to fund these vaults even with these drawbacks. That being said, balance checks could be added to add some slight guardrails!\n\n**[LayneHaber (Connext) resolved](https://github.com/code-423n4/2022-06-connext-findings/issues/234#issuecomment-1167489342):**\n > [connext/nxtp@be9671c](https://github.com/connext/nxtp/pull/1450/commits/be9671c327166047e611c771c8c81c71fe19ccaf)\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/234#issuecomment-1202008683):**\n > I actually agree with the warden here. This type of attack would not be recognisable and could be disguised as general protocol activity. However, users' funds are not at direct risk, but sponsors' funds who intentionally give up these funds would be at risk of leaking value. Downgrading to `medium` risk.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/helpers/SponsorVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20, Address} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\nimport {ITokenExchange} from \"../interfaces/ITokenExchange.sol\";\nimport {IGasTokenOracle} from \"../interfaces/IGasTokenOracle.sol\";\n\n/**\n * @title SponsorVault\n * @author Connext Labs\n * @notice Contains logic for sponsoring liquidity and relayer fees\n */\ncontract SponsorVault is ISponsorVault, Ownable {\n  // ============ Libraries ============\n  using SafeERC20 for IERC20;\n\n  // ============ Struct ============\n  struct Rate {\n    uint256 num;\n    uint256 den;\n  }\n\n  // ============ Private storage ============\n\n  // ============ Public storage ============\n\n  /**\n   * @notice The address of connext\n   */\n  address public connext;\n\n  /**\n   * @notice The origin domain to this domain native token rates\n   * @dev Used when no oracle is available\n   */\n  mapping(uint32 => Rate) public rates;\n\n  /**\n   * @notice The maximum amount this domain native token to be sponsored for relayer fee\n   */\n  uint256 public relayerFeeCap;\n\n  /**\n   * @notice The origin domain to this domain native token oracle\n   * @dev Used to calculate sponsored relayer fee\n   */\n  IGasTokenOracle public gasTokenOracle;\n\n  /**\n   * @notice The this domain native token to token exchange\n   * @dev Used to exchange this domain native token to the token used to pay liquidity fees\n   */\n  mapping(address => ITokenExchange) public tokenExchanges;\n\n  // ============ Errors ============\n\n  error SponsorVault__setConnext_invalidConnext();\n  error SponsorVault__setRate_invalidOriginDomain();\n  error SponsorVault__setGasTokenOracle_invalidOriginDomain();\n  error SponsorVault__setTokenExchange_invalidAdopted();\n  error SponsorVault__onlyConnext();\n  error SponsorVault__withdraw_invalidAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new connext is set\n   */\n  event ConnextUpdated(address oldConnext, address newConnext, address caller);\n\n  /**\n   * @notice Emitted when a new rate is set\n   */\n  event RateUpdated(uint32 originDomain, Rate oldRate, Rate newRate, address caller);\n\n  /**\n   * @notice Emitted when a new relayerFeeCap is set\n   */\n  event RelayerFeeCapUpdated(uint256 oldRelayerFeeCap, uint256 newRelayerFeeCap, address caller);\n\n  /**\n   * @notice Emitted when a new native token oracle is set\n   */\n  event GasTokenOracleUpdated(address oldOracle, address newOracle, address caller);\n\n  /**\n   * @notice Emitted when a new token exchange is set\n   */\n  event TokenExchangeUpdated(address token, address oldTokenExchange, address newTokenExchange, address caller);\n\n  /**\n   * @notice Emitted when a liquidity fee is reimbursed\n   */\n  event ReimburseLiquidityFees(address token, uint256 amount, address receiver);\n\n  /**\n   * @notice Emitted when a relayer fee is reimbursed\n   */\n  event ReimburseRelayerFees(uint256 amount, address receiver);\n\n  /**\n   * @notice Emitted when liquidity is added\n   */\n  event Deposit(address token, uint256 amount, address caller);\n\n  /**\n   * @notice Emitted when liquidity is removed\n   */\n  event Withdraw(address token, address receiver, uint256 amount, address caller);\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Restricts the caller to connext\n   */\n  modifier onlyConnext() {\n    if (msg.sender != connext) revert SponsorVault__onlyConnext();\n    _;\n  }\n\n  // ============ Constructor ============\n\n  constructor(address _connext) Ownable() {\n    _setConnext(_connext);\n  }\n\n  // ============ Owner Functions ============\n\n  /**\n   * @notice Sets the Connext.\n   * @dev Connext and sponsor vault store references to each other\n   * @param _connext The address of the Connext implementation\n   */\n  function setConnext(address _connext) external onlyOwner {\n    _setConnext(_connext);\n  }\n\n  /**\n   * @notice Sets default origin domain native token to this domain native token rate.\n   * @param _originDomain The origin domain\n   * @param _rate The default rate\n   */\n  function setRate(uint32 _originDomain, Rate calldata _rate) external onlyOwner {\n    if (_originDomain == 0) revert SponsorVault__setRate_invalidOriginDomain();\n\n    emit RateUpdated(_originDomain, rates[_originDomain], _rate, msg.sender);\n\n    rates[_originDomain] = _rate;\n  }\n\n  /**\n   * @notice Sets the maximum sponsored relayer fee amount.\n   * @param _relayerFeeCap The new relayerFeeCap\n   */\n  function setRelayerFeeCap(uint256 _relayerFeeCap) external onlyOwner {\n    emit RelayerFeeCapUpdated(relayerFeeCap, _relayerFeeCap, msg.sender);\n    relayerFeeCap = _relayerFeeCap;\n  }\n\n  /**\n   * @notice Sets of an oracle that provides origin domain native token to this domain native token rates.\n   * @param _gasTokenOracle The oracle address\n   */\n  function setGasTokenOracle(address _gasTokenOracle) external onlyOwner {\n    emit GasTokenOracleUpdated(address(gasTokenOracle), _gasTokenOracle, msg.sender);\n    gasTokenOracle = IGasTokenOracle(_gasTokenOracle);\n  }\n\n  /**\n   * @notice Sets the address of an exchange used for swapping this domain native token for a given token.\n   * @param _token The address of the token\n   * @param _tokenExchange The oracle of the exchange\n   */\n  function setTokenExchange(address _token, address payable _tokenExchange) external onlyOwner {\n    if (_token == address(0)) revert SponsorVault__setTokenExchange_invalidAdopted();\n\n    emit TokenExchangeUpdated(_token, address(tokenExchanges[_token]), _tokenExchange, msg.sender);\n    tokenExchanges[_token] = ITokenExchange(_tokenExchange);\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Performs liquidity fee reimbursement.\n   * @dev Uses the token exchange or liquidity deposited in this contract.\n   *      The `_receiver` address is only used for emitting in the event.\n   * @param _token The address of the token\n   * @param _liquidityFee The liquidity fee amount\n   * @param _receiver The address of the receiver\n   * @return Sponsored liquidity fee amount\n   */\n  function reimburseLiquidityFees(\n    address _token,\n    uint256 _liquidityFee,\n    address _receiver\n  ) external override onlyConnext returns (uint256) {\n    uint256 sponsoredFee;\n\n    if (address(tokenExchanges[_token]) != address(0)) {\n      uint256 currentBalance = address(this).balance;\n      ITokenExchange tokenExchange = tokenExchanges[_token];\n\n      uint256 amountIn = tokenExchange.getInGivenExpectedOut(_token, _liquidityFee);\n      amountIn = currentBalance >= amountIn ? amountIn : currentBalance;\n\n      // sponsored fee may end being less than _liquidityFee due to slippage\n      sponsoredFee = tokenExchange.swapExactIn{value: amountIn}(_token, msg.sender);\n    } else {\n      uint256 balance = IERC20(_token).balanceOf(address(this));\n      sponsoredFee = balance < _liquidityFee ? balance : _liquidityFee;\n\n      // some ERC20 do not allow to transfer 0 amount\n      if (sponsoredFee > 0) {\n        IERC20(_token).safeTransfer(msg.sender, sponsoredFee);\n      }\n    }\n\n    emit ReimburseLiquidityFees(_token, sponsoredFee, _receiver);\n\n    return sponsoredFee;\n  }\n\n  /**\n   * @notice Performs relayer fee reimbursement sending the corresponding amount of this domain native token to `_to`.\n   * @dev Uses the configured oracle or default rate otherwise.\n   * @param _originDomain The origin domain id\n   * @param _to The fee recipient\n   * @param _originRelayerFee The relayer fee amount in origin domain native token\n   */\n  function reimburseRelayerFees(\n    uint32 _originDomain,\n    address payable _to,\n    uint256 _originRelayerFee\n  ) external override onlyConnext {\n    uint256 sponsoredFee;\n    uint256 num;\n    uint256 den;\n\n    if (address(gasTokenOracle) != address(0)) {\n      (num, den) = gasTokenOracle.getRate(_originDomain);\n\n      sponsoredFee = (_originRelayerFee * num) / den;\n    } else {\n      num = rates[_originDomain].num;\n      den = rates[_originDomain].den;\n    }\n\n    if (den != 0) {\n      sponsoredFee = (_originRelayerFee * num) / den;\n\n      // calculated or max\n      sponsoredFee = sponsoredFee > relayerFeeCap ? relayerFeeCap : sponsoredFee;\n      // calculated or leftover\n      sponsoredFee = sponsoredFee > address(this).balance ? address(this).balance : sponsoredFee;\n\n      Address.sendValue(_to, sponsoredFee);\n    }\n    emit ReimburseRelayerFees(sponsoredFee, _to);\n  }\n\n  /**\n   * @notice Adds liquidity to the sponsor vault, native token or ERC20.\n   * @dev Anyone can add liquidity.\n   * @param _token The ERC20 token address or address zero for native token\n   * @param _amount The amount of ERC20 to deposit or zero for native token since the amount is sent in msg.value\n   */\n  function deposit(address _token, uint256 _amount) external payable {\n    if (_token != address(0)) {\n      IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    emit Deposit(_token, _token != address(0) ? _amount : msg.value, msg.sender);\n  }\n\n  /**\n   * @notice Removes liquidity from the sponsor vault, native token or ERC20.\n   * @dev Only the owner can remove liquidity.\n   * @param _token The ERC20 token address or address zero for native token\n   * @param _receiver The receiver of the tokens\n   * @param _amount The amount to remove\n   */\n  function withdraw(\n    address _token,\n    address _receiver,\n    uint256 _amount\n  ) external onlyOwner {\n    if (_token == address(0)) {\n      if (address(this).balance < _amount) revert SponsorVault__withdraw_invalidAmount();\n      Address.sendValue(payable(_receiver), _amount);\n    } else {\n      if (IERC20(_token).balanceOf(address(this)) < _amount) revert SponsorVault__withdraw_invalidAmount();\n      IERC20(_token).safeTransfer(_receiver, _amount);\n    }\n\n    emit Withdraw(_token, _receiver, _amount, msg.sender);\n  }\n\n  // ============ Internal functions ============\n\n  function _setConnext(address _connext) internal {\n    if (_connext == address(0)) revert SponsorVault__setConnext_invalidConnext();\n\n    emit ConnextUpdated(connext, _connext, msg.sender);\n\n    connext = _connext;\n  }\n}"
    },
    {
      "filename": "packages/contracts-bridge/contracts/BridgeRouter.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.7.6;\n\n// ============ Internal Imports ============\nimport {BridgeMessage} from \"./BridgeMessage.sol\";\nimport {IBridgeToken} from \"./interfaces/IBridgeToken.sol\";\nimport {ITokenRegistry} from \"./interfaces/ITokenRegistry.sol\";\n// ============ External Imports ============\nimport {XAppConnectionClient} from \"@nomad-xyz/contracts-router/contracts/XAppConnectionClient.sol\";\nimport {Router} from \"@nomad-xyz/contracts-router/contracts/Router.sol\";\nimport {Home} from \"@nomad-xyz/contracts-core/contracts/Home.sol\";\nimport {Version0} from \"@nomad-xyz/contracts-core/contracts/Version0.sol\";\nimport {TypedMemView} from \"@summa-tx/memview-sol/contracts/TypedMemView.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title BridgeRouter\n */\ncontract BridgeRouter is Version0, Router {\n    // ============ Libraries ============\n\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n    using BridgeMessage for bytes29;\n    using SafeERC20 for IERC20;\n\n    // ============ Constants ============\n\n    // the amount transferred to bridgoors without gas funds\n    uint256 public constant DUST_AMOUNT = 0.06 ether;\n\n    // ============ Public Storage ============\n\n    // contract that manages registry representation tokens\n    ITokenRegistry public tokenRegistry;\n    // token transfer prefill ID => LP that pre-filled message to provide fast liquidity\n    mapping(bytes32 => address) public liquidityProvider;\n\n    // ============ Upgrade Gap ============\n\n    // gap for upgrade safety\n    uint256[49] private __GAP;\n\n    // ======== Events =========\n\n    /**\n     * @notice emitted when tokens are sent from this domain to another domain\n     * @param token the address of the token contract\n     * @param from the address sending tokens\n     * @param toDomain the domain of the chain the tokens are being sent to\n     * @param toId the bytes32 address of the recipient of the tokens\n     * @param amount the amount of tokens sent\n     * @param fastLiquidityEnabled True if fast liquidity is enabled, False otherwise\n     */\n    event Send(\n        address indexed token,\n        address indexed from,\n        uint32 indexed toDomain,\n        bytes32 toId,\n        uint256 amount,\n        bool fastLiquidityEnabled\n    );\n\n    /**\n     * @notice emitted when tokens are dispensed to an account on this domain\n     * emitted both when fast liquidity is provided, and when the transfer ultimately settles\n     * @param originAndNonce Domain where the transfer originated and the unique identifier\n     * for the message from origin to destination, combined in a single field ((origin << 32) & nonce)\n     * @param token The address of the local token contract being received\n     * @param recipient The address receiving the tokens; the original recipient of the transfer\n     * @param liquidityProvider The account providing liquidity\n     * @param amount The amount of tokens being received\n     */\n    event Receive(\n        uint64 indexed originAndNonce,\n        address indexed token,\n        address indexed recipient,\n        address liquidityProvider,\n        uint256 amount\n    );\n\n    // ======== Receive =======\n    receive() external payable {}\n\n    // ======== Initializer ========\n\n    function initialize(address _tokenRegistry, address _xAppConnectionManager)\n        public\n        initializer\n    {\n        tokenRegistry = ITokenRegistry(_tokenRegistry);\n        __XAppConnectionClient_initialize(_xAppConnectionManager);\n    }\n\n    // ======== External: Handle =========\n\n    /**\n     * @notice Handles an incoming message\n     * @param _origin The origin domain\n     * @param _nonce The unique identifier for the message from origin to destination\n     * @param _sender The sender address\n     * @param _message The message\n     */\n    function handle(\n        uint32 _origin,\n        uint32 _nonce,\n        bytes32 _sender,\n        bytes memory _message\n    ) external override onlyReplica onlyRemoteRouter(_origin, _sender) {\n        // parse tokenId and action from message\n        bytes29 _msg = _message.ref(0).mustBeMessage();\n        bytes29 _tokenId = _msg.tokenId();\n        bytes29 _action = _msg.action();\n        // handle message based on the intended action\n        if (_action.isTransfer()) {\n            _handleTransfer(_origin, _nonce, _tokenId, _action, false);\n        } else if (_action.isFastTransfer()) {\n            _handleTransfer(_origin, _nonce, _tokenId, _action, true);\n        } else {\n            require(false, \"!valid action\");\n        }\n    }\n\n    // ======== External: Send Token =========\n\n    /**\n     * @notice Send tokens to a recipient on a remote chain\n     * @param _token The token address\n     * @param _amount The token amount\n     * @param _destination The destination domain\n     * @param _recipient The recipient address\n     */\n    function send(\n        address _token,\n        uint256 _amount,\n        uint32 _destination,\n        bytes32 _recipient,\n        bool /*_enableFast - deprecated field, left argument for backwards compatibility */\n    ) external {\n        require(_amount > 0, \"!amnt\");\n        require(_recipient != bytes32(0), \"!recip\");\n        // get remote BridgeRouter address; revert if not found\n        bytes32 _remote = _mustHaveRemote(_destination);\n        // Setup vars used in both if branches\n        IBridgeToken _t = IBridgeToken(_token);\n        bytes32 _detailsHash;\n        // remove tokens from circulation on this chain\n        if (tokenRegistry.isLocalOrigin(_token)) {\n            // if the token originates on this chain,\n            // hold the tokens in escrow in the Router\n            IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n            // query token contract for details and calculate detailsHash\n            _detailsHash = BridgeMessage.getDetailsHash(\n                _t.name(),\n                _t.symbol(),\n                _t.decimals()\n            );\n        } else {\n            // if the token originates on a remote chain,\n            // burn the representation tokens on this chain\n            _t.burn(msg.sender, _amount);\n            _detailsHash = _t.detailsHash();\n        }\n        // format Transfer Tokens action\n        bytes29 _action = BridgeMessage.formatTransfer(\n            _recipient,\n            _amount,\n            _detailsHash\n        );\n        // get the tokenID\n        (uint32 _domain, bytes32 _id) = tokenRegistry.getTokenId(_token);\n        bytes29 _tokenId = BridgeMessage.formatTokenId(_domain, _id);\n        // send message to remote chain via Nomad\n        Home(xAppConnectionManager.home()).dispatch(\n            _destination,\n            _remote,\n            BridgeMessage.formatMessage(_tokenId, _action)\n        );\n        // emit Send event to record token sender\n        emit Send(\n            _token,\n            msg.sender,\n            _destination,\n            _recipient,\n            _amount,\n            false\n        );\n    }\n\n    // ======== External: Custom Tokens =========\n\n    /**\n     * @notice Enroll a custom token. This allows projects to work with\n     * governance to specify a custom representation.\n     * @param _domain the domain of the canonical Token to enroll\n     * @param _id the bytes32 ID of the canonical of the Token to enroll\n     * @param _custom the address of the custom implementation to use.\n     */\n    function enrollCustom(\n        uint32 _domain,\n        bytes32 _id,\n        address _custom\n    ) external onlyOwner {\n        // Sanity check. Ensures that human error doesn't cause an\n        // unpermissioned contract to be enrolled.\n        IBridgeToken(_custom).mint(address(this), 1);\n        IBridgeToken(_custom).burn(address(this), 1);\n        tokenRegistry.enrollCustom(_domain, _id, _custom);\n    }\n\n    /**\n     * @notice Migrate all tokens in a previous representation to the latest\n     * custom representation. This works by looking up local mappings and then\n     * burning old tokens and minting new tokens.\n     * @dev This is explicitly opt-in to allow dapps to decide when and how to\n     * upgrade to the new representation.\n     * @param _oldRepr The address of the old token to migrate\n     */\n    function migrate(address _oldRepr) external {\n        address _currentRepr = tokenRegistry.oldReprToCurrentRepr(_oldRepr);\n        require(_currentRepr != _oldRepr, \"!different\");\n        // burn the total balance of old tokens & mint the new ones\n        IBridgeToken _old = IBridgeToken(_oldRepr);\n        uint256 _bal = _old.balanceOf(msg.sender);\n        _old.burn(msg.sender, _bal);\n        IBridgeToken(_currentRepr).mint(msg.sender, _bal);\n    }\n\n    // ============ Internal: Handle ============\n\n    /**\n     * @notice Handles an incoming Transfer message.\n     *\n     * If the token is of local origin, the amount is sent from escrow.\n     * Otherwise, a representation token is minted.\n     *\n     * @param _origin The domain of the chain from which the transfer originated\n     * @param _nonce The unique identifier for the message from origin to destination\n     * @param _tokenId The token ID\n     * @param _action The action\n     * @param _fastEnabled True if fast liquidity was enabled, False otherwise\n     */\n    function _handleTransfer(\n        uint32 _origin,\n        uint32 _nonce,\n        bytes29 _tokenId,\n        bytes29 _action,\n        bool _fastEnabled\n    ) internal {\n        // get the token contract for the given tokenId on this chain;\n        // (if the token is of remote origin and there is\n        // no existing representation token contract, the TokenRegistry will\n        // deploy a new one)\n        address _token = tokenRegistry.ensureLocalToken(\n            _tokenId.domain(),\n            _tokenId.id()\n        );\n        // load the original recipient of the tokens\n        address _recipient = _action.evmRecipient();\n        if (_fastEnabled) {\n            // If an LP has prefilled this token transfer,\n            // send the tokens to the LP instead of the recipient\n            bytes32 _id = BridgeMessage.getPreFillId(\n                _origin,\n                _nonce,\n                _tokenId,\n                _action\n            );\n            address _lp = liquidityProvider[_id];\n            if (_lp != address(0)) {\n                _recipient = _lp;\n                delete liquidityProvider[_id];\n            }\n        }\n        // load amount once\n        uint256 _amount = _action.amnt();\n        // send the tokens into circulation on this chain\n        if (tokenRegistry.isLocalOrigin(_token)) {\n            // if the token is of local origin, the tokens have been held in\n            // escrow in this contract\n            // while they have been circulating on remote chains;\n            // transfer the tokens to the recipient\n            IERC20(_token).safeTransfer(_recipient, _amount);\n        } else {\n            // if the token is of remote origin, mint the tokens to the\n            // recipient on this chain\n            IBridgeToken(_token).mint(_recipient, _amount);\n            // Tell the token what its detailsHash is\n            IBridgeToken(_token).setDetailsHash(_action.detailsHash());\n        }\n        // dust the recipient if appropriate\n        _dust(_recipient);\n        // emit Receive event\n        emit Receive(\n            _originAndNonce(_origin, _nonce),\n            _token,\n            _recipient,\n            address(0),\n            _amount\n        );\n    }\n\n    // ============ Internal: Dust with Gas ============\n\n    /**\n     * @notice Dust the recipient. This feature allows chain operators to use\n     * the Bridge as a faucet if so desired. Any gas asset held by the\n     * bridge will be slowly sent to users who need initial gas bootstrapping\n     * @dev Does not dust if insufficient funds, or if user has funds already\n     */\n    function _dust(address _recipient) internal {\n        if (\n            _recipient.balance < DUST_AMOUNT &&\n            address(this).balance >= DUST_AMOUNT\n        ) {\n            // `send` gives execution 2300 gas and returns a `success` boolean.\n            // however, we do not care if the call fails. A failed call\n            // indicates a smart contract attempting to execute logic, which we\n            // specifically do not want.\n            // While we could check EXTCODESIZE, it seems sufficient to rely on\n            // the 2300 gas stipend to ensure that no state change logic can\n            // be executed.\n            payable(_recipient).send(DUST_AMOUNT);\n        }\n    }\n\n    // ============ Internal: Utils ============\n\n    /**\n     * @notice Internal utility function that combines\n     * `_origin` and `_nonce`.\n     * @dev Both origin and nonce should be less than 2^32 - 1\n     * @param _origin Domain of chain where the transfer originated\n     * @param _nonce The unique identifier for the message from origin to destination\n     * @return Returns (`_origin` << 32) & `_nonce`\n     */\n    function _originAndNonce(uint32 _origin, uint32 _nonce)\n        internal\n        pure\n        returns (uint64)\n    {\n        return (uint64(_origin) << 32) | _nonce;\n    }\n\n    /**\n    * @dev should be impossible to renounce ownership;\n     * we override OpenZeppelin OwnableUpgradeable's\n     * implementation of renounceOwnership to make it a no-op\n     */\n    function renounceOwnership() public override onlyOwner {\n        // do nothing\n    }\n}"
    }
  ]
}