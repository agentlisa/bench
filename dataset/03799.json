{
  "Title": "[H02] Markets are not being properly removed from the markets list",
  "Content": "In the [`HoldefiSettings` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol) there are two data structures to track markets: [`marketsList`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L64) which is an array of addresses, and [`marketAssets`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L63), which is a mapping that describes the properties of each market. Additionally, there are two functions to manipulate these markets: [the `addMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L176) which adds new markets, and [the `removeMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L205) which removes an already existent market.\n\n\nThe problem resides in that [the `removeMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L205) does not remove a market from both mentioned data structures, as it only sets a given market as not active in [the `Market` struct](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L42), but does not remove it from the [`marketsList` array](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L64). This means that, when the [`getMarketsList`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L115) function is called, it will list already removed markets, showing them as valid and active markets.\n\n\nThis could lead into [an undesired manipulation of collaterals of a borrower in a specific market](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L415-L424), that could [generate market debts for inactive collaterals in that market](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L422), and could trigger other operations such as [updating the promotion reserve and therefore update a market’s supply index](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L420) for a specific collateral in an inactive market. Also, this behavior of having a removed market that is still active could be confusing for the end-users.\n\n\nConsider renaming the `removeMarket` function to `deactivateMarket`, to make its behavior clear. On all the functions that query `marketsList` consider checking if the market is inactive. If the function supports or requires to take into account inactive markets, consider clearly documenting this.\n\n\nAlternatively, consider using different state variables to differentiate from active and inactive markets, instead of leaving them in a state that is not clearly defined.\n\n\n***Update:** Not fixed. Holdefi’s statement for this issue:*\n\n\n\n> We calculate the borrow-value of each account in “getAccountTotalBorrowValue” function. This function is using “marketsList” for calculating the borrow-value. If we remove a market from “marketList”, the borrow-value of that token for the users that borrowed it, will not be calculated.  \n> \n> We did not remove the market from “marketList” with awareness.  \n> \n> Actually removing market or collateral in Holdefi stops users from depositing new tokens to contract but withdrawing and other functionalities are not changed because we don’t want our users losing their tokens.  \n> \n> Also updating the supply index and promotion reserve doesn’t have any bad effect on the platform and these functions are not “sensitive operations“. They just update index or reserve till current time.  \n> \n> You suggested that we should check whether a market is active or not in the “clearDebts”. But if we do that, the platform will have problems and we will not consider the users that borrowed that market before.\n> \n> \n\n\n*We have updated our suggestions to make them clearer.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/HoldefiSettings.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\n\r\ninterface HoldefiInterface {\r\n\r\n\tfunction updateSupplyIndex(address market) external;\r\n\r\n\tfunction updateBorrowIndex(address market) external;\r\n\r\n\tfunction updatePromotionReserve(address market) external;\r\n}\r\n\r\n// All these settings is callable by only owner\r\ncontract HoldefiSettings is Ownable {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint constant public ratesDecimal = 10 ** 4;\r\n\r\n\tuint constant public secondsPerTenDays = 864000;\r\n\r\n\tuint constant public maxBorrowRate = 4000;\t\t\t\t  //40%\r\n\r\n\tuint constant public borrowRateMaxIncrease = 500;\t\t  //5%\r\n\r\n\tuint constant public minSuppliersShareRate = 5000;\t\t  //50%\r\n\r\n\tuint constant public suppliersShareRateMaxDecrease = 500; //5%\r\n\r\n\tuint constant public maxValueToLoanRate = 20000; \t\t  //200%\r\n\r\n\tuint constant public valueToLoanRateMaxIncrease = 500;\t  //5%\r\n\r\n\tuint constant public maxPenaltyRate = 13000; \t\t\t  //130%\r\n\r\n\tuint constant public penaltyRateMaxIncrease = 500; \t\t  //5%\r\n\r\n\t// Markets Features \r\n\tstruct Market {\r\n\t\tbool isActive;\r\n\r\n\t\tuint borrowRate;\r\n\t\tuint borrowRateUpdateTime;\r\n\r\n\t\tuint suppliersShareRate;\r\n\t\tuint suppliersShareRateUpdateTime;\t\r\n\t}\r\n\r\n\t// Collaterals Features\r\n\tstruct Collateral {\r\n\t\tbool isActive;\r\n\t\tuint valueToLoanRate;   // Collateral liquidation threshold\r\n\t\tuint VTLUpdateTime;\r\n\t\tuint penaltyRate; \t\t// Portion of collateral being liquidated during liquidation\r\n\t\tuint penaltyUpdateTime;\r\n\t\tuint bonusRate;\t\t    // Bonus for buyers who buy liquidated collaterals\r\n\t}\r\n\r\n\t// Asset address => Market features \r\n\tmapping (address => Market) public marketAssets;\r\n\taddress[] public marketsList;\r\n\r\n\t// Asset address => Collateral features\r\n\tmapping (address => Collateral) public collateralAssets;\r\n\r\n\tHoldefiInterface public holdefiContract;\r\n\r\n\tevent BorrowRateChanged(address market, uint newRate);\r\n\r\n\tevent SuppliersShareRateChanged(address market, uint newRate);\r\n\r\n\tevent MarketAdded(address market);\r\n\r\n\tevent MarketRemoved(address market);\r\n\r\n\tevent CollateralAdded(address collateral, uint valueToLoanRate, uint penaltyRate, uint bonusRate);\r\n\r\n\tevent CollateralRemoved(address collateral);\r\n\r\n\tevent ValueToLoanRateChanged(address collateral, uint newRate);\r\n\r\n\tevent PenaltyRateChanged(address collateral, uint newRate);\r\n\r\n\tevent BonusRateChanged(address collateral, uint newRate);\r\n\t\r\n\tconstructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\r\n\t}\r\n\r\n\t// Disposable function to Get in touch with Holdefi contract\r\n\tfunction setHoldefiContract(HoldefiInterface holdefiContractAddress) external onlyOwner {\r\n\t\trequire (address(holdefiContract) == address(0),'Should be set once');\r\n\t\tholdefiContract = holdefiContractAddress;\r\n\t}\r\n\r\n\t// Returns supply rate and borrow rate \r\n\t// supply rate = ((total borrow * Borrow rate * suppliers share rate) / total supply\r\n\tfunction getInterests (address market, uint totalSupply, uint totalBorrow) external view returns(uint borrowRate, uint supplyRate) {\r\n\t\tborrowRate = marketAssets[market].borrowRate;\r\n\t\tuint suppliersShareRate = marketAssets[market].suppliersShareRate;\r\n\t\tif (totalSupply == 0){\r\n\t\t\tsupplyRate = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint totalInterestFromBorrow = totalBorrow.mul(borrowRate);\r\n\t\t\tuint suppliersShare = totalInterestFromBorrow.mul(suppliersShareRate);\r\n\t\t\tsuppliersShare = suppliersShare.div(ratesDecimal);\r\n\t\t\tsupplyRate = suppliersShare.div(totalSupply);\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns list of all markets\r\n\tfunction getMarketsList() external view returns (address[] memory res){\r\n\t\tres = marketsList;\r\n\t}\r\n\r\n\t// Returns true if an asset is in the market list\r\n\tfunction getMarket(address market) external view returns (bool active){\r\n\t\tactive = marketAssets[market].isActive;\r\n\t}\r\n\r\n\t// Returns the features of a collateral (Is active- VTL rate- Penalty rate- Bonus rate)\r\n\tfunction getCollateral(address collateral) external view returns (bool, uint, uint, uint){\r\n\t\treturn(\r\n\t\t\tcollateralAssets[collateral].isActive,\r\n\t\t\tcollateralAssets[collateral].valueToLoanRate,\r\n\t\t\tcollateralAssets[collateral].penaltyRate,\r\n\t\t\tcollateralAssets[collateral].bonusRate\t\t\r\n\t\t\t);\r\n\t}\r\n\t\r\n\t// Owner can set a new borrow rate\r\n\tfunction setBorrowRate (address market, uint newBorrowRate) external onlyOwner {\r\n\t\trequire (newBorrowRate <= maxBorrowRate,'Rate should be less than max');\r\n\t\tuint currentTime = block.timestamp;\r\n\r\n\t\tif (newBorrowRate > marketAssets[market].borrowRate){\r\n\t\t\tuint deltaTime = currentTime.sub(marketAssets[market].borrowRateUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = marketAssets[market].borrowRate.add(borrowRateMaxIncrease);\r\n\t\t\trequire (newBorrowRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\r\n\t\tholdefiContract.updateBorrowIndex(market);\r\n\t\tholdefiContract.updateSupplyIndex(market);\r\n\t\tholdefiContract.updatePromotionReserve(market);\r\n\t\tmarketAssets[market].borrowRate = newBorrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = currentTime;\r\n\r\n\t\temit BorrowRateChanged(market, newBorrowRate);\r\n\t}\r\n\r\n\t// Owner can set a new 'suppliers share rate' (Supplier's share of borrower's interest).\r\n\tfunction setSuppliersShareRate (address market, uint newSuppliersShareRate) external onlyOwner {\r\n\t\trequire (newSuppliersShareRate >= minSuppliersShareRate && newSuppliersShareRate <= ratesDecimal,'Rate should be in allowed range');\r\n\t\tuint currentTime = block.timestamp;\r\n\r\n\t\tif (newSuppliersShareRate < marketAssets[market].suppliersShareRate) {\r\n\t\t\tuint deltaTime = currentTime.sub(marketAssets[market].suppliersShareRateUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Decreasing rate is not allowed at this time');\r\n\t\t\tuint maxDecrease = marketAssets[market].suppliersShareRate.sub(suppliersShareRateMaxDecrease);\r\n\t\t\trequire (newSuppliersShareRate >= maxDecrease,'Rate should be decreased less than max allowed');\r\n\t\t}\r\n\r\n\t\tholdefiContract.updateSupplyIndex(market);\r\n\t\tholdefiContract.updatePromotionReserve(market);\r\n\t\tmarketAssets[market].suppliersShareRate = newSuppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = currentTime;\r\n\r\n\t\temit SuppliersShareRateChanged(market, newSuppliersShareRate);\r\n\t}\r\n\r\n\t// Owner can add a new asset as a market.\r\n\tfunction addMarket (address market, uint borrowRate, uint suppliersShareRate) external onlyOwner {\r\n\t\trequire(!marketAssets[market].isActive, \"Market exists\");\r\n\t\trequire (borrowRate <= maxBorrowRate\r\n\t\t\t&& suppliersShareRate >= minSuppliersShareRate\r\n\t\t\t&& suppliersShareRate <= ratesDecimal\r\n\t\t\t, 'Rate should be in allowed range');\r\n\t\t\r\n\t\tmarketAssets[market].isActive = true;\r\n\t\tmarketAssets[market].borrowRate = borrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = block.timestamp;\r\n\t\tmarketAssets[market].suppliersShareRate = suppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = block.timestamp;\r\n\t\r\n\t\tbool exist = false;\r\n\t\tfor (uint i=0; i<marketsList.length; i++) {\r\n\t\t\tif (marketsList[i] == market){\r\n\t\t\t\texist = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!exist) {\r\n\t\t\tmarketsList.push(market);\r\n\t\t}\r\n\r\n\t\temit MarketAdded(market);\r\n\t}\r\n\r\n\t// Owner can remove a market asset\r\n\tfunction removeMarket (address market) external onlyOwner {\t\t\r\n\t\tmarketAssets[market].isActive = false;\r\n\t\temit MarketRemoved(market);\r\n\t}\r\n\r\n\t// Owner can add a collateral asset with its VTL, penalty and bonus rate\r\n\tfunction addCollateral (address collateralAsset, uint valueToLoanRate, uint penaltyRate, uint bonusRate) external onlyOwner {\r\n\t\trequire(!collateralAssets[collateralAsset].isActive, \"Collateral exists\");\t\t\r\n\t\trequire (valueToLoanRate <= maxValueToLoanRate\r\n\t\t\t\t&& penaltyRate <= maxPenaltyRate\r\n\t\t\t\t&& penaltyRate <= valueToLoanRate\r\n\t\t\t\t&& bonusRate <= penaltyRate\r\n\t\t\t\t&& bonusRate >= ratesDecimal\r\n\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t\tcollateralAssets[collateralAsset].isActive = true;\r\n\t\tcollateralAssets[collateralAsset].valueToLoanRate = valueToLoanRate;\r\n\t\tcollateralAssets[collateralAsset].penaltyRate  = penaltyRate;\r\n\t    collateralAssets[collateralAsset].bonusRate = bonusRate;\r\n\t    collateralAssets[collateralAsset].VTLUpdateTime = block.timestamp;\r\n\t    collateralAssets[collateralAsset].penaltyUpdateTime = block.timestamp;\r\n\t    \t\r\n\t\temit CollateralAdded(collateralAsset, valueToLoanRate, penaltyRate, bonusRate);\r\n\t}\r\n\r\n\t// Owner can remove a collateral asset\r\n\tfunction removeCollateral (address collateralAsset) external onlyOwner {\r\n\t\tcollateralAssets[collateralAsset].isActive = false;\r\n\t\temit CollateralRemoved(collateralAsset);\r\n\t}\r\n\t\r\n\t// Owner can set a new VTL rate (Liquidation threshold) for each collateral asset\r\n\tfunction setValueToLoanRate (address collateralAsset, uint newValueToLoanRate) external onlyOwner {\r\n\t\trequire (newValueToLoanRate <= maxValueToLoanRate\r\n\t\t\t\t&& collateralAssets[collateralAsset].penaltyRate <= newValueToLoanRate\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t\tuint currentTime = block.timestamp;\r\n\t\tif (newValueToLoanRate > collateralAssets[collateralAsset].valueToLoanRate) {\r\n\t\t\tuint deltaTime = currentTime.sub(collateralAssets[collateralAsset].VTLUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = collateralAssets[collateralAsset].valueToLoanRate.add(valueToLoanRateMaxIncrease);\r\n\t\t\trequire (newValueToLoanRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\t    collateralAssets[collateralAsset].valueToLoanRate = newValueToLoanRate;\r\n\t    collateralAssets[collateralAsset].VTLUpdateTime = currentTime;\r\n\r\n\t    emit ValueToLoanRateChanged(collateralAsset, newValueToLoanRate);\r\n\t}\r\n\r\n\t// Owner can set penalty rate for each collateral asset\r\n\tfunction setPenaltyRate (address collateralAsset ,uint newPenaltyRate) external onlyOwner {\r\n\t\trequire (newPenaltyRate <= maxPenaltyRate\r\n\t\t\t\t&& newPenaltyRate <= collateralAssets[collateralAsset].valueToLoanRate\r\n\t\t\t\t&& collateralAssets[collateralAsset].bonusRate <= newPenaltyRate\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\r\n\t\tuint currentTime = block.timestamp;\r\n\t\tif (newPenaltyRate > collateralAssets[collateralAsset].penaltyRate){\r\n\t\t\tuint deltaTime = currentTime.sub(collateralAssets[collateralAsset].penaltyUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = collateralAssets[collateralAsset].penaltyRate.add(penaltyRateMaxIncrease);\r\n\t\t\trequire (newPenaltyRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\t    collateralAssets[collateralAsset].penaltyRate  = newPenaltyRate;\r\n\t    collateralAssets[collateralAsset].penaltyUpdateTime = currentTime;\r\n\r\n\t    emit PenaltyRateChanged(collateralAsset, newPenaltyRate);\r\n\t}\r\n\r\n\t// Owner can set bonus rate for each collateral asset\r\n\tfunction setBonusRate (address collateralAsset, uint newBonusRate) external onlyOwner {\r\n\t\trequire (newBonusRate <= collateralAssets[collateralAsset].penaltyRate\r\n\t\t\t\t&& newBonusRate >= ratesDecimal\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t    collateralAssets[collateralAsset].bonusRate = newBonusRate;\r\n\r\n\t    emit BonusRateChanged(collateralAsset, newBonusRate);\r\n\t}\r\n\r\n\tfunction() payable external {\r\n        revert();\r\n    }\r\n}"
    },
    {
      "filename": "contracts/Holdefi.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./HoldefiPauser.sol\";\r\n\r\n//"
    },
    {
      "filename": "contracts/HoldefiPrices.sol",
      "content": "interface HoldefiPricesInterface {\r\n\tfunction getPrice(address token) external view returns(uint price);\t\r\n}\r\n\r\n//"
    },
    {
      "filename": "contracts/HoldefiSettings.sol",
      "content": "interface HoldefiSettingsInterface {\r\n\tfunction getInterests(address market, uint totalSupply, uint totalBorrow) external view returns(uint borrowRate, uint supplyRate);\r\n\tfunction getMarket(address market) external view returns(bool isActive);\r\n\tfunction getCollateral(address collateral) external view returns(bool isActive, uint valueToLoanRate, uint penaltyRate, uint bonusRate);\r\n\tfunction getMarketsList() external view returns(address[] memory marketsList);\r\n}\r\n\r\n//"
    },
    {
      "filename": "contracts/CollateralsWallet.sol",
      "content": "interface CollateralsWalletInterface {\r\n\tfunction withdraw(address collateral, address payable recipient, uint amount) external;\r\n}\r\n\r\ninterface ERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns(bool success);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool success);\r\n}\r\n\r\n\r\n\r\n // Main Holdefi contract.\r\n // The address of ETH asset considered as 0x00 in this contract.\r\ncontract Holdefi is HoldefiPauser {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\t// All rates in this contract are scaled by ratesDecimal.\r\n\tuint constant public ratesDecimal = 10 ** 4;\r\n\r\n\t// All Indexes in this contract are scaled by (secondsPerYear * ratesDecimal) \r\n\tuint constant public secondsPerYear = 31536000;\r\n\r\n\tuint constant public maxPromotionRate = 3000;\r\n\r\n\t// Markets are assets that can be supplied and borrowed\r\n\tstruct Market {\r\n\t\tuint totalSupply;\r\n\t\tuint supplyIndex;      //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint supplyIndexUpdateTime;\r\n\r\n\t\tuint totalBorrow;\r\n\t\tuint borrowIndex;      //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint borrowIndexUpdateTime;\r\n\r\n\t\tuint promotionRate;\r\n\t\tuint promotionReserveScaled; //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint promotionReserveLastUpdateTime;\r\n\t\tuint promotionDebtScaled;    //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint promotionDebtLastUpdateTime;\r\n\t}\r\n\r\n\t// Collaterals are assets that can be use only as collateral (no interest)\r\n\tstruct Collateral {\r\n\t\tuint totalCollateral;\r\n\t\tuint totalLiquidatedCollateral;\r\n\t}\r\n\r\n\t// Users profile for each market\r\n\tstruct MarketAccount {\r\n\t\tuint balance;\r\n\t\tuint accumulatedInterest; \r\n\t\tuint lastInterestIndex; //Scaled by: secondsPerYear * ratesDecimal\r\n\t}\r\n\t// Users profile for each collateral\r\n\tstruct CollateralAccount {\r\n\t\tuint balance;\r\n\t\tuint lastUpdateTime;\r\n\t}\r\n\r\n\t// Markets: marketAddress => Market\r\n\tmapping (address => Market) public marketAssets;\r\n\r\n\t// Collaterals: collateralAddress => Collateral\r\n\tmapping (address => Collateral) public collateralAssets;\r\n\r\n\t// Users Supplies: userAddress => marketAddress => supplyDetails\r\n\tmapping (address => mapping (address => MarketAccount)) private supplies;\r\n\r\n\t// Users Borrows: userAddress => collateralAddress => marketAddress => borrowDetails \r\n\tmapping (address => mapping (address => mapping (address => MarketAccount))) private borrows;\r\n\r\n\t// Users Collaterals: userAddress => collateralAddress => collateralDetails \r\n\tmapping (address => mapping (address => CollateralAccount)) private collaterals;\r\n\t\r\n\t// Markets Debt after liquidation: collateralAddress => marketAddress => marketDebtBalance \r\n\tmapping (address => mapping (address => uint)) public marketDebt;\r\n\r\n\r\n\t// Contract for getting markets supply rate and borrow rate \r\n\tHoldefiSettingsInterface public holdefiSettings;\r\n\r\n\t// Contract for getting token price \r\n\tHoldefiPricesInterface public holdefiPrices;\r\n\r\n\t// Wallet Contract for Collaterals \r\n\tCollateralsWalletInterface public holdefiCollaterals;\r\n\r\n\t// Price contract can be unchangeable\r\n\tbool public fixPrices = false;\r\n\r\n\t// ----------- Events -----------\r\n\r\n\tevent Supply(address supplier, address market, uint amount);\r\n\r\n\tevent WithdrawSupply(address supplier, address market, uint amount);\r\n\r\n\tevent Collateralize(address collateralizer, address collateral, uint amount);\r\n\r\n\tevent WithdrawCollateral(address collateralizer, address collateral, uint amount);\r\n\r\n\tevent Borrow(address borrower, address market, address collateral, uint amount);\r\n\r\n\tevent RepayBorrow(address borrower, address market, address collateral, uint amount);\r\n\r\n\tevent UpdateSupplyIndex(address market, uint newSupplyIndex, uint supplyRate);\r\n\r\n\tevent UpdateBorrowIndex(address market, uint newBorrowIndex);\r\n\r\n\tevent CollateralLiquidated(address borrower, address collateral, uint amount);\r\n\r\n\tevent NewMarketDebt(address borrower, address market, address collateral, uint amount);\r\n\r\n\tevent BuyLiquidatedCollateral(address market, address collateral, uint marketAmount);\r\n\r\n\tevent PromotionRateChanged(address market, uint newRate);\r\n\r\n\tevent HoldefiPricesContractChanged(HoldefiPricesInterface newAddress, HoldefiPricesInterface oldAddress);\r\n\t\r\n\tconstructor (address newOwnerChanger, CollateralsWalletInterface holdefiCollateralsAddress, HoldefiSettingsInterface holdefiSettingsAddress, HoldefiPricesInterface holdefiPricesAddress) HoldefiPauser(newOwnerChanger) public {\r\n\t\tholdefiCollaterals = holdefiCollateralsAddress;\r\n\t\tholdefiSettings = holdefiSettingsAddress;\r\n\t\tholdefiPrices = holdefiPricesAddress;\r\n\t}\r\n\t\r\n\tfunction supplyInternal (address market, uint amount) internal {\r\n\t\t(uint balance,uint interest,uint currentSupplyIndex) = getAccountSupply(msg.sender, market);\r\n\t\t\r\n\t\tsupplies[msg.sender][market].accumulatedInterest = interest;\r\n\t\tsupplies[msg.sender][market].balance = balance.add(amount);\r\n\t\tsupplies[msg.sender][market].lastInterestIndex = currentSupplyIndex;\r\n\r\n\t\tupdatePromotion(market);\r\n\t\t\r\n\t\tmarketAssets[market].totalSupply = marketAssets[market].totalSupply.add(amount);\r\n\r\n\t\temit Supply(msg.sender, market, amount);\r\n\t}\r\n\r\n\t// Deposit ERC20 assets for supplying (except ETH).\r\n\tfunction supply (address market, uint amount) external whenNotPaused(0) {\r\n\t\trequire (market != address(0), 'Supply asset should not be zero address');\r\n\t\tbool isActive = holdefiSettings.getMarket(market);\r\n\t\trequire (isActive,'Market is not active');\r\n\r\n\t\tERC20 token = ERC20(market);\r\n\t\tbool success = token.transferFrom(msg.sender, address(this), amount);\r\n\t\trequire (success, 'Cannot transfer token');\r\n\r\n\t\tsupplyInternal(market, amount);\r\n\t}\r\n\r\n\t// Deposit ETH for supplying\r\n\tfunction supply () payable external whenNotPaused(0) {\r\n\t\taddress market = address(0);\r\n\t\tuint amount = msg.value;\r\n\t\tbool isActive = holdefiSettings.getMarket(market);\r\n\t\trequire (isActive, 'Market is not active');\r\n\t\t\r\n\t\tsupplyInternal(market, amount);\r\n\t}\r\n\r\n\t// Withdraw ERC20 assets from a market (include interests).\r\n\tfunction withdrawSupply (address market, uint amount) external whenNotPaused(1) {\r\n\t\t(uint balance,uint interest,uint currentSupplyIndex) = getAccountSupply(msg.sender, market);\r\n\t\t\r\n\t\tuint transferAmount;\r\n\t\tuint totalBalance = balance.add(interest);\r\n\r\n\t\trequire (totalBalance != 0, 'Total balance should not be zero');\r\n\t\tif (amount <= totalBalance){\r\n\t\t\ttransferAmount = amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttransferAmount = totalBalance;\r\n\t\t}\r\n\r\n\t\tuint remaining;\r\n\t\tif (transferAmount <= interest) {\r\n\t\t\tsupplies[msg.sender][market].accumulatedInterest = interest.sub(transferAmount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tremaining = transferAmount.sub(interest);\r\n\t\t\tsupplies[msg.sender][market].accumulatedInterest = 0;\r\n\t\t\tsupplies[msg.sender][market].balance = balance.sub(remaining);\r\n\t\t}\r\n\t\tsupplies[msg.sender][market].lastInterestIndex = currentSupplyIndex;\r\n\r\n\t\tupdatePromotion(market);\r\n\t\t\r\n\t\tmarketAssets[market].totalSupply = marketAssets[market].totalSupply.sub(remaining);\t\r\n\t\t\t\t\r\n\t\tif (market == address(0)){\r\n\t\t\tmsg.sender.transfer(transferAmount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tERC20 token = ERC20(market);\r\n\t\t\tbool success = token.transfer(msg.sender, transferAmount);\r\n\t\t\trequire (success, 'Cannot transfer token');\r\n\t\t}\r\n\t\r\n\t\temit WithdrawSupply(msg.sender, market, transferAmount);\r\n\t}\r\n\r\n\tfunction collateralizeInternal (address collateral, uint amount) internal {\r\n\t\tcollaterals[msg.sender][collateral].balance = collaterals[msg.sender][collateral].balance.add(amount);\r\n\t\tcollaterals[msg.sender][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tcollateralAssets[collateral].totalCollateral = collateralAssets[collateral].totalCollateral.add(amount);\t\r\n\t\t\r\n\t\temit Collateralize(msg.sender, collateral, amount);\r\n\t}\r\n\r\n\t// Deposit ERC20 assets as collateral(except ETH) \r\n\tfunction collateralize (address collateral, uint amount) external whenNotPaused(2) {\r\n\t\trequire (collateral != address(0), 'Collateral asset should not be zero address');\r\n\t\t(bool isActive,,,) = holdefiSettings.getCollateral(collateral);\r\n\t\trequire (isActive, 'Collateral asset is not active');\r\n\r\n\t\tERC20 token = ERC20(collateral);\r\n\t\tbool success = token.transferFrom(msg.sender, address(holdefiCollaterals), amount);\r\n\t\trequire (success, 'Cannot Transfer Token');\r\n\r\n\t\tcollateralizeInternal(collateral, amount);\r\n\t}\r\n\r\n\t// Deposit ETH as collateral\r\n\tfunction collateralize () payable external whenNotPaused(2) {\r\n\t\taddress collateral = address(0);\r\n\t\tuint amount = msg.value;\r\n\t\t(bool isActive,,,) = holdefiSettings.getCollateral(collateral);\r\n\t\trequire (isActive, 'Collateral asset is not active');\r\n\r\n\t\t(bool success, ) = address(holdefiCollaterals).call.value(amount)(\"\");\r\n\t\trequire (success, 'Cannot Transfer ETH');\r\n\r\n\t\tcollateralizeInternal(collateral, amount);\r\n\t}\r\n\r\n\t// Withdraw collateral assets\r\n\tfunction withdrawCollateral (address collateral, uint amount) external whenNotPaused(3) {\r\n\t\t(uint balance, ,uint borrowPowerScaled,uint totalBorrowValueScaled,) = getAccountCollateral(msg.sender, collateral);\t\r\n\t\trequire (borrowPowerScaled != 0, 'Borrow power should not be zero');\r\n\r\n\t\tuint maxWithdraw;\r\n\t\tif (totalBorrowValueScaled == 0) {\r\n\t\t\tmaxWithdraw = balance;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint collateralPriceScaled = holdefiPrices.getPrice(collateral);\r\n\t\t\t(,uint valueToLoanRate,,) = holdefiSettings.getCollateral(collateral);\r\n\t\t\tuint totalCollateralValueScaled = totalBorrowValueScaled.mul(valueToLoanRate);\t\r\n\t\t\tuint collateralNedeed = totalCollateralValueScaled.div(collateralPriceScaled);\r\n\t\t\tcollateralNedeed = collateralNedeed.div(ratesDecimal);\r\n\r\n\t\t\tmaxWithdraw = balance.sub(collateralNedeed);\r\n\t\t}\r\n\r\n\t\tuint transferAmount;\r\n\t\tif (amount < maxWithdraw){\r\n\t\t\ttransferAmount = amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttransferAmount = maxWithdraw;\r\n\t\t}\r\n\r\n\t\tcollaterals[msg.sender][collateral].balance = balance.sub(transferAmount);\r\n\t\tcollaterals[msg.sender][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tcollateralAssets[collateral].totalCollateral = collateralAssets[collateral].totalCollateral.sub(transferAmount);\r\n\r\n\t\tholdefiCollaterals.withdraw(collateral, msg.sender, transferAmount);\r\n\r\n\t\temit WithdrawCollateral(msg.sender, collateral, transferAmount);\r\n\t}\r\n\r\n\t// Borrow a `market` asset based on a `collateral` power \r\n\tfunction borrow (address market, address collateral, uint amount) external whenNotPaused(4) {\r\n\t\tbool isActiveMarket = holdefiSettings.getMarket(market);\r\n\t\t(bool isActiveCollateral,,,) = holdefiSettings.getCollateral(collateral);\r\n\t\trequire (isActiveMarket && isActiveCollateral\r\n\t\t\t\t,'Market or Collateral asset is not active');\r\n\r\n\t\tuint maxAmount = marketAssets[market].totalSupply.sub(marketAssets[market].totalBorrow);\r\n\t\trequire (amount <= maxAmount, 'Amount should be less than cash');\r\n\r\n\t\t(,,uint borrowPowerScaled,,) = getAccountCollateral(msg.sender, collateral);\t\r\n\t\tuint assetToBorrowPrice = holdefiPrices.getPrice(market);\r\n\t\tuint assetToBorrowValueScaled = amount.mul(assetToBorrowPrice);\r\n\t\trequire (borrowPowerScaled > assetToBorrowValueScaled, 'Borrow power should be more than new borrow value');\r\n\r\n\t\t(,uint interest,uint currentBorrowIndex) = getAccountBorrow(msg.sender, market, collateral);\r\n\t\t\r\n\t\tborrows[msg.sender][collateral][market].accumulatedInterest = interest;\r\n\t\tborrows[msg.sender][collateral][market].balance = borrows[msg.sender][collateral][market].balance.add(amount);\r\n\t\tborrows[msg.sender][collateral][market].lastInterestIndex = currentBorrowIndex;\r\n\t\tcollaterals[msg.sender][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tupdateSupplyIndex(market);\r\n\t\tupdatePromotionReserve(market);\r\n\r\n\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.add(amount);\r\n\r\n\t\tif (market == address(0)){\r\n\t\t\tmsg.sender.transfer(amount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tERC20 token = ERC20(market);\r\n\t\t\tbool success = token.transfer(msg.sender, amount);\r\n\t\t\trequire (success, 'Cannot transfer token');\r\n\t\t}\r\n\t\temit Borrow(msg.sender, market, collateral, amount);\r\n\t}\r\n\r\n\tfunction repayBorrowInternal (address market, address collateral, uint amount) internal {\r\n\t\t(uint balance,uint interest,uint currentBorrowIndex) = getAccountBorrow(msg.sender, market, collateral);\r\n\t\t\r\n\t\tuint remaining;\r\n\t\tif (amount <= interest) {\r\n\t\t\tborrows[msg.sender][collateral][market].accumulatedInterest = interest.sub(amount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tremaining = amount.sub(interest);\r\n\t\t\tborrows[msg.sender][collateral][market].accumulatedInterest = 0;\r\n\t\t\tborrows[msg.sender][collateral][market].balance = balance.sub(remaining);\r\n\t\t}\r\n\t\tborrows[msg.sender][collateral][market].lastInterestIndex = currentBorrowIndex;\r\n\t\tcollaterals[msg.sender][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tupdateSupplyIndex(market);\r\n\t\tupdatePromotionReserve(market);\r\n\t\t\r\n\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.sub(remaining);\t\r\n\r\n\t\temit Borrow (msg.sender, market, collateral, amount);\r\n\t}\r\n\r\n\t// Repay borrow a `market` token based on a `collateral` power\r\n\tfunction repayBorrow (address market, address collateral, uint amount) external whenNotPaused(5) {\r\n\t\trequire (market != address(0), 'Borrow asset should not be zero address');\r\n\r\n\t\t(uint balance, uint interest,) = getAccountBorrow(msg.sender, market, collateral);\r\n\t\t\r\n\t\tuint transferAmount;\r\n\t\tuint totalBalance = balance.add(interest);\r\n\t\trequire (totalBalance != 0, 'Total balance should not be zero');\r\n\t\tif (amount <= totalBalance){\r\n\t\t\ttransferAmount = amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttransferAmount = totalBalance;\r\n\t\t}\r\n\r\n\t\tERC20 token = ERC20(market);\r\n\t\tbool success = token.transferFrom(msg.sender, address(this), transferAmount);\r\n\t\trequire (success, 'Cannot transfer token');\r\n\r\n\t\trepayBorrowInternal(market, collateral, transferAmount);\r\n\t}\r\n\r\n\t// Repay borrow ETH based on a `collateral` power\r\n\tfunction repayBorrow (address collateral) payable external whenNotPaused(5) {\r\n\t\taddress market = address(0);\r\n\t\tuint amount = msg.value;\t\t\r\n\r\n\t\t(uint balance,uint interest,) = getAccountBorrow(msg.sender, market, collateral);\r\n\t\t\r\n\t\tuint transferAmount;\r\n\t\tuint totalBalance = balance.add(interest);\r\n\t\trequire (totalBalance != 0, 'Total balance should not be zero');\r\n\t\tif (amount <= totalBalance) {\r\n\t\t\ttransferAmount = amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttransferAmount = totalBalance;\r\n\t\t\tuint extra = amount.sub(totalBalance);\r\n\t\t\tmsg.sender.transfer(extra);\r\n\t\t}\r\n\r\n\t\trepayBorrowInternal(market, collateral, transferAmount);\r\n\t}\r\n\r\n\tfunction clearDebts (address borrower, address collateral) internal {\r\n\t\taddress market;\r\n\t\tuint borrowBalance;\r\n\t\tuint borrowInterest;\r\n\t\tuint borrowInterestIndex;\r\n\t\tuint totalBalance;\r\n\t\taddress[] memory marketsList = holdefiSettings.getMarketsList();\r\n\t\tfor (uint i=0; i<marketsList.length; i++) {\r\n\t\t\tmarket = marketsList[i];\r\n\t\t\t\r\n\t\t\t(borrowBalance,borrowInterest,borrowInterestIndex) = getAccountBorrow(borrower, market, collateral);\r\n\t\t\ttotalBalance = borrowBalance.add(borrowInterest);\r\n\t\t\tif (totalBalance > 0) {\r\n\t\t\t\tborrows[borrower][collateral][market].balance = 0;\r\n\t\t\t\tborrows[borrower][collateral][market].accumulatedInterest = 0;\r\n\t\t\t\tborrows[borrower][collateral][market].lastInterestIndex = borrowInterestIndex;\r\n\t\t\t\tupdateSupplyIndex(market);\r\n\t\t\t\tupdatePromotionReserve(market);\t\t\r\n\t\t\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.sub(borrowBalance);\r\n\t\t\t\tmarketDebt[collateral][market] = marketDebt[collateral][market].add(totalBalance);\r\n\t\t\t\temit NewMarketDebt(borrower, market, collateral, totalBalance);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Liquidate borrower's collateral\r\n\tfunction liquidateBorrowerCollateral (address borrower, address collateral) external whenNotPaused(6) {\r\n\t\t(,uint timeSinceLastActivity,,uint totalBorrowValueScaled,bool underCollateral) = getAccountCollateral(borrower, collateral);\r\n\t\t\r\n\t\trequire (underCollateral || (timeSinceLastActivity > secondsPerYear), 'User should be under collateral or time is over');\r\n\r\n\t\tuint collateralPrice = holdefiPrices.getPrice(collateral);\r\n\t\t(,,uint penaltyRate,) = holdefiSettings.getCollateral(collateral);\r\n\t\tuint liquidatedCollateralValue = totalBorrowValueScaled.mul(penaltyRate);\r\n\t\tuint liquidatedCollateral = liquidatedCollateralValue.div(collateralPrice);\r\n\t\tliquidatedCollateral = liquidatedCollateral.div(ratesDecimal);\r\n\r\n\t\tif (liquidatedCollateral > collaterals[borrower][collateral].balance) {\r\n\t\t\tliquidatedCollateral = collaterals[borrower][collateral].balance;\r\n\t\t}\r\n\r\n\t\tcollaterals[borrower][collateral].balance = collaterals[borrower][collateral].balance.sub(liquidatedCollateral);\r\n\t\tcollateralAssets[collateral].totalCollateral = collateralAssets[collateral].totalCollateral.sub(liquidatedCollateral);\r\n\t\tcollateralAssets[collateral].totalLiquidatedCollateral = collateralAssets[collateral].totalLiquidatedCollateral.add(liquidatedCollateral);\r\n\t\tcollaterals[msg.sender][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tclearDebts(borrower, collateral);\r\n\r\n\t\temit CollateralLiquidated(borrower, collateral, liquidatedCollateral);\t\r\n\t}\r\n\r\n\tfunction buyLiquidatedCollateralInternal (address market, address collateral, uint marketAmount, uint collateralAmountWithDiscount) internal {\r\n\t\tcollateralAssets[collateral].totalLiquidatedCollateral = collateralAssets[collateral].totalLiquidatedCollateral.sub(collateralAmountWithDiscount);\r\n\t\tmarketDebt[collateral][market] = marketDebt[collateral][market].sub(marketAmount);\r\n\r\n\t\tholdefiCollaterals.withdraw(collateral, msg.sender, collateralAmountWithDiscount);\r\n\r\n\t\temit BuyLiquidatedCollateral(market, collateral, marketAmount);\r\n\t}\r\n\r\n\t// Buy `collateral` in exchange for `market` token\r\n\tfunction buyLiquidatedCollateral (address market, address collateral, uint marketAmount) external whenNotPaused(7) {\r\n\t\trequire (market != address(0), 'Market should not be zero address');\r\n\t\r\n\t\trequire (marketAmount <= marketDebt[collateral][market], 'Amount should be less than total liquidated assets');\r\n\r\n\t\tuint collateralAmountWithDiscount = getDiscountedCollateralAmount(market, collateral, marketAmount);\r\n\r\n\t\trequire (collateralAmountWithDiscount <= collateralAssets[collateral].totalLiquidatedCollateral, 'Collateral amount with discount should be less than total liquidated assets');\r\n\r\n\t\tERC20 token = ERC20(market);\r\n\t\tbool success = token.transferFrom(msg.sender, address(this), marketAmount);\r\n\t\trequire (success, 'Cannot transfer token');\r\n\r\n\t\tbuyLiquidatedCollateralInternal(market, collateral, marketAmount, collateralAmountWithDiscount);\r\n\t}\r\n\r\n\t// Buy `collateral` in exchange for ETH \r\n\tfunction buyLiquidatedCollateral (address collateral) external payable whenNotPaused(7) {\r\n\t\taddress market = address(0);\r\n\t\tuint marketAmount = msg.value;\r\n\r\n\t\trequire (marketAmount <= marketDebt[collateral][market], 'Amount should be less than total liquidated assets');\r\n\r\n\t\tuint collateralAmountWithDiscount = getDiscountedCollateralAmount(market, collateral, marketAmount);\r\n\r\n\t\trequire (collateralAmountWithDiscount <= collateralAssets[collateral].totalLiquidatedCollateral, 'Collateral amount with discount should be less than total liquidated assets');\r\n\r\n\t\tbuyLiquidatedCollateralInternal(market, collateral, marketAmount, collateralAmountWithDiscount);\r\n\t}\r\n\r\n\t// Returns amount of discounted collateral that buyer can buy by paying `market` asset\r\n\tfunction getDiscountedCollateralAmount (address market, address collateral, uint marketAmount) public view returns(uint collateralAmountWithDiscount) {\r\n\t\tuint marketPrice = holdefiPrices.getPrice(market);\r\n\t\tuint marketValue = marketAmount.mul(marketPrice);\r\n\r\n\t\tuint collateralPrice = holdefiPrices.getPrice(collateral);\r\n\t\t(,,,uint bonusRate) = holdefiSettings.getCollateral(collateral);\r\n\t\tuint collateralAmountWithDiscountScaled = marketValue.mul(bonusRate);\r\n\t\tcollateralAmountWithDiscount = collateralAmountWithDiscountScaled.div(collateralPrice);\r\n\t\tcollateralAmountWithDiscount = collateralAmountWithDiscount.div(ratesDecimal);\r\n\t}\r\n\t\r\n\t// Returns supply and borrow index for a given `market` at current time \r\n\tfunction getCurrentInterestIndex (address market) public view returns(uint supplyIndex, uint supplyRate, uint borrowIndex, uint borrowRate, uint currentTime) {\r\n\t\tuint supplyRateBase;\r\n\t\t(borrowRate,supplyRateBase) = holdefiSettings.getInterests(market, marketAssets[market].totalSupply, marketAssets[market].totalBorrow);\r\n\t\t\r\n\t\tcurrentTime = block.timestamp;\r\n\t\tsupplyRate = supplyRateBase.add(marketAssets[market].promotionRate);\r\n\r\n\t\tuint deltaTimeSupply = currentTime.sub(marketAssets[market].supplyIndexUpdateTime);\r\n\r\n\t\tuint deltaTimeBorrow = currentTime.sub(marketAssets[market].borrowIndexUpdateTime);\r\n\r\n\t\tuint deltaTimeInterest = deltaTimeSupply.mul(supplyRate);\r\n\t\tsupplyIndex = marketAssets[market].supplyIndex.add(deltaTimeInterest);\r\n\r\n\t\td"
    }
  ]
}