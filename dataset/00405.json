{
  "Title": "H-6: All ETH can be stolen during rebalancing for `mTOFTs` that hold native",
  "Content": "# Issue H-6: All ETH can be stolen during rebalancing for `mTOFTs` that hold native \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/69 \n\n## Found by \n0xadrii, GiuseppeDeLaZara\n## Summary\nRebalancing of ETH transfers the ETH to the destination mTOFT without calling `sgRecieve` which leaves the ETH hanging inside the `mTOFT` contract. \nThis can be exploited to steal all the ETH.\n\n## Vulnerability Detail\nRebalancing of `mTOFTs` that hold native tokens is done through the `routerETH` contract inside the `Balancer.sol` contract. \nHere is the code snippet for the `routerETH` contract:\n\n```solidity\n## Balancer.sol\n\nif (address(this).balance < _amount) revert ExceedsBalance();\n        uint256 valueAmount = msg.value + _amount;\n        routerETH.swapETH{value: valueAmount}(\n            _dstChainId,\n            payable(this),\n            abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n            _amount,\n            _computeMinAmount(_amount, _slippage)\n        );\n```\n\nThe expected behaviour is ETH being received on the destination chain whereby `sgReceive` is called and ETH is deposited inside the `TOFTVault`.\n\n```solidity\n## mTOFT.sol\n\n    function sgReceive(uint16, bytes memory, uint256, address, uint256 amountLD, bytes memory) external payable {\n        if (msg.sender != _stargateRouter) revert mTOFT_NotAuthorized();\n\n        if (erc20 == address(0)) {\n            vault.depositNative{value: amountLD}();\n        } else {\n            IERC20(erc20).safeTransfer(address(vault), amountLD);\n        }\n    }\n```\n\nBy taking a closer look at the logic inside the [`routerETH`](https://www.codeslaw.app/contracts/ethereum/0x150f94B44927F078737562f0fcF3C95c01Cc2376) contract we can see that the transfer is called with an empty payload:\n```solidity\n    // compose stargate to swap ETH on the source to ETH on the destination\n    function swapETH(\n        uint16 _dstChainId,                         // destination Stargate chainId\n        address payable _refundAddress,             // refund additional messageFee to this address\n        bytes calldata _toAddress,                  // the receiver of the destination ETH\n        uint256 _amountLD,                          // the amount, in Local Decimals, to be swapped\n        uint256 _minAmountLD                        // the minimum amount accepted out on destination\n    ) external payable {\n        require(msg.value > _amountLD, \"Stargate: msg.value must be > _amountLD\");\n\n        // wrap the ETH into WETH\n        IStargateEthVault(stargateEthVault).deposit{value: _amountLD}();\n        IStargateEthVault(stargateEthVault).approve(address(stargateRouter), _amountLD);\n\n        // messageFee is the remainder of the msg.value after wrap\n        uint256 messageFee = msg.value - _amountLD;\n\n        // compose a stargate swap() using the WETH that was just wrapped\n        stargateRouter.swap{value: messageFee}(\n            _dstChainId,                        // destination Stargate chainId\n            poolId,                             // WETH Stargate poolId on source\n            poolId,                             // WETH Stargate poolId on destination\n            _refundAddress,                     // message refund address if overpaid\n            _amountLD,                          // the amount in Local Decimals to swap()\n            _minAmountLD,                       // the minimum amount swap()er would allow to get out (ie: slippage)\n            IStargateRouter.lzTxObj(0, 0, \"0x\"),\n            _toAddress,                         // address on destination to send to\n>>>>>>      bytes(\"\")                           // empty payload, since sending to EOA\n        );\n    }\n```\n\nNotice the comment:\n\n> empty payload, since sending to EOA\n\nSo `routerETH` after depositing ETH in `StargateEthVault` calls the regular `StargateRouter` but with an empty payload. \n\nNext, let's see how the receiving logic works.\n\nAs Stargate is just another application built on top of LayerZero the receiving starts inside the [`Bridge::lzReceive`](https://github.com/stargate-protocol/stargate/blob/5f0dfd290d8290678b933b64f31d119b3c4b4e6a/contracts/Bridge.sol#L58) function.\nAs the type of transfer is `TYPE_SWAP_REMOTE` the `router::swapRemote` is called:\n\n```solidity\nfunction lzReceive(\n    uint16 _srcChainId,\n    bytes memory _srcAddress,\n    uint64 _nonce,\n    bytes memory _payload\n) external override {\n\n\n    if (functionType == TYPE_SWAP_REMOTE) {\n        (\n            ,\n            uint256 srcPoolId,\n            uint256 dstPoolId,\n            uint256 dstGasForCall,\n            Pool.CreditObj memory c,\n            Pool.SwapObj memory s,\n            bytes memory to,\n            bytes memory payload\n        ) = abi.decode(_payload, (uint8, uint256, uint256, uint256, Pool.CreditObj, Pool.SwapObj, bytes, bytes));\n        address toAddress;\n        assembly {\n            toAddress := mload(add(to, 20))\n        }\n        router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n>>>>>>  router.swapRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, dstGasForCall, toAddress, s, payload);\n```\n\n[`Router:swapRemote`](https://github.com/stargate-protocol/stargate/blob/5f0dfd290d8290678b933b64f31d119b3c4b4e6a/contracts/Router.sol#L390-#L425) has two responsibilities:\n- First it calls `pool::swapRemote` that transfers the actual tokens to the destination address. In this case this is the `mTOFT` contract. \n- Second it will call `IStargateReceiver(mTOFTAddress)::sgReceive` but only if the payload is not empty.\n\n```solidity\n function _swapRemote(\n    uint16 _srcChainId,\n    bytes memory _srcAddress,\n    uint256 _nonce,\n    uint256 _srcPoolId,\n    uint256 _dstPoolId,\n    uint256 _dstGasForCall,\n    address _to,\n    Pool.SwapObj memory _s,\n    bytes memory _payload\n) internal {\n    Pool pool = _getPool(_dstPoolId);\n    // first try catch the swap remote\n    try pool.swapRemote(_srcChainId, _srcPoolId, _to, _s) returns (uint256 amountLD) {\n>>>>>>   if (_payload.length > 0) {\n            // then try catch the external contract call\n>>>>>>      try IStargateReceiver(_to).sgReceive{gas: _dstGasForCall}(_srcChainId, _srcAddress, _nonce, pool.token(), amountLD, _payload) {\n                // do nothing\n            } catch (bytes memory reason) {\n                cachedSwapLookup[_srcChainId][_srcAddress][_nonce] = CachedSwap(pool.token(), amountLD, _to, _payload);\n                emit CachedSwapSaved(_srcChainId, _srcAddress, _nonce, pool.token(), amountLD, _to, _payload, reason);\n            }\n        }\n    } catch {\n        revertLookup[_srcChainId][_srcAddress][_nonce] = abi.encode(\n            TYPE_SWAP_REMOTE_RETRY,\n            _srcPoolId,\n            _dstPoolId,\n            _dstGasForCall,\n            _to,\n            _s,\n            _payload\n        );\n        emit Revert(TYPE_SWAP_REMOTE_RETRY, _srcChainId, _srcAddress, _nonce);\n    }\n}\n```\n\nAs payload is empty in case of using the `routerETH` contract the `sgReceive` function is never called. This means that the ETH is left sitting inside the `mTOFT` contract. \n\nThere are several ways of stealing the balance of `mTOFT`. \nAn attacker can use the [`mTOFT::sendPacket`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/mTOFT.sol#L234) function and utilize the `lzNativeGasDrop` option to airdrop the balance of mTOFT to attacker's address on the destination chain: https://docs.layerzero.network/contracts/options#lznativedrop-option\n\n```solidity\n## TapiocaOmnichainSender.sol\n\n function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        external\n        payable\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        // @dev Applies the token transfers regarding this send() operation.\n        // - amountDebitedLD is the amount in local decimals that was ACTUALLY debited from the sender.\n        // - amountToCreditLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        (uint256 amountDebitedLD, uint256 amountToCreditLD) =\n            _debit(_lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid);\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) =\n            _buildOFTMsgAndOptions(_lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD);\n\n        // @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        // @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD, amountToCreditLD);\n\n        emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, msg.sender, amountDebitedLD);\n    }\n```\n\nAll he has to do is specify the option type `lzNativeDrop` inside the `_lsSendParams.extraOptions` and the cost of calling `_lzSend` plus the airdrop amount will be paid out from the balance of `mTOFT`.\n\nAs this is a complete theft of the rebalanced amount I'm rating this as a critical vulnerability.\n\n\n## Impact\nAll ETH can be stolen during rebalancing for mTOFTs that hold native tokens.\n\n## Code Snippet\n- https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/Balancer.sol#L269-#L279\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\nOne way to fix this is use the alternative `RouterETH.sol` contract available from Stargate that allows for a payload to be sent. \nIt is denoted as `*RouterETH.sol` in the Stargate documentation: https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\nThis router has the `swapETHAndCall` interface:\n\n```solidity\nfunction swapETHAndCall(\n        uint16 _dstChainId, // destination Stargate chainId\n        address payable _refundAddress, // refund additional messageFee to this address\n        bytes calldata _toAddress, // the receiver of the destination ETH\n        SwapAmount memory _swapAmount, // the amount and the minimum swap amount\n        IStargateRouter.lzTxObj memory _lzTxParams, // the LZ tx params\n        bytes calldata _payload // the payload to send to the destination\n    ) external payable {\n```\n\nThe contract on Ethereum can be found at: https://www.codeslaw.app/contracts/ethereum/0xb1b2eeF380f21747944f46d28f683cD1FBB4d03c. \nAnd the Stargate docs specify its deployment address on all the chains where ETH is supported: https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nWe had a chat with LZ about this a while ago and yes, the router cannot be used in this case. However the contract we're going to use is https://etherscan.io/address/0xeCc19E177d24551aA7ed6Bc6FE566eCa726CC8a9#code and it respects the IStargateRouter interface\n\n**windhustler**\n\nThe contract you referenced above, i.e. [`StargateComposer`](https://etherscan.io/address/0xeCc19E177d24551aA7ed6Bc6FE566eCa726CC8a9#code) doesn't have the `swapETH` interface: \n\n```solidity\nfunction swapETH(uint16 _dstChainId, address payable _refundAddress, bytes calldata _toAddress, uint256 _amountLD, uint256 _minAmountLD) external;\n```\n\nYour options are to refactor this to either use the [`*RouterETH: swapETHAndCall`](https://etherscan.io/address/0xb1b2eeF380f21747944f46d28f683cD1FBB4d03c#code) or the [`StargateComposer::swapETHAndCall`](https://etherscan.io/address/0xeCc19E177d24551aA7ed6Bc6FE566eCa726CC8a9#code) function.\n\n\n**cryptotechmaker**\n\nGood catch @windhustler\n\n\n**cryptotechmaker**\n\nChanged the status to 'Will fix'\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/pull/174; https://github.com/Tapioca-DAO/tapioca-periph/pull/198.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "contracts/Bridge.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\n// imports\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Pool.sol\";\nimport \"./Router.sol\";\n// interfaces\nimport \"@layerzerolabs/contracts/contracts/interfaces/ILayerZeroReceiver.sol\";\nimport \"@layerzerolabs/contracts/contracts/interfaces/ILayerZeroEndpoint.sol\";\nimport \"@layerzerolabs/contracts/contracts/interfaces/ILayerZeroUserApplicationConfig.sol\";\n\n// libraries\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Bridge is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using SafeMath for uint256;\n\n    //---------------------------------------------------------------------------\n    // CONSTANTS\n    uint8 internal constant TYPE_SWAP_REMOTE = 1;\n    uint8 internal constant TYPE_ADD_LIQUIDITY = 2;\n    uint8 internal constant TYPE_REDEEM_LOCAL_CALL_BACK = 3;\n    uint8 internal constant TYPE_WITHDRAW_REMOTE = 4;\n\n    //---------------------------------------------------------------------------\n    // VARIABLES\n    ILayerZeroEndpoint public immutable layerZeroEndpoint;\n    mapping(uint16 => bytes) public bridgeLookup;\n    mapping(uint16 => mapping(uint8 => uint256)) public gasLookup;\n    Router public immutable router;\n    bool public useLayerZeroToken;\n\n    //---------------------------------------------------------------------------\n    // EVENTS\n    event SendMsg(uint8 msgType, uint64 nonce);\n\n    //---------------------------------------------------------------------------\n    // MODIFIERS\n    modifier onlyRouter() {\n        require(msg.sender == address(router), \"Stargate: caller must be Router.\");\n        _;\n    }\n\n    constructor(address _layerZeroEndpoint, address _router) {\n        require(_layerZeroEndpoint != address(0x0), \"Stargate: _layerZeroEndpoint cannot be 0x0\");\n        require(_router != address(0x0), \"Stargate: _router cannot be 0x0\");\n        layerZeroEndpoint = ILayerZeroEndpoint(_layerZeroEndpoint);\n        router = Router(_router);\n    }\n\n    //---------------------------------------------------------------------------\n    // EXTERNAL functions\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        require(msg.sender == address(layerZeroEndpoint), \"Stargate: only LayerZero endpoint can call lzReceive\");\n        require(\n            _srcAddress.length == bridgeLookup[_srcChainId].length && keccak256(_srcAddress) == keccak256(bridgeLookup[_srcChainId]),\n            \"Stargate: bridge does not match\"\n        );\n\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        if (functionType == TYPE_SWAP_REMOTE) {\n            (\n                ,\n                uint256 srcPoolId,\n                uint256 dstPoolId,\n                uint256 dstGasForCall,\n                Pool.CreditObj memory c,\n                Pool.SwapObj memory s,\n                bytes memory to,\n                bytes memory payload\n            ) = abi.decode(_payload, (uint8, uint256, uint256, uint256, Pool.CreditObj, Pool.SwapObj, bytes, bytes));\n            address toAddress;\n            assembly {\n                toAddress := mload(add(to, 20))\n            }\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n            router.swapRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, dstGasForCall, toAddress, s, payload);\n        } else if (functionType == TYPE_ADD_LIQUIDITY) {\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c) = abi.decode(_payload, (uint8, uint256, uint256, Pool.CreditObj));\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n        } else if (functionType == TYPE_REDEEM_LOCAL_CALL_BACK) {\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c, uint256 amountSD, uint256 mintAmountSD, bytes memory to) = abi\n                .decode(_payload, (uint8, uint256, uint256, Pool.CreditObj, uint256, uint256, bytes));\n            address toAddress;\n            assembly {\n                toAddress := mload(add(to, 20))\n            }\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n            router.redeemLocalCallback(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, toAddress, amountSD, mintAmountSD);\n        } else if (functionType == TYPE_WITHDRAW_REMOTE) {\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c, uint256 amountSD, bytes memory to) = abi.decode(\n                _payload,\n                (uint8, uint256, uint256, Pool.CreditObj, uint256, bytes)\n            );\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n            router.redeemLocalCheckOnRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, amountSD, to);\n        }\n    }\n\n    //---------------------------------------------------------------------------\n    // LOCAL CHAIN FUNCTIONS\n    function swap(\n        uint16 _chainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c,\n        Pool.SwapObj memory _s,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes calldata _to,\n        bytes calldata _payload\n    ) external payable onlyRouter {\n        bytes memory payload = abi.encode(TYPE_SWAP_REMOTE, _srcPoolId, _dstPoolId, _lzTxParams.dstGasForCall, _c, _s, _to, _payload);\n        _call(_chainId, TYPE_SWAP_REMOTE, _refundAddress, _lzTxParams, payload);\n    }\n\n    function redeemLocalCallback(\n        uint16 _chainId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes memory _payload\n    ) external payable onlyRouter {\n        bytes memory payload;\n\n        {\n            (, uint256 srcPoolId, uint256 dstPoolId, uint256 amountSD, uint256 mintAmountSD, bytes memory to) = abi.decode(\n                _payload,\n                (uint8, uint256, uint256, uint256, uint256, bytes)\n            );\n\n            // swap dst and src because we are headed back\n            payload = abi.encode(TYPE_REDEEM_LOCAL_CALL_BACK, dstPoolId, srcPoolId, _c, amountSD, mintAmountSD, to);\n        }\n\n        _call(_chainId, TYPE_REDEEM_LOCAL_CALL_BACK, _refundAddress, _lzTxParams, payload);\n    }\n\n    function redeemLocal(\n        uint16 _chainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c,\n        uint256 _amountSD,\n        bytes calldata _to,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) external payable onlyRouter {\n        bytes memory payload = abi.encode(TYPE_WITHDRAW_REMOTE, _srcPoolId, _dstPoolId, _c, _amountSD, _to);\n        _call(_chainId, TYPE_WITHDRAW_REMOTE, _refundAddress, _lzTxParams, payload);\n    }\n\n    function sendCredits(\n        uint16 _chainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c\n    ) external payable onlyRouter {\n        bytes memory payload = abi.encode(TYPE_ADD_LIQUIDITY, _srcPoolId, _dstPoolId, _c);\n        IStargateRouter.lzTxObj memory lzTxObj = IStargateRouter.lzTxObj(0, 0, \"0x\");\n        _call(_chainId, TYPE_ADD_LIQUIDITY, _refundAddress, lzTxObj, payload);\n    }\n\n    function quoteLayerZeroFee(\n        uint16 _chainId,\n        uint8 _functionType,\n        bytes calldata _toAddress,\n        bytes calldata _transferAndCallPayload,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) external view returns (uint256, uint256) {\n        bytes memory payload = \"\";\n        Pool.CreditObj memory c = Pool.CreditObj(1, 1);\n        if (_functionType == TYPE_SWAP_REMOTE) {\n            Pool.SwapObj memory s = Pool.SwapObj(1, 1, 1, 1, 1, 1);\n            payload = abi.encode(TYPE_SWAP_REMOTE, 0, 0, 0, c, s, _toAddress, _transferAndCallPayload);\n        } else if (_functionType == TYPE_ADD_LIQUIDITY) {\n            payload = abi.encode(TYPE_ADD_LIQUIDITY, 0, 0, c);\n        } else if (_functionType == TYPE_REDEEM_LOCAL_CALL_BACK) {\n            payload = abi.encode(TYPE_REDEEM_LOCAL_CALL_BACK, 0, 0, c, 0, 0, _toAddress);\n        } else if (_functionType == TYPE_WITHDRAW_REMOTE) {\n            payload = abi.encode(TYPE_WITHDRAW_REMOTE, 0, 0, c, 0, _toAddress);\n        } else {\n            revert(\"Stargate: unsupported function type\");\n        }\n\n        bytes memory lzTxParamBuilt = _txParamBuilder(_chainId, _functionType, _lzTxParams);\n        return layerZeroEndpoint.estimateFees(_chainId, address(this), payload, useLayerZeroToken, lzTxParamBuilt);\n    }\n\n    //---------------------------------------------------------------------------\n    // dao functions\n    function setBridge(uint16 _chainId, bytes calldata _bridgeAddress) external onlyOwner {\n        require(bridgeLookup[_chainId].length == 0, \"Stargate: Bridge already set!\");\n        bridgeLookup[_chainId] = _bridgeAddress;\n    }\n\n    function setGasAmount(\n        uint16 _chainId,\n        uint8 _functionType,\n        uint256 _gasAmount\n    ) external onlyOwner {\n        require(_functionType >= 1 && _functionType <= 4, \"Stargate: invalid _functionType\");\n        gasLookup[_chainId][_functionType] = _gasAmount;\n    }\n\n    function approveTokenSpender(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).approve(spender, amount);\n    }\n\n    function setUseLayerZeroToken(bool enable) external onlyOwner {\n        useLayerZeroToken = enable;\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        layerZeroEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // generic config for user Application\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint256 _configType,\n        bytes calldata _config\n    ) external override onlyOwner {\n        layerZeroEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 version) external override onlyOwner {\n        layerZeroEndpoint.setSendVersion(version);\n    }\n\n    function setReceiveVersion(uint16 version) external override onlyOwner {\n        layerZeroEndpoint.setReceiveVersion(version);\n    }\n\n    //---------------------------------------------------------------------------\n    // INTERNAL functions\n    function txParamBuilderType1(uint256 _gasAmount) internal pure returns (bytes memory) {\n        uint16 txType = 1;\n        return abi.encodePacked(txType, _gasAmount);\n    }\n\n    function txParamBuilderType2(\n        uint256 _gasAmount,\n        uint256 _dstNativeAmount,\n        bytes memory _dstNativeAddr\n    ) internal pure returns (bytes memory) {\n        uint16 txType = 2;\n        return abi.encodePacked(txType, _gasAmount, _dstNativeAmount, _dstNativeAddr);\n    }\n\n    function _txParamBuilder(\n        uint16 _chainId,\n        uint8 _type,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) internal view returns (bytes memory) {\n        bytes memory lzTxParam;\n        address dstNativeAddr;\n        {\n            bytes memory dstNativeAddrBytes = _lzTxParams.dstNativeAddr;\n            assembly {\n                dstNativeAddr := mload(add(dstNativeAddrBytes, 20))\n            }\n        }\n\n        uint256 totalGas = gasLookup[_chainId][_type].add(_lzTxParams.dstGasForCall);\n        if (_lzTxParams.dstNativeAmount > 0 && dstNativeAddr != address(0x0)) {\n            lzTxParam = txParamBuilderType2(totalGas, _lzTxParams.dstNativeAmount, _lzTxParams.dstNativeAddr);\n        } else {\n            lzTxParam = txParamBuilderType1(totalGas);\n        }\n\n        return lzTxParam;\n    }\n\n    function _call(\n        uint16 _chainId,\n        uint8 _type,\n        address payable _refundAddress,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes memory _payload\n    ) internal {\n        bytes memory lzTxParamBuilt = _txParamBuilder(_chainId, _type, _lzTxParams);\n        uint64 nextNonce = layerZeroEndpoint.getOutboundNonce(_chainId, address(this)) + 1;\n        layerZeroEndpoint.send{value: msg.value}(_chainId, bridgeLookup[_chainId], _payload, _refundAddress, address(this), lzTxParamBuilt);\n        emit SendMsg(_type, nextNonce);\n    }\n\n    function renounceOwnership() public override onlyOwner {}\n}"
    },
    {
      "filename": "contracts/Router.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\n// imports\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./Factory.sol\";\nimport \"./Pool.sol\";\nimport \"./Bridge.sol\";\n\n// interfaces\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IStargateRouter.sol\";\nimport \"./interfaces/IStargateReceiver.sol\";\n\n// libraries\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Router is IStargateRouter, Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //---------------------------------------------------------------------------\n    // CONSTANTS\n    uint8 internal constant TYPE_REDEEM_LOCAL_RESPONSE = 1;\n    uint8 internal constant TYPE_REDEEM_LOCAL_CALLBACK_RETRY = 2;\n    uint8 internal constant TYPE_SWAP_REMOTE_RETRY = 3;\n\n    //---------------------------------------------------------------------------\n    // STRUCTS\n    struct CachedSwap {\n        address token;\n        uint256 amountLD;\n        address to;\n        bytes payload;\n    }\n\n    //---------------------------------------------------------------------------\n    // VARIABLES\n    Factory public factory; // used for creating pools\n    address public protocolFeeOwner; // can call methods to pull Stargate fees collected in pools\n    address public mintFeeOwner; // can call methods to pull mint fees collected in pools\n    Bridge public bridge;\n    mapping(uint16 => mapping(bytes => mapping(uint256 => bytes))) public revertLookup; //[chainId][srcAddress][nonce]\n    mapping(uint16 => mapping(bytes => mapping(uint256 => CachedSwap))) public cachedSwapLookup; //[chainId][srcAddress][nonce]\n\n    //---------------------------------------------------------------------------\n    // EVENTS\n    event Revert(uint8 bridgeFunctionType, uint16 chainId, bytes srcAddress, uint256 nonce);\n    event CachedSwapSaved(uint16 chainId, bytes srcAddress, uint256 nonce, address token, uint256 amountLD, address to, bytes payload, bytes reason);\n    event RevertRedeemLocal(uint16 srcChainId, uint256 _srcPoolId, uint256 _dstPoolId, bytes to, uint256 redeemAmountSD, uint256 mintAmountSD, uint256 indexed nonce, bytes indexed srcAddress);\n    event RedeemLocalCallback(uint16 srcChainId, bytes indexed srcAddress, uint256 indexed nonce, uint256 srcPoolId, uint256 dstPoolId, address to, uint256 amountSD, uint256 mintAmountSD);\n\n    //---------------------------------------------------------------------------\n    // MODIFIERS\n    modifier onlyBridge() {\n        require(msg.sender == address(bridge), \"Bridge: caller must be Bridge.\");\n        _;\n    }\n\n    constructor() {}\n\n    function setBridgeAndFactory(Bridge _bridge, Factory _factory) external onlyOwner {\n        require(address(bridge) == address(0x0) && address(factory) == address(0x0), \"Stargate: bridge and factory already initialized\"); // 1 time only\n        require(address(_bridge) != address(0x0), \"Stargate: bridge cant be 0x0\");\n        require(address(_factory) != address(0x0), \"Stargate: factory cant be 0x0\");\n\n        bridge = _bridge;\n        factory = _factory;\n    }\n\n    //---------------------------------------------------------------------------\n    // VIEWS\n    function _getPool(uint256 _poolId) internal view returns (Pool pool) {\n        pool = factory.getPool(_poolId);\n        require(address(pool) != address(0x0), \"Stargate: Pool does not exist\");\n    }\n\n    //---------------------------------------------------------------------------\n    // INTERNAL\n    function _safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"Stargate: TRANSFER_FROM_FAILED\");\n    }\n\n    //---------------------------------------------------------------------------\n    // LOCAL CHAIN FUNCTIONS\n    function addLiquidity(\n        uint256 _poolId,\n        uint256 _amountLD,\n        address _to\n    ) external override nonReentrant {\n        Pool pool = _getPool(_poolId);\n        uint256 convertRate = pool.convertRate();\n        _amountLD = _amountLD.div(convertRate).mul(convertRate);\n        _safeTransferFrom(pool.token(), msg.sender, address(pool), _amountLD);\n        pool.mint(_to, _amountLD);\n    }\n\n    function swap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        lzTxObj memory _lzTxParams,\n        bytes calldata _to,\n        bytes calldata _payload\n    ) external payable override nonReentrant {\n        require(_amountLD > 0, \"Stargate: cannot swap 0\");\n        require(_refundAddress != address(0x0), \"Stargate: _refundAddress cannot be 0x0\");\n        Pool.SwapObj memory s;\n        Pool.CreditObj memory c;\n        {\n            Pool pool = _getPool(_srcPoolId);\n            {\n                uint256 convertRate = pool.convertRate();\n                _amountLD = _amountLD.div(convertRate).mul(convertRate);\n            }\n\n            s = pool.swap(_dstChainId, _dstPoolId, msg.sender, _amountLD, _minAmountLD, true);\n            _safeTransferFrom(pool.token(), msg.sender, address(pool), _amountLD);\n            c = pool.sendCredits(_dstChainId, _dstPoolId);\n        }\n        bridge.swap{value: msg.value}(_dstChainId, _srcPoolId, _dstPoolId, _refundAddress, c, s, _lzTxParams, _to, _payload);\n    }\n\n    function redeemRemote(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        uint256 _amountLP,\n        uint256 _minAmountLD,\n        bytes calldata _to,\n        lzTxObj memory _lzTxParams\n    ) external payable override nonReentrant {\n        require(_refundAddress != address(0x0), \"Stargate: _refundAddress cannot be 0x0\");\n        require(_amountLP > 0, \"Stargate: not enough lp to redeemRemote\");\n        Pool.SwapObj memory s;\n        Pool.CreditObj memory c;\n        {\n            Pool pool = _getPool(_srcPoolId);\n            uint256 amountLD = pool.amountLPtoLD(_amountLP);\n            // perform a swap with no liquidity\n            s = pool.swap(_dstChainId, _dstPoolId, msg.sender, amountLD, _minAmountLD, false);\n            pool.redeemRemote(_dstChainId, _dstPoolId, msg.sender, _amountLP);\n            c = pool.sendCredits(_dstChainId, _dstPoolId);\n        }\n        // equal to a swap, with no payload (\"0x\") no dstGasForCall 0\n        bridge.swap{value: msg.value}(_dstChainId, _srcPoolId, _dstPoolId, _refundAddress, c, s, _lzTxParams, _to, \"\");\n    }\n\n    function instantRedeemLocal(\n        uint16 _srcPoolId,\n        uint256 _amountLP,\n        address _to\n    ) external override nonReentrant returns (uint256 amountSD) {\n        require(_amountLP > 0, \"Stargate: not enough lp to redeem\");\n        Pool pool = _getPool(_srcPoolId);\n        amountSD = pool.instantRedeemLocal(msg.sender, _amountLP, _to);\n    }\n\n    function redeemLocal(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        uint256 _amountLP,\n        bytes calldata _to,\n        lzTxObj memory _lzTxParams\n    ) external payable override nonReentrant {\n        require(_refundAddress != address(0x0), \"Stargate: _refundAddress cannot be 0x0\");\n        Pool pool = _getPool(_srcPoolId);\n        require(_amountLP > 0, \"Stargate: not enough lp to redeem\");\n        uint256 amountSD = pool.redeemLocal(msg.sender, _amountLP, _dstChainId, _dstPoolId, _to);\n        require(amountSD > 0, \"Stargate: not enough lp to redeem with amountSD\");\n\n        Pool.CreditObj memory c = pool.sendCredits(_dstChainId, _dstPoolId);\n        bridge.redeemLocal{value: msg.value}(_dstChainId, _srcPoolId, _dstPoolId, _refundAddress, c, amountSD, _to, _lzTxParams);\n    }\n\n    function sendCredits(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress\n    ) external payable override nonReentrant {\n        require(_refundAddress != address(0x0), \"Stargate: _refundAddress cannot be 0x0\");\n        Pool pool = _getPool(_srcPoolId);\n        Pool.CreditObj memory c = pool.sendCredits(_dstChainId, _dstPoolId);\n        bridge.sendCredits{value: msg.value}(_dstChainId, _srcPoolId, _dstPoolId, _refundAddress, c);\n    }\n\n    function quoteLayerZeroFee(\n        uint16 _dstChainId,\n        uint8 _functionType,\n        bytes calldata _toAddress,\n        bytes calldata _transferAndCallPayload,\n        Router.lzTxObj memory _lzTxParams\n    ) external view override returns (uint256, uint256) {\n        return bridge.quoteLayerZeroFee(_dstChainId, _functionType, _toAddress, _transferAndCallPayload, _lzTxParams);\n    }\n\n    function revertRedeemLocal(\n        uint16 _dstChainId,\n        bytes calldata _srcAddress,\n        uint256 _nonce,\n        address payable _refundAddress,\n        lzTxObj memory _lzTxParams\n    ) external payable {\n        require(_refundAddress != address(0x0), \"Stargate: _refundAddress cannot be 0x0\");\n        bytes memory payload = revertLookup[_dstChainId][_srcAddress][_nonce];\n        require(payload.length > 0, \"Stargate: no retry revert\");\n        {\n            uint8 functionType;\n            assembly {\n                functionType := mload(add(payload, 32))\n            }\n            require(functionType == TYPE_REDEEM_LOCAL_RESPONSE, \"Stargate: invalid function type\");\n        }\n\n        // empty it\n        revertLookup[_dstChainId][_srcAddress][_nonce] = \"\";\n\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        assembly {\n            srcPoolId := mload(add(payload, 64))\n            dstPoolId := mload(add(payload, 96))\n        }\n\n        Pool.CreditObj memory c;\n        {\n            Pool pool = _getPool(dstPoolId);\n            c = pool.sendCredits(_dstChainId, srcPoolId);\n        }\n\n        bridge.redeemLocalCallback{value: msg.value}(_dstChainId, _refundAddress, c, _lzTxParams, payload);\n    }\n\n    function retryRevert(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint256 _nonce\n    ) external payable {\n        bytes memory payload = revertLookup[_srcChainId][_srcAddress][_nonce];\n        require(payload.length > 0, \"Stargate: no retry revert\");\n\n        // empty it\n        revertLookup[_srcChainId][_srcAddress][_nonce] = \"\";\n\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(payload, 32))\n        }\n\n        if (functionType == TYPE_REDEEM_LOCAL_CALLBACK_RETRY) {\n            (, uint256 srcPoolId, uint256 dstPoolId, address to, uint256 amountSD, uint256 mintAmountSD) = abi.decode(\n                payload,\n                (uint8, uint256, uint256, address, uint256, uint256)\n            );\n            _redeemLocalCallback(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, to, amountSD, mintAmountSD);\n        }\n        // for retrying the swapRemote. if it fails again, retry\n        else if (functionType == TYPE_SWAP_REMOTE_RETRY) {\n            (, uint256 srcPoolId, uint256 dstPoolId, uint256 dstGasForCall, address to, Pool.SwapObj memory s, bytes memory p) = abi.decode(\n                payload,\n                (uint8, uint256, uint256, uint256, address, Pool.SwapObj, bytes)\n            );\n            _swapRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, dstGasForCall, to, s, p);\n        } else {\n            revert(\"Stargate: invalid function type\");\n        }\n    }\n\n    function clearCachedSwap(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint256 _nonce\n    ) external {\n        CachedSwap memory cs = cachedSwapLookup[_srcChainId][_srcAddress][_nonce];\n        require(cs.to != address(0x0), \"Stargate: cache already cleared\");\n        // clear the data\n        cachedSwapLookup[_srcChainId][_srcAddress][_nonce] = CachedSwap(address(0x0), 0, address(0x0), \"\");\n        IStargateReceiver(cs.to).sgReceive(_srcChainId, _srcAddress, _nonce, cs.token, cs.amountLD, cs.payload);\n    }\n\n    function creditChainPath(\n        uint16 _dstChainId,\n        uint256 _dstPoolId,\n        uint256 _srcPoolId,\n        Pool.CreditObj memory _c\n    ) external onlyBridge {\n        Pool pool = _getPool(_srcPoolId);\n        pool.creditChainPath(_dstChainId, _dstPoolId, _c);\n    }\n\n    //---------------------------------------------------------------------------\n    // REMOTE CHAIN FUNCTIONS\n    function redeemLocalCheckOnRemote(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint256 _nonce,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _amountSD,\n        bytes calldata _to\n    ) external onlyBridge {\n        Pool pool = _getPool(_dstPoolId);\n        try pool.redeemLocalCheckOnRemote(_srcChainId, _srcPoolId, _amountSD) returns (uint256 redeemAmountSD, uint256 mintAmountSD) {\n            revertLookup[_srcChainId][_srcAddress][_nonce] = abi.encode(\n                TYPE_REDEEM_LOCAL_RESPONSE,\n                _srcPoolId,\n                _dstPoolId,\n                redeemAmountSD,\n                mintAmountSD,\n                _to\n            );\n            emit RevertRedeemLocal(_srcChainId, _srcPoolId, _dstPoolId, _to, redeemAmountSD, mintAmountSD, _nonce, _srcAddress);\n        } catch {\n            // if the func fail, return [swapAmount: 0, mintAMount: _amountSD]\n            // swapAmount represents the amount of chainPath balance deducted on the remote side, which because the above tx failed, should be 0\n            // mintAmount is the full amount of tokens the user attempted to redeem on the src side, which gets converted back into the lp amount\n            revertLookup[_srcChainId][_srcAddress][_nonce] = abi.encode(TYPE_REDEEM_LOCAL_RESPONSE, _srcPoolId, _dstPoolId, 0, _amountSD, _to);\n            emit Revert(TYPE_REDEEM_LOCAL_RESPONSE, _srcChainId, _srcAddress, _nonce);\n        }\n    }\n\n    function redeemLocalCallback(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint256 _nonce,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address _to,\n        uint256 _amountSD,\n        uint256 _mintAmountSD\n    ) external onlyBridge {\n        _redeemLocalCallback(_srcChainId, _srcAddress, _nonce, _srcPoolId, _dstPoolId, _to, _amountSD, _mintAmountSD);\n    }\n\n    function _redeemLocalCallback(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint256 _nonce,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address _to,\n        uint256 _amountSD,\n        uint256 _mintAmountSD\n    ) internal {\n        Pool pool = _getPool(_dstPoolId);\n        try pool.redeemLocalCallback(_srcChainId, _srcPoolId, _to, _amountSD, _mintAmountSD) {} catch {\n            revertLookup[_srcChainId][_srcAddress][_nonce] = abi.encode(\n                TYPE_REDEEM_LOCAL_CALLBACK_RETRY,\n                _srcPoolId,\n                _dstPoolId,\n                _to,\n                _amountSD,\n                _mintAmountSD\n            );\n            emit Revert(TYPE_REDEEM_LOCAL_CALLBACK_RETRY, _srcChainId, _srcAddress, _nonce);\n        }\n        emit RedeemLocalCallback(_srcChainId, _srcAddress, _nonce, _srcPoolId, _dstPoolId, _to, _amountSD, _mintAmountSD);\n    }\n\n    function swapRemote(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint256 _nonce,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _dstGasForCall,\n        address _to,\n        Pool.SwapObj memory _s,\n        bytes memory _payload\n    ) external onlyBridge {\n        _swapRemote(_srcChainId, _srcAddress, _nonce, _srcPoolId, _dstPoolId, _dstGasForCall, _to, _s, _payload);\n    }\n\n    function _swapRemote(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint256 _nonce,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _dstGasForCall,\n        address _to,\n        Pool.SwapObj memory _s,\n        bytes memory _payload\n    ) internal {\n        Pool pool = _getPool(_dstPoolId);\n        // first try catch the swap remote\n        try pool.swapRemote(_srcChainId, _srcPoolId, _to, _s) returns (uint256 amountLD) {\n            if (_payload.length > 0) {\n                // then try catch the external contract call\n                try IStargateReceiver(_to).sgReceive{gas: _dstGasForCall}(_srcChainId, _srcAddress, _nonce, pool.token(), amountLD, _payload) {\n                    // do nothing\n                } catch (bytes memory reason) {\n                    cachedSwapLookup[_srcChainId][_srcAddress][_nonce] = CachedSwap(pool.token(), amountLD, _to, _payload);\n                    emit CachedSwapSaved(_srcChainId, _srcAddress, _nonce, pool.token(), amountLD, _to, _payload, reason);\n                }\n            }\n        } catch {\n            revertLookup[_srcChainId][_srcAddress][_nonce] = abi.encode(\n                TYPE_SWAP_REMOTE_RETRY,\n                _srcPoolId,\n                _dstPoolId,\n                _dstGasForCall,\n                _to,\n                _s,\n                _payload\n            );\n            emit Revert(TYPE_SWAP_REMOTE_RETRY, _srcChainId, _srcAddress, _nonce);\n        }\n    }\n\n    //---------------------------------------------------------------------------\n    // DAO Calls\n    function createPool(\n        uint256 _poolId,\n        address _token,\n        uint8 _sharedDecimals,\n        uint8 _localDecimals,\n        string memory _name,\n        string memory _symbol\n    ) external onlyOwner returns (address) {\n        require(_token != address(0x0), \"Stargate: _token cannot be 0x0\");\n        return factory.createPool(_poolId, _token, _sharedDecimals, _localDecimals, _name, _symbol);\n    }\n\n    function createChainPath(\n        uint256 _poolId,\n        uint16 _dstChainId,\n        uint256 _dstPoolId,\n        uint256 _weight\n    ) external onlyOwner {\n        Pool pool = _getPool(_poolId);\n        pool.createChainPath(_dstChainId, _dstPoolId, _weight);\n    }\n\n    function activateChainPath(\n        uint256 _poolId,\n        uint16 _dstChainId,\n        uint256 _dstPoolId\n    ) external onlyOwner {\n        Pool pool = _getPool(_poolId);\n        pool.activateChainPath(_dstChainId, _dstPoolId);\n    }\n\n    function setWeightForChainPath(\n        uint256 _poolId,\n        uint16 _dstChainId,\n        uint256 _dstPoolId,\n        uint16 _weight\n    ) external onlyOwner {\n        Pool pool = _getPool(_poolId);\n        pool.setWeightForChainPath(_dstChainId, _dstPoolId, _weight);\n    }\n\n    function setProtocolFeeOwner(address _owner) external onlyOwner {\n        require(_owner != address(0x0), \"Stargate: _owner cannot be 0x0\");\n        protocolFeeOwner = _owner;\n    }\n\n    function setMintFeeOwner(address _owner) external onlyOwner {\n        require(_owner != address(0x0), \"Stargate: _owner cannot be 0x0\");\n        mintFeeOwner = _owner;\n    }\n\n    function setFees(uint256 _poolId, uint256 _mintFeeBP) external onlyOwner {\n        Pool pool = _getPool(_poolId);\n        pool.setFee(_mintFeeBP);\n    }\n\n    function setFeeLibrary(uint256 _poolId, address _feeLibraryAddr) external onlyOwner {\n        Pool pool = _getPool(_poolId);\n        pool.setFeeLibrary(_feeLibraryAddr);\n    }\n\n    function setSwapStop(uint256 _poolId, bool _swapStop) external onlyOwner {\n        Pool pool = _getPool(_poolId);\n        pool.setSwapStop(_swapStop);\n    }\n\n    function setDeltaParam(\n        uint256 _poolId,\n        bool _batched,\n        uint256 _swapDeltaBP,\n        uint256 _lpDeltaBP,\n        bool _defaultSwapMode,\n        bool _defaultLPMode\n    ) external onlyOwner {\n        Pool pool = _getPool(_poolId);\n        pool.setDeltaParam(_batched, _swapDeltaBP, _lpDeltaBP, _defaultSwapMode, _defaultLPMode);\n    }\n\n    function callDelta(uint256 _poolId, bool _fullMode) external {\n        Pool pool = _getPool(_poolId);\n        pool.callDelta(_fullMode);\n    }\n\n    function withdrawMintFee(uint256 _poolId, address _to) external {\n        require(mintFeeOwner == msg.sender, \"Star"
    }
  ]
}