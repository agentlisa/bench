{
  "Title": "[M-35] Removing a `UniswapV3Gauge` via `UniswapV3GaugeFactory` does not actually remove it from the `UniswapV3Staker`. The gauge still gains rewards and can be staked too (even though deprecated). Plus old stakers can game the rewards of new stakers",
  "Content": "\nGauge factories have a [`BaseV2GaugeFactory::removeGauge`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L130-L137) that removes the indicated gauge and marks it as deprecated for the corresponding [`bHermesGauges` and `bHermesBoost`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeManager.sol#L100-L103) token contracts.\n\nHowever, removing a `UniswapV3Gauge` with `UniswapV3GaugeFactory` does not actually remove it from the `UniswapV3Staker`. The gauge still remains and existing users that staked can still gain the exact same benefits from it.\n\nWhat is worse, is that staking to the gauge can still happen. Any new users that stake cannot receive a share of the generated fees (plus boost), as it is impossible to vote for the deprecated gauge.\n\n### Issue detailed explanation\n\nWhen a `UniswapV3Gauge` is created via `UniswapV3GaugeFactory`, it is also attached to a `UniswapV3Staker` via the [`BaseV2GaugeFactory::afterCreateGauge`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L122-L125) callback [implementation](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/UniswapV3GaugeFactory.sol#L87-L91):\n\n```Solidity\n    /// @notice Adds Gauge to UniswapV3Staker\n    /// @dev Updates the UniswapV3 staker with bribe and minimum width information\n    function afterCreateGauge(address strategy, bytes memory) internal override {\n        uniswapV3Staker.updateGauges(IUniswapV3Pool(strategy));\n    }\n```\n\nHowever, there is no `afterCreateRemoved` mechanism implemented in `BaseV2GaugeFactory`. As such, the `UniswapV3Staker` contract is never updated about the removed gauge. This creates a situation in which existing users/stakes benefit while new stakes lose out on bribes, gaming the system.\n\nThis is because:\n\n- New users can stake to the deprecated gauge, as there is no mechanism to check if the gauge they are staking to is active or not (similar to how [`UniswapV3Staker::updateGauges` checks](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/uni-v3-staker/UniswapV3Staker.sol#L526-L529)).\n\n```Solidity\n    function updateGauges(IUniswapV3Pool uniswapV3Pool) external {\n        address uniswapV3Gauge = address(uniswapV3GaugeFactory.strategyGauges(address(uniswapV3Pool)));\n\n\n        if (uniswapV3Gauge == address(0)) revert InvalidGauge();\n```\n\n- **But** new users that stake to the deprecated gauge do not receive a portion of fees that are generated and sent to the bribe deposit. Although, users that have staked to the *now* deprecated gauge **beforehand** still gain the fees generated by the staked positions.\n\nThis happens because when gauge removal happens in [BaseV2GaugeManager::removeGauge](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeManager.sol#L100-L103), the indicated gauge is marked as deprecated ([bHermesGauges::ERC20Gauges::\\_removeGauge](https://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20Gauges.sol#L435)). Users that have already voted to the deprecated gauge still get the bribe rewards when `BaseV2Gauge::accrueBribes` is called.\n\nRewards flows is:\n\n- [BaseV2Gauge::accrueBribes](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/BaseV2Gauge.sol#L111-L121)\n    - [FlywheelCore::accrue](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/base/FlywheelCore.sol#L69-L72)\n        - [FlywheelCore::\\_accrue](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/base/FlywheelCore.sol#L74-L81)\n            - [FlywheelCore::accrueUser](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/base/FlywheelCore.sol#L196-L198) (which influences reward calculation)\n                - [FlywheelBoosterGaugeWeight::boostedBalanceOf](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/booster/FlywheelBoosterGaugeWeight.sol#L58-L61)\n                    - [bHermesGauges::ERC20Gauges::getUserGaugeWeight](https://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/interfaces/IERC20Gauges.sol#L62-L65)\n                        - And `ERC20Gauges::getUserGaugeWeight` is only [increasable if the gauge is not deprecated](https://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20Gauges.sol#L203)\n\nTo be noted, the action of *unstaking* (calling [UniswapV3Staker::\\_unstakeToken](https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L377-L390)) sends rewards to the gauge bribe deposit:\n\n```Solidity\n            // scope for bribeAddress, avoids stack too deep errors\n            address bribeAddress = bribeDepots[key.pool];\n\n\n            if (bribeAddress != address(0)) {\n                nonfungiblePositionManager.collect(\n                    INonfungiblePositionManager.CollectParams({\n                        tokenId: tokenId,\n                        recipient: bribeAddress,\n                        amount0Max: type(uint128).max,\n                        amount1Max: type(uint128).max\n                    })\n                );\n            }\n        }\n```\n\nFrom there, it is then transferred to those that already delegated to the (now deprecated) gauge, following the already mentioned execution flow.\n\nNote, that deprecated gauges [still have the boosting bonus associated with `bHermesBoost`](https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L401-L424), where the same issue as above appears; already existing users get the boost and new users cannot.\n\n```Solidity\n        // ...\n        \n        // get boost amount and total supply\n        (boostAmount, boostTotalSupply) = hermesGaugeBoost.getUserGaugeBoost(owner, address(gauge));\n        \n        // ...\n\n        secondsInsideX128 = RewardMath.computeBoostedSecondsInsideX128(\n            // ...\n            uint128(boostAmount),\n            uint128(boostTotalSupply),\n            // ...\n\n        );\n\n        // ...\n\n        uint256 reward = RewardMath.computeBoostedRewardAmount(\n            // ...\n            secondsInsideX128,\n            // ...\n        );\n\n        }\n```\n\n### Proof of Concept\n\nA step by step execution flow was shown above.\n\nThe lack of active gauge check can be observed in any of the staking flow functions:\n\n- [restakeToken](https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L340-L348)\n- [stakeToken](https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L465-L473)\n- [\\_stakeToken](https://github.com/code-423n4/2023-05-maia/blob/main/src/uni-v3-staker/UniswapV3Staker.sol#L475-L519) (called by the above 2)\n\nAlso, there is no [`BaseV2GaugeFactory::afterCreateRemoved`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeFactory.sol#L125-L137) type of `callback` existing.\n\nA theoretical POC would be as:\n\n- A `UniswapV3Gauge` is created via `UniswapV3GaugeFactory` (it is also automatically attached to the existing `UniswapV3Staker`).\n- Users vote for it via `bHermesGauges`.\n- A team decided to remove the existing `UniswapV3Gauge` for a newer version.\n- A team calls `BaseV2GaugeFactory::removeGauge` that does not remove the gauge from the `UniswapV3Staker`, while also deprecating it in `bHermesGauges`.\n- The now deprecated and faulty removed `UniswapV3Gauge` still receives fees from the `UniswapV3Staker`.\n- New users stake to the removed `UniswapV3Gauge`, but will not receive any bribe rewards; creating a situation where the first depositors gain the later ones.\n\n### Tools Used\n\n**The most important factor**: a very good, active and helping project team!\n\n### Recommended Mitigation Steps\n\nAs the system is complex, we must take into consideration a few observations:\n\n- We cannot remove the gauge from `UniswapV3Staker` because already existing incentives would become bricked and worthless.\n- Removing a gauge completely from the `UniswapV3Staker` means losing potential rewards deposited by users.\n    - A `UniswapV3Staker` without the `bHermesGauges` mechanism is similar to a normal `UniswapV3Staker`, so it does still work has some incentive.\n- Leaving the gauge open to be staked and added incentives would allow old stakers to prey on new stakes and new stakers will not receive any fees generated by the staked positions.\n- Refunding potential emissions (rewards) deposited by users (or protocols) adds storage overhead.\n- A `BaseV2GaugeFactory::afterCreateRemoved` mechanism is required regardless for any future gauge that needs post-remove operations.\n- Deprecated gauges still have the boosting bonus associated with `bHermesBoost`, where the same issue as above appears; already existing users get the boost and new users cannot.\n\nA possible solution can be a mix of the above:\n\n1. Create a `BaseV2GaugeFactory::afterCreateRemoved` mechanism.\n2. Add a function `UniswapV3GaugeFactory::afterCreateRemoved` that overrides the above that calls `UniswapV3Staker::updateBribeDepot`.\n3. In `UniswapV3Staker::updateBribeDepot` check if the strategy associated with the `IUniswapV3Pool` is active and if not, then set the bribeDepot (`bribeDepots[uniswapV3Pool]`) of that pool's gauge to the zero address so that no new rewards are sent to the deprecated gauge.\n\nThe above is a minimum suggested regardless. \n\nExtra:\n\n4. Add a check for `UniswapV3Staker::_stakeToken` if the gauge is active or not and revert; i.e. do not allow any further staking into inactive gauges.\n5. Consider decreasing the gain value of `bHermesBoost` if the gauge is deprecated in `_unstakeToken`. Some more consideration should be taken if implementing this, as any reward bonuses that were not collected before the removal/deprecation will also be lost (that in itself is an issue that must not happen).\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/277#issuecomment-1632759940)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/277#issuecomment-1709221247):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/277).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/gauges/factories/BaseV2GaugeFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\nimport {BaseV2Gauge} from \"@gauges/BaseV2Gauge.sol\";\n\nimport {BribesFactory} from \"./BribesFactory.sol\";\nimport {BaseV2GaugeManager} from \"./BaseV2GaugeManager.sol\";\n\nimport {IBaseV2GaugeFactory} from \"../interfaces/IBaseV2GaugeFactory.sol\";\n\n/// @title Base V2 Gauge Factory\nabstract contract BaseV2GaugeFactory is Ownable, IBaseV2GaugeFactory {\n    /*///////////////////////////////////////////////////////////////\n                            FACTORY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BaseV2GaugeManager public immutable override gaugeManager;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    bHermesBoost public immutable override bHermesBoostToken;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BribesFactory public immutable override bribesFactory;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BaseV2Gauge[] public override gauges;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(BaseV2Gauge => uint256) public override gaugeIds;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(BaseV2Gauge => bool) public override activeGauges;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(address => BaseV2Gauge) public override strategyGauges;\n\n    /**\n     * @notice Creates a new gauge factory\n     * @param _gaugeManager The gauge manager to use\n     * @param _bHermesBoost The bHermes boost token to use\n     * @param _bribesFactory The bribes factory to use\n     * @param _owner The owner of the factory\n     */\n    constructor(\n        BaseV2GaugeManager _gaugeManager,\n        bHermesBoost _bHermesBoost,\n        BribesFactory _bribesFactory,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        bribesFactory = _bribesFactory;\n        bHermesBoostToken = _bHermesBoost;\n        gaugeManager = _gaugeManager;\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function getGauges() external view returns (BaseV2Gauge[] memory) {\n        return gauges;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         EPOCH LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function newEpoch() external {\n        BaseV2Gauge[] storage _gauges = gauges;\n\n        uint256 length = _gauges.length;\n        for (uint256 i = 0; i < length;) {\n            if (activeGauges[_gauges[i]]) _gauges[i].newEpoch();\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function newEpoch(uint256 start, uint256 end) external {\n        BaseV2Gauge[] storage _gauges = gauges;\n\n        uint256 length = _gauges.length;\n        if (end > length) end = length;\n\n        for (uint256 i = start; i < end;) {\n            if (activeGauges[_gauges[i]]) _gauges[i].newEpoch();\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         GAUGE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a new gauge for the given strategy\n    /// @param strategy The strategy address to create a gauge for\n    /// @param data The information to pass to create a new gauge.\n    function createGauge(address strategy, bytes memory data) external onlyOwner {\n        if (address(strategyGauges[strategy]) != address(0)) revert GaugeAlreadyExists();\n\n        BaseV2Gauge gauge = newGauge(strategy, data);\n        strategyGauges[strategy] = gauge;\n\n        uint256 id = gauges.length;\n        gauges.push(gauge);\n        gaugeIds[gauge] = id;\n        activeGauges[gauge] = true;\n\n        gaugeManager.addGauge(address(gauge));\n\n        afterCreateGauge(strategy, data);\n    }\n\n    function afterCreateGauge(address strategy, bytes memory data) internal virtual;\n\n    function newGauge(address strategy, bytes memory data) internal virtual returns (BaseV2Gauge gauge);\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function removeGauge(BaseV2Gauge gauge) external onlyOwner {\n        if (!activeGauges[gauge] || gauges[gaugeIds[gauge]] != gauge) revert InvalidGauge();\n        delete gauges[gaugeIds[gauge]];\n        delete gaugeIds[gauge];\n        delete activeGauges[gauge];\n        delete strategyGauges[gauge.strategy()];\n        gaugeManager.removeGauge(address(gauge));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           BRIBE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function addBribeToGauge(BaseV2Gauge gauge, address bribeToken) external onlyOwnerOrBribesFactoryOwner {\n        if (!activeGauges[gauge]) revert InvalidGauge();\n        gauge.addBribeFlywheel(bribesFactory.flywheelTokens(bribeToken));\n        bribesFactory.addGaugetoFlywheel(address(gauge), bribeToken);\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function removeBribeFromGauge(BaseV2Gauge gauge, address bribeToken) external onlyOwnerOrBribesFactoryOwner {\n        if (!activeGauges[gauge]) revert InvalidGauge();\n        gauge.removeBribeFlywheel(bribesFactory.flywheelTokens(bribeToken));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyOwnerOrBribesFactoryOwner() {\n        if (msg.sender != bribesFactory.owner() && msg.sender != owner()) {\n            revert NotOwnerOrBribesFactoryOwner();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/gauges/factories/BaseV2GaugeFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\nimport {BaseV2Gauge} from \"@gauges/BaseV2Gauge.sol\";\n\nimport {BribesFactory} from \"./BribesFactory.sol\";\nimport {BaseV2GaugeManager} from \"./BaseV2GaugeManager.sol\";\n\nimport {IBaseV2GaugeFactory} from \"../interfaces/IBaseV2GaugeFactory.sol\";\n\n/// @title Base V2 Gauge Factory\nabstract contract BaseV2GaugeFactory is Ownable, IBaseV2GaugeFactory {\n    /*///////////////////////////////////////////////////////////////\n                            FACTORY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BaseV2GaugeManager public immutable override gaugeManager;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    bHermesBoost public immutable override bHermesBoostToken;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BribesFactory public immutable override bribesFactory;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    BaseV2Gauge[] public override gauges;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(BaseV2Gauge => uint256) public override gaugeIds;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(BaseV2Gauge => bool) public override activeGauges;\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    mapping(address => BaseV2Gauge) public override strategyGauges;\n\n    /**\n     * @notice Creates a new gauge factory\n     * @param _gaugeManager The gauge manager to use\n     * @param _bHermesBoost The bHermes boost token to use\n     * @param _bribesFactory The bribes factory to use\n     * @param _owner The owner of the factory\n     */\n    constructor(\n        BaseV2GaugeManager _gaugeManager,\n        bHermesBoost _bHermesBoost,\n        BribesFactory _bribesFactory,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        bribesFactory = _bribesFactory;\n        bHermesBoostToken = _bHermesBoost;\n        gaugeManager = _gaugeManager;\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function getGauges() external view returns (BaseV2Gauge[] memory) {\n        return gauges;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         EPOCH LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function newEpoch() external {\n        BaseV2Gauge[] storage _gauges = gauges;\n\n        uint256 length = _gauges.length;\n        for (uint256 i = 0; i < length;) {\n            if (activeGauges[_gauges[i]]) _gauges[i].newEpoch();\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function newEpoch(uint256 start, uint256 end) external {\n        BaseV2Gauge[] storage _gauges = gauges;\n\n        uint256 length = _gauges.length;\n        if (end > length) end = length;\n\n        for (uint256 i = start; i < end;) {\n            if (activeGauges[_gauges[i]]) _gauges[i].newEpoch();\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         GAUGE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a new gauge for the given strategy\n    /// @param strategy The strategy address to create a gauge for\n    /// @param data The information to pass to create a new gauge.\n    function createGauge(address strategy, bytes memory data) external onlyOwner {\n        if (address(strategyGauges[strategy]) != address(0)) revert GaugeAlreadyExists();\n\n        BaseV2Gauge gauge = newGauge(strategy, data);\n        strategyGauges[strategy] = gauge;\n\n        uint256 id = gauges.length;\n        gauges.push(gauge);\n        gaugeIds[gauge] = id;\n        activeGauges[gauge] = true;\n\n        gaugeManager.addGauge(address(gauge));\n\n        afterCreateGauge(strategy, data);\n    }\n\n    function afterCreateGauge(address strategy, bytes memory data) internal virtual;\n\n    function newGauge(address strategy, bytes memory data) internal virtual returns (BaseV2Gauge gauge);\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function removeGauge(BaseV2Gauge gauge) external onlyOwner {\n        if (!activeGauges[gauge] || gauges[gaugeIds[gauge]] != gauge) revert InvalidGauge();\n        delete gauges[gaugeIds[gauge]];\n        delete gaugeIds[gauge];\n        delete activeGauges[gauge];\n        delete strategyGauges[gauge.strategy()];\n        gaugeManager.removeGauge(address(gauge));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           BRIBE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function addBribeToGauge(BaseV2Gauge gauge, address bribeToken) external onlyOwnerOrBribesFactoryOwner {\n        if (!activeGauges[gauge]) revert InvalidGauge();\n        gauge.addBribeFlywheel(bribesFactory.flywheelTokens(bribeToken));\n        bribesFactory.addGaugetoFlywheel(address(gauge), bribeToken);\n    }\n\n    /// @inheritdoc IBaseV2GaugeFactory\n    function removeBribeFromGauge(BaseV2Gauge gauge, address bribeToken) external onlyOwnerOrBribesFactoryOwner {\n        if (!activeGauges[gauge]) revert InvalidGauge();\n        gauge.removeBribeFlywheel(bribesFactory.flywheelTokens(bribeToken));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyOwnerOrBribesFactoryOwner() {\n        if (msg.sender != bribesFactory.owner() && msg.sender != owner()) {\n            revert NotOwnerOrBribesFactoryOwner();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/uni-v3-staker/UniswapV3Staker.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by Uniswap V3 Contracts (Uniswap/v3-staker/contracts/UniswapV3Staker.sol)\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {Multicallable} from \"solady/utils/Multicallable.sol\";\n\nimport {IUniswapV3Factory} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IUniswapV3GaugeFactory} from \"@gauges/interfaces/IUniswapV3GaugeFactory.sol\";\nimport {UniswapV3Gauge} from \"@gauges/UniswapV3Gauge.sol\";\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\n\nimport {IncentiveId} from \"./libraries/IncentiveId.sol\";\nimport {IncentiveTime} from \"./libraries/IncentiveTime.sol\";\nimport {NFTPositionInfo} from \"./libraries/NFTPositionInfo.sol\";\nimport {RewardMath} from \"./libraries/RewardMath.sol\";\n\nimport {IUniswapV3Staker} from \"./interfaces/IUniswapV3Staker.sol\";\n\n/// @title Uniswap V3 Staker Interface with bHermes Boost.\ncontract UniswapV3Staker is IUniswapV3Staker, Multicallable {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                        UNISWAP V3 STAKER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(address => IUniswapV3Pool) public gaugePool;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(IUniswapV3Pool => UniswapV3Gauge) public gauges;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(IUniswapV3Pool => address) public bribeDepots;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(IUniswapV3Pool => uint24) public poolsMinimumWidth;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(bytes32 => Incentive) public override incentives;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(uint256 => Deposit) public override deposits;\n\n    /// @notice stakes[user][pool] => tokenId of attached position of user per pool\n    mapping(address => mapping(IUniswapV3Pool => uint256)) private _userAttachements;\n\n    /// @dev stakes[tokenId][incentiveHash] => Stake\n    mapping(uint256 => mapping(bytes32 => Stake)) private _stakes;\n\n    /// @dev stakedIncentives[tokenId] => incentiveIds\n    mapping(uint256 => IncentiveKey) private stakedIncentiveKey;\n\n    /// @inheritdoc IUniswapV3Staker\n    function stakes(uint256 tokenId, bytes32 incentiveId)\n        public\n        view\n        override\n        returns (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity)\n    {\n        Stake storage stake = _stakes[tokenId][incentiveId];\n        secondsPerLiquidityInsideInitialX128 = stake.secondsPerLiquidityInsideInitialX128;\n        liquidity = stake.liquidityNoOverflow;\n        if (liquidity == type(uint96).max) {\n            liquidity = stake.liquidityIfOverflow;\n        }\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function userAttachements(address user, IUniswapV3Pool pool) external view override returns (uint256) {\n        return hermesGaugeBoost.isUserGauge(user, address(gauges[pool])) ? _userAttachements[user][pool] : 0;\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(address => uint256) public override rewards;\n\n    /// @inheritdoc IUniswapV3Staker\n    mapping(uint256 => uint256) public tokenIdRewards;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Uniswap V3 Gauge Factory\n    IUniswapV3GaugeFactory public immutable uniswapV3GaugeFactory;\n\n    /// @inheritdoc IUniswapV3Staker\n    IUniswapV3Factory public immutable override factory;\n\n    /// @inheritdoc IUniswapV3Staker\n    INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n    /// @inheritdoc IUniswapV3Staker\n    uint256 public immutable override maxIncentiveStartLeadTime;\n\n    /// @inheritdoc IUniswapV3Staker\n    address public immutable minter;\n\n    /// @inheritdoc IUniswapV3Staker\n    address public immutable hermes;\n\n    /// @inheritdoc IUniswapV3Staker\n    bHermesBoost public immutable hermesGaugeBoost;\n\n    /// @param _factory the Uniswap V3 factory\n    /// @param _nonfungiblePositionManager the NFT position manager contract address\n    /// @param _maxIncentiveStartLeadTime the max duration of an incentive in seconds\n    constructor(\n        IUniswapV3Factory _factory,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        IUniswapV3GaugeFactory _uniswapV3GaugeFactory,\n        bHermesBoost _hermesGaugeBoost,\n        uint256 _maxIncentiveStartLeadTime,\n        address _minter,\n        address _hermes\n    ) {\n        factory = _factory;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        maxIncentiveStartLeadTime = _maxIncentiveStartLeadTime;\n        uniswapV3GaugeFactory = _uniswapV3GaugeFactory;\n        hermesGaugeBoost = _hermesGaugeBoost;\n        minter = _minter;\n        hermes = _hermes;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        CREATE INCENTIVE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function createIncentiveFromGauge(uint256 reward) external {\n        if (reward <= 0) revert IncentiveRewardMustBePositive();\n\n        uint96 startTime = IncentiveTime.computeEnd(block.timestamp);\n\n        IUniswapV3Pool pool = gaugePool[msg.sender];\n\n        if (address(pool) == address(0)) revert IncentiveCallerMustBeRegisteredGauge();\n\n        IncentiveKey memory key = IncentiveKey({startTime: startTime, pool: pool});\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        incentives[incentiveId].totalRewardUnclaimed += reward;\n\n        hermes.safeTransferFrom(msg.sender, address(this), reward);\n\n        emit IncentiveCreated(pool, startTime, reward);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function createIncentive(IncentiveKey memory key, uint256 reward) external {\n        if (reward <= 0) revert IncentiveRewardMustBePositive();\n\n        uint96 startTime = IncentiveTime.computeStart(key.startTime);\n\n        if (startTime != key.startTime) revert IncentiveStartTimeNotAtEndOfAnEpoch();\n\n        if (startTime <= block.timestamp) revert IncentiveStartTimeMustBeNowOrInTheFuture();\n        if (startTime - block.timestamp > maxIncentiveStartLeadTime) {\n            revert IncentiveStartTimeTooFarIntoFuture();\n        }\n\n        if (address(gauges[key.pool]) == address(0)) {\n            revert IncentiveCannotBeCreatedForPoolWithNoGauge();\n        }\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        incentives[incentiveId].totalRewardUnclaimed += reward;\n\n        hermes.safeTransferFrom(msg.sender, address(this), reward);\n\n        emit IncentiveCreated(key.pool, startTime, reward);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            END INCENTIVE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function endIncentive(IncentiveKey memory key) external returns (uint256 refund) {\n        if (block.timestamp < IncentiveTime.getEnd(key.startTime)) {\n            revert EndIncentiveBeforeEndTime();\n        }\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        Incentive storage incentive = incentives[incentiveId];\n\n        refund = incentive.totalRewardUnclaimed;\n\n        if (refund == 0) revert EndIncentiveNoRefundAvailable();\n        if (incentive.numberOfStakes > 0) revert EndIncentiveWhileStakesArePresent();\n\n        // issue the refund\n        incentive.totalRewardUnclaimed = 0;\n\n        hermes.safeTransfer(minter, refund);\n\n        // note we never clear totalSecondsClaimedX128\n\n        emit IncentiveEnded(incentiveId, refund);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            DEPOSIT TOKEN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Upon receiving a Uniswap V3 ERC721, create the token deposit and\n    ///      _stakes in current incentive setting owner to `from`.\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata)\n        external\n        override\n        returns (bytes4)\n    {\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager;\n        if (msg.sender != address(_nonfungiblePositionManager)) revert TokenNotUniswapV3NFT();\n\n        (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) =\n            NFTPositionInfo.getPositionInfo(factory, nonfungiblePositionManager, tokenId);\n\n        deposits[tokenId] = Deposit({owner: from, tickLower: tickLower, tickUpper: tickUpper, stakedTimestamp: 0});\n        emit DepositTransferred(tokenId, address(0), from);\n\n        // stake the token in the current incentive\n        _stakeToken(tokenId, pool, tickLower, tickUpper, liquidity);\n\n        return this.onERC721Received.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            WITHDRAW TOKEN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function withdrawToken(uint256 tokenId, address to, bytes memory data) external {\n        if (to == address(0)) revert InvalidRecipient();\n\n        Deposit storage deposit = deposits[tokenId];\n\n        if (deposit.owner != msg.sender) revert NotCalledByOwner();\n        if (deposit.stakedTimestamp != 0) revert TokenStakedError();\n\n        delete deposits[tokenId];\n        emit DepositTransferred(tokenId, msg.sender, address(0));\n\n        nonfungiblePositionManager.safeTransferFrom(address(this), to, tokenId, data);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            REWARD LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function claimReward(address to, uint256 amountRequested) external returns (uint256 reward) {\n        reward = rewards[msg.sender];\n        if (amountRequested != 0 && amountRequested < reward) {\n            reward = amountRequested;\n            rewards[msg.sender] -= reward;\n        } else {\n            rewards[msg.sender] = 0;\n        }\n\n        if (reward > 0) hermes.safeTransfer(to, reward);\n\n        emit RewardClaimed(to, reward);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function claimAllRewards(address to) external returns (uint256 reward) {\n        reward = rewards[msg.sender];\n        rewards[msg.sender] = 0;\n\n        if (reward > 0) hermes.safeTransfer(to, reward);\n\n        emit RewardClaimed(to, reward);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function getRewardInfo(IncentiveKey memory key, uint256 tokenId)\n        external\n        view\n        override\n        returns (uint256 reward, uint160 secondsInsideX128)\n    {\n        Deposit storage deposit = deposits[tokenId];\n\n        (uint96 endTime, uint256 stakedDuration) =\n            IncentiveTime.getEndAndDuration(key.startTime, deposit.stakedTimestamp, block.timestamp);\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n        {\n            uint128 boostAmount;\n            uint128 boostTotalSupply;\n            address owner = deposit.owner;\n            // If tokenId is attached to gauge\n            if (_userAttachements[owner][key.pool] == tokenId) {\n                // get boost amount and total supply\n                (boostAmount, boostTotalSupply) = hermesGaugeBoost.getUserGaugeBoost(owner, address(gauges[key.pool]));\n            }\n\n            (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity) = stakes(tokenId, incentiveId);\n            if (liquidity == 0) revert TokenNotStaked();\n\n            (, uint160 secondsPerLiquidityInsideX128,) =\n                key.pool.snapshotCumulativesInside(deposit.tickLower, deposit.tickUpper);\n\n            secondsInsideX128 = RewardMath.computeBoostedSecondsInsideX128(\n                stakedDuration,\n                liquidity,\n                uint128(boostAmount),\n                uint128(boostTotalSupply),\n                secondsPerLiquidityInsideInitialX128,\n                secondsPerLiquidityInsideX128\n            );\n        }\n\n        Incentive storage incentive = incentives[incentiveId];\n        reward = RewardMath.computeBoostedRewardAmount(\n            incentive.totalRewardUnclaimed,\n            incentive.totalSecondsClaimedX128,\n            key.startTime,\n            endTime,\n            secondsInsideX128,\n            block.timestamp\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            RE-STAKE TOKEN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function restakeToken(uint256 tokenId) external {\n        IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId];\n        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true);\n\n        (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) =\n            NFTPositionInfo.getPositionInfo(factory, nonfungiblePositionManager, tokenId);\n\n        _stakeToken(tokenId, pool, tickLower, tickUpper, liquidity);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UNSTAKE TOKEN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function unstakeToken(uint256 tokenId) external {\n        IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId];\n        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function unstakeToken(IncentiveKey memory key, uint256 tokenId) external {\n        _unstakeToken(key, tokenId, true);\n    }\n\n    function _unstakeToken(IncentiveKey memory key, uint256 tokenId, bool isNotRestake) private {\n        Deposit storage deposit = deposits[tokenId];\n\n        (uint96 endTime, uint256 stakedDuration) =\n            IncentiveTime.getEndAndDuration(key.startTime, deposit.stakedTimestamp, block.timestamp);\n\n        address owner = deposit.owner;\n\n        // anyone can call restakeToken if the block time is after the end time of the incentive\n        if ((isNotRestake || block.timestamp < endTime) && owner != msg.sender) revert NotCalledByOwner();\n\n        {\n            // scope for bribeAddress, avoids stack too deep errors\n            address bribeAddress = bribeDepots[key.pool];\n\n            if (bribeAddress != address(0)) {\n                nonfungiblePositionManager.collect(\n                    INonfungiblePositionManager.CollectParams({\n                        tokenId: tokenId,\n                        recipient: bribeAddress,\n                        amount0Max: type(uint128).max,\n                        amount1Max: type(uint128).max\n                    })\n                );\n            }\n        }\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n        uint160 secondsInsideX128;\n        uint128 liquidity;\n        {\n            uint128 boostAmount;\n            uint128 boostTotalSupply;\n\n            UniswapV3Gauge gauge = gauges[key.pool]; // saves another SLOAD if no tokenId is attached\n\n            // If tokenId is attached to gauge\n            if (hermesGaugeBoost.isUserGauge(owner, address(gauge)) && _userAttachements[owner][key.pool] == tokenId) {\n                // get boost amount and total supply\n                (boostAmount, boostTotalSupply) = hermesGaugeBoost.getUserGaugeBoost(owner, address(gauge));\n                gauge.detachUser(owner);\n                _userAttachements[owner][key.pool] = 0;\n            }\n\n            uint160 secondsPerLiquidityInsideInitialX128;\n            (secondsPerLiquidityInsideInitialX128, liquidity) = stakes(tokenId, incentiveId);\n            if (liquidity == 0) revert TokenNotStaked();\n\n            (, uint160 secondsPerLiquidityInsideX128,) =\n                key.pool.snapshotCumulativesInside(deposit.tickLower, deposit.tickUpper);\n\n            secondsInsideX128 = RewardMath.computeBoostedSecondsInsideX128(\n                stakedDuration,\n                liquidity,\n                uint128(boostAmount),\n                uint128(boostTotalSupply),\n                secondsPerLiquidityInsideInitialX128,\n                secondsPerLiquidityInsideX128\n            );\n        }\n\n        deposit.stakedTimestamp = 0;\n        Incentive storage incentive = incentives[incentiveId];\n        incentive.numberOfStakes--;\n        uint256 reward = RewardMath.computeBoostedRewardAmount(\n            incentive.totalRewardUnclaimed,\n            incentive.totalSecondsClaimedX128,\n            key.startTime,\n            endTime,\n            secondsInsideX128,\n            block.timestamp\n        );\n\n        unchecked {\n            // if this overflows, e.g. after 2^32-1 full liquidity seconds have been claimed,\n            // reward rate will fall drastically so it's safe\n            // can't overflow if incentiveDuration < 2^32-1 seconds\n            incentive.totalSecondsClaimedX128 += secondsInsideX128;\n            // reward is never greater than total reward unclaimed\n            incentive.totalRewardUnclaimed -= reward;\n            // this only overflows if a token has a total supply greater than type(uint256).max\n            rewards[owner] += reward;\n\n            // this only overflows if a token has a total supply greater than type(uint256).max\n            // Accounting purposes for external contracts only\n            tokenIdRewards[tokenId] += reward;\n        }\n\n        Stake storage stake = _stakes[tokenId][incentiveId];\n        stake.secondsPerLiquidityInsideInitialX128 = 0;\n        stake.liquidityNoOverflow = 0;\n        if (liquidity >= type(uint96).max) stake.liquidityIfOverflow = 0;\n        delete stakedIncentiveKey[tokenId];\n        emit TokenUnstaked(tokenId, incentiveId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            STAKE TOKEN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Staker\n    function stakeToken(uint256 tokenId) external override {\n        if (deposits[tokenId].stakedTimestamp != 0) revert TokenStakedError();\n\n        (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) =\n            NFTPositionInfo.getPositionInfo(factory, nonfungiblePositionManager, tokenId);\n\n        _stakeToken(tokenId, pool, tickLower, tickUpper, liquidity);\n    }\n\n    /// @dev Stakes a deposited token without doing an already staked in another position check\n    function _stakeToken(uint256 tokenId, IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity)\n        private\n    {\n        IncentiveKey memory key = IncentiveKey({pool: pool, startTime: IncentiveTime.computeStart(block.timestamp)});\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        if (incentives[incentiveId].totalRewardUnclaimed == 0) revert NonExistentIncentiveError();\n\n        if (uint24(tickUpper - tickLower) < poolsMinimumWidth[pool]) revert RangeTooSmallError();\n        if (liquidity == 0) revert NoLiquidityError();\n\n        stakedIncentiveKey[tokenId] = key;\n\n        // If user not attached to gauge, attach\n        address tokenOwner = deposits[tokenId].owner;\n        if (tokenOwner == address(0)) revert TokenNotDeposited();\n\n        UniswapV3Gauge gauge = gauges[pool]; // saves another SLOAD if no tokenId is attached\n\n        if (!hermesGaugeBoost.isUserGauge(tokenOwner, address(gauge))) {\n            _userAttachements[tokenOwner][pool] = tokenId;\n            gauge.attachUser(tokenOwner);\n        }\n\n        deposits[tokenId].stakedTimestamp = uint40(block.timestamp);\n        incentives[incentiveId].numberOfStakes++;\n\n        (, uint160 secondsPerLiquidityInsideX128,) = pool.snapshotCumulativesInside(tickLower, tickUpper);\n\n        if (liquidity >= type(uint96).max) {\n            _stakes[tokenId][incentiveId] = Stake({\n                secondsPerLiquidityInsideInitialX128: secondsPerLiquidityInsideX128,\n                liquidityNoOverflow: type(uint96).max,\n                liquidityIfOverflow: liquidity\n            });\n        } else {\n            Stake storage stake = _stakes[tokenId][incentiveId];\n            stake.secondsPerLiquidityInsideInitialX128 = secondsPerLiquidityInsideX128;\n            stake.liquidityNoOverflow = uint96(liquidity);\n        }\n\n        emit TokenStaked(tokenId, incentiveId, liquidity);\n    }\n\n    /*///////////////////////////////////////////"
    }
  ]
}