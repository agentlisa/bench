{
  "Title": "M-2: OCL_ZVE::pushToLockerMulti() will revert due to incorrect assert() statements when interacting with UniswapV2",
  "Content": "# Issue M-2: OCL_ZVE::pushToLockerMulti() will revert due to incorrect assert() statements when interacting with UniswapV2 \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/18 \n\n## Found by \n0rpse, 0x73696d616f, 0xAnmol, 0xboriskataa, 0xpiken, 0xvj, AMOW, Afriaudit, AllTooWell, BiasedMerc, BoRonGod, Drynooo, FastTiger, Ironsidesec, JigglypuffAndPikachu, KupiaSec, Maniacs, Quanta, Ruhum, SilverChariot, Tendency, blackhole, blockchain555, cergyk, dany.armstrong90, den\\_sosnovskyi, ether\\_sky, flacko, jasonxiale, krikolkk, lemonmon, mt030d, recursiveEth, saidam017, sl1\n## Summary\n\n`OCL_ZVE::pushToLockerMulti()` verifies that the allowances for both tokens is 0 after providing liquidity to UniswapV2 or Sushi routers, however there is a high likelihood that one allowance will not be 0, due to setting a 90% minimum liquidity provided value. Therefore, the function will revert most of the time breaking core functionality of the locker, making the contract useless.\n\n## Vulnerability Detail\n\nThe DAO can add liquidity to UniswapV2 or Sushi through `OCL_ZVE::pushToLockerMulti()` function, where `addLiquidity` is called on `router`:\n\n[OCL_ZVE.sol#L198C78-L198](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L198)\n```solidity\nIRouter_OCL_ZVE(router).addLiquidity(\n```\n\n[OCL_ZVE.sol#L90](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L90)\n```solidity\naddress public immutable router;            /// @dev Address for the Router (Uniswap v2 or Sushi).\n```\nThe router is intended to be Uniswap v2 or Sushi (Sushi router uses the same code as Uniswap v2 [0xd9e1ce17f2641f24ae83637ab66a2cca9c378b9f](https://etherscan.io/address/0xd9e1ce17f2641f24ae83637ab66a2cca9c378b9f#code)). \n\n[UniswapV2Router02::addLiquidity](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76)\n```solidity\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }\n```\n\nWhen calling the function 4 variables relevant to this issue are passed:\n`amountADesired` and `amountBDesired` are the ideal amount of tokens we want to deposit, whilst\n`amountAMin` and `amountBMin` are the minimum amounts of tokens we want to deposit. \nMeaning the true amount that will deposit be deposited for each token will be inbetween those 2 values, e.g:\n`amountAMin <= amountA <= amountADesired`.\nWhere `amountA` is how much of `tokenA` will be transfered.\n\nThe transfered amount are `amountA` and `amountB` which are calculated as follows:\n[UniswapV2Router02::_addLiquidity](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L33-L60)\n```solidity\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n        }\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n```\n`UniswapV2Router02::_addLiquidity` receives a quote for how much of each token can be added and validates that the values fall within the `amountAMin` and `amountADesired` range. Unless the exactly correct amounts are passed as `amountADesired` and `amountBDesired` then the amount of one of the two tokens will be less than the desired amount.\n\nNow lets look at how `OCL_ZVE` interacts with the Uniswapv2 router:\n\n[OCL_ZVE::addLiquidity](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L191-L209)\n```solidity\n        // Router addLiquidity() endpoint.\n        uint balPairAsset = IERC20(pairAsset).balanceOf(address(this));\n        uint balZVE = IERC20(ZVE).balanceOf(address(this));\n        IERC20(pairAsset).safeIncreaseAllowance(router, balPairAsset);\n        IERC20(ZVE).safeIncreaseAllowance(router, balZVE);\n\n        // Prevent volatility of greater than 10% in pool relative to amounts present.\n        (uint256 depositedPairAsset, uint256 depositedZVE, uint256 minted) = IRouter_OCL_ZVE(router).addLiquidity(\n            pairAsset, \n            ZVE, \n            balPairAsset,\n            balZVE, \n            (balPairAsset * 9) / 10,\n            (balZVE * 9) / 10, \n            address(this), block.timestamp + 14 days\n        );\n        emit LiquidityTokensMinted(minted, depositedZVE, depositedPairAsset);\n        assert(IERC20(pairAsset).allowance(address(this), router) == 0);\n        assert(IERC20(ZVE).allowance(address(this), router) == 0);\n```\nThe function first increases the allowances for both tokens to `balPairAsset` and `balZVE` respectively. \n\nWhen calling the router, `balPairAsset` and `valZVE` are provided as the desired amount of liquidity to add, however `(balPairAsset * 9) / 10` and `(balZVE * 9) / 10` are also passed as minimums for how much liquidity we want to add.\n\nAs the final transfered value will be between:\n `(balPairAsset * 9) / 10 <= x <= balPairAsset`\ntherefore the allowance after providing liquidity will be:\n `0 <= IERC20(pairAsset).allowance(address(this), router) <= balPairAsset - (balPairAsset * 9) / 10` \nhowever the function expects the allowance to be 0 for both tokens after providing liquidity.\nThe same applies to the `ZVE` allowance.\n\nThis means that in most cases one of the assert statements will not be met, leading to the add liquidity call to revert. This is unintended behaviour, as the function passed a `90%` minimum amount, however the allowance asserts do not take this into consideration.\n\n## Impact\n\nCalls to `OCL_ZVE::pushToLockerMulti()` will revert a majority of the time, causing core functionality of providing liquidity through the locker to be broken.\n\n## Code Snippet\n\n[OCL_ZVE.sol#L198C78-L198](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L198)\n[UniswapV2Router02.sol#L61-L76](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76)\n[UniswapV2Router02.sol#L33-L60](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L33-L60)\n[OCL_ZVE.sol#L191-L209](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L191-L209)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe project wants to clear allowances after all transfers, therefore set the router allowance to 0 after providing liquidity using the returned value from the router:\n```diff\n  (uint256 depositedPairAsset, uint256 depositedZVE, uint256 minted) = IRouter_OCL_ZVE(router).addLiquidity(\n      pairAsset, \n      ZVE, \n      balPairAsset,\n      balZVE, \n      (balPairAsset * 9) / 10,\n      (balZVE * 9) / 10, \n      address(this), block.timestamp + 14 days\n  );\n  emit LiquidityTokensMinted(minted, depositedZVE, depositedPairAsset);\n- assert(IERC20(pairAsset).allowance(address(this), router) == 0);\n- assert(IERC20(ZVE).allowance(address(this), router) == 0);\n+ uint256 pairAssetAllowanceLeft = balPairAsset - depositedPairAsset;\n+ if (pairAssetAllowanceLeft > 0) {\n+     IERC20(pairAsset).safeDecreaseAllowance(router, pairAssetAllowanceLeft);\n+ }\n+ uint256 zveAllowanceLeft = balZVE - depositedZVE;\n+ if (zveAllowanceLeft > 0) {\n+     IERC20(ZVE).safeDecreaseAllowance(router, zveAllowanceLeft);\n+ }\n```\nThis will remove the left over allowance after providing liquidity, ensuring the allowance is 0.\n\n\n\n## Discussion\n\n**pseudonaut**\n\nValid\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> medium. While amounts provided are from the trusted admin, who is supposed to provide exact amounts to add liquidity in correct ratio of token amounts, the fact that live balance of the contract is used makes it possible for the balance to change from the time admin provides the amounts, making the transaction revert. Additionally, current contract balances might be in so high disproportion, that admin will simply not have enough funds to create correct ratio to add liquidity.\n\n\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/264\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IFactory_OCL_ZVE {\n    /// @notice Returns the address of the pair for tokenA and tokenB, if it has been created, else address(0).\n    /// @param tokenA Address of one of pair's tokens.\n    /// @param tokenB Address of pair's other token.\n    /// @return pair The address of the pair.\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface IRouter_OCL_ZVE {\n    /// @notice Adds liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param amountADesired Amount tokenA to add as liquidity if B/A <= amountBDesired/amountADesired (A depreciates).\n    /// @param amountBDesired Amount tokenB to add as liquidity if A/B <= amountADesired/amountBDesired (B depreciates).\n    /// @param amountAMin Bounds B/A price max before the transaction reverts. Must be <= amountADesired.\n    /// @param amountBMin Bounds A/B price max before the transaction reverts. Must be <= amountBDesired.\n    /// @param to Recipient of the liquidity tokens.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA sent to the pool.\n    /// @return amountB The amount of tokenB sent to the pool.\n    /// @return liquidity The amount of liquidity tokens minted.\n    function addLiquidity(\n        address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    /// @notice Removes liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param liquidity The amount of liquidity tokens to remove.\n    /// @param amountAMin The minimum amount of tokenA that must be received for the transaction not to revert.\n    /// @param amountBMin The minimum amount of tokenB that must be received for the transaction not to revert.\n    /// @param to Recipient of the underlying assets.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA received.\n    /// @return amountB The amount of tokenB received.\n    function removeLiquidity(\n        address tokenA, address tokenB, uint256 liquidity, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n\ninterface IZivoeGlobals_OCL_ZVE {\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeYDL contract.\n    function YDL() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeToken contract.\n    function ZVE() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns true if an address is whitelisted as a keeper.\n    function isKeeper(address) external view returns (bool);\n}\n\ninterface IZivoeYDL_OCL_ZVE {\n    /// @notice Returns the \"stablecoin\" that will be distributed via YDL.\n    /// @return asset The address of the \"stablecoin\" that will be distributed via YDL.\n    function distributedAsset() external view returns (address asset);\n}\n\n\n/// @notice This contract manages liquidity provisioning for a Uniswap v2 or Sushi pool.\n///         This contract has the following responsibilities:\n///           - Allocate capital to a $ZVE/pairAsset pool.\n///           - Remove capital from a $ZVE/pairAsset pool.\n///           - Forward yield (profits) every 30 days to the YDL with compounding mechanisms.\ncontract OCL_ZVE is ZivoeLocker, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    \n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;               /// @dev The ZivoeGlobals contract.\n    address public immutable factory;           /// @dev Address for the Factory (Uniswap v2 or Sushi).\n    address public immutable pairAsset;         /// @dev ERC20 that will be paired with $ZVE for Sushi pool.\n    address public immutable router;            /// @dev Address for the Router (Uniswap v2 or Sushi).\n\n    address public OCT_YDL;                     /// @dev Facilitates swaps and forwards distributedAsset() to YDL.\n    \n    uint256 public basis;                       /// @dev The basis used for forwardYield() accounting.\n    uint256 public compoundingRateBIPS = 5000;  /// @dev The % of returns to retain, in BIPS.\n    uint256 public nextYieldDistribution;       /// @dev Determines next available forwardYield() call.\n\n    uint256 private constant BIPS = 10000;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCL_ZVE contract.\n    /// @param DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param _GBL The ZivoeGlobals contract.\n    /// @param _pairAsset ERC20 that will be paired with $ZVE for pool.\n    /// @param  _OCT_YDL The contract that facilitates swaps and forwards distributedAsset() to YDL.\n    constructor(address DAO, address _GBL, address _pairAsset, address _router, address _factory, address _OCT_YDL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n        pairAsset = _pairAsset;\n        router = _router;\n        factory = _factory;\n        OCT_YDL = _OCT_YDL;\n    }\n\n\n\n    // ------------\n    //    Events   \n    // ------------\n\n    /// @notice Emitted during pullFromLocker() and pullFromLockerPartial() and _forwardYield() [via forwardYield()].\n    /// @param  amountBurned Amount of liquidity tokens burned.\n    /// @param  claimedZVE Amount of ZVE claimed.\n    /// @param  claimedPairAsset Amount of pairAsset claimed.\n    event LiquidityTokensBurned(uint256 amountBurned, uint256 claimedZVE, uint256 claimedPairAsset);\n\n    /// @notice Emitted during pushToLockerMulti().\n    /// @param  amountMinted Amount of liquidity tokens minted.\n    /// @param  depositedZVE Amount of ZVE deposited.\n    /// @param  depositedPairAsset Amount of pairAsset deposited.\n    event LiquidityTokensMinted(uint256 amountMinted, uint256 depositedZVE, uint256 depositedPairAsset);\n\n    /// @notice Emitted during updateCompoundingRateBIPS().\n    /// @param  oldValue The old value of compoundingRateBIPS.\n    /// @param  newValue The new value of compoundingRateBIPS.\n    event UpdatedCompoundingRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateOCTYDL().\n    /// @param  newOCT The new OCT_YDL contract.\n    /// @param  oldOCT The old OCT_YDL contract.\n    event UpdatedOCTYDL(address indexed newOCT, address indexed oldOCT);\n\n    /// @notice Emitted during forwardYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  amount The amount distributed.\n    event YieldForwarded(address indexed asset, uint256 amount);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLockerMulti().\n    function canPushMulti() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice This pulls capital from the DAO and adds liquidity into a $ZVE/pairAsset pool.\n    /// @param  assets The assets to pull from the DAO.\n    /// @param  amounts The amount to pull of each asset respectively.\n    /// @param  data Accompanying transaction data.\n    function pushToLockerMulti(\n        address[] calldata assets, uint256[] calldata amounts, bytes[] calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        require(\n            assets[0] == pairAsset && assets[1] == ZVE,\n            \"OCL_ZVE::pushToLockerMulti() assets[0] != pairAsset || assets[1] != ZVE\"\n        );\n\n        for (uint256 i = 0; i < 2; i++) {\n            require(amounts[i] >= 10 * 10**6, \"OCL_ZVE::pushToLockerMulti() amounts[i] < 10 * 10**6\");\n            IERC20(assets[i]).safeTransferFrom(owner(), address(this), amounts[i]);\n        }\n\n        if (nextYieldDistribution == 0) { nextYieldDistribution = block.timestamp + 30 days; }\n\n        uint256 preBasis;\n        if (basis != 0) { (preBasis,) = fetchBasis(); }\n\n        // Router addLiquidity() endpoint.\n        uint balPairAsset = IERC20(pairAsset).balanceOf(address(this));\n        uint balZVE = IERC20(ZVE).balanceOf(address(this));\n        IERC20(pairAsset).safeIncreaseAllowance(router, balPairAsset);\n        IERC20(ZVE).safeIncreaseAllowance(router, balZVE);\n\n        // Prevent volatility of greater than 10% in pool relative to amounts present.\n        (uint256 depositedPairAsset, uint256 depositedZVE, uint256 minted) = IRouter_OCL_ZVE(router).addLiquidity(\n            pairAsset, \n            ZVE, \n            balPairAsset,\n            balZVE, \n            (balPairAsset * 9) / 10,\n            (balZVE * 9) / 10, \n            address(this), block.timestamp + 14 days\n        );\n        emit LiquidityTokensMinted(minted, depositedZVE, depositedPairAsset);\n        assert(IERC20(pairAsset).allowance(address(this), router) == 0);\n        assert(IERC20(ZVE).allowance(address(this), router) == 0);\n\n        // Increase basis by difference.\n        (uint256 postBasis,) = fetchBasis();\n        require(postBasis > preBasis, \"OCL_ZVE::pushToLockerMulti() postBasis <= preBasis\");\n        basis += postBasis - preBasis;\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLocker(address asset, bytes calldata data) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            uint256 preBalLPToken = IERC20(pair).balanceOf(address(this));\n            IERC20(pair).safeIncreaseAllowance(router, preBalLPToken);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, preBalLPToken, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(preBalLPToken, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n\n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            basis = 0;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), IERC20(asset).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  amount The amount of \"asset\" to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLockerPartial(\n        address asset, uint256 amount, bytes calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            (uint256 preBasis,) = fetchBasis();\n            IERC20(pair).safeIncreaseAllowance(router, amount);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, amount, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(amount, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n            \n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            (uint256 postBasis,) = fetchBasis();\n            require(postBasis < preBasis, \"OCL_ZVE::pullFromLockerPartial() postBasis >= preBasis\");\n            basis -= preBasis - postBasis;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), amount);\n        }\n    }\n\n    /// @notice This forwards yield in excess of the basis.\n    function forwardYield() external {\n        if (IZivoeGlobals_OCL_ZVE(GBL).isKeeper(_msgSender())) {\n            require(\n                block.timestamp > nextYieldDistribution - 12 hours, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution - 12 hours\"\n            );\n        }\n        else {\n            require(\n                block.timestamp > nextYieldDistribution, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution\"\n            );\n        }\n\n        (uint256 amount, uint256 lp) = fetchBasis();\n        if (amount > basis) { _forwardYield(amount, lp); }\n        (basis,) = fetchBasis();\n        nextYieldDistribution += 30 days;\n    }\n\n    /// @notice This forwards yield to the YDL in the form of pairAsset.\n    /// @dev    Private function, only callable via forwardYield().\n    /// @param  amount Current pairAsset harvestable.\n    /// @param  lp Current ZVE/pairAsset LP tokens.\n    function _forwardYield(uint256 amount, uint256 lp) private nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        uint256 lpBurnable = (amount - basis) * lp / amount * (BIPS - compoundingRateBIPS) / BIPS;\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        IERC20(pair).safeIncreaseAllowance(router, lpBurnable);\n        (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n            pairAsset, ZVE, lpBurnable, 0, 0, address(this), block.timestamp + 14 days\n        );\n        emit LiquidityTokensBurned(lpBurnable, claimedZVE, claimedPairAsset);\n        assert(IERC20(pair).allowance(address(this), router) == 0);\n        uint balPairAsset = IERC20(pairAsset).balanceOf(address(this));\n        emit YieldForwarded(pairAsset, balPairAsset);\n        if (pairAsset != IZivoeYDL_OCL_ZVE(IZivoeGlobals_OCL_ZVE(GBL).YDL()).distributedAsset()) {\n            IERC20(pairAsset).safeTransfer(OCT_YDL, balPairAsset);\n        }\n        else {\n            IERC20(pairAsset).safeTransfer(IZivoeGlobals_OCL_ZVE(GBL).YDL(), balPairAsset);\n        }\n        IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n    }\n\n    /// @notice Returns amount of pairAsset redeemable with current LP position.\n    /// @dev    The withdrawal mechanism is ZVE/pairAsset_LP => pairAsset.\n    /// @return amount Current pairAsset harvestable.\n    /// @return lp Current ZVE/pairAsset LP tokens.\n    function fetchBasis() public view returns (uint256 amount, uint256 lp) {\n        address pool = IFactory_OCL_ZVE(factory).getPair(pairAsset, IZivoeGlobals_OCL_ZVE(GBL).ZVE());\n        uint256 pairAssetBalance = IERC20(pairAsset).balanceOf(pool);\n        uint256 poolTotalSupply = IERC20(pool).totalSupply();\n        lp = IERC20(pool).balanceOf(address(this));\n        amount = lp * pairAssetBalance / poolTotalSupply;\n    }\n\n    /// @notice Updates the compounding rate of this contract.\n    /// @dev    A value of 2,000 represent 20% of the earnings stays in this contract, compounding.\n    /// @param  _compoundingRateBIPS The new compounding rate value.\n    function updateCompoundingRateBIPS(uint256 _compoundingRateBIPS) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCL_ZVE(GBL).TLC(), \n            \"OCL_ZVE::updateCompoundingRateBIPS() _msgSender() != IZivoeGlobals_OCL_ZVE(GBL).TLC()\"\n        );\n        require(_compoundingRateBIPS <= BIPS, \"OCL_ZVE::updateCompoundingRateBIPS() ratio > BIPS\");\n\n        emit UpdatedCompoundingRateBIPS(compoundingRateBIPS, _compoundingRateBIPS);\n        compoundingRateBIPS = _compoundingRateBIPS;\n    }\n\n    /// @notice Update the OCT_YDL endpoint.\n    /// @dev    This function MUST only be called by ZVL().\n    /// @param  _OCT_YDL The new address for OCT_YDL.\n    function updateOCTYDL(address _OCT_YDL) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCL_ZVE(GBL).ZVL(), \n            \"OCL_ZVE::updateOCTYDL() _msgSender() != IZivoeGlobals_OCL_ZVE(GBL).ZVL()\"\n        );\n        require(_OCT_YDL != address(0), \"OCL_ZVE::updateOCTYDL() _OCT_YDL == address(0)\");\n        emit UpdatedOCTYDL(_OCT_YDL, OCT_YDL);\n        OCT_YDL = _OCT_YDL;\n    }\n    \n}"
    },
    {
      "filename": "zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IFactory_OCL_ZVE {\n    /// @notice Returns the address of the pair for tokenA and tokenB, if it has been created, else address(0).\n    /// @param tokenA Address of one of pair's tokens.\n    /// @param tokenB Address of pair's other token.\n    /// @return pair The address of the pair.\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface IRouter_OCL_ZVE {\n    /// @notice Adds liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param amountADesired Amount tokenA to add as liquidity if B/A <= amountBDesired/amountADesired (A depreciates).\n    /// @param amountBDesired Amount tokenB to add as liquidity if A/B <= amountADesired/amountBDesired (B depreciates).\n    /// @param amountAMin Bounds B/A price max before the transaction reverts. Must be <= amountADesired.\n    /// @param amountBMin Bounds A/B price max before the transaction reverts. Must be <= amountBDesired.\n    /// @param to Recipient of the liquidity tokens.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA sent to the pool.\n    /// @return amountB The amount of tokenB sent to the pool.\n    /// @return liquidity The amount of liquidity tokens minted.\n    function addLiquidity(\n        address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    /// @notice Removes liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param liquidity The amount of liquidity tokens to remove.\n    /// @param amountAMin The minimum amount of tokenA that must be received for the transaction not to revert.\n    /// @param amountBMin The minimum amount of tokenB that must be received for the transaction not to revert.\n    /// @param to Recipient of the underlying assets.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA received.\n    /// @return amountB The amount of tokenB received.\n    function removeLiquidity(\n        address tokenA, address tokenB, uint256 liquidity, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n\ninterface IZivoeGlobals_OCL_ZVE {\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeYDL contract.\n    function YDL() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeToken contract.\n    function ZVE() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns true if an address is whitelisted as a keeper.\n    function isKeeper(address) external view returns (bool);\n}\n\ninterface IZivoeYDL_OCL_ZVE {\n    /// @notice Returns the \"stablecoin\" that will be distributed via YDL.\n    /// @return asset The address of the \"stablecoin\" that will be distributed via YDL.\n    function distributedAsset() external view returns (address asset);\n}\n\n\n/// @notice This contract manages liquidity provisioning for a Uniswap v2 or Sushi pool.\n///         This contract has the following responsibilities:\n///           - Allocate capital to a $ZVE/pairAsset pool.\n///           - Remove capital from a $ZVE/pairAsset pool.\n///           - Forward yield (profits) every 30 days to the YDL with compounding mechanisms.\ncontract OCL_ZVE is ZivoeLocker, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    \n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;               /// @dev The ZivoeGlobals contract.\n    address public immutable factory;           /// @dev Address for the Factory (Uniswap v2 or Sushi).\n    address public immutable pairAsset;         /// @dev ERC20 that will be paired with $ZVE for Sushi pool.\n    address public immutable router;            /// @dev Address for the Router (Uniswap v2 or Sushi).\n\n    address public OCT_YDL;                     /// @dev Facilitates swaps and forwards distributedAsset() to YDL.\n    \n    uint256 public basis;                       /// @dev The basis used for forwardYield() accounting.\n    uint256 public compoundingRateBIPS = 5000;  /// @dev The % of returns to retain, in BIPS.\n    uint256 public nextYieldDistribution;       /// @dev Determines next available forwardYield() call.\n\n    uint256 private constant BIPS = 10000;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCL_ZVE contract.\n    /// @param DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param _GBL The ZivoeGlobals contract.\n    /// @param _pairAsset ERC20 that will be paired with $ZVE for pool.\n    /// @param  _OCT_YDL The contract that facilitates swaps and forwards distributedAsset() to YDL.\n    constructor(address DAO, address _GBL, address _pairAsset, address _router, address _factory, address _OCT_YDL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n        pairAsset = _pairAsset;\n        router = _router;\n        factory = _factory;\n        OCT_YDL = _OCT_YDL;\n    }\n\n\n\n    // ------------\n    //    Events   \n    // ------------\n\n    /// @notice Emitted during pullFromLocker() and pullFromLockerPartial() and _forwardYield() [via forwardYield()].\n    /// @param  amountBurned Amount of liquidity tokens burned.\n    /// @param  claimedZVE Amount of ZVE claimed.\n    /// @param  claimedPairAsset Amount of pairAsset claimed.\n    event LiquidityTokensBurned(uint256 amountBurned, uint256 claimedZVE, uint256 claimedPairAsset);\n\n    /// @notice Emitted during pushToLockerMulti().\n    /// @param  amountMinted Amount of liquidity tokens minted.\n    /// @param  depositedZVE Amount of ZVE deposited.\n    /// @param  depositedPairAsset Amount of pairAsset deposited.\n    event LiquidityTokensMinted(uint256 amountMinted, uint256 depositedZVE, uint256 depositedPairAsset);\n\n    /// @notice Emitted during updateCompoundingRateBIPS().\n    /// @param  oldValue The old value of compoundingRateBIPS.\n    /// @param  newValue The new value of compoundingRateBIPS.\n    event UpdatedCompoundingRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateOCTYDL().\n    /// @param  newOCT The new OCT_YDL contract.\n    /// @param  oldOCT The old OCT_YDL contract.\n    event UpdatedOCTYDL(address indexed newOCT, address indexed oldOCT);\n\n    /// @notice Emitted during forwardYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  amount The amount distributed.\n    event YieldForwarded(address indexed asset, uint256 amount);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLockerMulti().\n    function canPushMulti() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice This pulls capital from the DAO and adds liquidity into a $ZVE/pairAsset pool.\n    /// @param  assets The assets to pull from the DAO.\n    /// @param  amounts The amount to pull of each asset respectively.\n    /// @param  data Accompanying transaction data.\n    function pushToLockerMulti(\n        address[] calldata assets, uint256[] calldata amounts, bytes[] calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        require(\n            assets[0] == pairAsset && assets[1] == ZVE,\n            \"OCL_ZVE::pushToLockerMulti() assets[0] != pairAsset || assets[1] != ZVE\"\n        );\n\n        for (uint256 i = 0; i < 2; i++) {\n            require(amounts[i] >= 10 * 10**6, \"OCL_ZVE::pushToLockerMulti() amounts[i] < 10 * 10**6\");\n            IERC20(assets[i]).safeTransferFrom(owner(), address(this), amounts[i]);\n        }\n\n        if (nextYieldDistribution == 0) { nextYieldDistribution = block.timestamp + 30 days; }\n\n        uint256 preBasis;\n        if (basis != 0) { (preBasis,) = fetchBasis(); }\n\n        // Router addLiquidity() endpoint.\n        uint balPairAsset = IERC20(pairAsset).balanceOf(address(this));\n        uint balZVE = IERC20(ZVE).balanceOf(address(this));\n        IERC20(pairAsset).safeIncreaseAllowance(router, balPairAsset);\n        IERC20(ZVE).safeIncreaseAllowance(router, balZVE);\n\n        // Prevent volatility of greater than 10% in pool relative to amounts present.\n        (uint256 depositedPairAsset, uint256 depositedZVE, uint256 minted) = IRouter_OCL_ZVE(router).addLiquidity(\n            pairAsset, \n            ZVE, \n            balPairAsset,\n            balZVE, \n            (balPairAsset * 9) / 10,\n            (balZVE * 9) / 10, \n            address(this), block.timestamp + 14 days\n        );\n        emit LiquidityTokensMinted(minted, depositedZVE, depositedPairAsset);\n        assert(IERC20(pairAsset).allowance(address(this), router) == 0);\n        assert(IERC20(ZVE).allowance(address(this), router) == 0);\n\n        // Increase basis by difference.\n        (uint256 postBasis,) = fetchBasis();\n        require(postBasis > preBasis, \"OCL_ZVE::pushToLockerMulti() postBasis <= preBasis\");\n        basis += postBasis - preBasis;\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLocker(address asset, bytes calldata data) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            uint256 preBalLPToken = IERC20(pair).balanceOf(address(this));\n            IERC20(pair).safeIncreaseAllowance(router, preBalLPToken);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, preBalLPToken, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(preBalLPToken, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n\n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            basis = 0;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), IERC20(asset).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  amount The amount of \"asset\" to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLockerPartial(\n        address asset, uint256 amount, bytes calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            (uint256 preBasis,) = fetchBasis();\n            IERC20(pair).safeIncreaseAllowance(router, amount);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, amount, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(amount, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n            \n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            (uint256 postBasis,) = fetchBasis();\n            require(postBasis < preBasis, \"OCL_ZVE::pullFromLockerPartial() postBasis >= preBasis\");\n            basis -= preBasis - postBasis;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), amount);\n        }\n    }\n\n    /// @notice This forwards yield in excess of the basis.\n    function forwardYield() external {\n        if (IZivoeGlobals_OCL_ZVE(GBL).isKeeper(_msgSender())) {\n            require(\n                block.timestamp > nextYieldDistribution - 12 hours, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution - 12 hours\"\n            );\n        }\n        else {\n            require(\n                block.timestamp > nextYieldDistribution, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution\"\n            );\n        }\n\n        (uint256 amount, uint256 lp) = fetchBasis();\n        if (amount > basis) { _forwardYield(amount, lp); }\n        (basis,) = fetchBasis();\n        nextYieldDistribution += 30 days;\n    }\n\n    /// @notice This forwards yield to the YDL in the form of pairAsset.\n    /// @dev    Private function, only callable via forwardYield().\n    /// @param  amount Current pairAsset harvestable.\n    /// @param  lp Current ZVE/pairAsset LP tokens.\n    function _forwardYield(uint256 amount, uint256 lp) private nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        uint256 lpBurnable = (amount - basis) * lp / amount * (BIPS - compoundingRateBIPS) / BIPS;\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        IERC20(pair).safeIncreaseAllowance(router, lpBurnable);\n        (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n            pairAsset, ZVE, lpBurnable, 0, 0, address(this), b"
    }
  ]
}