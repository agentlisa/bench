{
  "Title": "[N-04] Outstanding TODO",
  "Content": "\n### Line Reference\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/money-market-contracts/contracts/overseer/src/contract.rs#L395>\n\n### Description\n\nThereâ€™s 1 remaining TODO that may not have been resolved.\n\n`// TODO: Should this become a reply? If so which SubMsg to make reply_on?`\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-02-anchor",
  "Code": [
    {
      "filename": "contracts/money-market-contracts/contracts/overseer/src/contract.rs",
      "content": "#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, to_binary, Addr, BankMsg, Binary, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo,\n    Response, StdResult, WasmMsg,\n};\n\nuse crate::collateral::{\n    liquidate_collateral, lock_collateral, query_all_collaterals, query_borrow_limit,\n    query_collaterals, unlock_collateral,\n};\nuse crate::error::ContractError;\nuse crate::querier::query_epoch_state;\nuse crate::state::{\n    read_config, read_epoch_state, read_whitelist, read_whitelist_elem, store_config,\n    store_epoch_state, store_whitelist_elem, Config, EpochState, WhitelistElem,\n};\n\nuse cosmwasm_bignumber::{Decimal256, Uint256};\nuse moneymarket::common::optional_addr_validate;\nuse moneymarket::custody::ExecuteMsg as CustodyExecuteMsg;\nuse moneymarket::market::EpochStateResponse;\nuse moneymarket::market::ExecuteMsg as MarketExecuteMsg;\nuse moneymarket::overseer::{\n    ConfigResponse, ExecuteMsg, InstantiateMsg, QueryMsg, WhitelistResponse, WhitelistResponseElem,\n};\nuse moneymarket::querier::{deduct_tax, query_balance};\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    store_config(\n        deps.storage,\n        &Config {\n            owner_addr: deps.api.addr_canonicalize(&msg.owner_addr)?,\n            oracle_contract: deps.api.addr_canonicalize(&msg.oracle_contract)?,\n            market_contract: deps.api.addr_canonicalize(&msg.market_contract)?,\n            liquidation_contract: deps.api.addr_canonicalize(&msg.liquidation_contract)?,\n            collector_contract: deps.api.addr_canonicalize(&msg.collector_contract)?,\n            stable_denom: msg.stable_denom,\n            epoch_period: msg.epoch_period,\n            threshold_deposit_rate: msg.threshold_deposit_rate,\n            target_deposit_rate: msg.target_deposit_rate,\n            buffer_distribution_factor: msg.buffer_distribution_factor,\n            anc_purchase_factor: msg.anc_purchase_factor,\n            price_timeframe: msg.price_timeframe,\n        },\n    )?;\n\n    store_epoch_state(\n        deps.storage,\n        &EpochState {\n            deposit_rate: Decimal256::zero(),\n            prev_aterra_supply: Uint256::zero(),\n            prev_interest_buffer: Uint256::zero(),\n            prev_exchange_rate: Decimal256::one(),\n            last_executed_height: env.block.height,\n        },\n    )?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> Result<Response, ContractError> {\n    match msg {\n        ExecuteMsg::UpdateConfig {\n            owner_addr,\n            oracle_contract,\n            liquidation_contract,\n            threshold_deposit_rate,\n            target_deposit_rate,\n            buffer_distribution_factor,\n            anc_purchase_factor,\n            epoch_period,\n            price_timeframe,\n        } => {\n            let api = deps.api;\n            update_config(\n                deps,\n                info,\n                optional_addr_validate(api, owner_addr)?,\n                optional_addr_validate(api, oracle_contract)?,\n                optional_addr_validate(api, liquidation_contract)?,\n                threshold_deposit_rate,\n                target_deposit_rate,\n                buffer_distribution_factor,\n                anc_purchase_factor,\n                epoch_period,\n                price_timeframe,\n            )\n        }\n        ExecuteMsg::Whitelist {\n            name,\n            symbol,\n            collateral_token,\n            custody_contract,\n            max_ltv,\n        } => {\n            let api = deps.api;\n            register_whitelist(\n                deps,\n                info,\n                name,\n                symbol,\n                api.addr_validate(&collateral_token)?,\n                api.addr_validate(&custody_contract)?,\n                max_ltv,\n            )\n        }\n        ExecuteMsg::UpdateWhitelist {\n            collateral_token,\n            custody_contract,\n            max_ltv,\n        } => {\n            let api = deps.api;\n            update_whitelist(\n                deps,\n                info,\n                api.addr_validate(&collateral_token)?,\n                optional_addr_validate(api, custody_contract)?,\n                max_ltv,\n            )\n        }\n        ExecuteMsg::ExecuteEpochOperations {} => execute_epoch_operations(deps, env),\n        ExecuteMsg::UpdateEpochState {\n            interest_buffer,\n            distributed_interest,\n        } => update_epoch_state(deps, env, info, interest_buffer, distributed_interest),\n        ExecuteMsg::LockCollateral { collaterals } => lock_collateral(deps, info, collaterals),\n        ExecuteMsg::UnlockCollateral { collaterals } => {\n            unlock_collateral(deps, env, info, collaterals)\n        }\n        ExecuteMsg::LiquidateCollateral { borrower } => {\n            let api = deps.api;\n            liquidate_collateral(deps, env, info, api.addr_validate(&borrower)?)\n        }\n    }\n}\n\n#[allow(clippy::too_many_arguments)]\npub fn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    owner_addr: Option<Addr>,\n    oracle_contract: Option<Addr>,\n    liquidation_contract: Option<Addr>,\n    threshold_deposit_rate: Option<Decimal256>,\n    target_deposit_rate: Option<Decimal256>,\n    buffer_distribution_factor: Option<Decimal256>,\n    anc_purchase_factor: Option<Decimal256>,\n    epoch_period: Option<u64>,\n    price_timeframe: Option<u64>,\n) -> Result<Response, ContractError> {\n    let mut config: Config = read_config(deps.storage)?;\n\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(owner_addr) = owner_addr {\n        config.owner_addr = deps.api.addr_canonicalize(&owner_addr.to_string())?;\n    }\n\n    if let Some(oracle_contract) = oracle_contract {\n        config.oracle_contract = deps.api.addr_canonicalize(&oracle_contract.to_string())?;\n    }\n\n    if let Some(liquidation_contract) = liquidation_contract {\n        config.liquidation_contract = deps\n            .api\n            .addr_canonicalize(&liquidation_contract.to_string())?;\n    }\n\n    if let Some(threshold_deposit_rate) = threshold_deposit_rate {\n        config.threshold_deposit_rate = threshold_deposit_rate;\n    }\n\n    if let Some(buffer_distribution_factor) = buffer_distribution_factor {\n        config.buffer_distribution_factor = buffer_distribution_factor;\n    }\n\n    if let Some(anc_purchase_factor) = anc_purchase_factor {\n        config.anc_purchase_factor = anc_purchase_factor;\n    }\n\n    if let Some(target_deposit_rate) = target_deposit_rate {\n        config.target_deposit_rate = target_deposit_rate;\n    }\n\n    if let Some(epoch_period) = epoch_period {\n        config.epoch_period = epoch_period;\n    }\n\n    if let Some(price_timeframe) = price_timeframe {\n        config.price_timeframe = price_timeframe;\n    }\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![attr(\"action\", \"update_config\")]))\n}\n\npub fn register_whitelist(\n    deps: DepsMut,\n    info: MessageInfo,\n    name: String,\n    symbol: String,\n    collateral_token: Addr,\n    custody_contract: Addr,\n    max_ltv: Decimal256,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let collateral_token_raw = deps.api.addr_canonicalize(collateral_token.as_str())?;\n    if read_whitelist_elem(deps.storage, &collateral_token_raw).is_ok() {\n        return Err(ContractError::TokenAlreadyRegistered {});\n    }\n\n    store_whitelist_elem(\n        deps.storage,\n        &collateral_token_raw,\n        &WhitelistElem {\n            name: name.to_string(),\n            symbol: symbol.to_string(),\n            custody_contract: deps.api.addr_canonicalize(custody_contract.as_str())?,\n            max_ltv,\n        },\n    )?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"register_whitelist\"),\n        attr(\"name\", name),\n        attr(\"symbol\", symbol),\n        attr(\"collateral_token\", collateral_token),\n        attr(\"custody_contract\", custody_contract),\n        attr(\"LTV\", max_ltv.to_string()),\n    ]))\n}\n\npub fn update_whitelist(\n    deps: DepsMut,\n    info: MessageInfo,\n    collateral_token: Addr,\n    custody_contract: Option<Addr>,\n    max_ltv: Option<Decimal256>,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let collateral_token_raw = deps.api.addr_canonicalize(collateral_token.as_str())?;\n    let mut whitelist_elem: WhitelistElem =\n        read_whitelist_elem(deps.storage, &collateral_token_raw)?;\n\n    if let Some(custody_contract) = custody_contract {\n        whitelist_elem.custody_contract = deps.api.addr_canonicalize(custody_contract.as_str())?;\n    }\n\n    if let Some(max_ltv) = max_ltv {\n        whitelist_elem.max_ltv = max_ltv;\n    }\n\n    store_whitelist_elem(deps.storage, &collateral_token_raw, &whitelist_elem)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"update_whitelist\"),\n        attr(\"collateral_token\", collateral_token),\n        attr(\n            \"custody_contract\",\n            deps.api.addr_humanize(&whitelist_elem.custody_contract)?,\n        ),\n        attr(\"LTV\", whitelist_elem.max_ltv.to_string()),\n    ]))\n}\n\npub fn execute_epoch_operations(deps: DepsMut, env: Env) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    let state: EpochState = read_epoch_state(deps.storage)?;\n    if env.block.height < state.last_executed_height + config.epoch_period {\n        return Err(ContractError::EpochNotPassed(state.last_executed_height));\n    }\n\n    // # of blocks from the last executed height\n    let blocks = Uint256::from(env.block.height - state.last_executed_height);\n\n    // Compute next epoch state\n    let market_contract = deps.api.addr_humanize(&config.market_contract)?;\n    let epoch_state: EpochStateResponse = query_epoch_state(\n        deps.as_ref(),\n        market_contract.clone(),\n        env.block.height,\n        None,\n    )?;\n\n    // effective_deposit_rate = cur_exchange_rate / prev_exchange_rate\n    // deposit_rate = (effective_deposit_rate - 1) / blocks\n    let effective_deposit_rate = epoch_state.exchange_rate / state.prev_exchange_rate;\n    let deposit_rate =\n        (effective_deposit_rate - Decimal256::one()) / Decimal256::from_uint256(blocks);\n\n    let mut messages: Vec<CosmosMsg> = vec![];\n    let mut interest_buffer = query_balance(\n        deps.as_ref(),\n        env.contract.address.clone(),\n        config.stable_denom.to_string(),\n    )?;\n\n    // Send accrued_buffer * config.anc_purchase_factor amount stable token to collector\n    let accrued_buffer = interest_buffer - state.prev_interest_buffer;\n    let anc_purchase_amount = accrued_buffer * config.anc_purchase_factor;\n    if !anc_purchase_amount.is_zero() {\n        messages.push(CosmosMsg::Bank(BankMsg::Send {\n            to_address: deps\n                .api\n                .addr_humanize(&config.collector_contract)?\n                .to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom.to_string(),\n                    amount: anc_purchase_amount.into(),\n                },\n            )?],\n        }));\n    }\n\n    // Deduct anc_purchase_amount from the interest_buffer\n    interest_buffer = interest_buffer - anc_purchase_amount;\n\n    // Distribute Interest Buffer to depositor\n    // Only executed when deposit rate < threshold_deposit_rate\n    let mut distributed_interest: Uint256 = Uint256::zero();\n    if deposit_rate < config.threshold_deposit_rate {\n        // missing_deposit_rate(_per_block)\n        let missing_deposit_rate = config.threshold_deposit_rate - deposit_rate;\n        let prev_deposits = state.prev_aterra_supply * state.prev_exchange_rate;\n\n        // missing_deposits = prev_deposits * missing_deposit_rate(_per_block) * blocks\n        let missing_deposits = prev_deposits * blocks * missing_deposit_rate;\n        let distribution_buffer = interest_buffer * config.buffer_distribution_factor;\n\n        // When there was not enough deposits happens,\n        // distribute interest to market contract\n        distributed_interest = std::cmp::min(missing_deposits, distribution_buffer);\n        interest_buffer = interest_buffer - distributed_interest;\n\n        if !distributed_interest.is_zero() {\n            // deduct tax\n            distributed_interest = Uint256::from(\n                deduct_tax(\n                    deps.as_ref(),\n                    Coin {\n                        denom: config.stable_denom.to_string(),\n                        amount: distributed_interest.into(),\n                    },\n                )?\n                .amount,\n            );\n\n            // Send some portion of interest buffer to Market contract\n            messages.push(CosmosMsg::Bank(BankMsg::Send {\n                to_address: market_contract.to_string(),\n                amount: vec![Coin {\n                    denom: config.stable_denom,\n                    amount: distributed_interest.into(),\n                }],\n            }));\n        }\n    }\n\n    // Execute DistributeRewards\n    let whitelist: Vec<WhitelistResponseElem> = read_whitelist(deps.as_ref(), None, None)?;\n    for elem in whitelist.iter() {\n        messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: elem.custody_contract.clone(),\n            funds: vec![],\n            msg: to_binary(&CustodyExecuteMsg::DistributeRewards {})?,\n        }));\n    }\n\n    // TODO: Should this become a reply? If so which SubMsg to make reply_on?\n    // Execute store epoch state operation\n    messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: env.contract.address.to_string(),\n        funds: vec![],\n        msg: to_binary(&ExecuteMsg::UpdateEpochState {\n            interest_buffer,\n            distributed_interest,\n        })?,\n    }));\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"epoch_operations\"),\n        attr(\"deposit_rate\", deposit_rate.to_string()),\n        attr(\"exchange_rate\", epoch_state.exchange_rate.to_string()),\n        attr(\"aterra_supply\", epoch_state.aterra_supply),\n        attr(\"distributed_interest\", distributed_interest),\n        attr(\"anc_purchase_amount\", anc_purchase_amount),\n    ]))\n}\n\npub fn update_epoch_state(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    // To store interest buffer before receiving epoch staking rewards,\n    // pass interest_buffer from execute_epoch_operations\n    interest_buffer: Uint256,\n    distributed_interest: Uint256,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    let overseer_epoch_state: EpochState = read_epoch_state(deps.storage)?;\n    if info.sender != env.contract.address {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    // # of blocks from the last executed height\n    let blocks = Uint256::from(env.block.height - overseer_epoch_state.last_executed_height);\n\n    // Compute next epoch state\n    let market_contract = deps.api.addr_humanize(&config.market_contract)?;\n    let market_epoch_state: EpochStateResponse = query_epoch_state(\n        deps.as_ref(),\n        market_contract.clone(),\n        env.block.height,\n        Some(distributed_interest),\n    )?;\n\n    // effective_deposit_rate = cur_exchange_rate / prev_exchange_rate\n    // deposit_rate = (effective_deposit_rate - 1) / blocks\n    let effective_deposit_rate =\n        market_epoch_state.exchange_rate / overseer_epoch_state.prev_exchange_rate;\n    let deposit_rate =\n        (effective_deposit_rate - Decimal256::one()) / Decimal256::from_uint256(blocks);\n\n    // store updated epoch state\n    store_epoch_state(\n        deps.storage,\n        &EpochState {\n            last_executed_height: env.block.height,\n            prev_aterra_supply: market_epoch_state.aterra_supply,\n            prev_exchange_rate: market_epoch_state.exchange_rate,\n            prev_interest_buffer: interest_buffer,\n            deposit_rate,\n        },\n    )?;\n\n    Ok(Response::new()\n        .add_message(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: market_contract.to_string(),\n            funds: vec![],\n            msg: to_binary(&MarketExecuteMsg::ExecuteEpochOperations {\n                deposit_rate,\n                target_deposit_rate: config.target_deposit_rate,\n                threshold_deposit_rate: config.threshold_deposit_rate,\n                distributed_interest,\n            })?,\n        }))\n        .add_attributes(vec![\n            attr(\"action\", \"update_epoch_state\"),\n            attr(\"deposit_rate\", deposit_rate.to_string()),\n            attr(\"aterra_supply\", market_epoch_state.aterra_supply),\n            attr(\n                \"exchange_rate\",\n                market_epoch_state.exchange_rate.to_string(),\n            ),\n            attr(\"interest_buffer\", interest_buffer),\n        ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n        QueryMsg::EpochState {} => to_binary(&query_state(deps)?),\n        QueryMsg::Whitelist {\n            collateral_token,\n            start_after,\n            limit,\n        } => to_binary(&query_whitelist(\n            deps,\n            optional_addr_validate(deps.api, collateral_token)?,\n            optional_addr_validate(deps.api, start_after)?,\n            limit,\n        )?),\n        QueryMsg::Collaterals { borrower } => to_binary(&query_collaterals(\n            deps,\n            deps.api.addr_validate(&borrower)?,\n        )?),\n        QueryMsg::AllCollaterals { start_after, limit } => to_binary(&query_all_collaterals(\n            deps,\n            optional_addr_validate(deps.api, start_after)?,\n            limit,\n        )?),\n        QueryMsg::BorrowLimit {\n            borrower,\n            block_time,\n        } => to_binary(&query_borrow_limit(\n            deps,\n            deps.api.addr_validate(&borrower)?,\n            block_time,\n        )?),\n    }\n}\n\npub fn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let config: Config = read_config(deps.storage)?;\n    Ok(ConfigResponse {\n        owner_addr: deps.api.addr_humanize(&config.owner_addr)?.to_string(),\n        oracle_contract: deps.api.addr_humanize(&config.oracle_contract)?.to_string(),\n        market_contract: deps.api.addr_humanize(&config.market_contract)?.to_string(),\n        liquidation_contract: deps\n            .api\n            .addr_humanize(&config.liquidation_contract)?\n            .to_string(),\n        collector_contract: deps\n            .api\n            .addr_humanize(&config.collector_contract)?\n            .to_string(),\n        stable_denom: config.stable_denom,\n        epoch_period: config.epoch_period,\n        threshold_deposit_rate: config.threshold_deposit_rate,\n        target_deposit_rate: config.target_deposit_rate,\n        buffer_distribution_factor: config.buffer_distribution_factor,\n        anc_purchase_factor: config.anc_purchase_factor,\n        price_timeframe: config.price_timeframe,\n    })\n}\n\npub fn query_state(deps: Deps) -> StdResult<EpochState> {\n    read_epoch_state(deps.storage)\n}\n\npub fn query_whitelist(\n    deps: Deps,\n    collateral_token: Option<Addr>,\n    start_after: Option<Addr>,\n    limit: Option<u32>,\n) -> StdResult<WhitelistResponse> {\n    if let Some(collateral_token) = collateral_token {\n        let whitelist_elem: WhitelistElem = read_whitelist_elem(\n            deps.storage,\n            &deps.api.addr_canonicalize(collateral_token.as_str())?,\n        )?;\n        Ok(WhitelistResponse {\n            elems: vec![WhitelistResponseElem {\n                name: whitelist_elem.name,\n                symbol: whitelist_elem.symbol,\n                max_ltv: whitelist_elem.max_ltv,\n                custody_contract: deps\n                    .api\n                    .addr_humanize(&whitelist_elem.custody_contract)?\n                    .to_string(),\n                collateral_token: collateral_token.to_string(),\n            }],\n        })\n    } else {\n        let start_after = if let Some(start_after) = start_after {\n            Some(deps.api.addr_canonicalize(start_after.as_str())?)\n        } else {\n            None\n        };\n\n        let whitelist: Vec<WhitelistResponseElem> = read_whitelist(deps, start_after, limit)?;\n        Ok(WhitelistResponse { elems: whitelist })\n    }\n}"
    }
  ]
}