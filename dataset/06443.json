{
  "Title": "[H-14] User may underpay for the remote call `ExecutionGas` on the root chain",
  "Content": "\nUser may underpay for the remote call `ExecutionGas`. Meaning, the incorrect `minExecCost` is being deposited at the `_replenishGas` call inside `_payExecutionGas` function.\n\n### Proof of Concept\n\nMultichain contracts - `anycall` v7 lines:<br>\n<https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L265>\n<br><https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L167>\n<br><https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L276>\n\nUlysses-omnichain contract lines:\n<br><https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L811>\n<br><https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L851>\n\nThe user is paying the incorrect minimum execution cost for `Anycall Mutlichain` [L820](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L820), as the value of `minExecCost` is calculated incorrectly. The `AnycallV7` protocol considers a premium fee (`_feeData.premium`) on top of the TX gas price, which is not considered here.\n\nLet's get into the flow from the start. When `anyExec` is called by the executor ([L265](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L265)), the `anycall` request that comes from a source chain includes the `chargeDestFee` modifier.\n\n```Solidity\n    function anyExec(\n        address _to,\n        bytes calldata _data,\n        string calldata _appID,\n        RequestContext calldata _ctx,\n        bytes calldata _extdata\n    )\n        external\n        virtual\n        lock\n        whenNotPaused\n        chargeDestFee(_to, _ctx.flags)\n        onlyMPC\n    {\n        IAnycallConfig(config).checkExec(_appID, _ctx.from, _to);\n```\n\nNow, the `chargeDestFee` modifier will call the `chargeFeeOnDestChain` function as well at [L167](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L167).\n\n```Solidity\n/// @dev Charge an account for execution costs on this chain\n/// @param _from The account to charge for execution costs\n    modifier chargeDestFee(address _from, uint256 _flags) {\n        if (_isSet(_flags, AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {\n            uint256 _prevGasLeft = gasleft();\n            _;\n            IAnycallConfig(config).chargeFeeOnDestChain(_from, _prevGasLeft);\n        } else {\n            _;\n        }\n    }\n```\n\nAs you see here in [L198-L210](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Config.sol#L198C1-L210), inside the `chargeFeeOnDestChain` function includes `_feeData.premium` for the execution cost `totalCost`.\n\n```Solidity\nfunction chargeFeeOnDestChain(address _from, uint256 _prevGasLeft)\n        external\n        onlyAnycallContract\n    {\n        if (!_isSet(mode, FREE_MODE)) {\n            uint256 gasUsed = _prevGasLeft + EXECUTION_OVERHEAD - gasleft();\n            uint256 totalCost = gasUsed * (tx.gasprice + _feeData.premium);\n            uint256 budget = executionBudget[_from];\n            require(budget > totalCost, \"no enough budget\");\n            executionBudget[_from] = budget - totalCost;\n            _feeData.accruedFees += uint128(totalCost);\n        }\n    }\n```\n\nThe conclusion: the `minExecCost` calculation doesn't include `_feeData.premium` at [L811](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L811), according to the Multichain `AnycallV7` protocol.\n\nYou should include `_feeData.premium` in `minExecCost` as well. The same as in [L204](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Config.sol#L204).\n\n    uint256 totalCost = gasUsed * (tx.gasprice + _feeData.premium);\n\nThis also applicable on:<br>\n`_payFallbackGas()` in `RootBridgeAgent` at [L836](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L836).<br>\n`_payFallbackGas()` in `BranchBridgeAgent` at [L1066](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1066).<br>\n`_payExecutionGas` in `BranchBridgeAgent` at [L1032](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1032).\n\n### Recommended Mitigation Steps\n\nAdd `_feeData.premium` to `minExecCost` at the `_payExecutionGas` function [L811](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L811).\n\nYou need to get `_feeData.premium` first from `AnycallV7Config` by the `premium(`) function at [L286-L288](https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Config.sol#L286-L288).\n\n```\nuint256 minExecCost = (tx.gasprice  + _feeData.premium) * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft()));\n\n```\n\n**[0xBugsy (Maia) confirmed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/612#issuecomment-1655675080):**\n > We recognize the audit's findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "contracts/anycall/v7/AnycallV7Upgradeable.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.10;\n\nimport \"../../common/Initializable.sol\";\nimport \"./interfaces/IAnycallExecutor.sol\";\nimport \"./interfaces/IAnycallConfig.sol\";\nimport \"./interfaces/IAnycallProxy.sol\";\nimport \"./interfaces/AnycallFlags.sol\";\n\n/// anycall proxy is a universal protocal to complete cross-chain interaction.\n/// 1. the client call `AnycallV7Proxy::anyCall`\n///         on the originating chain\n///         to submit a request for a cross chain interaction\n/// 2. the mpc network verify the request and call `AnycallV7Proxy::anyExec`\n///         on the destination chain\n///         to execute a cross chain interaction (exec `IApp::anyExecute`)\n/// 3. if step 2 failed and step 1 has set allow fallback flags,\n///         then emit a `LogAnyCall` log on the destination chain\n///         to cause fallback on the originating chain (exec `IApp::anyFallback`)\ncontract AnyCallV7Upgradeable is IAnycallProxy, Initializable {\n    // Context of the request on originating chain\n    struct RequestContext {\n        bytes32 txhash;\n        address from;\n        uint256 fromChainID;\n        uint256 nonce;\n        uint256 flags;\n    }\n\n    // anycall version\n    string public constant ANYCALL_VERSION = \"v7.0\";\n\n    address public admin;\n    address public mpc;\n    address public pendingMPC;\n\n    bool public paused;\n\n    // applications should give permission to this executor\n    address public executor;\n\n    // anycall config contract\n    address public config;\n\n    mapping(bytes32 => bytes32) public retryExecRecords;\n    bool public retryWithPermit;\n\n    mapping(bytes32 => bool) public execCompleted;\n    uint256 nonce;\n\n    uint256 private unlocked;\n    modifier lock() {\n        require(unlocked == 1, \"locked\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    event LogAnyCall(\n        address indexed from,\n        address to,\n        bytes data,\n        uint256 toChainID,\n        uint256 flags,\n        string appID,\n        uint256 nonce,\n        bytes extdata\n    );\n    event LogAnyCall(\n        address indexed from,\n        string to,\n        bytes data,\n        uint256 toChainID,\n        uint256 flags,\n        string appID,\n        uint256 nonce,\n        bytes extdata\n    );\n\n    event LogAnyExec(\n        bytes32 indexed txhash,\n        address indexed from,\n        address indexed to,\n        uint256 fromChainID,\n        uint256 nonce,\n        bool success,\n        bytes result\n    );\n\n    event SetAdmin(address admin);\n    event SetExecutor(address executor);\n    event SetConfig(address config);\n    event SetRetryWithPermit(bool flag);\n    event SetPaused(bool paused);\n    event ChangeMPC(\n        address indexed oldMPC,\n        address indexed newMPC,\n        uint256 timestamp\n    );\n    event ApplyMPC(\n        address indexed oldMPC,\n        address indexed newMPC,\n        uint256 timestamp\n    );\n    event StoreRetryExecRecord(\n        bytes32 indexed txhash,\n        address indexed from,\n        address indexed to,\n        uint256 fromChainID,\n        uint256 nonce,\n        bytes data\n    );\n    event DoneRetryExecRecord(\n        bytes32 indexed txhash,\n        address indexed from,\n        uint256 fromChainID,\n        uint256 nonce\n    );\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _admin,\n        address _mpc,\n        address _executor,\n        address _config\n    ) external initializer {\n        require(_mpc != address(0), \"zero mpc address\");\n\n        unlocked = 1;\n\n        admin = _admin;\n        mpc = _mpc;\n        executor = _executor;\n        config = _config;\n\n        emit ApplyMPC(address(0), _mpc, block.timestamp);\n    }\n\n    /// @dev Access control function\n    modifier onlyMPC() {\n        require(msg.sender == mpc, \"only MPC\");\n        _;\n    }\n\n    /// @dev Access control function\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin\");\n        _;\n    }\n\n    /// @dev pausable control function\n    modifier whenNotPaused() {\n        require(!paused, \"paused\");\n        _;\n    }\n\n    /// @dev Charge an account for execution costs on this chain\n    /// @param _from The account to charge for execution costs\n    modifier chargeDestFee(address _from, uint256 _flags) {\n        if (_isSet(_flags, AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {\n            uint256 _prevGasLeft = gasleft();\n            _;\n            IAnycallConfig(config).chargeFeeOnDestChain(_from, _prevGasLeft);\n        } else {\n            _;\n        }\n    }\n\n    /// @dev pay fee on source chain and return remaining amount\n    function _paySrcFees(uint256 fees) internal {\n        require(msg.value >= fees, \"no enough src fee\");\n        if (fees > 0) {\n            // pay fees\n            (bool success, ) = mpc.call{value: fees}(\"\");\n            require(success);\n        }\n        if (msg.value > fees) {\n            // return remaining amount\n            (bool success, ) = msg.sender.call{value: msg.value - fees}(\"\");\n            require(success);\n        }\n    }\n\n    /**\n        @notice Submit a request for a cross chain interaction\n        @param _to The target to interact with on `_toChainID`\n        @param _data The calldata supplied for the interaction with `_to`\n        @param _toChainID The target chain id to interact with\n        @param _flags The flags of app on the originating chain\n        @param _extdata The extension data for call context\n    */\n    function anyCall(\n        address _to,\n        bytes calldata _data,\n        uint256 _toChainID,\n        uint256 _flags,\n        bytes calldata _extdata\n    ) external payable virtual whenNotPaused {\n        require(_flags < AnycallFlags.FLAG_EXEC_START_VALUE, \"invalid flags\");\n        (string memory _appID, uint256 _srcFees) = IAnycallConfig(config)\n            .checkCall(msg.sender, _data, _toChainID, _flags);\n\n        _paySrcFees(_srcFees);\n\n        nonce++;\n        emit LogAnyCall(\n            msg.sender,\n            _to,\n            _data,\n            _toChainID,\n            _flags,\n            _appID,\n            nonce,\n            _extdata\n        );\n    }\n\n    /**\n        @notice Submit a request for a cross chain interaction\n        @param _to The target to interact with on `_toChainID`\n        @param _data The calldata supplied for the interaction with `_to`\n        @param _toChainID The target chain id to interact with\n        @param _flags The flags of app on the originating chain\n        @param _extdata The extension data for call context\n    */\n    function anyCall(\n        string calldata _to,\n        bytes calldata _data,\n        uint256 _toChainID,\n        uint256 _flags,\n        bytes calldata _extdata\n    ) external payable virtual whenNotPaused {\n        require(_flags < AnycallFlags.FLAG_EXEC_START_VALUE, \"invalid flags\");\n        (string memory _appID, uint256 _srcFees) = IAnycallConfig(config)\n            .checkCall(msg.sender, _data, _toChainID, _flags);\n\n        _paySrcFees(_srcFees);\n\n        nonce++;\n        emit LogAnyCall(\n            msg.sender,\n            _to,\n            _data,\n            _toChainID,\n            _flags,\n            _appID,\n            nonce,\n            _extdata\n        );\n    }\n\n    /**\n        @notice Execute a cross chain interaction\n        @dev Only callable by the MPC\n        @param _to The cross chain interaction target\n        @param _data The calldata supplied for interacting with target\n        @param _appID The app identifier to check whitelist\n        @param _ctx The context of the request on originating chain\n        @param _extdata The extension data for execute context\n    */\n    function anyExec(\n        address _to,\n        bytes calldata _data,\n        string calldata _appID,\n        RequestContext calldata _ctx,\n        bytes calldata _extdata\n    )\n        external\n        virtual\n        lock\n        whenNotPaused\n        chargeDestFee(_to, _ctx.flags)\n        onlyMPC\n    {\n        IAnycallConfig(config).checkExec(_appID, _ctx.from, _to);\n\n        bytes32 uniqID = calcUniqID(\n            _ctx.txhash,\n            _ctx.from,\n            _ctx.fromChainID,\n            _ctx.nonce\n        );\n        require(!execCompleted[uniqID], \"exec completed\");\n\n        bool success = _execute(_to, _data, _ctx, _extdata);\n\n        // set exec completed (dont care success status)\n        execCompleted[uniqID] = true;\n\n        if (!success) {\n            if (_isSet(_ctx.flags, AnycallFlags.FLAG_ALLOW_FALLBACK)) {\n                // Call the fallback on the originating chain\n                nonce++;\n                string memory appID = _appID; // fix Stack too deep\n                emit LogAnyCall(\n                    _to,\n                    _ctx.from,\n                    _data,\n                    _ctx.fromChainID,\n                    AnycallFlags.FLAG_EXEC_FALLBACK | AnycallFlags.FLAG_PAY_FEE_ON_DEST, // pay fee on dest chain\n                    appID,\n                    nonce,\n                    \"\"\n                );\n            } else {\n                // Store retry record and emit a log\n                bytes memory data = _data; // fix Stack too deep\n                retryExecRecords[uniqID] = keccak256(abi.encode(_to, data));\n                emit StoreRetryExecRecord(\n                    _ctx.txhash,\n                    _ctx.from,\n                    _to,\n                    _ctx.fromChainID,\n                    _ctx.nonce,\n                    data\n                );\n            }\n        }\n    }\n\n    /// @notice execute through the executor (sandbox)\n    function _execute(\n        address _to,\n        bytes calldata _data,\n        RequestContext calldata _ctx,\n        bytes calldata _extdata\n    ) internal returns (bool success) {\n        bytes memory result;\n\n        try\n            IAnycallExecutor(executor).execute(\n                _to,\n                _data,\n                _ctx.from,\n                _ctx.fromChainID,\n                _ctx.nonce,\n                _ctx.flags,\n                _extdata\n            )\n        returns (bool succ, bytes memory res) {\n            (success, result) = (succ, res);\n        } catch Error(string memory reason) {\n            result = bytes(reason);\n        } catch (bytes memory reason) {\n            result = reason;\n        }\n\n        emit LogAnyExec(\n            _ctx.txhash,\n            _ctx.from,\n            _to,\n            _ctx.fromChainID,\n            _ctx.nonce,\n            success,\n            result\n        );\n    }\n\n    function _isSet(uint256 _value, uint256 _testBits)\n        internal\n        pure\n        returns (bool)\n    {\n        return (_value & _testBits) == _testBits;\n    }\n\n    /// @notice Calc unique ID\n    function calcUniqID(\n        bytes32 _txhash,\n        address _from,\n        uint256 _fromChainID,\n        uint256 _nonce\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_txhash, _from, _fromChainID, _nonce));\n    }\n\n    /// @notice Retry stored exec record\n    function retryExec(\n        bytes32 _txhash,\n        address _from,\n        uint256 _fromChainID,\n        uint256 _nonce,\n        address _to,\n        bytes calldata _data\n    ) external virtual lock {\n        require(!retryWithPermit || msg.sender == admin, \"no permit\");\n\n        bytes32 uniqID = calcUniqID(_txhash, _from, _fromChainID, _nonce);\n        require(execCompleted[uniqID], \"no exec\");\n        require(\n            retryExecRecords[uniqID] == keccak256(abi.encode(_to, _data)),\n            \"no retry record\"\n        );\n\n        // Clear record\n        delete retryExecRecords[uniqID];\n\n        (bool success, bytes memory result) = IAnycallExecutor(executor)\n            .execute(_to, _data, _from, _fromChainID, _nonce, AnycallFlags.FLAG_NONE, \"\");\n        require(success, string(result));\n\n        emit DoneRetryExecRecord(_txhash, _from, _fromChainID, _nonce);\n    }\n\n    /// @notice Set executor\n    function setExecutor(address _executor) external onlyMPC {\n        executor = _executor;\n        emit SetExecutor(_executor);\n    }\n\n    /// @notice Set Config\n    function setConfig(address _config) external onlyMPC {\n        config = _config;\n        emit SetConfig(_config);\n    }\n\n    /// @notice Change mpc\n    function changeMPC(address _mpc) external onlyMPC {\n        pendingMPC = _mpc;\n        emit ChangeMPC(mpc, _mpc, block.timestamp);\n    }\n\n    /// @notice Apply mpc\n    function applyMPC() external {\n        require(msg.sender == pendingMPC);\n        emit ApplyMPC(mpc, pendingMPC, block.timestamp);\n        mpc = pendingMPC;\n        pendingMPC = address(0);\n    }\n\n    /// @notice Set admin\n    function setAdmin(address _admin) external onlyMPC {\n        admin = _admin;\n        emit SetAdmin(_admin);\n    }\n\n    /// @dev set paused flag to pause/unpause functions\n    function setPaused(bool _paused) external onlyAdmin {\n        paused = _paused;\n        emit SetPaused(_paused);\n    }\n\n    /// @notice Set retryWithPermit\n    function setRetryWithPermit(bool _flag) external onlyAdmin {\n        retryWithPermit = _flag;\n        emit SetRetryWithPermit(_flag);\n    }\n}"
    },
    {
      "filename": "contracts/anycall/v7/AnycallV7Upgradeable.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.10;\n\nimport \"../../common/Initializable.sol\";\nimport \"./interfaces/IAnycallExecutor.sol\";\nimport \"./interfaces/IAnycallConfig.sol\";\nimport \"./interfaces/IAnycallProxy.sol\";\nimport \"./interfaces/AnycallFlags.sol\";\n\n/// anycall proxy is a universal protocal to complete cross-chain interaction.\n/// 1. the client call `AnycallV7Proxy::anyCall`\n///         on the originating chain\n///         to submit a request for a cross chain interaction\n/// 2. the mpc network verify the request and call `AnycallV7Proxy::anyExec`\n///         on the destination chain\n///         to execute a cross chain interaction (exec `IApp::anyExecute`)\n/// 3. if step 2 failed and step 1 has set allow fallback flags,\n///         then emit a `LogAnyCall` log on the destination chain\n///         to cause fallback on the originating chain (exec `IApp::anyFallback`)\ncontract AnyCallV7Upgradeable is IAnycallProxy, Initializable {\n    // Context of the request on originating chain\n    struct RequestContext {\n        bytes32 txhash;\n        address from;\n        uint256 fromChainID;\n        uint256 nonce;\n        uint256 flags;\n    }\n\n    // anycall version\n    string public constant ANYCALL_VERSION = \"v7.0\";\n\n    address public admin;\n    address public mpc;\n    address public pendingMPC;\n\n    bool public paused;\n\n    // applications should give permission to this executor\n    address public executor;\n\n    // anycall config contract\n    address public config;\n\n    mapping(bytes32 => bytes32) public retryExecRecords;\n    bool public retryWithPermit;\n\n    mapping(bytes32 => bool) public execCompleted;\n    uint256 nonce;\n\n    uint256 private unlocked;\n    modifier lock() {\n        require(unlocked == 1, \"locked\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    event LogAnyCall(\n        address indexed from,\n        address to,\n        bytes data,\n        uint256 toChainID,\n        uint256 flags,\n        string appID,\n        uint256 nonce,\n        bytes extdata\n    );\n    event LogAnyCall(\n        address indexed from,\n        string to,\n        bytes data,\n        uint256 toChainID,\n        uint256 flags,\n        string appID,\n        uint256 nonce,\n        bytes extdata\n    );\n\n    event LogAnyExec(\n        bytes32 indexed txhash,\n        address indexed from,\n        address indexed to,\n        uint256 fromChainID,\n        uint256 nonce,\n        bool success,\n        bytes result\n    );\n\n    event SetAdmin(address admin);\n    event SetExecutor(address executor);\n    event SetConfig(address config);\n    event SetRetryWithPermit(bool flag);\n    event SetPaused(bool paused);\n    event ChangeMPC(\n        address indexed oldMPC,\n        address indexed newMPC,\n        uint256 timestamp\n    );\n    event ApplyMPC(\n        address indexed oldMPC,\n        address indexed newMPC,\n        uint256 timestamp\n    );\n    event StoreRetryExecRecord(\n        bytes32 indexed txhash,\n        address indexed from,\n        address indexed to,\n        uint256 fromChainID,\n        uint256 nonce,\n        bytes data\n    );\n    event DoneRetryExecRecord(\n        bytes32 indexed txhash,\n        address indexed from,\n        uint256 fromChainID,\n        uint256 nonce\n    );\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _admin,\n        address _mpc,\n        address _executor,\n        address _config\n    ) external initializer {\n        require(_mpc != address(0), \"zero mpc address\");\n\n        unlocked = 1;\n\n        admin = _admin;\n        mpc = _mpc;\n        executor = _executor;\n        config = _config;\n\n        emit ApplyMPC(address(0), _mpc, block.timestamp);\n    }\n\n    /// @dev Access control function\n    modifier onlyMPC() {\n        require(msg.sender == mpc, \"only MPC\");\n        _;\n    }\n\n    /// @dev Access control function\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin\");\n        _;\n    }\n\n    /// @dev pausable control function\n    modifier whenNotPaused() {\n        require(!paused, \"paused\");\n        _;\n    }\n\n    /// @dev Charge an account for execution costs on this chain\n    /// @param _from The account to charge for execution costs\n    modifier chargeDestFee(address _from, uint256 _flags) {\n        if (_isSet(_flags, AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {\n            uint256 _prevGasLeft = gasleft();\n            _;\n            IAnycallConfig(config).chargeFeeOnDestChain(_from, _prevGasLeft);\n        } else {\n            _;\n        }\n    }\n\n    /// @dev pay fee on source chain and return remaining amount\n    function _paySrcFees(uint256 fees) internal {\n        require(msg.value >= fees, \"no enough src fee\");\n        if (fees > 0) {\n            // pay fees\n            (bool success, ) = mpc.call{value: fees}(\"\");\n            require(success);\n        }\n        if (msg.value > fees) {\n            // return remaining amount\n            (bool success, ) = msg.sender.call{value: msg.value - fees}(\"\");\n            require(success);\n        }\n    }\n\n    /**\n        @notice Submit a request for a cross chain interaction\n        @param _to The target to interact with on `_toChainID`\n        @param _data The calldata supplied for the interaction with `_to`\n        @param _toChainID The target chain id to interact with\n        @param _flags The flags of app on the originating chain\n        @param _extdata The extension data for call context\n    */\n    function anyCall(\n        address _to,\n        bytes calldata _data,\n        uint256 _toChainID,\n        uint256 _flags,\n        bytes calldata _extdata\n    ) external payable virtual whenNotPaused {\n        require(_flags < AnycallFlags.FLAG_EXEC_START_VALUE, \"invalid flags\");\n        (string memory _appID, uint256 _srcFees) = IAnycallConfig(config)\n            .checkCall(msg.sender, _data, _toChainID, _flags);\n\n        _paySrcFees(_srcFees);\n\n        nonce++;\n        emit LogAnyCall(\n            msg.sender,\n            _to,\n            _data,\n            _toChainID,\n            _flags,\n            _appID,\n            nonce,\n            _extdata\n        );\n    }\n\n    /**\n        @notice Submit a request for a cross chain interaction\n        @param _to The target to interact with on `_toChainID`\n        @param _data The calldata supplied for the interaction with `_to`\n        @param _toChainID The target chain id to interact with\n        @param _flags The flags of app on the originating chain\n        @param _extdata The extension data for call context\n    */\n    function anyCall(\n        string calldata _to,\n        bytes calldata _data,\n        uint256 _toChainID,\n        uint256 _flags,\n        bytes calldata _extdata\n    ) external payable virtual whenNotPaused {\n        require(_flags < AnycallFlags.FLAG_EXEC_START_VALUE, \"invalid flags\");\n        (string memory _appID, uint256 _srcFees) = IAnycallConfig(config)\n            .checkCall(msg.sender, _data, _toChainID, _flags);\n\n        _paySrcFees(_srcFees);\n\n        nonce++;\n        emit LogAnyCall(\n            msg.sender,\n            _to,\n            _data,\n            _toChainID,\n            _flags,\n            _appID,\n            nonce,\n            _extdata\n        );\n    }\n\n    /**\n        @notice Execute a cross chain interaction\n        @dev Only callable by the MPC\n        @param _to The cross chain interaction target\n        @param _data The calldata supplied for interacting with target\n        @param _appID The app identifier to check whitelist\n        @param _ctx The context of the request on originating chain\n        @param _extdata The extension data for execute context\n    */\n    function anyExec(\n        address _to,\n        bytes calldata _data,\n        string calldata _appID,\n        RequestContext calldata _ctx,\n        bytes calldata _extdata\n    )\n        external\n        virtual\n        lock\n        whenNotPaused\n        chargeDestFee(_to, _ctx.flags)\n        onlyMPC\n    {\n        IAnycallConfig(config).checkExec(_appID, _ctx.from, _to);\n\n        bytes32 uniqID = calcUniqID(\n            _ctx.txhash,\n            _ctx.from,\n            _ctx.fromChainID,\n            _ctx.nonce\n        );\n        require(!execCompleted[uniqID], \"exec completed\");\n\n        bool success = _execute(_to, _data, _ctx, _extdata);\n\n        // set exec completed (dont care success status)\n        execCompleted[uniqID] = true;\n\n        if (!success) {\n            if (_isSet(_ctx.flags, AnycallFlags.FLAG_ALLOW_FALLBACK)) {\n                // Call the fallback on the originating chain\n                nonce++;\n                string memory appID = _appID; // fix Stack too deep\n                emit LogAnyCall(\n                    _to,\n                    _ctx.from,\n                    _data,\n                    _ctx.fromChainID,\n                    AnycallFlags.FLAG_EXEC_FALLBACK | AnycallFlags.FLAG_PAY_FEE_ON_DEST, // pay fee on dest chain\n                    appID,\n                    nonce,\n                    \"\"\n                );\n            } else {\n                // Store retry record and emit a log\n                bytes memory data = _data; // fix Stack too deep\n                retryExecRecords[uniqID] = keccak256(abi.encode(_to, data));\n                emit StoreRetryExecRecord(\n                    _ctx.txhash,\n                    _ctx.from,\n                    _to,\n                    _ctx.fromChainID,\n                    _ctx.nonce,\n                    data\n                );\n            }\n        }\n    }\n\n    /// @notice execute through the executor (sandbox)\n    function _execute(\n        address _to,\n        bytes calldata _data,\n        RequestContext calldata _ctx,\n        bytes calldata _extdata\n    ) internal returns (bool success) {\n        bytes memory result;\n\n        try\n            IAnycallExecutor(executor).execute(\n                _to,\n                _data,\n                _ctx.from,\n                _ctx.fromChainID,\n                _ctx.nonce,\n                _ctx.flags,\n                _extdata\n            )\n        returns (bool succ, bytes memory res) {\n            (success, result) = (succ, res);\n        } catch Error(string memory reason) {\n            result = bytes(reason);\n        } catch (bytes memory reason) {\n            result = reason;\n        }\n\n        emit LogAnyExec(\n            _ctx.txhash,\n            _ctx.from,\n            _to,\n            _ctx.fromChainID,\n            _ctx.nonce,\n            success,\n            result\n        );\n    }\n\n    function _isSet(uint256 _value, uint256 _testBits)\n        internal\n        pure\n        returns (bool)\n    {\n        return (_value & _testBits) == _testBits;\n    }\n\n    /// @notice Calc unique ID\n    function calcUniqID(\n        bytes32 _txhash,\n        address _from,\n        uint256 _fromChainID,\n        uint256 _nonce\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_txhash, _from, _fromChainID, _nonce));\n    }\n\n    /// @notice Retry stored exec record\n    function retryExec(\n        bytes32 _txhash,\n        address _from,\n        uint256 _fromChainID,\n        uint256 _nonce,\n        address _to,\n        bytes calldata _data\n    ) external virtual lock {\n        require(!retryWithPermit || msg.sender == admin, \"no permit\");\n\n        bytes32 uniqID = calcUniqID(_txhash, _from, _fromChainID, _nonce);\n        require(execCompleted[uniqID], \"no exec\");\n        require(\n            retryExecRecords[uniqID] == keccak256(abi.encode(_to, _data)),\n            \"no retry record\"\n        );\n\n        // Clear record\n        delete retryExecRecords[uniqID];\n\n        (bool success, bytes memory result) = IAnycallExecutor(executor)\n            .execute(_to, _data, _from, _fromChainID, _nonce, AnycallFlags.FLAG_NONE, \"\");\n        require(success, string(result));\n\n        emit DoneRetryExecRecord(_txhash, _from, _fromChainID, _nonce);\n    }\n\n    /// @notice Set executor\n    function setExecutor(address _executor) external onlyMPC {\n        executor = _executor;\n        emit SetExecutor(_executor);\n    }\n\n    /// @notice Set Config\n    function setConfig(address _config) external onlyMPC {\n        config = _config;\n        emit SetConfig(_config);\n    }\n\n    /// @notice Change mpc\n    function changeMPC(address _mpc) external onlyMPC {\n        pendingMPC = _mpc;\n        emit ChangeMPC(mpc, _mpc, block.timestamp);\n    }\n\n    /// @notice Apply mpc\n    function applyMPC() external {\n        require(msg.sender == pendingMPC);\n        emit ApplyMPC(mpc, pendingMPC, block.timestamp);\n        mpc = pendingMPC;\n        pendingMPC = address(0);\n    }\n\n    /// @notice Set admin\n    function setAdmin(address _admin) external onlyMPC {\n        admin = _admin;\n        emit SetAdmin(_admin);\n    }\n\n    /// @dev set paused flag to pause/unpause functions\n    function setPaused(bool _paused) external onlyAdmin {\n        paused = _paused;\n        emit SetPaused(_paused);\n    }\n\n    /// @notice Set retryWithPermit\n    function setRetryWithPermit(bool _flag) external onlyAdmin {\n        retryWithPermit = _flag;\n        emit SetRetryWithPermit(_flag);\n    }\n}"
    },
    {
      "filename": "contracts/anycall/v7/AnycallV7Upgradeable.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.10;\n\nimport \"../../common/Initializable.sol\";\nimport \"./interfaces/IAnycallExecutor.sol\";\nimport \"./interfaces/IAnycallConfig.sol\";\nimport \"./interfaces/IAnycallProxy.sol\";\nimport \"./interfaces/AnycallFlags.sol\";\n\n/// anycall proxy is a universal protocal to complete cross-chain interaction.\n/// 1. the client call `AnycallV7Proxy::anyCall`\n///         on the originating chain\n///         to submit a request for a cross chain interaction\n/// 2. the mpc network verify the request and call `AnycallV7Proxy::anyExec`\n///         on the destination chain\n///         to execute a cross chain interaction (exec `IApp::anyExecute`)\n/// 3. if step 2 failed and step 1 has set allow fallback flags,\n///         then emit a `LogAnyCall` log on the destination chain\n///         to cause fallback on the originating chain (exec `IApp::anyFallback`)\ncontract AnyCallV7Upgradeable is IAnycallProxy, Initializable {\n    // Context of the request on originating chain\n    struct RequestContext {\n        bytes32 txhash;\n        address from;\n        uint256 fromChainID;\n        uint256 nonce;\n        uint256 flags;\n    }\n\n    // anycall version\n    string public constant ANYCALL_VERSION = \"v7.0\";\n\n    address public admin;\n    address public mpc;\n    address public pendingMPC;\n\n    bool public paused;\n\n    // applications should give permission to this executor\n    address public executor;\n\n    // anycall config contract\n    address public config;\n\n    mapping(bytes32 => bytes32) public retryExecRecords;\n    bool public retryWithPermit;\n\n    mapping(bytes32 => bool) public execCompleted;\n    uint256 nonce;\n\n    uint256 private unlocked;\n    modifier lock() {\n        require(unlocked == 1, \"locked\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    event LogAnyCall(\n        address indexed from,\n        address to,\n        bytes data,\n        uint256 toChainID,\n        uint256 flags,\n        string appID,\n        uint256 nonce,\n        bytes extdata\n    );\n    event LogAnyCall(\n        address indexed from,\n        string to,\n        bytes data,\n        uint256 toChainID,\n        uint256 flags,\n        string appID,\n        uint256 nonce,\n        bytes extdata\n    );\n\n    event LogAnyExec(\n        bytes32 indexed txhash,\n        address indexed from,\n        address indexed to,\n        uint256 fromChainID,\n        uint256 nonce,\n        bool success,\n        bytes result\n    );\n\n    event SetAdmin(address admin);\n    event SetExecutor(address executor);\n    event SetConfig(address config);\n    event SetRetryWithPermit(bool flag);\n    event SetPaused(bool paused);\n    event ChangeMPC(\n        address indexed oldMPC,\n        address indexed newMPC,\n        uint256 timestamp\n    );\n    event ApplyMPC(\n        address indexed oldMPC,\n        address indexed newMPC,\n        uint256 timestamp\n    );\n    event StoreRetryExecRecord(\n        bytes32 indexed txhash,\n        address indexed from,\n        address indexed to,\n        uint256 fromChainID,\n        uint256 nonce,\n        bytes data\n    );\n    event DoneRetryExecRecord(\n        bytes32 indexed txhash,\n        address indexed from,\n        uint256 fromChainID,\n        uint256 nonce\n    );\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _admin,\n        address _mpc,\n        address _executor,\n        address _config\n    ) external initializer {\n        require(_mpc != address(0), \"zero mpc address\");\n\n        unlocked = 1;\n\n        admin = _admin;\n        mpc = _mpc;\n        executor = _executor;\n        config = _config;\n\n        emit ApplyMPC(address(0), _mpc, block.timestamp);\n    }\n\n    /// @dev Access control function\n    modifier onlyMPC() {\n        require(msg.sender == mpc, \"only MPC\");\n        _;\n    }\n\n    /// @dev Access control function\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin\");\n        _;\n    }\n\n    /// @dev pausable control function\n    modifier whenNotPaused() {\n        require(!paused, \"paused\");\n        _;\n    }\n\n    /// @dev Charge an account for execution costs on this chain\n    /// @param _from The account to charge for execution costs\n    modifier chargeDestFee(address _from, uint256 _flags) {\n        if (_isSet(_flags, AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {\n            uint256 _prevGasLeft = gasleft();\n            _;\n            IAnycallConfig(config).chargeFeeOnDestChain(_from, _prevGasLeft);\n        } else {\n            _;\n        }\n    }\n\n    /// @dev pay fee on source chain and return remaining amount\n    function _paySrcFees(uint256 fees) internal {\n        require(msg.value >= fees, \"no enough src fee\");\n        if (fees > 0) {\n            // pay fees\n            (bool success, ) = mpc.call{value: fees}(\"\");\n            require(success);\n        }\n        if (msg.value > fees) {\n            // return remaining amount\n            (bool success, ) = msg.sender.call{value: msg.value - fees}(\"\");\n            require(success);\n        }\n    }\n\n    /**\n        @notice Submit a request for a cross chain interaction\n        @param _to The target to interact with on `_toChainID`\n        @param _data The calldata supplied for the interaction with `_to`\n        @param _toChainID The target chain id to interact with\n        @param _flags The flags of app on the originating chain\n        @param _extdata The extension data for call context\n    */\n    function anyCall(\n        address _to,\n        bytes calldata _data,\n        uint256 _toChainID,\n        uint256 _flags,\n        bytes calldata _extdata\n    ) external payable virtual whenNotPaused {\n        require(_flags < AnycallFlags.FLAG_EXEC_START_VALUE, \"invalid flags\");\n        (string memory _appID, uint256 _srcFees) = IAnycallConfig(config)\n            .checkCall(msg.sender, _data, _toChainID, _flags);\n\n        _paySrcFees(_srcFees);\n\n        nonce++;\n        emit LogAnyCall(\n            msg.sender,\n            _to,\n            _data,\n            _toChainID,\n            _flags,\n            _appID,\n            nonce,\n            _extdata\n        );\n    }\n\n    /**\n        @notice Submit a request for a cross chain interaction\n        @param _to The target to interact with on `_toChainID`\n        @param _data The calldata supplied for the interaction with `_to`\n        @param _toChainID The target chain id to interact with\n        @param _flags The flags of app on the origina"
    }
  ]
}