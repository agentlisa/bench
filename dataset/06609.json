{
  "Title": "[G-01] State variables only set in the constructor should be declared immutable",
  "Content": "The solidity compiler will directly embed the values of immutable variables into your contract bytecode and therefore will save you from incurring a `Gsset (20000 gas)` when you set storage variables in the constructor; a `Gcoldsload (2100 gas)` when you access storage variables for the first time in a transaction, and a `Gwarmaccess (100 gas)` for each subsequent access to that storage slot.\n\nTotal Instances: `1`\n\nEstimated Gas Saved: `1 * 2100 = 2100`\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/BaseJumpRateModelV2.sol#L18\n\n```solidity\nFile: contracts/BaseJumpRateModelV2.sol\n18:    IAccessControlManagerV8 public accessControlManager;\n```diff\ndiff --git a/contracts/BaseJumpRateModelV2.sol b/contracts/BaseJumpRateModelV2.sol\nindex 68b535a..bd83624 100644\n--- a/contracts/BaseJumpRateModelV2.sol\n+++ b/contracts/BaseJumpRateModelV2.sol\n@@ -15,7 +15,7 @@ abstract contract BaseJumpRateModelV2 is InterestRateModel {\n     /**\n      * @notice The address of the AccessControlManager contract\n      */\n-    IAccessControlManagerV8 public accessControlManager;\n+    IAccessControlManagerV8 public immutable accessControlManager;\n\n     /**\n      * @notice The approximate number of blocks per year that is assumed by the interest rate model\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/BaseJumpRateModelV2.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Logic for Compound's JumpRateModel Contract V2.\n * @author Compound (modified by Dharma Labs, refactored by Arr00)\n * @notice Version 2 modifies Version 1 by enabling updateable parameters.\n */\nabstract contract BaseJumpRateModelV2 is InterestRateModel {\n    uint256 private constant BASE = 1e18;\n\n    /**\n     * @notice The address of the AccessControlManager contract\n     */\n    IAccessControlManagerV8 public accessControlManager;\n\n    /**\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n    uint256 public constant blocksPerYear = 10512000;\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint256 public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint256 public baseRatePerBlock;\n\n    /**\n     * @notice The multiplierPerBlock after hitting a specified utilization point\n     */\n    uint256 public jumpMultiplierPerBlock;\n\n    /**\n     * @notice The utilization point at which the jump multiplier is applied\n     */\n    uint256 public kink;\n\n    event NewInterestParams(\n        uint256 baseRatePerBlock,\n        uint256 multiplierPerBlock,\n        uint256 jumpMultiplierPerBlock,\n        uint256 kink\n    );\n\n    /**\n     * @notice Thrown when the action is prohibited by AccessControlManager\n     */\n    error Unauthorized(address sender, address calledContract, string methodSignature);\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param accessControlManager_ The address of the AccessControlManager contract\n     */\n    constructor(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_,\n        IAccessControlManagerV8 accessControlManager_\n    ) {\n        require(address(accessControlManager_) != address(0), \"invalid ACM address\");\n\n        accessControlManager = accessControlManager_;\n\n        _updateJumpRateModel(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    /**\n     * @notice Update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @custom:error Unauthorized if the sender is not allowed to call this function\n     * @custom:access Controlled by AccessControlManager\n     */\n    function updateJumpRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) external virtual {\n        string memory signature = \"updateJumpRateModel(uint256,uint256,uint256,uint256)\";\n        bool isAllowedToCall = accessControlManager.isAllowedToCall(msg.sender, signature);\n\n        if (!isAllowedToCall) {\n            revert Unauthorized(msg.sender, address(this), signature);\n        }\n\n        _updateJumpRateModel(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by BASE)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) public view virtual override returns (uint256) {\n        uint256 oneMinusReserveFactor = BASE - reserveFactorMantissa;\n        uint256 borrowRate = _getBorrowRate(cash, borrows, reserves);\n        uint256 rateToPool = (borrowRate * oneMinusReserveFactor) / BASE;\n        return (utilizationRate(cash, borrows, reserves) * rateToPool) / BASE;\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, BASE]\n     */\n    function utilizationRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public pure returns (uint256) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return (borrows * BASE) / (cash + borrows - reserves);\n    }\n\n    /**\n     * @notice Internal function to update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function _updateJumpRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) internal {\n        baseRatePerBlock = baseRatePerYear / blocksPerYear;\n        multiplierPerBlock = (multiplierPerYear * BASE) / (blocksPerYear * kink_);\n        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\n        kink = kink_;\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\n     */\n    function _getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) internal view returns (uint256) {\n        uint256 util = utilizationRate(cash, borrows, reserves);\n\n        if (util <= kink) {\n            return ((util * multiplierPerBlock) / BASE) + baseRatePerBlock;\n        } else {\n            uint256 normalRate = ((kink * multiplierPerBlock) / BASE) + baseRatePerBlock;\n            uint256 excessUtil;\n            unchecked {\n                excessUtil = util - kink;\n            }\n            return ((excessUtil * jumpMultiplierPerBlock) / BASE) + normalRate;\n        }\n    }\n}"
    }
  ]
}