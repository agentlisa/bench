{
  "Title": "[N-17]  Interfaces should be indicated with an `I` prefix in the contract name",
  "Content": "\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/vault/adapter/yearn/IYearn.sol\n\n8:    interface VaultAPI is IERC20 {\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/yearn/IYearn.sol#L8\n\n\n___\n\n## Excluded Low Risk Findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness\n\n| |Issue|Instances|\n|-|:-|:-:|\n| [L&#x2011;09] | Unsafe use of `transfer()`/`transferFrom()` with `IERC20` | 1 | \n| [L&#x2011;10] | Return values of `transfer()`/`transferFrom()` not checked | 1 | \n| [L&#x2011;11] | `safeApprove()` is deprecated | 1 | \n| [L&#x2011;12] | Missing checks for `address(0x0)` when assigning values to `address` state variables | 1 | \n\nTotal: 4 instances over 4 issues\n\n### [L&#x2011;09]  Unsafe use of `transfer()`/`transferFrom()` with `IERC20`\nSome tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens.  For example Tether (USDT)'s `transfer()` and `transferFrom()` functions on L1 do not return booleans as the specification requires, and instead have no return value. When these sorts of tokens are cast to `IERC20`, their [function signatures](https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca) do not match and therefore the calls made, revert (see [this](https://gist.github.com/IllIllI000/2b00a32e8f0559e8f386ea4f1800abc5) link for a test case). Use OpenZeppelinâ€™s `SafeERC20`'s `safeTransfer()`/`safeTransferFrom()` instead\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/vault/VaultController.sol\n\n/// @audit (valid but excluded finding)\n457:        IERC20(rewardsToken).transferFrom(msg.sender, address(adminProxy), amount);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L457\n\n### [L&#x2011;10]  Return values of `transfer()`/`transferFrom()` not checked\nNot all `IERC20` implementations `revert()` when there's a failure in `transfer()`/`transferFrom()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/vault/VaultController.sol\n\n/// @audit (valid but excluded finding)\n457:        IERC20(rewardsToken).transferFrom(msg.sender, address(adminProxy), amount);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L457\n\n### [L&#x2011;11]  `safeApprove()` is deprecated\n[Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead. The function may currently work, but if a bug is found in this version of OpenZeppelin, and the version that you're forced to upgrade to no longer has this function, you'll encounter unnecessary delays in porting and testing replacement contracts.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/utils/MultiRewardStaking.sol\n\n/// @audit (valid but excluded finding)\n271:        rewardToken.safeApprove(address(escrow), type(uint256).max);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L271\n\n### [L&#x2011;12]  Missing checks for `address(0x0)` when assigning values to `address` state variables\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/utils/MultiRewardEscrow.sol\n\n/// @audit (valid but excluded finding)\n31:       feeRecipient = _feeRecipient;\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardEscrow.sol#L31\n\n## Excluded Non-Critical Findings\n\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness\n\n| |Issue|Instances|\n|-|:-|:-:|\n| [N&#x2011;18] | Return values of `approve()` not checked | 5 | \n| [N&#x2011;19] | `public` functions not called by the contract should be declared `external` instead | 4 | \n| [N&#x2011;20] | Event is missing `indexed` fields | 27 | \n\nTotal: 36 instances over 3 issues\n\n### [N&#x2011;18]  Return values of `approve()` not checked\nNot all `IERC20` implementations `revert()` when there's a failure in `approve()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually approving anything\n\n*There are 5 instances of this issue:*\n\n```solidity\nFile: src/vault/adapter/beefy/BeefyAdapter.sol\n\n/// @audit (valid but excluded finding)\n80:           IERC20(asset()).approve(_beefyVault, type(uint256).max);\n\n/// @audit (valid but excluded finding)\n83:               IERC20(_beefyVault).approve(_beefyBooster, type(uint256).max);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/beefy/BeefyAdapter.sol#L80\n\n```solidity\nFile: src/vault/adapter/yearn/YearnAdapter.sol\n\n/// @audit (valid but excluded finding)\n54:           IERC20(_asset).approve(address(yVault), type(uint256).max);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/yearn/YearnAdapter.sol#L54\n\n```solidity\nFile: src/vault/VaultController.sol\n\n/// @audit (valid but excluded finding)\n171:        asset.approve(address(target), initialDeposit);\n\n/// @audit (valid but excluded finding)\n456:        IERC20(rewardsToken).approve(staking, type(uint256).max);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L171\n\n### [N&#x2011;19]  `public` functions not called by the contract should be declared `external` instead\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: src/vault/Vault.sol\n\n/// @audit (valid but excluded finding)\n323       function previewDeposit(uint256 assets)\n324           public\n325           view\n326:          returns (uint256 shares)\n\n/// @audit (valid but excluded finding)\n340:      function previewMint(uint256 shares) public view returns (uint256 assets) {\n\n/// @audit (valid but excluded finding)\n380       function previewRedeem(uint256 shares)\n381           public\n382           view\n383:          returns (uint256 assets)\n\n/// @audit (valid but excluded finding)\n399:      function maxDeposit(address caller) public view returns (uint256) {\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L323-L326\n\n### [N&#x2011;20]  Event is missing `indexed` fields\nIndex event fields make the field more quickly accessible [to off-chain tools](https://ethereum.stackexchange.com/questions/40396/can-somebody-please-explain-the-concept-of-event-indexing) that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n*There are 27 instances of this issue:*\n\n```solidity\nFile: src/interfaces/vault/IERC4626.sol\n\n/// @audit (valid but excluded finding)\n8:      event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/interfaces/vault/IERC4626.sol#L8\n\n```solidity\nFile: src/utils/MultiRewardEscrow.sol\n\n/// @audit (valid but excluded finding)\n73:     event Locked(IERC20 indexed token, address indexed account, uint256 amount, uint32 duration, uint32 offset);\n\n/// @audit (valid but excluded finding)\n136:    event RewardsClaimed(IERC20 indexed token, address indexed account, uint256 amount);\n\n/// @audit (valid but excluded finding)\n196:    event FeeSet(IERC20 indexed token, uint256 amount);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardEscrow.sol#L73\n\n```solidity\nFile: src/utils/MultiRewardStaking.sol\n\n/// @audit (valid but excluded finding)\n159:    event RewardsClaimed(address indexed user, IERC20 rewardToken, uint256 amount, bool escrowed);\n\n/// @audit (valid but excluded finding)\n220:    event RewardInfoUpdate(IERC20 rewardToken, uint160 rewardsPerSecond, uint32 rewardsEndTimestamp);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L159\n\n```solidity\nFile: src/vault/adapter/abstracts/AdapterBase.sol\n\n/// @audit (valid but excluded finding)\n491:      event HarvestCooldownChanged(uint256 oldCooldown, uint256 newCooldown);\n\n/// @audit (valid but excluded finding)\n519:      event PerformanceFeeChanged(uint256 oldFee, uint256 newFee);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L491\n\n```solidity\nFile: src/vault/CloneRegistry.sol\n\n/// @audit (valid but excluded finding)\n33:     event CloneAdded(address clone);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/CloneRegistry.sol#L33\n\n```solidity\nFile: src/vault/PermissionRegistry.sol\n\n/// @audit (valid but excluded finding)\n28:     event PermissionSet(address target, bool newEndorsement, bool newRejection);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/PermissionRegistry.sol#L28\n\n```solidity\nFile: src/vault/TemplateRegistry.sol\n\n/// @audit (valid but excluded finding)\n38:     event TemplateCategoryAdded(bytes32 templateCategory);\n\n/// @audit (valid but excluded finding)\n39:     event TemplateAdded(bytes32 templateCategory, bytes32 templateId, address implementation);\n\n/// @audit (valid but excluded finding)\n40:     event TemplateUpdated(bytes32 templateCategory, bytes32 templateId);\n\n/// @audit (valid but excluded finding)\n88      event TemplateEndorsementToggled(\n89        bytes32 templateCategory,\n90        bytes32 templateId,\n91        bool oldEndorsement,\n92        bool newEndorsement\n93:     );\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/TemplateRegistry.sol#L38\n\n```solidity\nFile: src/vault/VaultController.sol\n\n/// @audit (valid but excluded finding)\n741:    event PerformanceFeeChanged(uint256 oldFee, uint256 newFee);\n\n/// @audit (valid but excluded finding)\n781:    event HarvestCooldownChanged(uint256 oldCooldown, uint256 newCooldown);\n\n/// @audit (valid but excluded finding)\n824:    event DeploymentControllerChanged(address oldController, address newController);\n\n/// @audit (valid but excluded finding)\n853:    event ActiveTemplateIdChanged(bytes32 oldKey, bytes32 newKey);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L741\n\n```solidity\nFile: src/vault/VaultRegistry.sol\n\n/// @audit (valid but excluded finding)\n36:     event VaultAdded(address vaultAddress, string metadataCID);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultRegistry.sol#L36\n\n```solidity\nFile: src/vault/Vault.sol\n\n/// @audit (valid but excluded finding)\n42:       event VaultInitialized(bytes32 contractName, address indexed asset);\n\n/// @audit (valid but excluded finding)\n108       event Deposit(\n109           address indexed caller,\n110           address indexed owner,\n111           uint256 assets,\n112           uint256 shares\n113:      );\n\n/// @audit (valid but excluded finding)\n512:      event NewFeesProposed(VaultFees newFees, uint256 timestamp);\n\n/// @audit (valid but excluded finding)\n513:      event ChangedFees(VaultFees oldFees, VaultFees newFees);\n\n/// @audit (valid but excluded finding)\n514:      event FeeRecipientUpdated(address oldFeeRecipient, address newFeeRecipient);\n\n/// @audit (valid but excluded finding)\n569:      event NewAdapterProposed(IERC4626 newAdapter, uint256 timestamp);\n\n/// @audit (valid but excluded finding)\n570:      event ChangedAdapter(IERC4626 oldAdapter, IERC4626 newAdapter);\n\n/// @audit (valid but excluded finding)\n621:      event QuitPeriodSet(uint256 quitPeriod);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L42\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/vault/adapter/yearn/IYearn.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport { IERC20Upgradeable as IERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface VaultAPI is IERC20 {\n  function deposit(uint256 amount) external returns (uint256);\n\n  function withdraw(uint256 maxShares) external returns (uint256);\n\n  function pricePerShare() external view returns (uint256);\n\n  function totalAssets() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function depositLimit() external view returns (uint256);\n\n  function token() external view returns (address);\n\n  function lastReport() external view returns (uint256);\n\n  function lockedProfit() external view returns (uint256);\n\n  function lockedProfitDegradation() external view returns (uint256);\n\n  function totalDebt() external view returns (uint256);\n}\n\ninterface IYearnRegistry {\n  function latestVault(address token) external view returns (address);\n}"
    },
    {
      "filename": "src/vault/VaultController.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\npragma solidity ^0.8.15;\n\nimport { SafeERC20Upgradeable as SafeERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { Owned } from \"../utils/Owned.sol\";\nimport { IVault, VaultInitParams, VaultFees } from \"../interfaces/vault/IVault.sol\";\nimport { IMultiRewardStaking } from \"../interfaces/IMultiRewardStaking.sol\";\nimport { IMultiRewardEscrow } from \"../interfaces/IMultiRewardEscrow.sol\";\nimport { IDeploymentController, ICloneRegistry } from \"../interfaces/vault/IDeploymentController.sol\";\nimport { ITemplateRegistry, Template } from \"../interfaces/vault/ITemplateRegistry.sol\";\nimport { IPermissionRegistry, Permission } from \"../interfaces/vault/IPermissionRegistry.sol\";\nimport { IVaultRegistry, VaultMetadata } from \"../interfaces/vault/IVaultRegistry.sol\";\nimport { IAdminProxy } from \"../interfaces/vault/IAdminProxy.sol\";\nimport { IERC4626, IERC20 } from \"../interfaces/vault/IERC4626.sol\";\nimport { IStrategy } from \"../interfaces/vault/IStrategy.sol\";\nimport { IAdapter } from \"../interfaces/vault/IAdapter.sol\";\nimport { IPausable } from \"../interfaces/IPausable.sol\";\nimport { DeploymentArgs } from \"../interfaces/vault/IVaultController.sol\";\n\n/**\n * @title   VaultController\n * @author  RedVeil\n * @notice  Admin contract for the vault ecosystem.\n *\n * Deploys Vaults, Adapter, Strategies and Staking contracts.\n * Calls admin functions on deployed contracts.\n */\ncontract VaultController is Owned {\n  using SafeERC20 for IERC20;\n\n  /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n  bytes32 public immutable VAULT = \"Vault\";\n  bytes32 public immutable ADAPTER = \"Adapter\";\n  bytes32 public immutable STRATEGY = \"Strategy\";\n  bytes32 public immutable STAKING = \"Staking\";\n  bytes4 internal immutable DEPLOY_SIG = bytes4(keccak256(\"deploy(bytes32,bytes32,bytes)\"));\n\n  error UnderlyingError(bytes revertReason);\n\n  /**\n   * @notice Constructor of this contract.\n   * @param _owner Owner of the contract. Controls management functions.\n   * @param _adminProxy `AdminProxy` ownes contracts in the vault ecosystem.\n   * @param _deploymentController `DeploymentController` with auxiliary deployment contracts.\n   * @param _vaultRegistry `VaultRegistry` to safe vault metadata.\n   * @param _permissionRegistry `permissionRegistry` to add endorsements and rejections.\n   * @param _escrow `MultiRewardEscrow` To escrow rewards of staking contracts.\n   */\n  constructor(\n    address _owner,\n    IAdminProxy _adminProxy,\n    IDeploymentController _deploymentController,\n    IVaultRegistry _vaultRegistry,\n    IPermissionRegistry _permissionRegistry,\n    IMultiRewardEscrow _escrow\n  ) Owned(_owner) {\n    adminProxy = _adminProxy;\n    vaultRegistry = _vaultRegistry;\n    permissionRegistry = _permissionRegistry;\n    escrow = _escrow;\n\n    _setDeploymentController(_deploymentController);\n\n    activeTemplateId[STAKING] = \"MultiRewardStaking\";\n    activeTemplateId[VAULT] = \"V1\";\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          VAULT DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  event VaultDeployed(address indexed vault, address indexed staking, address indexed adapter);\n\n  /**\n   * @notice Deploy a new Vault. Optionally with an Adapter and Staking. Caller must be owner.\n   * @param vaultData Vault init params.\n   * @param adapterData Encoded adapter init data.\n   * @param strategyData Encoded strategy init data.\n   * @param staking Address of staking contract to use for the vault. If 0, a new staking contract will be deployed.\n   * @param rewardsData Encoded data to add a rewards to the staking contract\n   * @param metadata Vault metadata for the `VaultRegistry` (Will be used by the frontend for additional informations)\n   * @param initialDeposit Initial deposit to the vault. If 0, no deposit will be made.\n   * @dev This function is the one stop solution to create a new vault with all necessary admin functions or auxiliery contracts.\n   */\n  function deployVault(\n    VaultInitParams memory vaultData,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    address staking,\n    bytes memory rewardsData,\n    VaultMetadata memory metadata,\n    uint256 initialDeposit\n  ) external canCreate returns (address vault) {\n    IDeploymentController _deploymentController = deploymentController;\n\n    _verifyToken(address(vaultData.asset));\n    _verifyAdapterConfiguration(address(vaultData.adapter), adapterData.id);\n\n    if (adapterData.id > 0)\n      vaultData.adapter = IERC4626(_deployAdapter(vaultData.asset, adapterData, strategyData, _deploymentController));\n\n    vault = _deployVault(vaultData, _deploymentController);\n\n    if (staking == address(0)) staking = _deployStaking(IERC20(address(vault)), _deploymentController);\n\n    _registerCreatedVault(vault, staking, metadata);\n\n    if (rewardsData.length > 0) _handleVaultStakingRewards(vault, rewardsData);\n\n    emit VaultDeployed(vault, staking, address(vaultData.adapter));\n\n    _handleInitialDeposit(initialDeposit, IERC20(vaultData.asset), IERC4626(vault));\n  }\n\n  /// @notice Deploys a new vault contract using the `activeTemplateId`.\n  function _deployVault(VaultInitParams memory vaultData, IDeploymentController _deploymentController)\n    internal\n    returns (address vault)\n  {\n    vaultData.owner = address(adminProxy);\n\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(\n        DEPLOY_SIG,\n        VAULT,\n        activeTemplateId[VAULT],\n        abi.encodeWithSelector(IVault.initialize.selector, vaultData)\n      )\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    vault = abi.decode(returnData, (address));\n  }\n\n  /// @notice Registers newly created vault metadata.\n  function _registerCreatedVault(\n    address vault,\n    address staking,\n    VaultMetadata memory metadata\n  ) internal {\n    metadata.vault = vault;\n    metadata.staking = staking;\n    metadata.creator = msg.sender;\n\n    _registerVault(vault, metadata);\n  }\n\n  /// @notice Prepares and calls `addStakingRewardsTokens` for the newly created staking contract.\n  function _handleVaultStakingRewards(address vault, bytes memory rewardsData) internal {\n    address[] memory vaultContracts = new address[](1);\n    bytes[] memory rewardsDatas = new bytes[](1);\n\n    vaultContracts[0] = vault;\n    rewardsDatas[0] = rewardsData;\n\n    addStakingRewardsTokens(vaultContracts, rewardsDatas);\n  }\n\n  function _handleInitialDeposit(\n    uint256 initialDeposit,\n    IERC20 asset,\n    IERC4626 target\n  ) internal {\n    if (initialDeposit > 0) {\n      asset.safeTransferFrom(msg.sender, address(this), initialDeposit);\n      asset.approve(address(target), initialDeposit);\n      target.deposit(initialDeposit, msg.sender);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      ADAPTER DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Deploy a new Adapter with our without a strategy. Caller must be owner.\n   * @param asset Asset which will be used by the adapter.\n   * @param adapterData Encoded adapter init data.\n   * @param strategyData Encoded strategy init data.\n   */\n  function deployAdapter(\n    IERC20 asset,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    uint256 initialDeposit\n  ) external canCreate returns (address adapter) {\n    _verifyToken(address(asset));\n\n    adapter = _deployAdapter(asset, adapterData, strategyData, deploymentController);\n\n    _handleInitialDeposit(initialDeposit, asset, IERC4626(adapter));\n  }\n\n  /**\n   * @notice Deploys an adapter and optionally a strategy.\n   * @dev Adds the newly deployed strategy to the adapter.\n   */\n  function _deployAdapter(\n    IERC20 asset,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    IDeploymentController _deploymentController\n  ) internal returns (address) {\n    address strategy;\n    bytes4[8] memory requiredSigs;\n    if (strategyData.id > 0) {\n      strategy = _deployStrategy(strategyData, _deploymentController);\n      requiredSigs = templateRegistry.getTemplate(STRATEGY, strategyData.id).requiredSigs;\n    }\n\n    return\n      __deployAdapter(\n        adapterData,\n        abi.encode(asset, address(adminProxy), IStrategy(strategy), harvestCooldown, requiredSigs, strategyData.data),\n        _deploymentController\n      );\n  }\n\n  /// @notice Deploys an adapter and sets the management fee via `AdminProxy`\n  function __deployAdapter(\n    DeploymentArgs memory adapterData,\n    bytes memory baseAdapterData,\n    IDeploymentController _deploymentController\n  ) internal returns (address adapter) {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(DEPLOY_SIG, ADAPTER, adapterData.id, _encodeAdapterData(adapterData, baseAdapterData))\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    adapter = abi.decode(returnData, (address));\n\n    adminProxy.execute(adapter, abi.encodeWithSelector(IAdapter.setPerformanceFee.selector, performanceFee));\n  }\n\n  /// @notice Encodes adapter init call. Was moved into its own function to fix \"stack too deep\" error.\n  function _encodeAdapterData(DeploymentArgs memory adapterData, bytes memory baseAdapterData)\n    internal\n    returns (bytes memory)\n  {\n    return\n      abi.encodeWithSelector(\n        IAdapter.initialize.selector,\n        baseAdapterData,\n        templateRegistry.getTemplate(ADAPTER, adapterData.id).registry,\n        adapterData.data\n      );\n  }\n\n  /// @notice Deploys a new strategy contract.\n  function _deployStrategy(DeploymentArgs memory strategyData, IDeploymentController _deploymentController)\n    internal\n    returns (address strategy)\n  {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(DEPLOY_SIG, STRATEGY, strategyData.id, \"\")\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    strategy = abi.decode(returnData, (address));\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    STAKING DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Deploy a new staking contract. Caller must be owner.\n   * @param asset The staking token for the new contract.\n   * @dev Deploys `MultiRewardsStaking` based on the latest templateTemplateKey.\n   */\n  function deployStaking(IERC20 asset) external canCreate returns (address) {\n    _verifyToken(address(asset));\n    return _deployStaking(asset, deploymentController);\n  }\n\n  /// @notice Deploys a new staking contract using the activeTemplateId.\n  function _deployStaking(IERC20 asset, IDeploymentController _deploymentController)\n    internal\n    returns (address staking)\n  {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(\n        DEPLOY_SIG,\n        STAKING,\n        activeTemplateId[STAKING],\n        abi.encodeWithSelector(IMultiRewardStaking.initialize.selector, asset, escrow, adminProxy)\n      )\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    staking = abi.decode(returnData, (address));\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    VAULT MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  error DoesntExist(address adapter);\n\n  /**\n   * @notice Propose a new Adapter. Caller must be creator of the vaults.\n   * @param vaults Vaults to propose the new adapter for.\n   * @param newAdapter New adapters to propose.\n   */\n  function proposeVaultAdapters(address[] calldata vaults, IERC4626[] calldata newAdapter) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, newAdapter.length);\n\n    ICloneRegistry _cloneRegistry = cloneRegistry;\n    for (uint8 i = 0; i < len; i++) {\n      _verifyCreator(vaults[i]);\n      if (!_cloneRegistry.cloneExists(address(newAdapter[i]))) revert DoesntExist(address(newAdapter[i]));\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.proposeAdapter.selector, newAdapter[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Change adapter of a vault to the previously proposed adapter.\n   * @param vaults Addresses of the vaults to change\n   */\n  function changeVaultAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint8 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.changeAdapter.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Sets new fees per vault. Caller must be creator of the vaults.\n   * @param vaults Addresses of the vaults to change\n   * @param fees New fee structures for these vaults\n   * @dev Value is in 1e18, e.g. 100% = 1e18 - 1 BPS = 1e12\n   */\n  function proposeVaultFees(address[] calldata vaults, VaultFees[] calldata fees) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, fees.length);\n\n    for (uint8 i = 0; i < len; i++) {\n      _verifyCreator(vaults[i]);\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.proposeFees.selector, fees[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Change adapter of a vault to the previously proposed adapter.\n   * @param vaults Addresses of the vaults\n   */\n  function changeVaultFees(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint8 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.changeFees.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          REGISTER VAULT\n    //////////////////////////////////////////////////////////////*/\n\n  IVaultRegistry public vaultRegistry;\n\n  /// @notice Call the `VaultRegistry` to register a vault via `AdminProxy`\n  function _registerVault(address vault, VaultMetadata memory metadata) internal {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(vaultRegistry),\n      abi.encodeWithSelector(IVaultRegistry.registerVault.selector, metadata)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    ENDORSEMENT / REJECTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Set permissions for an array of target. Caller must be owner.\n   * @param targets `AdminProxy`\n   * @param newPermissions An array of permissions to set for the targets.\n   * @dev See `PermissionRegistry` for more details\n   */\n  function setPermissions(address[] calldata targets, Permission[] calldata newPermissions) external onlyOwner {\n    // No need to check matching array length since its already done in the permissionRegistry\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(permissionRegistry),\n      abi.encodeWithSelector(IPermissionRegistry.setPermissions.selector, targets, newPermissions)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      STAKING MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Adds a new rewardToken which can be earned via staking. Caller must be creator of the Vault or owner.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokenData Token that can be earned by staking.\n   * @dev `rewardToken` - Token that can be earned by staking.\n   * @dev `rewardsPerSecond` - The rate in which `rewardToken` will be accrued.\n   * @dev `amount` - Initial funding amount for this reward.\n   * @dev `useEscrow Bool` - if the rewards should be escrowed on claim.\n   * @dev `escrowPercentage` - The percentage of the reward that gets escrowed in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev `escrowDuration` - The duration of the escrow.\n   * @dev `offset` - A cliff after claim before the escrow starts.\n   * @dev See `MultiRewardsStaking` for more details.\n   */\n  function addStakingRewardsTokens(address[] memory vaults, bytes[] memory rewardTokenData) public {\n    _verifyEqualArrayLength(vaults.length, rewardTokenData.length);\n    address staking;\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      (\n        address rewardsToken,\n        uint160 rewardsPerSecond,\n        uint256 amount,\n        bool useEscrow,\n        uint224 escrowDuration,\n        uint24 escrowPercentage,\n        uint256 offset\n      ) = abi.decode(rewardTokenData[i], (address, uint160, uint256, bool, uint224, uint24, uint256));\n      _verifyToken(rewardsToken);\n      staking = _verifyCreatorOrOwner(vaults[i]).staking;\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        rewardsToken,\n        abi.encodeWithSelector(IERC20.approve.selector, staking, type(uint256).max)\n      );\n      if (!success) revert UnderlyingError(returnData);\n\n      IERC20(rewardsToken).approve(staking, type(uint256).max);\n      IERC20(rewardsToken).transferFrom(msg.sender, address(adminProxy), amount);\n\n      (success, returnData) = adminProxy.execute(\n        staking,\n        abi.encodeWithSelector(\n          IMultiRewardStaking.addRewardToken.selector,\n          rewardsToken,\n          rewardsPerSecond,\n          amount,\n          useEscrow,\n          escrowDuration,\n          escrowPercentage,\n          offset\n        )\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Changes rewards speed for a rewardToken. This works only for rewards that accrue over time. Caller must be creator of the Vault.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokens Token that can be earned by staking.\n   * @param rewardsSpeeds The rate in which `rewardToken` will be accrued.\n   * @dev See `MultiRewardsStaking` for more details.\n   */\n  function changeStakingRewardsSpeeds(\n    address[] calldata vaults,\n    IERC20[] calldata rewardTokens,\n    uint160[] calldata rewardsSpeeds\n  ) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, rewardTokens.length);\n    _verifyEqualArrayLength(len, rewardsSpeeds.length);\n\n    address staking;\n    for (uint256 i = 0; i < len; i++) {\n      staking = _verifyCreator(vaults[i]).staking;\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        staking,\n        abi.encodeWithSelector(IMultiRewardStaking.changeRewardSpeed.selector, rewardTokens[i], rewardsSpeeds[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Funds rewards for a rewardToken.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokens Token that can be earned by staking.\n   * @param amounts The amount of rewardToken that will fund this reward.\n   * @dev See `MultiRewardStaking` for more details.\n   */\n  function fundStakingRewards(\n    address[] calldata vaults,\n    IERC20[] calldata rewardTokens,\n    uint256[] calldata amounts\n  ) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, rewardTokens.length);\n    _verifyEqualArrayLength(len, amounts.length);\n\n    address staking;\n    for (uint256 i = 0; i < len; i++) {\n      staking = vaultRegistry.getVault(vaults[i]).staking;\n\n      rewardTokens[i].transferFrom(msg.sender, address(this), amounts[i]);\n      IMultiRewardStaking(staking).fundReward(rewardTokens[i], amounts[i]);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      ESCROW MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IMultiRewardEscrow public escrow;\n\n  /**\n   * @notice Set fees for multiple tokens. Caller must be the owner.\n   * @param tokens Array of tokens.\n   * @param fees Array of fees for `tokens` in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev See `MultiRewardEscrow` for more details.\n   */\n  function setEscrowTokenFees(IERC20[] calldata tokens, uint256[] calldata fees) external onlyOwner {\n    _verifyEqualArrayLength(tokens.length, fees.length);\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(escrow),\n      abi.encodeWithSelector(IMultiRewardEscrow.setFees.selector, tokens, fees)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          TEMPLATE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a new templateCategory to the registry. Caller must be owner.\n   * @param templateCategories A new category of templates.\n   * @dev See `TemplateRegistry` for more details.\n   */\n  function addTemplateCategories(bytes32[] calldata templateCategories) external onlyOwner {\n    address _deploymentController = address(deploymentController);\n    uint8 len = uint8(templateCategories.length);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        _deploymentController,\n        abi.encodeWithSelector(IDeploymentController.addTemplateCategory.selector, templateCategories[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Toggles the endorsement of a templates. Caller must be owner.\n   * @param templateCategories TemplateCategory of the template to endorse.\n   * @param templateIds TemplateId of the template to endorse.\n   * @dev See `TemplateRegistry` for more details.\n   */\n  function toggleTemplateEndorsements(bytes32[] calldata templateCategories, bytes32[] calldata templateIds)\n    external\n    onlyOwner\n  {\n    uint8 len = uint8(templateCategories.length);\n    _verifyEqualArrayLength(len, templateIds.length);\n\n    address _deploymentController = address(deploymentController);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        address(_deploymentController),\n        abi.encodeWithSelector(\n          ITemplateRegistry.toggleTemplateEndorsement.selector,\n          templateCategories[i],\n          templateIds[i]\n        )\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          PAUSING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Pause Deposits and withdraw all funds from the underlying protocol. Caller must be owner or creator of the Vault.\n  function pauseAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        IVault(vaults[i]).adapter(),\n        abi.encodeWithSelector(IPausable.pause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Pause deposits. Caller must be owner or creator of the Vault.\n  function pauseVaults(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IPausable.pause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Unpause Deposits and deposit all funds into the underlying protocol. Caller must be owner or creator of the Vault.\n  function unpauseAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        IVault(vaults[i]).adapter(),\n        abi.encodeWithSelector(IPausable.unpause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Unpause deposits. Caller must be owner or creator of the Vault.\n  function unpauseVaults(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IPausable.unpause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                       VERIFICATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  error NotSubmitterNorOwner(address caller);\n  error NotSubmitter(address caller);\n  error NotAllowed(address subject);\n  error AdapterConfigFaulty();\n  error ArrayLengthMissmatch();\n\n  /// @notice Verify that the caller is the creator of the vault or owner of `VaultController` (admin rights).\n  function _verifyCreatorOrOwner(address vault) internal returns (VaultMetadata memory metadata) {\n    metadata = vaultRegistry.getVault(vault);\n    if (msg.sender != metadata.creator || msg.sender != owner) revert NotSubmitterNorOwner(msg.sender);\n  }\n\n  /// @notice Verify that the caller is the creator of the vault.\n  function _verifyCreator(address vault) internal view returns (VaultMetadata memory metadata) {\n    metadata = vaultRegistry.getVault(vault);\n    if (msg.sender != metadata.creator) revert NotSubmitter(msg.sender);\n  }\n\n  /// @notice Verify that the token is not rejected nor a clone.\n  function _verifyToken(address token) internal view {\n    if (\n      (\n        permissionRegistry.endorsed(address(0))\n          ? !permissionRegistry.endorsed(token)\n          : permissionRegistry.rejected(token)\n      ) ||\n      cloneRegistry.cloneExists(token) ||\n      token == address(0)\n    ) revert NotAllowed(token);\n  }\n\n  /// @notice Verify that the adapter configuration is valid.\n  function _verifyAdapterConfiguration(address adapter, bytes32 adapterId) internal view {\n    if (adapter != address(0)) {\n      if (adapterId > 0) revert AdapterConfigFaulty();\n      if (!cloneRegistry.cloneExists(adapter)) revert AdapterConfigFaulty();\n    }\n  }\n\n  /// @notice Verify that the array lengths are equal.\n  function _verifyEqualArrayLength(uint256 length1, uint256 length2) internal pure {\n    if (length1 != length2) revert ArrayLengthMissmatch();\n  }\n\n  modifier canCreate() {\n    if (\n      permissionRegistry.endorsed(address(1))\n        ? !permissionRegistry.endorsed(msg.sender)\n        : permissionRegistry.rejected(msg.sender)\n    ) revert NotAllowed(msg.sender);\n    _;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IAdminProxy public adminProxy;\n\n  /**\n   * @notice Nominates a new owner of `AdminProxy`. Caller must be owner.\n   * @dev Must be called if the `VaultController` gets swapped out or upgraded\n   */\n  function nominateNewAdminProxyOwner(address newOwner) external onlyOwner {\n    adminProxy.nominateNewOwner(newOwner);\n  }\n\n  /**\n   * @notice Accepts ownership of `AdminProxy`. Caller must be nominated owner.\n   * @dev Must be called after construction\n   */\n  function acceptAdminProxyOwnership() external {\n    adminProxy.acceptOwnership();\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          MANAGEMENT FEE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  uint256 public performanceFee;\n\n  event PerformanceFeeChanged(uint256 oldFee, uint256 newFee);\n\n  error InvalidPerformanceFee(uint256 fee);\n\n  /**\n   * @notice Set a new performanceFee for all new adapters. Caller must be owner.\n   * @param newFee performance fee in 1e18.\n   * @dev Fees can be 0 but never more than 2e17 (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev Can be retroactively applied to existing adapters.\n   */\n  function setPerformanceFee(uint256 newFee) external onlyOwner {\n    // Dont take more than 20% performanceFee\n    if (newFee > 2e17) revert InvalidPerformanceFee(newFee);\n\n    emit PerformanceFeeChanged(performanceFee, newFee);\n\n    performanceFee = newFee;\n  }\n\n  /**\n   * @notice Set a new performanceFee for existing adapters. Caller must be owner.\n   * @param adapters array of adapters to set the management fee for.\n   */\n  function setAdapterPerformanceFees(address[] calldata adapters) external onlyOwner {\n    uint8 len = uint8(adapters.length);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        adapters[i],\n        abi.encodeWithSelector(IAdapter.setPerformanceFee.selector, performanceFee)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          HARVEST COOLDOWN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  uint256 public harvestCooldown;\n\n  event HarvestCooldownChanged(uint256 oldCooldown, uint256 newCooldown);\n\n  error InvalidHarvestCooldown(uint256 cooldown);\n\n  /**\n   * @notice Set a new harvestCooldown for all new adapters. Caller must be owner.\n   * @param newCooldown Time in seconds that must pass before a harvest can be called again.\n   * @dev Cant be longer than 1 day.\n   * @dev Can be retroactively applied to existing adapters.\n   */\n  function setHarvestCooldown(uint256 newCooldown) external onlyOwner {\n    // Dont wait more than X seconds\n    if (newCooldown > 1 days) revert InvalidHarvestCooldown(newCooldown);\n\n    emit HarvestCooldownChanged(harvestCooldown, newCooldown);\n\n    harvestCooldown = newCooldown;\n  }\n\n  /**\n   * @notice Set a new harvestCooldown for existing adapters. Caller must be owner.\n   * @param adapters Array of adapters to set the cooldown for.\n   */\n  function setAdapterHarvestCooldowns(address[] calldata adapters) external onlyOwner {\n    uint8 len = uint8(adapters.length);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        adapters[i],\n        abi.encodeWithSelector(IAdapter.setHarvestCooldown.selector, harvestCooldown)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      DEPLYOMENT CONTROLLER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IDeploymentController public deploymentController;\n  ICloneRegistry public cloneRegistry;\n  ITemplateRegistry public templateRegistry;\n  IPermissionRegistry public permissionRegistry;\n\n  event DeploymentControllerChanged(address oldController, address newCo"
    }
  ]
}