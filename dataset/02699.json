{
  "Title": "M-3: `FeeBuyback` native token can not be rescued",
  "Content": "# Issue M-3: `FeeBuyback` native token can not be rescued \n\nSource: https://github.com/sherlock-audit/2022-11-telcoin-judging/issues/80 \n\n## Found by \nWATCHPUG\n\n## Summary\n\nLack of methods to rescue native tokens trapped in the `FeeBuyback` contract.\n\n## Vulnerability Detail\n\nLike ERC20 tokens, the native token may also get stuck in the `FeeBuyback` contract for all sorts of reasons.\n\nFor example, at L77, the `_aggregator` is called with a `msg.value`, which means that the native token can be used as an inToken for the swap. Therefore, part of the input native token can be sent back to the FeeBuyback contract as a leftover.\n\nHowever, the current implementation of `rescueERC20()` only supports rescue ERC20 tokens.\n\n## Impact\n\nThe leftover native tokens trapped in the contract can not be rescued.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/fee-buyback/FeeBuyback.sol#L77-L78\n\nhttps://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/fee-buyback/FeeBuyback.sol#L94-L97\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding support to rescue native tokens.\n\n## Discussion\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-staking/pull/10\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/25",
  "Code": [
    {
      "filename": "contracts/fee-buyback/FeeBuyback.sol",
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\n//imports\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./TieredOwnership.sol\";\nimport \"./IFeeBuyback.sol\";\nimport \"./ISimplePlugin.sol\";\n\n/**\n * @title FeeBuyback\n * @author Amir Shirif, Telcoin, LLC.\n * @notice Helps facilitate a secondary swap, if required, to allow the referrer of a user to receive a fraction of the generated transaction fee, based on the stake of the referrer.\n */\ncontract FeeBuyback is IFeeBuyback, TieredOwnership {\n  //MATIC address\n  address constant public MATIC = 0x0000000000000000000000000000000000001010;\n  //1 inch aggregator address\n  address immutable public _aggregator;\n  //location of fee rewards\n  address immutable public _safe;\n  //reward token\n  IERC20 immutable public _telcoin;\n  //destination of rewards\n  ISimplePlugin immutable public _referral;\n\n  //constructor\n  constructor(address aggregator_, address safe_, IERC20 telcoin_, ISimplePlugin referral_) TieredOwnership() {\n    _aggregator = aggregator_;\n    _safe = safe_;\n    _telcoin = telcoin_;\n    _referral = referral_;\n  }\n\n  /**\n   * @notice submits wallet transactions\n   * @dev a secondary swap may occur\n   * @dev staking contract updates may be made\n   * @dev function can be paused\n   * @param wallet address of the primary transaction\n   * @param walletData bytes wallet data for primary transaction\n   * @param token address the token that is being swapped from in a secondary transaction\n   * @param amount uint256 the quantity of the token being swapped\n   * @param swapData bytes swap data from primary transaction\n   * @return boolean representing if a referral transaction was made\n   */\n  function submit(address wallet, bytes memory walletData, address token, address recipient, uint256 amount, bytes memory swapData) external override payable onlyOwner() returns (bool) {\n    //Perform user swap first\n    //Verify success\n    (bool walletResult,) = wallet.call{value: 0}(walletData);\n    require(walletResult, \"FeeBuyback: wallet transaction failed\");\n\n    //check if this is a referral transaction\n    //if not exit execution\n    if (token == address(0) || recipient == address(0) || amount == 0 ) {\n      return false;\n    }\n\n    //if swapped token is in TEL, no swap is necessary\n    //do simple transfer from and submit\n    if (token == address(_telcoin)) {\n      _telcoin.transferFrom(_safe, address(this), amount);\n      _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n      require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n      return true;\n    }\n\n    //MATIC does not allow for approvals\n    //ERC20s only\n    if (token != MATIC) {\n      IERC20(token).transferFrom(_safe, address(this), amount);\n      IERC20(token).approve(_aggregator, amount);\n    }\n\n    //Perform secondary swap from fee token to TEL\n    //do simple transfer from and submit\n    (bool swapResult,) = _aggregator.call{value: msg.value}(swapData);\n    require(swapResult, \"FeeBuyback: swap transaction failed\");\n    _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n    require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n    return true;\n  }\n\n  /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Only an owner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n  * Emits a {Transfer} event.\n  */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyExecutor() returns (bool) {\n    IERC20(externalToken).transfer(account, amount);\n    return true;\n  }\n}"
    },
    {
      "filename": "contracts/fee-buyback/FeeBuyback.sol",
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\n//imports\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./TieredOwnership.sol\";\nimport \"./IFeeBuyback.sol\";\nimport \"./ISimplePlugin.sol\";\n\n/**\n * @title FeeBuyback\n * @author Amir Shirif, Telcoin, LLC.\n * @notice Helps facilitate a secondary swap, if required, to allow the referrer of a user to receive a fraction of the generated transaction fee, based on the stake of the referrer.\n */\ncontract FeeBuyback is IFeeBuyback, TieredOwnership {\n  //MATIC address\n  address constant public MATIC = 0x0000000000000000000000000000000000001010;\n  //1 inch aggregator address\n  address immutable public _aggregator;\n  //location of fee rewards\n  address immutable public _safe;\n  //reward token\n  IERC20 immutable public _telcoin;\n  //destination of rewards\n  ISimplePlugin immutable public _referral;\n\n  //constructor\n  constructor(address aggregator_, address safe_, IERC20 telcoin_, ISimplePlugin referral_) TieredOwnership() {\n    _aggregator = aggregator_;\n    _safe = safe_;\n    _telcoin = telcoin_;\n    _referral = referral_;\n  }\n\n  /**\n   * @notice submits wallet transactions\n   * @dev a secondary swap may occur\n   * @dev staking contract updates may be made\n   * @dev function can be paused\n   * @param wallet address of the primary transaction\n   * @param walletData bytes wallet data for primary transaction\n   * @param token address the token that is being swapped from in a secondary transaction\n   * @param amount uint256 the quantity of the token being swapped\n   * @param swapData bytes swap data from primary transaction\n   * @return boolean representing if a referral transaction was made\n   */\n  function submit(address wallet, bytes memory walletData, address token, address recipient, uint256 amount, bytes memory swapData) external override payable onlyOwner() returns (bool) {\n    //Perform user swap first\n    //Verify success\n    (bool walletResult,) = wallet.call{value: 0}(walletData);\n    require(walletResult, \"FeeBuyback: wallet transaction failed\");\n\n    //check if this is a referral transaction\n    //if not exit execution\n    if (token == address(0) || recipient == address(0) || amount == 0 ) {\n      return false;\n    }\n\n    //if swapped token is in TEL, no swap is necessary\n    //do simple transfer from and submit\n    if (token == address(_telcoin)) {\n      _telcoin.transferFrom(_safe, address(this), amount);\n      _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n      require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n      return true;\n    }\n\n    //MATIC does not allow for approvals\n    //ERC20s only\n    if (token != MATIC) {\n      IERC20(token).transferFrom(_safe, address(this), amount);\n      IERC20(token).approve(_aggregator, amount);\n    }\n\n    //Perform secondary swap from fee token to TEL\n    //do simple transfer from and submit\n    (bool swapResult,) = _aggregator.call{value: msg.value}(swapData);\n    require(swapResult, \"FeeBuyback: swap transaction failed\");\n    _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n    require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n    return true;\n  }\n\n  /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Only an owner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n  * Emits a {Transfer} event.\n  */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyExecutor() returns (bool) {\n    IERC20(externalToken).transfer(account, amount);\n    return true;\n  }\n}"
    }
  ]
}