{
  "Title": "M-2: No deadline and slippage check on `takeOverDebt()` can lead to unexpected results",
  "Content": "# Issue M-2: No deadline and slippage check on `takeOverDebt()` can lead to unexpected results \n\nSource: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/51 \n\n## Found by \nHHK\n\nThe function [`takeOverDebt()`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L395) in the LiquidityBorrowingManager contract doesn't have any deadline check like [`borrow`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L465) or [`repay`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L532).\n\nAdditionally it also doesn't have any \"slippage\" check that would make sure the position hasn't changed between the moment a user calls [`takeOverDebt()`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L395) and the transaction is confirmed.\n\n## Vulnerability Detail\n\nBlockchains are asynchronous by nature, when sending a transaction, the contract targeted can see its state changed affecting the result of our transaction.\n\nWhen a user wants to call [`takeOverDebt()`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L395) he expects that the debt he is gonna take over will be the same (or very close) as when he signed the transaction.\n\nBy not providing any deadline check, if the transaction is not confirmed for a long time then the user might end up with a position that is not as interesting as it was.\n\nTake this example:\n\n- A position on Ethereum is in debt of collateral but the borrowed tokens are at profit and the user think the token's price is going to keep increasing, it makes sense to take over.\n- The user makes a transaction to take over.\n- The gas price rise and the transaction takes longer than he thoughts to be confirmed.\n- Eventually the transaction is confirmed but the position is not in profit anymore because price changed during that time.\n- User paid the debt of the position for nothing as he won't be making profits.\n\nAdditionally when the collateral of a position is negative, lenders can call [`repay()`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L532) as part of the \"emergency liquidity restoration mode\" which will reduce the size of the position. If this happens while another user is taking over the debt then he might end up with a position that is not as interesting as he thoughts.\n\nTake this second example:\n\n- A position on Ethereum with 2 loans is in debt of collateral but the borrowed tokens are at profit and the user think the token's price is going to keep increasing, it makes sense to take over.\n- The user makes a transaction to take over.\n- While the user's transaction is in the MEMPOOL a lender call ['repay()'](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L532) and get back his tokens.\n- The user's transaction is confirmed and he take over the position but it only has 1 loan now as one of the 2 loans was sent back to the lender. the position might not be at profit anymore or less than it was supposed to be.\n- User paid the debt of the position for nothing as he won't be making profits.\n\n## Impact\n\nMedium. User might pay collateral debt of a position for nothing.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L395\n\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L581\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding the modifier `checkDeadline()` as well as a parameter `minBorrowedAmount` and compare it to the current `borrowedAmount` to make sure no lender repaid their position during the take over.\n\n\n\n## Discussion\n\n**fann95**\n\nwe will add a deadline check.\n\n**fann95**\n\nFixed: https://github.com/RealWagmi/wagmi-leverage/commit/97f30b9cf2ef1715f6050eb6b2d9d044235af86f\n\n**IAm0x52**\n\nEscalate\n\nWhile I agree that having the deadline enforcement is ideal, I don't see how this would cause any negative impact to the user taking over the loan besides wasted gas. Taking over a loan can only be done for a position that is eligible for liquidation. Liquidation is highly incentivized which means that a delayed transaction would already be very unlikely to succeed. \n\nIn the event that the position is not changed at all, the new borrower has collateralAmt to protect themselves from excess fees. If the owner of the position repays or if the loan is liquidated by another user ahead of this transaction, the takeOverDebt call will revert. If a lender requests emergency closure ahead of time then the fees owed will be reduced proportionally and any excess underwater fees would be written off [here](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L573-L575) during the emergency repayment. \n\nDue to this I don't see any negative financial impact to the new borrower besides wasted gas. I believe this should be a valid low.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> While I agree that having the deadline enforcement is ideal, I don't see how this would cause any negative impact to the user taking over the loan besides wasted gas. Taking over a loan can only be done for a position that is eligible for liquidation. Liquidation is highly incentivized which means that a delayed transaction would already be very unlikely to succeed. \n> \n> In the event that the position is not changed at all, the new borrower has collateralAmt to protect themselves from excess fees. If the owner of the position repays or if the loan is liquidated by another user ahead of this transaction, the takeOverDebt call will revert. If a lender requests emergency closure ahead of time then the fees owed will be reduced proportionally and any excess underwater fees would be written off [here](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L573-L575) during the emergency repayment. \n> \n> Due to this I don't see any negative financial impact to the new borrower besides wasted gas. I believe this should be a valid low.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Czar102**\n\nA user calling `takeOverDebt()` proposes to liquidate a position. Enforcing timely execution is callers' responsibility. Adding a deadline argument seems like a good add-on, but its lack does not seem to cause any loss of funds.\nAs far as I understand, this function will be called by MEV extractors, so revert after repaying is not an issue. It's the risk they are taking by design.\nRealizing losses by liquidators because of price movement is out of scope. If there are other possible kinds of losses, please let me know. Otherwise will consider the issue a low and accept the escalation.\n\n**HHK-ETH**\n\n> If a lender requests emergency closure ahead of time then the fees owed will be reduced proportionally and any excess underwater fees would be written off [here](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L573-L575) during the emergency repayment.\n\nI believe this is wrong, the line tagged add the collateral that was available to use to the fees owned to the lenders but it doesn't write off the underwater fees. These underwater fees are saved [here](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L612). By updating the `accLoanRatePerSeconds` the contract will be able to recalculate the missing collateral on future calls.\n\nThus if a lender use emergency repay the user taking over the debt will be repaying the full missing collateral for a position that might not be worth it anymore.\n\n**HHK-ETH**\n\nYou can check this comment from another issue to illustrate my point: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/119#issuecomment-1784834772\n\nAs confirmed by the sponsor, the debt is maintained as no one is paying it off and to do that we play with the `accLoanRatePerSeconds`.\n\nThis means the user taking over pays the debt the position owned to all lenders including the ones that emergency withdrew. So we need to make sure no loan was emergency repaid during that time otherwise the user may end up at a loss by repaying the whole collateral missing for a position that is not worth it anymore.\n\nMy proposition was first to add a deadline but this is only half a fix, thus I proposed to also introduce a `minBorrowedAmount` parameter.\n\n**Czar102**\n\n@IAm0x52 could you verify the above comment?\n\n> Thus if a lender use emergency repay the user taking over the debt will be repaying collateral for a position that might not be worth it.\n\n@HHK-ETH that would mean that the emergency withdraw could make underwater positions more underwater? Could you define \"might not be worth it\"?\n\n**HHK-ETH**\n\n> @HHK-ETH that would mean that the emergency withdraw could make underwater positions more underwater? Could you define \"might not be worth it\"?\n\nWhat I mean is that if you want to take over then you estimate that keeping the current position can make you money and thus you're okay to pay back the missing collateral.\nLet's take an example: \n\n- A position has 5 ETH long over 2 different loans and 0.2 ETH of missing collateral\n- User is bullish on ETH and wants to take over instead of liquidate the position. Take note that when liquidating you don't have to pay the missing collateral.\n- During the take over, one of the loans is reimbursed taking away 3 ETH from the position.\n- Once take over is confirmed, the position now holds only 2 ETH and not the initial 5 ETH. the user repaid 0.2 ETH but has a smaller position than expected and the long might not generate enough profits to reimburse the extra collateral paid (0.2 ETH). \n \nIf he knew it would have happened he maybe would have called `liquidate()` instead or `borrow()` to borrow from different positions that might not generate as much upside but at least wouldn't require to repay missing collateral.\n\n**HHK-ETH**\n\n> Take this second example:\n\nThis example used in the initial finding can be a little confusing as I talk about positions in profits. But after going through the contracts again I think the profits are not necessarily taken away when a lender emergency repays and so would stay on the position.\n\nStill the example I gave above still stands, even in profits, if they're not superior than the underwater collateral paid (minus the `liquidationBonus` you got from the old position) you end up at a loss that you might not be able to reimburse longing a smaller position than expected.\n\n**IAm0x52**\n\n> > @HHK-ETH that would mean that the emergency withdraw could make underwater positions more underwater? Could you define \"might not be worth it\"?\n> \n> What I mean is that if you want to take over then you estimate that keeping the current position can make you money and thus you're okay to pay back the missing collateral. Let's take an example:\n> \n> * A position has 5 ETH long over 2 different loans and 0.2 ETH of missing collateral\n> * User is bullish on ETH and wants to take over instead of liquidate the position. Take note that when liquidating you don't have to pay the missing collateral.\n> * During the take over, one of the loans is reimbursed taking away 3 ETH from the position.\n> * Once take over is confirmed, the position now holds only 2 ETH and not the initial 5 ETH. the user repaid 0.2 ETH but has a smaller position than expected and the long might not generate enough profits to reimburse the extra collateral paid (0.2 ETH).\n> \n> If he knew it would have happened he maybe would have called `liquidate()` instead or `borrow()` to borrow from different positions that might not generate as much upside but at least wouldn't require to repay missing collateral.\n\nThe problem with this is that the user taking over would not owe 0.2 ETH still because [here](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L597) fees owed by the position is reduced. So if the position owed 0.2 ETH and closed 3/5 (60%) then it would also remove 3/5 of the fees as we can see [here](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L744) since it uses a proportional calculation. This would leave the position with 0.08 ETH to repay when taken over.\n\n**Czar102**\n\n@HHK-ETH can you confirm?\n\n**HHK-ETH**\n\n> The problem with this is that the user taking over would not owe 0.2 ETH still because [here](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L597) fees owed by the position is reduced. So if the position owed 0.2 ETH and closed 3/5 (60%) then it would also remove 3/5 of the fees as we can see [here](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L744) since it uses a proportional calculation. This would leave the position with 0.08 ETH to repay when taken over.\n\nBut if the total collateral to be paid is below 0 [the fees accounted here are only the dailyCollateral available not the missing collateral](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L574). I believe `feesOwed` is accounting only fees that have been paid and not fees that couldn't be paid because of missing collateral.\n\n**HHK-ETH**\n\nTake this poc you can copy paste it in the main test file just keep the setup and nft creation test and delete the rest:\n\n```js\nit(\"Updated accRate\", async () => {\n        const amountWBTC = ethers.utils.parseUnits(\"0.05\", 8); //token0\n        let deadline = (await time.latest()) + 60;\n        const minLeverageDesired = 50;\n        const maxCollateralWBTC = amountWBTC.div(minLeverageDesired);\n\n        const loans = [\n            {\n                liquidity: nftpos[3].liquidity,\n                tokenId: nftpos[3].tokenId,\n            },\n            {\n                liquidity: nftpos[5].liquidity,\n                tokenId: nftpos[5].tokenId,\n            },\n        ];\n\n        const swapParams: ApproveSwapAndPay.SwapParamsStruct = {\n            swapTarget: constants.AddressZero,\n            swapAmountInDataIndex: 0,\n            maxGasForCall: 0,\n            swapData: swapData,\n        };\n\n        const borrowParams = {\n            internalSwapPoolfee: 500,\n            saleToken: WETH_ADDRESS,\n            holdToken: WBTC_ADDRESS,\n            minHoldTokenOut: amountWBTC,\n            maxCollateral: maxCollateralWBTC,\n            externalSwap: swapParams,\n            loans: loans,\n        };\n\n        //borrow tokens\n        await borrowingManager.connect(bob).borrow(borrowParams, deadline);\n\n        await time.increase(3600 * 25); //1h of missing collateral since when we borrow we add collateral for a day\n        deadline = (await time.latest()) + 60;\n\n        const borrowingKey = await borrowingManager.userBorrowingKeys(bob.address, 0);\n\n        let repayParams = {\n            isEmergency: true,\n            internalSwapPoolfee: 0,\n            externalSwap: swapParams,\n            borrowingKey: borrowingKey,\n            swapSlippageBP1000: 0,\n        };\n\n        const oldCollateralMissing = await borrowingManager.checkDailyRateCollateral(borrowingKey);\n        console.log(oldCollateralMissing.balance);\n\n        //Alice emergency repay her loan\n        await borrowingManager.connect(alice).repay(repayParams, deadline);\n\n        const newCollateralMissing = await borrowingManager.checkDailyRateCollateral(borrowingKey);\n        console.log(newCollateralMissing.balance);\n\n        //missing collateral is still the same\n        expect(oldCollateralMissing.balance).to.eq(newCollateralMissing.balance);\n    });\n```\n\nIt shows that the missing collateral is still the same after emergency repay.\n\n**IAm0x52**\n\n> I believe this is wrong, the line tagged add the collateral that was available to use to the fees owned to the lenders but it doesn't write off the underwater fees. These underwater fees are saved [here](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L612). By updating the `accLoanRatePerSeconds` the contract will be able to recalculate the missing collateral on future calls.\n\nYes this comment is incorrect. Underwater fees are saved. My initial comment regarding emergency closure was made based on the misconception that underwater fees are written off. Since they are not written off and fees continue to accumulate as normal minBorrowedAmount would still effectively function as a deadline. If the position is currently accumulating 1e16 interest per second then using a minBorrowedAmount that is 1e17 above the current amount owed, then if the takeOverDebt is delayed by more than 10 seconds then the call will fail.\n\n**HHK-ETH**\n\nSee the finding recommendation:\n\n> `minBorrowedAmount` and compare it to the current `borrowedAmount` to make sure no lender repaid their position during the take over\n\nMy proposition doesn't act as a deadline but as a check on the position's size, by checking `borrowingsInfo[key].borrowedAmount`. If it's below the passed parameter `minBorrowedAmount` then revert.\n\nThis effectively protects you from having lender repaying their position while your transaction is being confirmed.\n\n**IAm0x52**\n\n> See the finding recommendation:\n> \n> > `minBorrowedAmount` and compare it to the current `borrowedAmount` to make sure no lender repaid their position during the take over\n> \n> My proposition doesn't act as a deadline but as a check on the position's size, by checking `borrowingsInfo[key].borrowedAmount`. If it's below the passed parameter `minBorrowedAmount` then revert.\n\nSo then what exact loss scenario are you preventing? As shown above, there is already effectively a deadline. The only one I see would be for a lender to frontrun their call with an emergency closure. But what would be the benefit of that? The lender calling it would end up losing fees that it would have otherwise received. They could **potentially** cause a loss to the user taking over the loan but would guarantee a loss for themselves.\n\n**HHK-ETH**\n\n> So then what exact loss scenario are you preventing? As shown above, there is already effectively a deadline. The only one I see would be for a lender to frontrun their call with an emergency closure. But what would be the benefit of that? The lender calling it would end up losing fees that it would have otherwise received. They could potentially cause a loss to the user taking over the loan but would guarantee a loss for themselves.\n\nThe lender doesn't have to be malicious, he just need to be submitting a repay around the same time that the user is taking over. He doesn't know that someone is planning on taking over and might want his tokens back. Yes this is not likely to happen but it can happen  if both are unlucky and will result in loss for the user and less fees for the lender.\n\nI submitted this finding with slippage in the title because you could see it as a swap, let's imagine a nice world with no MEV. If you submit a swap on a pool but someone else swap on it before you (this user is not malicious but just happened to have called swap around the same time as you), you end up with a different amount than expected, Thus `minOut` act as a slippage protection.\nHere it's kind of the same but way less likely because a position can have only 7 loans maximum so there is only 7 other actors, **still the chance is not 0**.\n\nAdditionally like you said lender can go rogue and loose his fees to make user taking over pay collateral for a smaller position.\n\nSince there is money at stake I submitted this as a medium (and it seemed to be fitting criteria 1 or 3 https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue) but ultimately if you think it's not likely enough to happen and cost is too high for a malicious lender then I could understand that severity is lowered.\n\n**fann95**\n\nhttps://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/119 I have made changes to the emergency repayment. Now, in case of an emergency repayment, the debts for this liquidity will also be written off. Therefore, if someone takes over a debt, he will not pay in the event of a frontrunning emergency repayment.\n\n**Czar102**\n\nI think this issue is correctly classified as a medium. Planning to reject the escalation.\n\n**HHK-ETH**\n\nIf only the slippage part of this finding is accepted as a medium and the deadline is considered low I would suggest reviewing the duplicate https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/134 as it only talks about deadline check.\n\n**Czar102**\n\nPlanning to invalidate #134, too.\n\n**Evert0x**\n\nBased on the conversation this issue should be Medium without #134 as a duplicate. \n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/51/#issuecomment-1789466887): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/118",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/LiquidityBorrowingManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./abstract/LiquidityManager.sol\";\nimport \"./abstract/OwnerSettings.sol\";\nimport \"./abstract/DailyRateAndCollateral.sol\";\nimport \"./libraries/ErrLib.sol\";\n\n/**\n * @title LiquidityBorrowingManager\n * @dev This contract manages the borrowing liquidity functionality for WAGMI Leverage protocol.\n * It inherits from LiquidityManager, OwnerSettings, DailyRateAndCollateral, and ReentrancyGuard contracts.\n */\ncontract LiquidityBorrowingManager is\n    LiquidityManager,\n    OwnerSettings,\n    DailyRateAndCollateral,\n    ReentrancyGuard\n{\n    using { Keys.removeKey, Keys.addKeyIfNotExists } for bytes32[];\n    using { ErrLib.revertError } for bool;\n\n    /// @title BorrowParams\n    /// @notice This struct represents the parameters required for borrowing.\n    struct BorrowParams {\n        /// @notice The pool fee level for the internal swap\n        uint24 internalSwapPoolfee;\n        /// @notice The address of the token that will be sold to obtain the loan currency\n        address saleToken;\n        /// @notice The address of the token that will be held\n        address holdToken;\n        /// @notice The minimum amount of holdToken that must be obtained\n        uint256 minHoldTokenOut;\n        /// @notice The maximum amount of collateral that can be provided for the loan\n        uint256 maxCollateral;\n        /// @notice The SwapParams struct representing the external swap parameters\n        SwapParams externalSwap;\n        /// @notice An array of LoanInfo structs representing multiple loans\n        LoanInfo[] loans;\n    }\n    /// @title BorrowingInfo\n    /// @notice This struct represents the borrowing information for a borrower.\n    struct BorrowingInfo {\n        address borrower;\n        address saleToken;\n        address holdToken;\n        /// @notice The amount of fees owed by the creditor\n        uint256 feesOwed;\n        /// @notice The amount borrowed by the borrower\n        uint256 borrowedAmount;\n        /// @notice The amount of liquidation bonus\n        uint256 liquidationBonus;\n        /// @notice The accumulated loan rate per share\n        uint256 accLoanRatePerSeconds;\n        /// @notice The daily rate collateral balance multiplied by COLLATERAL_BALANCE_PRECISION\n        uint256 dailyRateCollateralBalance;\n    }\n    /// @notice This struct used for caching variables inside a function 'borrow'\n    struct BorrowCache {\n        uint256 dailyRateCollateral;\n        uint256 accLoanRatePerSeconds;\n        uint256 borrowedAmount;\n        uint256 holdTokenBalance;\n    }\n    /// @notice Struct representing the extended borrowing information.\n    struct BorrowingInfoExt {\n        /// @notice The main borrowing information.\n        BorrowingInfo info;\n        /// @notice An array of LoanInfo structs representing multiple loans\n        LoanInfo[] loans;\n        /// @notice The balance of the collateral.\n        int256 collateralBalance;\n        /// @notice The estimated lifetime of the loan.\n        uint256 estimatedLifeTime;\n        /// borrowing Key\n        bytes32 key;\n    }\n\n    /// @title RepayParams\n    /// @notice This struct represents the parameters required for repaying a loan.\n    struct RepayParams {\n        /// @notice The activation of the emergency liquidity restoration mode (available only to the lender)\n        bool isEmergency;\n        /// @notice The pool fee level for the internal swap\n        uint24 internalSwapPoolfee;\n        /// @notice The external swap parameters for the repayment transaction\n        SwapParams externalSwap;\n        /// @notice The unique borrowing key associated with the loan\n        bytes32 borrowingKey;\n        /// @notice The slippage allowance for the swap in basis points (1/10th of a percent)\n        uint256 swapSlippageBP1000;\n    }\n    /// borrowingKey=>LoanInfo\n    mapping(bytes32 => LoanInfo[]) public loansInfo;\n    /// borrowingKey=>BorrowingInfo\n    mapping(bytes32 => BorrowingInfo) public borrowingsInfo;\n    /// borrower => BorrowingKeys[]\n    mapping(address => bytes32[]) public userBorrowingKeys;\n    /// NonfungiblePositionManager tokenId => BorrowingKeys[]\n    mapping(uint256 => bytes32[]) public tokenIdToBorrowingKeys;\n\n    ///  token => FeesAmt\n    mapping(address => uint256) private platformsFeesInfo;\n\n    /// Indicates that a borrower has made a new loan\n    event Borrow(\n        address borrower,\n        bytes32 borrowingKey,\n        uint256 borrowedAmount,\n        uint256 borrowingCollateral,\n        uint256 liquidationBonus,\n        uint256 dailyRatePrepayment\n    );\n    /// Indicates that a borrower has repaid their loan, optionally with the help of a liquidator\n    event Repay(address borrower, address liquidator, bytes32 borrowingKey);\n    /// Indicates that a loan has been closed due to an emergency situation\n    event EmergencyLoanClosure(address borrower, address lender, bytes32 borrowingKey);\n    /// Indicates that the protocol has collected fee tokens\n    event CollectProtocol(address recipient, address[] tokens, uint256[] amounts);\n    /// Indicates that the daily interest rate for holding token(for specific pair) has been updated\n    event UpdateHoldTokenDailyRate(address saleToken, address holdToken, uint256 value);\n    /// Indicates that a borrower has increased their collateral balance for a loan\n    event IncreaseCollateralBalance(address borrower, bytes32 borrowingKey, uint256 collateralAmt);\n    /// Indicates that a new borrower has taken over the debt from an old borrower\n    event TakeOverDebt(\n        address oldBorrower,\n        address newBorrower,\n        bytes32 oldBorrowingKey,\n        bytes32 newBorrowingKey\n    );\n\n    error TooLittleReceivedError(uint256 minOut, uint256 out);\n\n    /// @dev Modifier to check if the current block timestamp is before or equal to the deadline.\n    modifier checkDeadline(uint256 deadline) {\n        (_blockTimestamp() > deadline).revertError(ErrLib.ErrorCode.TOO_OLD_TRANSACTION);\n        _;\n    }\n\n    function _blockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _underlyingQuoterV2,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    )\n        LiquidityManager(\n            _underlyingPositionManagerAddress,\n            _underlyingQuoterV2,\n            _underlyingV3Factory,\n            _underlyingV3PoolInitCodeHash\n        )\n    {}\n\n    /**\n     * @dev Adds or removes a swap call params to the whitelist.\n     * @param swapTarget The address of the target contract for the swap call.\n     * @param funcSelector The function selector of the swap call.\n     * @param isAllowed A boolean indicating whether the swap call is allowed or not.\n     */\n    function setSwapCallToWhitelist(\n        address swapTarget,\n        bytes4 funcSelector,\n        bool isAllowed\n    ) external onlyOwner {\n        (swapTarget == VAULT_ADDRESS ||\n            swapTarget == address(this) ||\n            swapTarget == address(underlyingPositionManager) ||\n            funcSelector == IERC20.transferFrom.selector).revertError(ErrLib.ErrorCode.FORBIDDEN);\n        whitelistedCall[swapTarget][funcSelector] = isAllowed;\n    }\n\n    /**\n     * @notice This function allows the owner to collect protocol fees for multiple tokens\n     * and transfer them to a specified recipient.\n     * @dev Only the contract owner can call this function.\n     * @param recipient The address of the recipient who will receive the collected fees.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectProtocol(address recipient, address[] calldata tokens) external onlyOwner {\n        uint256[] memory amounts = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ) {\n            address token = tokens[i];\n            uint256 amount = platformsFeesInfo[token] / Constants.COLLATERAL_BALANCE_PRECISION;\n            if (amount > 0) {\n                platformsFeesInfo[token] = 0;\n                amounts[i] = amount;\n                Vault(VAULT_ADDRESS).transferToken(token, recipient, amount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit CollectProtocol(recipient, tokens, amounts);\n    }\n\n    /**\n     * @notice This function is used to update the daily rate for holding token for specific pair.\n     * @dev Only the daily rate operator can call this function.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param value The new value of the daily rate for the hold token will be calculated based\n     * on the volatility of the pair and the popularity of loans in it\n     * @dev The value must be within the range of MIN_DAILY_RATE and MAX_DAILY_RATE.\n     */\n    function updateHoldTokenDailyRate(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external {\n        (msg.sender != dailyRateOperator).revertError(ErrLib.ErrorCode.INVALID_CALLER);\n        if (value > Constants.MAX_DAILY_RATE || value < Constants.MIN_DAILY_RATE) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(saleToken, holdToken);\n        holdTokenRateInfo.currentDailyRate = value;\n        emit UpdateHoldTokenDailyRate(saleToken, holdToken, value);\n    }\n\n    /**\n     * @notice This function is used to check the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The key of the borrowing.\n     * @return balance The balance of the daily rate collateral.\n     * @return estimatedLifeTime The estimated lifetime of the collateral in seconds.\n     */\n    function checkDailyRateCollateral(\n        bytes32 borrowingKey\n    ) external view returns (int256 balance, uint256 estimatedLifeTime) {\n        (, balance, estimatedLifeTime) = _getDebtInfo(borrowingKey);\n        balance /= int256(Constants.COLLATERAL_BALANCE_PRECISION);\n    }\n\n    /**\n     * @notice Get information about loans associated with a borrowing key\n     * @dev This function retrieves an array of loan information for a given borrowing key.\n     * The loans are stored in the loansInfo mapping, which is a mapping of borrowing keys to LoanInfo arrays.\n     * @param borrowingKey The unique key associated with the borrowing\n     * @return loans An array containing LoanInfo structs representing the loans associated with the borrowing key\n     */\n    function getLoansInfo(bytes32 borrowingKey) external view returns (LoanInfo[] memory loans) {\n        loans = loansInfo[borrowingKey];\n    }\n\n    /**\n     * @notice Retrieves the borrowing information for a specific NonfungiblePositionManager tokenId.\n     * @param tokenId The unique identifier of the PositionManager token.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getLenderCreditsInfo(\n        uint256 tokenId\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = tokenIdToBorrowingKeys[tokenId];\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @notice Retrieves the debts information for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getBorrowerDebtsInfo(\n        address borrower\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower];\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Returns the number of loans associated with a given NonfungiblePositionManager tokenId.\n     * @param tokenId The ID of the token.\n     * @return count The total number of loans associated with the tokenId.\n     */\n    function getLenderCreditsCount(uint256 tokenId) external view returns (uint256 count) {\n        bytes32[] memory borrowingKeys = tokenIdToBorrowingKeys[tokenId];\n        count = borrowingKeys.length;\n    }\n\n    /**\n     * @dev Returns the number of borrowings for a given borrower.\n     * @param borrower The address of the borrower.\n     * @return count The total number of borrowings for the borrower.\n     */\n    function getBorrowerDebtsCount(address borrower) external view returns (uint256 count) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower];\n        count = borrowingKeys.length;\n    }\n\n    /**\n     * @dev Returns the current daily rate for holding token.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @return currentDailyRate The current daily rate .\n     */\n    function getHoldTokenDailyRateInfo(\n        address saleToken,\n        address holdToken\n    ) external view returns (uint256 currentDailyRate, TokenInfo memory holdTokenRateInfo) {\n        (currentDailyRate, holdTokenRateInfo) = _getHoldTokenRateInfo(saleToken, holdToken);\n    }\n\n    /**\n     * @dev Returns the fees information for multiple tokens in an array.\n     * @param tokens An array of token addresses for which the fees are to be retrieved.\n     * @return fees An array containing the fees for each token.\n     */\n    function getPlatformsFeesInfo(\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        fees = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ) {\n            address token = tokens[i];\n            uint256 amount = platformsFeesInfo[token] / Constants.COLLATERAL_BALANCE_PRECISION;\n            fees[i] = amount;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates the collateral amount required for a lifetime in seconds.\n     *\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param lifetimeInSeconds The duration of the borrowing in seconds.\n     * @return collateralAmt The calculated collateral amount that is needed.\n     */\n    function calculateCollateralAmtForLifetime(\n        bytes32 borrowingKey,\n        uint256 lifetimeInSeconds\n    ) external view returns (uint256 collateralAmt) {\n        // Retrieve the BorrowingInfo struct associated with the borrowing key\n        BorrowingInfo memory borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowed position is existing\n        if (borrowing.borrowedAmount > 0) {\n            // Get the current daily rate for the hold token\n            (uint256 currentDailyRate, ) = _getHoldTokenRateInfo(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n            // Calculate the collateral amount per second\n            uint256 everySecond = (\n                FullMath.mulDivRoundingUp(\n                    borrowing.borrowedAmount,\n                    currentDailyRate * Constants.COLLATERAL_BALANCE_PRECISION,\n                    1 days * Constants.BP\n                )\n            );\n            // Calculate the total collateral amount for the borrowing lifetime\n            collateralAmt = FullMath.mulDivRoundingUp(\n                everySecond,\n                lifetimeInSeconds,\n                Constants.COLLATERAL_BALANCE_PRECISION\n            );\n            // Ensure that the collateral amount is at least 1\n            if (collateralAmt == 0) collateralAmt = 1;\n        }\n    }\n\n    /**\n     * @notice This function is used to increase the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param collateralAmt The amount of collateral to be added.\n     */\n    function increaseCollateralBalance(bytes32 borrowingKey, uint256 collateralAmt) external {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists and the borrower is the message sender\n        (borrowing.borrowedAmount == 0 || borrowing.borrower != address(msg.sender)).revertError(\n            ErrLib.ErrorCode.INVALID_BORROWING_KEY\n        );\n        // Increase the daily rate collateral balance by the specified collateral amount\n        borrowing.dailyRateCollateralBalance +=\n            collateralAmt *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        _pay(borrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt);\n        emit IncreaseCollateralBalance(msg.sender, borrowingKey, collateralAmt);\n    }\n\n    /**\n     * @notice Take over debt by transferring ownership of a borrowing to the current caller\n     * @dev This function allows the current caller to take over a debt from another borrower.\n     * The function validates the borrowingKey and checks if the collateral balance is negative.\n     * If the conditions are met, the function transfers ownership of the borrowing to the current caller,\n     * updates the daily rate collateral balance, and pays the collateral amount to the vault.\n     * Emits a `TakeOverDebt` event.\n     * @param borrowingKey The unique key associated with the borrowing to be taken over\n     * @param collateralAmt The amount of collateral to be provided by the new borrower\n     */\n    function takeOverDebt(bytes32 borrowingKey, uint256 collateralAmt) external {\n        BorrowingInfo memory oldBorrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists\n        (oldBorrowing.borrowedAmount == 0).revertError(ErrLib.ErrorCode.INVALID_BORROWING_KEY);\n\n        uint256 accLoanRatePerSeconds;\n        uint256 minPayment;\n        {\n            // Update token rate info and retrieve the accumulated loan rate per second for holdToken\n            (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(\n                oldBorrowing.saleToken,\n                oldBorrowing.holdToken\n            );\n            accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n            // Calculate the collateral balance and current fees for the oldBorrowing\n            (int256 collateralBalance, uint256 currentFees) = _calculateCollateralBalance(\n                oldBorrowing.borrowedAmount,\n                oldBorrowing.accLoanRatePerSeconds,\n                oldBorrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n            // Ensure that the collateral balance is greater than or equal to 0\n            (collateralBalance >= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            // Pick up platform fees from the oldBorrowing's holdToken and add them to the feesOwed\n            currentFees = _pickUpPlatformFees(oldBorrowing.holdToken, currentFees);\n            oldBorrowing.feesOwed += currentFees;\n            // Calculate the minimum payment required based on the collateral balance\n            minPayment = (uint256(-collateralBalance) / Constants.COLLATERAL_BALANCE_PRECISION) + 1;\n            (collateralAmt <= minPayment).revertError(\n                ErrLib.ErrorCode.COLLATERAL_AMOUNT_IS_NOT_ENOUGH\n            );\n        }\n        // Retrieve the old loans associated with the borrowing key and remove them from storage\n        LoanInfo[] memory oldLoans = loansInfo[borrowingKey];\n        _removeKeysAndClearStorage(oldBorrowing.borrower, borrowingKey, oldLoans);\n        // Initialize a new borrowing using the same saleToken, holdToken\n        (\n            uint256 feesDebt,\n            bytes32 newBorrowingKey,\n            BorrowingInfo storage newBorrowing\n        ) = _initOrUpdateBorrowing(\n                oldBorrowing.saleToken,\n                oldBorrowing.holdToken,\n                accLoanRatePerSeconds\n            );\n        // Add the new borrowing key and old loans to the newBorrowing\n        _addKeysAndLoansInfo(newBorrowing.borrowedAmount > 0, borrowingKey, oldLoans);\n        // Increase the borrowed amount, liquidation bonus, and fees owed of the newBorrowing based on the oldBorrowing\n        newBorrowing.borrowedAmount += oldBorrowing.borrowedAmount;\n        newBorrowing.liquidationBonus += oldBorrowing.liquidationBonus;\n        newBorrowing.feesOwed += oldBorrowing.feesOwed;\n        // oldBorrowing.dailyRateCollateralBalance is 0\n        newBorrowing.dailyRateCollateralBalance +=\n            (collateralAmt - minPayment) *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        //newBorrowing.accLoanRatePerSeconds = oldBorrowing.accLoanRatePerSeconds;\n        _pay(oldBorrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt + feesDebt);\n        emit TakeOverDebt(oldBorrowing.borrower, msg.sender, borrowingKey, newBorrowingKey);\n    }\n\n    /**\n     * @notice Borrow function allows a user to borrow tokens by providing collateral and taking out loans.\n     * The trader opens a long position by borrowing the liquidity of Uniswap V3 and extracting it into a pair of tokens,\n     * one of which will be swapped into a desired(holdToken).The tokens will be kept in storage until the position is closed.\n     * The margin is calculated on the basis that liquidity must be restored with any price movement.\n     * The time the position is held is paid by the trader.\n     * @dev Emits a Borrow event upon successful borrowing.\n     * @param params The BorrowParams struct containing the necessary parameters for borrowing.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     */\n    function borrow(\n        BorrowParams calldata params,\n        uint256 deadline\n    ) external nonReentrant checkDeadline(deadline) {\n        // Precalculating borrowing details and storing them in cache\n        BorrowCache memory cache = _precalculateBorrowing(params);\n        // Initializing borrowing variables and obtaining borrowing key\n        (\n            uint256 feesDebt,\n            bytes32 borrowingKey,\n            BorrowingInfo storage borrowing\n        ) = _initOrUpdateBorrowing(params.saleToken, params.holdToken, cache.accLoanRatePerSeconds);\n        // Adding borrowing key and loans information to storage\n        _addKeysAndLoansInfo(borrowing.borrowedAmount > 0, borrowingKey, params.loans);\n        // Calculating liquidation bonus based on hold token, borrowed amount, and number of used loans\n        uint256 liquidationBonus = getLiquidationBonus(\n            params.holdToken,\n            cache.borrowedAmount,\n            params.loans.length\n        );\n        // Updating borrowing details\n        borrowing.borrowedAmount += cache.borrowedAmount;\n        borrowing.liquidationBonus += liquidationBonus;\n        borrowing.dailyRateCollateralBalance +=\n            cache.dailyRateCollateral *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        // Checking if borrowing collateral exceeds the maximum allowed collateral\n        uint256 borrowingCollateral = cache.borrowedAmount - cache.holdTokenBalance;\n        (borrowingCollateral > params.maxCollateral).revertError(\n            ErrLib.ErrorCode.TOO_BIG_COLLATERAL\n        );\n\n        // Transfer the required tokens to the VAULT_ADDRESS for collateral and holdTokenBalance\n        _pay(\n            params.holdToken,\n            msg.sender,\n            VAULT_ADDRESS,\n            borrowingCollateral + liquidationBonus + cache.dailyRateCollateral + feesDebt\n        );\n        // Transferring holdTokenBalance to VAULT_ADDRESS\n        _pay(params.holdToken, address(this), VAULT_ADDRESS, cache.holdTokenBalance);\n        // Emit the Borrow event with the borrower, borrowing key, and borrowed amount\n        emit Borrow(\n            msg.sender,\n            borrowingKey,\n            cache.borrowedAmount,\n            borrowingCollateral,\n            liquidationBonus,\n            cache.dailyRateCollateral\n        );\n    }\n\n    /**\n     * @notice This function is used to repay a loan.\n     * The position is closed either by the trader or by the liquidator if the trader has not paid for holding the position\n     * and the moment of liquidation has arrived.The positions borrowed from liquidation providers are restored from the held\n     * token and the remainder is sent to the caller.In the event of liquidation, the liquidity provider\n     * whose liquidity is present in the traderâ€™s position can use the emergency mode and withdraw their liquidity.In this case,\n     * he will receive hold tokens and liquidity will not be restored in the uniswap pool.\n     * @param params The repayment parameters including\n     *  activation of the emergency liquidity restoration mode (available only to the lender)\n     *  internal swap pool fee,\n     *  external swap parameters,\n     *  borrowing key,\n     *  swap slippage allowance.\n     * @param deadline The deadline by which the repayment must be made.\n     */\n    function repay(\n        RepayParams calldata params,\n        uint256 deadline\n    ) external nonReentrant checkDeadline(deadline) {\n        BorrowingInfo memory borrowing = borrowingsInfo[params.borrowingKey];\n        // Check if the borrowing key is valid\n        (borrowing.borrowedAmount == 0).revertError(ErrLib.ErrorCode.INVALID_BORROWING_KEY);\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n        uint256 liquidationBonus = borrowing.liquidationBonus;\n        int256 collateralBalance;\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n        {\n            // Calculate collateral balance and validate caller\n            uint256 accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n            uint256 currentFees;\n            (collateralBalance, currentFees) = _calculateCollateralBalance(\n                borrowing.borrowedAmount,\n                borrowing.accLoanRatePerSeconds,\n                borrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n\n            (msg.sender != borrowing.borrower && collateralBalance >= 0).revertError(\n                ErrLib.ErrorCode.INVALID_CALLER\n            );\n\n            // Calculate liquidation bonus and adjust fees owed\n\n            if (\n                collateralBalance > 0 &&\n                (currentFees + borrowing.feesOwed) / Constants.COLLATERAL_BALANCE_PRECISION >\n                Constants.MINIMUM_AMOUNT\n            ) {\n                liquidationBonus +=\n                    uint256(collateralBalance) /\n                    Constants.COLLATERAL_BALANCE_PRECISION;\n            } else {\n                currentFees = borrowing.dailyRateCollateralBalance;\n            }\n\n            // Calculate platform fees and adjust fees owed\n            borrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees);\n        }\n        // Check if it's an emergency repayment\n        if (params.isEmergency) {\n            (collateralBalance >= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            (\n                uint256 removedAmt,\n                uint256 feesAmt,\n                bool completeRepayment\n            ) = _calculateEmergencyLoanClosure(\n                    zeroForSaleToken,\n                    params.borrowingKey,\n                    borrowing.feesOwed,\n                    borrowing.borrowedAmount\n                );\n            (removedAmt == 0).revertError(ErrLib.ErrorCode.LIQUIDITY_IS_ZERO);\n            // prevent overspent\n            // Subtract the removed amount and fees from borrowedAmount and feesOwed\n            borrowing.borrowedAmount -= removedAmt;\n            borrowing.feesOwed -= feesAmt;\n            feesAmt /= Constants.COLLATERAL_BALANCE_PRECISION;\n            // Deduct the removed amount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= removedAmt;\n            // If loansInfoLength is 0, remove the borrowing key from storage and get the liquidation bonus\n            if (completeRepayment) {\n                LoanInfo[] memory empty;\n                _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, empty);\n                feesAmt += liquidationBonus;\n            } else {\n                BorrowingInfo storage borrowingStorage = borrowingsInfo[params.borrowingKey];\n                borrowingStorage.dailyRateCollateralBalance = 0;\n                borrowingStorage.feesOwed = borrowing.feesOwed;\n                borrowingStorage.borrowedAmount = borrowing.borrowedAmount;\n                // Calculate the updated accLoanRatePerSeconds\n                borrowingStorage.accLoanRatePerSeconds =\n                    holdTokenRateInfo.accLoanRatePerSeconds -\n                    FullMath.mulDiv(\n                        uint256(-collateralBalance),\n                        Constants.BP,\n                        borrowing.borrowedAmount // new amount\n                    );\n            }\n            // Transfer removedAmt + feesAmt to msg.sender and emit EmergencyLoanClosure event\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                msg.sender,\n                removedAmt + feesAmt\n            );\n            emit EmergencyLoanClosure(borrowing.borrower, msg.sender, params.borrowingKey);\n        } else {\n            // Deduct borrowedAmount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= borrowing.borrowedAmount;\n\n            // Transfer the borrowed amount and liquidation bonus from the VAULT to this contract\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                address(this),\n                borrowing.borrowedAmount + liquidationBonus\n            );\n            // Restore liquidity using the borrowed amount and pay a daily rate fee\n            LoanInfo[] memory loans = loansInfo[params.borrowingKey];\n            _maxApproveIfNecessary(\n                borrowing.holdToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n            _maxApproveIfNecessary(\n                borrowing.saleToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n\n            _restoreLiquidity(\n                RestoreLiquidityParams({\n                    zeroForSaleToken: zeroForSaleToken,\n                    fee: params.internalSwapPoolfee,\n                    slippageBP1000: params.swapSlippageBP1000,\n                    totalfeesOwed: borrowing.feesOwed,\n                    totalBorrowedAmount: borrowing.borrowedAmount\n                }),\n                params.externalSwap,\n                loans\n            );\n            // Get the remaining balance of saleToken and holdToken\n            (uint256 saleTokenBalance, uint256 holdTokenBalance) = _getPairBalance(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n            // Remove borrowing key from related data structures\n            _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, loans);\n            // Pay a profit to a msg.sender\n            _pay(borrowing.holdToken, address(this), msg.sender, holdTokenBalance);\n            _pay(borrowing.saleToken, address(this), msg.sender, saleTokenBalance);\n\n            emit Repay(borrowing.borrower, msg.sender, params.borrowingKey);\n        }\n    }\n\n    /**\n     * @dev Calculates the liquidation bonus for a given token, borrowed amount, and times factor.\n     * @param token The address of the token.\n     * @param borrowedAmount The amount of tokens borrowed.\n     * @param times The times factor to apply to the liquidation bonus calculation.\n     * @return liquidationBonus The calculated liquidation bonus.\n     */\n    function getLiquidationBonus(\n        address token,\n        uint256 borrowedAmount,\n        uint256 times\n    ) public view returns (uint256 liquidationBonus) {\n        // Retrieve liquidation bonus for the given token\n        Liquidation memory liq = liquidationBonusForToken[token];\n\n        if (liq.bonusBP == 0) {\n            // If there is no specific bonus for the token\n            // Use default bonus\n            liq.minBonusAmount = Constants.MINIMUM_AMOUNT;\n            liq.bonusBP = dafaultLiquidationBonusBP;\n        }\n        liquidationBonus = (borrowedAmount * liq.bonusBP) / Constants.BP;\n\n        if (liquidationBonus < liq.minBonusAmount) {\n            liquidationBonus = liq.minBonusAmount;\n        }\n        l"
    }
  ]
}