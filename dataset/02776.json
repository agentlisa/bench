{
  "Title": "M-4: Protocol won't work with `USDC` even though it is a token specifically mentioned in the docs",
  "Content": "# Issue M-4: Protocol won't work with `USDC` even though it is a token specifically mentioned in the docs \n\nSource: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/21 \n\n## Found by \npashov, ctf\\_sec, 0x52\n\n## Summary\nThe protocol has requirements for values (for example 1e18) that would be too big if used with a 6 decimals token like `USDC` - `USDC` is mentioned as a token that will be used in the docs\n## Vulnerability Detail\nFor the mint functionality, a user has to transfer at least 1e18 tokens so that he can mint pool tokens - `if (amount < 1e18) revert InvalidActionAmount(amount);`. If the `paymentToken` used was `USDC` (as pointed out in docs), this would mean he would have to contribute at least 1e12 USDC tokens (more than a billion) which would be pretty much impossible to do. There is also another such check in `MarketExtended::addPoolToExistingMarket` with `require(initialActualLiquidityForNewPool >= 1e12, \"Insufficient market seed\");` - both need huge amounts when using a low decimals token like USDC that has 6 decimals.\n\n## Impact\nThe protocol just wouldn't work at all in its current state when using a lower decimals token. Since such a token was mentioned in the docs I set this as a High severity issue.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketExtended.sol#L125\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L265\n## Tool used\n\nManual Review\n\n## Recommendation\nDrastically lower  the `require` checks so they can work with tokens with a low decimals count like `USDC`\n\n## Discussion\n\n**JasoonS**\n\nI feel really silly that I didn't think of that when I wrote the readme - we have spoken about it came up many times in the alpha version audit that we did last year. We have no intention of using USDC anytime soon. We have been using DAI exclusively. My mistake - I thought why not just have the option for insurance sake and mention USDC (since it is the only other token remotely likely that we might use).\n\nThis most certainly isn't `high` - it is in the constructor that we'd immediately notice that (of course as I mentioned we have been aware of this for a long time). The rest of the mechanism works with USDC - just those minimums will need to be adjusted.\n\nSo, \"_Bug in the readme?_\" I'd say this isn't a vulnerability at all!\n\nWe could fetch the `decimals` from the payment token on initialization, but honestly don't think the extra complexity is justified in our situation.\n\n\n**Evert0x**\n\nAs USDC was explicitly mentioned by the protocol we would like to reward this finding.\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/15",
  "Code": [
    {
      "filename": "contracts/market/template/MarketExtended.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\nimport \"./MarketStorage.sol\";\n\n/// @title Extended (not often used) functions for market\n/// @author float\n/// @dev This contract is contains a set of non-core functions for the MarketCore contract that are not important enough to be included in the core contract.\ncontract MarketExtendedCore is AccessControlledAndUpgradeableModifiers, MarketStorage, IMarketExtendedCore {\n  using SafeERC20 for IERC20;\n\n  constructor(address _paymentToken, IRegistry _registry) initializer MarketStorage(_paymentToken, _registry) {}\n\n  /*╔═══════════════════════╗\n    ║       INITIALIZE      ║\n    ╚═══════════════════════╝*/\n\n  /// @notice Initialize pools in the market\n  /// @dev Can only be called by registry contract\n  /// @param params struct containing addresses of dependency contracts and other market initialization parameters\n  /// @return initializationSuccess bool value indicating whether initialization was successful.\n  function initializePools(InitializePoolsParams memory params) external override initializer returns (bool initializationSuccess) {\n    require(msg.sender == address(registry), \"Not registry\");\n    require(params.seederAndAdmin != address(0) && params.oracleManager != address(0) && params.liquidityManager != address(0));\n    // The below function ensures that this contract can't be re-initialized!\n    _AccessControlledAndUpgradeable_init(params.seederAndAdmin);\n\n    _setupRole(FLOAT_POOL_ROLE, params.seederAndAdmin);\n    _setRoleAdmin(FLOAT_POOL_ROLE, ADMIN_ROLE);\n\n    oracleManager = IOracleManager(params.oracleManager);\n    liquidityManager = params.liquidityManager;\n\n    epochInfo.latestExecutedEpochIndex = uint32(oracleManager.getCurrentEpochIndex() - 1);\n\n    (uint80 latestRoundId, int256 initialAssetPrice, , , ) = oracleManager.chainlinkOracle().latestRoundData();\n    epochInfo.latestExecutedOracleRoundId = latestRoundId;\n\n    // Ie default max percentage change is 19.99% (for the 5x FLOAT tier)\n    // given general deviation threshold of 0.5% for most oracle price feeds\n    // price movements greater than 20% are extremely unlikely and so maintaining a hard cap of 19.99% on price changes is reasonable.\n    // We start this value at 99% as the max change, but it gets reduced when pools with higher leverage are added.\n    maxPercentChange = 0.99e18;\n\n    emit SeparateMarketLaunchedAndSeeded(\n      params._marketIndex,\n      params.seederAndAdmin,\n      address(oracleManager),\n      liquidityManager,\n      paymentToken,\n      initialAssetPrice\n    );\n\n    // NOTE: The first pool HAS to be the 1 and only FLOAT pool - otherwise initializer will fail!\n    for (uint256 i = 0; i < params.initPools.length; i++) {\n      _addPoolToExistingMarket(params.initPools[i], params.initialLiquidityToSeedEachPool, params.seederAndAdmin, params._marketIndex);\n    }\n\n    // Return true to drastically reduce chance of making mistakes with this.\n    initializationSuccess = true;\n  }\n\n  /*╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝*/\n\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param oracleConfig Address of the replacement oracle manager.\n  function updateMarketOracle(OracleUpdate memory oracleConfig) external adminOnly {\n    // NOTE: we could also upgrade this contract to reference the new oracle potentially and have it as immutable\n    // If not a oracle contract this would break things.. Test's arn't validating this\n    // Ie require isOracle interface - ERC165\n\n    // This check helps make sure that config changes are deliberate.\n    require(oracleConfig.prevOracle == oracleManager, \"Incorrect prev oracle\");\n\n    oracleManager = oracleConfig.newOracle;\n    emit ConfigChange(ConfigType.marketOracleUpdate, abi.encode(oracleConfig));\n  }\n\n  /// @notice Update the yearly funding rate multiplier for the market\n  /// @dev Can only be called by the current admin.\n  /// @param fundingRateConfig New funding rate multiplier\n  function changeMarketFundingRateMultiplier(FundingRateUpdate memory fundingRateConfig) external adminOnly {\n    // Funding multiplier quoted in basis points\n    require(fundingRateConfig.newMultiplier <= 10000, \"funding rate must be <= 100%\");\n\n    // This check helps make sure that config changes are deliberate.\n    require(fundingRateConfig.prevMultiplier == fundingRateMultiplier, \"Incorrect prev value\");\n\n    fundingRateMultiplier = fundingRateConfig.newMultiplier;\n    emit ConfigChange(ConfigType.fundingRateMultiplier, abi.encode(fundingRateConfig));\n  }\n\n  /// @notice Update the yearly stability fee for the market\n  /// @dev Can only be called by the current admin.\n  /// @param stabilityFeeConfig New stability fee multiplier\n  function changeStabilityFeeBasisPoints(StabilityFeeUpdate memory stabilityFeeConfig) external adminOnly {\n    require(stabilityFeeConfig.newStabilityFee <= 500, \"stability fee must be <= 5%\");\n\n    // This check helps make sure that config changes are deliberate.\n    require(stabilityFeeConfig.prevStabilityFee == stabilityFee_basisPoints, \"Incorrect prev value\");\n\n    stabilityFee_basisPoints = stabilityFeeConfig.newStabilityFee;\n    emit ConfigChange(ConfigType.stabilityFee, abi.encode(stabilityFeeConfig));\n  }\n\n  /// @notice Add a pool to an existing market.\n  /// @dev Can only be called by the current admin.\n  /// @param initPool initialization info for the new pool\n  /// @param initialActualLiquidityForNewPool initial effective liquidity to be added to new pool at initialization\n  /// @param seederAndAdmin address of pool seeder and admin\n  /// @param _marketIndex index of the market\n  //slither-disable-next-line costly-operations-inside-a-loop\n  function _addPoolToExistingMarket(\n    SinglePoolInitInfo memory initPool,\n    uint256 initialActualLiquidityForNewPool,\n    address seederAndAdmin,\n    uint32 _marketIndex\n  ) internal {\n    require(seederAndAdmin != address(0), \"Invalid seederAndAdmin can't be zero\");\n    // You require at least 1e12 (1 payment token with 12 decimal places) of the underlying payment token to seed the market.\n    require(initialActualLiquidityForNewPool >= 1e12, \"Insufficient market seed\");\n    require(\n      _numberOfPoolsOfType[uint256(initPool.poolType)] < 8 &&\n        initPool.token != address(0) &&\n        initPool.poolType < PoolType.LAST &&\n        (initPool.leverage >= 1e18 && initPool.leverage <= 10e18),\n      \"Invalid pool params\"\n    );\n\n    SinglePoolInitInfo memory poolInfo = initPool;\n    uint256 tierPriceMovementThresholdAbsolute = PoolType.FLOAT == initPool.poolType ? 0.1999e18 : (1e36 / poolInfo.leverage) - 1e14;\n\n    maxPercentChange = int256(Math.min(uint256(maxPercentChange), tierPriceMovementThresholdAbsolute));\n\n    IPoolToken(initPool.token).initialize(initPool, seederAndAdmin, _marketIndex, uint8(_numberOfPoolsOfType[uint256(initPool.poolType)]));\n\n    IPoolToken(initPool.token).mint(MARKET_SEEDER_DEAD_ADDRESS, initialActualLiquidityForNewPool);\n\n    Pool storage pool = pools[initPool.poolType][_numberOfPoolsOfType[uint256(initPool.poolType)]];\n\n    pool.fixedConfig = PoolFixedConfig(initPool.token, (initPool.poolType == PoolType.SHORT ? -int96(initPool.leverage) : int96(initPool.leverage)));\n    pool.value = initialActualLiquidityForNewPool;\n\n    require(_numberOfPoolsOfType[uint256(initPool.poolType)]++ == poolInfo.poolTier, \"incorrect pool tier\");\n    ++_totalNumberOfPoolTiers;\n\n    emit TierAdded(poolInfo, initialActualLiquidityForNewPool);\n\n    IERC20(paymentToken).safeTransferFrom(seederAndAdmin, liquidityManager, initialActualLiquidityForNewPool);\n\n    if (initPool.poolType != PoolType.FLOAT)\n      effectiveLiquidityForPoolType[uint256(initPool.poolType)] += uint128(MathUintFloat.mul(initialActualLiquidityForNewPool, initPool.leverage));\n\n    require(_numberOfPoolsOfType[FLOAT_TYPE] == 1, \"Must be exactly 1 float pool\");\n  }\n\n  /// @notice Add a pool to an existing market.\n  /// @dev Can only be called by the current admin.\n  /// @param initPool initialization info for the new pool\n  /// @param initialActualLiquidityForNewPool initial effective liquidity to be added to new pool at initialization\n  /// @param seederAndAdmin address of pool seeder and admin\n  /// @param _marketIndex index of the market\n  function addPoolToExistingMarket(\n    SinglePoolInitInfo memory initPool,\n    uint256 initialActualLiquidityForNewPool,\n    address seederAndAdmin,\n    uint32 _marketIndex\n  ) external adminOnly {\n    require(!marketDeprecated && !mintingPaused, \"can't add pool to when paused/deprecated\");\n    _addPoolToExistingMarket(initPool, initialActualLiquidityForNewPool, seederAndAdmin, _marketIndex);\n  }\n\n  /// @notice Stop allowing mints on the market\n  /// @dev Can only be called by the current admin.\n  function pauseMinting() external adminOnly {\n    mintingPaused = true;\n    emit MintingPauseChange(mintingPaused);\n  }\n\n  /// @notice Resume allowing mints on the market\n  /// @dev Can only be called by the current admin.\n  function unpauseMinting() external adminOnly {\n    require(!marketDeprecated, \"can't unpause deprecated market\");\n    mintingPaused = false;\n    emit MintingPauseChange(mintingPaused);\n  }\n}"
    },
    {
      "filename": "contracts/market/template/MarketCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\nimport \"./MarketStorage.sol\";\n\n/// @title Main market contract with all the main functionality\ncontract MarketCore is AccessControlledAndUpgradeableModifiers, IMarketCommon, IMarketCore, MarketStorage, ProxyNonPayable {\n  using SafeERC20 for IERC20;\n  using MathUintFloat for uint256;\n  using MathIntFloat for int256;\n\n  /*╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝*/\n\n  function gemCollectingModifierLogic(address user) internal {\n    IGEMS(gems).gm(user);\n  }\n\n  modifier gemCollecting(address user) {\n    gemCollectingModifierLogic(user);\n    _;\n  }\n\n  modifier checkMarketNotDeprecated() {\n    if (marketDeprecated) revert MarketDeprecated();\n    _;\n  }\n\n  /*╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝*/\n\n  /// @notice This calculates the value transfer from the overbalanced to underbalanced side (i.e. the funding rate)\n  /// This is a further incentive measure to balanced markets. This may be present on some and not other pool token markets.\n  /// @param overbalancedIndex poolType with more liquidity.\n  /// @param overbalancedValue Side with more liquidity.\n  /// @param underbalancedValue Side with less liquidity.\n  /// @return fundingAmount The amount the overbalanced side needs to pay the underbalanced.\n  function _calculateFundingAmount(\n    uint256 overbalancedIndex,\n    uint256 overbalancedValue,\n    uint256 underbalancedValue\n  ) internal view returns (int256[2] memory fundingAmount) {\n    /*\n    totalFunding is calculated on the notional of between long and short liquidity and 2x long and short liquidity. \n    The notional on which funding is calculated increaseas as the imbalance increases.\n    The split of funding paid between underbalanced and overbalanced is 50/50 when long = short liq and moves\n    linearly to 100% paid by the overbalanced beyong the point where liquidity is 2:1 ratio\n    (liquidity in overbalanced side is more than double liquidity in underbalanced side)\n    This modular function is logical but naive implementation that will likely change somewhat upon more indepth \n    modelling results that are still pending. \n    */\n\n    // fundingRateMultiplier is in basis points so need to divide by 10,000.\n    uint256 totalFunding = (2 * overbalancedValue * fundingRateMultiplier * oracleManager.EPOCH_LENGTH()) / (365.25 days * 10000);\n\n    uint256 overbalancedFunding = Math.min(\n      totalFunding,\n      (totalFunding * ((2 * overbalancedValue) - underbalancedValue)) / (overbalancedValue + underbalancedValue)\n    );\n    uint256 underbalancedFunding = totalFunding - overbalancedFunding;\n\n    if (overbalancedIndex == SHORT_TYPE) fundingAmount = [-int256(overbalancedFunding), int256(underbalancedFunding)];\n    else fundingAmount = [-int256(underbalancedFunding), int256(overbalancedFunding)];\n  }\n\n  function _getValueChangeAndFunding(\n    uint256 effectiveValueLong,\n    uint256 effectiveValueShort,\n    int256 previousPrice,\n    int256 currentPrice\n  ) internal view returns (int256 floatPoolLeverage, ValueChangeAndFunding memory params) {\n    uint256 floatPoolLiquidity = pools[PoolType.FLOAT][0].value;\n    // We set the floating tranche leverage to the exact leverage that ensure effectiveValueLong = effectiveValueShort when taking\n    //     into the floating liquidity added the underbalanced side.\n    floatPoolLeverage = (int256(effectiveValueShort) - int256(effectiveValueLong)).div(int256(floatPoolLiquidity));\n\n    // If there is a large diff between long and short liquidity or little floatPoolLiquidity, then the float pool leverage\n    // may be set to a very high amount. Here we cap it such that floatPoolLeverage is between -5x and 5x.\n    // This give Market Makers who deposit in the floatPool certain garuntees on the maximum delta they will be exposed to.\n    if (floatPoolLeverage > 5e18) floatPoolLeverage = 5e18;\n    else if (floatPoolLeverage < -5e18) floatPoolLeverage = -5e18;\n\n    // NOTE - we are dividing by previous price before multiplying this value again in _rebalancePoolsAndExecuteBatchedActions - this means some accuracy is lost - however we deem this insignificant.\n    int256 priceMovement_e18 = (currentPrice - previousPrice).div(previousPrice);\n\n    // A really large price movement could bankrupt a 5x leveraged pool. We contrain the price movement to a max percentage\n    // that ensure no pool will be underwater. This limimts the gain/loss on any single price movement. In practice\n    // maxPercentChange is about 20% for a 5x pool, and we don't expect to see 20% price changes in one epoch, but if we do,\n    // The system is able to tolerate it.\n    if (priceMovement_e18 > maxPercentChange) priceMovement_e18 = maxPercentChange;\n    else if (priceMovement_e18 < -maxPercentChange) priceMovement_e18 = -maxPercentChange;\n\n    // Value change (amount to transfer between Short and Long pools) is based on the price movement multiplied by the\n    // Notional value of the smaller side (long or short). Given the float pool should in most cases make the liquidity of long and short\n    // exactly equal, the only case where long and short liquidity is different is when the float pool leverage is constrained to its 5x or -5x cap.\n    // If this is the case, the side with greater liquidity will have a reduced exposure or delta of their position. I.e. If $1m long and $500k short,\n    // Longs will only get 50% ($500k) long exposure.\n    if (effectiveValueShort > effectiveValueLong) {\n      params.fundingAmount = _calculateFundingAmount(SHORT_TYPE, effectiveValueShort, effectiveValueLong);\n      params.valueChange = priceMovement_e18.mul(int256(effectiveValueLong + uint256(floatPoolLeverage).mul(floatPoolLiquidity)));\n      params.underBalancedSide = LONG_TYPE;\n    } else {\n      params.fundingAmount = _calculateFundingAmount(LONG_TYPE, effectiveValueLong, effectiveValueShort);\n      params.valueChange = priceMovement_e18.mul(int256(effectiveValueShort + uint256(-floatPoolLeverage).mul(floatPoolLiquidity)));\n      params.underBalancedSide = SHORT_TYPE;\n    }\n  }\n\n  /// @notice Reblances the pool given the epoch execution information and can also perform batched actions from the epoch.\n  /// @param epochIndex The index of the epoch to execute\n  /// @param totalEffectiveLiquidityPoolType Effective liquidity of short (0) and long (1) pools\n  /// @param params Compact struct with all parameters needed for rebalance\n  /// @return nextTotalEffectiveLiquidityPoolType Updated short and long liquidities\n  /// @return poolStates Compact struct of pool states after rebalance\n  function _rebalancePoolsAndExecuteBatchedActions(\n    uint32 epochIndex,\n    uint128[2] memory totalEffectiveLiquidityPoolType,\n    int256 floatPoolLeverage,\n    ValueChangeAndFunding memory params\n  ) internal returns (uint128[2] memory nextTotalEffectiveLiquidityPoolType, PoolState[] memory poolStates) {\n    poolStates = new PoolState[](_totalNumberOfPoolTiers);\n    uint8 currentPoolStateIndex;\n\n    // Correctly account for liquidity in long and short by adding the float liquidity to the underbalanced side.\n    totalEffectiveLiquidityPoolType[params.underBalancedSide] += uint128(uint256(pools[PoolType.FLOAT][0].value).mul(floatPoolLeverage.abs()));\n\n    // For every pool (long pools, short pools and float pool)\n    // 1) Adjust poolValue based on price movements and funding (and fees for float pool)\n    // 2) Batch process all new entries and exits in pool\n    for (uint256 poolType = SHORT_TYPE; poolType < POOL_TYPE_UPPER_BOUND; ++poolType) {\n      for (uint256 poolTier = 0; poolTier < _numberOfPoolsOfType[poolType]; ++poolTier) {\n        int256 poolValue = int256(pools[PoolType(poolType)][poolTier].value);\n        PoolFixedConfig memory poolFixedConfig = pools[PoolType(poolType)][poolTier].fixedConfig;\n\n        if (poolType != FLOAT_TYPE) {\n          // To correctly apportion funding owed for the underblananced tiers, we need to remove the float liquidity contribution\n          int256 actualTotalEffectiveLiquidityForPoolType = int256(\n            (uint256(totalEffectiveLiquidityPoolType[poolType]) -\n              (poolType == params.underBalancedSide ? uint256(pools[PoolType.FLOAT][0].value).mul(floatPoolLeverage.abs()) : 0))\n          );\n\n          // Long and short pools both pay funding\n          poolValue +=\n            (((poolValue * poolFixedConfig.leverage * params.valueChange) / int128(totalEffectiveLiquidityPoolType[poolType])) -\n              ((poolValue * poolFixedConfig.leverage * params.fundingAmount[poolType]) / (actualTotalEffectiveLiquidityForPoolType))) /\n            1e18;\n        } else {\n          // Float pool recieves all funding and fees.\n          poolValue +=\n            ((poolValue * floatPoolLeverage * params.valueChange) /\n              (int256(uint256(totalEffectiveLiquidityPoolType[params.underBalancedSide])) * 1e18)) +\n            -params.fundingAmount[SHORT_TYPE] + // funding value is negative for short side (double negative to add it)\n            params.fundingAmount[LONG_TYPE] +\n            int256(feesToDistribute[epochIndex & 1]);\n\n          feesToDistribute[epochIndex & 1] = 0;\n        }\n\n        uint256 tokenSupply = IPoolToken(poolFixedConfig.token).totalSupply();\n        uint256 price = uint256(poolValue).div(tokenSupply);\n\n        // All entries and exits to the pool are processed at latest price based on newly calculated poolValue\n        poolValue += _processAllBatchedEpochActions(epochIndex, PoolType(poolType), poolTier, price, poolFixedConfig.token);\n\n        // We calculate the new total liquidity always excluding the floating tranche.\n        if (poolType != FLOAT_TYPE)\n          nextTotalEffectiveLiquidityPoolType[poolType] += uint128(uint256(poolValue).mul(int256(poolFixedConfig.leverage).abs()));\n\n        pools[PoolType(poolType)][poolTier].value = uint256(poolValue);\n\n        // Token price snapshot for this epoch is used to calculate amount individual token allocation retrospectively for entrants/exits\n        poolToken_priceSnapshot[epochIndex][PoolType(poolType)][poolTier] = price;\n\n        // This structure is purely to emit event info as easily as possible for the indexer.\n        poolStates[currentPoolStateIndex++] = PoolState({\n          poolId: MarketHelpers.packPoolId(PoolType(poolType), uint8(poolTier)),\n          tokenPrice: price,\n          value: poolValue\n        });\n      }\n    }\n  }\n\n  /// @notice System state update function that verifies (instead of trying to find) oracle prices\n  /// @param oracleRoundIdsToExecute The oracle prices that will be the prices for each epoch\n  function updateSystemStateUsingValidatedOracleRoundIds(uint80[] memory oracleRoundIdsToExecute) external checkMarketNotDeprecated {\n    uint32 latestExecutedEpochIndex = epochInfo.latestExecutedEpochIndex;\n    (int256 previousPrice, int256[] memory epochPrices) = oracleManager.validateAndReturnMissedEpochInformation(\n      latestExecutedEpochIndex,\n      epochInfo.latestExecutedOracleRoundId,\n      oracleRoundIdsToExecute\n    );\n\n    uint256 numberOfEpochsToExecute = epochPrices.length;\n\n    uint128[2] memory totalEffectiveLiquidityPoolType = effectiveLiquidityForPoolType;\n\n    for (uint256 i = 0; i < numberOfEpochsToExecute; ) {\n      /* i is incremented later in scope*/\n      (int256 floatPoolLeverage, ValueChangeAndFunding memory rebalanceParams) = _getValueChangeAndFunding(\n        totalEffectiveLiquidityPoolType[LONG_TYPE],\n        totalEffectiveLiquidityPoolType[SHORT_TYPE],\n        // this is the previous execution price, not the previous oracle update price\n        previousPrice,\n        epochPrices[i]\n      );\n\n      previousPrice = epochPrices[i];\n\n      PoolState[] memory poolStates;\n      (totalEffectiveLiquidityPoolType, poolStates) = _rebalancePoolsAndExecuteBatchedActions(\n        latestExecutedEpochIndex + uint32(++i),\n        totalEffectiveLiquidityPoolType,\n        floatPoolLeverage,\n        rebalanceParams\n      );\n\n      emit EpochUpdated(latestExecutedEpochIndex + uint32(i), previousPrice, rebalanceParams.valueChange, rebalanceParams.fundingAmount, poolStates);\n    }\n\n    // Saving the final state of liquidity and info once all epochs have been executed.\n    // In practive, keepers should ensure that the above loop length is only ever 1,\n    // and we are never catching up multiple epochs. This arcitecture is built such that the\n    // the system can gracefully handle missed upkeep fairly.\n    effectiveLiquidityForPoolType = totalEffectiveLiquidityPoolType;\n    epochInfo = EpochInfo({\n      latestExecutedEpochIndex: latestExecutedEpochIndex + uint32(numberOfEpochsToExecute),\n      latestExecutedOracleRoundId: oracleRoundIdsToExecute[oracleRoundIdsToExecute.length - 1]\n    });\n  }\n\n  /*╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice Calculates the fees for the mint amount depending on the market\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function _calculateStabilityFees(uint256 amount) internal view returns (uint256 amountFees) {\n    // stability fee is based on effectiveLiquidity added (takes into account leverage)\n    amountFees = (amount * stabilityFee_basisPoints) / (10000);\n  }\n\n  /// @notice Allows users to mint pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @dev We have to check market not deprecated after system state update because that is the function that determines whether the market should be deprecated.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function _mint(\n    uint112 amount,\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) internal {\n    // ASIDE: This check also checks that the poolType is valid - since if it is invalid it will be zero - and no uint can be less than zero\n    if (uint256(poolTier) >= _numberOfPoolsOfType[uint256(poolType)]) revert InvalidPool();\n\n    if (mintingPaused) revert MintingPaused();\n\n    // Due to get amount of payment token calculation we must have amount * 1e18 > poolTokenPriceInPaymentTokens otherwise we get 0\n    // In fact, all the decimals of amount * 1e18 that are less than poolTokenPriceInPaymentTokens get cut off\n    if (amount < 1e18) revert InvalidActionAmount(amount);\n\n    IERC20(paymentToken).safeTransferFrom(msg.sender, liquidityManager, amount);\n\n    uint256 fees = _calculateStabilityFees(uint256(amount).mul(int256(pools[poolType][poolTier].fixedConfig.leverage).abs()));\n    amount -= uint112(fees);\n\n    uint32 currentEpoch = uint32(oracleManager.getCurrentEpochIndex());\n\n    // Actions cannot take place if upkeep has fallen behind and there are already 2 oustanding epochs needing to be executed\n    if (currentEpoch > epochInfo.latestExecutedEpochIndex + 2)\n      revert MarketStale({currentEpoch: currentEpoch, latestExecutedEpoch: epochInfo.latestExecutedEpochIndex});\n\n    // Before minting we ensure user recieves tokens from any already executed mints in previous epochs.\n    // This ensures the userAction_depositPaymentToken[user][poolType][poolTier] struct will be up to date\n    // and correctly handle to new mint.\n    settlePoolUserMints(user, poolType, poolTier);\n\n    UserAction memory userAction = userAction_depositPaymentToken[user][poolType][poolTier];\n\n    /// NOTE: userAction.amount > 0 IFF userAction.correspondingEpoch <= currentEpoch - this check is redundant for safety.\n    if (userAction.amount > 0 && userAction.correspondingEpoch < currentEpoch) {\n      // This case occurs when a user minted in the previous epoch and upkeep has still not yet\n      // occured and therefore this previous order has not been processed.\n      // This is likely to happen if the user mints early on in a new epoch when enough time has not\n      // passed (see MEWT) for the previous epoch to be executed.\n      userAction.nextEpochAmount += amount;\n    } else {\n      userAction.amount += amount;\n      userAction.correspondingEpoch = currentEpoch;\n    }\n\n    // NOTE: `currentEpoch & 1` and `currentEpoch % 2` are equivalent, but the former is more efficient using bitwise operations.\n    // Since there can only ever be oustanding mint and redeem orders in two consecutive epochs (cannot have oustanding orders in 3 epochs etc)\n    // We use an odd even batch scheme to easily batch orders.\n    pools[poolType][poolTier].batchedAmount[currentEpoch & 1].paymentToken_deposit += amount;\n    feesToDistribute[currentEpoch & 1] += fees;\n\n    userAction_depositPaymentToken[user][poolType][poolTier] = userAction;\n\n    emit Deposit(MarketHelpers.packPoolId(poolType, uint8(poolTier)), amount, fees, user, currentEpoch);\n  }\n\n  /// @notice Allows users to mint long pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintLong(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _mint(amount, msg.sender, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows users to mint short pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintShort(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _mint(amount, msg.sender, PoolType.SHORT, poolTier);\n  }\n\n  /// @notice Allows users to mint float pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintFloatPool(uint112 amount) external {\n    _checkRole(FLOAT_POOL_ROLE, msg.sender);\n    _mint(amount, msg.sender, PoolType.FLOAT, 0); // There is always only one float pool at poolTier index 0\n  }\n\n  /// @notice Allows mint long pool token assets for a market on behalf of some user. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  /// @param user Address of the user.\n  function mintLongFor(\n    uint256 poolTier,\n    uint112 amount,\n    address user\n  ) external override gemCollecting(user) {\n    _mint(amount, user, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows mint short pool token assets for a market on behalf of some user. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  /// @param user Address of the user.\n  function mintShortFor(\n    uint256 poolTier,\n    uint112 amount,\n    address user\n  ) external gemCollecting(user) {\n    _mint(amount, user, PoolType.SHORT, poolTier);\n  }\n\n  /*╔═══════════════════════════╗\n    ║       REDEEM POSITION     ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice Allows users to mint pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @dev We have to check market not deprecated after system state update because that is the function that determines whether the market should be deprecated.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function _redeem(\n    uint112 amount,\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) internal checkMarketNotDeprecated {\n    // In this function, amount refers to the amount of poolToken.\n    // In the _mint function amount refers to the amount of paymentToken\n    // This function is very similar to _mint. See _mint for comprehensive commenting\n    if (amount < 1e12) revert InvalidActionAmount(amount);\n\n    uint32 currentEpoch = uint32(oracleManager.getCurrentEpochIndex());\n    if (currentEpoch > epochInfo.latestExecutedEpochIndex + 2)\n      revert MarketStale({currentEpoch: currentEpoch, latestExecutedEpoch: epochInfo.latestExecutedEpochIndex});\n\n    settlePoolUserRedeems(user, poolType, poolTier);\n\n    //slither-disable-next-line unchecked-transfer\n    // If an invalid poolType and poolTier is passed, this will revert.\n    IPoolToken(pools[poolType][poolTier].fixedConfig.token).transferFrom(user, address(this), amount);\n\n    UserAction memory userAction = userAction_redeemPoolToken[user][poolType][poolTier];\n\n    if (userAction.amount > 0 && userAction.correspondingEpoch < currentEpoch) {\n      userAction.nextEpochAmount += amount;\n    } else {\n      userAction.amount += amount;\n      userAction.correspondingEpoch = currentEpoch;\n    }\n\n    // NOTE: `currentEpoch & 1` and `currentEpoch % 2` are equivalent, but the former is more efficient using bitwise operations.\n    pools[poolType][poolTier].batchedAmount[currentEpoch & 1].poolToken_redeem += amount;\n\n    userAction_redeemPoolToken[user][poolType][poolTier] = userAction;\n\n    emit Redeem(MarketHelpers.packPoolId(poolType, uint8(poolTier)), amount, user, currentEpoch);\n  }\n\n  /// @notice Allows users to mint long pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  function redeemLong(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _redeem(amount, msg.sender, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows users to redeem short pool token assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to redeem pool token assets at next price.\n  function redeemShort(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _redeem(amount, msg.sender, PoolType.SHORT, poolTier);\n  }\n\n  /// @notice Allows users to redeem"
    }
  ]
}