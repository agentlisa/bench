{
  "Title": "[H-04] Malicious delegatees can block delegators from redelegating and from sending their NFTs",
  "Content": "\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/base/VotesUpgradeable.sol#L166> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/base/VotesUpgradeable.sol#L235-L244> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/base/ERC721CheckpointableUpgradeable.sol#L41>\n\nIf user `X` delegates his votes to `Y`, `Y` can block `X` from redelegating and even from sending his NFT anywhere, forever.\n\n### Detailed description\n\nUsers can acquire votes in two ways:\n\n*   by having some `NontransferableERC20Votes` tokens\n*   by having `VerbsToken` tokens\n\nIt is possible for them to delegate their votes to someone else. It is handled in the `VotesUpgradable` contract, that is derived from OpenZeppelin's `VotesUpgradable` and the following change is made with respect to the original implementation:\n\n```diff\nfunction delegates(address account) public view virtual returns (address) {\n-        return $._delegatee[account];\n+        return $._delegatee[account] == address(0) ? account : $._delegatee[account];\n```\n\nIt is meant to be a convenience feature so that users don't have to delegate to themselves in order to be able to vote. However, it has very serious implications.\n\nIn order to see that, let's look at the `_moveDelegateVotes` function that is invoked every time someone delegates his votes or wants to transfer a voting token (`VerbsToken` in this case as `NontransferableERC20Votes` is non-transferable):\n\n```solidity\n    function _moveDelegateVotes(address from, address to, uint256 amount) private {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[from],\n                    _subtract,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[to],\n                    _add,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n```\n\nAs can be seen, it subtracts votes from current delegatee and adds them to the new one. There are 2 edge cases here:\n\n*   `from == address(0)`, which is the case when current delegatee equals `0`\n*   `to == address(0)`, which is the case when users delegates to `0`\n\nIf any of these conditions hold, only one of `$._delegateCheckpoints` is updated. This is fine in the original implementation as the function ignores cases when `from == to` and if function updates only `$._delegateCheckpoints[from]` it means that a user was delegating to `0` and when he changes delegatee, votes only should be added to some account, not subtracted from any account. Similarly, if the function updates only  `$._delegateCheckpoints[to]`, it means that user temporarily removes his votes from the system and hence his current delegatee's votes should be subtracted and not added into any other account.\n\nAs long as user cannot cause this function to update one of `$._delegateCheckpoints[from]` and `$._delegateCheckpoints[to]` several times in a row, it works correctly. It is indeed the case in the original OpenZeppelin's implementation as when `from == to`, function doesn't perform any operation.\n\n**However, the problem with the current implementation is that it is possible to call this function with `to == 0` several times in a row.** In order to see it, consider the `_delegate` function which is called when users want to (re)delegate their votes:\n\n```solidity\n    function _delegate(address account, address delegatee) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        address oldDelegate = delegates(account);\n        $._delegatee[account] = delegatee;\n\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n```\n\nAs we can see, it calls `_moveDelegateVotes`, but with `oldDelegate` equal to `delegates(account)`. **But if `$._delegatee[account] == address(0)`, that function returns `account`**.\n\nIt means that `_moveDelegateVotes` can be called several times in a row with parameters `(account, 0, _getVotingUnits(account))`. In other words, if user delegates to `address(0)`, he will be able to do it several times in a row as `from` will be different than `to` in `_moveDelegateVotes` and the function will subtract his amount of votes from his `$._delegateCheckpoints` every time.\n\nIt may seem that a user `X` who delegates to `address(0)` multiple times will only harm himself, but it's not true as someone else can delegate to him and each time he delegates to `0`, his original voting power will be subtracted from his `$._delegateCheckpoints`, making it `0` or some small, value. If a user `Y` who delegated to `X` wants to redelegate to someone else or transfer his tokens, `_moveDelegateVotes` will revert with integer underflow as it will try to subtract `Y`'s votes from `$._delegateCheckpoints[X]`, but it will already be either a small number or even `0` meaning that `Y` will be unable to transfer his tokens or redelegate.\n\n### Impact\n\nVictims of the exploit presented above will neither be able to transfer their NFTs (the same would be true for `NontransferableERC20Votes`, but it's not transferable by design) nor to even redelegate back to themselves or to any other address.\n\nWhile it can be argued that users will only delegate to users they trust, I argue that the issue is of High severity because of the following reasons:\n\n*   Possibility of delegating is implemented in the code and it's expected to be used.\n*   Every user who uses it risks the loss of access to all his NFTs and to redelegating his votes.\n*   Even when delegatees are trusted, it still shouldn't be possible for them to block redelegating and blocking access to NFTs of their delegators; if delegators stop trusting delegatees, they should have a possibility to redelegate back, let alone to have access to their own NFTs, which is not the case in the current implementation.\n*   The attack is not costly for the attacker as he doesn't have to lose any tokens - for instance, if he has `1` NFT and the victim who delegates to him has `10`, he can delegate to `address(0)` `10` times and then transfer his NFT to a different address - it will still block his victim and the attacker wouldn't lose anything.\n\n### Proof of Concept\n\nPlease put the following test into the `Voting.t.sol` file and run it. It shows how a victim loses access to all his votes and all his NFTs just by delegating to someone:\n\n<details>\n\n```solidity\n    function testBlockingOfTransferAndRedelegating() public\n    {\n        address user = address(0x1234);\n        address attacker = address(0x4321);\n\n        vm.stopPrank();\n\n        // create 3 random pieces\n        createDefaultArtPiece();\n        createDefaultArtPiece();\n        createDefaultArtPiece();\n\n        // transfer 2 pieces to normal user and 1 to the attacker\n        vm.startPrank(address(auction));\n        erc721Token.mint();\n        erc721Token.transferFrom(address(auction), user, 0);\n\n        erc721Token.mint();\n        erc721Token.transferFrom(address(auction), user, 1);\n\n        erc721Token.mint();\n        erc721Token.transferFrom(address(auction), attacker, 2);\n\n        vm.stopPrank();\n        \n        // user delegates his votes to attacker\n        vm.prank(user);\n        erc721Token.delegate(attacker);\n\n        // attacker delegates to address(0) multiple times, blocking user from redelegating\n        vm.prank(attacker);\n        erc721Token.delegate(address(0));\n\n        vm.prank(attacker);\n        erc721Token.delegate(address(0));\n\n        // now, user cannot redelegate\n        vm.prank(user);\n        vm.expectRevert();\n        erc721Token.delegate(user);\n\n        // attacker transfer his only NFT to an address controlled by himself\n        // he doesn't lose anything, but he still trapped victim's votes and NFTs\n        vm.prank(attacker);\n        erc721Token.transferFrom(attacker, address(0x43214321), 2);\n\n        // user cannot transfer any of his NTFs either\n        vm.prank(user);\n        vm.expectRevert();\n        erc721Token.transferFrom(user, address(0x1234567890), 0);\n    }\n```\n</details>\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nDo not allow users to delegate to `address(0)`.\n\n**[rocketman-21 (Revolution) confirmed and commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/49#issuecomment-1885578994):**\n > This is valid, major find thank you so much.\n> \n> Proposed fix here:\n> https://github.com/collectivexyz/revolution-protocol/commit/ef2a492e93e683f5d9d8c77cbcf3622bb936522a\n\n**[0xTheC0der (Judge) commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/49#issuecomment-1885621992):**\n > Warden has shown how assets can be permanently frozen.\n\n***\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/base/VotesUpgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/Votes.sol)\npragma solidity ^0.8.20;\n\nimport { IERC5805 } from \"@openzeppelin/contracts/interfaces/IERC5805.sol\";\nimport { ContextUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport { NoncesUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol\";\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport { Checkpoints } from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { Time } from \"@openzeppelin/contracts/utils/types/Time.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_update}).\n */\n\n/**\n * @dev MODIFICATIONS\n * Checkpointing logic from VotesUpgradeable.sol has been used with the following modifications:\n * - `delegates` is renamed to `_delegates` and is set to private\n * - `delegates` is a public function that uses the `_delegates` mapping look-up, but unlike\n *   VotesUpgradeable.sol, returns the delegator's own address if there is no delegate.\n *   This avoids the delegator needing to \"delegate to self\" with an additional transaction\n */\n\nabstract contract VotesUpgradeable is\n    Initializable,\n    ContextUpgradeable,\n    EIP712Upgradeable,\n    NoncesUpgradeable,\n    IERC5805\n{\n    using Checkpoints for Checkpoints.Trace208;\n\n    bytes32 private constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Votes\n    struct VotesStorage {\n        mapping(address account => address) _delegatee;\n        mapping(address delegatee => Checkpoints.Trace208) _delegateCheckpoints;\n        Checkpoints.Trace208 _totalCheckpoints;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Votes\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 public constant VotesStorageLocation = 0xe8b26c30fad74198956032a3533d903385d56dd795af560196f9c78d4af40d00;\n\n    function _getVotesStorage() private pure returns (VotesStorage storage $) {\n        assembly {\n            $.slot := VotesStorageLocation\n        }\n    }\n\n    /**\n     * @dev The clock was incorrectly modified.\n     */\n    error ERC6372InconsistentClock();\n\n    /**\n     * @dev Lookup to future votes is not available.\n     */\n    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);\n\n    function __Votes_init() internal onlyInitializing {}\n\n    function __Votes_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based\n     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.\n     */\n    function clock() public view virtual returns (uint48) {\n        return Time.blockNumber();\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory) {\n        // Check that the clock was not modified\n        if (clock() != Time.blockNumber()) {\n            revert ERC6372InconsistentClock();\n        }\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return $._delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return $._totalCheckpoints.upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._totalCheckpoints.latest();\n    }\n\n    // /**\n    //  * @notice Overrides the standard `VotesUpgradeable.sol` delegates mapping to return\n    //  * the accounts's own address if they haven't delegated.\n    //  * This avoids having to delegate to oneself.\n    //  */\n    function delegates(address account) public view virtual returns (address) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegatee[account] == address(0) ? account : $._delegatee[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > expiry) {\n            revert VotesExpiredSignature(expiry);\n        }\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        _useCheckedNonce(signer, nonce);\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        address oldDelegate = delegates(account);\n        $._delegatee[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from == address(0)) {\n            _push($._totalCheckpoints, _add, SafeCast.toUint208(amount));\n        }\n        if (to == address(0)) {\n            _push($._totalCheckpoints, _subtract, SafeCast.toUint208(amount));\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(address from, address to, uint256 amount) private {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[from],\n                    _subtract,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[to],\n                    _add,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function _numCheckpoints(address account) internal view virtual returns (uint32) {\n        VotesStorage storage $ = _getVotesStorage();\n        return SafeCast.toUint32($._delegateCheckpoints[account].length());\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function _checkpoints(\n        address account,\n        uint32 pos\n    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].at(pos);\n    }\n\n    function _push(\n        Checkpoints.Trace208 storage store,\n        function(uint208, uint208) view returns (uint208) op,\n        uint208 delta\n    ) private returns (uint208, uint208) {\n        return store.push(clock(), op(store.latest(), delta));\n    }\n\n    function _add(uint208 a, uint208 b) private pure returns (uint208) {\n        return a + b;\n    }\n\n    function _subtract(uint208 a, uint208 b) private pure returns (uint208) {\n        return a - b;\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "packages/revolution/src/base/VotesUpgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/Votes.sol)\npragma solidity ^0.8.20;\n\nimport { IERC5805 } from \"@openzeppelin/contracts/interfaces/IERC5805.sol\";\nimport { ContextUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport { NoncesUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol\";\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport { Checkpoints } from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { Time } from \"@openzeppelin/contracts/utils/types/Time.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_update}).\n */\n\n/**\n * @dev MODIFICATIONS\n * Checkpointing logic from VotesUpgradeable.sol has been used with the following modifications:\n * - `delegates` is renamed to `_delegates` and is set to private\n * - `delegates` is a public function that uses the `_delegates` mapping look-up, but unlike\n *   VotesUpgradeable.sol, returns the delegator's own address if there is no delegate.\n *   This avoids the delegator needing to \"delegate to self\" with an additional transaction\n */\n\nabstract contract VotesUpgradeable is\n    Initializable,\n    ContextUpgradeable,\n    EIP712Upgradeable,\n    NoncesUpgradeable,\n    IERC5805\n{\n    using Checkpoints for Checkpoints.Trace208;\n\n    bytes32 private constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Votes\n    struct VotesStorage {\n        mapping(address account => address) _delegatee;\n        mapping(address delegatee => Checkpoints.Trace208) _delegateCheckpoints;\n        Checkpoints.Trace208 _totalCheckpoints;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Votes\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 public constant VotesStorageLocation = 0xe8b26c30fad74198956032a3533d903385d56dd795af560196f9c78d4af40d00;\n\n    function _getVotesStorage() private pure returns (VotesStorage storage $) {\n        assembly {\n            $.slot := VotesStorageLocation\n        }\n    }\n\n    /**\n     * @dev The clock was incorrectly modified.\n     */\n    error ERC6372InconsistentClock();\n\n    /**\n     * @dev Lookup to future votes is not available.\n     */\n    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);\n\n    function __Votes_init() internal onlyInitializing {}\n\n    function __Votes_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based\n     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.\n     */\n    function clock() public view virtual returns (uint48) {\n        return Time.blockNumber();\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory) {\n        // Check that the clock was not modified\n        if (clock() != Time.blockNumber()) {\n            revert ERC6372InconsistentClock();\n        }\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return $._delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return $._totalCheckpoints.upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._totalCheckpoints.latest();\n    }\n\n    // /**\n    //  * @notice Overrides the standard `VotesUpgradeable.sol` delegates mapping to return\n    //  * the accounts's own address if they haven't delegated.\n    //  * This avoids having to delegate to oneself.\n    //  */\n    function delegates(address account) public view virtual returns (address) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegatee[account] == address(0) ? account : $._delegatee[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > expiry) {\n            revert VotesExpiredSignature(expiry);\n        }\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        _useCheckedNonce(signer, nonce);\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        address oldDelegate = delegates(account);\n        $._delegatee[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from == address(0)) {\n            _push($._totalCheckpoints, _add, SafeCast.toUint208(amount));\n        }\n        if (to == address(0)) {\n            _push($._totalCheckpoints, _subtract, SafeCast.toUint208(amount));\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(address from, address to, uint256 amount) private {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[from],\n                    _subtract,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[to],\n                    _add,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function _numCheckpoints(address account) internal view virtual returns (uint32) {\n        VotesStorage storage $ = _getVotesStorage();\n        return SafeCast.toUint32($._delegateCheckpoints[account].length());\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function _checkpoints(\n        address account,\n        uint32 pos\n    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].at(pos);\n    }\n\n    function _push(\n        Checkpoints.Trace208 storage store,\n        function(uint208, uint208) view returns (uint208) op,\n        uint208 delta\n    ) private returns (uint208, uint208) {\n        return store.push(clock(), op(store.latest(), delta));\n    }\n\n    function _add(uint208 a, uint208 b) private pure returns (uint208) {\n        return a + b;\n    }\n\n    function _subtract(uint208 a, uint208 b) private pure returns (uint208) {\n        return a - b;\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "packages/revolution/src/base/ERC721CheckpointableUpgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721Votes.sol)\n\npragma solidity ^0.8.22;\n\nimport { ERC721EnumerableUpgradeable } from \"./ERC721EnumerableUpgradeable.sol\";\nimport { VotesUpgradeable } from \"./VotesUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC-721 to support voting and delegation as implemented by {Votes}, where each individual NFT counts\n * as 1 vote unit.\n *\n * Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost\n * on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of\n * the votes in governance decisions, or they can delegate to themselves to be their own representative.\n */\n\n/**\n * @dev MODIFICATIONS\n * Checkpointing logic from VotesUpgradeable.sol has been used with the following modifications:\n * - `delegates` is renamed to `_delegates` and is set to private\n * - `delegates` is a public function that uses the `_delegates` mapping look-up, but unlike\n *   VotesUpgradeable.sol, returns the delegator's own address if there is no delegate.\n *   This avoids the delegator needing to \"delegate to self\" with an additional transaction\n */\n\nabstract contract ERC721CheckpointableUpgradeable is Initializable, ERC721EnumerableUpgradeable, VotesUpgradeable {\n    function __ERC721Votes_init() internal onlyInitializing {}\n\n    function __ERC721Votes_init_unchained() internal onlyInitializing {}\n\n    /**\n     * @dev See {ERC721-_update}. Adjusts votes when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n\n        _transferVotingUnits(previousOwner, to, 1);\n\n        return previousOwner;\n    }\n\n    function getVotesStorage() private pure returns (VotesStorage storage $) {\n        assembly {\n            $.slot := VotesStorageLocation\n        }\n    }\n\n    // /**\n    //  * @notice Overrides the standard `VotesUpgradeable.sol` delegates mapping to return\n    //  * the accounts's own address if they haven't delegated.\n    //  * This avoids having to delegate to oneself.\n    //  */\n    function delegates(address account) public view override returns (address) {\n        VotesStorage storage $ = getVotesStorage();\n        return $._delegatee[account] == address(0) ? account : $._delegatee[account];\n    }\n\n    /**\n     * @dev Returns the balance of `account`.\n     *\n     * WARNING: Overriding this function will likely result in incorrect vote tracking.\n     */\n    function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * @dev See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch.\n     */\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        super._increaseBalance(account, amount);\n        _transferVotingUnits(address(0), account, amount);\n    }\n}"
    }
  ]
}