{
  "Title": "M-3: recover() using the standard transfer may not be able to retrieve some tokens",
  "Content": "# Issue M-3: recover() using the standard transfer may not be able to retrieve some tokens \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/19 \n\n## Found by \nAuditorPraise, MohammedRizwan, bin2chen, twicek\n## Summary\nin `SecondaryRewarder.recover()`\nUsing the standard `IERC20.transfer()`\nIf `REWARD_TOKEN` is like `USDT`, it will not be able to transfer out, because this kind of `token` does not return `bool`\nThis will cause it to always `revert`\n\n## Vulnerability Detail\n`SecondaryRewarder.recover()` use for \n\n> Allows the Notional owner to recover any tokens sent to the address or any reward tokens remaining on the contract in excess of the total rewards emitted.\n\n```solidity\n    function recover(address token, uint256 amount) external onlyOwner {\n        if (Constants.ETH_ADDRESS == token) {\n            (bool status,) = msg.sender.call{value: amount}(\"\");\n            require(status);\n        } else {\n@>          IERC20(token).transfer(msg.sender, amount);\n        }\n    }\n```\nUsing the standard `IERC20.transfer()` method to execute the transfer\nA `token` of a type similar to `USDT` has no return value\nThis will cause the execution of the transfer to always fail\n\n## Impact\n\nIf `REWARD_TOKEN` is like `USDT`, it will not be able to transfer out.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/external/adapters/SecondaryRewarder.sol#L152C3-L159\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\n    function recover(address token, uint256 amount) external onlyOwner {\n        if (Constants.ETH_ADDRESS == token) {\n            (bool status,) = msg.sender.call{value: amount}(\"\");\n            require(status);\n        } else {\n-          IERC20(token).transfer(msg.sender, amount);\n+          GenericToken.safeTransferOut(token,msg.sender,amount);\n        }\n    }\n```\n\n\n\n## Discussion\n\n**nevillehuang**\n\n@jeffywu @T-Woodward Were there any publicly available information stating USDT won't be use as a potential reward tokens at the point of the contest?\n\n**sherlock-admin2**\n\n> Escalate\n> Upon closer examination and in alignment with the [Sherlock rules](https://docs.sherlock.xyz/audits/judging/judging), it becomes evident that issues of this nature are categorically classified under informational issues. Furthermore, should we acknowledge the concerns surrounding `safeTransferOut` due to `USDT` peculiarities, it is imperative to underscore that, at most, this warrants a classification of low severity. This is primarily because the core functionality of the protocol remains unaffected and fully operational without getting bricked. \n\nYou've deleted an escalation for this issue.\n\n**AuditorPraise**\n\n> Escalate Upon closer examination and in alignment with the [Sherlock rules](https://docs.sherlock.xyz/audits/judging/judging), it becomes evident that issues of this nature are categorically classified under informational issues. Furthermore, should we acknowledge the concerns surrounding `safeTransferOut` due to `USDT` peculiarities, it is imperative to underscore that, at most, this warrants a classification of low severity. This is primarily because the core functionality of the protocol remains unaffected and fully operational without getting bricked.\n\n\"Non-Standard tokens: Issues related to tokens with non-standard behaviors, such as [weird-tokens](https://github.com/d-xo/weird-erc20) are not considered valid by default unless these tokens are explicitly mentioned in the README\"\n\ncontest readme::\n```\n Do you expect to use any of the following tokens with non-standard behaviour with the smart contracts?\n\nUSDC and USDT are the primary examples.\n\n```\n\n**0xMR0**\n\nEscalate\n\nThis is indeed a valid issue since the non-standard behavior of USDT is not acceptable to protocol team and it is explicitly mentioned in contest readme. \n\nFurther, comment by @AuditorPraise is correct and enough for the validation of this issue.\n\n\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This is indeed a valid issue since the non-standard behavior of USDT is not acceptable to protocol team and it is explicitly mentioned in contest readme. \n> \n> Further, comment by @AuditorPraise is correct and enough for the validation of this issue.\n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Hash01011122**\n\nIMO In my opinion, the issue with `safeTransfer` has been widely recognized since 2022. Furthermore, it seems unfair to Watson who are discovering different vulnerabilities along with their attack paths. For instance, the issue of hardcoded `chainId` was previously classified as high severity. However, as seen in this [issue](https://github.com/sherlock-audit/2023-12-dodo-gsp-judging/issues/113), it was downgraded to low severity due to its widespread awareness and ease of discovery. \n\n**As mentioned in sherlock [rules](https://docs.sherlock.xyz/audits/judging/judging):**\n**Low/Informational Issues:** While Sherlock acknowledges that it would be great to include & reward low-impact/informational issues, we strongly feel that Watsons should focus on finding the most critical vulnerabilities that will potentially cause millions of dollars of losses on mainnet. Sherlock understands that it could be missing out on some potential \"value add\" for protocol, but it's only because the real task of finding critical vulnerabilities requires 100% of the attention of Watsons. While low/informational issues are not rewarded individually if a Watson identifies an attack vector that combines multiple lows to cause significant loss/damage that would still be categorized as a valid medium/high.\n\n\n**AuditorPraise**\n\n> IMO In my opinion, the issue with `safeTransfer` has been widely recognized since 2022. \n\nThe issue isn't about `safeTransfer` but USDT.\nIt's no one's fault that devs still make such mistakes... But that doesn't reduce the risks associated with making such a mistake. The impact it has had on protocols since 2022 till now remains the same. \n\nFunds could be stuck \n\nSo why should it be an informational now?\n\nYou can't compare chain Id issue to USDT being stuck in a contract as a result of the devs not using safeTransfer.\n\n**nevillehuang**\n\n@Hash01011122 You are circling too much around sherlock rules, and should look at it more factually instead of subjectively. In the contest details/code logic/documentation, no place does it mention that USDT cannot be a reward token, so I believe your argument is basically invalid. I believe no further discussions is required from my side, imo, this should remain medium severity.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xMR0](https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/19/#issuecomment-1925588123): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "contracts-v3/contracts/external/adapters/SecondaryRewarder.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\n\nimport {GenericToken} from \"../../internal/balances/protocols/GenericToken.sol\";\nimport {IRewarder} from \"../../../interfaces/notional/IRewarder.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {FloatingPoint} from \"../../math/FloatingPoint.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\n\ncontract SecondaryRewarder is IRewarder {\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n\n    NotionalProxy public immutable NOTIONAL;\n    address public immutable override NTOKEN_ADDRESS;\n    address public immutable REWARD_TOKEN;\n    uint8 public immutable REWARD_TOKEN_DECIMALS;\n    uint16 public immutable override CURRENCY_ID;\n\n    /// @notice When a rewarder is detached, it converts to an airdrop contract using the\n    /// this merkleRoot that is set.\n    /// @dev Uses a single storage slot\n    bytes32 public merkleRoot;\n\n    /* Rest of storage variables are packed into 256 bits */\n    /// @notice When true user needs to call contract directly to claim any rewards left\n    bool public override detached;\n\n    /// @notice Marks the timestamp when incentives will end. Will always be less than block.timestamp\n    /// if detached is true.\n    uint32 public endTime;\n\n    /// @notice Last time the contract accumulated the reward\n    uint32 public override lastAccumulatedTime;\n\n    // The emission rate of REWARD_TOKEN in INTERNAL_TOKEN_PRECISION packed to uint56\n    uint56 private packedEmissionRatePerYear;\n\n    /// @notice Aggregate tokens accumulated per nToken at `lastAccumulateTime` \n    //  in INCENTIVE_ACCUMULATION_PRECISION\n    uint128 public override accumulatedRewardPerNToken;\n\n    /// @notice Reward debt per account stored in 18 decimals.\n    mapping(address => uint128) public rewardDebtPerAccount;\n\n    modifier onlyOwner() {\n        require(msg.sender == NOTIONAL.owner(), \"Only owner\");\n        _;\n    }\n\n    modifier onlyNotional() {\n        require(msg.sender == address(NOTIONAL), \"Only Notional\");\n        _;\n    }\n\n    constructor(\n        NotionalProxy notional,\n        uint16 currencyId,\n        IERC20 incentive_token,\n        uint128 _emissionRatePerYear, // in INTERNAL_TOKEN_PRECISION\n        uint32 _endTime\n    ) {\n        NOTIONAL = notional;\n        CURRENCY_ID = currencyId;\n        NTOKEN_ADDRESS = notional.nTokenAddress(currencyId);\n        REWARD_TOKEN = address(incentive_token);\n        REWARD_TOKEN_DECIMALS = IERC20(address(incentive_token)).decimals();\n\n        packedEmissionRatePerYear = FloatingPoint.packTo56Bits(_emissionRatePerYear);\n        lastAccumulatedTime = uint32(block.timestamp);\n        require(lastAccumulatedTime < _endTime, \"Invalid End Time\");\n        endTime = _endTime;\n    }\n\n    /// @notice The emission rate of REWARD_TOKEN in INTERNAL_TOKEN_PRECISION\n    function emissionRatePerYear() public view override returns(uint128) {\n        return uint128(FloatingPoint.unpackFromBits(packedEmissionRatePerYear));\n    }\n\n    /// @notice Get amount of reward account can claim at specified block time, only called before rewarder is detached\n    /// @param account address to get reward amount for\n    /// @param blockTime block time at which to get reward amount\n    function getAccountRewardClaim(address account, uint32 blockTime)\n        external\n        view\n        override\n        returns (uint256 rewardToClaim)\n    {\n        require(!detached, \"Detached\");\n        require(lastAccumulatedTime <= blockTime, \"Invalid block time\");\n\n        uint256 totalSupply = IERC20(NTOKEN_ADDRESS).totalSupply();\n        uint256 nTokenBalance = IERC20(NTOKEN_ADDRESS).balanceOf(account);\n\n        uint32 time = uint32(SafeInt256.min(blockTime, endTime));\n        uint128 rewardsPerNToken = _getAccumulatedRewardPerToken(time, totalSupply);\n        rewardToClaim = _calculateRewardToClaim(account, nTokenBalance, rewardsPerNToken);\n    }\n\n    /// @notice Get amount of reward still left for account to claim, only called after rewarder is detached\n    /// and merkle root is set\n    /// @param account address to get reward amount for\n    /// @param nTokenBalanceAtDetach nToken balance of account at time of detachment\n    /// @param proof merkle proof to prove account and nTokenBalanceAtDetach are in tree\n    function getAccountRewardClaim(address account, uint256 nTokenBalanceAtDetach, bytes32[] calldata proof)\n        external\n        view\n        override\n        returns (uint256 rewardToClaim)\n    {\n        require(detached && merkleRoot != bytes32(0), \"Not detached\");\n\n        _checkProof(account, nTokenBalanceAtDetach, proof);\n        // no need to accumulate, it was already accumulated when rewarder was detached\n        rewardToClaim = _calculateRewardToClaim(account, nTokenBalanceAtDetach, accumulatedRewardPerNToken);\n    }\n\n    /// @notice Set incentive emission rate and incentive period end time, called only in case emission\n    /// rate or incentive period changes since it is already set at deploy time, only can be called before\n    /// rewarder is detached\n    /// @param _emissionRatePerYear emission rate per year in INTERNAL_TOKEN_PRECISION\n    /// @param _endTime time in seconds when incentive period will end\n    function setIncentiveEmissionRate(uint128 _emissionRatePerYear, uint32 _endTime) external onlyOwner {\n        require(!detached, \"Detached\");\n        uint256 totalSupply = IERC20(NTOKEN_ADDRESS).totalSupply();\n\n        _accumulateRewardPerNToken(uint32(block.timestamp), totalSupply);\n\n        packedEmissionRatePerYear = FloatingPoint.packTo56Bits(_emissionRatePerYear);\n        // lastAccumulatedTime is at block.timestamp here, ensure that the end time is always\n        // further in the future.\n        require(lastAccumulatedTime < _endTime, \"Invalid End Time\");\n        endTime = _endTime;\n\n        emit RewardEmissionUpdate(FloatingPoint.unpackFromBits(packedEmissionRatePerYear), _endTime);\n    }\n\n    /// @notice Set merkle root, only called after rewarder is detached\n    /// @param _merkleRoot merkle root of the tree that contains accounts and nToken balances at detach time\n    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        require(_merkleRoot != bytes32(0), \"Invalid\");\n        merkleRoot = _merkleRoot;\n    }\n\n    /// @notice Allows owner to recover any ERC20 or ETH mistakenly sent to this contract\n    /// @param token address of the token to recover, in case of ETH pass address(0)\n    /// @param amount amount to recover\n    function recover(address token, uint256 amount) external onlyOwner {\n        if (Constants.ETH_ADDRESS == token) {\n            (bool status,) = msg.sender.call{value: amount}(\"\");\n            require(status);\n        } else {\n            IERC20(token).transfer(msg.sender, amount);\n        }\n    }\n\n    /// @dev Called from Notional system to detach rewarder when switching to a new rewarder or when incentive\n    /// period is over, after this merkle tree of user nToken balances at detach time should be generated\n    /// offline and merkle root uploaded to this contract\n    function detach() external override onlyNotional {\n        require(!detached, \"Already detached\");\n\n        // accumulate for the last time if needed\n        uint256 totalSupply = IERC20(NTOKEN_ADDRESS).totalSupply();\n        _accumulateRewardPerNToken(uint32(block.timestamp), totalSupply);\n\n        detached = true;\n        packedEmissionRatePerYear = 0;\n\n        if (block.timestamp < endTime) {\n            endTime = uint32(block.timestamp);\n        }\n\n        emit RewardEmissionUpdate(0, endTime);\n    }\n\n    /// @notice Allows claiming rewards after rewarder has been detached\n    /// @param account address to claim rewards for\n    /// @param nTokenBalanceAtDetach nToken balance of account at time of detachment\n    /// @param proof merkle proof to prove account and nTokenBalanceAtDetach are in tree\n    function claimRewardsDirect(address account, uint256 nTokenBalanceAtDetach, bytes32[] calldata proof)\n        external\n        override\n    {\n        require(detached, \"Not detached\");\n\n        _checkProof(account, nTokenBalanceAtDetach, proof);\n\n        _claimRewards(account, nTokenBalanceAtDetach, nTokenBalanceAtDetach);\n    }\n\n    /// @notice Allows claiming rewards but only from Notional system, called on each nToken balance change\n    /// @param account address to claim rewards for\n    /// @param currencyId id number of the currency\n    /// @param nTokenBalanceBefore account nToken balance before the change\n    /// @param nTokenBalanceAfter account nToken balance after the change\n    /// @param priorNTokenSupply total nToken supply before the change\n    function claimRewards(\n        address account,\n        uint16 currencyId,\n        uint256 nTokenBalanceBefore,\n        uint256 nTokenBalanceAfter,\n        uint256 priorNTokenSupply\n    ) external override onlyNotional {\n        require(!detached, \"Detached\");\n        require(currencyId == CURRENCY_ID, \"Wrong currency id\");\n\n        _accumulateRewardPerNToken(uint32(block.timestamp), priorNTokenSupply);\n        _claimRewards(account, nTokenBalanceBefore, nTokenBalanceAfter);\n    }\n\n    function _claimRewards(address account, uint256 nTokenBalanceBefore, uint256 nTokenBalanceAfter) private {\n        uint256 rewardToClaim = _calculateRewardToClaim(account, nTokenBalanceBefore, accumulatedRewardPerNToken);\n\n        // Precision here is:\n        //  nTokenBalanceAfter (INTERNAL_TOKEN_PRECISION)\n        //  accumulatedRewardPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\n        // DIVIDE BY\n        //  INTERNAL_TOKEN_PRECISION\n        //  => INCENTIVE_ACCUMULATION_PRECISION (1e18)\n        rewardDebtPerAccount[account] = nTokenBalanceAfter\n            .mul(accumulatedRewardPerNToken)\n            .div(uint256(Constants.INTERNAL_TOKEN_PRECISION))\n            .toUint128();\n\n        if (0 < rewardToClaim) {\n            GenericToken.safeTransferOut(REWARD_TOKEN, account, rewardToClaim);\n            emit RewardTransfer(REWARD_TOKEN, account, rewardToClaim);\n        }\n    }\n\n    function _getAccumulatedRewardPerToken(uint32 time, uint256 totalSupply) private view returns (uint128) {\n        uint256 additionalIncentiveAccumulatedPerNToken;\n        if (lastAccumulatedTime < time && 0 < totalSupply) {\n            // NOTE: no underflow, checked in if statement\n            uint256 timeSinceLastAccumulation = time - lastAccumulatedTime;\n            // Precision here is:\n            //  timeSinceLastAccumulation (SECONDS)\n            //  INCENTIVE_ACCUMULATION_PRECISION (1e18)\n            //  INTERNAL_TOKEN_PRECISION (1e8)\n            // DIVIDE BY\n            //  YEAR (SECONDS)\n            //  INTERNAL_TOKEN_PRECISION (1e8)\n            // => Precision = INCENTIVE_ACCUMULATION_PRECISION * INTERNAL_TOKEN_PRECISION / INTERNAL_TOKEN_PRECISION\n            // => 1e18\n            additionalIncentiveAccumulatedPerNToken = timeSinceLastAccumulation\n                .mul(Constants.INCENTIVE_ACCUMULATION_PRECISION)\n                .mul(emissionRatePerYear())\n                .div(Constants.YEAR)\n                .div(totalSupply);\n        }\n\n        return uint256(accumulatedRewardPerNToken).add(additionalIncentiveAccumulatedPerNToken).toUint128();\n    }\n\n    function _accumulateRewardPerNToken(uint32 blockTime, uint256 totalSupply) private {\n        // Ensure that end time is set to some value\n        require(0 < endTime);\n        uint32 time = uint32(SafeInt256.min(blockTime, endTime));\n\n        accumulatedRewardPerNToken = _getAccumulatedRewardPerToken(time, totalSupply);\n\n        lastAccumulatedTime = uint32(block.timestamp);\n    }\n\n    function _calculateRewardToClaim(address account, uint256 nTokenBalanceAtLastClaim, uint128 rewardsPerNToken)\n        private\n        view\n        returns (uint256)\n    {\n        // Precision here is:\n        //   nTokenBalanceAtLastClaim (INTERNAL_TOKEN_PRECISION)\n        //   mul rewardsPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\n        //   div INTERNAL_TOKEN_PRECISION\n        // => INCENTIVE_ACCUMULATION_PRECISION\n        // SUB rewardDebtPerAccount (INCENTIVE_ACCUMULATION_PRECISION)\n        //\n        // - mul REWARD_TOKEN_DECIMALS\n        // - div INCENTIVE_ACCUMULATION_PRECISION\n        // => REWARD_TOKEN_DECIMALS\n        return uint256(nTokenBalanceAtLastClaim)\n            .mul(rewardsPerNToken)\n            .div(uint256(Constants.INTERNAL_TOKEN_PRECISION))\n            .sub(rewardDebtPerAccount[account])\n            .mul(10 ** REWARD_TOKEN_DECIMALS)\n            .div(Constants.INCENTIVE_ACCUMULATION_PRECISION);\n    }\n\n    /// @notice Verify merkle proof, or revert if not in tree\n    function _checkProof(address account, uint256 balance, bytes32[] calldata proof) private view {\n        // Verify merkle proof, or revert if not in tree\n        bytes32 leaf = keccak256(abi.encodePacked(account, balance));\n        bool isValidLeaf = MerkleProof.verify(proof, merkleRoot, leaf);\n        require(isValidLeaf, \"NotInMerkle\");\n    }\n}"
    }
  ]
}