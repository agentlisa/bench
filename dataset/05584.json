{
  "Title": "[L-03] Missing cardinality check in function read()",
  "Content": "\nThere is 1 instance of this issue:\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/oracles/CamelotRelayer.sol#L91C1-L101C4\n\nOn Line 93, the comment mentions that the read() function should revert with \"OLD!\" if the pool does not have enough cardinality or initialized history. But there is no check done for the cardinality, which can return an incorrect quote.\n```solidity\nFile: CamelotRelayer.sol\n092:   function read() external view returns (uint256 _result) {\n093:     // This call may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n094:     (int24 _arithmeticMeanTick,) = OracleLibrary.consult(camelotPair, quotePeriod);\n095:     uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n096:       tick: _arithmeticMeanTick,\n097:       baseAmount: baseAmount,\n098:       baseToken: baseToken,\n099:       quoteToken: quoteToken\n100:     });\n101:     _result = _parseResult(_quoteAmount);\n102:   }\n```\nSolution:\n```solidity\nFile: CamelotRelayer.sol\n69:   function read() external view returns (uint256 _result) {\n70:     // If the pool doesn't have enough history return false\n71:     if (OracleLibrary.getOldestObservationSecondsAgo(camelotPair) < quotePeriod) {\n72:       return (0, false);\n73:     }\n74:     // Consult the query with a TWAP period of quotePeriod\n75:     (int24 _arithmeticMeanTick,) = OracleLibrary.consult(camelotPair, quotePeriod);\n76:     // Calculate the quote amount\n77:     uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n78:       tick: _arithmeticMeanTick,\n79:       baseAmount: baseAmount,\n80:       baseToken: baseToken,\n81:       quoteToken: quoteToken\n82:     });\n83:     // Process the quote result to 18 decimal quote\n84:     _result = _parseResult(_quoteAmount);\n85:   }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/oracles/CamelotRelayer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {IBaseOracle} from '@interfaces/oracles/IBaseOracle.sol';\nimport {ICamelotRelayer} from '@interfaces/oracles/ICamelotRelayer.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\n// import {ICamelotFactory} from '@camelot/interfaces/ICamelotFactory.sol';\nimport {IAlgebraFactory} from '@interfaces/factories/IAlgebraFactory.sol';\nimport {ICamelotPair} from '@camelot/interfaces/ICamelotPair.sol';\nimport {OracleLibrary} from '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport {CAMELOT_V3_FACTORY, GOERLI_CAMELOT_V3_FACTORY} from '@script/Registry.s.sol';\n\n/**\n * @title  CamelotRelayer\n * @notice This contracts consults a CamelotRelayer TWAP and transforms the result into a standard IBaseOracle feed\n * @dev    The quote obtained from the pool query is transformed into an 18 decimals format\n */\ncontract CamelotRelayer is IBaseOracle, ICamelotRelayer {\n  // --- Registry ---\n  address internal constant _CAMELOT_FACTORY = GOERLI_CAMELOT_V3_FACTORY;\n\n  /// @inheritdoc ICamelotRelayer\n  address public camelotPair;\n  /// @inheritdoc ICamelotRelayer\n  address public baseToken;\n  /// @inheritdoc ICamelotRelayer\n  address public quoteToken;\n\n  // --- Data ---\n  /// @inheritdoc IBaseOracle\n  string public symbol;\n\n  /// @inheritdoc ICamelotRelayer\n  uint128 public baseAmount;\n  /// @inheritdoc ICamelotRelayer\n  uint256 public multiplier;\n  /// @inheritdoc ICamelotRelayer\n  uint32 public quotePeriod;\n\n  constructor(address _baseToken, address _quoteToken, uint32 _quotePeriod) {\n    // camelotPair = ICamelotFactory(_CAMELOT_FACTORY).getPair(_baseToken, _quoteToken);\n    camelotPair = IAlgebraFactory(_CAMELOT_FACTORY).poolByPair(_baseToken, _quoteToken);\n    if (camelotPair == address(0)) revert CamelotRelayer_InvalidPool();\n\n    address _token0 = ICamelotPair(camelotPair).token0();\n    address _token1 = ICamelotPair(camelotPair).token1();\n\n    // The factory validates that both token0 and token1 are desired baseToken and quoteTokens\n    if (_token0 == _baseToken) {\n      baseToken = _token0;\n      quoteToken = _token1;\n    } else {\n      baseToken = _token1;\n      quoteToken = _token0;\n    }\n\n    baseAmount = uint128(10 ** IERC20Metadata(_baseToken).decimals());\n    multiplier = 18 - IERC20Metadata(_quoteToken).decimals();\n    quotePeriod = _quotePeriod;\n\n    symbol = string(abi.encodePacked(IERC20Metadata(_baseToken).symbol(), ' / ', IERC20Metadata(_quoteToken).symbol()));\n  }\n\n  /**\n   * @dev    Method will return invalid if the pool doesn't have enough history\n   * @inheritdoc IBaseOracle\n   */\n  function getResultWithValidity() external view returns (uint256 _result, bool _validity) {\n    // If the pool doesn't have enough history return false\n    if (OracleLibrary.getOldestObservationSecondsAgo(camelotPair) < quotePeriod) {\n      return (0, false);\n    }\n    // Consult the query with a TWAP period of quotePeriod\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(camelotPair, quotePeriod);\n    // Calculate the quote amount\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    // Process the quote result to 18 decimal quote\n    _result = _parseResult(_quoteAmount);\n    _validity = true;\n  }\n\n  /**\n   * @dev    This method may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n   * @inheritdoc IBaseOracle\n   */\n  function read() external view returns (uint256 _result) {\n    // This call may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(camelotPair, quotePeriod);\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    _result = _parseResult(_quoteAmount);\n  }\n\n  function _parseResult(uint256 _quoteResult) internal view returns (uint256 _result) {\n    return _quoteResult * 10 ** multiplier;\n  }\n}"
    }
  ]
}