{
  "Title": "M-11: last repayments are calculated incorrectly for \"irregular\" loan durations",
  "Content": "# Issue M-11: last repayments are calculated incorrectly for \"irregular\" loan durations \n\nSource: https://github.com/sherlock-audit/2023-03-teller-judging/issues/328 \n\n## Found by \nimmeas\n## Summary\nWhen taking a loan, a borrower expects that at the end of each payment cycle they should pay `paymentCycleAmount`. This is not true for loans that are not a multiple of `paymentCycle`.\n\n## Vulnerability Detail\nImagine a loan of `1000` that is taken for 2.5 payment cycles (skip interest to keep calculations simple).\n\nA borrower would expect to pay `400` + `400` + `200`\n\nThis holds true for the first installment.\n\nBut lets look at what happens at the second installment, here's the calculation of what is to pay in `V2Calculations.sol`:\n\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol#L93-L101\n```solidity\nFile: libraries/V2Calculations.sol\n\n 93:        // Cast to int265 to avoid underflow errors (negative means loan duration has passed)\n 94:        int256 durationLeftOnLoan = int256(\n 95:            uint256(_bid.loanDetails.loanDuration)\n 96:        ) -\n 97:            (int256(_timestamp) -\n 98:                int256(uint256(_bid.loanDetails.acceptedTimestamp)));\n 99:        bool isLastPaymentCycle = durationLeftOnLoan <\n100:            int256(uint256(_bid.terms.paymentCycle)) || // Check if current payment cycle is within or beyond the last one\n101:            owedPrincipal_ + interest_ <= _bid.terms.paymentCycleAmount; // Check if what is left to pay is less than the payment cycle amount\n```\n\nSimplified the first calculation says `timeleft = loanDuration - (now - acceptedTimestamp)` and then if `timeleft < paymentCycle` we are within the last payment cycle.\n\nThis isn't true for loan durations that aren't multiples of the payment cycles. This code says the last payment cycle is when you are one payment cycle from the end of the loan. Which is not the same as last payment cycle as my example above shows.\n\nPoC:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { UpgradeableBeacon } from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport { AddressUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport { TellerV2 } from \"../contracts/TellerV2.sol\";\nimport { Payment } from \"../contracts/TellerV2Storage.sol\";\nimport { CollateralManager } from \"../contracts/CollateralManager.sol\";\nimport { LenderCommitmentForwarder } from \"../contracts/LenderCommitmentForwarder.sol\";\nimport { CollateralEscrowV1 } from \"../contracts/escrow/CollateralEscrowV1.sol\";\nimport { Collateral, CollateralType } from \"../contracts/interfaces/escrow/ICollateralEscrowV1.sol\";\n\nimport { ReputationManagerMock } from \"../contracts/mock/ReputationManagerMock.sol\";\nimport { LenderManagerMock } from \"../contracts/mock/LenderManagerMock.sol\";\nimport { MarketRegistryMock } from \"../contracts/mock/MarketRegistryMock.sol\";\n\nimport {TestERC20Token} from \"./tokens/TestERC20Token.sol\";\n\nimport \"lib/forge-std/src/Test.sol\";\n\ncontract LoansTest is Test {\n    using AddressUpgradeable for address;\n\n    MarketRegistryMock marketRegistry;\n\n    TellerV2 tellerV2;\n    LenderCommitmentForwarder lenderCommitmentForwarder;\n    CollateralManager collateralManager;\n    \n    TestERC20Token principalToken;\n\n    address alice = address(0x1111);\n\n    uint256 marketId = 0;\n\n    function setUp() public {\n        tellerV2 = new TellerV2(address(0));\n\n        marketRegistry = new MarketRegistryMock();\n\n        lenderCommitmentForwarder = new LenderCommitmentForwarder(address(tellerV2),address(marketRegistry));\n        \n        collateralManager = new CollateralManager();\n        collateralManager.initialize(address(new UpgradeableBeacon(address(new CollateralEscrowV1()))), address(tellerV2));\n\n        address rm = address(new ReputationManagerMock());\n        address lm = address(new LenderManagerMock());\n        tellerV2.initialize(0, address(marketRegistry), rm, address(lenderCommitmentForwarder), address(collateralManager), lm);\n\n        marketRegistry.setMarketOwner(address(this));\n        marketRegistry.setMarketFeeRecipient(address(this));\n\n        tellerV2.setTrustedMarketForwarder(marketId,address(lenderCommitmentForwarder));\n\n        principalToken = new TestERC20Token(\"Principal Token\", \"PRIN\", 12e18, 18);\n    }\n\n\n    function testLoanInstallmentsCalculatedIncorrectly() public {\n        // payment cycle is 1000 in market registry\n        \n        uint256 amount = 1000;\n        principalToken.transfer(alice,amount);\n     \n        vm.startPrank(alice);\n        principalToken.approve(address(tellerV2),2*amount);\n        uint256 bidId = tellerV2.submitBid(\n            address(principalToken),\n            marketId,\n            amount,\n            2500, // 2.5 payment cycles\n            0, // 0 interest to make calculations easier\n            \"\",\n            alice\n        );\n        tellerV2.lenderAcceptBid(bidId);\n        vm.stopPrank();\n\n        // jump to first payment cycle end\n        vm.warp(block.timestamp + 1000);\n        Payment memory p = tellerV2.calculateAmountDue(bidId);\n        assertEq(400,p.principal);\n\n        // borrower pays on time\n        vm.prank(alice);\n        tellerV2.repayLoanMinimum(bidId);\n\n        // jump to second payment cycle\n        vm.warp(block.timestamp + 1000);\n        p = tellerV2.calculateAmountDue(bidId);\n\n        // should be 400 but is full loan\n        assertEq(600,p.principal);\n    }\n}\n```\n\nThe details of this finding are out of scope but since it makes `TellerV2`, in scope, behave unexpectedly I believe this finding to be in scope.\n\n## Impact\nA borrower taking a loan might not be able to pay the last payment cycle and be liquidated. At the worst possible time since they've paid the whole loan on schedule up to the last installment. The liquidator just need to pay the last installment to take the whole collateral.\n\nThis requires the loan to not be a multiple of the payment cycle which might sound odd. But since a year is 365 days and a common payment cycle is 30 days I imagine there can be quite a lot of loans that after 360 days will end up in this issue.\n\nThere is also nothing stopping an unknowing borrower from placing a bid or accepting a commitment with an odd duration.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol#L94-L101\n\n## Tool used\nManual Review\n\n## Recommendation\nFirst I thought that you could remove the `lastPaymentCycle` calculation all together. I tried that and then also tested what happened with \"irregular\" loans with interest.\n\nThen I found this in the EMI calculation:\n\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/libraries/NumbersLib.sol#L123\n```solidity\nFile: libraries/NumbersLib.sol\n\n132:        uint256 n = Math.ceilDiv(loanDuration, cycleDuration);\n```\n\nEMI, which is designed for mortgages, assumes the payments is a discrete number of the same amortization essentially. I.e they don't allow \"partial\" periods at the end, because that doesn't make sense for a mortgage.\n\nIn Teller this is allowed which causes some issues with the EMI calculation since the above row will always round up to a full number of payment periods. If you also count interest, which triggers the EMI calculation: The lender, in an \"irregular\" loan duration, would get less per installment up to the last one which would be bigger. The funds would all be paid with the correct interest in the end just not in the expected amounts.\n\n### My recommendation now is:\neither\n\n- **don't allow loan durations that aren't a multiple of the period**, at least warn about it UI-wise, no one will lose any money but the installments might be split in unexpected amounts.\n- **Do away with EMI all together** as DeFi loans aren't the same as mortgages. The defaulting/liquidation logic only cares about time since last payment.\n- **Do more math** to make EMI work with irregular loan durations. This nerd sniped me:\n\n### More math:\nFrom the link in the comment, https://en.wikipedia.org/wiki/Equated_monthly_installment you can follow one of the links in that wiki page to a derivation of the formula: http://rmathew.com/2006/calculating-emis.html\n\nIn the middle we have an equation which describes the owed amount at a time $P_n$:\n\n$$P_n=Pt^n-E\\frac{(t^n-1)}{t-n}$$\nwhere $t=1+r$ and $r$ is the monthly interest rate ($apy*C/year$).\n\nNow, from here, we want to calculate the loan at a time $P_{n + \\Delta}$:\n\n$$P_{n + \\Delta}=Pt^nt_\\Delta-E\\frac{t^n-1}{t-1}t_\\Delta-kE$$\n\nWhere $k$ is $c/C$ i.e. the ratio of partial cycle compared to a full cycle.\n\nSame with $t_\\Delta$ which is $1+r_\\Delta$, ($r_\\Delta$ is also equal to $kr$, ratio of partial cycle rate to full cycle rate, which we'll use later).\n\nReorganize to get $E$ from above:\n\n$$\nE = P r \\frac{t^nt_\\Delta}{t_\\Delta \\frac{t^n-1}{t-1} + k}\n$$\n\nNow substitute in $1+r$ in place of $t$ and $1+r_\\Delta$ instead of $t_\\Delta$ and multiply both numerator and denominator with $r$:\n\n$$\nE = P \\frac{r (1+r)^n(1+r_\\Delta)}{(1+r_\\Delta)((1+r)^n - 1) + kr}\n$$\n\nand $kr = r_\\Delta$ gives us:\n\n$$\nE = P r (1+r)^n \\frac{(1+r_\\Delta)}{(1+r_\\Delta)((1+r)^n - 1) + r_\\Delta}\n$$\n\nTo check that this is correct, $r_\\Delta = 0$ (no extra cycle added) should give us the regular EMI equation. Which we can see is true for the above. And $r_\\Delta = r$ (a full extra cycle added) should give us the EMI equation but with $n+1$ which we can also see it does.\n\nHere are the code changes to use this, together with changes to `V2Calculations.sol` to calculate the last period correctly:\n```diff\ndiff --git a/teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol b/teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol\nindex 1cce8da..1ad5bcf 100644\n--- a/teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol\n+++ b/teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol\n@@ -90,30 +90,15 @@ library V2Calculations {\n         uint256 owedTime = _timestamp - uint256(_lastRepaidTimestamp);\n         interest_ = (interestOwedInAYear * owedTime) / daysInYear;\n \n-        // Cast to int265 to avoid underflow errors (negative means loan duration has passed)\n-        int256 durationLeftOnLoan = int256(\n-            uint256(_bid.loanDetails.loanDuration)\n-        ) -\n-            (int256(_timestamp) -\n-                int256(uint256(_bid.loanDetails.acceptedTimestamp)));\n-        bool isLastPaymentCycle = durationLeftOnLoan <\n-            int256(uint256(_bid.terms.paymentCycle)) || // Check if current payment cycle is within or beyond the last one\n-            owedPrincipal_ + interest_ <= _bid.terms.paymentCycleAmount; // Check if what is left to pay is less than the payment cycle amount\n-\n         if (_bid.paymentType == PaymentType.Bullet) {\n-            if (isLastPaymentCycle) {\n-                duePrincipal_ = owedPrincipal_;\n-            }\n+            duePrincipal_ = owedPrincipal_;\n         } else {\n             // Default to PaymentType.EMI\n             // Max payable amount in a cycle\n             // NOTE: the last cycle could have less than the calculated payment amount\n-            uint256 maxCycleOwed = isLastPaymentCycle\n-                ? owedPrincipal_ + interest_\n-                : _bid.terms.paymentCycleAmount;\n \n             // Calculate accrued amount due since last repayment\n-            uint256 owedAmount = (maxCycleOwed * owedTime) /\n+            uint256 owedAmount = (_bid.terms.paymentCycleAmount * owedTime) /\n                 _bid.terms.paymentCycle;\n             duePrincipal_ = Math.min(owedAmount - interest_, owedPrincipal_);\n         }\n\n```\n\nAnd then `NumbersLib.sol`:\n```diff\ndiff --git a/teller-protocol-v2/packages/contracts/contracts/libraries/NumbersLib.sol b/teller-protocol-v2/packages/contracts/contracts/libraries/NumbersLib.sol\nindex f34dd9c..8ca48bc 100644\n--- a/teller-protocol-v2/packages/contracts/contracts/libraries/NumbersLib.sol\n+++ b/teller-protocol-v2/packages/contracts/contracts/libraries/NumbersLib.sol\n@@ -120,7 +120,8 @@ library NumbersLib {\n                 );\n \n         // Number of payment cycles for the duration of the loan\n-        uint256 n = Math.ceilDiv(loanDuration, cycleDuration);\n+        uint256 n = loanDuration/ cycleDuration;\n+        uint256 rest = loanDuration%cycleDuration;\n \n         uint256 one = WadRayMath.wad();\n         uint256 r = WadRayMath.pctToWad(apr).wadMul(cycleDuration).wadDiv(\n@@ -128,8 +129,16 @@ library NumbersLib {\n         );\n         uint256 exp = (one + r).wadPow(n);\n         uint256 numerator = principal.wadMul(r).wadMul(exp);\n-        uint256 denominator = exp - one;\n \n-        return numerator.wadDiv(denominator);\n+        if(rest==0) {\n+            // duration is multiple of cycle\n+            uint256 denominator = exp - one;\n+            return numerator.wadDiv(denominator);\n+        }\n+        // duration is an uneven cycle\n+        uint256 rDelta = WadRayMath.pctToWad(apr).wadMul(rest).wadDiv(daysInYear);\n+        uint256 n1 = numerator.wadMul(one + rDelta);\n+        uint256 denom = ((one + rDelta).wadMul(exp - one)) + rDelta;\n+        return n1.wadDiv(denom);\n     }\n }\n```\n\n\n\n## Discussion\n\n**ethereumdegen**\n\nIt seems that in that example of a loan with 3 cycles, 400 then 400 and then 200,  if the borrower is more than halfway through the second installment (second 400) , they would be considered to be in the 'lastPaymentCycle' incorrectly and would 'owe' 600  instead of 400.   We will investigate this more for a fix. \n\n**cducrest**\n\nEscalate for 10 USDC\n\nIssue is from out of scope contract. Both vulnerability and fix are in out-of-scope contract. Awarding issues for contracts not in scope incentivize poor scoping from protocol in the future and lead to more work for auditors with less pay (protocols pay for smaller scope and receive audits for bigger scopes).\n\nMultiple incorrect behaviours could be spotted in `MarketRegistry` or `ReputationManager` as well but were not reported because they are out of scope.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Issue is from out of scope contract. Both vulnerability and fix are in out-of-scope contract. Awarding issues for contracts not in scope incentivize poor scoping from protocol in the future and lead to more work for auditors with less pay (protocols pay for smaller scope and receive audits for bigger scopes).\n> \n> Multiple incorrect behaviours could be spotted in `MarketRegistry` or `ReputationManager` as well but were not reported because they are out of scope.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ethereumdegen**\n\nGithub PR: [Issue 328 - new repayment logic for v2 calculations](https://github.com/teller-protocol/teller-protocol-v2/pull/92)\n\n**hrishibhat**\n\nEscalation rejected\n\nValid medium. \nThe library is used in the in-scope contract and the error impacts an in-scope contract. This is a valid issue. \n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid medium. \n> The library is used in the in-scope contract and the error impacts an in-scope contract. This is a valid issue. \n> \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n**IAm0x52**\n\nFix looks good. Final repayment period is now calculated via modulo which allows it to correctly detect the final payment cycle for loans of irregular duration\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/62",
  "Code": [
    {
      "filename": "teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n\n// SPDX-License-Identifier: MIT\n\n// Libraries\nimport \"./NumbersLib.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { Bid } from \"../TellerV2Storage.sol\";\n\nenum PaymentType {\n    EMI,\n    Bullet\n}\n\nenum PaymentCycleType {\n    Seconds,\n    Monthly\n}\n\nlibrary V2Calculations {\n    using NumbersLib for uint256;\n\n    /**\n     * @notice Returns the timestamp of the last payment made for a loan.\n     * @param _bid The loan bid struct to get the timestamp for.\n     */\n    function lastRepaidTimestamp(Bid storage _bid)\n        internal\n        view\n        returns (uint32)\n    {\n        return\n            _bid.loanDetails.lastRepaidTimestamp == 0\n                ? _bid.loanDetails.acceptedTimestamp\n                : _bid.loanDetails.lastRepaidTimestamp;\n    }\n\n    /**\n     * @notice Calculates the amount owed for a loan.\n     * @param _bid The loan bid struct to get the owed amount for.\n     * @param _timestamp The timestamp at which to get the owed amount at.\n     * @param _paymentCycleType The payment cycle type of the loan (Seconds or Monthly).\n     */\n    function calculateAmountOwed(\n        Bid storage _bid,\n        uint256 _timestamp,\n        PaymentCycleType _paymentCycleType\n    )\n        internal\n        view\n        returns (\n            uint256 owedPrincipal_,\n            uint256 duePrincipal_,\n            uint256 interest_\n        )\n    {\n        // Total principal left to pay\n        return\n            calculateAmountOwed(\n                _bid,\n                lastRepaidTimestamp(_bid),\n                _timestamp,\n                _paymentCycleType\n            );\n    }\n\n    function calculateAmountOwed(\n        Bid storage _bid,\n        uint256 _lastRepaidTimestamp,\n        uint256 _timestamp,\n        PaymentCycleType _paymentCycleType\n    )\n        internal\n        view\n        returns (\n            uint256 owedPrincipal_,\n            uint256 duePrincipal_,\n            uint256 interest_\n        )\n    {\n        owedPrincipal_ =\n            _bid.loanDetails.principal -\n            _bid.loanDetails.totalRepaid.principal;\n\n        uint256 daysInYear = _paymentCycleType == PaymentCycleType.Monthly\n            ? 360 days\n            : 365 days;\n\n        uint256 interestOwedInAYear = owedPrincipal_.percent(_bid.terms.APR);\n        uint256 owedTime = _timestamp - uint256(_lastRepaidTimestamp);\n        interest_ = (interestOwedInAYear * owedTime) / daysInYear;\n\n        // Cast to int265 to avoid underflow errors (negative means loan duration has passed)\n        int256 durationLeftOnLoan = int256(\n            uint256(_bid.loanDetails.loanDuration)\n        ) -\n            (int256(_timestamp) -\n                int256(uint256(_bid.loanDetails.acceptedTimestamp)));\n        bool isLastPaymentCycle = durationLeftOnLoan <\n            int256(uint256(_bid.terms.paymentCycle)) || // Check if current payment cycle is within or beyond the last one\n            owedPrincipal_ + interest_ <= _bid.terms.paymentCycleAmount; // Check if what is left to pay is less than the payment cycle amount\n\n        if (_bid.paymentType == PaymentType.Bullet) {\n            if (isLastPaymentCycle) {\n                duePrincipal_ = owedPrincipal_;\n            }\n        } else {\n            // Default to PaymentType.EMI\n            // Max payable amount in a cycle\n            // NOTE: the last cycle could have less than the calculated payment amount\n            uint256 maxCycleOwed = isLastPaymentCycle\n                ? owedPrincipal_ + interest_\n                : _bid.terms.paymentCycleAmount;\n\n            // Calculate accrued amount due since last repayment\n            uint256 owedAmount = (maxCycleOwed * owedTime) /\n                _bid.terms.paymentCycle;\n            duePrincipal_ = Math.min(owedAmount - interest_, owedPrincipal_);\n        }\n    }\n\n    /**\n     * @notice Calculates the amount owed for a loan for the next payment cycle.\n     * @param _type The payment type of the loan.\n     * @param _cycleType The cycle type set for the loan. (Seconds or Monthly)\n     * @param _principal The starting amount that is owed on the loan.\n     * @param _duration The length of the loan.\n     * @param _paymentCycle The length of the loan's payment cycle.\n     * @param _apr The annual percentage rate of the loan.\n     */\n    function calculatePaymentCycleAmount(\n        PaymentType _type,\n        PaymentCycleType _cycleType,\n        uint256 _principal,\n        uint32 _duration,\n        uint32 _paymentCycle,\n        uint16 _apr\n    ) internal returns (uint256) {\n        uint256 daysInYear = _cycleType == PaymentCycleType.Monthly\n            ? 360 days\n            : 365 days;\n        if (_type == PaymentType.Bullet) {\n            return\n                _principal.percent(_apr).percent(\n                    uint256(_paymentCycle).ratioOf(daysInYear, 10),\n                    10\n                );\n        }\n        // Default to PaymentType.EMI\n        return\n            NumbersLib.pmt(\n                _principal,\n                _duration,\n                _paymentCycle,\n                _apr,\n                daysInYear\n            );\n    }\n}"
    },
    {
      "filename": "teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n\n// SPDX-License-Identifier: MIT\n\n// Libraries\nimport \"./NumbersLib.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { Bid } from \"../TellerV2Storage.sol\";\n\nenum PaymentType {\n    EMI,\n    Bullet\n}\n\nenum PaymentCycleType {\n    Seconds,\n    Monthly\n}\n\nlibrary V2Calculations {\n    using NumbersLib for uint256;\n\n    /**\n     * @notice Returns the timestamp of the last payment made for a loan.\n     * @param _bid The loan bid struct to get the timestamp for.\n     */\n    function lastRepaidTimestamp(Bid storage _bid)\n        internal\n        view\n        returns (uint32)\n    {\n        return\n            _bid.loanDetails.lastRepaidTimestamp == 0\n                ? _bid.loanDetails.acceptedTimestamp\n                : _bid.loanDetails.lastRepaidTimestamp;\n    }\n\n    /**\n     * @notice Calculates the amount owed for a loan.\n     * @param _bid The loan bid struct to get the owed amount for.\n     * @param _timestamp The timestamp at which to get the owed amount at.\n     * @param _paymentCycleType The payment cycle type of the loan (Seconds or Monthly).\n     */\n    function calculateAmountOwed(\n        Bid storage _bid,\n        uint256 _timestamp,\n        PaymentCycleType _paymentCycleType\n    )\n        internal\n        view\n        returns (\n            uint256 owedPrincipal_,\n            uint256 duePrincipal_,\n            uint256 interest_\n        )\n    {\n        // Total principal left to pay\n        return\n            calculateAmountOwed(\n                _bid,\n                lastRepaidTimestamp(_bid),\n                _timestamp,\n                _paymentCycleType\n            );\n    }\n\n    function calculateAmountOwed(\n        Bid storage _bid,\n        uint256 _lastRepaidTimestamp,\n        uint256 _timestamp,\n        PaymentCycleType _paymentCycleType\n    )\n        internal\n        view\n        returns (\n            uint256 owedPrincipal_,\n            uint256 duePrincipal_,\n            uint256 interest_\n        )\n    {\n        owedPrincipal_ =\n            _bid.loanDetails.principal -\n            _bid.loanDetails.totalRepaid.principal;\n\n        uint256 daysInYear = _paymentCycleType == PaymentCycleType.Monthly\n            ? 360 days\n            : 365 days;\n\n        uint256 interestOwedInAYear = owedPrincipal_.percent(_bid.terms.APR);\n        uint256 owedTime = _timestamp - uint256(_lastRepaidTimestamp);\n        interest_ = (interestOwedInAYear * owedTime) / daysInYear;\n\n        // Cast to int265 to avoid underflow errors (negative means loan duration has passed)\n        int256 durationLeftOnLoan = int256(\n            uint256(_bid.loanDetails.loanDuration)\n        ) -\n            (int256(_timestamp) -\n                int256(uint256(_bid.loanDetails.acceptedTimestamp)));\n        bool isLastPaymentCycle = durationLeftOnLoan <\n            int256(uint256(_bid.terms.paymentCycle)) || // Check if current payment cycle is within or beyond the last one\n            owedPrincipal_ + interest_ <= _bid.terms.paymentCycleAmount; // Check if what is left to pay is less than the payment cycle amount\n\n        if (_bid.paymentType == PaymentType.Bullet) {\n            if (isLastPaymentCycle) {\n                duePrincipal_ = owedPrincipal_;\n            }\n        } else {\n            // Default to PaymentType.EMI\n            // Max payable amount in a cycle\n            // NOTE: the last cycle could have less than the calculated payment amount\n            uint256 maxCycleOwed = isLastPaymentCycle\n                ? owedPrincipal_ + interest_\n                : _bid.terms.paymentCycleAmount;\n\n            // Calculate accrued amount due since last repayment\n            uint256 owedAmount = (maxCycleOwed * owedTime) /\n                _bid.terms.paymentCycle;\n            duePrincipal_ = Math.min(owedAmount - interest_, owedPrincipal_);\n        }\n    }\n\n    /**\n     * @notice Calculates the amount owed for a loan for the next payment cycle.\n     * @param _type The payment type of the loan.\n     * @param _cycleType The cycle type set for the loan. (Seconds or Monthly)\n     * @param _principal The starting amount that is owed on the loan.\n     * @param _duration The length of the loan.\n     * @param _paymentCycle The length of the loan's payment cycle.\n     * @param _apr The annual percentage rate of the loan.\n     */\n    function calculatePaymentCycleAmount(\n        PaymentType _type,\n        PaymentCycleType _cycleType,\n        uint256 _principal,\n        uint32 _duration,\n        uint32 _paymentCycle,\n        uint16 _apr\n    ) internal returns (uint256) {\n        uint256 daysInYear = _cycleType == PaymentCycleType.Monthly\n            ? 360 days\n            : 365 days;\n        if (_type == PaymentType.Bullet) {\n            return\n                _principal.percent(_apr).percent(\n                    uint256(_paymentCycle).ratioOf(daysInYear, 10),\n                    10\n                );\n        }\n        // Default to PaymentType.EMI\n        return\n            NumbersLib.pmt(\n                _principal,\n                _duration,\n                _paymentCycle,\n                _apr,\n                daysInYear\n            );\n    }\n}"
    },
    {
      "filename": "teller-protocol-v2/packages/contracts/contracts/libraries/NumbersLib.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Libraries\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./WadRayMath.sol\";\n\n/**\n * @dev Utility library for uint256 numbers\n *\n * @author develop@teller.finance\n */\nlibrary NumbersLib {\n    using WadRayMath for uint256;\n\n    /**\n     * @dev It represents 100% with 2 decimal places.\n     */\n    uint16 internal constant PCT_100 = 10000;\n\n    function percentFactor(uint256 decimals) internal pure returns (uint256) {\n        return 100 * (10**decimals);\n    }\n\n    /**\n     * @notice Returns a percentage value of a number.\n     * @param self The number to get a percentage of.\n     * @param percentage The percentage value to calculate with 2 decimal places (10000 = 100%).\n     */\n    function percent(uint256 self, uint16 percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        return percent(self, percentage, 2);\n    }\n\n    /**\n     * @notice Returns a percentage value of a number.\n     * @param self The number to get a percentage of.\n     * @param percentage The percentage value to calculate with.\n     * @param decimals The number of decimals the percentage value is in.\n     */\n    function percent(uint256 self, uint256 percentage, uint256 decimals)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (self * percentage) / percentFactor(decimals);\n    }\n\n    /**\n     * @notice it returns the absolute number of a specified parameter\n     * @param self the number to be returned in it's absolute\n     * @return the absolute number\n     */\n    function abs(int256 self) internal pure returns (uint256) {\n        return self >= 0 ? uint256(self) : uint256(-1 * self);\n    }\n\n    /**\n     * @notice Returns a ratio percentage of {num1} to {num2}.\n     * @dev Returned value is type uint16.\n     * @param num1 The number used to get the ratio for.\n     * @param num2 The number used to get the ratio from.\n     * @return Ratio percentage with 2 decimal places (10000 = 100%).\n     */\n    function ratioOf(uint256 num1, uint256 num2)\n        internal\n        pure\n        returns (uint16)\n    {\n        return SafeCast.toUint16(ratioOf(num1, num2, 2));\n    }\n\n    /**\n     * @notice Returns a ratio percentage of {num1} to {num2}.\n     * @param num1 The number used to get the ratio for.\n     * @param num2 The number used to get the ratio from.\n     * @param decimals The number of decimals the percentage value is returned in.\n     * @return Ratio percentage value.\n     */\n    function ratioOf(uint256 num1, uint256 num2, uint256 decimals)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (num2 == 0) return 0;\n        return (num1 * percentFactor(decimals)) / num2;\n    }\n\n    /**\n     * @notice Calculates the payment amount for a cycle duration.\n     *  The formula is calculated based on the standard Estimated Monthly Installment (https://en.wikipedia.org/wiki/Equated_monthly_installment)\n     *  EMI = [P x R x (1+R)^N]/[(1+R)^N-1]\n     * @param principal The starting amount that is owed on the loan.\n     * @param loanDuration The length of the loan.\n     * @param cycleDuration The length of the loan's payment cycle.\n     * @param apr The annual percentage rate of the loan.\n     */\n    function pmt(\n        uint256 principal,\n        uint32 loanDuration,\n        uint32 cycleDuration,\n        uint16 apr,\n        uint256 daysInYear\n    ) internal pure returns (uint256) {\n        require(\n            loanDuration >= cycleDuration,\n            \"PMT: cycle duration < loan duration\"\n        );\n        if (apr == 0)\n            return\n                Math.mulDiv(\n                    principal,\n                    cycleDuration,\n                    loanDuration,\n                    Math.Rounding.Up\n                );\n\n        // Number of payment cycles for the duration of the loan\n        uint256 n = Math.ceilDiv(loanDuration, cycleDuration);\n\n        uint256 one = WadRayMath.wad();\n        uint256 r = WadRayMath.pctToWad(apr).wadMul(cycleDuration).wadDiv(\n            daysInYear\n        );\n        uint256 exp = (one + r).wadPow(n);\n        uint256 numerator = principal.wadMul(r).wadMul(exp);\n        uint256 denominator = exp - one;\n\n        return numerator.wadDiv(denominator);\n    }\n}"
    }
  ]
}