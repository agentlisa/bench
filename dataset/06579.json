{
  "Title": "[L-06] Use Ownable2Step instead of Ownable for access control",
  "Content": "\n- https://github.com/code-423n4/2023-05-xeth/blob/main/src/wxETH.sol#L9\n- https://github.com/code-423n4/2023-05-xeth/blob/main/src/CVXStaker.sol#L11\n\nUse the [Ownable2Step](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol) variant of the Ownable contract to better safeguard against accidental transfers of access control.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-xeth",
  "Code": [
    {
      "filename": "src/wxETH.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"@openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin-contracts/access/Ownable.sol\";\nimport \"solmate/utils/FixedPointMathLib.sol\";\n\ncontract WrappedXETH is ERC20, Ownable {\n    using SafeERC20 for IERC20;\n\n    /* --------------------------------- Events --------------------------------- */\n    /// @dev emitted when the dripRatePerBlock is updated\n    event UpdateDripRate(uint oldDripRatePerBlock, uint256 newDripRatePerBlock);\n    /// @dev emitted when a sucessful accrueDrip is called\n    event Drip(uint256 amountDripped, uint256 lockedFunds, uint256 totalFunds);\n    /// @dev emitted when a user stakes xETH to receieve wxETH\n    event Stake(\n        address indexed user,\n        uint256 xETHAmount,\n        uint256 wxETHReceived\n    );\n    /// @dev emitted when a user unstakes wxETH to receieve xETH\n    event Unstake(\n        address indexed user,\n        uint256 wxETHAmount,\n        uint256 xETHReceived\n    );\n\n    /// @dev emitted when the dripping mechanism is started\n    event DripStarted();\n    /// @dev emitted when the dripping mechanism is stopped\n    event DripStopped();\n\n    /// @dev emitted when locked funds are added to the contract by the owner\n    event LockedFundsAdded(uint256 amountAdded, uint256 totalLockedFunds);\n\n    /* --------------------------------- Errors --------------------------------- */\n    error AddressZeroProvided();\n    error AmountZeroProvided();\n    error DripAlreadyRunning();\n    error DripAlreadyStopped();\n\n    /* -------------------------- Constants and Storage ------------------------- */\n\n    /// @dev initial exchange rate of wxETH to xETH. Set to 1:1\n    uint256 public constant INITIAL_EXCHANGE_RATE = 1E18; // exchange rate at begining is 1:1\n\n    /// @dev Base unit of the xETH token\n    uint256 public constant BASE_UNIT = 1E18;\n\n    /// @dev Immutable ERC20 reference to the xETH token\n    IERC20 public immutable xETH;\n\n    /// @dev amount of xETH that are locked in the contract\n    uint256 public lockedFunds;\n    /// @dev amount of xETH that will be dripped per block\n    uint256 public dripRatePerBlock;\n    /// @dev block number of the last drip\n    uint256 public lastReport;\n    /// @dev is dripping enabled in the contract?\n    bool public dripEnabled;\n\n    /* ------------------------------- Constructor ------------------------------ */\n    constructor(address xETHAddress) ERC20(\"Wrapped xETH\", \"wxETH\") {\n        /// @dev if the xETH address is address(0), revert\n        if (xETHAddress == address(0)) revert AddressZeroProvided();\n\n        /// @dev set the xETH reference\n        xETH = IERC20(xETHAddress);\n\n        /// @dev set the drip lastReport to current block\n        lastReport = block.number;\n    }\n\n    /* --------------------------- External functions --------------------------- */\n\n    /// @dev Preview the amount of wxETH that would be minted for a given xETH amount.\n    /// @param xETHAmount The amount of xETH input.\n    /// @return The amount of wxETH that would be minted.\n    /// @notice Reverts if xETHAmount is 0.\n    function previewStake(uint256 xETHAmount) public view returns (uint256) {\n        /// @dev if xETHAmount is 0, revert.\n        if (xETHAmount == 0) revert AmountZeroProvided();\n\n        /// @dev calculate the amount of wxETH to mint before transfer\n        return (xETHAmount * BASE_UNIT) / exchangeRate();\n    }\n\n    /// @dev stake allows for staking xETH in exchange for wxETH\n    /// @notice this function can only be called by a user that has approved to spend xETH\n    /// @notice this function can only be called if the xETHAmount provided is not 0\n    /// @param xETHAmount amount of xETH to be staked\n    function stake(uint256 xETHAmount) external drip returns (uint256) {\n        /// @dev calculate the amount of wxETH to mint\n        uint256 mintAmount = previewStake(xETHAmount);\n\n        /// @dev transfer xETH from the user to the contract\n        xETH.safeTransferFrom(msg.sender, address(this), xETHAmount);\n\n        /// @dev emit event\n        emit Stake(msg.sender, xETHAmount, mintAmount);\n\n        /// @dev mint the wxETH to the user\n        _mint(msg.sender, mintAmount);\n\n        return mintAmount;\n    }\n\n    /// @dev Preview the amount of xETH that would be returned for a given wxETH amount.\n    /// @param wxETHAmount The amount of wxETH input.\n    /// @return The amount of xETH that would be returned.\n    /// @notice Reverts if wxETHAmount is 0.\n    function previewUnstake(uint256 wxETHAmount) public view returns (uint256) {\n        /// @dev if wxETHAmount is 0, revert.\n        if (wxETHAmount == 0) revert AmountZeroProvided();\n\n        /// @dev calculate the amount of xETH to return\n        return (wxETHAmount * exchangeRate()) / BASE_UNIT;\n    }\n\n    /// @dev unstake allows for unstaking wxETH in exchange for xETH\n    /// @notice this function can only be called if the wxETHAmount provided is not 0\n    /// @param wxETHAmount amount of wxETH to be unstaked\n    function unstake(uint256 wxETHAmount) external drip returns (uint256) {\n        /// @dev calculate the amount of xETH to return\n        uint256 returnAmount = previewUnstake(wxETHAmount);\n\n        /// @dev emit event\n        emit Unstake(msg.sender, wxETHAmount, returnAmount);\n\n        /// @dev burn the wxETH from the user\n        _burn(msg.sender, wxETHAmount);\n\n        /// @dev return the xETH back to user\n        xETH.safeTransfer(msg.sender, returnAmount);\n\n        /// @dev return the amount of xETH sent to user\n        return returnAmount;\n    }\n\n    /// @dev addLockedFunds allows for adding locked funds to the contract\n    /// @notice this function can only be called by the owner\n    /// @notice this function can only be called if the amount provided \n    /// @dev if amount is 0, revert.\n    function addLockedFunds(uint256 amount) external onlyOwner drip {\n        /// @dev if amount or _dripRatePerBlock is 0, revert.\n        if (amount == 0) revert AmountZeroProvided();\n\n        /// @dev transfer xETH from the user to the contract\n        xETH.safeTransferFrom(msg.sender, address(this), amount);\n\n        /// @dev add the amount to the locked funds variable\n        lockedFunds += amount;\n\n        emit LockedFundsAdded(amount, lockedFunds);\n    }\n\n    function setDripRate(uint256 newDripRatePerBlock) external onlyOwner drip {\n        if (newDripRatePerBlock == 0) revert AmountZeroProvided();\n\n        emit UpdateDripRate(dripRatePerBlock, newDripRatePerBlock);\n\n        /// @dev set the drip rate per block\n        dripRatePerBlock = newDripRatePerBlock;\n    }\n\n    /// @dev This function starts (or un-pauses) the drip mechanism\n    /// @notice can be only called by the owner\n    function startDrip() external onlyOwner drip {\n        /// @dev if the drip is already running, revert\n        if (dripEnabled) revert DripAlreadyRunning();\n\n        dripEnabled = true;\n\n        /// @dev set the drip lastReport to current block\n        lastReport = block.number;\n\n        emit DripStarted();\n    }\n\n    /// @dev This function stops (or pauses) the drip mechanism\n    /// @notice can be only called by the owner\n    function stopDrip() external onlyOwner drip {\n        /// @dev if the drip is already stopped, revert\n        if (!dripEnabled) revert DripAlreadyStopped();\n\n        dripEnabled = false;\n\n        /// @dev set the drip lastReport to current block\n        lastReport = block.number;\n\n        emit DripStopped();\n    }\n\n    /// @dev accrueDrip allows for manually triggering a drip\n    // solhint-disable-next-line no-empty-blocks\n    function accrueDrip() external drip {}\n\n    /* ---------------------------- Public functions ---------------------------- */\n    /// @dev exchangeRate returns the current exchange rate of wxETH to xETH\n    function exchangeRate() public view returns (uint256) {\n        /// @dev if there are no tokens minted, return the initial exchange rate\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return INITIAL_EXCHANGE_RATE;\n        }\n\n        /// @dev calculate the cash on hand by removing locked funds from the total xETH balance\n        /// @notice this balanceOf call will include any lockedFunds,\n        /// @notice as the locked funds are also in xETH\n        uint256 cashMinusLocked = xETH.balanceOf(address(this)) - lockedFunds;\n\n        /// @dev return the exchange rate by dividing the cash on hand by the total supply\n        return (cashMinusLocked * BASE_UNIT) / _totalSupply;\n    }\n\n    /* -------------------- Intenral functions and Modifiers -------------------- */\n\n    /// @dev _accrueDrip calculates the amount of xETH to drip and updates\n    /// @dev the lockedFunds and lastReport variables\n    function _accrueDrip() private {\n        /// @dev if drip is disabled, no need to accrue\n        if (!dripEnabled) return;\n\n        /// @dev blockDelta is the difference between now and last accrual\n        uint256 blockDelta = block.number - lastReport;\n\n        if (blockDelta != 0) {\n            /// @dev calculate dripAmount using blockDelta and dripRatePerBlock\n            uint256 dripAmount = blockDelta * dripRatePerBlock;\n\n            /// @dev We can only drip what we have\n            /// @notice if the dripAmount is greater than the lockedFunds\n            /// @notice then we set the dripAmount to the lockedFunds\n            if (dripAmount > lockedFunds) dripAmount = lockedFunds;\n\n            /// @dev unlock the dripAmount from the lockedFunds\n            /// @notice so that it reflects the amount of xETH that is available\n            /// @notice and the exchange rate shows that\n            lockedFunds -= dripAmount;\n\n            /// @dev set the lastReport to the current block\n            lastReport = block.number;\n\n            /// @notice if there are no remaining locked funds\n            /// @notice the drip must be stopped.\n            if (lockedFunds == 0) {\n                dripEnabled = false;\n                emit DripStopped();\n            }\n\n            /// @dev emit succesful drip event with dripAmount, lockedFunds and xETH balance\n            emit Drip(dripAmount, lockedFunds, xETH.balanceOf(address(this)));\n        }\n    }\n\n    /// @dev modifier drip calls accrueDrip before executing the function\n    modifier drip() {\n        _accrueDrip();\n        _;\n    }\n}"
    },
    {
      "filename": "src/CVXStaker.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin-contracts/access/Ownable.sol\";\nimport \"./interfaces/ICurvePool.sol\";\nimport \"./interfaces/ICVXBooster.sol\";\nimport \"./interfaces/IBaseRewardPool.sol\";\n\ncontract CVXStaker is Ownable {\n    using SafeERC20 for IERC20;\n\n    address public operator;\n    // @notice CLP tokens for curve pool\n    IERC20 public immutable clpToken;\n    CvxPoolInfo public cvxPoolInfo;\n    // @notice Cvx booster\n    ICVXBooster public immutable booster;\n\n    address public rewardsRecipient;\n    address[] public rewardTokens;\n\n    struct CvxPoolInfo {\n        address token;\n        address rewards;\n        uint32 pId;\n    }\n\n    struct Position {\n        uint256 staked;\n        uint256 earned;\n    }\n\n    error NotOperator();\n    error NotOperatorOrOwner();\n\n    event SetCvxPoolInfo(uint32 indexed pId, address token, address rewards);\n    event SetOperator(address operator);\n    event RecoveredToken(address token, address to, uint256 amount);\n    event SetRewardsRecipient(address recipient);\n\n    constructor(\n        address _operator,\n        IERC20 _clpToken,\n        ICVXBooster _booster,\n        address[] memory _rewardTokens\n    ) {\n        operator = _operator;\n        clpToken = _clpToken;\n        booster = _booster;\n        rewardTokens = _rewardTokens;\n    }\n\n    /**\n     * @dev Sets the CVX pool information.\n     * @param _pId The pool ID of the CVX pool.\n     * @param _token The address of the CLP token.\n     * @param _rewards The address of the CVX reward pool.\n     * Only the contract owner can call this function.\n     */\n    function setCvxPoolInfo(\n        uint32 _pId,\n        address _token,\n        address _rewards\n    ) external onlyOwner {\n        cvxPoolInfo.pId = _pId;\n        cvxPoolInfo.token = _token;\n        cvxPoolInfo.rewards = _rewards;\n\n        emit SetCvxPoolInfo(_pId, _token, _rewards);\n    }\n\n    /**\n     * @notice Set operator\n     * @param _operator New operator\n     */\n    function setOperator(address _operator) external onlyOwner {\n        operator = _operator;\n\n        emit SetOperator(_operator);\n    }\n\n    /**\n     * @dev Sets the address of the rewards recipient.\n     * @param _recipeint The address of the rewards recipient.\n     * Only the contract owner can call this function.\n     */\n    function setRewardsRecipient(address _recipeint) external onlyOwner {\n        rewardsRecipient = _recipeint;\n\n        emit SetRewardsRecipient(_recipeint);\n    }\n\n    /**\n     * @notice Recover any token from AMO\n     * @param token Token to recover\n     * @param to Recipient address\n     * @param amount Amount to recover\n     */\n    function recoverToken(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeTransfer(to, amount);\n\n        emit RecoveredToken(token, to, amount);\n    }\n\n    /**\n     * @dev Checks whether the CVX pool is currently shutdown.\n     * @return A boolean indicating whether the CVX pool is currently shutdown.\n     */\n    function isCvxShutdown() public view returns (bool) {\n        // It's not necessary to check that the booster itself is shutdown, as that can only\n        // be shutdown once all the pools are shutdown - see Cvx BoosterOwner.shutdownSystem()\n        return booster.poolInfo(cvxPoolInfo.pId).shutdown;\n    }\n\n    /**\n     * @dev Deposits a specified amount of CLP tokens into the booster and stakes them in the reward pool.\n     * @param amount The amount of CLP tokens to deposit and stake.\n     * Only the operator can call this function.\n     */\n    function depositAndStake(uint256 amount) external onlyOperator {\n        // Only deposit if the aura pool is open. Otherwise leave the CLP Token in this contract.\n        if (!isCvxShutdown()) {\n            clpToken.safeIncreaseAllowance(address(booster), amount);\n            booster.deposit(cvxPoolInfo.pId, amount, true);\n        }\n    }\n\n    /**\n     * @dev Withdraws a specified amount of staked tokens from the reward pool and unwraps them to the original tokens.\n     * @param amount The amount of tokens to withdraw and unwrap.\n     * @param claim A boolean indicating whether to claim rewards before withdrawing.\n     * @param to The address to receive the unwrapped tokens.\n     * If set to 0x0, the tokens will remain in the contract.\n     * Only the contract owner or operator can call this function.\n     */\n    function withdrawAndUnwrap(\n        uint256 amount,\n        bool claim,\n        address to\n    ) external onlyOperatorOrOwner {\n        // Optimistically use CLP balance in this contract, and then try and unstake any remaining\n        uint256 clpBalance = clpToken.balanceOf(address(this));\n        uint256 toUnstake = (amount < clpBalance) ? 0 : amount - clpBalance;\n        if (toUnstake > 0) {\n            IBaseRewardPool(cvxPoolInfo.rewards).withdrawAndUnwrap(\n                toUnstake,\n                claim\n            );\n        }\n\n        if (to != address(0)) {\n            // unwrapped amount is 1 to 1\n            clpToken.safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @dev Withdraws all staked tokens from the reward pool and unwraps them to the original tokens.\n     * @param claim A boolean indicating whether to claim rewards before withdrawing.\n     * @param sendToOperator A boolean indicating whether to send the unwrapped tokens to the operator.\n     * If false, the tokens will remain in the contract.\n     * Only the contract owner can call this function.\n     */\n    function withdrawAllAndUnwrap(\n        bool claim,\n        bool sendToOperator\n    ) external onlyOwner {\n        IBaseRewardPool(cvxPoolInfo.rewards).withdrawAllAndUnwrap(claim);\n        if (sendToOperator) {\n            uint256 totalBalance = clpToken.balanceOf(address(this));\n            clpToken.safeTransfer(operator, totalBalance);\n        }\n    }\n\n    /**\n     * @dev Claims the rewards and transfers them to the rewards recipient, if specified.\n     * @param claimExtras A boolean indicating whether to claim extra rewards.\n     */\n    function getReward(bool claimExtras) external {\n        IBaseRewardPool(cvxPoolInfo.rewards).getReward(\n            address(this),\n            claimExtras\n        );\n        if (rewardsRecipient != address(0)) {\n            for (uint i = 0; i < rewardTokens.length; i++) {\n                uint256 balance = IERC20(rewardTokens[i]).balanceOf(\n                    address(this)\n                );\n                IERC20(rewardTokens[i]).safeTransfer(rewardsRecipient, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the current staked balance of the contract.\n     * @return balance The current staked balance.\n     */\n    function stakedBalance() public view returns (uint256 balance) {\n        balance = IBaseRewardPool(cvxPoolInfo.rewards).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Returns the amount of earned rewards by the contract.\n     * @return earnedRewards The amount of earned rewards.\n     */\n    function earned() public view returns (uint256 earnedRewards) {\n        earnedRewards = IBaseRewardPool(cvxPoolInfo.rewards).earned(\n            address(this)\n        );\n    }\n\n    /**\n     * @notice show staked position and earned rewards\n     */\n    function showPositions() external view returns (Position memory position) {\n        position.staked = stakedBalance();\n        position.earned = earned();\n    }\n\n    /// @dev Modifier to restrict function execution to only the contract operator.\n    /// @notice Throws a custom exception `NotOperator` if the caller is not the operator.\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert NotOperator();\n        }\n        _;\n    }\n\n    /// @dev Modifier to restrict function execution to only the contract operator or owner.\n    /// @notice Throws a custom exception `NotOperatorOrOwner` if the caller is neither the operator nor the owner.\n    modifier onlyOperatorOrOwner() {\n        if (msg.sender != operator && msg.sender != owner()) {\n            revert NotOperatorOrOwner();\n        }\n        _;\n    }\n}"
    }
  ]
}