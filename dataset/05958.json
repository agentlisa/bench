{
  "Title": "[M-04] Security Council can undermine any DAO votes to remove a member",
  "Content": "\n<https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/SecurityCouncilManager.sol#L183-L190><br>\n<https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/SecurityCouncilManager.sol#L161-L173><br>\n<https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/SecurityCouncilManager.sol#L176-L180><br>\n<https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/SecurityCouncilManager.sol#L143-L159>\n\nAs stated in the updated constitution text:\n\n\"Security Council members may only be removed prior to the end of their terms under two conditions:\n\n1.  At least 10% of all Votable Tokens have casted votes “in favour” of removal and at least 5/6 (83.33%) of all casted votes are “in favour” of removal; or\n\n2.  At least 9 of the Security Council members vote in favour of removal.\"\n\nHowever, since the Security Council are the only party with the ability to add a member, they can simply re-add the member that was removed by a DAO vote if they disagree with the vote. This entirely defeats the point of giving the DAO the ability to remove a member of the council mid-term.\n\n### Proof of Concept\n\nA member of the Security Council can be removed mid-term by calling `removeMember` in `SecurityCouncilManager.sol`. This can only be called by addresses that have the `MEMBER_REMOVER_ROLE` role; the `SecurityCouncilMemberRemovalGovernor.sol` contract and the 9 of 12 emergency Security Council:\n\n        function removeMember(address _member) external onlyRole(MEMBER_REMOVER_ROLE) {\n            if (_member == address(0)) {\n                revert ZeroAddress();\n            }\n            Cohort cohort = _removeMemberFromCohortArray(_member);\n            _scheduleUpdate();\n            emit MemberRemoved({member: _member, cohort: cohort});\n        }\n\nThe actual member removal is performed by `_removeMemberFromCohortArray`:\n\n        function _removeMemberFromCohortArray(address _member) internal returns (Cohort) {\n            for (uint256 i = 0; i < 2; i++) {\n                address[] storage cohort = i == 0 ? firstCohort : secondCohort;\n                for (uint256 j = 0; j < cohort.length; j++) {\n                    if (_member == cohort[j]) {\n                        cohort[j] = cohort[cohort.length - 1];\n                        cohort.pop();\n                        return i == 0 ? Cohort.FIRST : Cohort.SECOND;\n                    }\n                }\n            }\n            revert NotAMember({member: _member});\n        }\n\nAs you can see, the member that has been removed isn't tracked/stored anywhere for later querying. So, let's assume that the DAO has successfully voted to remove a member. The `removeMember` method is called when the vote is successful and the update is schedule in the L2 timelock.\n\nThe Security Council now have the ability (as the only party with the `MEMBER_ADDER_ROLE` role) to add a new member to fill the relevant cohort on the council by calling `addMember`:\n\n        function addMember(address _newMember, Cohort _cohort) external onlyRole(MEMBER_ADDER_ROLE) {\n            _addMemberToCohortArray(_newMember, _cohort);\n            _scheduleUpdate();\n            emit MemberAdded(_newMember, _cohort);\n        }\n\nWhere `_addMemberToCohortArray` looks like:\n\n        function _addMemberToCohortArray(address _newMember, Cohort _cohort) internal {\n            if (_newMember == address(0)) {\n                revert ZeroAddress();\n            }\n            address[] storage cohort = _cohort == Cohort.FIRST ? firstCohort : secondCohort;\n            if (cohort.length == cohortSize) {\n                revert CohortFull({cohort: _cohort});\n            }\n            if (firstCohortIncludes(_newMember)) {\n                revert MemberInCohort({member: _newMember, cohort: Cohort.FIRST});\n            }\n            if (secondCohortIncludes(_newMember)) {\n                revert MemberInCohort({member: _newMember, cohort: Cohort.SECOND});\n            }\n\n            cohort.push(_newMember);\n        }\n\nAs you can see, this method only checks to ensure the member being added doesn't already exist in either cohort, however there is no validation whether or not this member has been removed before in the current term. As a result, any DAO votes to remove a member can be usurped by the Security Council since they can simply restate the member that was voted to be removed.\n\n### Recommended Mitigation Steps\n\nAny member removals mid-term should be tracked for the lifecycle of the term (6 months) to ensure that the same member can't be re-added. This array should be wiped when a cohort is replaced with a call to `replaceCohort`.\n\n### Assessed type\n\nInvalid Validation\n\n**[yahgwai (Arbitrum) acknowledged and commented](https://github.com/code-423n4/2023-08-arbitrum-findings/issues/97#issuecomment-1678824516):**\n > Acknowledge: The system is working as intended here. The constitution does not specify who the council can or cannot add. This issue is therefore a critique of the constitution (which was not in scope) rather than the code. However we appreciate this critique of the constitution and believe it to be a valid concern.\n\n**[dirk_y (warden) commented](https://github.com/code-423n4/2023-08-arbitrum-findings/issues/97#issuecomment-1686615709):**\n > Just wanted to add some more context here as I'm expecting some debate around this.\n> \n> In my view the Security Council could still be acting in good faith but simply disagree with the vote of the DAO. The security council might have some inside knowledge or existing relationships with the removed member, and they still trust the removed member and trust them to act in good faith for any emergency/non-emergency votes. Maybe they're simply the best person for the job.\n> \n> Imagine a democratic vote for a new prime minister where the existing prime minister simply declines the result of the vote and remains in office anyway...i.e. a dictatorship. The dictator still believes they're acting in the best interests of the nation state. In summary the security council can still be acting in good faith, but their actions are undermining trust in the system (in particular the DAO is losing trust in the security council, despite the security council believing they are acting in the best interests of the DAO).\n> \n> And yes you could argue this is a critique of the constitution but I actually believe this is a critique of the current implementation. Similarly to using OZ roles, you could have a role that can undermine another role's action; this could be a valid medium assuming the two roles weren't owned by the same user.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-arbitrum",
  "Code": [
    {
      "filename": "src/security-council-mgmt/SecurityCouncilManager.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"../ArbitrumTimelock.sol\";\nimport \"../UpgradeExecutor.sol\";\nimport \"../L1ArbitrumTimelock.sol\";\nimport \"./SecurityCouncilMgmtUtils.sol\";\nimport \"./interfaces/ISecurityCouncilManager.sol\";\nimport \"./SecurityCouncilMemberSyncAction.sol\";\nimport \"../UpgradeExecRouteBuilder.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"./Common.sol\";\n\n/// @title  The Security Council Manager\n/// @notice The source of truth for an array of Security Councils that are under management.\n///         Can be used to change members, and replace whole cohorts, ensuring that all managed\n///         Security Councils stay in sync.\n/// @dev    The cohorts in the Security Council Manager can be updated from a number of different sources.\n///         Care must be taken in the timing of these updates to avoid race conditions, as well as to avoid\n///         invalidating other operations.\n///         An example of this could be replacing a member whilst there is an ongoing election. This contract\n///         ensures that a member cannot be in both cohorts, so if a cohort is elected but just prior the security\n///         council decides to replace a member in the previous cohort, then a member could end up in both cohorts.\n///         Since the functions in this contract ensure that this cannot be case, one of the transactions will fail.\n///         To avoid this care must be taken whilst elections are ongoing.\ncontract SecurityCouncilManager is\n    Initializable,\n    AccessControlUpgradeable,\n    ISecurityCouncilManager\n{\n    event CohortReplaced(address[] newCohort, Cohort indexed cohort);\n    event MemberAdded(address indexed newMember, Cohort indexed cohort);\n    event MemberRemoved(address indexed member, Cohort indexed cohort);\n    event MemberReplaced(address indexed replacedMember, address indexed newMember, Cohort cohort);\n    event MemberRotated(address indexed replacedAddress, address indexed newAddress, Cohort cohort);\n    event SecurityCouncilAdded(\n        address securityCouncil, address updateAction, uint256 securityCouncilsLength\n    );\n    event SecurityCouncilRemoved(\n        address securityCouncil, address updateAction, uint256 securityCouncilsLength\n    );\n    event UpgradeExecRouteBuilderSet(address UpgradeExecRouteBuilder);\n\n    // The Security Council members are separated into two cohorts, allowing a whole cohort to be replaced, as\n    // specified by the Arbitrum Constitution.\n    // These two cohort arrays contain the source of truth for the members of the Security Council. When a membership\n    // change needs to be made, a change to these arrays is first made here locally, then pushed to each of the Security Councils\n    // A member cannot be in both cohorts at the same time\n    address[] internal firstCohort;\n    address[] internal secondCohort;\n\n    /// @notice Address of the l2 timelock used by core governance\n    address payable public l2CoreGovTimelock;\n\n    /// @notice The list of Security Councils under management. Any changes to the cohorts in this manager\n    ///         will be pushed to each of these security councils, ensuring that they all stay in sync\n    SecurityCouncilData[] public securityCouncils;\n\n    /// @notice Address of UpgradeExecRouteBuilder. Used to help create security council updates\n    UpgradeExecRouteBuilder public router;\n\n    /// @notice Maximum possible number of Security Councils to manage\n    /// @dev    Since the councils array will be iterated this provides a safety check to make too many Sec Councils\n    ///         aren't added to the array.\n    uint256 public immutable MAX_SECURITY_COUNCILS = 500;\n\n    /// @notice Nonce to ensure that scheduled updates create unique entries in the timelocks\n    uint256 public updateNonce;\n\n    /// @notice Size of cohort under ordinary circumstancces\n    uint256 public cohortSize;\n\n    /// @notice Magic value used by the L1 timelock to indicate that a retryable ticket should be created\n    ///         Value is defined in L1ArbitrumTimelock contract https://etherscan.io/address/0xE6841D92B0C345144506576eC13ECf5103aC7f49#readProxyContract#F5\n    address public constant RETRYABLE_TICKET_MAGIC = 0xa723C008e76E379c55599D2E4d93879BeaFDa79C;\n\n    bytes32 public constant COHORT_REPLACER_ROLE = keccak256(\"COHORT_REPLACER\");\n    bytes32 public constant MEMBER_ADDER_ROLE = keccak256(\"MEMBER_ADDER\");\n    bytes32 public constant MEMBER_REPLACER_ROLE = keccak256(\"MEMBER_REPLACER\");\n    bytes32 public constant MEMBER_ROTATOR_ROLE = keccak256(\"MEMBER_ROTATOR\");\n    bytes32 public constant MEMBER_REMOVER_ROLE = keccak256(\"MEMBER_REMOVER\");\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address[] memory _firstCohort,\n        address[] memory _secondCohort,\n        SecurityCouncilData[] memory _securityCouncils,\n        SecurityCouncilManagerRoles memory _roles,\n        address payable _l2CoreGovTimelock,\n        UpgradeExecRouteBuilder _router\n    ) external initializer {\n        if (_firstCohort.length != _secondCohort.length) {\n            revert CohortLengthMismatch(_firstCohort, _secondCohort);\n        }\n        firstCohort = _firstCohort;\n        secondCohort = _secondCohort;\n        cohortSize = _firstCohort.length;\n        _grantRole(DEFAULT_ADMIN_ROLE, _roles.admin);\n        _grantRole(COHORT_REPLACER_ROLE, _roles.cohortUpdator);\n        _grantRole(MEMBER_ADDER_ROLE, _roles.memberAdder);\n        for (uint256 i = 0; i < _roles.memberRemovers.length; i++) {\n            _grantRole(MEMBER_REMOVER_ROLE, _roles.memberRemovers[i]);\n        }\n        _grantRole(MEMBER_ROTATOR_ROLE, _roles.memberRotator);\n        _grantRole(MEMBER_REPLACER_ROLE, _roles.memberReplacer);\n\n        if (!Address.isContract(_l2CoreGovTimelock)) {\n            revert NotAContract({account: _l2CoreGovTimelock});\n        }\n        l2CoreGovTimelock = _l2CoreGovTimelock;\n\n        _setUpgradeExecRouteBuilder(_router);\n        for (uint256 i = 0; i < _securityCouncils.length; i++) {\n            _addSecurityCouncil(_securityCouncils[i]);\n        }\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function replaceCohort(address[] memory _newCohort, Cohort _cohort)\n        external\n        onlyRole(COHORT_REPLACER_ROLE)\n    {\n        if (_newCohort.length != cohortSize) {\n            revert InvalidNewCohortLength({cohort: _newCohort, cohortSize: cohortSize});\n        }\n\n        // delete the old cohort\n        _cohort == Cohort.FIRST ? delete firstCohort : delete secondCohort;\n\n        for (uint256 i = 0; i < _newCohort.length; i++) {\n            _addMemberToCohortArray(_newCohort[i], _cohort);\n        }\n\n        _scheduleUpdate();\n        emit CohortReplaced(_newCohort, _cohort);\n    }\n\n    function _addMemberToCohortArray(address _newMember, Cohort _cohort) internal {\n        if (_newMember == address(0)) {\n            revert ZeroAddress();\n        }\n        address[] storage cohort = _cohort == Cohort.FIRST ? firstCohort : secondCohort;\n        if (cohort.length == cohortSize) {\n            revert CohortFull({cohort: _cohort});\n        }\n        if (firstCohortIncludes(_newMember)) {\n            revert MemberInCohort({member: _newMember, cohort: Cohort.FIRST});\n        }\n        if (secondCohortIncludes(_newMember)) {\n            revert MemberInCohort({member: _newMember, cohort: Cohort.SECOND});\n        }\n\n        cohort.push(_newMember);\n    }\n\n    function _removeMemberFromCohortArray(address _member) internal returns (Cohort) {\n        for (uint256 i = 0; i < 2; i++) {\n            address[] storage cohort = i == 0 ? firstCohort : secondCohort;\n            for (uint256 j = 0; j < cohort.length; j++) {\n                if (_member == cohort[j]) {\n                    cohort[j] = cohort[cohort.length - 1];\n                    cohort.pop();\n                    return i == 0 ? Cohort.FIRST : Cohort.SECOND;\n                }\n            }\n        }\n        revert NotAMember({member: _member});\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function addMember(address _newMember, Cohort _cohort) external onlyRole(MEMBER_ADDER_ROLE) {\n        _addMemberToCohortArray(_newMember, _cohort);\n        _scheduleUpdate();\n        emit MemberAdded(_newMember, _cohort);\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function removeMember(address _member) external onlyRole(MEMBER_REMOVER_ROLE) {\n        if (_member == address(0)) {\n            revert ZeroAddress();\n        }\n        Cohort cohort = _removeMemberFromCohortArray(_member);\n        _scheduleUpdate();\n        emit MemberRemoved({member: _member, cohort: cohort});\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function replaceMember(address _memberToReplace, address _newMember)\n        external\n        onlyRole(MEMBER_REPLACER_ROLE)\n    {\n        Cohort cohort = _swapMembers(_memberToReplace, _newMember);\n        emit MemberReplaced({\n            replacedMember: _memberToReplace,\n            newMember: _newMember,\n            cohort: cohort\n        });\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function rotateMember(address _currentAddress, address _newAddress)\n        external\n        onlyRole(MEMBER_ROTATOR_ROLE)\n    {\n        Cohort cohort = _swapMembers(_currentAddress, _newAddress);\n        emit MemberRotated({\n            replacedAddress: _currentAddress,\n            newAddress: _newAddress,\n            cohort: cohort\n        });\n    }\n\n    function _swapMembers(address _addressToRemove, address _addressToAdd)\n        internal\n        returns (Cohort)\n    {\n        if (_addressToRemove == address(0) || _addressToAdd == address(0)) {\n            revert ZeroAddress();\n        }\n        Cohort cohort = _removeMemberFromCohortArray(_addressToRemove);\n        _addMemberToCohortArray(_addressToAdd, cohort);\n        _scheduleUpdate();\n        return cohort;\n    }\n\n    function _addSecurityCouncil(SecurityCouncilData memory _securityCouncilData) internal {\n        if (securityCouncils.length == MAX_SECURITY_COUNCILS) {\n            revert MaxSecurityCouncils(securityCouncils.length);\n        }\n\n        if (\n            _securityCouncilData.updateAction == address(0)\n                || _securityCouncilData.securityCouncil == address(0)\n        ) {\n            revert ZeroAddress();\n        }\n\n        if (_securityCouncilData.chainId == 0) {\n            revert SecurityCouncilZeroChainID(_securityCouncilData);\n        }\n\n        if (!router.upExecLocationExists(_securityCouncilData.chainId)) {\n            revert SecurityCouncilNotInRouter(_securityCouncilData);\n        }\n\n        for (uint256 i = 0; i < securityCouncils.length; i++) {\n            SecurityCouncilData storage existantSecurityCouncil = securityCouncils[i];\n\n            if (\n                existantSecurityCouncil.chainId == _securityCouncilData.chainId\n                    && existantSecurityCouncil.securityCouncil == _securityCouncilData.securityCouncil\n            ) {\n                revert SecurityCouncilAlreadyInRouter(_securityCouncilData);\n            }\n        }\n\n        securityCouncils.push(_securityCouncilData);\n        emit SecurityCouncilAdded(\n            _securityCouncilData.securityCouncil,\n            _securityCouncilData.updateAction,\n            securityCouncils.length\n        );\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function addSecurityCouncil(SecurityCouncilData memory _securityCouncilData)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _addSecurityCouncil(_securityCouncilData);\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function removeSecurityCouncil(SecurityCouncilData memory _securityCouncilData)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        returns (bool)\n    {\n        for (uint256 i = 0; i < securityCouncils.length; i++) {\n            SecurityCouncilData storage securityCouncilData = securityCouncils[i];\n            if (\n                securityCouncilData.securityCouncil == _securityCouncilData.securityCouncil\n                    && securityCouncilData.chainId == _securityCouncilData.chainId\n                    && securityCouncilData.updateAction == _securityCouncilData.updateAction\n            ) {\n                SecurityCouncilData storage lastSecurityCouncil =\n                    securityCouncils[securityCouncils.length - 1];\n\n                securityCouncils[i] = lastSecurityCouncil;\n                securityCouncils.pop();\n                emit SecurityCouncilRemoved(\n                    securityCouncilData.securityCouncil,\n                    securityCouncilData.updateAction,\n                    securityCouncils.length\n                );\n                return true;\n            }\n        }\n        revert SecurityCouncilNotInManager(_securityCouncilData);\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function setUpgradeExecRouteBuilder(UpgradeExecRouteBuilder _router)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _setUpgradeExecRouteBuilder(_router);\n    }\n\n    function _setUpgradeExecRouteBuilder(UpgradeExecRouteBuilder _router) internal {\n        address routerAddress = address(_router);\n\n        if (!Address.isContract(routerAddress)) {\n            revert NotAContract({account: routerAddress});\n        }\n\n        router = _router;\n        emit UpgradeExecRouteBuilderSet(routerAddress);\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function getFirstCohort() external view returns (address[] memory) {\n        return firstCohort;\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function getSecondCohort() external view returns (address[] memory) {\n        return secondCohort;\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function getBothCohorts() public view returns (address[] memory) {\n        address[] memory members = new address[](firstCohort.length + secondCohort.length);\n        for (uint256 i = 0; i < firstCohort.length; i++) {\n            members[i] = firstCohort[i];\n        }\n        for (uint256 i = 0; i < secondCohort.length; i++) {\n            members[firstCohort.length + i] = secondCohort[i];\n        }\n        return members;\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function securityCouncilsLength() public view returns (uint256) {\n        return securityCouncils.length;\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function firstCohortIncludes(address account) public view returns (bool) {\n        return cohortIncludes(Cohort.FIRST, account);\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function secondCohortIncludes(address account) public view returns (bool) {\n        return cohortIncludes(Cohort.SECOND, account);\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function cohortIncludes(Cohort cohort, address account) public view returns (bool) {\n        address[] memory cohortMembers = cohort == Cohort.FIRST ? firstCohort : secondCohort;\n        return SecurityCouncilMgmtUtils.isInArray(account, cohortMembers);\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function generateSalt(address[] memory _members, uint256 nonce)\n        external\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_members, nonce));\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function getScheduleUpdateInnerData(uint256 nonce)\n        public\n        view\n        returns (address[] memory, address, bytes memory)\n    {\n        // build a union array of security council members\n        address[] memory newMembers = getBothCohorts();\n\n        // build batch call to L1 timelock\n        address[] memory actionAddresses = new address[](securityCouncils.length);\n        bytes[] memory actionDatas = new bytes[](securityCouncils.length);\n        uint256[] memory chainIds = new uint256[](securityCouncils.length);\n\n        for (uint256 i = 0; i < securityCouncils.length; i++) {\n            SecurityCouncilData memory securityCouncilData = securityCouncils[i];\n            actionAddresses[i] = securityCouncilData.updateAction;\n            chainIds[i] = securityCouncilData.chainId;\n            actionDatas[i] = abi.encodeWithSelector(\n                SecurityCouncilMemberSyncAction.perform.selector,\n                securityCouncilData.securityCouncil,\n                newMembers,\n                nonce\n            );\n        }\n\n        // unique salt used for replay protection in the L1 timelock\n        bytes32 salt = this.generateSalt(newMembers, nonce);\n        (address to, bytes memory data) = router.createActionRouteData(\n            chainIds,\n            actionAddresses,\n            new uint256[](securityCouncils.length), // all values are always 0\n            actionDatas,\n            0,\n            salt\n        );\n\n        return (newMembers, to, data);\n    }\n\n    /// @dev Create a union of the second and first cohort, then update all Security Councils under management with that unioned array.\n    ///      Updates will need to be scheduled through timelocks and target upgrade executors\n    function _scheduleUpdate() internal {\n        // always update the nonce\n        // this is used to ensure that proposals in the timelocks are unique\n        // and calls to the upgradeExecutors are in the correct order\n        updateNonce++;\n        (address[] memory newMembers, address to, bytes memory data) =\n            getScheduleUpdateInnerData(updateNonce);\n\n        ArbitrumTimelock(l2CoreGovTimelock).schedule({\n            target: to, // ArbSys address - this will trigger a call from L2->L1\n            value: 0,\n            // call to ArbSys.sendTxToL1; target the L1 timelock with the calldata previously constucted\n            data: data,\n            predecessor: bytes32(0),\n            // must be unique as the proposal hash is used for replay protection in the L2 timelock\n            // we cant be sure another proposal wont use this salt, and the same target + data\n            // but in that case the proposal will do what we want it to do anyway\n            // this can however block the execution of the election - so in this case the\n            // Security Council would need to unblock it by setting the election to executed state\n            // in the Member Election governor\n            salt: this.generateSalt(newMembers, updateNonce),\n            delay: ArbitrumTimelock(l2CoreGovTimelock).getMinDelay()\n        });\n    }\n}"
    },
    {
      "filename": "src/security-council-mgmt/SecurityCouncilManager.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"../ArbitrumTimelock.sol\";\nimport \"../UpgradeExecutor.sol\";\nimport \"../L1ArbitrumTimelock.sol\";\nimport \"./SecurityCouncilMgmtUtils.sol\";\nimport \"./interfaces/ISecurityCouncilManager.sol\";\nimport \"./SecurityCouncilMemberSyncAction.sol\";\nimport \"../UpgradeExecRouteBuilder.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"./Common.sol\";\n\n/// @title  The Security Council Manager\n/// @notice The source of truth for an array of Security Councils that are under management.\n///         Can be used to change members, and replace whole cohorts, ensuring that all managed\n///         Security Councils stay in sync.\n/// @dev    The cohorts in the Security Council Manager can be updated from a number of different sources.\n///         Care must be taken in the timing of these updates to avoid race conditions, as well as to avoid\n///         invalidating other operations.\n///         An example of this could be replacing a member whilst there is an ongoing election. This contract\n///         ensures that a member cannot be in both cohorts, so if a cohort is elected but just prior the security\n///         council decides to replace a member in the previous cohort, then a member could end up in both cohorts.\n///         Since the functions in this contract ensure that this cannot be case, one of the transactions will fail.\n///         To avoid this care must be taken whilst elections are ongoing.\ncontract SecurityCouncilManager is\n    Initializable,\n    AccessControlUpgradeable,\n    ISecurityCouncilManager\n{\n    event CohortReplaced(address[] newCohort, Cohort indexed cohort);\n    event MemberAdded(address indexed newMember, Cohort indexed cohort);\n    event MemberRemoved(address indexed member, Cohort indexed cohort);\n    event MemberReplaced(address indexed replacedMember, address indexed newMember, Cohort cohort);\n    event MemberRotated(address indexed replacedAddress, address indexed newAddress, Cohort cohort);\n    event SecurityCouncilAdded(\n        address securityCouncil, address updateAction, uint256 securityCouncilsLength\n    );\n    event SecurityCouncilRemoved(\n        address securityCouncil, address updateAction, uint256 securityCouncilsLength\n    );\n    event UpgradeExecRouteBuilderSet(address UpgradeExecRouteBuilder);\n\n    // The Security Council members are separated into two cohorts, allowing a whole cohort to be replaced, as\n    // specified by the Arbitrum Constitution.\n    // These two cohort arrays contain the source of truth for the members of the Security Council. When a membership\n    // change needs to be made, a change to these arrays is first made here locally, then pushed to each of the Security Councils\n    // A member cannot be in both cohorts at the same time\n    address[] internal firstCohort;\n    address[] internal secondCohort;\n\n    /// @notice Address of the l2 timelock used by core governance\n    address payable public l2CoreGovTimelock;\n\n    /// @notice The list of Security Councils under management. Any changes to the cohorts in this manager\n    ///         will be pushed to each of these security councils, ensuring that they all stay in sync\n    SecurityCouncilData[] public securityCouncils;\n\n    /// @notice Address of UpgradeExecRouteBuilder. Used to help create security council updates\n    UpgradeExecRouteBuilder public router;\n\n    /// @notice Maximum possible number of Security Councils to manage\n    /// @dev    Since the councils array will be iterated this provides a safety check to make too many Sec Councils\n    ///         aren't added to the array.\n    uint256 public immutable MAX_SECURITY_COUNCILS = 500;\n\n    /// @notice Nonce to ensure that scheduled updates create unique entries in the timelocks\n    uint256 public updateNonce;\n\n    /// @notice Size of cohort under ordinary circumstancces\n    uint256 public cohortSize;\n\n    /// @notice Magic value used by the L1 timelock to indicate that a retryable ticket should be created\n    ///         Value is defined in L1ArbitrumTimelock contract https://etherscan.io/address/0xE6841D92B0C345144506576eC13ECf5103aC7f49#readProxyContract#F5\n    address public constant RETRYABLE_TICKET_MAGIC = 0xa723C008e76E379c55599D2E4d93879BeaFDa79C;\n\n    bytes32 public constant COHORT_REPLACER_ROLE = keccak256(\"COHORT_REPLACER\");\n    bytes32 public constant MEMBER_ADDER_ROLE = keccak256(\"MEMBER_ADDER\");\n    bytes32 public constant MEMBER_REPLACER_ROLE = keccak256(\"MEMBER_REPLACER\");\n    bytes32 public constant MEMBER_ROTATOR_ROLE = keccak256(\"MEMBER_ROTATOR\");\n    bytes32 public constant MEMBER_REMOVER_ROLE = keccak256(\"MEMBER_REMOVER\");\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address[] memory _firstCohort,\n        address[] memory _secondCohort,\n        SecurityCouncilData[] memory _securityCouncils,\n        SecurityCouncilManagerRoles memory _roles,\n        address payable _l2CoreGovTimelock,\n        UpgradeExecRouteBuilder _router\n    ) external initializer {\n        if (_firstCohort.length != _secondCohort.length) {\n            revert CohortLengthMismatch(_firstCohort, _secondCohort);\n        }\n        firstCohort = _firstCohort;\n        secondCohort = _secondCohort;\n        cohortSize = _firstCohort.length;\n        _grantRole(DEFAULT_ADMIN_ROLE, _roles.admin);\n        _grantRole(COHORT_REPLACER_ROLE, _roles.cohortUpdator);\n        _grantRole(MEMBER_ADDER_ROLE, _roles.memberAdder);\n        for (uint256 i = 0; i < _roles.memberRemovers.length; i++) {\n            _grantRole(MEMBER_REMOVER_ROLE, _roles.memberRemovers[i]);\n        }\n        _grantRole(MEMBER_ROTATOR_ROLE, _roles.memberRotator);\n        _grantRole(MEMBER_REPLACER_ROLE, _roles.memberReplacer);\n\n        if (!Address.isContract(_l2CoreGovTimelock)) {\n            revert NotAContract({account: _l2CoreGovTimelock});\n        }\n        l2CoreGovTimelock = _l2CoreGovTimelock;\n\n        _setUpgradeExecRouteBuilder(_router);\n        for (uint256 i = 0; i < _securityCouncils.length; i++) {\n            _addSecurityCouncil(_securityCouncils[i]);\n        }\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function replaceCohort(address[] memory _newCohort, Cohort _cohort)\n        external\n        onlyRole(COHORT_REPLACER_ROLE)\n    {\n        if (_newCohort.length != cohortSize) {\n            revert InvalidNewCohortLength({cohort: _newCohort, cohortSize: cohortSize});\n        }\n\n        // delete the old cohort\n        _cohort == Cohort.FIRST ? delete firstCohort : delete secondCohort;\n\n        for (uint256 i = 0; i < _newCohort.length; i++) {\n            _addMemberToCohortArray(_newCohort[i], _cohort);\n        }\n\n        _scheduleUpdate();\n        emit CohortReplaced(_newCohort, _cohort);\n    }\n\n    function _addMemberToCohortArray(address _newMember, Cohort _cohort) internal {\n        if (_newMember == address(0)) {\n            revert ZeroAddress();\n        }\n        address[] storage cohort = _cohort == Cohort.FIRST ? firstCohort : secondCohort;\n        if (cohort.length == cohortSize) {\n            revert CohortFull({cohort: _cohort});\n        }\n        if (firstCohortIncludes(_newMember)) {\n            revert MemberInCohort({member: _newMember, cohort: Cohort.FIRST});\n        }\n        if (secondCohortIncludes(_newMember)) {\n            revert MemberInCohort({member: _newMember, cohort: Cohort.SECOND});\n        }\n\n        cohort.push(_newMember);\n    }\n\n    function _removeMemberFromCohortArray(address _member) internal returns (Cohort) {\n        for (uint256 i = 0; i < 2; i++) {\n            address[] storage cohort = i == 0 ? firstCohort : secondCohort;\n            for (uint256 j = 0; j < cohort.length; j++) {\n                if (_member == cohort[j]) {\n                    cohort[j] = cohort[cohort.length - 1];\n                    cohort.pop();\n                    return i == 0 ? Cohort.FIRST : Cohort.SECOND;\n                }\n            }\n        }\n        revert NotAMember({member: _member});\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function addMember(address _newMember, Cohort _cohort) external onlyRole(MEMBER_ADDER_ROLE) {\n        _addMemberToCohortArray(_newMember, _cohort);\n        _scheduleUpdate();\n        emit MemberAdded(_newMember, _cohort);\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function removeMember(address _member) external onlyRole(MEMBER_REMOVER_ROLE) {\n        if (_member == address(0)) {\n            revert ZeroAddress();\n        }\n        Cohort cohort = _removeMemberFromCohortArray(_member);\n        _scheduleUpdate();\n        emit MemberRemoved({member: _member, cohort: cohort});\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function replaceMember(address _memberToReplace, address _newMember)\n        external\n        onlyRole(MEMBER_REPLACER_ROLE)\n    {\n        Cohort cohort = _swapMembers(_memberToReplace, _newMember);\n        emit MemberReplaced({\n            replacedMember: _memberToReplace,\n            newMember: _newMember,\n            cohort: cohort\n        });\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function rotateMember(address _currentAddress, address _newAddress)\n        external\n        onlyRole(MEMBER_ROTATOR_ROLE)\n    {\n        Cohort cohort = _swapMembers(_currentAddress, _newAddress);\n        emit MemberRotated({\n            replacedAddress: _currentAddress,\n            newAddress: _newAddress,\n            cohort: cohort\n        });\n    }\n\n    function _swapMembers(address _addressToRemove, address _addressToAdd)\n        internal\n        returns (Cohort)\n    {\n        if (_addressToRemove == address(0) || _addressToAdd == address(0)) {\n            revert ZeroAddress();\n        }\n        Cohort cohort = _removeMemberFromCohortArray(_addressToRemove);\n        _addMemberToCohortArray(_addressToAdd, cohort);\n        _scheduleUpdate();\n        return cohort;\n    }\n\n    function _addSecurityCouncil(SecurityCouncilData memory _securityCouncilData) internal {\n        if (securityCouncils.length == MAX_SECURITY_COUNCILS) {\n            revert MaxSecurityCouncils(securityCouncils.length);\n        }\n\n        if (\n            _securityCouncilData.updateAction == address(0)\n                || _securityCouncilData.securityCouncil == address(0)\n        ) {\n            revert ZeroAddress();\n        }\n\n        if (_securityCouncilData.chainId == 0) {\n            revert SecurityCouncilZeroChainID(_securityCouncilData);\n        }\n\n        if (!router.upExecLocationExists(_securityCouncilData.chainId)) {\n            revert SecurityCouncilNotInRouter(_securityCouncilData);\n        }\n\n        for (uint256 i = 0; i < securityCouncils.length; i++) {\n            SecurityCouncilData storage existantSecurityCouncil = securityCouncils[i];\n\n            if (\n                existantSecurityCouncil.chainId == _securityCouncilData.chainId\n                    && existantSecurityCouncil.securityCouncil == _securityCouncilData.securityCouncil\n            ) {\n                revert SecurityCouncilAlreadyInRouter(_securityCouncilData);\n            }\n        }\n\n        securityCouncils.push(_securityCouncilData);\n        emit SecurityCouncilAdded(\n            _securityCouncilData.securityCouncil,\n            _securityCouncilData.updateAction,\n            securityCouncils.length\n        );\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function addSecurityCouncil(SecurityCouncilData memory _securityCouncilData)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _addSecurityCouncil(_securityCouncilData);\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function removeSecurityCouncil(SecurityCouncilData memory _securityCouncilData)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        returns (bool)\n    {\n        for (uint256 i = 0; i < securityCouncils.length; i++) {\n            SecurityCouncilData storage securityCouncilData = securityCouncils[i];\n            if (\n                securityCouncilData.securityCouncil == _securityCouncilData.securityCouncil\n                    && securityCouncilData.chainId == _securityCouncilData.chainId\n                    && securityCouncilData.updateAction == _securityCouncilData.updateAction\n            ) {\n                SecurityCouncilData storage lastSecurityCouncil =\n                    securityCouncils[securityCouncils.length - 1];\n\n                securityCouncils[i] = lastSecurityCouncil;\n                securityCouncils.pop();\n                emit SecurityCouncilRemoved(\n                    securityCouncilData.securityCouncil,\n                    securityCouncilData.updateAction,\n                    securityCouncils.length\n                );\n                return true;\n            }\n        }\n        revert SecurityCouncilNotInManager(_securityCouncilData);\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function setUpgradeExecRouteBuilder(UpgradeExecRouteBuilder _router)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        _setUpgradeExecRouteBuilder(_router);\n    }\n\n    function _setUpgradeExecRouteBuilder(UpgradeExecRouteBuilder _router) internal {\n        address routerAddress = address(_router);\n\n        if (!Address.isContract(routerAddress)) {\n            revert NotAContract({account: routerAddress});\n        }\n\n        router = _router;\n        emit UpgradeExecRouteBuilderSet(routerAddress);\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function getFirstCohort() external view returns (address[] memory) {\n        return firstCohort;\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function getSecondCohort() external view returns (address[] memory) {\n        return secondCohort;\n    }\n\n    /// @inheritdoc ISecurityCouncilManager\n    function getBothCohorts() public view returns (address[] memory) {\n        address[] memory members = new address[](firstCohort.length + secondCohort.length);\n        for (uint256 i = 0; i < firstCohort.length; i++) {\n            me"
    }
  ]
}