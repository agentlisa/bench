{
  "Title": "[G-09] Don't compare boolean expressions to boolean literals (3 instances)",
  "Content": "\n*   Deployment. Gas Saved: **3 006**\n\n*   Minumal Method Call. Gas Saved: **43**\n\n*   Average Method Call. Gas Saved: **-477**\n\n*   Maximum Method Call. Gas Saved: **55**\n\n### src/ERC20/ERC20PermitPermissionedMint.sol:[46](https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/ERC20/ERC20PermitPermissionedMint.sol#L46), [68](https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/ERC20/ERC20PermitPermissionedMint.sol#L68), [78](https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/ERC20/ERC20PermitPermissionedMint.sol#L78)\n\n```diff\ndiff --git a/src/ERC20/ERC20PermitPermissionedMint.sol b/src/ERC20/ERC20PermitPermissionedMint.sol\nindex 3bed26d..860d2c4 100644\n--- a/src/ERC20/ERC20PermitPermissionedMint.sol\n+++ b/src/ERC20/ERC20PermitPermissionedMint.sol\n@@ -43,7 +43,7 @@ contract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n   43,  43:     }\n   44,  44:\n   45,  45:     modifier onlyMinters() {\n-  46     :-       require(minters[msg.sender] == true, \"Only minters\");\n+       46:+       require(minters[msg.sender], \"Only minters\");\n   47,  47:         _;\n   48,  48:     }\n   49,  49:\n@@ -65,7 +65,7 @@ contract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n   65,  65:     function addMinter(address minter_address) public onlyByOwnGov {\n   66,  66:         require(minter_address != address(0), \"Zero address detected\");\n   67,  67:\n-  68     :-        require(minters[minter_address] == false, \"Address already exists\");\n+       68:+        require(!minters[minter_address], \"Address already exists\");\n   69,  69:         minters[minter_address] = true;\n   70,  70:         minters_array.push(minter_address);\n   71,  71:\n@@ -75,7 +75,7 @@ contract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n   75,  75:     // Remove a minter\n   76,  76:     function removeMinter(address minter_address) public onlyByOwnGov {\n   77,  77:         require(minter_address != address(0), \"Zero address detected\");\n-  78     :-        require(minters[minter_address] == true, \"Address nonexistant\");\n+       78:+        require(minters[minter_address], \"Address nonexistant\");\n   79,  79:\n   80,  80:         // Delete from the mapping\n   81,  81:         delete minters[minter_address];\n```\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-09-frax",
  "Code": [
    {
      "filename": "src/ERC20/ERC20PermitPermissionedMint.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"../Utils/Owned.sol\";\n\n/// @title Parent contract for frxETH.sol\n/** @notice Combines Openzeppelin's ERC20Permit and ERC20Burnable with Synthetix's Owned. \n    Also includes a list of authorized minters */\n/// @dev frxETH adheres to EIP-712/EIP-2612 and can use permits\ncontract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n    // Core\n    address public timelock_address;\n\n    // Minters\n    address[] public minters_array; // Allowed to mint\n    mapping(address => bool) public minters; // Mapping is also used for faster verification\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _creator_address,\n        address _timelock_address,\n        string memory _name,\n        string memory _symbol\n    ) \n    ERC20(_name, _symbol)\n    ERC20Permit(_name) \n    Owned(_creator_address)\n    {\n      timelock_address = _timelock_address;\n    }\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyMinters() {\n       require(minters[msg.sender] == true, \"Only minters\");\n        _;\n    } \n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // Used by minters when user redeems\n    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {\n        super.burnFrom(b_address, b_amount);\n        emit TokenMinterBurned(b_address, msg.sender, b_amount);\n    }\n\n    // This function is what other minters will call to mint new tokens \n    function minter_mint(address m_address, uint256 m_amount) public onlyMinters {\n        super._mint(m_address, m_amount);\n        emit TokenMinterMinted(msg.sender, m_address, m_amount);\n    }\n\n    // Adds whitelisted minters \n    function addMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n\n        require(minters[minter_address] == false, \"Address already exists\");\n        minters[minter_address] = true; \n        minters_array.push(minter_address);\n\n        emit MinterAdded(minter_address);\n    }\n\n    // Remove a minter \n    function removeMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == true, \"Address nonexistant\");\n        \n        // Delete from the mapping\n        delete minters[minter_address];\n\n        // 'Delete' from the array by setting the address to 0x0\n        for (uint i = 0; i < minters_array.length; i++){ \n            if (minters_array[i] == minter_address) {\n                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                break;\n            }\n        }\n\n        emit MinterRemoved(minter_address);\n    }\n\n    function setTimelock(address _timelock_address) public onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\"); \n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    /* ========== EVENTS ========== */\n    \n    event TokenMinterBurned(address indexed from, address indexed to, uint256 amount);\n    event TokenMinterMinted(address indexed from, address indexed to, uint256 amount);\n    event MinterAdded(address minter_address);\n    event MinterRemoved(address minter_address);\n    event TimelockChanged(address timelock_address);\n}"
    }
  ]
}