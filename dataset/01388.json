{
  "Title": "The callerOrDelegated specification is not followed for CloseTrove",
  "Content": "##### Description\nFor all key functions in `BorrowerOperations` users can choose their privileged address to delegate an operation.\n- https://github.com/prisma-fi/prisma-contracts/blob/52b26b8a2f1904b048754d5443e08d2144610b92/contracts/dependencies/DelegatedOps.sol#L22-L29\n\nComment there states that:\n```\nIn executing the call, \nall internal state updates \nshould be applied for `account` \nand all value transfers \nshould occur to or from the caller.\n```\nIt is not the case for `closeTrove()`.\n- https://github.com/prisma-fi/prisma-contracts/blob/52b26b8a2f1904b048754d5443e08d2144610b92/contracts/core/BorrowerOperations.sol#L393-L398\nHere, the contract closes the trove taking debtToken from `msg.sender` (as it should), but the remaining collateral is sent to `account`, so the specification is not followed.\n\n##### Recommendation\nWe recommend either sending collateral to `msg.sender` or fixing the comment describing the desired behavior.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/dependencies/DelegatedOps.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n/**\n    @title Prisma Delegated Operations\n    @notice Allows delegation to specific contract functionality. Useful for creating\n            wrapper contracts to bundle multiple interactions into a single call.\n\n            Functions that supports delegation should include an `account` input allowing\n            the delegated caller to indicate who they are calling on behalf of. In executing\n            the call, all internal state updates should be applied for `account` and all\n            value transfers should occur to or from the caller.\n\n            For example: a delegated call to `openTrove` should transfer collateral\n            from the caller, create the debt position for `account`, and send newly\n            minted tokens to the caller.\n */\ncontract DelegatedOps {\n    mapping(address owner => mapping(address caller => bool isApproved)) public isApprovedDelegate;\n\n    modifier callerOrDelegated(address _account) {\n        require(msg.sender == _account || isApprovedDelegate[_account][msg.sender], \"Delegate not approved\");\n        _;\n    }\n\n    function setDelegateApproval(address _delegate, bool _isApproved) external {\n        isApprovedDelegate[msg.sender][_delegate] = _isApproved;\n    }\n}"
    },
    {
      "filename": "contracts/core/BorrowerOperations.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IDebtToken.sol\";\nimport \"../dependencies/PrismaBase.sol\";\nimport \"../dependencies/PrismaMath.sol\";\nimport \"../dependencies/PrismaOwnable.sol\";\nimport \"../dependencies/DelegatedOps.sol\";\n\n/**\n    @title Prisma Borrower Operations\n    @notice Based on Liquity's `BorrowerOperations`\n            https://github.com/liquity/dev/blob/main/packages/contracts/contracts/BorrowerOperations.sol\n\n            Prisma's implementation is modified to support multiple collaterals. There is a 1:n\n            relationship between `BorrowerOperations` and each `TroveManager` / `SortedTroves` pair.\n */\ncontract BorrowerOperations is PrismaBase, PrismaOwnable, DelegatedOps {\n    IDebtToken public immutable debtToken;\n    address public immutable factory;\n    uint256 public minNetDebt;\n\n    mapping(IERC20 => TrovesContracts) internal _trovesContracts;\n    ITroveManager[] internal _troveManagers;\n\n    struct TrovesContracts {\n        ITroveManager troveManager;\n        uint16 index;\n    }\n\n    struct SystemBalances {\n        uint256[] collaterals;\n        uint256[] debts;\n        uint256[] prices;\n    }\n\n    struct LocalVariables_adjustTrove {\n        uint256 price;\n        uint256 collChange;\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 debt;\n        uint256 coll;\n        uint256 newDebt;\n        uint256 newColl;\n        uint256 stake;\n        bool isDebtIncrease;\n        uint256 debtChange;\n    }\n\n    struct LocalVariables_openTrove {\n        uint256 price;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 NICR;\n        uint256 stake;\n        uint256 arrayIndex;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 stake,\n        BorrowerOperation operation\n    );\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 stake, uint8 operation);\n    event BorrowingFeePaid(address indexed borrower, uint256 amount);\n    event CollateralEnabled(address collateralToken);\n\n    constructor(\n        address _prismaCore,\n        address _debtTokenAddress,\n        address _factory,\n        uint256 _minNetDebt,\n        uint256 _gasCompensation\n    ) PrismaOwnable(_prismaCore) PrismaBase(_gasCompensation) {\n        debtToken = IDebtToken(_debtTokenAddress);\n        factory = _factory;\n        _setMinNetDebt(_minNetDebt);\n    }\n\n    function setMinNetDebt(uint256 _minNetDebt) public onlyOwner {\n        _setMinNetDebt(_minNetDebt);\n    }\n\n    function _setMinNetDebt(uint256 _minNetDebt) internal {\n        require(_minNetDebt > 0);\n        minNetDebt = _minNetDebt;\n    }\n\n    function enableCollateral(ITroveManager troveManager, IERC20 collateralToken) external {\n        require(msg.sender == factory, \"!factory\");\n        require(address(_trovesContracts[collateralToken].troveManager) == address(0), \"Collateral already enabled\");\n        _trovesContracts[collateralToken] = TrovesContracts(troveManager, uint16(_troveManagers.length));\n        _troveManagers.push(troveManager);\n        emit CollateralEnabled(address(collateralToken));\n    }\n\n    function getTCR(\n        SystemBalances memory balances\n    ) public pure returns (uint256 amount, uint256 totalPricedCollateral, uint256 totalDebt) {\n        uint256 loopEnd = balances.collaterals.length;\n        for (uint256 i; i < loopEnd; ) {\n            totalPricedCollateral += (balances.collaterals[i] * balances.prices[i]);\n            totalDebt += balances.debts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        amount = PrismaMath._computeCR(totalPricedCollateral, totalDebt);\n\n        return (amount, totalPricedCollateral, totalDebt);\n    }\n\n    /**\n        @notice Get total collateral and debt balances for all active collaterals, as well as\n                the current collateral prices\n        @dev Not a view because fetching from the oracle is state changing.\n             Can still be accessed as a view from within the UX.\n     */\n    function fetchBalances() public returns (SystemBalances memory balances) {\n        uint256 loopEnd = _troveManagers.length;\n        balances = SystemBalances({\n            collaterals: new uint256[](loopEnd),\n            debts: new uint256[](loopEnd),\n            prices: new uint256[](loopEnd)\n        });\n        for (uint256 i; i < loopEnd; ) {\n            ITroveManager troveManager = _troveManagers[i];\n            (uint256 collateral, uint256 debt, uint256 price) = troveManager.getEntireSystemBalances();\n            balances.collaterals[i] = collateral;\n            balances.debts[i] = debt;\n            balances.prices[i] = price;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function checkRecoveryMode(uint256 TCR) public pure returns (bool) {\n        return TCR < CCR;\n    }\n\n    function getCompositeDebt(uint256 _debt) external view returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        IERC20 collateralToken,\n        address account,\n        uint256 _maxFeePercentage,\n        uint256 _collateralAmount,\n        uint256 _debtAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        require(!PRISMA_CORE.paused(), \"Deposits are paused\");\n\n        (ITroveManager troveManager, uint256 index) = _getTroveManagerAndIndex(collateralToken);\n\n        LocalVariables_openTrove memory vars;\n        bool isRecoveryMode;\n        uint256 totalPricedCollateral;\n        uint256 totalDebt;\n        (vars.price, totalPricedCollateral, totalDebt, isRecoveryMode) = _getTCRData(index);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n\n        vars.netDebt = _debtAmount;\n\n        if (!isRecoveryMode) {\n            vars.netDebt = vars.netDebt + _triggerBorrowingFee(troveManager, account, _maxFeePercentage, _debtAmount);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested Debt amount + Debt borrowing fee + Debt gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        vars.ICR = PrismaMath._computeCR(_collateralAmount, vars.compositeDebt, vars.price);\n        vars.NICR = PrismaMath._computeNominalCR(_collateralAmount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint256 newTCR = _getNewTCRFromTroveChange(\n                totalPricedCollateral,\n                totalDebt,\n                _collateralAmount * vars.price,\n                true,\n                vars.compositeDebt,\n                true\n            ); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        // Create the trove\n        (vars.stake, vars.arrayIndex) = troveManager.openTrove(\n            account,\n            _collateralAmount,\n            vars.compositeDebt,\n            vars.NICR,\n            _upperHint,\n            _lowerHint\n        );\n        emit TroveCreated(account, vars.arrayIndex);\n\n        // Move the collateral to the Trove Manager\n        collateralToken.transferFrom(msg.sender, address(troveManager), _collateralAmount);\n\n        //  and mint the DebtAmount to the caller and gas compensation for Gas Pool\n        debtToken.mintWithGasCompensation(msg.sender, _debtAmount);\n\n        emit TroveUpdated(account, vars.compositeDebt, _collateralAmount, vars.stake, BorrowerOperation.openTrove);\n    }\n\n    // Send collateral to a trove\n    function addColl(\n        IERC20 collateralToken,\n        address account,\n        uint256 _collateralAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        require(!PRISMA_CORE.paused(), \"Trove adjustments are paused\");\n        _adjustTrove(collateralToken, account, 0, _collateralAmount, 0, 0, false, _upperHint, _lowerHint);\n    }\n\n    // Withdraw collateral from a trove\n    function withdrawColl(\n        IERC20 collateralToken,\n        address account,\n        uint256 _collWithdrawal,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        _adjustTrove(collateralToken, account, 0, 0, _collWithdrawal, 0, false, _upperHint, _lowerHint);\n    }\n\n    // Withdraw Debt tokens from a trove: mint new Debt tokens to the owner, and increase the trove's debt accordingly\n    function withdrawDebt(\n        IERC20 collateralToken,\n        address account,\n        uint256 _maxFeePercentage,\n        uint256 _debtAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        require(!PRISMA_CORE.paused(), \"Withdrawals are paused\");\n        _adjustTrove(collateralToken, account, _maxFeePercentage, 0, 0, _debtAmount, true, _upperHint, _lowerHint);\n    }\n\n    // Repay Debt tokens to a Trove: Burn the repaid Debt tokens, and reduce the trove's debt accordingly\n    function repayDebt(\n        IERC20 collateralToken,\n        address account,\n        uint256 _debtAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        _adjustTrove(collateralToken, account, 0, 0, 0, _debtAmount, false, _upperHint, _lowerHint);\n    }\n\n    function adjustTrove(\n        IERC20 collateralToken,\n        address account,\n        uint256 _maxFeePercentage,\n        uint256 _collDeposit,\n        uint256 _collWithdrawal,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        require((_collDeposit == 0 && !_isDebtIncrease) || !PRISMA_CORE.paused(), \"Trove adjustments are paused\");\n        require(_collDeposit == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n        _adjustTrove(\n            collateralToken,\n            account,\n            _maxFeePercentage,\n            _collDeposit,\n            _collWithdrawal,\n            _debtChange,\n            _isDebtIncrease,\n            _upperHint,\n            _lowerHint\n        );\n    }\n\n    function _adjustTrove(\n        IERC20 collateralToken,\n        address account,\n        uint256 _maxFeePercentage,\n        uint256 _collDeposit,\n        uint256 _collWithdrawal,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    ) internal {\n        require(\n            _collDeposit != 0 || _collWithdrawal != 0 || _debtChange != 0,\n            \"BorrowerOps: There must be either a collateral change or a debt change\"\n        );\n\n        (ITroveManager troveManager, uint256 index) = _getTroveManagerAndIndex(collateralToken);\n        LocalVariables_adjustTrove memory vars;\n\n        bool isRecoveryMode;\n        uint256 totalPricedCollateral;\n        uint256 totalDebt;\n        (vars.price, totalPricedCollateral, totalDebt, isRecoveryMode) = _getTCRData(index);\n\n        (vars.coll, vars.debt) = troveManager.applyPendingRewards(account);\n\n        // Get the collChange based on whether or not collateral was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(_collDeposit, _collWithdrawal);\n        vars.netDebtChange = _debtChange;\n        vars.debtChange = _debtChange;\n        vars.isDebtIncrease = _isDebtIncrease;\n\n        if (_isDebtIncrease) {\n            require(_debtChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n            _requireValidMaxFeePercentage(_maxFeePercentage);\n            if (!isRecoveryMode) {\n                // If the adjustment incorporates a debt increase and system is in Normal Mode, trigger a borrowing fee\n                vars.netDebtChange += _triggerBorrowingFee(troveManager, msg.sender, _maxFeePercentage, _debtChange);\n            }\n        }\n\n        // Calculate old and new ICRs and check if adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            totalPricedCollateral,\n            totalDebt,\n            isRecoveryMode,\n            _collWithdrawal,\n            _isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough Debt\n        if (!_isDebtIncrease && _debtChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt) - vars.netDebtChange);\n        }\n\n        // If we are incrasing collateral, send tokens to the trove manager prior to adjusting the trove\n        if (vars.isCollIncrease) collateralToken.transferFrom(msg.sender, address(troveManager), vars.collChange);\n\n        (vars.newColl, vars.newDebt, vars.stake) = troveManager.updateTroveFromAdjustment(\n            account,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.debtChange,\n            _isDebtIncrease,\n            vars.netDebtChange,\n            _upperHint,\n            _lowerHint,\n            msg.sender\n        );\n\n        emit TroveUpdated(account, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n    }\n\n    function closeTrove(IERC20 collateralToken, address account) external callerOrDelegated(account) {\n        (ITroveManager troveManager, uint256 index) = _getTroveManagerAndIndex(collateralToken);\n\n        uint256 price;\n        bool isRecoveryMode;\n        uint256 totalPricedCollateral;\n        uint256 totalDebt;\n        (price, totalPricedCollateral, totalDebt, isRecoveryMode) = _getTCRData(index);\n\n        require(!isRecoveryMode, \"BorrowerOps: Operation not permitted during Recovery Mode\");\n\n        (uint256 coll, uint256 debt) = troveManager.applyPendingRewards(account);\n\n        uint256 newTCR = _getNewTCRFromTroveChange(totalPricedCollateral, totalDebt, coll * price, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManager.closeTrove(account, coll, debt);\n\n        emit TroveUpdated(account, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid Debt from the user's balance and the gas compensation from the Gas Pool\n        debtToken.burnWithGasCompensation(msg.sender, debt - DEBT_GAS_COMPENSATION);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        address _caller,\n        uint256 _maxFeePercentage,\n        uint256 _debtAmount\n    ) internal returns (uint256) {\n        uint256 debtFee = _troveManager.decayBaseRateAndGetBorrowingFee(_debtAmount);\n\n        _requireUserAcceptsFee(debtFee, _debtAmount, _maxFeePercentage);\n\n        debtToken.mint(PRISMA_CORE.feeReceiver(), debtFee);\n\n        emit BorrowingFeePaid(_caller, debtFee);\n\n        return debtFee;\n    }\n\n    function _getCollChange(\n        uint256 _collReceived,\n        uint256 _requestedCollWithdrawal\n    ) internal pure returns (uint256 collChange, bool isCollIncrease) {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        uint256 totalPricedCollateral,\n        uint256 totalDebt,\n        bool _isRecoveryMode,\n        uint256 _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal pure {\n        /*\n         *In Recovery Mode, only allow:\n         *\n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n         *\n         * In Normal Mode, ensure:\n         *\n         * - The new ICR is above MCR\n         * - The adjustment won't pull the TCR below CCR\n         */\n\n        // Get the trove's old ICR before the adjustment\n        uint256 oldICR = PrismaMath._computeCR(_vars.coll, _vars.debt, _vars.price);\n\n        // Get the trove's new ICR after the adjustment\n        uint256 newICR = _getNewICRFromTroveChange(\n            _vars.coll,\n            _vars.debt,\n            _vars.collChange,\n            _vars.isCollIncrease,\n            _vars.netDebtChange,\n            _isDebtIncrease,\n            _vars.price\n        );\n\n        if (_isRecoveryMode) {\n            require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(newICR);\n                _requireNewICRisAboveOldICR(newICR, oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(newICR);\n            uint256 newTCR = _getNewTCRFromTroveChange(\n                totalPricedCollateral,\n                totalDebt,\n                _vars.collChange * _vars.price,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal view {\n        require(_netDebt >= minNetDebt, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal pure {\n        require(_maxFeePercentage <= DECIMAL_PRECISION, \"Max fee percentage must less than or equal to 100%\");\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _price\n    ) internal pure returns (uint256) {\n        (uint256 newColl, uint256 newDebt) = _getNewTroveAmounts(\n            _coll,\n            _debt,\n            _collChange,\n            _isCollIncrease,\n            _debtChange,\n            _isDebtIncrease\n        );\n\n        uint256 newICR = PrismaMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256, uint256) {\n        uint256 newColl = _coll;\n        uint256 newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll + _collChange : _coll - _collChange;\n        newDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 totalColl,\n        uint256 totalDebt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        totalDebt = _isDebtIncrease ? totalDebt + _debtChange : totalDebt - _debtChange;\n        totalColl = _isCollIncrease ? totalColl + _collChange : totalColl - _collChange;\n\n        uint256 newTCR = PrismaMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n\n    function _getTroveManagerAndIndex(\n        IERC20 collateralToken\n    ) internal view returns (ITroveManager troveManager, uint256 index) {\n        TrovesContracts storage t = _trovesContracts[collateralToken];\n        (troveManager, index) = (t.troveManager, t.index);\n\n        require(address(troveManager) != address(0), \"Collateral not enabled\");\n\n        return (troveManager, index);\n    }\n\n    function _getTCRData(\n        uint256 index\n    ) internal returns (uint256 price, uint256 totalPricedCollateral, uint256 totalDebt, bool isRecoveryMode) {\n        uint256 amount;\n        SystemBalances memory balances = fetchBalances();\n        (amount, totalPricedCollateral, totalDebt) = getTCR(balances);\n        isRecoveryMode = checkRecoveryMode(amount);\n\n        return (balances.prices[index], totalPricedCollateral, totalDebt, isRecoveryMode);\n    }\n\n    function getGlobalSystemBalances() external returns (uint256 totalPricedCollateral, uint256 totalDebt) {\n        SystemBalances memory balances = fetchBalances();\n        (, totalPricedCollateral, totalDebt) = getTCR(balances);\n    }\n}"
    }
  ]
}