{
  "Title": "[M-01] Freezed Chain will never be unfreeze since `StateTransitionManager::unfreezeChain` is calling `freezeDiamond` instead of `unfreezeDiamond`",
  "Content": "\n`StateTransitionManager::unfreezeChain` function is meant for unfreeze the freezed chain of passed `_chainId` param. While `freezeChain` function is meant for freeze the chain according to passed \\_chainId. But `freezeChain` and `unfreezeChain` both functions are calling same function `freezeDiamond` by same line `IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond()` by mistake. So both these function will only freeze the chain.\n\nAlso there is no other function inside `StateTransitionManager.sol` contract which is calling `unfreezeDiamond`. `unfreezeDiamond` is function defined in `Admin.sol` where the call is going since `IZkSyncStateTransition` also inherits IAdmin which have freezeDiamond and unfreezeDiamond both functions. But `unfreezeDiamond` is not called from `unfreezeChain` function. So freezed chain will never be unfreeze.\n\n`unfreezeChain` also have wrong comment instead of writing unfreezes it writes freezes.\nIt seems like dev just copy pasted without doing required changes.\n\n### Vulnerable Code\n\n[code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L165-L167](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L165C4-L167C6)\n\n```solidity\n\n159:    /// @dev freezes the specified chain\n160:    function freezeChain(uint256 _chainId) external onlyOwner {\n161:        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n     }\n\n164:    /// @dev freezes the specified chain\n165:    function unfreezeChain(uint256 _chainId) external onlyOwner {\n166:        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();//@audit `freezeDiamond` called instead of `unfreezeDiamond`\n\n    }\n\n```\n\n(<https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-interfaces/IZkSyncStateTransition.sol#L15>)\n\n[IZkSyncStateTransition is inheriting IAdmin](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-interfaces/IZkSyncStateTransition.sol#L15) and by IZkSyncStateTransition wrapping instance is prepared to call freezeDiamond.\n\n```solidity\n15: interface IZkSyncStateTransition is IAdmin, IExecutor, IGetters, IMailbox {\n```\n\n[IAdmin interfaces have both functions](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-interfaces/IAdmin.sol#L52C5-L58C41)\n\n```solidity\n13:  interface IAdmin is IZkSyncStateTransitionBase {\n\n    ....\n\n52:  /// @notice Instantly pause the functionality of all freezable facets & their selectors\n     /// @dev Only the governance mechanism may freeze Diamond Proxy\n54:    function freezeDiamond() external;\n\n     /// @notice Unpause the functionality of all freezable facets & their selectors\n     /// @dev Both the admin and the STM can unfreeze Diamond Proxy\n58:    function unfreezeDiamond() external;\n\n```\n\nIt shows that by mistake unfreezeChain is calling freezeDiamond instaed of unfreezeDiamond which should be used to unfreeze the chain.\n\n### Impact\n\nFreezed chain will never be unfreeze.\nSince `freezeChain` and `unfreezeChain` both functions are calling same function `freezeDiamond` which is used to freeze the chain. And `unfreezeDiamond` no where called which should is made for unfreeze the freezed chain.\n\n### Recommended Mitigation\n\nIn `StateTransitionManager::unfreezeChain` function call `unfreezeDiamond` instead of `freezeDiamond` on `IZkSyncStateTransition(stateTransition[_chainId])` instance.\n\n```diff\nFile:  code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol\n- 164:    /// @dev freezes the specified chain\n+ 164:    /// @dev unfreezes the specified chain\n165:    function unfreezeChain(uint256 _chainId) external onlyOwner {\n- 166:        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n+ 166:        IZkSyncStateTransition(stateTransition[_chainId]).unfreezeDiamond();\n          }\n```\n\n**[0xsomeone (judge) increased severity to High](https://github.com/code-423n4/2024-03-zksync-findings/issues/97#issuecomment-2032589179)**\n\n**[saxenism (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/97#issuecomment-2036801296):**\n > This is a good finding, but we consider this a `medium` severity issue because in the current codebase `admin` could also unfreeze (so no permanent freeze & so not high), but in the future we might wanna change this mechanism.\n\n**[0xsomeone (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/97#issuecomment-2082815615):**\n > The submission and its relevant duplicates have identified a mistype in the codebase that causes certain functionality that is expected to be accessible to behave oppositely.\n> \n> The exhibit represents an actual error in the code resulting in functionality missing, however, the functionality does contain an alternative access path per the Sponsor's statement and as such I consider this exhibit to be of medium risk.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Diamond} from \"./libraries/Diamond.sol\";\nimport {DiamondProxy} from \"./chain-deps/DiamondProxy.sol\";\nimport {IAdmin} from \"./chain-interfaces/IAdmin.sol\";\nimport {IDefaultUpgrade} from \"../upgrades/IDefaultUpgrade.sol\";\nimport {IDiamondInit} from \"./chain-interfaces/IDiamondInit.sol\";\nimport {IExecutor} from \"./chain-interfaces/IExecutor.sol\";\nimport {IStateTransitionManager, StateTransitionManagerInitializeData} from \"./IStateTransitionManager.sol\";\nimport {ISystemContext} from \"./l2-deps/ISystemContext.sol\";\nimport {IZkSyncStateTransition} from \"./chain-interfaces/IZkSyncStateTransition.sol\";\nimport {L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR, L2_FORCE_DEPLOYER_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {ProposedUpgrade} from \"../upgrades/BaseZkSyncUpgrade.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA, L2_TO_L1_LOG_SERIALIZE_SIZE, DEFAULT_L2_LOGS_TREE_ROOT_HASH, EMPTY_STRING_KECCAK, SYSTEM_UPGRADE_L2_TX_TYPE, ERA_DIAMOND_PROXY, ERA_CHAIN_ID} from \"../common/Config.sol\";\nimport {VerifierParams} from \"./chain-interfaces/IVerifier.sol\";\n\n/// @title StateTransition contract\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract StateTransitionManager is IStateTransitionManager, ReentrancyGuard, Ownable2Step {\n    /// @notice Address of the bridgehub\n    address public immutable bridgehub;\n\n    /// @notice chainId => chainContract\n    mapping(uint256 => address) public stateTransition;\n\n    /// @dev Batch hash zero, calculated at initialization\n    bytes32 public storedBatchZero;\n\n    /// @dev Stored cutData for diamond cut\n    bytes32 public initialCutHash;\n\n    /// @dev genesisUpgrade contract address, used to setChainId\n    address public genesisUpgrade;\n\n    /// @dev current protocolVersion\n    uint256 public protocolVersion;\n\n    /// @dev validatorTimelock contract address, used to setChainId\n    address public validatorTimelock;\n\n    /// @dev Stored cutData for upgrade diamond cut. protocolVersion => cutHash\n    mapping(uint256 => bytes32) public upgradeCutHash;\n\n    /// @dev used to manage non critical updates\n    address public admin;\n\n    /// @dev used to accept the admin role\n    address private pendingAdmin;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(address _bridgehub) reentrancyGuardInitializer {\n        bridgehub = _bridgehub;\n    }\n\n    /// @notice only the bridgehub can call\n    modifier onlyBridgehub() {\n        require(msg.sender == bridgehub, \"StateTransition: only bridgehub\");\n        _;\n    }\n\n    /// @notice the admin can call, for non-critical updates\n    modifier onlyOwnerOrAdmin() {\n        require(msg.sender == admin || msg.sender == owner(), \"Bridgehub: not owner or admin\");\n        _;\n    }\n\n    function getChainAdmin(uint256 _chainId) external view override returns (address) {\n        return IZkSyncStateTransition(stateTransition[_chainId]).getAdmin();\n    }\n\n    /// @dev initialize\n    function initialize(\n        StateTransitionManagerInitializeData calldata _initializeData\n    ) external reentrancyGuardInitializer {\n        require(_initializeData.governor != address(0), \"StateTransition: governor zero\");\n        _transferOwnership(_initializeData.governor);\n\n        genesisUpgrade = _initializeData.genesisUpgrade;\n        protocolVersion = _initializeData.protocolVersion;\n        validatorTimelock = _initializeData.validatorTimelock;\n\n        // We need to initialize the state hash because it is used in the commitment of the next batch\n        IExecutor.StoredBatchInfo memory batchZero = IExecutor.StoredBatchInfo(\n            0,\n            _initializeData.genesisBatchHash,\n            _initializeData.genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _initializeData.genesisBatchCommitment\n        );\n        storedBatchZero = keccak256(abi.encode(batchZero));\n\n        initialCutHash = keccak256(abi.encode(_initializeData.diamondCut));\n\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = pendingAdmin;\n        // Change pending admin\n        pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function acceptAdmin() external {\n        address currentPendingAdmin = pendingAdmin;\n        require(msg.sender == currentPendingAdmin, \"n42\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = admin;\n        admin = currentPendingAdmin;\n        delete pendingAdmin;\n\n        emit NewPendingAdmin(currentPendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @dev set validatorTimelock. Cannot do it an initialization, as validatorTimelock is deployed after STM\n    function setValidatorTimelock(address _validatorTimelock) external onlyOwnerOrAdmin {\n        validatorTimelock = _validatorTimelock;\n    }\n\n    /// @dev set initial cutHash\n    function setInitialCutHash(Diamond.DiamondCutData calldata _diamondCut) external onlyOwner {\n        initialCutHash = keccak256(abi.encode(_diamondCut));\n    }\n\n    /// @dev set New Version with upgrade from old version\n    function setNewVersionUpgrade(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion,\n        uint256 _newProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n        protocolVersion = _newProtocolVersion;\n    }\n\n    /// @dev set upgrade for some protocolVersion\n    function setUpgradeDiamondCut(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n    }\n\n    /// @dev freezes the specified chain\n    function freezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev freezes the specified chain\n    function unfreezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev reverts batches on the specified chain\n    function revertBatches(uint256 _chainId, uint256 _newLastBatch) external onlyOwnerOrAdmin {\n        IZkSyncStateTransition(stateTransition[_chainId]).revertBatches(_newLastBatch);\n    }\n\n    /// registration\n\n    /// @dev we have to set the chainId at genesis, as blockhashzero is the same for all chains with the same chainId\n    function _setChainIdUpgrade(uint256 _chainId, address _chainContract) internal {\n        bytes memory systemContextCalldata = abi.encodeCall(ISystemContext.setChainId, (_chainId));\n        uint256[] memory uintEmptyArray;\n        bytes[] memory bytesEmptyArray;\n\n        L2CanonicalTransaction memory l2ProtocolUpgradeTx = L2CanonicalTransaction({\n            txType: SYSTEM_UPGRADE_L2_TX_TYPE,\n            from: uint256(uint160(L2_FORCE_DEPLOYER_ADDR)),\n            to: uint256(uint160(L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR)),\n            gasLimit: $(PRIORITY_TX_MAX_GAS_LIMIT),\n            gasPerPubdataByteLimit: REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            maxFeePerGas: uint256(0),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: protocolVersion,\n            value: 0,\n            reserved: [uint256(0), 0, 0, 0],\n            data: systemContextCalldata,\n            signature: new bytes(0),\n            factoryDeps: uintEmptyArray,\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n\n        ProposedUpgrade memory proposedUpgrade = ProposedUpgrade({\n            l2ProtocolUpgradeTx: l2ProtocolUpgradeTx,\n            factoryDeps: bytesEmptyArray,\n            bootloaderHash: bytes32(0),\n            defaultAccountHash: bytes32(0),\n            verifier: address(0),\n            verifierParams: VerifierParams({\n                recursionNodeLevelVkHash: bytes32(0),\n                recursionLeafLevelVkHash: bytes32(0),\n                recursionCircuitsSetVksHash: bytes32(0)\n            }),\n            l1ContractsUpgradeCalldata: new bytes(0),\n            postUpgradeCalldata: new bytes(0),\n            upgradeTimestamp: 0,\n            newProtocolVersion: protocolVersion\n        });\n\n        Diamond.FacetCut[] memory emptyArray;\n        Diamond.DiamondCutData memory cutData = Diamond.DiamondCutData({\n            facetCuts: emptyArray,\n            initAddress: genesisUpgrade,\n            initCalldata: abi.encodeCall(IDefaultUpgrade.upgrade, (proposedUpgrade))\n        });\n\n        IAdmin(_chainContract).executeUpgrade(cutData);\n        emit SetChainIdUpgrade(_chainContract, l2ProtocolUpgradeTx, protocolVersion);\n    }\n\n    function registerAlreadyDeployedStateTransition(\n        uint256 _chainId,\n        address _stateTransitionContract\n    ) external onlyOwner {\n        stateTransition[_chainId] = _stateTransitionContract;\n        emit StateTransitionNewChain(_chainId, _stateTransitionContract);\n    }\n\n    /// @notice called by Bridgehub when a chain registers\n    function createNewChain(\n        uint256 _chainId,\n        address _baseToken,\n        address _sharedBridge,\n        address _admin,\n        bytes calldata _diamondCut\n    ) external onlyBridgehub {\n        if (stateTransition[_chainId] != address(0)) {\n            // StateTransition chain already registered\n            return;\n        }\n\n        // check not registered\n        Diamond.DiamondCutData memory diamondCut = abi.decode(_diamondCut, (Diamond.DiamondCutData));\n\n        // check input\n        bytes32 cutHashInput = keccak256(_diamondCut);\n        require(cutHashInput == initialCutHash, \"StateTransition: initial cutHash mismatch\");\n\n        // construct init data\n        bytes memory initData;\n        /// all together 4+9*32=292 bytes\n        initData = bytes.concat(\n            IDiamondInit.initialize.selector,\n            bytes32(_chainId),\n            bytes32(uint256(uint160(bridgehub))),\n            bytes32(uint256(uint160(address(this)))),\n            bytes32(uint256(protocolVersion)),\n            bytes32(uint256(uint160(_admin))),\n            bytes32(uint256(uint160(validatorTimelock))),\n            bytes32(uint256(uint160(_baseToken))),\n            bytes32(uint256(uint160(_sharedBridge))),\n            bytes32(storedBatchZero),\n            diamondCut.initCalldata\n        );\n\n        diamondCut.initCalldata = initData;\n        // deploy stateTransitionContract\n        DiamondProxy stateTransitionContract = new DiamondProxy{salt: bytes32(0)}(block.chainid, diamondCut);\n\n        // save data\n        address stateTransitionAddress = address(stateTransitionContract);\n\n        stateTransition[_chainId] = stateTransitionAddress;\n\n        // set chainId in VM\n        _setChainIdUpgrade(_chainId, stateTransitionAddress);\n\n        emit StateTransitionNewChain(_chainId, stateTransitionAddress);\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-interfaces/IZkSyncStateTransition.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IAdmin} from \"./IAdmin.sol\";\nimport {IExecutor} from \"./IExecutor.sol\";\nimport {IGetters} from \"./IGetters.sol\";\nimport {IMailbox} from \"./IMailbox.sol\";\nimport {Verifier} from \"../Verifier.sol\";\nimport {VerifierParams} from \"./IVerifier.sol\";\n\n// kl to do remove this, needed for the server for now\nimport \"../libraries/Diamond.sol\";\n\ninterface IZkSyncStateTransition is IAdmin, IExecutor, IGetters, IMailbox {\n    // KL todo: need this in the server for now\n    event ProposeTransparentUpgrade(\n        Diamond.DiamondCutData diamondCut,\n        uint256 indexed proposalId,\n        bytes32 proposalSalt\n    );\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-interfaces/IZkSyncStateTransition.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IAdmin} from \"./IAdmin.sol\";\nimport {IExecutor} from \"./IExecutor.sol\";\nimport {IGetters} from \"./IGetters.sol\";\nimport {IMailbox} from \"./IMailbox.sol\";\nimport {Verifier} from \"../Verifier.sol\";\nimport {VerifierParams} from \"./IVerifier.sol\";\n\n// kl to do remove this, needed for the server for now\nimport \"../libraries/Diamond.sol\";\n\ninterface IZkSyncStateTransition is IAdmin, IExecutor, IGetters, IMailbox {\n    // KL todo: need this in the server for now\n    event ProposeTransparentUpgrade(\n        Diamond.DiamondCutData diamondCut,\n        uint256 indexed proposalId,\n        bytes32 proposalSalt\n    );\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-interfaces/IAdmin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IZkSyncStateTransitionBase} from \"../chain-interfaces/IZkSyncStateTransitionBase.sol\";\n\nimport {Diamond} from \"../libraries/Diamond.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../chain-deps/ZkSyncStateTransitionStorage.sol\";\n\n/// @title The interface of the Admin Contract that controls access rights for contract management.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IAdmin is IZkSyncStateTransitionBase {\n    /// @notice Starts the transfer of admin rights. Only the current admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external;\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external;\n\n    /// @notice Change validator status (active or not active)\n    /// @param _validator Validator address\n    /// @param _active Active flag\n    function setValidator(address _validator, bool _active) external;\n\n    /// @notice Change zk porter availability\n    /// @param _zkPorterIsAvailable The availability of zk porter shard\n    function setPorterAvailability(bool _zkPorterIsAvailable) external;\n\n    /// @notice Change the max L2 gas limit for L1 -> L2 transactions\n    /// @param _newPriorityTxMaxGasLimit The maximum number of L2 gas that a user can request for L1 -> L2 transactions\n    function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external;\n\n    /// @notice Change the fee params for L1->L2 transactions\n    /// @param _newFeeParams The new fee params\n    function changeFeeParams(FeeParams calldata _newFeeParams) external;\n\n    /// @notice Change the token multiplier for L1->L2 transactions\n    function setTokenMultiplier(uint128 _nominator, uint128 _denominator) external;\n\n    /// @notice Used to set to validium directly after genesis\n    function setValidiumMode(PubdataPricingMode _validiumMode) external;\n\n    function upgradeChainFromVersion(uint256 _protocolVersion, Diamond.DiamondCutData calldata _cutData) external;\n\n    /// @notice Executes a proposed governor upgrade\n    /// @dev Only the current admin can execute the upgrade\n    /// @param _diamondCut The diamond cut parameters to be executed\n    function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut) external;\n\n    /// @notice Instantly pause the functionality of all freezable facets & their selectors\n    /// @dev Only the governance mechanism may freeze Diamond Proxy\n    function freezeDiamond() external;\n\n    /// @notice Unpause the functionality of all freezable facets & their selectors\n    /// @dev Both the admin and the STM can unfreeze Diamond Proxy\n    function unfreezeDiamond() external;\n\n    /// @notice Porter availability status changes\n    event IsPorterAvailableStatusUpdate(bool isPorterAvailable);\n\n    /// @notice Validator's status changed\n    event ValidatorStatusUpdate(address indexed validatorAddress, bool isActive);\n\n    /// @notice pendingAdmin is changed\n    /// @dev Also emitted when new admin is accepted and in this case, `newPendingAdmin` would be zero address\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Admin changed\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Priority transaction max L2 gas limit changed\n    event NewPriorityTxMaxGasLimit(uint256 oldPriorityTxMaxGasLimit, uint256 newPriorityTxMaxGasLimit);\n\n    /// @notice Fee params for L1->L2 transactions changed\n    event NewFeeParams(FeeParams oldFeeParams, FeeParams newFeeParams);\n\n    /// @notice Validium mode status changed\n    event ValidiumModeStatusUpdate(PubdataPricingMode validiumMode);\n\n    /// @notice BaseToken multiplier for L1->L2 transactions changed\n    event NewBaseTokenMultiplier(\n        uint128 oldNominator,\n        uint128 oldDenominator,\n        uint128 newNominator,\n        uint128 newDenominator\n    );\n\n    /// @notice Emitted when an upgrade is executed.\n    event ExecuteUpgrade(Diamond.DiamondCutData diamondCut);\n\n    /// @notice Emitted when the contract is frozen.\n    event Freeze();\n\n    /// @notice Emitted when the contract is unfrozen.\n    event Unfreeze();\n}"
    }
  ]
}