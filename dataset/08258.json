{
  "Title": "[M-01] Vault rebalancing can be exploited if two vaults rebalance into the same vault",
  "Content": "_Submitted by 0x52, also found by ayeslick_\n\nUser funds stolen.\n\n### Proof of Concept\n\nSwap data is completely arbitrary and can be used to swap though malicious ERC20 tokens allowing control transfer. This control transfer would allow the attacker to call rebalance on a second vault and exploit both as long as both vaults rebalance into the same vault.\n\nAssumptions:<br>\nVault A and C both rebalance into vault B (i.e. value is transferred from vault A and C to vault B)<br>\nVault A and C are both eligible for rebalances<br>\n\nVault A -<br>\nValue: $100<br>\nFlashloan value: 50<br>\n\nVault B -<br>\nValue: $100<br>\n\nVault C -<br>\nValue: $100<br>\nFlashloan value: 50<br>\n\n1.  User calls rebalance on vault A to trigger it rebalancing to vault B, storing vault B's value as $100\n\n2.  During the swap control is transferred due to use of malicious ERC20 specified in swap data\n\n3.  Malicious token calls rebalance on vault C to trigger a rebalancing to vault B, storing vault B's value as $100 because Vault B's value hasn't been modified yet.\n\n4.  Swap data in vault C rebalance swaps flashloan C to $50 worth of asset B\n\n5.  Vault C rebalance deposits swap funds into vault B\n\n6.  Vault C rebalance withdraws from vault C to pay back flashloan C\n\n7.  Vault C rebalance validates that the value of B = $150 ( 100 + 50 ) and finishes, resuming Vault A rebalance\n\n8.  Vault A rebalance finishes its swap, siphoning off the swapped funds to attacker through the malicious pool\n\n9.  Vault A rebalance doesn't deposit any funds but the value of vault B has already been increased by rebalance C\n\n10. Vault A rebalance withdraws from vault A to pay back vault flashloan A\n\n11. Vault A rebalance validates that the value of B = $150 ( 100 + 50 )\n\nThe attacker has now stolen funds, up to half the value of the total rebalance amount.\n\n### Recommended Mitigation Steps\n\nAdd nonReentrant modifier to MIMOAutomatedRebalnce.sol#rebalance.\n\n**[RayXpub (Mimo) disagreed with severity and commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/39#issuecomment-1210505384):**\n > The attack described seems to be missing some elements mainly on item 9. Rebalance can't choose to just not deposit as it calls `depositAndBorrow()` with a `mintAmount` computed onchain through the `_getAmounts()` function so it will have to mint some amount. This might be possible if the additional minting requirement by the second rebalance repayment can happen within the limits of vault B MCR. This seems to be an edge case and a complex attack, as it would require 2 vaults under trigger ratio, a malicious pool with enough liquidity and a user set mcr buffer high enough to not require additional deposit on second rebalance.\n> \n> Given the complexity and the low probability of this attack we think it should be downgraded to medium risk. We do plan on applying the recommendation of adding nonReentrant modifier.\n\n**[gzeoneth (judge) decreased severity to Medium](https://github.com/code-423n4/2022-08-mimo-findings/issues/39)** \n\n**horsefacts (warden) reviewed mitigation:**\n> **Status:** âœ… Resolved\n\n> **Finding:** Wardens identified that `MIMOAutoRebalance#rebalance` was vulnerable to reentrancy by swapping through a malicious token that transfers control to the caller.\n\n> **What changed:** The Mimo team added a [reentrancy guard](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/contracts/actions/automated/MIMOAutoRebalance.sol#L59) to the `rebalance` function. An [integration test](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/test/02_integration/automated/MIMOAutoActionSecurity.test.ts#L137) demonstrates that the function is protected against reentrancy.\n\n> **Why it works:** Since `rebalance` is protected by a reentrancy guard, attempts to reenter `rebalance` will now revert.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
  "Code": [
    {
      "filename": "contracts/actions/automated/MIMOAutoRebalance.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol\";\n\nimport \"./MIMOAutoAction.sol\";\nimport \"./interfaces/IMIMOAutoRebalance.sol\";\nimport \"../MIMOFlashLoan.sol\";\nimport \"../MIMOPausable.sol\";\nimport \"../interfaces/IMIMORebalance.sol\";\nimport { Errors } from \"../../libraries/Errors.sol\";\n\n/**\n  Rebalance value is calculated by the formula below :\n\n                     targetRatio * (vaultDebt + fixedFee) - collateralValue\n-----------------------------------------------------------------------------------------------------\n        targetRatio - (mcrb + mcrBuffer) * premium\n     ----------------------------------------------------  - targetRatio * varFee    -  WAD\n               (mcrB + mcrBuffer) \n */\n\ncontract MIMOAutoRebalance is MIMOPausable, MIMOAutoAction, MIMOFlashLoan, ReentrancyGuard, IMIMOAutoRebalance {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  uint256 public constant ROUNDING_BUFFER = 1e15; // Padding for difference between accumulated debt since refresh \n  uint256 public constant FLASHLOAN_PERCENTAGE_FACTOR = 1e4; // The divisor needed to convert the flashloan fee int into a ratio\n\n  address public immutable mimoRebalance;\n\n  constructor(\n    IAddressProvider _a,\n    IPool _lendingPool,\n    IMIMOProxyFactory _proxyFactory,\n    address _mimoRebalance\n  ) MIMOAutoAction(_a, _proxyFactory) MIMOFlashLoan(_lendingPool) {\n    if (_mimoRebalance == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    mimoRebalance = _mimoRebalance;\n  }\n\n  /**\n    @notice Perform a rebalance on a vault on behalf of vault owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Reverts if operation results in vault value change above allowed variation or in vault ratio lower than min \n    ratio\n    @param vaultId Vault id of the vault to rebalance\n    @param swapData SwapData struct containing aggegator swap parameters\n   */\n  function rebalance(uint256 vaultId, IMIMOSwap.SwapData calldata swapData)\n    external\n    override\n    whenNotPaused\n    nonReentrant\n  {\n    AutomatedVault memory autoVault = _automatedVaults[vaultId];\n\n    (uint256 vaultARatioBefore, VaultState memory vaultAState) = _getVaultStats(vaultId);\n    _preRebalanceChecks(autoVault, vaultId, vaultARatioBefore);\n\n    IVaultsDataProvider vaultsData = a.vaultsData();\n    address vaultOwner = vaultsData.vaultOwner(vaultId);\n    uint256 vaultBId = vaultsData.vaultId(address(autoVault.toCollateral), vaultOwner);\n    uint256 vaultBBalanceBefore = vaultsData.vaultCollateralBalance(vaultBId);\n    (IMIMORebalance.RebalanceData memory rbData, FlashLoanData memory flData, uint256 autoFee) = _getRebalanceParams(\n      autoVault,\n      vaultAState,\n      IERC20(autoVault.toCollateral),\n      vaultId\n    );\n    _takeFlashLoan(flData, abi.encode(vaultOwner, autoFee, rbData, swapData));\n    _postRebalanceChecks(autoVault, flData.amount, vaultBBalanceBefore, vaultId, vaultOwner, vaultsData);\n\n    _operationTracker[vaultId] = block.timestamp;\n\n    IERC20(a.stablex()).safeTransfer(msg.sender, autoFee);\n  }\n\n  /**\n    @notice Routes a call from a flashloan pool to a leverage or rebalance operation\n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the reblanced asset\n    @param amounts Uint array with one element corresponding to the amount of the rebalanced asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, RebalanceData struct and SwapData struct\n    @return True if success and False if failed\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (\n      address mimoProxy,\n      uint256 managerFee,\n      IMIMORebalance.RebalanceData memory rbData,\n      IMIMOSwap.SwapData memory swapData\n    ) = abi.decode(params, (address, uint256, IMIMORebalance.RebalanceData, IMIMOSwap.SwapData));\n\n    if (initiator != address(this)) {\n      revert Errors.INITIATOR_NOT_AUTHORIZED(initiator, address(this));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert Errors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 fromCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      mimoRebalance,\n      abi.encodeWithSignature(\n        \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n        fromCollateral,\n        amount,\n        flashloanRepayAmount,\n        managerFee,\n        rbData,\n        swapData\n      )\n    );\n\n    fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Getter function returning rebalance amounts for specific vault id\n    @param vaultId Vault id of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @return rebalanceAmount Amount to rebalance\n    @return mintAmount Amount to mint on vault B\n    @return autoFee Automation fee\n   */\n  function getAmounts(uint256 vaultId, address toCollateral)\n    external\n    view\n    override\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    )\n  {\n    (, VaultState memory vaultState) = _getVaultStats(vaultId);\n    return _getAmounts(_automatedVaults[vaultId], vaultState, toCollateral);\n  }\n\n  /**\n    @notice Helper function calculating the amount to rebalance from vault A and to mint from vault B with rebalnce \n    formula\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultState VaultState struct of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @return rebalanceAmount Amount to rebalance\n    @return mintAmount Amount to mint on vault b\n    @return autoFee Automation fee\n   */\n  function _getAmounts(\n    AutomatedVault memory autoVault,\n    VaultState memory vaultState,\n    address toCollateral\n  )\n    internal\n    view\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    )\n  {\n    IAddressProvider _a = a;\n    uint256 targetRatio = autoVault.targetRatio + ROUNDING_BUFFER; // Add padding to account for parDebt accumulated since last refresh;\n    uint256 toVaultTargetMcr = _a.config().collateralMinCollateralRatio(address(toCollateral)) + autoVault.mcrBuffer;\n    uint256 premiumInt = lendingPool.FLASHLOAN_PREMIUM_TOTAL(); // Get premium from lendingPool, in Int \n    uint256 premium = (premiumInt * WadRayMath.WAD) / FLASHLOAN_PERCENTAGE_FACTOR; // Convert premium Int into WAD units\n    uint256 rebalanceValue = (targetRatio.wadMul(vaultState.vaultDebt + autoVault.fixedFee) -\n      vaultState.collateralValue).wadDiv(\n        (targetRatio - toVaultTargetMcr.wadMul(premium)).wadDiv(toVaultTargetMcr) -\n          targetRatio.wadMul(autoVault.varFee) -\n          WadRayMath.WAD\n      );\n    autoFee = autoVault.fixedFee + rebalanceValue.wadMul(autoVault.varFee);\n    rebalanceAmount = _a.priceFeed().convertTo(vaultState.collateralType, rebalanceValue);\n    mintAmount = rebalanceValue.wadDiv(toVaultTargetMcr);\n  }\n\n  /**\n    @notice Helper function formatting FlashloanData and RebalanceData parameters\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultState VaultState struct of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @param vaultId Vault id of the vault to rebalance\n    @return rbData RebalanceData struct\n    @return flData FlashloanData struct\n    @return autoFee Automation fee\n   */\n  function _getRebalanceParams(\n    AutomatedVault memory autoVault,\n    VaultState memory vaultState,\n    IERC20 toCollateral,\n    uint256 vaultId\n  )\n    internal\n    view\n    returns (\n      IMIMORebalance.RebalanceData memory rbData,\n      FlashLoanData memory flData,\n      uint256 autoFee\n    )\n  {\n    (uint256 rebalanceAmount, uint256 mintAmount, uint256 _autoFee) = _getAmounts(\n      autoVault,\n      vaultState,\n      address(toCollateral)\n    );\n    autoFee = _autoFee;\n    rbData = IMIMORebalance.RebalanceData({ toCollateral: toCollateral, vaultId: vaultId, mintAmount: mintAmount });\n    flData = FlashLoanData({ asset: vaultState.collateralType, proxyAction: address(this), amount: rebalanceAmount });\n  }\n\n  /**\n    @notice Helper function performing pre rebalance operation sanity checks\n    @dev Checks that :\n      - Vault is automated\n      - Maximum daily operations has not been exceeded\n      - Vault is below the trigger ratio\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultARatio Collateral to debt ratio of the vault to rebalance\n   */\n  function _preRebalanceChecks(\n    AutomatedVault memory autoVault,\n    uint256 vaultId,\n    uint256 vaultARatio\n  ) internal view {\n    if (!autoVault.isAutomated) {\n      revert Errors.VAULT_NOT_AUTOMATED();\n    }\n    if (_operationTracker[vaultId] > block.timestamp - 1 days) {\n      revert Errors.MAX_OPERATIONS_REACHED();\n    }\n    if (vaultARatio > autoVault.triggerRatio) {\n      revert Errors.VAULT_TRIGGER_RATIO_NOT_REACHED(vaultARatio, autoVault.triggerRatio);\n    }\n  }\n\n  /**\n    @notice Helper function performing post rebalance operation sanity checks\n    @dev Checks that :\n     - Rebalance swap slippage is below allowedVaration\n     - Vault ratio is above targetRatio\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param rebalanceAmount Rebalanced amount\n    @param vaultBBalanceBefore Collateral balance of the vault to be rebalanced to before the rebalance operation\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultOwner Rebalanced vault owner\n    @param vaultsData Cached VaultsDataProvider interface for gas saving\n   */\n  function _postRebalanceChecks(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceAmount,\n    uint256 vaultBBalanceBefore,\n    uint256 vaultId,\n    address vaultOwner,\n    IVaultsDataProvider vaultsData\n  ) internal view {\n    IPriceFeed priceFeed = a.priceFeed();\n    address fromCollateral = vaultsData.vaultCollateralType(vaultId);\n    uint256 rebalanceValue = priceFeed.convertFrom(fromCollateral, rebalanceAmount);\n    uint256 vaultBId = vaultsData.vaultId(autoVault.toCollateral, vaultOwner);\n    uint256 vaultBBalanceAfter = vaultsData.vaultCollateralBalance(vaultBId);\n    uint256 swapResultValue = priceFeed.convertFrom(autoVault.toCollateral, vaultBBalanceAfter - vaultBBalanceBefore);\n\n    if (!_isVaultVariationAllowed(autoVault, rebalanceValue, swapResultValue)) {\n      revert Errors.VAULT_VALUE_CHANGE_TOO_HIGH();\n    }\n\n    (uint256 vaultARatio, ) = _getVaultStats(vaultId);\n\n    if (vaultARatio < autoVault.targetRatio) {\n      revert Errors.FINAL_VAULT_RATIO_TOO_LOW(autoVault.targetRatio, vaultARatio);\n    }\n  }\n}"
    }
  ]
}