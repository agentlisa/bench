{
  "Title": "[G-38] Dot notation for struct assignment costs less gas",
  "Content": "\n**File:** `Diamond.sol`\n\nUsing named arguments for struct means that the compiler needs to organize the fields in memory before doing the assignment, which wastes gas. Set each field directly in storage (use dot-notation), or use the unnamed version of the constructor.\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/Diamond.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/Diamond.sol#L218)\n```solidity\n218:         ds.selectorToFacet[_selector] = SelectorToFacet({\n219:             facetAddress: _facet,\n220:             selectorPosition: selectorPosition,\n221:             isFreezable: _isSelectorFreezable\n222:         });\n```\n\nshould be optimized to:\n\n```\nds.selectorToFacet[_selector].facetAddress = _facet;\nds.selectorToFacet[_selector].selectorPosition = selectorPosition;\nds.selectorToFacet[_selector].isFreezable = _isSelectorFreezable;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/libraries/Diamond.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The helper library for managing the EIP-2535 diamond proxy.\nlibrary Diamond {\n    using UncheckedMath for uint256;\n    using SafeCast for uint256;\n\n    /// @dev Magic value that should be returned by diamond cut initialize contracts.\n    /// @dev Used to distinguish calls to contracts that were supposed to be used as diamond initializer from other contracts.\n    bytes32 internal constant DIAMOND_INIT_SUCCESS_RETURN_VALUE =\n        0x33774e659306e47509050e97cb651e731180a42d458212294d30751925c551a2; // keccak256(\"diamond.zksync.init\") - 1\n\n    /// @dev Storage position of `DiamondStorage` structure.\n    bytes32 private constant DIAMOND_STORAGE_POSITION =\n        0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131b; // keccak256(\"diamond.standard.diamond.storage\") - 1;\n\n    event DiamondCut(FacetCut[] facetCuts, address initAddress, bytes initCalldata);\n\n    /// @dev Utility struct that contains associated facet & meta information of selector\n    /// @param facetAddress address of the facet which is connected with selector\n    /// @param selectorPosition index in `FacetToSelectors.selectors` array, where is selector stored\n    /// @param isFreezable denotes whether the selector can be frozen.\n    struct SelectorToFacet {\n        address facetAddress;\n        uint16 selectorPosition;\n        bool isFreezable;\n    }\n\n    /// @dev Utility struct that contains associated selectors & meta information of facet\n    /// @param selectors list of all selectors that belong to the facet\n    /// @param facetPosition index in `DiamondStorage.facets` array, where is facet stored\n    struct FacetToSelectors {\n        bytes4[] selectors;\n        uint16 facetPosition;\n    }\n\n    /// @notice The structure that holds all diamond proxy associated parameters\n    /// @dev According to the EIP-2535 should be stored on a special storage key - `DIAMOND_STORAGE_POSITION`\n    /// @param selectorToFacet A mapping from the selector to the facet address and its meta information\n    /// @param facetToSelectors A mapping from facet address to its selectors with meta information\n    /// @param facets The array of all unique facet addresses that belong to the diamond proxy\n    /// @param isFrozen Denotes whether the diamond proxy is frozen and all freezable facets are not accessible\n    struct DiamondStorage {\n        mapping(bytes4 selector => SelectorToFacet selectorInfo) selectorToFacet;\n        mapping(address facetAddress => FacetToSelectors facetInfo) facetToSelectors;\n        address[] facets;\n        bool isFrozen;\n    }\n\n    /// @dev Parameters for diamond changes that touch one of the facets\n    /// @param facet The address of facet that's affected by the cut\n    /// @param action The action that is made on the facet\n    /// @param isFreezable Denotes whether the facet & all their selectors can be frozen\n    /// @param selectors An array of unique selectors that belongs to the facet address\n    struct FacetCut {\n        address facet;\n        Action action;\n        bool isFreezable;\n        bytes4[] selectors;\n    }\n\n    /// @dev Structure of the diamond proxy changes\n    /// @param facetCuts The set of changes (adding/removing/replacement) of implementation contracts\n    /// @param initAddress The address that's delegate called after setting up new facet changes\n    /// @param initCalldata Calldata for the delegate call to `initAddress`\n    struct DiamondCutData {\n        FacetCut[] facetCuts;\n        address initAddress;\n        bytes initCalldata;\n    }\n\n    /// @dev Type of change over diamond: add/replace/remove facets\n    enum Action {\n        Add,\n        Replace,\n        Remove\n    }\n\n    /// @return diamondStorage The pointer to the storage where all specific diamond proxy parameters stored\n    function getDiamondStorage() internal pure returns (DiamondStorage storage diamondStorage) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            diamondStorage.slot := position\n        }\n    }\n\n    /// @dev Add/replace/remove any number of selectors and optionally execute a function with delegatecall\n    /// @param _diamondCut Diamond's facet changes and the parameters to optional initialization delegatecall\n    function diamondCut(DiamondCutData memory _diamondCut) internal {\n        FacetCut[] memory facetCuts = _diamondCut.facetCuts;\n        address initAddress = _diamondCut.initAddress;\n        bytes memory initCalldata = _diamondCut.initCalldata;\n        uint256 facetCutsLength = facetCuts.length;\n        for (uint256 i = 0; i < facetCutsLength; i = i.uncheckedInc()) {\n            Action action = facetCuts[i].action;\n            address facet = facetCuts[i].facet;\n            bool isFacetFreezable = facetCuts[i].isFreezable;\n            bytes4[] memory selectors = facetCuts[i].selectors;\n\n            require(selectors.length > 0, \"B\"); // no functions for diamond cut\n\n            if (action == Action.Add) {\n                _addFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Replace) {\n                _replaceFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Remove) {\n                _removeFunctions(facet, selectors);\n            } else {\n                revert(\"C\"); // undefined diamond cut action\n            }\n        }\n\n        _initializeDiamondCut(initAddress, initCalldata);\n        emit DiamondCut(facetCuts, initAddress, initCalldata);\n    }\n\n    /// @dev Add new functions to the diamond proxy\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _addFunctions(address _facet, bytes4[] memory _selectors, bool _isFacetFreezable) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Facet with no code cannot be added.\n        // This check also verifies that the facet does not have zero address, since it is the\n        // address with which 0x00000000 selector is associated.\n        require(_facet.code.length > 0, \"G\");\n\n        // Add facet to the list of facets if the facet address is new one\n        _saveFacetIfNew(_facet);\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress == address(0), \"J\"); // facet for this selector already exists\n\n            _addOneFunction(_facet, selector, _isFacetFreezable);\n        }\n    }\n\n    /// @dev Change associated facets to already known function selectors\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _replaceFunctions(address _facet, bytes4[] memory _selectors, bool _isFacetFreezable) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Facet with no code cannot be added.\n        // This check also verifies that the facet does not have zero address, since it is the\n        // address with which 0x00000000 selector is associated.\n        require(_facet.code.length > 0, \"K\");\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress != address(0), \"L\"); // it is impossible to replace the facet with zero address\n\n            _removeOneFunction(oldFacet.facetAddress, selector);\n            // Add facet to the list of facets if the facet address is a new one\n            _saveFacetIfNew(_facet);\n            _addOneFunction(_facet, selector, _isFacetFreezable);\n        }\n    }\n\n    /// @dev Remove association with function and facet\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _removeFunctions(address _facet, bytes4[] memory _selectors) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        require(_facet == address(0), \"a1\"); // facet address must be zero\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress != address(0), \"a2\"); // Can't delete a non-existent facet\n\n            _removeOneFunction(oldFacet.facetAddress, selector);\n        }\n    }\n\n    /// @dev Add address to the list of known facets if it is not on the list yet\n    /// NOTE: should be called ONLY before adding a new selector associated with the address\n    function _saveFacetIfNew(address _facet) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        uint256 selectorsLength = ds.facetToSelectors[_facet].selectors.length;\n        // If there are no selectors associated with facet then save facet as new one\n        if (selectorsLength == 0) {\n            ds.facetToSelectors[_facet].facetPosition = ds.facets.length.toUint16();\n            ds.facets.push(_facet);\n        }\n    }\n\n    /// @dev Add one function to the already known facet\n    /// NOTE: It is expected but NOT enforced that:\n    /// - `_facet` is NON-ZERO address\n    /// - `_facet` is already stored address in `DiamondStorage.facets`\n    /// - `_selector` is NOT associated by another facet\n    function _addOneFunction(address _facet, bytes4 _selector, bool _isSelectorFreezable) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        uint16 selectorPosition = (ds.facetToSelectors[_facet].selectors.length).toUint16();\n\n        // if selectorPosition is nonzero, it means it is not a new facet\n        // so the freezability of the first selector must be matched to _isSelectorFreezable\n        // so all the selectors in a facet will have the same freezability\n        if (selectorPosition != 0) {\n            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\n            require(_isSelectorFreezable == ds.selectorToFacet[selector0].isFreezable, \"J1\");\n        }\n\n        ds.selectorToFacet[_selector] = SelectorToFacet({\n            facetAddress: _facet,\n            selectorPosition: selectorPosition,\n            isFreezable: _isSelectorFreezable\n        });\n        ds.facetToSelectors[_facet].selectors.push(_selector);\n    }\n\n    /// @dev Remove one associated function with facet\n    /// NOTE: It is expected but NOT enforced that `_facet` is NON-ZERO address\n    function _removeOneFunction(address _facet, bytes4 _selector) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Get index of `FacetToSelectors.selectors` of the selector and last element of array\n        uint256 selectorPosition = ds.selectorToFacet[_selector].selectorPosition;\n        uint256 lastSelectorPosition = ds.facetToSelectors[_facet].selectors.length - 1;\n\n        // If the selector is not at the end of the array then move the last element to the selector position\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetToSelectors[_facet].selectors[lastSelectorPosition];\n\n            ds.facetToSelectors[_facet].selectors[selectorPosition] = lastSelector;\n            ds.selectorToFacet[lastSelector].selectorPosition = selectorPosition.toUint16();\n        }\n\n        // Remove last element from the selectors array\n        ds.facetToSelectors[_facet].selectors.pop();\n\n        // Finally, clean up the association with facet\n        delete ds.selectorToFacet[_selector];\n\n        // If there are no selectors for facet then remove the facet from the list of known facets\n        if (lastSelectorPosition == 0) {\n            _removeFacet(_facet);\n        }\n    }\n\n    /// @dev remove facet from the list of known facets\n    /// NOTE: It is expected but NOT enforced that there are no selectors associated with `_facet`\n    function _removeFacet(address _facet) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Get index of `DiamondStorage.facets` of the facet and last element of array\n        uint256 facetPosition = ds.facetToSelectors[_facet].facetPosition;\n        uint256 lastFacetPosition = ds.facets.length - 1;\n\n        // If the facet is not at the end of the array then move the last element to the facet position\n        if (facetPosition != lastFacetPosition) {\n            address lastFacet = ds.facets[lastFacetPosition];\n\n            ds.facets[facetPosition] = lastFacet;\n            ds.facetToSelectors[lastFacet].facetPosition = facetPosition.toUint16();\n        }\n\n        // Remove last element from the facets array\n        ds.facets.pop();\n    }\n\n    /// @dev Delegates call to the initialization address with provided calldata\n    /// @dev Used as a final step of diamond cut to execute the logic of the initialization for changed facets\n    function _initializeDiamondCut(address _init, bytes memory _calldata) private {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"H\"); // Non-empty calldata for zero address\n        } else {\n            // Do not check whether `_init` is a contract since later we check that it returns data.\n            (bool success, bytes memory data) = _init.delegatecall(_calldata);\n            if (!success) {\n                // If the returndata is too small, we still want to produce some meaningful error\n                if (data.length <= 4) {\n                    revert(\"I\"); // delegatecall failed\n                }\n\n                assembly {\n                    revert(add(data, 0x20), mload(data))\n                }\n            }\n\n            // Check that called contract returns magic value to make sure that contract logic\n            // supposed to be used as diamond cut initializer.\n            require(data.length == 32, \"lp\");\n            require(abi.decode(data, (bytes32)) == DIAMOND_INIT_SUCCESS_RETURN_VALUE, \"lp1\");\n        }\n    }\n}"
    }
  ]
}