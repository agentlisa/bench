{
  "Title": "Avoid duplicated code",
  "Content": "Duplicate code makes it harder to understand the code’s intention and thus, auditing the code correctly. It also increases the risk of introducing hidden bugs when modifying one of the copies of some code and not the others.\n\n\nThe logic of the contracts `Token`, `AbstractToken`, and `SafeMath` are very similar to OpenZeppelin library contracts `ERC20Token`, `StandardToken`, and `SafeMath`, respectively. Consider avoiding code repetition, which can bring regression problems and [introduce unexpected bugs](https://medium.com/zeppelin-blog/hackergold-bug-analysis-68d893cad738). Consider using the standard modules from [OpenZeppelin](https://github.com/OpenZeppelin/zeppelin-solidity).\n\n\nAnother instance of duplicated code is [the owner variable of BCAPToken.sol](https://github.com/BCAPtoken/BCAPToken/blob/5cb5e76338cc47343ba9268663a915337c8b268e/sol/BCAPToken.sol#L89). Consider using OpenZeppelin’s `Ownable` as an equivalent. [Checks for owner being the msg.sender](https://github.com/BCAPtoken/BCAPToken/blob/5cb5e76338cc47343ba9268663a915337c8b268e/sol/BCAPToken.sol#L28) are implemented in `Ownable` too, but could also be extracted as a function modifier.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "sol/BCAPToken.sol",
      "content": "/*\n * Blockchain Capital Token Smart Contract.  Copyright © 2017 by ABDK\n * Consulting.\n */\npragma solidity ^0.4.1;\n\nimport \"./StandardToken.sol\";\n\n/**\n * Blockchain Capital Token Smart Contract.\n */\ncontract BCAPToken is StandardToken {\n  /**\n   * Create new Blockchain Capital Token contract with given central bank\n   * address.\n   *\n   * @param _centralBank address of central bank\n   */\n  function BCAPToken (address _centralBank)\n    StandardToken (_centralBank) {\n    owner = _centralBank;\n  }\n\n  /**\n   * Freeze token transfers.\n   */\n  function freezeTransfers () {\n    if (msg.sender != owner) throw;\n\n    if (!transfersFrozen) {\n      transfersFrozen = true;\n      Freeze ();\n    }\n  }\n\n  /**\n   * Unfreeze token transfers.\n   */\n  function unfreezeTransfers () {\n    if (msg.sender != owner) throw;\n\n    if (transfersFrozen) {\n      transfersFrozen = false;\n      Unfreeze ();\n    }\n  }\n\n  /**\n   * Transfer given number of tokens from message sender to given recipient.\n   *\n   * @param _to address to transfer tokens to the owner of\n   * @param _value number of tokens to transfer to the owner of given address\n   * @return true if tokens were transferred successfully, false otherwise\n   */\n  function transfer (address _to, uint256 _value) returns (bool success) {\n    if (transfersFrozen) return false;\n    else return AbstractToken.transfer (_to, _value);\n  }\n\n  /**\n   * Transfer given number of tokens from given owner to given recipient.\n   *\n   * @param _from address to transfer tokens from the owner of\n   * @param _to address to transfer tokens to the owner of\n   * @param _value number of tokens to transfer from given owner to given\n            recipient\n   * @return true if tokens were transferred successfully, false otherwise\n   */\n  function transferFrom (address _from, address _to, uint256 _value)\n  returns (bool success) {\n    if (transfersFrozen) return false;\n    else return AbstractToken.transferFrom (_from, _to, _value);\n  }\n\n  /**\n   * Logged when transfers were frozen.\n   */\n  event Freeze ();\n\n  /**\n   * Logged when transfers were unfrozen.\n   */\n  event Unfreeze ();\n\n  /**\n   * Address of the owner of smart contract.  Only owner is allowed to\n   * freeze/unfreeze transfers.\n   */\n  address owner;\n\n  /**\n   * Whether transfers are currently frozen or not.\n   */\n  bool transfersFrozen = false;\n}"
    }
  ]
}