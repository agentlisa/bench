{
  "Title": "User Can Derive Call to Be on Behalf of the L1ScrollMessenger",
  "Content": "The [`L1ScrollMessenger` contract](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L28) enables users to [send messages](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L100-L118) to L2. To pay for the fees or any value sent with the message, ETH is provided along with the call. Because the [restriction](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L249) only asserts that the value needed is less than or equal to the one sent, the protocol [refunds any overpayment to the `_refundAddress` address](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L271).\n\n\nHowever, the `_refundAddress` address does not have any restrictions. As there are currently many access-controlled functionalities which only allow the `L1ScrollMessenger` contract to interact with them (e.g., [[1]](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/L1MessageQueue.sol#L243) and [[2]](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/gateway/ScrollGatewayBase.sol#L52)), a malicious user might take advantage of the refund process to execute access-controlled functionalities in their `receive` functions. When relaying a message from L2 to L1, a [few checks](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L148-L149) are done to prevent this type of attack.\n\n\nEven though currently there are no implementations at risk, it is always important to reduce the attack surface for future versions of this upgradeable contract. Hence, consider restricting the `_refundAddress` to addresses that do not allow the `L1ScrollMessenger` contract to execute access-controlled functionalities.\n\n\n***Update:** Acknowledged, not resolved. The Scroll team stated:*\n\n\n\n> *We do not think this needs to be fixed at the moment.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/L1ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IScrollChain} from \"./rollup/IScrollChain.sol\";\nimport {IL1MessageQueue} from \"./rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"./IL1ScrollMessenger.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\nimport {AddressAliasHelper} from \"../libraries/common/AddressAliasHelper.sol\";\nimport {WithdrawTrieVerifier} from \"../libraries/verifier/WithdrawTrieVerifier.sol\";\n\n// solhint-disable avoid-low-level-calls\n\n/// @title L1ScrollMessenger\n/// @notice The `L1ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 1 to layer 2;\n/// 2. relay messages from layer 2 layer 1;\n/// 3. replay failed message by replacing the gas limit;\n/// 4. drop expired message due to sequencer problems.\n///\n/// @dev All deposited Ether (including `WETH` deposited throng `L1WETHGateway`) will locked in\n/// this contract.\ncontract L1ScrollMessenger is PausableUpgradeable, ScrollMessengerBase, IL1ScrollMessenger {\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from relay id to relay status.\n    mapping(bytes32 => bool) public isL1MessageRelayed;\n\n    /// @notice Mapping from L1 message hash to sent status.\n    mapping(bytes32 => bool) public isL1MessageSent;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice The address of Rollup contract.\n    address public rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public messageQueue;\n\n    // @note move to ScrollMessengerBase in next big refactor\n    /// @dev The status of for non-reentrant check.\n    uint256 private _lock_status;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_lock_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _lock_status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _lock_status = _NOT_ENTERED;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        PausableUpgradeable.__Pausable_init();\n        ScrollMessengerBase._initialize(_counterpart, _feeVault);\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, tx.origin);\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            \"Message is already in execution\"\n        );\n\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        {\n            address _rollup = rollup;\n            require(IScrollChain(_rollup).isBatchFinalized(_proof.batchIndex), \"Batch is not finalized\");\n            bytes32 _messageRoot = IScrollChain(_rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                \"Invalid proof\"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, \"Forbid to call message queue\");\n        require(_to != address(this), \"Forbid to call self\");\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n\n        bytes32 _relayId = keccak256(abi.encodePacked(_xDomainCalldataHash, msg.sender, block.number));\n        isL1MessageRelayed[_relayId] = true;\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _queueIndex,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` in layer 2 to avoid duplicated execution.\n        // So, only one message will succeed in layer 2. If one of the message is executed successfully, the other one\n        // will revert with \"Message was already successfully executed\".\n        address _messageQueue = messageQueue;\n        address _counterpart = counterpart;\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _queueIndex, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(isL1MessageSent[_xDomainCalldataHash], \"Provided message has not been enqueued\");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, \"Insufficient msg.value for fee\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // enqueue the new transaction\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _newGasLimit, _xDomainCalldata);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        address _messageQueue = messageQueue; // gas saving\n        address _counterpart = counterpart; // gas saving\n\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(_messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(msg.sender, _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, \"Insufficient msg.value\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(!isL1MessageSent[_xDomainCalldataHash], \"Duplicated message\");\n        isL1MessageSent[_xDomainCalldataHash] = true;\n\n        emit SentMessage(msg.sender, _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/L1MessageQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL2GasPriceOracle} from \"./IL2GasPriceOracle.sol\";\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\n\nimport {AddressAliasHelper} from \"../../libraries/common/AddressAliasHelper.sol\";\n\n/// @title L1MessageQueue\n/// @notice This contract will hold all L1 to L2 messages.\n/// Each appended message is assigned with a unique and increasing `uint256` index.\ncontract L1MessageQueue is OwnableUpgradeable, IL1MessageQueue {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates gas oracle contract.\n    /// @param _oldGasOracle The address of old gas oracle contract.\n    /// @param _newGasOracle The address of new gas oracle contract.\n    event UpdateGasOracle(address _oldGasOracle, address _newGasOracle);\n\n    /// @notice Emitted when owner updates EnforcedTxGateway contract.\n    /// @param _oldGateway The address of old EnforcedTxGateway contract.\n    /// @param _newGateway The address of new EnforcedTxGateway contract.\n    event UpdateEnforcedTxGateway(address _oldGateway, address _newGateway);\n\n    /// @notice Emitted when owner updates max gas limit.\n    /// @param _oldMaxGasLimit The old max gas limit.\n    /// @param _newMaxGasLimit The new max gas limit.\n    event UpdateMaxGasLimit(uint256 _oldMaxGasLimit, uint256 _newMaxGasLimit);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ScrollMessenger contract.\n    address public messenger;\n\n    /// @notice The address of ScrollChain contract.\n    address public scrollChain;\n\n    /// @notice The address EnforcedTxGateway contract.\n    address public enforcedTxGateway;\n\n    /// @notice The address of GasOracle contract.\n    address public gasOracle;\n\n    /// @notice The list of queued cross domain messages.\n    bytes32[] public messageQueue;\n\n    /// @inheritdoc IL1MessageQueue\n    uint256 public pendingQueueIndex;\n\n    /// @notice The max gas limit of L1 transactions.\n    uint256 public maxGasLimit;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function initialize(\n        address _messenger,\n        address _scrollChain,\n        address _enforcedTxGateway,\n        address _gasOracle,\n        uint256 _maxGasLimit\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messenger = _messenger;\n        scrollChain = _scrollChain;\n        enforcedTxGateway = _enforcedTxGateway;\n        gasOracle = _gasOracle;\n        maxGasLimit = _maxGasLimit;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1MessageQueue\n    function nextCrossDomainMessageIndex() external view returns (uint256) {\n        return messageQueue.length;\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function getCrossDomainMessage(uint256 _queueIndex) external view returns (bytes32) {\n        return messageQueue[_queueIndex];\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function estimateCrossDomainMessageFee(uint256 _gasLimit) external view override returns (uint256) {\n        address _oracle = gasOracle;\n        if (_oracle == address(0)) return 0;\n        return IL2GasPriceOracle(_oracle).estimateCrossDomainMessageFee(_gasLimit);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function calculateIntrinsicGasFee(bytes memory _calldata) public view override returns (uint256) {\n        address _oracle = gasOracle;\n        if (_oracle == address(0)) return 0;\n        return IL2GasPriceOracle(_oracle).calculateIntrinsicGasFee(_calldata);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function computeTransactionHash(\n        address _sender,\n        uint256 _queueIndex,\n        uint256 _value,\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) public pure override returns (bytes32) {\n        // We use EIP-2718 to encode the L1 message, and the encoding of the message is\n        //      `TransactionType || TransactionPayload`\n        // where\n        //  1. `TransactionType` is 0x7E\n        //  2. `TransactionPayload` is `rlp([queueIndex, gasLimit, to, value, data, sender])`\n        //\n        // The spec of rlp: https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n        uint256 transactionType = 0x7E;\n        bytes32 hash;\n        assembly {\n            function get_uint_bytes(v) -> len {\n                if eq(v, 0) {\n                    len := 1\n                    leave\n                }\n                for {\n\n                } gt(v, 0) {\n\n                } {\n                    len := add(len, 1)\n                    v := shr(8, v)\n                }\n            }\n\n            function store_uint(_ptr, v) -> ptr {\n                ptr := _ptr\n                switch lt(v, 128)\n                case 1 {\n                    // single byte in the [0x00, 0x7f]\n                    mstore(ptr, shl(248, v))\n                    ptr := add(ptr, 1)\n                }\n                default {\n                    // 1-32 bytes long\n                    let len := get_uint_bytes(v)\n                    mstore(ptr, shl(248, add(len, 0x80)))\n                    ptr := add(ptr, 1)\n                    mstore(ptr, shl(mul(8, sub(32, len)), v))\n                    ptr := add(ptr, len)\n                }\n            }\n\n            function store_address(_ptr, v) -> ptr {\n                ptr := _ptr\n                // 20 bytes long\n                mstore(ptr, shl(248, 0x94)) // 0x80 + 0x14\n                ptr := add(ptr, 1)\n                mstore(ptr, shl(96, v))\n                ptr := add(ptr, 0x14)\n            }\n\n            // 1 byte for TransactionType\n            // 4 byte for list payload length\n            let start_ptr := add(mload(0x40), 5)\n            let ptr := start_ptr\n            ptr := store_uint(ptr, _queueIndex)\n            ptr := store_uint(ptr, _gasLimit)\n            ptr := store_address(ptr, _target)\n            ptr := store_uint(ptr, _value)\n\n            switch eq(_data.length, 1)\n            case 1 {\n                // single byte\n                ptr := store_uint(ptr, shr(248, calldataload(_data.offset)))\n            }\n            default {\n                switch lt(_data.length, 56)\n                case 1 {\n                    // a string is 0-55 bytes long\n                    mstore(ptr, shl(248, add(0x80, _data.length)))\n                    ptr := add(ptr, 1)\n                    calldatacopy(ptr, _data.offset, _data.length)\n                    ptr := add(ptr, _data.length)\n                }\n                default {\n                    // a string is more than 55 bytes long\n                    let len_bytes := get_uint_bytes(_data.length)\n                    mstore(ptr, shl(248, add(0xb7, len_bytes)))\n                    ptr := add(ptr, 1)\n                    mstore(ptr, shl(mul(8, sub(32, len_bytes)), _data.length))\n                    ptr := add(ptr, len_bytes)\n                    calldatacopy(ptr, _data.offset, _data.length)\n                    ptr := add(ptr, _data.length)\n                }\n            }\n            ptr := store_address(ptr, _sender)\n\n            let payload_len := sub(ptr, start_ptr)\n            let value\n            let value_bytes\n            switch lt(payload_len, 56)\n            case 1 {\n                // the total payload of a list is 0-55 bytes long\n                value := add(0xc0, payload_len)\n                value_bytes := 1\n            }\n            default {\n                // If the total payload of a list is more than 55 bytes long\n                let len_bytes := get_uint_bytes(payload_len)\n                value_bytes := add(len_bytes, 1)\n                value := add(0xf7, len_bytes)\n                value := shl(mul(len_bytes, 8), value)\n                value := or(value, payload_len)\n            }\n            value := or(value, shl(mul(8, value_bytes), transactionType))\n            value_bytes := add(value_bytes, 1)\n            let value_bits := mul(8, value_bytes)\n            value := or(shl(sub(256, value_bits), value), shr(value_bits, mload(start_ptr)))\n            start_ptr := sub(start_ptr, value_bytes)\n            mstore(start_ptr, value)\n            hash := keccak256(start_ptr, sub(ptr, start_ptr))\n        }\n        return hash;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1MessageQueue\n    function appendCrossDomainMessage(\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) external override {\n        require(msg.sender == messenger, \"Only callable by the L1ScrollMessenger\");\n\n        // validate gas limit\n        _validateGasLimit(_gasLimit, _data);\n\n        // do address alias to avoid replay attack in L2.\n        address _sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n\n        _queueTransaction(_sender, _target, 0, _gasLimit, _data);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function appendEnforcedTransaction(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) external override {\n        require(msg.sender == enforcedTxGateway, \"Only callable by the EnforcedTxGateway\");\n        // We will check it in EnforcedTxGateway, just in case.\n        require(_sender.code.length == 0, \"only EOA\");\n\n        // validate gas limit\n        _validateGasLimit(_gasLimit, _data);\n\n        _queueTransaction(_sender, _target, _value, _gasLimit, _data);\n    }\n\n    /// @inheritdoc IL1MessageQueue\n    function popCrossDomainMessage(\n        uint256 _startIndex,\n        uint256 _count,\n        uint256 _skippedBitmap\n    ) external {\n        require(msg.sender == scrollChain, \"Only callable by the ScrollChain\");\n\n        require(_count <= 256, \"pop too many messages\");\n        require(pendingQueueIndex == _startIndex, \"start index mismatch\");\n\n        unchecked {\n            for (uint256 i = 0; i < _count; i++) {\n                if ((_skippedBitmap >> i) & 1 == 0) {\n                    messageQueue[_startIndex + i] = bytes32(0);\n                }\n            }\n\n            pendingQueueIndex = _startIndex + _count;\n        }\n\n        emit DequeueTransaction(_startIndex, _count, _skippedBitmap);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of gas oracle.\n    /// @dev This function can only called by contract owner.\n    /// @param _newGasOracle The address to update.\n    function updateGasOracle(address _newGasOracle) external onlyOwner {\n        address _oldGasOracle = gasOracle;\n        gasOracle = _newGasOracle;\n\n        emit UpdateGasOracle(_oldGasOracle, _newGasOracle);\n    }\n\n    /// @notice Update the address of EnforcedTxGateway.\n    /// @dev This function can only called by contract owner.\n    /// @param _newGateway The address to update.\n    function updateEnforcedTxGateway(address _newGateway) external onlyOwner {\n        address _oldGateway = enforcedTxGateway;\n        enforcedTxGateway = _newGateway;\n\n        emit UpdateEnforcedTxGateway(_oldGateway, _newGateway);\n    }\n\n    /// @notice Update the max gas limit.\n    /// @dev This function can only called by contract owner.\n    /// @param _newMaxGasLimit The new max gas limit.\n    function updateMaxGasLimit(uint256 _newMaxGasLimit) external onlyOwner {\n        uint256 _oldMaxGasLimit = maxGasLimit;\n        maxGasLimit = _newMaxGasLimit;\n\n        emit UpdateMaxGasLimit(_oldMaxGasLimit, _newMaxGasLimit);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to queue a L1 transaction.\n    /// @param _sender The address of sender who will initiate this transaction in L2.\n    /// @param _target The address of target contract to call in L2.\n    /// @param _value The value passed\n    /// @param _gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param _data The calldata passed to target contract.\n    function _queueTransaction(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) internal {\n        // compute transaction hash\n        uint256 _queueIndex = messageQueue.length;\n        bytes32 _hash = computeTransactionHash(_sender, _queueIndex, _value, _target, _gasLimit, _data);\n        messageQueue.push(_hash);\n\n        // emit event\n        emit QueueTransaction(_sender, _target, _value, _queueIndex, _gasLimit, _data);\n    }\n\n    function _validateGasLimit(uint256 _gasLimit, bytes memory _calldata) internal view {\n        require(_gasLimit <= maxGasLimit, \"Gas limit must not exceed maxGasLimit\");\n        // check if the gas limit is above intrinsic gas\n        uint256 intrinsicGas = calculateIntrinsicGasFee(_calldata);\n        require(_gasLimit >= intrinsicGas, \"Insufficient gas limit, must be above intrinsic gas\");\n    }\n}"
    }
  ]
}