{
  "Title": "Missing error messages in require statements [core and samples]",
  "Content": "Within the [codebase](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/) there are some `require` statements that lack error messages:\n\n\n* The `require` statement on [line 105](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L105) of [`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* The `require` statement on [line 49](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol#L49) of [`DepositPaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol)\n* The `require` statement on [line 137](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L137) of [`SimpleAccount.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol)\n\n\nConsider including specific, informative error messages in `require` statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied.\n\n\n***Update:** Resolved in [pull request #198](https://github.com/eth-infinitism/account-abstraction/pull/198) and merged at commit [`182b7d3`](https://github.com/eth-infinitism/account-abstraction/commit/182b7d3387a12d2d96974dbb883ed4c15f573122). Error messages were added to the deficient `require` statements in `BasePaymaster.sol` and `DepositPaymaster.sol`, and the `require` statement in `SimpleAccount.sol` was eliminated as part of a code change.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/BasePaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\n/**\n * Helper class for creating a paymaster.\n * provides helper methods for staking.\n * validates that the postOp is called only by the entryPoint\n */\nabstract contract BasePaymaster is IPaymaster, Ownable {\n\n    IEntryPoint public entryPoint;\n\n    constructor(IEntryPoint _entryPoint) {\n        setEntryPoint(_entryPoint);\n    }\n\n    function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner {\n        entryPoint = _entryPoint;\n    }\n\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n    external virtual override returns (bytes memory context, uint256 sigTimeRange);\n\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external override {\n        _requireFromEntryPoint();\n        _postOp(mode, context, actualGasCost);\n    }\n\n    /**\n     * post-operation handler.\n     * (verified to be called only through the entryPoint)\n     * @dev if subclass returns a non-empty context from validatePaymasterUserOp, it must also implement this method.\n     * @param mode enum with the following options:\n     *      opSucceeded - user operation succeeded.\n     *      opReverted  - user op reverted. still has to pay for gas.\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context - the context value returned by validatePaymasterUserOp\n     * @param actualGasCost - actual gas used so far (without this postOp call).\n     */\n    function _postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) internal virtual {\n\n        (mode,context,actualGasCost); // unused params\n        // subclass must override this method if validatePaymasterUserOp returns a context\n        revert(\"must override\");\n    }\n\n    /**\n     * add a deposit for this paymaster, used for paying for transaction fees\n     */\n    function deposit() public payable {\n        entryPoint.depositTo{value : msg.value}(address(this));\n    }\n\n    /**\n     * withdraw value from the deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n    /**\n     * add stake for this paymaster.\n     * This method can also carry eth value to add to the current stake.\n     * @param unstakeDelaySec - the unstake delay for this paymaster. Can only be increased.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n        entryPoint.addStake{value : msg.value}(unstakeDelaySec);\n    }\n\n    /**\n     * return current paymaster's deposit on the entryPoint.\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint.balanceOf(address(this));\n    }\n\n    /**\n     * unlock the stake, in order to withdraw it.\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\n     */\n    function unlockStake() external onlyOwner {\n        entryPoint.unlockStake();\n    }\n\n    /**\n     * withdraw the entire paymaster's stake.\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\n        entryPoint.withdrawStake(withdrawAddress);\n    }\n\n    /// validate the call is made from a valid entrypoint\n    function _requireFromEntryPoint() internal virtual {\n        require(msg.sender == address(entryPoint));\n    }\n\n    /**\n     * helper to pack the return value for validatePaymasterUserOp\n     * (copy of same method from BaseAccount)\n     * @param sigFailed true if the signature check failed, false, if it succeeded.\n     * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\n     * @param validAfter first timestamp this UserOperation is valid\n     */\n    function packSigTimeRange(bool sigFailed, uint256 validUntil, uint256 validAfter) internal pure returns (uint256) {\n        return uint256(sigFailed ? 1 : 0) | uint256(validUntil << 8) | uint256(validAfter << (64 + 8));\n    }\n}"
    },
    {
      "filename": "contracts/samples/DepositPaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../core/BasePaymaster.sol\";\nimport \"./IOracle.sol\";\n\n/**\n * A token-based paymaster that accepts token deposit\n * The deposit is only a safeguard: the user pays with his token balance.\n *  only if the user didn't approve() the paymaster, or if the token balance is not enough, the deposit will be used.\n *  thus the required deposit is to cover just one method call.\n * The deposit is locked for the current block: the user must issue unlockTokenDeposit() to be allowed to withdraw\n *  (but can't use the deposit for this or further operations)\n *\n * paymasterAndData holds the paymaster address followed by the token address to use.\n * @notice This paymaster will be rejected by the standard rules of EIP4337, as it uses an external oracle.\n * (the standard rules ban accessing data of an external contract)\n * It can only be used if it is \"whitelisted\" by the bundler.\n * (technically, it can be used by an \"oracle\" which returns a static value, without accessing any storage)\n */\ncontract DepositPaymaster is BasePaymaster {\n\n    using UserOperationLib for UserOperation;\n    using SafeERC20 for IERC20;\n\n    //calculated cost of the postOp\n    uint256 constant public COST_OF_POST = 35000;\n\n    IOracle private constant NULL_ORACLE = IOracle(address(0));\n    mapping(IERC20 => IOracle) public oracles;\n    mapping(IERC20 => mapping(address => uint256)) public balances;\n    mapping(address => uint256) public unlockBlock;\n\n    constructor(IEntryPoint _entryPoint) BasePaymaster(_entryPoint) {\n        //owner account is unblocked, to allow withdraw of paid tokens;\n        unlockTokenDeposit();\n    }\n\n    /**\n     * owner of the paymaster should add supported tokens\n     */\n    function addToken(IERC20 token, IOracle tokenPriceOracle) external onlyOwner {\n        require(oracles[token] == NULL_ORACLE);\n        oracles[token] = tokenPriceOracle;\n    }\n\n    /**\n     * deposit tokens that a specific account can use to pay for gas.\n     * The sender must first approve this paymaster to withdraw these tokens (they are only withdrawn in this method).\n     * Note depositing the tokens is equivalent to transferring them to the \"account\" - only the account can later\n     *  use them - either as gas, or using withdrawTo()\n     *\n     * @param token the token to deposit.\n     * @param account the account to deposit for.\n     * @param amount the amount of token to deposit.\n     */\n    function addDepositFor(IERC20 token, address account, uint256 amount) external {\n        //(sender must have approval for the paymaster)\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        require(oracles[token] != NULL_ORACLE, \"unsupported token\");\n        balances[token][account] += amount;\n        if (msg.sender == account) {\n            lockTokenDeposit();\n        }\n    }\n\n    function depositInfo(IERC20 token, address account) public view returns (uint256 amount, uint256 _unlockBlock) {\n        amount = balances[token][account];\n        _unlockBlock = unlockBlock[account];\n    }\n\n    /**\n     * unlock deposit, so that it can be withdrawn.\n     * can't be called in the same block as withdrawTo()\n     */\n    function unlockTokenDeposit() public {\n        unlockBlock[msg.sender] = block.number;\n    }\n\n    /**\n     * lock the tokens deposited for this account so they can be used to pay for gas.\n     * after calling unlockTokenDeposit(), the account can't use this paymaster until the deposit is locked.\n     */\n    function lockTokenDeposit() public {\n        unlockBlock[msg.sender] = 0;\n    }\n\n    /**\n     * withdraw tokens.\n     * can only be called after unlock() is called in a previous block.\n     * @param token the token deposit to withdraw\n     * @param target address to send to\n     * @param amount amount to withdraw\n     */\n    function withdrawTokensTo(IERC20 token, address target, uint256 amount) public {\n        require(unlockBlock[msg.sender] != 0 && block.number > unlockBlock[msg.sender], \"DepositPaymaster: must unlockTokenDeposit\");\n        balances[token][msg.sender] -= amount;\n        token.safeTransfer(target, amount);\n    }\n\n    /**\n     * translate the given eth value to token amount\n     * @param token the token to use\n     * @param ethBought the required eth value we want to \"buy\"\n     * @return requiredTokens the amount of tokens required to get this amount of eth\n     */\n    function getTokenValueOfEth(IERC20 token, uint256 ethBought) internal view virtual returns (uint256 requiredTokens) {\n        IOracle oracle = oracles[token];\n        require(oracle != NULL_ORACLE, \"DepositPaymaster: unsupported token\");\n        return oracle.getTokenValueOfEth(ethBought);\n    }\n\n    /**\n     * Validate the request:\n     * The sender should have enough deposit to pay the max possible cost.\n     * Note that the sender's balance is not checked. If it fails to pay from its balance,\n     * this deposit will be used to compensate the paymaster for the transaction.\n     */\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n    external view override returns (bytes memory context, uint256 sigTimeRange) {\n\n        (userOpHash);\n        // verificationGasLimit is dual-purposed, as gas limit for postOp. make sure it is high enough\n        require(userOp.verificationGasLimit > COST_OF_POST, \"DepositPaymaster: gas too low for postOp\");\n\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        require(paymasterAndData.length == 20+20, \"DepositPaymaster: paymasterAndData must specify token\");\n        IERC20 token = IERC20(address(bytes20(paymasterAndData[20:])));\n        address account = userOp.getSender();\n        uint256 maxTokenCost = getTokenValueOfEth(token, maxCost);\n        uint256 gasPriceUserOp = userOp.gasPrice();\n        require(unlockBlock[account] == 0, \"DepositPaymaster: deposit not locked\");\n        require(balances[token][account] >= maxTokenCost, \"DepositPaymaster: deposit too low\");\n        return (abi.encode(account, token, gasPriceUserOp, maxTokenCost, maxCost),0);\n    }\n\n    /**\n     * perform the post-operation to charge the sender for the gas.\n     * in normal mode, use transferFrom to withdraw enough tokens from the sender's balance.\n     * in case the transferFrom fails, the _postOp reverts and the entryPoint will call it again,\n     * this time in *postOpReverted* mode.\n     * In this mode, we use the deposit to pay (which we validated to be large enough)\n     */\n    function _postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) internal override {\n\n        (address account, IERC20 token, uint256 gasPricePostOp, uint256 maxTokenCost, uint256 maxCost) = abi.decode(context, (address, IERC20, uint256, uint256, uint256));\n        //use same conversion rate as used for validation.\n        uint256 actualTokenCost = (actualGasCost + COST_OF_POST * gasPricePostOp) * maxTokenCost / maxCost;\n        if (mode != PostOpMode.postOpReverted) {\n            // attempt to pay with tokens:\n            token.safeTransferFrom(account, address(this), actualTokenCost);\n        } else {\n            //in case above transferFrom failed, pay with deposit:\n            balances[token][account] -= actualTokenCost;\n        }\n        balances[token][owner()] += actualTokenCost;\n    }\n}"
    },
    {
      "filename": "contracts/samples/SimpleAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport \"../core/BaseAccount.sol\";\n\n/**\n  * minimal account.\n  *  this is sample minimal account.\n  *  has execute, eth handling methods\n  *  has a single signer that can send requests through the entryPoint.\n  */\ncontract SimpleAccount is BaseAccount, UUPSUpgradeable, Initializable {\n    using ECDSA for bytes32;\n\n    //explicit sizes of nonce, to fit a single storage cell with \"owner\"\n    uint96 private _nonce;\n    address public owner;\n\n    function nonce() public view virtual override returns (uint256) {\n        return _nonce;\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    IEntryPoint private immutable _entryPoint;\n\n    event SimpleAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    constructor(IEntryPoint anEntryPoint) {\n        _entryPoint = anEntryPoint;\n    }\n\n    modifier onlyOwner() {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() internal view {\n        //directly from EOA owner, or through the entryPoint (which gets redirected through execFromEntryPoint)\n        require(msg.sender == owner || msg.sender == address(this), \"only owner\");\n    }\n\n    /**\n     * execute a transaction (called directly from owner, not by entryPoint)\n     */\n    function execute(address dest, uint256 value, bytes calldata func) external {\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    /**\n     * execute a sequence of transaction\n     */\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external {\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint256 i = 0; i < dest.length; i++) {\n            _call(dest[i], 0, func[i]);\n        }\n    }\n\n    /**\n     * change entry-point:\n     * an account must have a method for replacing the entryPoint, in case the the entryPoint is\n     * upgraded to a newer version.\n     */\n    function initialize(address anOwner) public virtual initializer {\n        _initialize(anOwner);\n    }\n\n    function _initialize(address anOwner) internal virtual {\n        owner = anOwner;\n        emit SimpleAccountInitialized(_entryPoint, owner);\n    }\n\n    /**\n     * validate the userOp is correct.\n     * revert if it doesn't.\n     * - must only be called from the entryPoint.\n     * - make sure the signature is of our supported signer.\n     * - validate current nonce matches request nonce, and increment it.\n     * - pay prefund, in case current deposit is not enough\n     */\n    function _requireFromEntryPointOrOwner() internal view {\n        require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {\n        require(_nonce++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)\n    internal override virtual returns (uint256 sigTimeRange) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        if (owner != hash.recover(userOp.signature))\n            return SIG_VALIDATION_FAILED;\n        return 0;\n    }\n\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value : value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    /**\n     * check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n\n        (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n        require(req);\n    }\n\n    /**\n     * withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        (newImplementation);\n        _onlyOwner();\n    }\n}"
    }
  ]
}