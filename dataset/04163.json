{
  "Title": "[M03][Fixed] Actions are undefined at the exact time of oToken expiry",
  "Content": "The `oToken` contract defines an [expiration time](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Otoken.sol#L35) in which certain operations will no longer be active due to the expiration of the option. The option style used for the Protocol is the [european option](https://www.investopedia.com/terms/e/europeanoption.asp) in which the exercise of the option comes at maturity.\n\n\nSome actions that can be performed before the expiration time are [depositing long oTokens](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Controller.sol#L587) or [minting new oTokens](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Controller.sol#L669); while after the expiration time it can be [redeemed](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Controller.sol#L710) or [settled a vault](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Controller.sol#L739).\n\n\nNevertheless, at the exact time of expiry, none of the time-based actions will succeed because that moment is not included in either of those 2 conditions and the transaction will revert.\n\n\nBecause it is based on a European option, actions that happen after maturity should be able to be called at the exact time of expiry. Consider including and defining the expiration time to either of the 2 conditions so transactions will not revert.\n\n\n**Update:** *Fixed in [PR#291](https://github.com/opynfinance/GammaProtocol/pull/291).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Otoken.sol",
      "content": "/* SPDX-License-Identifier: UNLICENSED */\npragma solidity =0.6.10;\n\nimport {ERC20Initializable} from \"./packages/oz/upgradeability/ERC20Initializable.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {Strings} from \"./packages/oz/Strings.sol\";\nimport {BokkyPooBahsDateTimeLibrary} from \"./packages/BokkyPooBahsDateTimeLibrary.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\n\n/**\n * @title Otoken\n * @author Opyn Team\n * @notice Otoken is the ERC20 token for an option\n * @dev The Otoken inherits ERC20Initializable because we need to use the init instead of constructor\n */\ncontract Otoken is ERC20Initializable {\n    using SafeMath for uint256;\n\n    /// @notice address of the AddressBook module\n    address public addressBook;\n\n    /// @notice asset that the option references\n    address public underlyingAsset;\n\n    /// @notice asset that the strike price is denominated in\n    address public strikeAsset;\n\n    /// @notice asset that is held as collateral against short/written options\n    address public collateralAsset;\n\n    /// @notice strike price with decimals = 8\n    uint256 public strikePrice;\n\n    /// @notice expiration timestamp of the option, represented as a unix timestamp\n    uint256 public expiryTimestamp;\n\n    /// @notice True if a put option, False if a call option\n    bool public isPut;\n\n    uint256 private constant STRIKE_PRICE_SCALE = 1e8;\n    uint256 private constant STRIKE_PRICE_DIGITS = 8;\n\n    /**\n     * @notice initialize the oToken\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 8\n     * @param _expiryTimestamp expiration timestamp of the option, represented as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     */\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTimestamp,\n        bool _isPut\n    ) external initializer {\n        addressBook = _addressBook;\n        underlyingAsset = _underlyingAsset;\n        strikeAsset = _strikeAsset;\n        collateralAsset = _collateralAsset;\n        strikePrice = _strikePrice;\n        expiryTimestamp = _expiryTimestamp;\n        isPut = _isPut;\n        (string memory tokenName, string memory tokenSymbol) = _getNameAndSymbol();\n        __ERC20_init_unchained(tokenName, tokenSymbol);\n        _setupDecimals(8);\n    }\n\n    /**\n     * @notice mint oToken for an account\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to mint token to\n     * @param amount amount to mint\n     */\n    function mintOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getController(),\n            \"Otoken: Only Controller can mint Otokens\"\n        );\n        _mint(account, amount);\n    }\n\n    /**\n     * @notice burn oToken from an account.\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to burn token from\n     * @param amount amount to burn\n     */\n    function burnOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getController(),\n            \"Otoken: Only Controller can burn Otokens\"\n        );\n        _burn(account, amount);\n    }\n\n    /**\n     * @notice generates the name and symbol for an option\n     * @dev this function uses a named return variable to avoid the stack-too-deep error\n     * @return tokenName (ex: ETHUSDC 05-September-2020 200 Put USDC Collateral)\n     * @return tokenSymbol (ex: oETHUSDC-05SEP20-200P)\n     */\n    function _getNameAndSymbol() internal view returns (string memory tokenName, string memory tokenSymbol) {\n        string memory underlying = ERC20Initializable(underlyingAsset).symbol();\n        string memory strike = ERC20Initializable(strikeAsset).symbol();\n        string memory collateral = ERC20Initializable(collateralAsset).symbol();\n        string memory displayStrikePrice = _getDisplayedStrikePrice(strikePrice);\n\n        // convert expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(expiryTimestamp);\n\n        // get option type string\n        (string memory typeSymbol, string memory typeFull) = _getOptionType(isPut);\n\n        //get option month string\n        (string memory monthSymbol, string memory monthFull) = _getMonth(month);\n\n        // concatenated name string: ETHUSDC 05-September-2020 200 Put USDC Collateral\n        tokenName = string(\n            abi.encodePacked(\n                underlying,\n                strike,\n                \" \",\n                _uintTo2Chars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                typeFull,\n                \" \",\n                collateral,\n                \" Collateral\"\n            )\n        );\n\n        // concatenated symbol string: oETHUSDC-05SEP20-200P\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"o\",\n                underlying,\n                strike,\n                \"-\",\n                _uintTo2Chars(day),\n                monthSymbol,\n                _uintTo2Chars(year),\n                \"-\",\n                displayStrikePrice,\n                typeSymbol\n            )\n        );\n    }\n\n    /**\n     * @dev convert strike price scaled by 1e8 to human readable number string\n     * @param _strikePrice strike price scaled by 1e8\n     * @return strike price string\n     */\n    function _getDisplayedStrikePrice(uint256 _strikePrice) internal pure returns (string memory) {\n        uint256 remainder = _strikePrice.mod(STRIKE_PRICE_SCALE);\n        uint256 quotient = _strikePrice.div(STRIKE_PRICE_SCALE);\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) return quotientStr;\n\n        uint256 trailingZeroes = 0;\n        while (remainder.mod(10) == 0) {\n            remainder = remainder / 10;\n            trailingZeroes += 1;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory tmpStr = Strings.toString(remainder);\n        tmpStr = _slice(tmpStr, 1, 1 + STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory completeStr = string(abi.encodePacked(quotientStr, \".\", tmpStr));\n        return completeStr;\n    }\n\n    /**\n     * @dev return a representation of a number using 2 characters, adds a leading 0 if one digit, uses two trailing digits if a 3 digit number\n     * @return 2 characters that corresponds to a number\n     */\n    function _uintTo2Chars(uint256 number) internal pure returns (string memory) {\n        if (number > 99) number = number % 100;\n        string memory str = Strings.toString(number);\n        if (number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n        return str;\n    }\n\n    /**\n     * @dev return string representation of option type\n     * @return shortString a 1 character representation of option type (P or C)\n     * @return longString a full length string of option type (Put or Call)\n     */\n    function _getOptionType(bool _isPut) internal pure returns (string memory shortString, string memory longString) {\n        if (_isPut) {\n            return (\"P\", \"Put\");\n        } else {\n            return (\"C\", \"Call\");\n        }\n    }\n\n    /**\n     * @dev cut string s into s[start:end]\n     * @param _s the string to cut\n     * @param _start the starting index\n     * @param _end the ending index (excluded in the substring)\n     */\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure returns (string memory) {\n        bytes memory a = new bytes(_end - _start);\n        for (uint256 i = 0; i < _end - _start; i++) {\n            a[i] = bytes(_s)[_start + i];\n        }\n        return string(a);\n    }\n\n    /**\n     * @dev return string representation of a month\n     * @return shortString a 3 character representation of a month (ex: SEP, DEC, etc)\n     * @return longString a full length string of a month (ex: September, December, etc)\n     */\n    function _getMonth(uint256 _month) internal pure returns (string memory shortString, string memory longString) {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Controller.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {OwnableUpgradeSafe} from \"./packages/oz/upgradeability/OwnableUpgradeSafe.sol\";\nimport {ReentrancyGuardUpgradeSafe} from \"./packages/oz/upgradeability/ReentrancyGuardUpgradeSafe.sol\";\nimport {Initializable} from \"./packages/oz/upgradeability/Initializable.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {MarginVault} from \"./libs/MarginVault.sol\";\nimport {Actions} from \"./libs/Actions.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\nimport {OtokenInterface} from \"./interfaces/OtokenInterface.sol\";\nimport {MarginCalculatorInterface} from \"./interfaces/MarginCalculatorInterface.sol\";\nimport {OracleInterface} from \"./interfaces/OracleInterface.sol\";\nimport {WhitelistInterface} from \"./interfaces/WhitelistInterface.sol\";\nimport {MarginPoolInterface} from \"./interfaces/MarginPoolInterface.sol\";\nimport {CalleeInterface} from \"./interfaces/CalleeInterface.sol\";\n\n/**\n * @title Controller\n * @author Opyn Team\n * @notice Contract that controls the Gamma Protocol and the interaction of all sub contracts\n */\ncontract Controller is Initializable, OwnableUpgradeSafe, ReentrancyGuardUpgradeSafe {\n    using MarginVault for MarginVault.Vault;\n    using SafeMath for uint256;\n\n    AddressBookInterface public addressbook;\n    WhitelistInterface public whitelist;\n    OracleInterface public oracle;\n    MarginCalculatorInterface public calculator;\n    MarginPoolInterface public pool;\n\n    ///@dev scale used in MarginCalculator\n    uint256 internal constant BASE = 8;\n\n    /// @notice address that has permission to partially pause the system, where system functionality is paused\n    /// except redeem and settleVault\n    address public partialPauser;\n\n    /// @notice address that has permission to fully pause the system, where all system functionality is paused\n    address public fullPauser;\n\n    /// @notice True if all system functionality is paused other than redeem and settle vault\n    bool public systemPartiallyPaused;\n\n    /// @notice True if all system functionality is paused\n    bool public systemFullyPaused;\n\n    /// @notice True if a call action can only be executed to a whitelisted callee\n    bool public callRestricted;\n\n    /// @dev mapping between an owner address and the number of owner address vaults\n    mapping(address => uint256) internal accountVaultCounter;\n    /// @dev mapping between an owner address and a specific vault using a vault id\n    mapping(address => mapping(uint256 => MarginVault.Vault)) internal vaults;\n    /// @dev mapping between an account owner and their approved or unapproved account operators\n    mapping(address => mapping(address => bool)) internal operators;\n\n    /// @notice emits an event when an account operator is updated for a specific account owner\n    event AccountOperatorUpdated(address indexed accountOwner, address indexed operator, bool isSet);\n    /// @notice emits an event when a new vault is opened\n    event VaultOpened(address indexed accountOwner, uint256 vaultId);\n    /// @notice emits an event when a long oToken is deposited into a vault\n    event LongOtokenDeposited(\n        address indexed otoken,\n        address indexed accountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a long oToken is withdrawn from a vault\n    event LongOtokenWithdrawed(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a collateral asset is deposited into a vault\n    event CollateralAssetDeposited(\n        address indexed asset,\n        address indexed accountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a collateral asset is withdrawn from a vault\n    event CollateralAssetWithdrawed(\n        address indexed asset,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a short oToken is minted from a vault\n    event ShortOtokenMinted(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a short oToken is burned\n    event ShortOtokenBurned(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when an oToken is redeemed\n    event Redeem(\n        address indexed otoken,\n        address indexed redeemer,\n        address indexed receiver,\n        address collateralAsset,\n        uint256 otokenBurned,\n        uint256 payout\n    );\n    /// @notice emits an event when a vault is settled\n    event VaultSettled(address indexed AccountOwner, address indexed to, uint256 vaultId, uint256 payout);\n    /// @notice emits an event when a call action is executed\n    event CallExecuted(\n        address indexed from,\n        address indexed to,\n        address indexed vaultOwner,\n        uint256 vaultId,\n        bytes data\n    );\n    /// @notice emits an event when the fullPauser address changes\n    event FullPauserUpdated(address indexed oldFullPauser, address indexed newFullPauser);\n    /// @notice emits an event when the partialPauser address changes\n    event PartialPauserUpdated(address indexed oldPartialPauser, address indexed newPartialPauser);\n    /// @notice emits an event when the system partial paused status changes\n    event SystemPartiallyPaused(bool isActive);\n    /// @notice emits an event when the system fully paused status changes\n    event SystemFullyPaused(bool isActive);\n    /// @notice emits an event when the call action restriction changes\n    event CallRestricted(bool isRestricted);\n\n    /**\n     * @notice modifier to check if the system is not partially paused, where only redeem and settleVault is allowed\n     */\n    modifier notPartiallyPaused {\n        _isNotPartiallyPaused();\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the system is not fully paused, where no functionality is allowed\n     */\n    modifier notFullyPaused {\n        _isNotFullyPaused();\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if sender is the fullPauser address\n     */\n    modifier onlyFullPauser {\n        require(msg.sender == fullPauser, \"Controller: sender is not fullPauser\");\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the sender is the partialPauser address\n     */\n    modifier onlyPartialPauser {\n        require(msg.sender == partialPauser, \"Controller: sender is not partialPauser\");\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the sender is the account owner or an approved account operator\n     * @param _sender sender address\n     * @param _accountOwner account owner address\n     */\n    modifier onlyAuthorized(address _sender, address _accountOwner) {\n        _isAuthorized(_sender, _accountOwner);\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the called address is a whitelisted callee address\n     * @param _callee called address\n     */\n    modifier onlyWhitelistedCallee(address _callee) {\n        if (callRestricted) {\n            require(_isCalleeWhitelisted(_callee), \"Controller: callee is not a whitelisted address\");\n        }\n\n        _;\n    }\n\n    /**\n     * @dev check if the system is not in a partiallyPaused state\n     */\n    function _isNotPartiallyPaused() internal view {\n        require(!systemPartiallyPaused, \"Controller: system is partially paused\");\n    }\n\n    /**\n     * @dev check if the system is not in an fullyPaused state\n     */\n    function _isNotFullyPaused() internal view {\n        require(!systemFullyPaused, \"Controller: system is fully paused\");\n    }\n\n    /**\n     * @dev check if the sender is an authorized operator\n     * @param _sender msg.sender\n     * @param _accountOwner owner of a vault\n     */\n    function _isAuthorized(address _sender, address _accountOwner) internal view {\n        require(\n            (_sender == _accountOwner) || (operators[_accountOwner][_sender]),\n            \"Controller: msg.sender is not authorized to run action\"\n        );\n    }\n\n    /**\n     * @notice initalize the deployed contract\n     * @param _addressBook addressbook module\n     * @param _owner account owner address\n     */\n    function initialize(address _addressBook, address _owner) external initializer {\n        require(_addressBook != address(0), \"Controller: invalid addressbook address\");\n        require(_owner != address(0), \"Controller: invalid owner address\");\n\n        __Context_init_unchained();\n        __Ownable_init_unchained(_owner);\n        __ReentrancyGuard_init_unchained();\n\n        addressbook = AddressBookInterface(_addressBook);\n        _refreshConfigInternal();\n    }\n\n    /**\n     * @notice allows the partialPauser to toggle the systemPartiallyPaused variable and partially pause or partially unpause the system\n     * @dev can only be called by the partialPauser\n     * @param _partiallyPaused new boolean value to set systemPartiallyPaused to\n     */\n    function setSystemPartiallyPaused(bool _partiallyPaused) external onlyPartialPauser {\n        systemPartiallyPaused = _partiallyPaused;\n\n        emit SystemPartiallyPaused(systemPartiallyPaused);\n    }\n\n    /**\n     * @notice allows the fullPauser to toggle the systemFullyPaused variable and fully pause or fully unpause the system\n     * @dev can only be called by the fullPauser\n     * @param _fullyPaused new boolean value to set systemFullyPaused to\n     */\n    function setSystemFullyPaused(bool _fullyPaused) external onlyFullPauser {\n        systemFullyPaused = _fullyPaused;\n\n        emit SystemFullyPaused(systemFullyPaused);\n    }\n\n    /**\n     * @notice allows the owner to set the fullPauser address\n     * @dev can only be called by the owner\n     * @param _fullPauser new fullPauser address\n     */\n    function setFullPauser(address _fullPauser) external onlyOwner {\n        require(_fullPauser != address(0), \"Controller: fullPauser cannot be set to address zero\");\n\n        emit FullPauserUpdated(fullPauser, _fullPauser);\n\n        fullPauser = _fullPauser;\n    }\n\n    /**\n     * @notice allows the owner to set the partialPauser address\n     * @dev can only be called by the owner\n     * @param _partialPauser new partialPauser address\n     */\n    function setPartialPauser(address _partialPauser) external onlyOwner {\n        require(_partialPauser != address(0), \"Controller: partialPauser cannot be set to address zero\");\n\n        emit PartialPauserUpdated(partialPauser, _partialPauser);\n\n        partialPauser = _partialPauser;\n    }\n\n    /**\n     * @notice allows the owner to toggle the restriction on whitelisted call actions and only allow whitelisted\n     * call addresses or allow any arbitrary call addresses\n     * @dev can only be called by the owner\n     * @param _isRestricted new call restriction state\n     */\n    function setCallRestriction(bool _isRestricted) external onlyOwner {\n        callRestricted = _isRestricted;\n\n        emit CallRestricted(callRestricted);\n    }\n\n    /**\n     * @notice allows a user to give or revoke privileges to an operator which can act on their behalf on their vaults\n     * @dev can only be updated by the vault owner\n     * @param _operator operator that the sender wants to give privileges to or revoke them from\n     * @param _isOperator new boolean value that expresses if the sender is giving or revoking privileges for _operator\n     */\n    function setOperator(address _operator, bool _isOperator) external {\n        operators[msg.sender][_operator] = _isOperator;\n\n        emit AccountOperatorUpdated(msg.sender, _operator, _isOperator);\n    }\n\n    /**\n     * @dev updates the configuration of the controller. can only be called by the owner\n     */\n    function refreshConfiguration() external onlyOwner {\n        _refreshConfigInternal();\n    }\n\n    /**\n     * @notice execute a number of actions on specific vaults\n     * @dev can only be called when the system is not fully paused\n     * @param _actions array of actions arguments\n     */\n    function operate(Actions.ActionArgs[] memory _actions) external payable nonReentrant notFullyPaused {\n        (bool vaultUpdated, address vaultOwner, uint256 vaultId) = _runActions(_actions);\n        if (vaultUpdated) _verifyFinalState(vaultOwner, vaultId);\n    }\n\n    /**\n     * @notice check if a specific address is an operator for an owner account\n     * @param _owner account owner address\n     * @param _operator account operator address\n     * @return True if the _operator is an approved operator for the _owner account\n     */\n    function isOperator(address _owner, address _operator) external view returns (bool) {\n        return operators[_owner][_operator];\n    }\n\n    /**\n     * @notice returns the current controller configuration\n     * @return whitelist, the address of the whitelist module\n     * @return oracle, the address of the oracle module\n     * @return calculator, the address of the calculator module\n     * @return pool, the address of the pool module\n     */\n    function getConfiguration()\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            address\n        )\n    {\n        return (address(whitelist), address(oracle), address(calculator), address(pool));\n    }\n\n    /**\n     * @notice return a vault's proceeds pre or post expiry, the amount of collateral that can be removed from a vault\n     * @param _owner account owner of the vault\n     * @param _vaultId vaultId to return balances for\n     * @return amount of collateral that can be taken out\n     */\n    function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {\n        MarginVault.Vault memory vault = getVault(_owner, _vaultId);\n\n        (uint256 netValue, ) = calculator.getExcessCollateral(vault);\n        return netValue;\n    }\n\n    /**\n     * @notice get an oToken's payout/cash value after expiry, in the collateral asset\n     * @param _otoken oToken address\n     * @param _amount amount of the oToken to calculate the payout for, always represented in 1e8\n     * @return amount of collateral to pay out\n     */\n    function getPayout(address _otoken, uint256 _amount) public view returns (uint256) {\n        uint256 rate = calculator.getExpiredPayoutRate(_otoken);\n        return rate.mul(_amount).div(10**BASE);\n    }\n\n    /**\n     * @dev return if an expired oToken contractâ€™s settlement price has been finalized\n     * @param _otoken address of the oToken\n     * @return True if the oToken has expired AND all oracle prices at the expiry timestamp have been finalized, False if not\n     */\n    function isSettlementAllowed(address _otoken) public view returns (bool) {\n        OtokenInterface otoken = OtokenInterface(_otoken);\n\n        address underlying = otoken.underlyingAsset();\n        address strike = otoken.strikeAsset();\n        address collateral = otoken.collateralAsset();\n\n        uint256 expiry = otoken.expiryTimestamp();\n\n        bool isUnderlyingFinalized = oracle.isDisputePeriodOver(underlying, expiry);\n        bool isStrikeFinalized = oracle.isDisputePeriodOver(strike, expiry);\n        bool isCollateralFinalized = oracle.isDisputePeriodOver(collateral, expiry);\n\n        return isUnderlyingFinalized && isStrikeFinalized && isCollateralFinalized;\n    }\n\n    /**\n     * @notice get the number of vaults for a specified account owner\n     * @param _accountOwner account owner address\n     * @return number of vaults\n     */\n    function getAccountVaultCounter(address _accountOwner) external view returns (uint256) {\n        return accountVaultCounter[_accountOwner];\n    }\n\n    /**\n     * @notice check if an oToken has expired\n     * @param _otoken oToken address\n     * @return True if the otoken has expired, False if not\n     */\n    function hasExpired(address _otoken) external view returns (bool) {\n        uint256 otokenExpiryTimestamp = OtokenInterface(_otoken).expiryTimestamp();\n\n        return now > otokenExpiryTimestamp;\n    }\n\n    /**\n     * @notice return a specific vault\n     * @param _owner account owner\n     * @param _vaultId vault id of vault to return\n     * @return Vault struct that corresponds to the _vaultId of _owner\n     */\n    function getVault(address _owner, uint256 _vaultId) public view returns (MarginVault.Vault memory) {\n        return vaults[_owner][_vaultId];\n    }\n\n    /**\n     * @notice execute a variety of actions\n     * @dev for each action in the action array, execute the corresponding action, only one vault can be modified\n     * for all actions except SettleVault, Redeem, and Call\n     * @param _actions array of type Actions.ActionArgs[], which expresses which actions the user wants to execute\n     * @return vaultUpdated, indicates if a vault has changed\n     * @return owner, the vault owner if a vault has changed\n     * @return vaultId, the vault Id if a vault has changed\n     */\n    function _runActions(Actions.ActionArgs[] memory _actions)\n        internal\n        returns (\n            bool,\n            address,\n            uint256\n        )\n    {\n        address vaultOwner;\n        uint256 vaultId;\n        uint256 ethLeft = msg.value;\n        bool vaultUpdated;\n\n        for (uint256 i = 0; i < _actions.length; i++) {\n            Actions.ActionArgs memory action = _actions[i];\n            Actions.ActionType actionType = action.actionType;\n\n            if (\n                (actionType != Actions.ActionType.SettleVault) &&\n                (actionType != Actions.ActionType.Redeem) &&\n                (actionType != Actions.ActionType.Call)\n            ) {\n                // check if this action is manipulating the same vault as all other actions, if a vault has already been updated\n                if (vaultUpdated) {\n                    require(vaultOwner == action.owner, \"Controller: can not run actions for different owners\");\n                    require(vaultId == action.vaultId, \"Controller: can not run actions on different vaults\");\n                }\n                vaultUpdated = true;\n                vaultId = action.vaultId;\n                vaultOwner = action.owner;\n            }\n\n            if (actionType == Actions.ActionType.OpenVault) {\n                _openVault(Actions._parseOpenVaultArgs(action));\n            } else if (actionType == Actions.ActionType.DepositLongOption) {\n                _depositLong(Actions._parseDepositArgs(action));\n            } else if (actionType == Actions.ActionType.WithdrawLongOption) {\n                _withdrawLong(Actions._parseWithdrawArgs(action));\n            } else if (actionType == Actions.ActionType.DepositCollateral) {\n                _depositCollateral(Actions._parseDepositArgs(action));\n            } else if (actionType == Actions.ActionType.WithdrawCollateral) {\n                _withdrawCollateral(Actions._parseWithdrawArgs(action));\n            } else if (actionType == Actions.ActionType.MintShortOption) {\n                _mintOtoken(Actions._parseMintArgs(action));\n            } else if (actionType == Actions.ActionType.BurnShortOption) {\n                _burnOtoken(Actions._parseBurnArgs(action));\n            } else if (actionType == Actions.ActionType.Redeem) {\n                _redeem(Actions._parseRedeemArgs(action));\n            } else if (actionType == Actions.ActionType.SettleVault) {\n                _settleVault(Actions._parseSettleVaultArgs(action));\n            } else {\n                // actionType == Actions.ActionType.Call\n                ethLeft = _call(Actions._parseCallArgs(action), ethLeft);\n            }\n        }\n\n        return (vaultUpdated, vaultOwner, vaultId);\n    }\n\n    /**\n     * @notice verify the vault final state after executing all actions\n     * @param _owner account owner address\n     * @param _vaultId vault id of the final vault\n     */\n    function _verifyFinalState(address _owner, uint256 _vaultId) internal view {\n        MarginVault.Vault memory _vault = getVault(_owner, _vaultId);\n        (, bool isValidVault) = calculator.getExcessCollateral(_vault);\n\n        require(isValidVault, \"Controller: invalid final vault state\");\n    }\n\n    /**\n     * @notice open a new vault inside an account\n     * @dev only the account owner or operator can open a vault, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args OpenVaultArgs structure\n     */\n    function _openVault(Actions.OpenVaultArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        accountVaultCounter[_args.owner] = accountVaultCounter[_args.owner].add(1);\n\n        require(\n            _args.vaultId == accountVaultCounter[_args.owner],\n            \"Controller: can not run actions on inexistent vault\"\n        );\n\n        emit VaultOpened(_args.owner, accountVaultCounter[_args.owner]);\n    }\n\n    /**\n     * @notice deposit a long oToken into a vault\n     * @dev only the account owner or operator can deposit a long oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args DepositArgs structure\n     */\n    function _depositLong(Actions.DepositArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"Controller: invalid vault id\");\n        require(\n            (_args.from == msg.sender) || (_args.from == _args.owner),\n            \"Controller: cannot deposit long otoken from this address\"\n        );\n\n        require(\n            whitelist.isWhitelistedOtoken(_args.asset),\n            \"Controller: otoken is not whitelisted to be used as collateral\"\n        );\n\n        OtokenInterface otoken = OtokenInterface(_args.asset);\n\n        require(now < otoken.expiryTimestamp(), \"Controller: otoken used as collateral is already expired\");\n\n        vaults[_args.owner][_args.vaultId].addLong(_args.asset, _args.amount, _args.index);\n\n        pool.transferToPool(_args.asset, _args.from, _args.amount);\n\n        emit LongOtokenDeposited(_args.asset, _args.owner, _args.from, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice withdraw a long oToken from a vault\n     * @dev only the account owner or operator can withdraw a long oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args WithdrawArgs structure\n     */\n    function _withdrawLong(Actions.WithdrawArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"Controller: invalid vault id\");\n\n        OtokenInterface otoken = OtokenInterface(_args.asset);\n\n        require(now < otoken.expiryTimestamp(), \"Controller: can not withdraw a"
    }
  ]
}