{
  "Title": "Lack of essential stale check in oracleCircuitBreaker()",
  "Content": "# Lack of essential stale check in oracleCircuitBreaker()\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L120-L123\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L120-L123</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L73\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L73</a>\n\n\n## Summary\n\nThe `LibOracle::oracleCircuitBreaker()` lacks checking the condition: \"`block.timestamp > 2 hours + baseTimeStamp`\". Hence, the function will not be able to verify whether or not the `baseChainlinkPrice` is stale (2-hour stale heartbeat).\n\n## Vulnerability Details\n\n> **This report raises an issue regarding the lack of stale price check for the base oracle (ETH/USD price) in the `oracleCircuitBreaker()` only**, as the 2-hour stale check and the lack of stale price check for the non-USD asset oracle were flagged as known issues.\n\nThe [`oracleCircuitBreaker()`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L120-L123) lacks checking the condition: \"`block.timestamp > 2 hours + baseTimeStamp`\" when compared to the [`baseOracleCircuitBreaker()`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L73).\n\nWithout the check of the condition: \"`block.timestamp > 2 hours + baseTimeStamp`\", the `oracleCircuitBreaker()` will not be able to verify whether or not the `baseChainlinkPrice` is stale (2-hour stale heartbeat).\n\nFor this reason, the `oracleCircuitBreaker()` will [not revert the transaction](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L125) as expected if the `baseChainlinkPrice` is stale.\n\n```solidity\n    //@audit -- this report raises an issue regarding the lack of stale price check for the base oracle (ETH/USD price) in the oracleCircuitBreaker() only, as the 2-hour stale check and the lack of stale price check for the non-USD asset oracle were flagged as known issues\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view { //@audit -- this report raises an issue regarding the lack of stale price check for the base oracle (ETH/USD price) in the oracleCircuitBreaker() only, as the 2-hour stale check and the lack of stale price check for the non-USD asset oracle were flagged as known issues\n@>      bool invalidFetchData = roundId == 0 || timeStamp == 0\n@>          || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n@>          || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n@>          || baseChainlinkPrice <= 0; //@audit -- lack the condition: \"block.timestamp > 2 hours + baseTimeStamp\"\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n@>          || block.timestamp > 2 hours + timeStamp; //@audit -- the baseOracleCircuitBreaker() checks this condition, but the oracleCircuitBreaker() does not check it (for the base oracle (ETH/USD price) only)\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        ...\n    }\n```\n\n- `The oracleCircuitBreaker() lacks checking the condition: \"block.timestamp > 2 hours + baseTimeStamp\"`: https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L120-L123\n\n- `Whereas the baseOracleCircuitBreaker() checks that condition`: https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L73\n\n## Impact\n\n> **This report raises an issue regarding the lack of stale price check for the base oracle (ETH/USD price) in the `oracleCircuitBreaker()` only**, as the 2-hour stale check and the lack of stale price check for the non-USD asset oracle were flagged as known issues.\n\nThe `oracleCircuitBreaker()` lacks checking the condition: \"`block.timestamp > 2 hours + baseTimeStamp`\". Hence, the function will not be able to verify whether or not the `baseChainlinkPrice` is stale (2-hour stale heartbeat).\n\nConsequently, the `oracleCircuitBreaker()` will [not revert the transaction](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L125) as expected if the `baseChainlinkPrice` is stale. The stale price will be consumed by core functions of the protocol, leading to harming the funds of the protocol and its users.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nAdd the condition: \"`block.timestamp > 2 hours + baseTimeStamp`\" in the `oracleCircuitBreaker()` to provide the stale check.\n\n```diff\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n-           || baseChainlinkPrice <= 0;\n+           || baseChainlinkPrice <= 0 || block.timestamp > 2 hours + baseTimeStamp;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n```",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrd"
    }
  ]
}