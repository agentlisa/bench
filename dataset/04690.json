{
  "Title": "Usage of magic constants",
  "Content": "There are several [magic constants](https://en.wikipedia.org/wiki/Magic_number_%28programming%29) in the contract code. Some examples are:\n\n\n1. <https://github.com/ether-camp/virtual-accelerator/blob/2529ffe5efd5294b44f1bc89dc9a4721a7b16409/contracts/HackerGold.sol#L88-L90>\n2. <https://github.com/ether-camp/virtual-accelerator/blob/2529ffe5efd5294b44f1bc89dc9a4721a7b16409/contracts/HackerGold.sol#L116-L133>\n\n\nUse of magic constants reduces code readability and makes it harder to understand code intention. We recommend extracting magic constants into contract constants.\n\n\nEDIT: EtherCamp fixed this problem [in this commit](https://github.com/ether-camp/virtual-accelerator/commit/99d2940f91db20a074c5c20cb7ddf53fda255e59)\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/HackerGold.sol",
      "content": "import \"StandardToken.sol\";\n\npragma solidity ^0.4.0;\n\n/**\n *\n * Hacker gold is the official token of \n * the <hack.ether.camp> hackathon. \n *\n * todo: brief explained\n *\n * Whitepaper https://hack.ether.camp/whitepaper\n *\n */\n /// @title Hacker Gold\ncontract HackerGold is StandardToken {\n\n    \n    string public name = \"HackerGold\";\n\n    /// digits number after the point\n    uint8  public decimals = 3;          \n    string public symbol = \"HKG\";\n    \n    // 1 ether = 200 hkg\n    uint BASE_PRICE = 200;\n    \n    // total value in wei\n    uint totalValue;\n    \n    // multisig holding the value\n    address wallet;\n\n    struct milestones_struct {\n      uint p1;\n      uint p2; \n      uint p3;\n      uint p4;\n      uint p5;\n      uint p6;\n    }\n    milestones_struct milestones;\n    \n    /**\n     * Constructor\n     * \n     * @param multisig address of MultiSig wallet which will hold the value\n     */\n    function HackerGold(address multisig) {\n        \n        wallet = multisig;\n\n        // set time periods for sale\n        milestones = milestones_struct(\n        \n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \n                       //                                Hackathon Starts\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\n        );\n                \n    }\n    \n    \n    /**\n     * Fallback function: called on ether sent\n     */\n    function () payable {\n        createHKG(msg.sender);\n    }\n    \n    /**\n     * Creates HKG tokens\n     * \n     * @param holder token holder\n     */\n    function createHKG(address holder) payable {\n        \n        if (now < milestones.p1) throw;\n        if (now > milestones.p6) throw;\n        if (msg.value == 0) throw;\n    \n        // safety cap\n        if (getTotalValue() + msg.value > 4000000 ether) throw; \n    \n        uint tokens = msg.value / 1000000000000000 * getPrice();\n\n        totalSupply += tokens;\n        balances[holder] += tokens;\n        totalValue += msg.value;\n        \n        if (!wallet.send(msg.value)) throw;\n    }\n    \n    /**\n     * Denotes complete price structure during the sale.\n     *\n     * @return HKG amount per 1 ETH considering current moment in time\n     */\n    function getPrice() constant returns (uint result){\n        \n        if (now < milestones.p1) return 0;\n        \n        if (now >= milestones.p1 && now < milestones.p2){\n        \n            return BASE_PRICE;\n        }\n        \n        if (now >= milestones.p2 && now < milestones.p3){\n            \n        \n            uint days_in = 1 + (now - milestones.p2) / (60 * 60 *24); \n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\n        }\n\n        if (now >= milestones.p3 && now < milestones.p4){\n        \n            return BASE_PRICE / 4 * 3;\n        }\n        \n        if (now >= milestones.p4 && now < milestones.p5){\n            \n            days_in = 1 + (now - milestones.p4) / (60 * 60 *24); \n            return (BASE_PRICE / 4 * 3) - days_in * 25 / 7;  // daily decrease 3.5\n        }\n\n        if (now >= milestones.p5 && now < milestones.p6){\n        \n            return BASE_PRICE / 2;\n        }\n        \n        if (now >= milestones.p6){\n\n            return 0;\n        }\n\n     }\n    \n    /**\n     * Returns total HKG fractions amount (HKG amount * 1000)\n     * Pay attention to decimals variable defining number of digis after the point\n     * \n     * @return result HKG fractions amount\n     */\n    function getTotalSupply() constant returns (uint result){\n        return totalSupply;\n    } \n\n    function getNow() constant returns (uint result) {\n        return now;\n    }\n\n    /**\n     * Returns total value passed through the contract\n     * \n     * @return result total value in wei\n     */\n    function getTotalValue() constant returns (uint result) {\n        return totalValue;  \n    }\n}"
    },
    {
      "filename": "contracts/HackerGold.sol",
      "content": "import \"StandardToken.sol\";\n\npragma solidity ^0.4.0;\n\n/**\n *\n * Hacker gold is the official token of \n * the <hack.ether.camp> hackathon. \n *\n * todo: brief explained\n *\n * Whitepaper https://hack.ether.camp/whitepaper\n *\n */\n /// @title Hacker Gold\ncontract HackerGold is StandardToken {\n\n    \n    string public name = \"HackerGold\";\n\n    /// digits number after the point\n    uint8  public decimals = 3;          \n    string public symbol = \"HKG\";\n    \n    // 1 ether = 200 hkg\n    uint BASE_PRICE = 200;\n    \n    // total value in wei\n    uint totalValue;\n    \n    // multisig holding the value\n    address wallet;\n\n    struct milestones_struct {\n      uint p1;\n      uint p2; \n      uint p3;\n      uint p4;\n      uint p5;\n      uint p6;\n    }\n    milestones_struct milestones;\n    \n    /**\n     * Constructor\n     * \n     * @param multisig address of MultiSig wallet which will hold the value\n     */\n    function HackerGold(address multisig) {\n        \n        wallet = multisig;\n\n        // set time periods for sale\n        milestones = milestones_struct(\n        \n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \n                       //                                Hackathon Starts\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\n        );\n                \n    }\n    \n    \n    /**\n     * Fallback function: called on ether sent\n     */\n    function () payable {\n        createHKG(msg.sender);\n    }\n    \n    /**\n     * Creates HKG tokens\n     * \n     * @param holder token holder\n     */\n    function createHKG(address holder) payable {\n        \n        if (now < milestones.p1) throw;\n        if (now > milestones.p6) throw;\n        if (msg.value == 0) throw;\n    \n        // safety cap\n        if (getTotalValue() + msg.value > 4000000 ether) throw; \n    \n        uint tokens = msg.value / 1000000000000000 * getPrice();\n\n        totalSupply += tokens;\n        balances[holder] += tokens;\n        totalValue += msg.value;\n        \n        if (!wallet.send(msg.value)) throw;\n    }\n    \n    /**\n     * Denotes complete price structure during the sale.\n     *\n     * @return HKG amount per 1 ETH considering current moment in time\n     */\n    function getPrice() constant returns (uint result){\n        \n        if (now < milestones.p1) return 0;\n        \n        if (now >= milestones.p1 && now < milestones.p2){\n        \n            return BASE_PRICE;\n        }\n        \n        if (now >= milestones.p2 && now < milestones.p3){\n            \n        \n            uint days_in = 1 + (now - milestones.p2) / (60 * 60 *24); \n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\n        }\n\n        if (now >= milestones.p3 && now < milestones.p4){\n        \n            return BASE_PRICE / 4 * 3;\n        }\n        \n        if (now >= milestones.p4 && now < milestones.p5){\n            \n            days_in = 1 + (now - milestones.p4) / (60 * 60 *24); \n            return (BASE_PRICE / 4 * 3) - days_in * 25 / 7;  // daily decrease 3.5\n        }\n\n        if (now >= milestones.p5 && now < milestones.p6){\n        \n            return BASE_PRICE / 2;\n        }\n        \n        if (now >= milestones.p6){\n\n            return 0;\n        }\n\n     }\n    \n    /**\n     * Returns total HKG fractions amount (HKG amount * 1000)\n     * Pay attention to decimals variable defining number of digis after the point\n     * \n     * @return result HKG fractions amount\n     */\n    function getTotalSupply() constant returns (uint result){\n        return totalSupply;\n    } \n\n    function getNow() constant returns (uint result) {\n        return now;\n    }\n\n    /**\n     * Returns total value passed through the contract\n     * \n     * @return result total value in wei\n     */\n    function getTotalValue() constant returns (uint result) {\n        return totalValue;  \n    }\n}"
    }
  ]
}