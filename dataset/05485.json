{
  "Title": "[L-01] Prevent deposits to the nodes with max amount of assets being staked already",
  "Content": "\nIf the node has staked already 1e23 of assets, it should not receive any transfers, since there is no more space to stake at EigenLayer.\n\n### Example of an occurrence\n\nCould be implied [here](https://github.com/code-423n4/2023-11-kelp/blob/main/src/LRTDepositPool.sol#L183-L197).\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-11-kelp",
  "Code": [
    {
      "filename": "src/LRTDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\n\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title LRTDepositPool - Deposit Pool Contract for LSTs\n/// @notice Handles LST asset deposits\ncontract LRTDepositPool is ILRTDepositPool, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    uint256 public maxNodeDelegatorCount;\n\n    address[] public nodeDelegatorQueue;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        maxNodeDelegatorCount = 10;\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice gets the total asset present in protocol\n    /// @param asset Asset address\n    /// @return totalAssetDeposit total asset present in protocol\n    function getTotalAssetDeposits(address asset) public view override returns (uint256 totalAssetDeposit) {\n        (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer) =\n            getAssetDistributionData(asset);\n        return (assetLyingInDepositPool + assetLyingInNDCs + assetStakedInEigenLayer);\n    }\n\n    /// @notice gets the current limit of asset deposit\n    /// @param asset Asset address\n    /// @return currentLimit Current limit of asset deposit\n    function getAssetCurrentLimit(address asset) public view override returns (uint256) {\n        return lrtConfig.depositLimitByAsset(asset) - getTotalAssetDeposits(asset);\n    }\n\n    /// @dev get node delegator queue\n    /// @return nodeDelegatorQueue Array of node delegator contract addresses\n    function getNodeDelegatorQueue() external view override returns (address[] memory) {\n        return nodeDelegatorQueue;\n    }\n\n    /// @dev provides asset amount distribution data among depositPool, NDCs and eigenLayer\n    /// @param asset the asset to get the total amount of\n    /// @return assetLyingInDepositPool asset amount lying in this LRTDepositPool contract\n    /// @return assetLyingInNDCs asset amount sum lying in all NDC contract\n    /// @return assetStakedInEigenLayer asset amount staked in eigen layer through all NDCs\n    function getAssetDistributionData(address asset)\n        public\n        view\n        override\n        onlySupportedAsset(asset)\n        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)\n    {\n        // Question: is here the right place to have this? Could it be in LRTConfig?\n        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);\n            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice View amount of rsETH to mint for given asset amount\n    /// @param asset Asset address\n    /// @param amount Asset amount\n    /// @return rsethAmountToMint Amount of rseth to mint\n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice helps user stake LST to the protocol\n    /// @param asset LST asset address to stake\n    /// @param depositAmount LST asset amount to stake\n    function depositAsset(\n        address asset,\n        uint256 depositAmount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n    {\n        // checks\n        if (depositAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (depositAmount > getAssetCurrentLimit(asset)) {\n            revert MaximumDepositLimitReached();\n        }\n\n        if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {\n            revert TokenTransferFailed();\n        }\n\n        // interactions\n        uint256 rsethAmountMinted = _mintRsETH(asset, depositAmount);\n\n        emit AssetDeposit(asset, depositAmount, rsethAmountMinted);\n    }\n\n    /// @dev private function to mint rseth. It calculates rseth amount to mint based on asset amount and asset exchange\n    /// rates from oracle\n    /// @param _asset Asset address\n    /// @param _amount Asset amount to mint rseth\n    /// @return rsethAmountToMint Amount of rseth minted\n    function _mintRsETH(address _asset, uint256 _amount) private returns (uint256 rsethAmountToMint) {\n        (rsethAmountToMint) = getRsETHAmountToMint(_asset, _amount);\n\n        address rsethToken = lrtConfig.rsETH();\n        // mint rseth for user\n        IRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);\n    }\n\n    /// @notice add new node delegator contract addresses\n    /// @dev only callable by LRT manager\n    /// @param nodeDelegatorContracts Array of NodeDelegator contract addresses\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContracts) external onlyLRTAdmin {\n        uint256 length = nodeDelegatorContracts.length;\n        if (nodeDelegatorQueue.length + length > maxNodeDelegatorCount) {\n            revert MaximumNodeDelegatorCountReached();\n        }\n\n        for (uint256 i; i < length;) {\n            UtilLib.checkNonZeroAddress(nodeDelegatorContracts[i]);\n            nodeDelegatorQueue.push(nodeDelegatorContracts[i]);\n            emit NodeDelegatorAddedinQueue(nodeDelegatorContracts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice transfers asset lying in this DepositPool to node delegator contract\n    /// @dev only callable by LRT manager\n    /// @param ndcIndex Index of NodeDelegator contract address in nodeDelegatorQueue\n    /// @param asset Asset address\n    /// @param amount Asset amount to transfer\n    function transferAssetToNodeDelegator(\n        uint256 ndcIndex,\n        address asset,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n        if (!IERC20(asset).transfer(nodeDelegator, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice update max node delegator count\n    /// @dev only callable by LRT admin\n    /// @param maxNodeDelegatorCount_ Maximum count of node delegator\n    function updateMaxNodeDelegatorCount(uint256 maxNodeDelegatorCount_) external onlyLRTAdmin {\n        maxNodeDelegatorCount = maxNodeDelegatorCount_;\n        emit MaxNodeDelegatorCountUpdated(maxNodeDelegatorCount);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    }
  ]
}