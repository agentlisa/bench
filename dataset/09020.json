{
  "Title": "[M-15] Wrong calculation for the new `rewardRate[token]` can cause some of the late users can not get their rewards",
  "Content": "_Submitted by WatchPug_\n\n```solidity\nuint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\nuint adjustedTstamp = block.timestamp < bribeStart ? bribeStart : bribeStart + 7 days;\nif (rewardRate[token] == 0) _writeRewardPerTokenCheckpoint(token, 0, adjustedTstamp);\n(rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n_claimFees();\n\nif (block.timestamp >= periodFinish[token]) {\n    _safeTransferFrom(token, msg.sender, address(this), amount);\n    rewardRate[token] = amount / DURATION;\n} else {\n    uint _remaining = periodFinish[token] - block.timestamp;\n    uint _left = _remaining * rewardRate[token];\n    require(amount > _left);\n    _safeTransferFrom(token, msg.sender, address(this), amount);\n    rewardRate[token] = (amount + _left) / DURATION;\n}\n```\n\nIn `Gauge.sol#notifyRewardAmount()`, the updated rewardRate for the token: `rewardRate[token]` is calculated based on the newly added amount of tokens (`amount`), the remaining amount of existing rewards (`_left`), and the `DURATION`.\n\nWhile the DURATION is `5 days`, the period from the current time to `periodFinish[token]` is much longer.\n\n`rewardPerToken()` is calculated based on the current time, `lastUpdateTime[token]`, and `rewardRate[token]`.\n\n[Gauge.sol#L375-L380](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L375-L380)<br>\n\n```solidity\nfunction rewardPerToken(address token) public view returns (uint) {\n    if (derivedSupply == 0) {\n        return rewardPerTokenStored[token];\n    }\n    return rewardPerTokenStored[token] + ((lastTimeRewardApplicable(token) - Math.min(lastUpdateTime[token], periodFinish[token])) * rewardRate[token] * PRECISION / derivedSupply);\n}\n```\n\n`lastUpdateTime[token]` will frequently be updated to the current timestamp by `_updateRewardForAllTokens()`.\n\nSee: [Gauge.sol#L460-L469](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L460-L469)<br>\n\nAs a result, `rewardPerToken()` can be much higher than expected, which makes the total amount of reward tokens less than the total amount of rewards accumulated by all the users.\n\nThis makes the users who claim the rewards later unable to retrieve their rewards as the balance can be insufficient.\n\n### Proof of Concept\n\n1.  Alice and Bob both deposited `1,000` stake token to Gauge at `1653091200` (May 21 2022 00:00:00 GMT+0000)\n\n2.  Admin called `notifyRewardAmount()` add 1,000 DAI at `1653100000` (May 21 2022 02:26:40 GMT+0000)\n\n*   `bribeStart` = 1653004800 (May 20 2022 00:00:00 GMT+0000)\n*   `adjustedTstamp` = 1653609600 (May 27 2022 00:00:00 GMT+0000)\n*   `periodFinish[DAI]` = 1654041600 (Jun 01 2022 00:00:00 GMT+0000)\n*   `lastUpdateTime[DAI]` = 1653100000\n*   `rewardRate[DAI]` = 1,000 \\* 1e18 / 432000 = 2314814814814815\n\n3.  Alice withdrawn and `getReward()` at `1654041800` Jun 01 2022 00:03:20 GMT+0000, get \\~1,000 DAI\n\n*   `rewardPerTokenStored[DAI]` = \\~1e18\n\n4.  Bob tried to `getReward()`, the transaction will revert due to insufficient balance.\n\n### Recommended Mitigation Steps\n\nConsider calculating `rewardRate` base on timeUntilNextPeriodFinish to next period finish:\n\n```solidity\nuint nextPeriodFinish = adjustedTstamp + DURATION;\nuint timeUntilNextPeriodFinish = nextPeriodFinish - block.timestamp;\nif (block.timestamp >= periodFinish[token]) {\n    _safeTransferFrom(token, msg.sender, address(this), amount);\n    rewardRate[token] = amount / timeUntilNextPeriodFinish;\n} else {\n    uint _remaining = periodFinish[token] - block.timestamp;\n    uint _left = _remaining * rewardRate[token];\n    require(amount > _left);\n    _safeTransferFrom(token, msg.sender, address(this), amount);\n    rewardRate[token] = (amount + _left) / timeUntilNextPeriodFinish;\n}\nrequire(rewardRate[token] > 0);\nuint balance = IERC20(token).balanceOf(address(this));\nrequire(rewardRate[token] <= balance / timeUntilNextPeriodFinish, \"Provided reward too high\");\nperiodFinish[token] = nextPeriodFinish;\n```\n\n**[pooltypes (Velodrome) acknowledged](https://github.com/code-423n4/2022-05-velodrome-findings/issues/186)**\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/186#issuecomment-1171835621):**\n > The warden has shown how a desynch between `periodFinish` and `DURATION` can cause rewards to be distributed faster than a reward period, leaving the last claimers unable to claim.\n> \n> While the loss in this scenario, to those claimers can be viewed as total, in reality those people will be able to claim on the next rewards round (unless no more tokens will be minted to that gauge, which is highly unlikely but possible).\n> \n> For that reason, I believe Medium Severity to be more appropriate, as this will be a temporary loss of yield which for some people may be permanent.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/Gauge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n// Gauges are used to incentivize pools, they emit reward tokens every 7 days for staked LP tokens\ncontract Gauge {\n\n    address public immutable stake; // the LP token that needs to be staked for rewards\n    address public immutable _ve; // the ve token used for gauges\n    address public immutable bribe;\n    address public immutable voter;\n    address immutable factory;\n    bool public isForPair;\n\n    uint public derivedSupply;\n    mapping(address => uint) public derivedBalances;\n\n    uint internal constant DURATION = 5 days; // rewards are released over the voting period\n    uint internal constant BRIBE_LAG = 1 days;\n    uint internal constant MAX_REWARD_TOKENS = 16;\n\n    enum VotingStage\n    {\n        BribesPhase,\n        VotesPhase,\n        RewardsPhase\n    }\n\n    uint internal constant PRECISION = 10 ** 18;\n\n    // default snx staking contract implementation\n    mapping(address => uint) public rewardRate;\n    mapping(address => uint) public periodFinish;\n    mapping(address => uint) public lastUpdateTime;\n    mapping(address => uint) public rewardPerTokenStored;\n\n    mapping(address => mapping(address => uint)) public lastEarn;\n    mapping(address => mapping(address => uint)) public userRewardPerTokenStored;\n\n    mapping(address => uint) public tokenIds;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    address[] public rewards;\n    mapping(address => bool) public isReward;\n\n    /// @notice A checkpoint for marking balance\n    struct Checkpoint {\n        uint timestamp;\n        uint balanceOf;\n        bool voted;\n    }\n\n    /// @notice A checkpoint for marking reward rate\n    struct RewardPerTokenCheckpoint {\n        uint timestamp;\n        uint rewardPerToken;\n    }\n\n    /// @notice A checkpoint for marking supply\n    struct SupplyCheckpoint {\n        uint timestamp;\n        uint supply;\n    }\n\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address => mapping (uint => Checkpoint)) public checkpoints;\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint) public numCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (uint => SupplyCheckpoint) public supplyCheckpoints;\n    /// @notice The number of checkpoints\n    uint public supplyNumCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (address => mapping (uint => RewardPerTokenCheckpoint)) public rewardPerTokenCheckpoints;\n    /// @notice The number of checkpoints for each token\n    mapping (address => uint) public rewardPerTokenNumCheckpoints;\n\n    uint public fees0;\n    uint public fees1;\n\n    event Deposit(address indexed from, uint tokenId, uint amount);\n    event Withdraw(address indexed from, uint tokenId, uint amount);\n    event NotifyReward(address indexed from, address indexed reward, uint amount);\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n    event ClaimRewards(address indexed from, address indexed reward, uint amount);\n\n    constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {\n        stake = _stake;\n        bribe = _bribe;\n        _ve = __ve;\n        voter = _voter;\n\n        factory = msg.sender;\n\n        IBribe(bribe).setGauge(address(this));\n        address _token = IVotingEscrow(_ve).token();\n        IBribe(bribe).addRewardToken(_token);\n        isReward[_token] = true;\n        rewards.push(_token);\n\n        isForPair = _isForPair;\n        if (isForPair) {\n            (address _token0, address _token1) = IPair(stake).tokens();\n            IBribe(bribe).addRewardToken(_token0);\n            isReward[_token0] = true;\n            rewards.push(_token0);\n            IBribe(bribe).addRewardToken(_token1);\n            isReward[_token1] = true;\n            rewards.push(_token1);\n        }\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function claimFees() external lock returns (uint claimed0, uint claimed1) {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint claimed0, uint claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n        (claimed0, claimed1) = IPair(stake).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint _fees0 = fees0 + claimed0;\n            uint _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPair(stake).tokens();\n            if (_fees0 / DURATION > 0) {\n                fees0 = 0;\n                _safeApprove(_token0, bribe, _fees0);\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 / DURATION > 0) {\n                fees1 = 0;\n                _safeApprove(_token1, bribe, _fees1);\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n    function getVotingStage(uint timestamp) public pure returns (VotingStage) {\n        uint modTime = timestamp % (7 days);\n        if (modTime < BRIBE_LAG) {\n            return VotingStage.BribesPhase;\n        } else if (modTime > (BRIBE_LAG + DURATION)) {\n            return VotingStage.RewardsPhase;\n        }\n        return VotingStage.VotesPhase;\n    }\n\n    function deliverBribes() external lock {\n        require(msg.sender == voter);\n        IBribe sb = IBribe(bribe);\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint numRewards = sb.rewardsListLength();\n\n        for (uint i = 0; i < numRewards; i++) {\n            address token = sb.rewards(i);\n            uint epochRewards = sb.deliverReward(token, bribeStart);\n            if (epochRewards > 0) {\n                _notifyBribeAmount(token, epochRewards, bribeStart);\n            }\n        }\n    }\n\n    function setVoteStatus(address account, bool voted) external {\n        require(msg.sender == voter);\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            checkpoints[account][0] = Checkpoint(block.timestamp, 0, voted);\n            numCheckpoints[account] = 1;\n        } else {\n            checkpoints[account][nCheckpoints - 1].voted = voted;\n        }\n    }\n\n    /**\n    * @notice Determine the prior balance for an account as of a block number\n    * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    * @param account The address of the account to check\n    * @param timestamp The timestamp to get the balance at\n    * @return The balance the account had as of the given block\n    */\n    function getPriorBalanceIndex(address account, uint timestamp) public view returns (uint) {\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorSupplyIndex(uint timestamp) public view returns (uint) {\n        uint nCheckpoints = supplyNumCheckpoints;\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (supplyCheckpoints[0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorRewardPerToken(address token, uint timestamp) public view returns (uint, uint) {\n        uint nCheckpoints = rewardPerTokenNumCheckpoints[token];\n        if (nCheckpoints == 0) {\n            return (0,0);\n        }\n\n        // First check most recent balance\n        if (rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp <= timestamp) {\n            return (rewardPerTokenCheckpoints[token][nCheckpoints - 1].rewardPerToken, rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp);\n        }\n\n        // Next check implicit zero balance\n        if (rewardPerTokenCheckpoints[token][0].timestamp > timestamp) {\n            return (0,0);\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            RewardPerTokenCheckpoint memory cp = rewardPerTokenCheckpoints[token][center];\n            if (cp.timestamp == timestamp) {\n                return (cp.rewardPerToken, cp.timestamp);\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return (rewardPerTokenCheckpoints[token][lower].rewardPerToken, rewardPerTokenCheckpoints[token][lower].timestamp);\n    }\n\n    function _writeCheckpoint(address account, uint balance) internal {\n        uint _timestamp = block.timestamp;\n        uint _nCheckPoints = numCheckpoints[account];\n\n        if (_nCheckPoints > 0 && checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp) {\n            checkpoints[account][_nCheckPoints - 1].balanceOf = balance;\n        } else {\n            bool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;\n            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance, prevVoteStatus);\n            numCheckpoints[account] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeRewardPerTokenCheckpoint(address token, uint reward, uint timestamp) internal {\n        uint _nCheckPoints = rewardPerTokenNumCheckpoints[token];\n\n        if (_nCheckPoints > 0 && rewardPerTokenCheckpoints[token][_nCheckPoints - 1].timestamp == timestamp) {\n            rewardPerTokenCheckpoints[token][_nCheckPoints - 1].rewardPerToken = reward;\n        } else {\n            rewardPerTokenCheckpoints[token][_nCheckPoints] = RewardPerTokenCheckpoint(timestamp, reward);\n            rewardPerTokenNumCheckpoints[token] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeSupplyCheckpoint() internal {\n        uint _nCheckPoints = supplyNumCheckpoints;\n        uint _timestamp = block.timestamp;\n\n        if (_nCheckPoints > 0 && supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp) {\n            supplyCheckpoints[_nCheckPoints - 1].supply = derivedSupply;\n        } else {\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(_timestamp, derivedSupply);\n            supplyNumCheckpoints = _nCheckPoints + 1;\n        }\n    }\n\n    function rewardsListLength() external view returns (uint) {\n        return rewards.length;\n    }\n\n    // returns the last time the reward was modified or periodFinish if the reward has ended\n    function lastTimeRewardApplicable(address token) public view returns (uint) {\n        return Math.min(block.timestamp, periodFinish[token]);\n    }\n\n    function getReward(address account, address[] memory tokens) external lock {\n        require(msg.sender == account || msg.sender == voter);\n        _unlocked = 1;\n        IVoter(voter).distribute(address(this));\n        _unlocked = 2;\n\n        for (uint i = 0; i < tokens.length; i++) {\n            (rewardPerTokenStored[tokens[i]], lastUpdateTime[tokens[i]]) = _updateRewardPerToken(tokens[i]);\n\n            uint _reward = earned(tokens[i], account);\n            lastEarn[tokens[i]][account] = block.timestamp;\n            userRewardPerTokenStored[tokens[i]][account] = rewardPerTokenStored[tokens[i]];\n            if (_reward > 0) _safeTransfer(tokens[i], account, _reward);\n\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\n        }\n\n        uint _derivedBalance = derivedBalances[account];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(account);\n        derivedBalances[account] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(account, derivedBalances[account]);\n        _writeSupplyCheckpoint();\n    }\n\n\n    function rewardPerToken(address token) public view returns (uint) {\n        if (derivedSupply == 0) {\n            return rewardPerTokenStored[token];\n        }\n        return rewardPerTokenStored[token] + ((lastTimeRewardApplicable(token) - Math.min(lastUpdateTime[token], periodFinish[token])) * rewardRate[token] * PRECISION / derivedSupply);\n    }\n\n    function derivedBalance(address account) public view returns (uint) {\n        return balanceOf[account];\n    }\n\n    function batchRewardPerToken(address token, uint maxRuns) external {\n        (rewardPerTokenStored[token], lastUpdateTime[token])  = _batchRewardPerToken(token, maxRuns);\n    }\n\n    function _batchRewardPerToken(address token, uint maxRuns) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = Math.min(supplyNumCheckpoints-1, maxRuns);\n\n        for (uint i = _startIndex; i < _endIndex; i++) {\n            SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n            if (sp0.supply > 0) {\n                SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                reward += _reward;\n                _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                _startTimestamp = _endTime;\n            }\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    function _calcRewardPerToken(address token, uint timestamp1, uint timestamp0, uint supply, uint startTimestamp) internal view returns (uint, uint) {\n        uint endTime = Math.max(timestamp1, startTimestamp);\n        return (((Math.min(endTime, periodFinish[token]) - Math.min(Math.max(timestamp0, startTimestamp), periodFinish[token])) * rewardRate[token] * PRECISION / supply), endTime);\n    }\n\n    function _updateRewardForAllTokens() internal {\n        uint length = rewards.length;\n        for (uint i; i < length; i++) {\n            address token = rewards[i];\n            (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        }\n    }\n\n    function _updateRewardPerToken(address token) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = supplyNumCheckpoints-1;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n                if (sp0.supply > 0) {\n                    SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                    (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                    reward += _reward;\n                    _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                    _startTimestamp = _endTime;\n                }\n            }\n        }\n\n        SupplyCheckpoint memory sp = supplyCheckpoints[_endIndex];\n        if (sp.supply > 0) {\n            (uint _reward,) = _calcRewardPerToken(token, lastTimeRewardApplicable(token), Math.max(sp.timestamp, _startTimestamp), sp.supply, _startTimestamp);\n            reward += _reward;\n            _writeRewardPerTokenCheckpoint(token, reward, block.timestamp);\n            _startTimestamp = block.timestamp;\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    // earned is an estimation, it won't be exact till the supply > rewardPerToken calculations have run\n    function earned(address token, address account) public view returns (uint) {\n        uint _startTimestamp = Math.max(lastEarn[token][account], rewardPerTokenCheckpoints[token][0].timestamp);\n        if (numCheckpoints[account] == 0) {\n            return 0;\n        }\n\n        uint _startIndex = getPriorBalanceIndex(account, _startTimestamp);\n        uint _endIndex = numCheckpoints[account]-1;\n\n        uint reward = 0;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                Checkpoint memory cp0 = checkpoints[account][i];\n                Checkpoint memory cp1 = checkpoints[account][i+1];\n                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);\n                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);\n                if (cp0.voted) {\n                    reward += cp0.balanceOf * (_rewardPerTokenStored1 - _rewardPerTokenStored0) / PRECISION;\n                }\n            }\n        }\n\n        Checkpoint memory cp = checkpoints[account][_endIndex];\n        uint lastCpWeeksVoteEnd = cp.timestamp - (cp.timestamp % (7 days)) + BRIBE_LAG + DURATION;\n        if (block.timestamp > lastCpWeeksVoteEnd) {\n            (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);\n            if (cp.voted) {\n                reward += cp.balanceOf * (rewardPerToken(token) - Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][account])) / PRECISION;\n            }\n        }\n\n        return reward;\n    }\n\n    function depositAll(uint tokenId) external {\n        deposit(IERC20(stake).balanceOf(msg.sender), tokenId);\n    }\n\n    function deposit(uint amount, uint tokenId) public lock {\n        require(amount > 0);\n\n        _updateRewardForAllTokens();\n\n        _safeTransferFrom(stake, msg.sender, address(this), amount);\n        totalSupply += amount;\n        balanceOf[msg.sender] += amount;\n\n        if (tokenId > 0) {\n            require(IVotingEscrow(_ve).ownerOf(tokenId) == msg.sender);\n            if (tokenIds[msg.sender] == 0) {\n                tokenIds[msg.sender] = tokenId;\n                IVoter(voter).attachTokenToGauge(tokenId, msg.sender);\n            }\n            require(tokenIds[msg.sender] == tokenId);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, _derivedBalance);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitDeposit(tokenId, msg.sender, amount);\n        emit Deposit(msg.sender, tokenId, amount);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf[msg.sender]);\n    }\n\n    function withdraw(uint amount) public {\n        _updateRewardForAllTokens();\n\n        uint tokenId = 0;\n        if (amount == balanceOf[msg.sender]) {\n            tokenId = tokenIds[msg.sender];\n        }\n        withdrawToken(amount, tokenId);\n    }\n\n    function withdrawToken(uint amount, uint tokenId) public lock {\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;\n        _safeTransfer(stake, msg.sender, amount);\n\n        if (tokenId > 0) {\n            require(tokenId == tokenIds[msg.sender]);\n            tokenIds[msg.sender] = 0;\n            IVoter(voter).detachTokenFromGauge(tokenId, msg.sender);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, derivedBalances[msg.sender]);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitWithdraw(tokenId, msg.sender, amount);\n        emit Withdraw(msg.sender, tokenId, amount);\n    }\n\n    function left(address token) external view returns (uint) {\n        if (block.timestamp >= periodFinish[token]) return 0;\n        uint _remaining = periodFinish[token] - block.timestamp;\n        return _remaining * rewardRate[token];\n    }\n\n    function notifyRewardAmount(address token, uint amount) external lock {\n        require(token != stake);\n        require(amount > 0);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n        }\n        // rewards accrue only during the bribe period\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint adjustedTstamp = block.timestamp < bribeStart ? bribeStart : bribeStart + 7 days;\n        if (rewardRate[token] == 0) _writeRewardPerTokenCheckpoint(token, 0, adjustedTstamp);\n        (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        _claimFees();\n\n        if (block.timestamp >= periodFinish[token]) {\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n        require(rewardRate[token] > 0);\n        uint balance = IERC20(token).balanceOf(address(this));\n        require(rewardRate[token] <= balance / DURATION, \"Provided reward too high\");\n        periodFinish[token] = adjustedTstamp + DURATION;\n        if (!isReward[token]) {\n            isReward[token] = true;\n            rewards.push(token);\n            IBribe(bribe).addRewardToken(token);\n        }\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        require(rewards[i] == oldToken);\n        isReward[oldToken] = false;\n        isReward[newToken] = true;\n        rewards[i] = newToken;\n    }\n\n    function swapOutBribeRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        IBribe(bribe).swapOutRewardToken(i, oldToken, newToken);\n    }\n\n    function addBribeRewardToken(address token) external {\n        require(msg.sender == bribe);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n            isReward[token] = true;\n            rewards.push(token);\n        }\n    }\n\n    function _notifyBribeAmount(address token, uint amount, uint epochStart) internal {\n        if (block.timestamp >= periodFinish[token]) {\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n\n        lastUpdateTime[token] = epochStart;\n        periodFinish[token] = epochStart + DURATION;\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeApprove(address token, address spender, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}"
    },
    {
      "filename": "contracts/contracts/Gauge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n// Gauges are used to incentivize pools, they emit reward tokens every 7 days for staked LP tokens\ncontract Gauge {\n\n    address public immutable stake; // the LP token that needs to be staked for rewards\n    address public immutable _ve; // the ve token used for gauges\n    address public immutable bribe;\n    address public immutable voter;\n    address immutable factory;\n    bool public isForPair;\n\n    uint public derivedSupply;\n    mapping(address => uint) public derivedBalances;\n\n    uint internal constant DURATION = 5 days; // rewards are released over the voting period\n    uint internal constant BRIBE_LAG = 1 days;\n    uint internal constant MAX_REWARD_TOKENS = 16;\n\n    enum VotingStage\n    {\n        BribesPhase,\n        VotesPhase,\n        RewardsPhase\n    }\n\n    uint internal constant PRECISION = 10 ** 18;\n\n    // default snx staking contract implementation\n    mapping(address => uint) public rewardRate;\n    mapping(address => uint) public periodFinish;\n    mapping(address => uint) public lastUpdateTime;\n    mapping(address => uint) public rewardPerTokenStored;\n\n    mapping(address => mapping(address => uint)) public lastEarn;\n    mapping(address => mapping(address => uint)) public userRewardPerTokenStored;\n\n    mapping(address => uint) public tokenIds;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    address[] public rewards;\n    mapping(address => bool) public isReward;\n\n    /// @notice A checkpoint for marking balance\n    struct Checkpoint {\n        uint timestamp;\n        uint balanceOf;\n        bool voted;\n    }\n\n    /// @notice A checkpoint for marking reward rate\n    struct RewardPerTokenCheckpoint {\n        uint timestamp;\n        uint rewardPerToken;\n    }\n\n    /// @notice A checkpoint for marking supply\n    struct SupplyCheckpoint {\n        uint timestamp;\n        uint supply;\n    }\n\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address => mapping (uint => Checkpoint)) public checkpoints;\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint) public numCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (uint => SupplyCheckpoint) public supplyCheckpoints;\n    /// @notice The number of checkpoints\n    uint public supplyNumCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (address => mapping (uint => RewardPerTokenCheckpoint)) public rewardPerTokenCheckpoints;\n    /// @notice The number of checkpoints for each token\n    mapping (address => uint) public rewardPerTokenNumCheckpoints;\n\n    uint public fees0;\n    uint public fees1;\n\n    event Deposit(address indexed from, uint tokenId, uint amount);\n    event Withdraw(address indexed from, uint tokenId, uint amount);\n    event NotifyReward(address indexed from, address indexed reward, uint amount);\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n    event ClaimRewards(address indexed from, address indexed reward, uint amount);\n\n    constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {\n        stake = _stake;\n        bribe = _bribe;\n        _ve = __ve;\n        voter = _voter;\n\n        factory = msg.sender;\n\n        IBribe(bribe).setGauge(address(this));\n        address _token = IVotingEscrow(_ve).token();\n        IBribe(bribe).addRewardToken(_token);\n        isReward[_token] = true;\n        rewards.push(_token);\n\n        isForPair = _isForPair;\n        if (isForPair) {\n            (address _token0, address _token1) = IPair(stake).tokens();\n            IBribe(bribe).addRewardToken(_token0);\n            isReward[_token0] = true;\n            rewards.push(_token0);\n            IBribe(bribe).addRewardToken(_token1);\n            isReward[_token1] = true;\n            rewards.push(_token1);\n        }\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function claimFees() external lock returns (uint claimed0, uint claimed1) {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint claimed0, uint claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n        (claimed0, claimed1) = IPair(stake).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint _fees0 = fees0 + claimed0;\n            uint _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPair(stake).tokens();\n            if (_fees0 / DURATION > 0) {\n                fees0 = 0;\n                _safeApprove(_token0, bribe, _fees0);\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 / DURATION > 0) {\n                fees1 = 0;\n                _safeApprove(_token1, bribe, _fees1);\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n    function getVotingStage(uint timestamp) public pure returns (VotingStage) {\n        uint modTime = timestamp % (7 days);\n        if (modTime < BRIBE_LAG) {\n            return VotingStage.BribesPhase;\n        } else if (modTime > (BRIBE_LAG + DURATION)) {\n            return VotingStage.RewardsPhase;\n        }\n        return VotingStage.VotesPhase;\n    }\n\n    function deliverBribes() external lock {\n        require(msg.sender == voter);\n        IBribe sb = IBribe(bribe);\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint numRewards = sb.rewardsListLength();\n\n        for (uint i = 0; i < numRewards; i++) {\n            address token = sb.rewards(i);\n            uint epochRewards = sb.deliverReward(token, bribeStart);\n            if (epochRewards > 0) {"
    }
  ]
}