{
  "Title": "M-1: `accPointsPerShare` can reach a very large value leading to overflows",
  "Content": "# Issue M-1: `accPointsPerShare` can reach a very large value leading to overflows \n\nSource: https://github.com/sherlock-audit/2024-05-sophon-judging/issues/36 \n\n## Found by \nZdravkoHr.\n## Summary\nEach pool tracks the amount of points that should be distributed for one share of its LP token in the `accPointsPerShare` variable. This variable can reach very large values causing integer overflows. This is dangerous as it puts the protocol's functionality at great risks.\n\n## Vulnerability Detail\nThis is the code that calculates `accPointsPerShare`. `pointReward` is a variable with 36 decimals precision because `blockMultiplier` and `pointsPerBlock` have both 18 decimals. The result is then divided by `lpSupply`. \n```solidity\n        uint256 blockMultiplier = _getBlockMultiplier(pool.lastRewardBlock, getBlockNumber());\n        uint256 pointReward =\n            blockMultiplier *\n            _pointsPerBlock *\n            _allocPoint /\n            totalAllocPoint;\n\n        pool.accPointsPerShare = pointReward /\n            lpSupply +\n            pool.accPointsPerShare;\n```\n\nThe problem with this approach is that lpSupply can be a small value. It can happen either naturally (for example, tokens with low decimals, like USDC and USDT) or on purpose (by a malicious depositor).\n\nThe malicious depositor can deposit just 1 wei of the lp token and wait 1 block to update the `accPointsPerShare` variable. Since `lpSupply` will be equal to 1, `accPointsPerShare` will remain a value with 36 decimals.\n\nLet's now have a look at [pendingPoints()](https://github.com/sherlock-audit/2024-05-sophon/blob/05059e53755f24ae9e3a3bb2996de15df0289a6c/farming-contracts/contracts/farm/SophonFarming.sol#L357C1-L385C1)\n```solidity\n    function _pendingPoints(uint256 _pid, address _user) internal view returns (uint256) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n\n        uint256 accPointsPerShare = pool.accPointsPerShare * 1e18;\n\n        uint256 lpSupply = pool.amount;\n        if (getBlockNumber() > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 blockMultiplier = _getBlockMultiplier(pool.lastRewardBlock, getBlockNumber());\n\n            uint256 pointReward =\n                blockMultiplier *\n                pointsPerBlock *\n                pool.allocPoint /\n                totalAllocPoint;\n\n            accPointsPerShare = pointReward *\n                1e18 /\n                lpSupply +\n                accPointsPerShare;\n        }\n\n        return user.amount *\n            accPointsPerShare /\n            1e36 +\n            user.rewardSettled -\n            user.rewardDebt;\n    }\n\n```\n`pool.accPointsPerShare` is multipled by 1e18 once again, resulting in 54 decimals. This is not the end, in the return statement this value will be multiplied once again by `user.amount.` Depending on the token's decimals, the value will be scaled again. For 18 decimals, the value will reach 72 decimals. This will result in unexpected overflows because `type(uint256).max < 1e78`  \n\n\n```solidity\n        return user.amount *\n            accPointsPerShare \n```\n\n## Proof of Concept\nIn this test a first depositor deposits 1 wei worth of our Mock token to inflate the `accPointsPerShare`. In the next block, a honest depositor deposits `10_000` tokens. When `pendingPoints` is called, the transaction reverts because of an overflow.\n```solidity\n    function testOverflow() public {\n        vm.startPrank(deployer);\n        MockERC20 usdc = new MockERC20(\"Mock USDC Token\", \"MockUSDC\", 18);\n        usdc.mint(address(deployer), 10000e18);\n        dai.mint(address(deployer), 1000e18);\n\n        uint256 usdcId = sophonFarming.add(60000, address(usdc), \"\", false);\n\n        dai.approve(address(sophonFarming), 1000e18);\n        usdc.approve(address(sophonFarming), 10000e18);\n\n        sophonFarming.depositDai(1000e18, 0);\n        sophonFarming.deposit(usdcId, 1, 0);\n\n        vm.roll(block.number + 1);\n\n        sophonFarming.massUpdatePools();\n\n        address[] memory users = new address[](1);\n        users[0] = deployer;\n\n        uint256[][] memory pendingPoints = sophonFarming.getPendingPoints(\n            users\n        );\n\n        for (uint i = 0; i < pendingPoints.length; i++) {\n            uint256 poolsLength = pendingPoints[i].length;\n\n            for (uint j = 0; j < poolsLength; j++) {\n                uint256 currentPoints = pendingPoints[i][j];\n                console.log(currentPoints);\n            }\n        }\n\n        sophonFarming.deposit(usdcId, 10000e18 - 1, 0);\n\n        vm.roll(block.number + 1);\n\n        sophonFarming.massUpdatePools();\n\n        pendingPoints = sophonFarming.getPendingPoints(users);\n\n        for (uint i = 0; i < pendingPoints.length; i++) {\n            uint256 poolsLength = pendingPoints[i].length;\n\n            for (uint j = 0; j < poolsLength; j++) {\n                uint256 currentPoints = pendingPoints[i][j];\n                console.log(currentPoints);\n            }\n        }\n    }\n```\n\n## Impact\nThe `accPointsPerShare` variable becomes too large and breaks contract functionality\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-05-sophon/blob/05059e53755f24ae9e3a3bb2996de15df0289a6c/farming-contracts/contracts/farm/SophonFarming.sol#L423-L432\nhttps://github.com/sherlock-audit/2024-05-sophon/blob/05059e53755f24ae9e3a3bb2996de15df0289a6c/farming-contracts/contracts/farm/SophonFarming.sol#L357C1-L385C1\n## Tool used\n\nManual Review\n\n## Recommendation\nA possible solution may be to set a floor that a user has to deposit and also scale by a smaller value.\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  invalid because getPendingPoints() will not practically be used till point farming has ended. The higher precision adopted is by design\n\n**0xreadyplayer1** commented:\n>  even in the stated case - being the worst - the value goes uptil 1e72 and not 1e77 which is needed for overflow - the issue might exist but the watson was not able to clearly show the exploit about what happens if the price goes this large.\n\n\n\n**ZdravkoHr**\n\nEscalate\nThe value 1e72 will be multiplied by the user amount, thus causing the overflow as in the provided proof of concept.\n\n**sherlock-admin3**\n\n> Escalate\n> The value 1e72 will be multiplied by the user amount, thus causing the overflow as in the provided proof of concept.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mystery0x**\n\nThe extreme edge case isn't going to happen. You see, the user amount is only 1 wei when multiplying with the inflated accPointsPerShare (due to division by 1 wei of `lpSupply`). \n\nSo, when `user.amount` and `pool.amount` become sizable amounts (updated via the next [`_deposit()`](https://github.com/sherlock-audit/2024-05-sophon/blob/05059e53755f24ae9e3a3bb2996de15df0289a6c/farming-contracts/contracts/farm/SophonFarming.sol#L616-L617), `lpSupply` will no longer be 1 wei but rather whatever that has been last updated on [`pool.amount`](https://github.com/sherlock-audit/2024-05-sophon/blob/05059e53755f24ae9e3a3bb2996de15df0289a6c/farming-contracts/contracts/farm/SophonFarming.sol#L363) in `_pendingPoints()`.\n\n**WangSecurity**\n\nDo I understand correctly that the user still can deposit into the protocol by dividing their deposit into several ones? So they can successfully deposit all 10_000 tokens as the POC and later users will not have problems? @ZdravkoHr is it correct or not?\n\nAnd @mystery0x as I understand, user.amount and pool.amount will be updated after the point when the revert happens, no? Cause if what you're saying is correct, the POC wouldn't work, no? Or the POC is wrong?\n\n**ZdravkoHr**\n\nWhen lpSupply becomes an 1e18 value, the accPointsPerShare will already be a very large value because in the updatePool function the amount is being added, not overwritten.\n\n@WangSecurity, the problem is not that the user can't deposit, but that getPendingPoints will revert when the whole process depends on it\n\n**mystery0x**\n\n> When lpSupply becomes an 1e18 value, the accPointsPerShare will already be a very large value because in the updatePool function the amount is being added, not overwritten.\n\nCan you run the test and show us the result reverting? I don’t think it’s going to be a problem since division by lpSupply (1e18) at this point is going to make accPointsPerShare diminished prior to having it multiplied to user.amount.\n\n**ZdravkoHr**\n\nThe division by `1e18` will reduce the decimals of the `pointReward`, however this result will be added to the already big enough `pool.accPointsPerShare` value because there is an addition operation.\n\nHere is the result of the PoC: \n![image](https://github.com/sherlock-audit/2024-05-sophon-judging/assets/42611094/b239619a-02cb-41ad-8336-a2d967927598)\n\n\n**mystery0x**\n\n@ZdravkoHr Hmm... addition would cause overflow for the max value of uint256?\n\nWe agree that the first addend `user.amount * accPointsPerShare /1e36` is already curbed after the second call. How big can the second addend `user.rewardSettled` initially go? Can you plug in some practical numbers for these two addends and then the summation of both?\n\n```\n        return user.amount *\n            accPointsPerShare /\n            1e36 +\n            user.rewardSettled -\n            user.rewardDebt;\n```\n\n**ZdravkoHr**\n\nBut how is the first calculation curbed if there is an addition in any subsequent call and not assignment? The value will babe large decimals initially and will continue growing, there seems to be no way to decrease it\n\n**mystery0x**\n\n> But how is the first calculation curbed if there is an addition in any subsequent call and not assignment? The value will babe large decimals initially and will continue growing, there seems to be no way to decrease it\n\n`pointReward * 1e18 / lpSupply` is trivial as `lpSupply` is no longer 1 wei but 1e18:\n\n```\n            accPointsPerShare = pointReward *\n                1e18 /\n                lpSupply +\n                accPointsPerShare;\n```\nJust plug in some numbers, and I'm sure no issues are going to be found. You're not multiplying two big numbers (rather just adding) in the last arithmetic operation of function `_pendingPoints`: \n\n```\n        return user.amount *\n            accPointsPerShare /\n            1e36 +\n            user.rewardSettled -\n            user.rewardDebt;\n```\n\n**ZdravkoHr**\n\nWith the default values from the tests, pointsPerBlock = 25e18 and allocation of 50%.\naccPointsPerShare = 12.5e36\n\nUsers deposit and this value becomes > 12.5e36\n\nThen we go here\n```\n        uint256 accPointsPerShare = pool.accPointsPerShare * 1e18;\n         ...\n        return user.amount *\n            accPointsPerShare /\n            1e36 +\n            user.rewardSettled -\n            user.rewardDebt;\n```\nLet user amount be 10_000e18 = 1e22. Then we have\n`1e22 * 12.5e54` which is greater than `type(uint256.max)`\n![image](https://github.com/sherlock-audit/2024-05-sophon-judging/assets/42611094/dd0ca202-1803-4a26-9a2e-7207df18e3a6)\n\nHere are logs from the PoC:\n![image](https://github.com/sherlock-audit/2024-05-sophon-judging/assets/42611094/d1a2a34e-04a7-4a3d-8542-a1d135b3e749)\n\n\n\n\n**mystery0x**\n\nAh, ok. @RomanHiden you might want to look into this edge issue in `_pendingPoints()`. \n\n**WangSecurity**\n\nBased on the above discussion, I agree with the escalation.\n\nPlanning to accept it and validate with medium severity. Are there any duplicates of it?\n\n**ZdravkoHr**\n\n@WangSecurity, just searched for `getPendingPoints` and couldn't find a duplicate (there were 16 results). Maybe if @mystery0x knows of some\n\n**mystery0x**\n\nMany other reports touched on the topic but none of them identified the 1 wei culprit from the first and only depositor in the initial block(s).\n\nIt's noteworthy that the suggested mitigation, \"to set a floor that a user has to deposit\" will also solve the issues associated with #85 and #177. \n\n**WangSecurity**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ZdravkoHr](https://github.com/sherlock-audit/2024-05-sophon-judging/issues/36/#issuecomment-2145925136): accepted\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/sophon-org/farming-contracts/commit/f0b82fd83a5d85eb8dc7ba2bbce2d49fefb326a4\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/376",
  "Code": [
    {
      "filename": "farming-contracts/contracts/farm/SophonFarming.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IWeth.sol\";\nimport \"./interfaces/IstETH.sol\";\nimport \"./interfaces/IwstETH.sol\";\nimport \"./interfaces/IsDAI.sol\";\nimport \"./interfaces/IeETHLiquidityPool.sol\";\nimport \"./interfaces/IweETH.sol\";\nimport \"../proxies/Upgradeable2Step.sol\";\nimport \"./SophonFarmingState.sol\";\n\n/**\n * @title Sophon Farming Contract\n * @author Sophon\n */\ncontract SophonFarming is Upgradeable2Step, SophonFarmingState {\n    using SafeERC20 for IERC20;\n\n    /// @notice Emitted when a new pool is added\n    event Add(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n\n    /// @notice Emitted when a pool is updated\n    event Set(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n\n    /// @notice Emitted when a user deposits to a pool\n    event Deposit(address indexed user, uint256 indexed pid, uint256 depositAmount, uint256 boostAmount);\n\n    /// @notice Emitted when a user withdraws from a pool\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    /// @notice Emitted when a user increases the boost of an existing deposit\n    event IncreaseBoost(address indexed user, uint256 indexed pid, uint256 boostAmount);\n\n    /// @notice Emitted when all pool funds are bridged to Sophon blockchain\n    event Bridge(address indexed user, uint256 indexed pid, uint256 amount);\n\n    /// @notice Emitted when the admin withdraws booster proceeds\n    event WithdrawProceeds(uint256 indexed pid, uint256 proceeds);\n\n    error PoolExists();\n    error PoolDoesNotExist();\n    error AlreadyInitialized();\n    error NotFound(address lpToken);\n    error FarmingIsStarted();\n    error FarmingIsEnded();\n    error InvalidStartBlock();\n    error InvalidEndBlock();\n    error InvalidDeposit();\n    error InvalidBooster();\n    error WithdrawNotAllowed();\n    error WithdrawTooHigh(uint256 maxAllowed);\n    error WithdrawIsZero();\n    error NothingInPool();\n    error NoEthSent();\n    error BoostTooHigh(uint256 maxAllowed);\n    error BoostIsZero();\n    error BridgeInvalid();\n\n    address public immutable dai;\n    address public immutable sDAI;\n    address public immutable weth;\n    address public immutable stETH;\n    address public immutable wstETH;\n    address public immutable eETH;\n    address public immutable eETHLiquidityPool;\n    address public immutable weETH;\n\n    /**\n     * @notice Construct SophonFarming\n     * @param tokens_ Immutable token addresses\n     * @dev 0:dai, 1:sDAI, 2:weth, 3:stETH, 4:wstETH, 5:eETH, 6:eETHLiquidityPool, 7:weETH\n     */\n    constructor(address[8] memory tokens_) {\n        dai = tokens_[0];\n        sDAI = tokens_[1];\n        weth = tokens_[2];\n        stETH = tokens_[3];\n        wstETH = tokens_[4];\n        eETH = tokens_[5];\n        eETHLiquidityPool = tokens_[6];\n        weETH = tokens_[7];\n    }\n\n    /**\n     * @notice Allows direct deposits of ETH for deposit to the wstETH pool\n     */\n    receive() external payable {\n        if (msg.sender == weth) {\n            return;\n        }\n\n        depositEth(0, PredefinedPool.wstETH);\n    }\n\n    /**\n     * @notice Initialize the farm\n     * @param ethAllocPoint_ eth alloc points\n     * @param sDAIAllocPoint_ sdai alloc points\n     * @param _pointsPerBlock points per block\n     * @param _startBlock start block\n     * @param _boosterMultiplier booster multiplier\n     */\n    function initialize(uint256 ethAllocPoint_, uint256 sDAIAllocPoint_, uint256 _pointsPerBlock, uint256 _startBlock, uint256 _boosterMultiplier) public virtual onlyOwner {\n        if (_initialized) {\n            revert AlreadyInitialized();\n        }\n\n        pointsPerBlock = _pointsPerBlock;\n\n        if (_startBlock == 0) {\n            revert InvalidStartBlock();\n        }\n        startBlock = _startBlock;\n\n        if (_boosterMultiplier < 1e18) {\n            revert InvalidBooster();\n        }\n        boosterMultiplier = _boosterMultiplier;\n\n        poolExists[dai] = true;\n        poolExists[weth] = true;\n        poolExists[stETH] = true;\n        poolExists[eETH] = true;\n\n        // sDAI\n        typeToId[PredefinedPool.sDAI] = add(sDAIAllocPoint_, sDAI, \"sDAI\", false);\n        IERC20(dai).approve(sDAI, 2**256-1);\n\n        // wstETH\n        typeToId[PredefinedPool.wstETH] = add(ethAllocPoint_, wstETH, \"wstETH\", false);\n        IERC20(stETH).approve(wstETH, 2**256-1);\n\n        // weETH\n        typeToId[PredefinedPool.weETH] = add(ethAllocPoint_, weETH, \"weETH\", false);\n        IERC20(eETH).approve(weETH, 2**256-1);\n\n        _initialized = true;\n    }\n\n    /**\n     * @notice Adds a new pool to the farm. Can only be called by the owner.\n     * @param _allocPoint alloc point for new pool\n     * @param _lpToken lpToken address\n     * @param _description description of new pool\n     * @param _withUpdate True will update accounting for all pools\n     * @return uint256 The pid of the newly created asset\n     */\n    function add(uint256 _allocPoint, address _lpToken, string memory _description, bool _withUpdate) public onlyOwner returns (uint256) {\n        if (poolExists[_lpToken]) {\n            revert PoolExists();\n        }\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 lastRewardBlock =\n            getBlockNumber() > startBlock ? getBlockNumber() : startBlock;\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n        poolExists[_lpToken] = true;\n\n        uint256 pid = poolInfo.length;\n\n        poolInfo.push(\n            PoolInfo({\n                lpToken: IERC20(_lpToken),\n                l2Farm: address(0),\n                amount: 0,\n                boostAmount: 0,\n                depositAmount: 0,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accPointsPerShare: 0,\n                description: _description\n            })\n        );\n\n        emit Add(_lpToken, pid, _allocPoint);\n\n        return pid;\n    }\n\n    /**\n     * @notice Updates the given pool's allocation point. Can only be called by the owner.\n     * @param _pid The pid to update\n     * @param _allocPoint The new alloc point to set for the pool\n     * @param _withUpdate True will update accounting for all pools\n     */\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        address lpToken = address(pool.lpToken);\n        if (lpToken == address(0) || !poolExists[lpToken]) {\n            revert PoolDoesNotExist();\n        }\n        totalAllocPoint = totalAllocPoint - pool.allocPoint + _allocPoint;\n        pool.allocPoint = _allocPoint;\n\n        if (getBlockNumber() < pool.lastRewardBlock) {\n            pool.lastRewardBlock = startBlock;\n        }\n\n        emit Set(lpToken, _pid, _allocPoint);\n    }\n\n    /**\n     * @notice Returns the number of pools in the farm\n     * @return uint256 number of pools\n     */\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /**\n     * @notice Checks if farming is ended\n     * @return bool True if farming is ended\n     */\n    function isFarmingEnded() public view returns (bool) {\n        uint256 _endBlock = endBlock;\n        if (_endBlock != 0 && getBlockNumber() > _endBlock) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Checks if the withdrawal period is ended\n     * @return bool True if withdrawal period is ended\n     */\n    function isWithdrawPeriodEnded() public view returns (bool) {\n        uint256 _endBlockForWithdrawals = endBlockForWithdrawals;\n        if (_endBlockForWithdrawals != 0 && getBlockNumber() > _endBlockForWithdrawals) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Updates the bridge contract\n     */\n    function setBridge(BridgeLike _bridge) public onlyOwner {\n        bridge = _bridge;\n    }\n\n    /**\n     * @notice Updates the L2 Farm for the pool\n     * @param _pid the pid\n     * @param _l2Farm the l2Farm address\n     */\n    function setL2FarmForPool(uint256 _pid, address _l2Farm) public onlyOwner {\n        poolInfo[_pid].l2Farm = _l2Farm;\n    }\n\n    /**\n     * @notice Set the start block of the farm\n     * @param _startBlock the start block\n     */\n    function setStartBlock(uint256 _startBlock) public onlyOwner {\n        if (_startBlock == 0 || (endBlock != 0 && _startBlock >= endBlock)) {\n            revert InvalidStartBlock();\n        }\n        if (getBlockNumber() > startBlock) {\n            revert FarmingIsStarted();\n        }\n        startBlock = _startBlock;\n    }\n\n    /**\n     * @notice Set the end block of the farm\n     * @param _endBlock the end block\n     * @param _withdrawalBlocks the last block that withdrawals are allowed\n     */\n    function setEndBlock(uint256 _endBlock, uint256 _withdrawalBlocks) public onlyOwner {\n        uint256 _endBlockForWithdrawals;\n        if (_endBlock != 0) {\n            if (_endBlock <= startBlock || getBlockNumber() > _endBlock) {\n                revert InvalidEndBlock();\n            }\n            if (isFarmingEnded()) {\n                revert FarmingIsEnded();\n            }\n            _endBlockForWithdrawals = _endBlock + _withdrawalBlocks;\n        } else {\n            // withdrawal blocks needs an endBlock\n            _endBlockForWithdrawals = 0;\n        }\n        massUpdatePools();\n        endBlock = _endBlock;\n        endBlockForWithdrawals = _endBlockForWithdrawals;\n    }\n\n    /**\n     * @notice Set points per block\n     * @param _pointsPerBlock points per block to set\n     */\n    function setPointsPerBlock(uint256 _pointsPerBlock) public onlyOwner {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        massUpdatePools();\n        pointsPerBlock = _pointsPerBlock;\n    }\n\n    /**\n     * @notice Set booster multiplier\n     * @param _boosterMultiplier booster multiplier to set\n     */\n    function setBoosterMultiplier(uint256 _boosterMultiplier) public onlyOwner {\n        if (_boosterMultiplier < 1e18) {\n            revert InvalidBooster();\n        }\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        massUpdatePools();\n        boosterMultiplier = _boosterMultiplier;\n    }\n\n    /**\n     * @notice Returns the block multiplier\n     * @param _from from block\n     * @param _to to block\n     * @return uint256 The block multiplier\n     */\n    function _getBlockMultiplier(uint256 _from, uint256 _to) internal view returns (uint256) {\n        uint256 _endBlock = endBlock;\n        if (_endBlock != 0) {\n            _to = Math.min(_to, _endBlock);\n        }\n        if (_to > _from) {\n            return (_to - _from) * 1e18;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns pending points for user in a pool\n     * @param _pid pid of the pool\n     * @param _user user in the pool\n     * @return uint256 pendings points\n     */\n    function _pendingPoints(uint256 _pid, address _user) internal view returns (uint256) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n\n        uint256 accPointsPerShare = pool.accPointsPerShare * 1e18;\n\n        uint256 lpSupply = pool.amount;\n        if (getBlockNumber() > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 blockMultiplier = _getBlockMultiplier(pool.lastRewardBlock, getBlockNumber());\n\n            uint256 pointReward =\n                blockMultiplier *\n                pointsPerBlock *\n                pool.allocPoint /\n                totalAllocPoint;\n\n            accPointsPerShare = pointReward *\n                1e18 /\n                lpSupply +\n                accPointsPerShare;\n        }\n\n        return user.amount *\n            accPointsPerShare /\n            1e36 +\n            user.rewardSettled -\n            user.rewardDebt;\n    }\n\n    /**\n     * @notice Returns pending points for user in a pool\n     * @param _pid pid of the pool\n     * @param _user user in the pool\n     * @return uint256 pendings points\n     */\n    function pendingPoints(uint256 _pid, address _user) external view returns (uint256) {\n        return _pendingPoints(_pid, _user);\n    }\n\n    /**\n     * @notice Update accounting of all pools\n     */\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for(uint256 pid = 0; pid < length;) {\n            updatePool(pid);\n            unchecked { ++pid; }\n        }\n    }\n\n    /**\n     * @notice Updating accounting of a single pool\n     * @param _pid pid to update\n     */\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (getBlockNumber() <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.amount;\n        uint256 _pointsPerBlock = pointsPerBlock;\n        uint256 _allocPoint = pool.allocPoint;\n        if (lpSupply == 0 || _pointsPerBlock == 0 || _allocPoint == 0) {\n            pool.lastRewardBlock = getBlockNumber();\n            return;\n        }\n        uint256 blockMultiplier = _getBlockMultiplier(pool.lastRewardBlock, getBlockNumber());\n        uint256 pointReward =\n            blockMultiplier *\n            _pointsPerBlock *\n            _allocPoint /\n            totalAllocPoint;\n\n        pool.accPointsPerShare = pointReward /\n            lpSupply +\n            pool.accPointsPerShare;\n\n        pool.lastRewardBlock = getBlockNumber();\n    }\n\n    /**\n     * @notice Deposit assets to SophonFarming\n     * @param _pid pid of the pool\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function deposit(uint256 _pid, uint256 _amount, uint256 _boostAmount) external {\n        poolInfo[_pid].lpToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _deposit(_pid, _amount, _boostAmount);\n    }\n\n    /**\n     * @notice Deposit DAI to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function depositDai(uint256 _amount, uint256 _boostAmount) external {\n        IERC20(dai).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _depositPredefinedAsset(_amount, _amount, _boostAmount, PredefinedPool.sDAI);\n    }\n\n    /**\n     * @notice Deposit stETH to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function depositStEth(uint256 _amount, uint256 _boostAmount) external {\n        IERC20(stETH).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _depositPredefinedAsset(_amount, _amount, _boostAmount, PredefinedPool.wstETH);\n    }\n\n    /**\n     * @notice Deposit eETH to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function depositeEth(uint256 _amount, uint256 _boostAmount) external {\n        IERC20(eETH).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _depositPredefinedAsset(_amount, _amount, _boostAmount, PredefinedPool.weETH);\n    }\n\n    /**\n     * @notice Deposit ETH to SophonFarming when specifying a pool\n     * @param _boostAmount amount to boost\n     * @param _predefinedPool specific pool type to deposit to\n     */\n    function depositEth(uint256 _boostAmount, PredefinedPool _predefinedPool) public payable {\n        if (msg.value == 0) {\n            revert NoEthSent();\n        }\n\n        uint256 _finalAmount = msg.value;\n        if (_predefinedPool == PredefinedPool.wstETH) {\n            _finalAmount = _ethTOstEth(_finalAmount);\n        } else if (_predefinedPool == PredefinedPool.weETH) {\n            _finalAmount = _ethTOeEth(_finalAmount);\n        }\n\n        _depositPredefinedAsset(_finalAmount, msg.value, _boostAmount, _predefinedPool);\n    }\n\n    /**\n     * @notice Deposit WETH to SophonFarming when specifying a pool\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     * @param _predefinedPool specific pool type to deposit to\n     */\n    function depositWeth(uint256 _amount, uint256 _boostAmount, PredefinedPool _predefinedPool) external {\n        IERC20(weth).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        uint256 _finalAmount = _wethTOEth(_amount);\n        if (_predefinedPool == PredefinedPool.wstETH) {\n            _finalAmount = _ethTOstEth(_finalAmount);\n        } else if (_predefinedPool == PredefinedPool.weETH) {\n            _finalAmount = _ethTOeEth(_finalAmount);\n        }\n\n        _depositPredefinedAsset(_finalAmount, _amount, _boostAmount, _predefinedPool);\n    }\n\n    /**\n     * @notice Deposit a predefined asset to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _initalAmount amount of the deposit prior to conversions\n     * @param _boostAmount amount to boost\n     * @param _predefinedPool specific pool type to deposit to\n     */\n    function _depositPredefinedAsset(uint256 _amount, uint256 _initalAmount, uint256 _boostAmount, PredefinedPool _predefinedPool) internal {\n\n        uint256 _finalAmount;\n\n        if (_predefinedPool == PredefinedPool.sDAI) {\n            _finalAmount = _daiTOsDai(_amount);\n        } else if (_predefinedPool == PredefinedPool.wstETH) {\n            _finalAmount = _stEthTOwstEth(_amount);\n        } else if (_predefinedPool == PredefinedPool.weETH) {\n            _finalAmount = _eethTOweEth(_amount);\n        } else {\n            revert InvalidDeposit();\n        }\n\n        // adjust boostAmount for the new asset\n        _boostAmount = _boostAmount * _finalAmount / _initalAmount;\n\n        _deposit(typeToId[_predefinedPool], _finalAmount, _boostAmount);\n    }\n\n    /**\n     * @notice Deposit an asset to SophonFarming\n     * @param _pid pid of the deposit\n     * @param _depositAmount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function _deposit(uint256 _pid, uint256 _depositAmount, uint256 _boostAmount) internal {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        if (_depositAmount == 0) {\n            revert InvalidDeposit();\n        }\n        if (_boostAmount > _depositAmount) {\n            revert BoostTooHigh(_depositAmount);\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n\n        uint256 userAmount = user.amount;\n        user.rewardSettled =\n            userAmount *\n            pool.accPointsPerShare /\n            1e18 +\n            user.rewardSettled -\n            user.rewardDebt;\n\n        // booster purchase proceeds\n        heldProceeds[_pid] = heldProceeds[_pid] + _boostAmount;\n\n        // deposit amount is reduced by amount of the deposit to boost\n        _depositAmount = _depositAmount - _boostAmount;\n\n        // set deposit amount\n        user.depositAmount = user.depositAmount + _depositAmount;\n        pool.depositAmount = pool.depositAmount + _depositAmount;\n\n        // apply the boost multiplier\n        _boostAmount = _boostAmount * boosterMultiplier / 1e18;\n\n        user.boostAmount = user.boostAmount + _boostAmount;\n        pool.boostAmount = pool.boostAmount + _boostAmount;\n\n        // userAmount is increased by remaining deposit amount + full boosted amount\n        userAmount = userAmount + _depositAmount + _boostAmount;\n\n        user.amount = userAmount;\n        pool.amount = pool.amount + _depositAmount + _boostAmount;\n\n        user.rewardDebt = userAmount *\n            pool.accPointsPerShare /\n            1e18;\n\n        emit Deposit(msg.sender, _pid, _depositAmount, _boostAmount);\n    }\n\n    /**\n     * @notice Increase boost from existing deposits\n     * @param _pid pid to pool\n     * @param _boostAmount amount to boost\n     */\n    function increaseBoost(uint256 _pid, uint256 _boostAmount) external {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n\n        if (_boostAmount == 0) {\n            revert BoostIsZero();\n        }\n\n        uint256 maxAdditionalBoost = getMaxAdditionalBoost(msg.sender, _pid);\n        if (_boostAmount > maxAdditionalBoost) {\n            revert BoostTooHigh(maxAdditionalBoost);\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n\n        uint256 userAmount = user.amount;\n        user.rewardSettled =\n            userAmount *\n            pool.accPointsPerShare /\n            1e18 +\n            user.rewardSettled -\n            user.rewardDebt;\n\n        // booster purchase proceeds\n        heldProceeds[_pid] = heldProceeds[_pid] + _boostAmount;\n\n        // user's remaining deposit is reduced by amount of the deposit to boost\n        user.depositAmount = user.depositAmount - _boostAmount;\n        pool.depositAmount = pool.depositAmount - _boostAmount;\n\n        // apply the multiplier\n        uint256 finalBoostAmount = _boostAmount * boosterMultiplier / 1e18;\n\n        user.boostAmount = user.boostAmount + finalBoostAmount;\n        pool.boostAmount = pool.boostAmount + finalBoostAmount;\n\n        // user amount is increased by the full boosted amount - deposit amount used to boost\n        userAmount = userAmount + finalBoostAmount - _boostAmount;\n\n        user.amount = userAmount;\n        pool.amount = pool.amount + finalBoostAmount - _boostAmount;\n\n        user.rewardDebt = userAmount *\n            pool.accPointsPerShare /\n            1e18;\n\n        emit IncreaseBoost(msg.sender, _pid, finalBoostAmount);\n    }\n\n    /**\n     * @notice Returns max additional boost amount allowed to boost current deposits\n     * @dev total allowed boost is 100% of total deposit\n     * @param _user user in pool\n     * @param _pid pid of pool\n     * @return uint256 max additional boost\n     */\n    function getMaxAdditionalBoost(address _user, uint256 _pid) public view returns (uint256) {\n        return userInfo[_pid][_user].depositAmount;\n    }\n\n    /**\n     * @notice Withdraw an asset to SophonFarming\n     * @param _pid pid of the withdraw\n     * @param _withdrawAmount amount of the withdraw\n     */\n    function withdraw(uint256 _pid, uint256 _withdrawAmount) external {\n        if (isWithdrawPeriodEnded()) {\n            revert WithdrawNotAllowed();\n        }\n        if (_withdrawAmount == 0) {\n            revert WithdrawIsZero();\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n\n        uint256 userDepositAmount = user.depositAmount;\n\n        if (_withdrawAmount == type(uint256).max) {\n            _withdrawAmount = userDepositAmount;\n        } else if (_withdrawAmount > userDepositAmount) {\n            revert WithdrawTooHigh(userDepositAmount);\n        }\n\n        uint256 userAmount = user.amount;\n        user.rewardSettled =\n            userAmount *\n            pool.accPointsPerShare /\n            1e18 +\n            user.rewardSettled -\n            user.rewardDebt;\n\n        user.depositAmount = userDepositAmount - _withdrawAmount;\n        pool.depositAmount = pool.depositAmount - _withdrawAmount;\n\n        userAmount = userAmount - _withdrawAmount;\n\n        user.amount = userAmount;\n        pool.amount = pool.amount - _withdrawAmount;\n\n        pool.lpToken.safeTransfer(msg.sender, _withdrawAmount);\n\n        user.rewardDebt = userAmount *\n            pool.accPointsPerShare /\n            1e18;\n\n        emit Withdraw(msg.sender, _pid, _withdrawAmount);\n    }\n\n    /**\n     * @notice Permissionless function to allow anyone to bridge during the correct period\n     * @param _pid pid to bridge\n     */\n    function bridgePool(uint256 _pid) external {\n        if (!isFarmingEnded() || !isWithdrawPeriodEnded() || isBridged[_pid]) {\n            revert Unauthorized();\n        }\n\n        updatePool(_pid);\n        PoolInfo storage pool = poolInfo[_pid];\n\n        uint256 depositAmount = pool.depositAmount;\n        if (depositAmount == 0 || address(bridge) == address(0) || pool.l2Farm == address(0)) {\n            revert BridgeInvalid();\n        }\n\n        IERC20 lpToken = pool.lpToken;\n        lpToken.approve(address(bridge), depositAmount);\n\n        // TODO: change _refundRecipient, verify l2Farm, _l2TxGasLimit and _l2TxGasPerPubdataByte\n        // These are pending the launch of Sophon testnet\n        bridge.deposit(\n            pool.l2Farm,            // _l2Receiver\n            address(lpToken),       // _l1Token\n            depositAmount,          // _amount\n            200000,                 // _l2TxGasLimit\n            0,                      // _l2TxGasPerPubdataByte\n            owner()                 // _refundRecipient\n        );\n\n        isBridged[_pid] = true;\n\n        emit Bridge(msg.sender, _pid, depositAmount);\n    }\n\n    // TODO: does this function need to call claimFailedDeposit on the bridge?\n    // This is pending the launch of Sophon testnet\n    /**\n     * @notice Called by an admin if a bridge process to Sophon fails\n     * @param _pid pid of the failed bridge to revert\n     */\n    function revertFailedBridge(uint256 _pid) external onlyOwner {\n        isBridged[_pid] = false;\n    }\n\n    /**\n     * @notice Converts WETH to ETH\n     * @dev WETH withdrawl\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _wethTOEth(uint256 _amount) internal returns (uint256) {\n        // unwrap weth to eth\n        IWeth(weth).withdraw(_amount);\n        return _amount;\n    }\n\n    /**\n     * @notice Converts ETH to stETH\n     * @dev Lido\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _ethTOstEth(uint256 _amount) internal returns (uint256) {\n        // submit function does not return exact amount of stETH so we need to check balances\n        uint256 balanceBefore = IERC20(stETH).balanceOf(address(this));\n        IstETH(stETH).submit{value: _amount}(address(this));\n        return (IERC20(stETH).balanceOf(address(this)) - balanceBefore);\n    }\n\n    /**\n     * @notice Converts stETH to wstETH\n     * @dev Lido\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _stEthTOwstEth(uint256 _amount) internal returns (uint256) {\n        // wrap returns exact amount of wstETH\n        return IwstETH(wstETH).wrap(_amount);\n    }\n\n    /**\n     * @notice Converts ETH to eETH\n     * @dev ether.fi\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _ethTOeEth(uint256 _amount) internal returns (uint256) {\n        // deposit returns exact amount of eETH\n        return IeETHLiquidityPool(eETHLiquidityPool).deposit{value: _amount}(address(this));\n    }\n\n    /**\n     * @notice Converts eETH to weETH\n     * @dev ether.fi\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _eethTOweEth(uint256 _amount) internal returns (uint256) {\n        // wrap returns exact amount of weETH\n        return IweETH(weETH).wrap(_amount);\n    }\n\n    /**\n     * @notice Converts DAI to sDAI\n     * @dev MakerDao\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _daiTOsDai(uint256 _amount) internal returns (uint256) {\n        // deposit DAI to sDAI\n        return IsDAI(sDAI).deposit(_amount, address(this));\n    }\n\n    /**\n     * @notice Allows an admin to withdraw booster proceeds\n     * @param _pid pid to withdraw proceeds from\n     */\n    function withdrawProceeds(uint256 _pid) external onlyOwner {\n        PoolInfo storage pool = poolInfo[_pid];\n        uint256 _proceeds = heldProceeds[_pid];\n        heldProceeds[_pid] = 0;\n        pool.lpToken.safeTransfer(msg.sender, _proceeds);\n        emit WithdrawProceeds(_pid, _proceeds);\n    }\n\n    /**\n     * @notice Returns the current block number\n     * @dev Included to help with testing since it can be overridden for custom functionality\n     * @return uint256 current block number\n     */\n    function getBlockNumber() virtual public view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns info about each pool\n     * @return poolInfos all pool info\n     */\n    function getPoolInfo() external view returns (PoolInfo[] memory poolInfos) {\n        uint256 length = poolInfo.length;\n        poolInfos = new PoolInfo[](length);\n        for(uint256 pid = 0; pid < length;) {\n            poolInfos[pid] = poolInfo[pid];\n            unchecked { ++pid; }\n        }\n    }\n\n    /**\n     * @notice Returns user info for a list of users\n     * @param _users list of users\n     * @return userInfos optimized user info\n     */\n    function getOptimizedUserInfo(address[] memory _users) external view returns (uint256[4][][] memory userInfos) {\n        userInfos = new uint256[4][][](_users.length);\n        uint256 len = poolInfo.length;\n        for(uint256 i = 0; i < _users.length;) {\n            address _user = _users[i];\n            userInfos[i] = new uint256[4][](len);\n            for(uint256 pid = 0; pid < len;) {\n                UserInfo memory uinfo = userInfo[pid][_user];\n                userInfos[i][pid][0] = uinfo.amount;\n                userInfos[i][pid][1] = uinfo.boostAmount;\n                userInfos[i][pid][2] = uinfo.depositAmount;\n                userInfos[i][pid][3] = _pendingPoints(pid, _user);\n                unchecked { ++pid; }\n            }\n            unchecked { i++; }\n        }\n    }\n\n    /**\n     * @notice Returns accrued points for a list of users\n     * @param _users list of users\n     * @return pendings accured points for user\n     */\n    function getPendingPoints(address[] memory _users) external view returns (uint256[][] memory pendings) {\n        pendings = new uint256[][](_users.length);\n        uint256 len = poolInfo.length;\n        for(uint256 i = 0; i < _users.length;) {\n            address _user = _users[i];\n            pendings[i] = new uint256[](len);\n            for(uint256 pid = 0; pid < len;) {\n                pendings[i][pid] = _pendingPoints(pid, _user);\n                unchecked { ++pid; }\n            }\n            unchecked { i++; }\n        }\n    }\n}"
    },
    {
      "filename": "farming-contracts/contracts/farm/SophonFarming.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IWeth.sol\";\nimport \"./interfaces/IstETH.sol\";\nimport \"./interfaces/IwstETH.sol\";\nimport \"./interfaces/IsDAI.sol\";\nimport \"./interfaces/IeETHLiquidityPool.sol\";\nimport \"./interfaces/IweETH.sol\";\nimport \"../proxies/Upgradeable2Step.sol\";\nimport \"./SophonFarmingState.sol\";\n\n/**\n * @title Sophon Farming Contract\n * @author Sophon\n */\ncontract SophonFarming is Upgradeable2Step, SophonFarmingState {\n    using SafeERC20 for IERC20;\n\n    /// @notice Emitted when a new pool is added\n    event Add(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n\n    /// @notice Emitted when a pool is updated\n    event Set(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n\n    /// @notice Emitted when a user deposits to a pool\n    event Deposit(address indexed user, uint256 indexed pid, uint256 depositAmount, uint256 boostAmount);\n\n    /// @notice Emitted when a user withdraws from a pool\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    /// @notice Emitted when a user increases the boost of an existing deposit\n    event IncreaseBoost(address indexed user, uint256 indexed pid, uint256 boostAmount);\n\n    /// @notice Emitted when all pool funds are bridged to Sophon blockchain\n    event Bridge(address indexed user, uint256 indexed pid, uint256 amount);\n\n    /// @notice Emitted when the admin withdraws booster proceeds\n    event WithdrawProceeds(uint256 indexed pid, uint256 proceeds);\n\n    error PoolExists();\n    error PoolDoesNotExist();\n    error AlreadyInitialized();\n    error NotFound(address lpToken);\n    error FarmingIsStarted();\n    error FarmingIsEnded();\n    error InvalidStartBlock();\n    error InvalidEndBlock();"
    }
  ]
}