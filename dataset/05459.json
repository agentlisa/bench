{
  "Title": "[G-01] Avoid contract existence checks by using low level calls",
  "Content": "\n**Issue Description** - Prior to Solidity `0.8.10`, the compiler would insert extra code to check for contract existence before external function calls,\neven if the call had a return value. This wasted gas by performing a check that wasn't necessary.\n\n**Proposed Optimization** - For functions that make external calls with return values in Solidity `<0.8.10`, optimize the code to use low-level calls instead\nof regular calls. Low-level calls skip the unnecessary contract existence check.\n\nExample:\n\n```solidity\n//Before:\n\ncontract C {\n  function f() external returns(uint) {\n    address(otherContract).call(abi.encodeWithSignature(\"func()\"));\n  }\n}\n\n\n//After:\n\ncontract C {\n  function f() external returns(uint) {\n    (bool success,) = address(otherContract).call(abi.encodeWithSignature(\"func()\"));\n    require(success);\n    return decodeReturnValue();\n  }\n}\n```\n\n**Estimated Gas Savings** - Each avoided `EXTCODESIZE` check saves 100 gas. If 10 external calls are made in a common function, this would save 1000 gas\ntotal.\n\n**Code Snippets:**\n\n```solidity\nFile: adapters/Curve2PoolAdapter.sol\n\n78        address xTokenAddress = ICurve2Pool(primitive).coins(0);\n\n81        decimals[xToken] = IERC20Metadata(xTokenAddress).decimals();\n\n84        address yTokenAddress = ICurve2Pool(primitive).coins(1);\n\n88        decimals[yToken] = IERC20Metadata(yTokenAddress).decimals();\n\n93        decimals[lpTokenId] = IERC20Metadata(primitive_).decimals();\n\n113        IOceanInteractions(ocean).doInteraction(interaction);\n\n132        IOceanInteractions(ocean).doInteraction(interaction);\n\n164                ICurve2Pool(primitive).exchange(indexOfInputAmount, indexOfOutputAmount, rawInputAmount, 0);\n\n168            rawOutputAmount = ICurve2Pool(primitive).add_liquidity(inputAmounts, 0);\n\n170            rawOutputAmount = ICurve2Pool(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n\n190        IERC20Metadata(tokenAddress).approve(ocean, type(uint256).max);\n\n191        IERC20Metadata(tokenAddress).approve(primitive, type(uint256).max);\n```\n\nhttps://github.com/code-423n4/2023-11-shellprotocol/blob/main/src/adapters/Curve2PoolAdapter.sol#L78\n\n```solidity\nFile: src/adapters/CurveTricryptoAdapter.sol\n\n86        address xTokenAddress = ICurveTricrypto(primitive).coins(0);\n\n89        decimals[xToken] = IERC20Metadata(xTokenAddress).decimals();\n\n92        address yTokenAddress = ICurveTricrypto(primitive).coins(1);\n\n96        decimals[yToken] = IERC20Metadata(yTokenAddress).decimals();\n\n99        address wethAddress = ICurveTricrypto(primitive).coins(2);\n\n106        address lpTokenAddress = ICurveTricrypto(primitive).token();\n\n109        decimals[lpTokenId] = IERC20Metadata(lpTokenAddress).decimals();\n\n129            IOceanInteractions(ocean).doInteraction{ value: amount }(interaction);\n\n138            IOceanInteractions(ocean).doInteraction(interaction);\n\n168        IOceanInteractions(ocean).doInteraction(interaction);\n\n210            ICurveTricrypto(primitive).add_liquidity(inputAmounts, 0);\n\n213                uint256 wethBalance = IERC20Metadata(underlying[zToken]).balanceOf(address(this));\n\n214                ICurveTricrypto(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n\n215                IWETH(underlying[zToken]).withdraw(\n\n219                ICurveTricrypto(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n\n242        IERC20Metadata(tokenAddress).approve(ocean, type(uint256).max);\n\n243        IERC20Metadata(tokenAddress).approve(primitive, type(uint256).max);\n```\n\nhttps://github.com/code-423n4/2023-11-shellprotocol/blob/main/src/adapters/CurveTricryptoAdapter.sol#L86\n\n```solidity\nFile: src/ocean/Ocean.sol\n\n891        IERC721(tokenAddress).safeTransferFrom(userAddress, address(this), tokenId);\n\n904        IERC721(tokenAddress).safeTransferFrom(address(this), userAddress, tokenId);\n\n931        IERC1155(tokenAddress).safeTransferFrom(userAddress, address(this), tokenId, amount, \"\");\n\n968        IERC1155(tokenAddress).safeTransferFrom(address(this), userAddress, tokenId, amountRemaining, \"\");\n\n```\n\nhttps://github.com/code-423n4/2023-11-shellprotocol/blob/main/src/ocean/Ocean.sol#L891\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-11-shellprotocol",
  "Code": [
    {
      "filename": "src/adapters/Curve2PoolAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Cowri Labs Inc.\n\npragma solidity 0.8.20;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./ICurve2Pool.sol\";\nimport \"./OceanAdapter.sol\";\n\nenum ComputeType {\n    Deposit,\n    Swap,\n    Withdraw\n}\n\n/**\n * @notice\n *   curve2pool adapter contract enabling swapping, adding liquidity & removing liquidity for the curve usdc-usdt pool\n */\ncontract Curve2PoolAdapter is OceanAdapter {\n    /////////////////////////////////////////////////////////////////////\n    //                             Errors                              //\n    /////////////////////////////////////////////////////////////////////\n    error INVALID_COMPUTE_TYPE();\n    error SLIPPAGE_LIMIT_EXCEEDED();\n\n    /////////////////////////////////////////////////////////////////////\n    //                             Events                              //\n    /////////////////////////////////////////////////////////////////////\n    event Swap(\n        uint256 inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n    event Deposit(\n        uint256 inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n    event Withdraw(\n        uint256 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n\n    /// @notice x token Ocean ID.\n    uint256 public immutable xToken;\n\n    /// @notice y token Ocean ID.\n    uint256 public immutable yToken;\n\n    /// @notice lp token Ocean ID.\n    uint256 public immutable lpTokenId;\n\n    /// @notice map token Ocean IDs to corresponding Curve pool indices\n    mapping(uint256 => int128) indexOf;\n\n    /// @notice The underlying token decimals wrt to the Ocean ID\n    mapping(uint256 => uint8) decimals;\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice only initializing the immutables, mappings & approves tokens\n     */\n    constructor(address ocean_, address primitive_) OceanAdapter(ocean_, primitive_) {\n        address xTokenAddress = ICurve2Pool(primitive).coins(0);\n        xToken = _calculateOceanId(xTokenAddress, 0);\n        underlying[xToken] = xTokenAddress;\n        decimals[xToken] = IERC20Metadata(xTokenAddress).decimals();\n        _approveToken(xTokenAddress);\n\n        address yTokenAddress = ICurve2Pool(primitive).coins(1);\n        yToken = _calculateOceanId(yTokenAddress, 0);\n        indexOf[yToken] = int128(1);\n        underlying[yToken] = yTokenAddress;\n        decimals[yToken] = IERC20Metadata(yTokenAddress).decimals();\n        _approveToken(yTokenAddress);\n\n        lpTokenId = _calculateOceanId(primitive_, 0);\n        underlying[lpTokenId] = primitive_;\n        decimals[lpTokenId] = IERC20Metadata(primitive_).decimals();\n        _approveToken(primitive_);\n    }\n\n    /**\n     * @dev wraps the underlying token into the Ocean\n     * @param tokenId Ocean ID of token to wrap\n     * @param amount wrap amount\n     */\n    function wrapToken(uint256 tokenId, uint256 amount) internal override {\n        address tokenAddress = underlying[tokenId];\n\n        Interaction memory interaction = Interaction({\n            interactionTypeAndAddress: _fetchInteractionId(tokenAddress, uint256(InteractionType.WrapErc20)),\n            inputToken: 0,\n            outputToken: 0,\n            specifiedAmount: amount,\n            metadata: bytes32(0)\n        });\n\n        IOceanInteractions(ocean).doInteraction(interaction);\n    }\n\n    /**\n     * @dev unwraps the underlying token from the Ocean\n     * @param tokenId Ocean ID of token to unwrap\n     * @param amount unwrap amount\n     */\n    function unwrapToken(uint256 tokenId, uint256 amount) internal override {\n        address tokenAddress = underlying[tokenId];\n\n        Interaction memory interaction = Interaction({\n            interactionTypeAndAddress: _fetchInteractionId(tokenAddress, uint256(InteractionType.UnwrapErc20)),\n            inputToken: 0,\n            outputToken: 0,\n            specifiedAmount: amount,\n            metadata: bytes32(0)\n        });\n\n        IOceanInteractions(ocean).doInteraction(interaction);\n    }\n\n    /**\n     * @dev swaps/add liquidity/remove liquidity from Curve 2pool\n     * @param inputToken The user is giving this token to the pool\n     * @param outputToken The pool is giving this token to the user\n     * @param inputAmount The amount of the inputToken the user is giving to the pool\n     * @param minimumOutputAmount The minimum amount of tokens expected back after the exchange\n     */\n    function primitiveOutputAmount(\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 inputAmount,\n        bytes32 minimumOutputAmount\n    )\n        internal\n        override\n        returns (uint256 outputAmount)\n    {\n        uint256 rawInputAmount = _convertDecimals(NORMALIZED_DECIMALS, decimals[inputToken], inputAmount);\n\n        ComputeType action = _determineComputeType(inputToken, outputToken);\n\n        uint256 rawOutputAmount;\n\n        // avoid multiple SLOADS\n        int128 indexOfInputAmount = indexOf[inputToken];\n        int128 indexOfOutputAmount = indexOf[outputToken];\n\n        if (action == ComputeType.Swap) {\n            rawOutputAmount =\n                ICurve2Pool(primitive).exchange(indexOfInputAmount, indexOfOutputAmount, rawInputAmount, 0);\n        } else if (action == ComputeType.Deposit) {\n            uint256[2] memory inputAmounts;\n            inputAmounts[uint256(int256(indexOfInputAmount))] = rawInputAmount;\n            rawOutputAmount = ICurve2Pool(primitive).add_liquidity(inputAmounts, 0);\n        } else {\n            rawOutputAmount = ICurve2Pool(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n        }\n\n        outputAmount = _convertDecimals(decimals[outputToken], NORMALIZED_DECIMALS, rawOutputAmount);\n\n        if (uint256(minimumOutputAmount) > outputAmount) revert SLIPPAGE_LIMIT_EXCEEDED();\n\n        if (action == ComputeType.Swap) {\n            emit Swap(inputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        } else if (action == ComputeType.Deposit) {\n            emit Deposit(inputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        } else {\n            emit Withdraw(outputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        }\n    }\n\n    /**\n     * @dev Approves token to be spent by the Ocean and the Curve pool\n     */\n    function _approveToken(address tokenAddress) private {\n        IERC20Metadata(tokenAddress).approve(ocean, type(uint256).max);\n        IERC20Metadata(tokenAddress).approve(primitive, type(uint256).max);\n    }\n\n    /**\n     * @dev Uses the inputToken and outputToken to determine the ComputeType\n     *  (input: xToken, output: yToken) | (input: yToken, output: xToken) => SWAP\n     *  base := xToken | yToken\n     *  (input: base, output: lpToken) => DEPOSIT\n     *  (input: lpToken, output: base) => WITHDRAW\n     */\n    function _determineComputeType(\n        uint256 inputToken,\n        uint256 outputToken\n    )\n        private\n        view\n        returns (ComputeType computeType)\n    {\n        if (((inputToken == xToken) && (outputToken == yToken)) || ((inputToken == yToken) && (outputToken == xToken)))\n        {\n            return ComputeType.Swap;\n        } else if (((inputToken == xToken) || (inputToken == yToken)) && (outputToken == lpTokenId)) {\n            return ComputeType.Deposit;\n        } else if ((inputToken == lpTokenId) && ((outputToken == xToken) || (outputToken == yToken))) {\n            return ComputeType.Withdraw;\n        } else {\n            revert INVALID_COMPUTE_TYPE();\n        }\n    }\n}"
    },
    {
      "filename": "src/adapters/CurveTricryptoAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Cowri Labs Inc.\n\npragma solidity 0.8.20;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./ICurveTricrypto.sol\";\nimport \"./OceanAdapter.sol\";\n\ninterface IWETH {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external payable;\n}\n\nenum ComputeType {\n    Deposit,\n    Swap,\n    Withdraw\n}\n\n/**\n * @notice\n *   curve tricrypto adapter contract enabling swapping, adding liquidity & removing liquidity for the curve usdt-wbtc-eth pool\n */\ncontract CurveTricryptoAdapter is OceanAdapter {\n    /////////////////////////////////////////////////////////////////////\n    //                             Errors                              //\n    /////////////////////////////////////////////////////////////////////\n    error INVALID_COMPUTE_TYPE();\n    error SLIPPAGE_LIMIT_EXCEEDED();\n\n    /////////////////////////////////////////////////////////////////////\n    //                             Events                              //\n    /////////////////////////////////////////////////////////////////////\n    event Swap(\n        uint256 inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n    event Deposit(\n        uint256 inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n    event Withdraw(\n        uint256 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n\n    /// @notice x token Ocean ID\n    uint256 public immutable xToken;\n\n    /// @notice y token Ocean ID\n    uint256 public immutable yToken;\n\n    /// @notice z token Ocean ID\n    uint256 public immutable zToken;\n\n    /// @notice lp token Ocean ID\n    uint256 public immutable lpTokenId;\n\n    /// @notice map token Ocean IDs to corresponding Curve pool indices\n    mapping(uint256 => uint256) indexOf;\n\n    /// @notice The underlying token decimals wrt to the Ocean ID\n    mapping(uint256 => uint8) decimals;\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice only initializing the immutables, mappings & approves tokens\n     */\n    constructor(address ocean_, address primitive_) OceanAdapter(ocean_, primitive_) {\n        address xTokenAddress = ICurveTricrypto(primitive).coins(0);\n        xToken = _calculateOceanId(xTokenAddress, 0);\n        underlying[xToken] = xTokenAddress;\n        decimals[xToken] = IERC20Metadata(xTokenAddress).decimals();\n        _approveToken(xTokenAddress);\n\n        address yTokenAddress = ICurveTricrypto(primitive).coins(1);\n        yToken = _calculateOceanId(yTokenAddress, 0);\n        indexOf[yToken] = 1;\n        underlying[yToken] = yTokenAddress;\n        decimals[yToken] = IERC20Metadata(yTokenAddress).decimals();\n        _approveToken(yTokenAddress);\n\n        address wethAddress = ICurveTricrypto(primitive).coins(2);\n        zToken = _calculateOceanId(address(0x4574686572), 0); // hexadecimal(ascii(\"Ether\"))\n        indexOf[zToken] = 2;\n        underlying[zToken] = wethAddress;\n        decimals[zToken] = NORMALIZED_DECIMALS;\n        _approveToken(wethAddress);\n\n        address lpTokenAddress = ICurveTricrypto(primitive).token();\n        lpTokenId = _calculateOceanId(lpTokenAddress, 0);\n        underlying[lpTokenId] = lpTokenAddress;\n        decimals[lpTokenId] = IERC20Metadata(lpTokenAddress).decimals();\n        _approveToken(lpTokenAddress);\n    }\n\n    /**\n     * @dev wraps the underlying token into the Ocean\n     * @param tokenId Ocean ID of token to wrap\n     * @param amount wrap amount\n     */\n    function wrapToken(uint256 tokenId, uint256 amount) internal override {\n        Interaction memory interaction;\n\n        if (tokenId == zToken) {\n            interaction = Interaction({\n                interactionTypeAndAddress: 0,\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: 0,\n                metadata: bytes32(0)\n            });\n            IOceanInteractions(ocean).doInteraction{ value: amount }(interaction);\n        } else {\n            interaction = Interaction({\n                interactionTypeAndAddress: _fetchInteractionId(underlying[tokenId], uint256(InteractionType.WrapErc20)),\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: amount,\n                metadata: bytes32(0)\n            });\n            IOceanInteractions(ocean).doInteraction(interaction);\n        }\n    }\n\n    /**\n     * @dev unwraps the underlying token from the Ocean\n     * @param tokenId Ocean ID of token to unwrap\n     * @param amount unwrap amount\n     */\n    function unwrapToken(uint256 tokenId, uint256 amount) internal override {\n        Interaction memory interaction;\n\n        if (tokenId == zToken) {\n            interaction = Interaction({\n                interactionTypeAndAddress: _fetchInteractionId(address(0), uint256(InteractionType.UnwrapEther)),\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: amount,\n                metadata: bytes32(0)\n            });\n        } else {\n            interaction = Interaction({\n                interactionTypeAndAddress: _fetchInteractionId(underlying[tokenId], uint256(InteractionType.UnwrapErc20)),\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: amount,\n                metadata: bytes32(0)\n            });\n        }\n\n        IOceanInteractions(ocean).doInteraction(interaction);\n    }\n\n    /**\n     * @dev swaps/add liquidity/remove liquidity from Curve Tricrypto Pool\n     * @param inputToken The user is giving this token to the pool\n     * @param outputToken The pool is giving this token to the user\n     * @param inputAmount The amount of the inputToken the user is giving to the pool\n     * @param minimumOutputAmount The minimum amount of tokens expected back after the exchange\n     */\n    function primitiveOutputAmount(\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 inputAmount,\n        bytes32 minimumOutputAmount\n    )\n        internal\n        override\n        returns (uint256 outputAmount)\n    {\n        uint256 rawInputAmount = _convertDecimals(NORMALIZED_DECIMALS, decimals[inputToken], inputAmount);\n\n        ComputeType action = _determineComputeType(inputToken, outputToken);\n\n        uint256 _balanceBefore = _getBalance(underlying[outputToken]);\n\n        // avoid multiple SLOADS\n        uint256 indexOfInputAmount = indexOf[inputToken];\n        uint256 indexOfOutputAmount = indexOf[outputToken];\n\n        if (action == ComputeType.Swap) {\n            bool useEth = inputToken == zToken || outputToken == zToken;\n\n            ICurveTricrypto(primitive).exchange{ value: inputToken == zToken ? rawInputAmount : 0 }(\n                indexOfInputAmount, indexOfOutputAmount, rawInputAmount, 0, useEth\n            );\n        } else if (action == ComputeType.Deposit) {\n            uint256[3] memory inputAmounts;\n            inputAmounts[indexOfInputAmount] = rawInputAmount;\n\n            if (inputToken == zToken) IWETH(underlying[zToken]).deposit{ value: rawInputAmount }();\n\n            ICurveTricrypto(primitive).add_liquidity(inputAmounts, 0);\n        } else {\n            if (outputToken == zToken) {\n                uint256 wethBalance = IERC20Metadata(underlying[zToken]).balanceOf(address(this));\n                ICurveTricrypto(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n                IWETH(underlying[zToken]).withdraw(\n                    IERC20Metadata(underlying[zToken]).balanceOf(address(this)) - wethBalance\n                );\n            } else {\n                ICurveTricrypto(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n            }\n        }\n\n        uint256 rawOutputAmount = _getBalance(underlying[outputToken]) - _balanceBefore;\n\n        outputAmount = _convertDecimals(decimals[outputToken], NORMALIZED_DECIMALS, rawOutputAmount);\n\n        if (uint256(minimumOutputAmount) > outputAmount) revert SLIPPAGE_LIMIT_EXCEEDED();\n\n        if (action == ComputeType.Swap) {\n            emit Swap(inputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        } else if (action == ComputeType.Deposit) {\n            emit Deposit(inputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        } else {\n            emit Withdraw(outputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        }\n    }\n\n    /**\n     * @dev Approves token to be spent by the Ocean and the Curve pool\n     */\n    function _approveToken(address tokenAddress) private {\n        IERC20Metadata(tokenAddress).approve(ocean, type(uint256).max);\n        IERC20Metadata(tokenAddress).approve(primitive, type(uint256).max);\n    }\n\n    /**\n     * @dev fetches underlying token balances\n     */\n    function _getBalance(address tokenAddress) internal view returns (uint256 balance) {\n        if (tokenAddress == underlying[zToken]) {\n            return address(this).balance;\n        } else {\n            return IERC20Metadata(tokenAddress).balanceOf(address(this));\n        }\n    }\n\n    /**\n     * @dev Uses the inputToken and outputToken to determine the ComputeType\n     *  (input: xToken, output: yToken) | (input: yToken, output: xToken) => SWAP\n     *  base := xToken | yToken\n     *  (input: base, output: lpToken) => DEPOSIT\n     *  (input: lpToken, output: base) => WITHDRAW\n     */\n    function _determineComputeType(\n        uint256 inputToken,\n        uint256 outputToken\n    )\n        private\n        view\n        returns (ComputeType computeType)\n    {\n        if (\n            ((inputToken == xToken && outputToken == yToken) || (inputToken == yToken && outputToken == xToken))\n                || ((inputToken == xToken && outputToken == zToken) || (inputToken == zToken && outputToken == xToken))\n                || ((inputToken == yToken && outputToken == zToken) || (inputToken == zToken && outputToken == yToken))\n        ) {\n            return ComputeType.Swap;\n        } else if (\n            ((inputToken == xToken) || (inputToken == yToken) || (inputToken == zToken)) && (outputToken == lpTokenId)\n        ) {\n            return ComputeType.Deposit;\n        } else if (\n            (inputToken == lpTokenId) && ((outputToken == xToken) || (outputToken == yToken) || (outputToken == zToken))\n        ) {\n            return ComputeType.Withdraw;\n        } else {\n            revert INVALID_COMPUTE_TYPE();\n        }\n    }\n\n    fallback() external payable { }\n}"
    },
    {
      "filename": "src/ocean/Ocean.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Cowri Labs Inc.\n\n// All solidity behavior related comments are in reference to this version of\n// the solc compiler.\npragma solidity 0.8.20;\n\n// OpenZeppelin ERC Interfaces\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC1155Receiver } from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport { IERC721Receiver } from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\n// OpenZeppelin Utility Library\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// ShellV2 Interfaces, Data Structures, and Library\nimport { IOceanInteractions, Interaction, InteractionType } from \"./Interactions.sol\";\nimport { IOceanFeeChange } from \"./IOceanFeeChange.sol\";\nimport { IOceanPrimitive } from \"./IOceanPrimitive.sol\";\nimport { BalanceDelta, LibBalanceDelta } from \"./BalanceDelta.sol\";\n\n// ShellV2 ERC-1155 with logic related to public multitoken ledger management.\nimport { OceanERC1155 } from \"./OceanERC1155.sol\";\n\n/**\n * @title A public multitoken ledger for defi\n * @author Cowri Labs Team\n * @dev The ocean is designed to interact with contracts that implement IERC20,\n *  IERC721, IERC-1155, or IOceanPrimitive.\n * @dev The ocean is three things.\n *  1. At the highest level, it is a defi framework[0]. Users provide a list\n *   of interactions, and the ocean executes those interactions. Each\n *   interaction involves a call to an external contract. These calls result\n *   in updates to the ocean's accounting system.\n *  2. Suporting this defi framework is an accounting system that can transfer,\n *   mint, or burn tokens. Each token in the accounting system is identified by\n *   its oceanId. Every oceanId is uniquely derived from an external contract\n *   address. This external contract is the only contract able to cause mints\n *   or burns of this token[1].\n *  3. Supporting this accounting system is an ERC-1155 ledger with all the\n *   standard ERC-1155 features. Users and primitives can interact with their\n *   tokens using both the defi framework and the ERC-1155 functions.\n *\n * [0] We call it a framework because the ocean calls predefined functions on\n *  external contracts at certain points in its exection. The lifecycle is\n *  managed by the ocean, while the business logic is managed by external\n *  contracts.  Conceptually this is quite similar to a typical web framework.\n * [1] For example, when a user wraps an ERC-20 token into the ocean, the\n *   framework calls the ERC-20 transfer function, and upon success, mints the\n *   wrapped token to the user. In another case, when a user deposits a base\n *   token into a liquidity pool to recieve liquidity provider tokens, the\n *   framework calls the liquidity pool, tells it how much of the base token it\n *   will receive, and asks it how much of the liquidity provider token it\n *   would like to mint. When the pool responds, the framework mints this\n *   amount to the user.\n *\n * @dev Getting started tips:\n *  1. Check out Interactions.sol\n *  2. Read through the implementation of Ocean.doInteraction(), glossing over\n *   the function call to _executeInteraction().\n *  3. Read through the imlementation of Ocean.doMultipleInteractions(), again\n *   glossing over the function call to _executeInteraction(). When you\n *   encounter calls to LibBalanceDelta, check out their implementations.\n *  4. Read through _executeInteraction() and all the functions it calls.\n *   Understand how this is the line separating the accounting for the external\n *   contracts and the accounting for the current user.\n *   You can read the implementations of the specific interactions in any\n *   order, but it might be good to go through them in order of increasing\n *   complexity. The called functions, in order of increasing complexity, are:\n *   wrapErc721, unwrapErc721, wrapErc1155, unwrapErc1155, computeOutputAmount,\n *   computeInputAmount, unwrapErc20, and wrapErc20.  When you get to\n *   computeOutputAmount, check out IOceanPrimitive, IOceanToken, and the\n *   function registerNewTokens() in OceanERC1155.\n */\ncontract Ocean is IOceanInteractions, IOceanFeeChange, OceanERC1155, IERC721Receiver, IERC1155Receiver {\n    using LibBalanceDelta for BalanceDelta[];\n\n    /// @notice this is the oceanId used for shETH\n    /// @dev hexadecimal(ascii(\"shETH\"))\n    uint256 public immutable WRAPPED_ETHER_ID;\n\n    /// @notice Used to calculate the unwrap fee\n    /// unwrapFee = unwrapAmount / unwrapFeeDivisor\n    /// Because this uses integer division, the fee is always rounded down\n    /// If unwrapAmount < unwrapFeeDivisor, unwrapFee == 0\n    uint256 public unwrapFeeDivisor;\n    /// @dev this is equivalent to 5 basis points: 1 / 2000 = 0.05%\n    /// @dev When limited to 5 bips or less an integer divisor is an efficient\n    ///  and precise method of calculating a fee.\n    /// @notice As the divisor shrinks, the fee charged grows\n    uint256 constant MIN_UNWRAP_FEE_DIVISOR = 2000;\n\n    /// @notice wrapped ERC20 tokens are stored in an 18 decimal representation\n    /// @dev this makes it easier to implement AMMs between similar tokens\n    uint8 constant NORMALIZED_DECIMALS = 18;\n    /// @notice When the specifiedAmount is equal to this value, we set\n    ///  specifiedAmount to the balance delta.\n    uint256 constant GET_BALANCE_DELTA = type(uint256).max;\n\n    /// @dev Determines if a transfer callback is expected.\n    /// @dev adapted from OpenZeppelin Reentrancy Guard\n    uint256 constant NOT_INTERACTION = 1;\n    uint256 constant INTERACTION = 2;\n    uint256 _ERC1155InteractionStatus;\n    uint256 _ERC721InteractionStatus;\n\n    event ChangeUnwrapFee(uint256 oldFee, uint256 newFee, address sender);\n    event Erc20Wrap(\n        address indexed erc20Token,\n        uint256 transferredAmount,\n        uint256 wrappedAmount,\n        uint256 dust,\n        address indexed user,\n        uint256 indexed oceanId\n    );\n    event Erc20Unwrap(\n        address indexed erc20Token,\n        uint256 transferredAmount,\n        uint256 unwrappedAmount,\n        uint256 feeCharged,\n        address indexed user,\n        uint256 indexed oceanId\n    );\n    event Erc721Wrap(address indexed erc721Token, uint256 erc721id, address indexed user, uint256 indexed oceanId);\n    event Erc721Unwrap(address indexed erc721Token, uint256 erc721Id, address indexed user, uint256 indexed oceanId);\n    event Erc1155Wrap(\n        address indexed erc1155Token, uint256 erc1155Id, uint256 amount, address indexed user, uint256 indexed oceanId\n    );\n    event Erc1155Unwrap(\n        address indexed erc1155Token,\n        uint256 erc1155Id,\n        uint256 amount,\n        uint256 feeCharged,\n        address indexed user,\n        uint256 indexed oceanId\n    );\n    event EtherWrap(uint256 amount, address indexed user);\n    event EtherUnwrap(uint256 amount, uint256 feeCharged, address indexed user);\n    event ComputeOutputAmount(\n        address indexed primitive,\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        address indexed user\n    );\n    event ComputeInputAmount(\n        address indexed primitive,\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        address indexed user\n    );\n    event OceanTransaction(address indexed user, uint256 numberOfInteractions);\n    event ForwardedOceanTransaction(address indexed forwarder, address indexed user, uint256 numberOfInteractions);\n\n    /**\n     * @dev Creates custom ERC-1155 with passed uri_, sets DAO address, and\n     *  initializes ERC-1155 transfer guard.\n     * @notice initializes the fee divisor to uint256 max, which results in\n     *  a fee of zero unless unwrapAmount == type(uint256).max, in which\n     *  case the fee is one part in 1.16 * 10^77.\n     */\n    constructor(string memory uri_) OceanERC1155(uri_) {\n        unwrapFeeDivisor = type(uint256).max;\n        _ERC1155InteractionStatus = NOT_INTERACTION;\n        _ERC721InteractionStatus = NOT_INTERACTION;\n        WRAPPED_ETHER_ID = _calculateOceanId(address(0x4574686572), 0); // hexadecimal(ascii(\"Ether\"))\n    }\n\n    /**\n     * @dev ERC1155 Approvals also function as permission to execute\n     *  interactions on a user's behalf\n     * @param userAddress the address passed by the forwarder\n     *\n     * Because poorly chosen interactions are vulnerable to economic attacks,\n     *  calling do{Interaction|MultipleInteractions} on a user's behalf must\n     *  require the  same level of trust as direct balance transfers.\n     */\n    modifier onlyApprovedForwarder(address userAddress) {\n        if (!isApprovedForAll(userAddress, msg.sender)) revert FORWARDER_NOT_APPROVED();\n        _;\n    }\n\n    /**\n     * @notice this changes the unwrap fee immediately\n     * @notice The governance structure must appropriately handle any\n     *  time lock or other mechanism for managing fee changes\n     * @param nextUnwrapFeeDivisor the reciprocal of the next fee percentage.\n     */\n    function changeUnwrapFee(uint256 nextUnwrapFeeDivisor) external override onlyOwner {\n        /// @notice as the divisor gets smaller, the fee charged gets larger\n        if (MIN_UNWRAP_FEE_DIVISOR > nextUnwrapFeeDivisor) revert();\n        emit ChangeUnwrapFee(unwrapFeeDivisor, nextUnwrapFeeDivisor, msg.sender);\n        unwrapFeeDivisor = nextUnwrapFeeDivisor;\n    }\n\n    /**\n     * @notice Execute interactions `interaction`\n     * @notice Does not need ids because a single interaction does not require\n     *  the accounting system\n     * @dev call to _doInteraction() binds msg.sender to userAddress\n     * @param interaction Executed to produce a set of balance updates\n     */\n    function doInteraction(Interaction calldata interaction)\n        external\n        payable\n        override\n        returns (uint256 burnId, uint256 burnAmount, uint256 mintId, uint256 mintAmount)\n    {\n        emit OceanTransaction(msg.sender, 1);\n        return _doInteraction(interaction, msg.sender);\n    }\n\n    /**\n     * @notice Execute interactions `interactions` with tokens `ids`\n     * @notice ids must include all tokens invoked during the transaction\n     * @notice ids are used for memory allocation in the intra-transaction\n     *  accounting system.\n     * @dev call to _doMultipleInteractions() binds msg.sender to userAddress\n     * @param interactions Executed to produce a set of balance updates\n     * @param ids Ocean IDs of the tokens invoked by the interactions.\n     */\n    function doMultipleInteractions(\n        Interaction[] calldata interactions,\n        uint256[] calldata ids\n    )\n        external\n        payable\n        override\n        returns (\n            uint256[] memory burnIds,\n            uint256[] memory burnAmounts,\n            uint256[] memory mintIds,\n            uint256[] memory mintAmounts\n        )\n    {\n        emit OceanTransaction(msg.sender, interactions.length);\n        return _doMultipleInteractions(interactions, ids, msg.sender);\n    }\n\n    /**\n     * @notice Execute interactions `interactions` on behalf of `userAddress`\n     * @notice Does not need ids because a single interaction does not require\n     *  the overhead of the intra-transaction accounting system\n     * @dev MUST HAVE onlyApprovedForwarder modifer.\n     * @dev call to _doMultipleInteractions() forwards the userAddress\n     * @param interaction Executed to produce a set of balance updates\n     * @param userAddress interactions are executed on behalf of this address\n     */\n    function forwardedDoInteraction(\n        Interaction calldata interaction,\n        address userAddress\n    )\n        external\n        payable\n        override\n        onlyApprovedForwarder(userAddress)\n        returns (uint256 burnId, uint256 burnAmount, uint256 mintId, uint256 mintAmount)\n    {\n        emit ForwardedOceanTransaction(msg.sender, userAddress, 1);\n        return _doInteraction(interaction, userAddress);\n    }\n\n    /**\n     * @notice Execute interactions `interactions` with tokens `ids` on behalf of `userAddress`\n     * @notice ids must include all tokens invoked during the transaction\n     * @notice ids are used for memory allocation in the intra-transaction\n     *  accounting system.\n     * @dev MUST HAVE onlyApprovedForwarder modifer.\n     * @dev call to _doMultipleInteractions() forwards the userAddress\n     * @param interactions Executed to produce a set of balance updates\n     * @param ids Ocean IDs of the tokens invoked by the interactions.\n     * @param userAddress interactions are executed on behalf of this address\n     */\n    function forwardedDoMultipleInteractions(\n        Interaction[] calldata interactions,\n        uint256[] calldata ids,\n        address userAddress\n    )\n        external\n        payable\n        override\n        onlyApprovedForwarder(userAddress)\n        returns (\n            uint256[] memory burnIds,\n            uint256[] memory burnAmounts,\n            uint256[] memory mintIds,\n            uint256[] memory mintAmounts\n        )\n    {\n        emit ForwardedOceanTransaction(msg.sender, userAddress, interactions.length);\n        return _doMultipleInteractions(interactions, ids, userAddress);\n    }\n\n    /**"
    }
  ]
}