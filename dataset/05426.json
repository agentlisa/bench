{
  "Title": "[M-02] Inability to withdraw funds for certain users due to `whenNotPaused` modifier in `RateLimitedMinter`",
  "Content": "\nFrom the audit documentation:\n\n> [The GUARDIAN role] is expected to be able to freeze new usage of the protocol, but not prevent users from withdrawing their funds.\n\nHowever, due to the `whenNotPaused` modifier in the `RateLimitedMinter.mint()` function, users who have `CREDIT` tokens staked on a gauge with a pending `guildReward` will not be able to withdraw their funds. This is because the `SurplusGuildMinter.unstake()` function attempts to mint rewards through the `RateLimitedMinter` in the `getRewards()` function prior to unstaking. If the protocol is paused, this step will fail, causing the transaction to revert and preventing users from withdrawing their funds.\n\n### Proof of Concept\n\nConsider a scenario where Alice has `CREDIT` tokens staked on a gauge with a pending `guildReward`. Then, the protocol is paused and Alice attempts to unstake her tokens by calling the `SurplusGuildMinter.unstake()` function, which in turn calls the `getRewards()` function. This function attempts to mint rewards through the `RateLimitedMinter.mint()` function. However, because the protocol is paused, this function cannot be executed, causing the transaction to revert and preventing Alice from unstaking and withdrawing her funds.\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L52>\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L158-L163>\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L259>\n\n### Recommended Mitigation Steps\n\nProvide an `emergencyWithdraw` method allowing users to withdraw their funds while foregoing rewards when the protocol is paused. This change should be carefully reviewed and tested to ensure it does not introduce other security risks.\n\n**[eswak (Ethereum Credit Guild) confirmed and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1249#issuecomment-1898741180):**\n > Very nice catch, thanks a lot for reporting!\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/rate-limits/RateLimitedMinter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {RateLimitedV2} from \"@src/utils/RateLimitedV2.sol\";\n\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\n\ninterface IERC20Mintable {\n    function mint(address to, uint256 amount) external;\n}\n\n/// @notice contract to mint tokens on a rate limit.\n/// All minting should flow through this smart contract, as it should be the only one with\n/// minting capabilities.\ncontract RateLimitedMinter is RateLimitedV2 {\n    /// @notice the reference to token\n    address public immutable token;\n\n    /// @notice role used to access control on mint/replenishBuffer\n    bytes32 public immutable role;\n\n    /// @param _core reference to the core smart contract\n    /// @param _token reference to the token to mint\n    /// @param _role role used to check access control\n    /// @param _maxRateLimitPerSecond maximum rate limit per second that governance can set\n    /// @param _rateLimitPerSecond starting rate limit per second for minting\n    /// @param _bufferCap cap on buffer size for this rate limited instance\n    constructor(\n        address _core,\n        address _token,\n        bytes32 _role,\n        uint256 _maxRateLimitPerSecond,\n        uint128 _rateLimitPerSecond,\n        uint128 _bufferCap\n    )\n        CoreRef(_core)\n        RateLimitedV2(_maxRateLimitPerSecond, _rateLimitPerSecond, _bufferCap)\n    {\n        token = _token;\n        role = _role;\n    }\n\n    /// @notice Mint new tokens.\n    /// Pausable and depletes the buffer, reverts if buffer is used.\n    /// @param to the recipient address of the minted tokens.\n    /// @param amount the amount of tokens to mint.\n    function mint(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(role) whenNotPaused {\n        _depleteBuffer(amount); /// check and effects\n        IERC20Mintable(token).mint(to, amount); /// interactions\n    }\n\n    /// @notice replenish the buffer.\n    /// This can be used when tokens are burnt, for instance.\n    /// @param amount of tokens to replenish buffer by\n    function replenishBuffer(uint256 amount) external onlyCoreRole(role) {\n        _replenishBuffer(amount); /// effects\n    }\n}"
    },
    {
      "filename": "src/loan/SurplusGuildMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {SafeCastLib} from \"@src/external/solmate/SafeCastLib.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice SurplusGuildMinter allows GUILD to be minted from CREDIT collateral.\n/// In this contract, CREDIT tokens can be provided as first-loss capital to\n/// the surplus buffer of chosen terms, and in exchange, users can participate in the\n/// gauge voting system at a reduced capital cost & without exposure to GUILD\n/// token's price fluctuations. GUILD minted through this contract can only\n/// participate in the gauge system to increase debt ceiling and earn fees\n/// from selected lending terms.\n/// @dev note that any update to the `rewardRatio` (through `setRewardRatio`) will\n/// change the rewards of all pending unclaimed rewards. Before a proposal to update\n/// the reward ratio execute, this contract should be pinged with `getRewards` for\n/// all users that have pending rewards.\ncontract SurplusGuildMinter is CoreRef {\n    /// @notice minimum number of CREDIT to stake\n    uint256 public constant MIN_STAKE = 1e18;\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice emitted when a user stakes CREDIT on a target lending term\n    event Stake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user unstakes CREDIT on a target lending term\n    event Unstake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user is rewarded GUILD from non-zero interest\n    /// rate and closing their position without loss.\n    event GuildReward(\n        uint256 indexed timestamp,\n        address indexed user,\n        uint256 amount\n    );\n    /// @notice emitted when the mintRatio is updated\n    event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n    /// @notice emitted when the rewardRatio is updated\n    event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n\n    /// @notice reference to the ProfitManager\n    address public immutable profitManager;\n\n    /// @notice reference to the CREDIT token\n    address public immutable credit;\n\n    /// @notice reference to the GUILD token\n    address public immutable guild;\n\n    /// @notice reference to the RateLimitedGuildMinter\n    address public immutable rlgm;\n\n    /// @notice ratio of GUILD tokens minted per CREDIT tokens staked.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes 1e18 CREDIT tokens.\n    uint256 public mintRatio;\n\n    /// @notice ratio of GUILD tokens earned per CREDIT tokens earned.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes earned 1e18 CREDIT tokens.\n    uint256 public rewardRatio;\n\n    struct UserStake {\n        uint48 stakeTime;\n        uint48 lastGaugeLoss;\n        uint160 profitIndex;\n        uint128 credit;\n        uint128 guild;\n    }\n\n    /// @notice list of user stakes (stakes[user][term]=UserStake)\n    mapping(address => mapping(address => UserStake)) internal _stakes;\n\n    constructor(\n        address _core,\n        address _profitManager,\n        address _credit,\n        address _guild,\n        address _rlgm,\n        uint256 _mintRatio,\n        uint256 _rewardRatio\n    ) CoreRef(_core) {\n        profitManager = _profitManager;\n        credit = _credit;\n        guild = _guild;\n        rlgm = _rlgm;\n        mintRatio = _mintRatio;\n        rewardRatio = _rewardRatio;\n    }\n\n    /// @notice get a given user stake\n    function getUserStake(\n        address user,\n        address term\n    ) external view returns (UserStake memory) {\n        return _stakes[user][term];\n    }\n\n    /// @notice stake CREDIT tokens to start voting in a gauge.\n    function stake(address term, uint256 amount) external whenNotPaused {\n        // apply pending rewards\n        (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(\n            msg.sender,\n            term\n        );\n\n        require(\n            lastGaugeLoss != block.timestamp,\n            \"SurplusGuildMinter: loss in block\"\n        );\n        require(amount >= MIN_STAKE, \"SurplusGuildMinter: min stake\");\n\n        // pull CREDIT from user & transfer it to surplus buffer\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        CreditToken(credit).approve(address(profitManager), amount);\n        ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);\n\n        // self-mint GUILD tokens\n        uint256 _mintRatio = mintRatio;\n        uint256 guildAmount = (_mintRatio * amount) / 1e18;\n        RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n        GuildToken(guild).incrementGauge(term, guildAmount);\n\n        // update state\n        userStake = UserStake({\n            stakeTime: SafeCastLib.safeCastTo48(block.timestamp),\n            lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),\n            profitIndex: SafeCastLib.safeCastTo160(\n                ProfitManager(profitManager).userGaugeProfitIndex(\n                    address(this),\n                    term\n                )\n            ),\n            credit: userStake.credit + SafeCastLib.safeCastTo128(amount),\n            guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)\n        });\n        _stakes[msg.sender][term] = userStake;\n\n        // emit event\n        emit Stake(block.timestamp, term, amount);\n    }\n\n    /// @notice unstake CREDIT tokens and stop voting in a gauge.\n    function unstake(address term, uint256 amount) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(\n            msg.sender,\n            term\n        );\n\n        // if the user has been slashed, there is nothing to do\n        if (slashed) return;\n\n        // check that the user is at least staking `amount` CREDIT\n        require(\n            amount != 0 && userStake.credit >= amount,\n            \"SurplusGuildMinter: invalid amount\"\n        );\n\n        // update stake\n        uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /\n            userStake.credit; /// upcast guild to prevent overflow\n        uint256 guildAmount = (userMintRatio * amount) / 1e18;\n\n        if (amount == userStake.credit) guildAmount = userStake.guild;\n\n        userStake.credit -= SafeCastLib.safeCastTo128(amount);\n        userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);\n\n        if (userStake.credit == 0) {\n            userStake.stakeTime = 0;\n            userStake.lastGaugeLoss = 0;\n            userStake.profitIndex = 0;\n        } else {\n            // if not unstaking all, make sure the stake remains\n            // greater than the minimum stake\n            require(\n                userStake.credit >= MIN_STAKE,\n                \"SurplusGuildMinter: remaining stake below min\"\n            );\n        }\n        _stakes[msg.sender][term] = userStake;\n\n        // withdraw & transfer CREDIT\n        ProfitManager(profitManager).withdrawFromTermSurplusBuffer(\n            term,\n            msg.sender,\n            amount\n        );\n\n        // burn GUILD\n        GuildToken(guild).decrementGauge(term, guildAmount);\n        RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n        GuildToken(guild).burn(guildAmount);\n\n        // emit event\n        emit Unstake(block.timestamp, term, amount);\n    }\n\n    /// @notice get rewards from a staking position without unstaking.\n    /// This can be used to slash users that have an outstanding unapplied loss.\n    function getRewards(\n        address user,\n        address term\n    )\n        public\n        returns (\n            uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)\n            UserStake memory userStake, // stake state after execution of getRewards()\n            bool slashed // true if the user has been slashed\n        )\n    {\n        bool updateState;\n        lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);\n        if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {\n            slashed = true;\n        }\n\n        // if the user is not staking, do nothing\n        userStake = _stakes[user][term];\n        if (userStake.stakeTime == 0)\n            return (lastGaugeLoss, userStake, slashed);\n\n        // compute CREDIT rewards\n        ProfitManager(profitManager).claimRewards(address(this)); // this will update profit indexes\n        uint256 _profitIndex = ProfitManager(profitManager)\n            .userGaugeProfitIndex(address(this), term);\n        uint256 _userProfitIndex = uint256(userStake.profitIndex);\n\n        if (_profitIndex == 0) _profitIndex = 1e18;\n        if (_userProfitIndex == 0) _userProfitIndex = 1e18;\n\n        uint256 deltaIndex = _profitIndex - _userProfitIndex;\n\n        if (deltaIndex != 0) {\n            uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /\n                1e18;\n            uint256 guildReward = (creditReward * rewardRatio) / 1e18;\n            if (slashed) {\n                guildReward = 0;\n            }\n\n            // forward rewards to user\n            if (guildReward != 0) {\n                RateLimitedMinter(rlgm).mint(user, guildReward);\n                emit GuildReward(block.timestamp, user, guildReward);\n            }\n            if (creditReward != 0) {\n                CreditToken(credit).transfer(user, creditReward);\n            }\n\n            // save the updated profitIndex\n            userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);\n            updateState = true;\n        }\n\n        // if a loss occurred while the user was staking, the GuildToken.applyGaugeLoss(address(this))\n        // can be called by anyone to slash address(this) and decrement gauge weight etc.\n        // The contribution to the surplus buffer is also forfeited.\n        if (slashed) {\n            emit Unstake(block.timestamp, term, uint256(userStake.credit));\n            userStake = UserStake({\n                stakeTime: uint48(0),\n                lastGaugeLoss: uint48(0),\n                profitIndex: uint160(0),\n                credit: uint128(0),\n                guild: uint128(0)\n            });\n            updateState = true;\n        }\n\n        // store the updated stake, if needed\n        if (updateState) {\n            _stakes[user][term] = userStake;\n        }\n    }\n\n    /// @notice update the mint ratio for a given user.\n    function updateMintRatio(address user, address term) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(user, term);\n\n        // if the user has been slashed or isnt staking, there is nothing to do\n        if (userStake.stakeTime == 0 || slashed) return;\n\n        // update amount of GUILD tokens staked\n        uint256 guildBefore = uint256(userStake.guild);\n        uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18;\n        if (guildAfter > guildBefore) {\n            uint256 guildAmount = guildAfter - guildBefore;\n            RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n            GuildToken(guild).incrementGauge(term, guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        } else if (guildAfter < guildBefore) {\n            uint256 guildAmount = guildBefore - guildAfter;\n            GuildToken(guild).decrementGauge(term, guildAmount);\n            RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n            GuildToken(guild).burn(guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        }\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens minted\n    /// per CREDIT tokens contributed to the surplus buffer.\n    function setMintRatio(\n        uint256 _mintRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        mintRatio = _mintRatio;\n        emit MintRatioUpdate(block.timestamp, _mintRatio);\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens rewarded\n    /// per CREDIT tokens earned from GUILD staking.\n    function setRewardRatio(\n        uint256 _rewardRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        rewardRatio = _rewardRatio;\n        emit RewardRatioUpdate(block.timestamp, _rewardRatio);\n    }\n}"
    },
    {
      "filename": "src/loan/SurplusGuildMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {SafeCastLib} from \"@src/external/solmate/SafeCastLib.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice SurplusGuildMinter allows GUILD to be minted from CREDIT collateral.\n/// In this contract, CREDIT tokens can be provided as first-loss capital to\n/// the surplus buffer of chosen terms, and in exchange, users can participate in the\n/// gauge voting system at a reduced capital cost & without exposure to GUILD\n/// token's price fluctuations. GUILD minted through this contract can only\n/// participate in the gauge system to increase debt ceiling and earn fees\n/// from selected lending terms.\n/// @dev note that any update to the `rewardRatio` (through `setRewardRatio`) will\n/// change the rewards of all pending unclaimed rewards. Before a proposal to update\n/// the reward ratio execute, this contract should be pinged with `getRewards` for\n/// all users that have pending rewards.\ncontract SurplusGuildMinter is CoreRef {\n    /// @notice minimum number of CREDIT to stake\n    uint256 public constant MIN_STAKE = 1e18;\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice emitted when a user stakes CREDIT on a target lending term\n    event Stake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user unstakes CREDIT on a target lending term\n    event Unstake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user is rewarded GUILD from non-zero interest\n    /// rate and closing their position without loss.\n    event GuildReward(\n        uint256 indexed timestamp,\n        address indexed user,\n        uint256 amount\n    );\n    /// @notice emitted when the mintRatio is updated\n    event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n    /// @notice emitted when the rewardRatio is updated\n    event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n\n    /// @notice reference to the ProfitManager\n    address public immutable profitManager;\n\n    /// @notice reference to the CREDIT token\n    address public immutable credit;\n\n    /// @notice reference to the GUILD token\n    address public immutable guild;\n\n    /// @notice reference to the RateLimitedGuildMinter\n    address public immutable rlgm;\n\n    /// @notice ratio of GUILD tokens minted per CREDIT tokens staked.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes 1e18 CREDIT tokens.\n    uint256 public mintRatio;\n\n    /// @notice ratio of GUILD tokens earned per CREDIT tokens earned.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes earned 1e18 CREDIT tokens.\n    uint256 public rewardRatio;\n\n    struct UserStake {\n        uint48 stakeTime;\n        uint48 lastGaugeLoss;\n        uint160 profitIndex;\n        uint128 credit;\n        uint128 guild;\n    }\n\n    /// @notice list of user stakes (stakes[user][term]=UserStake)\n    mapping(address => mapping(address => UserStake)) internal _stakes;\n\n    constructor(\n        address _core,\n        address _profitManager,\n        address _credit,\n        address _guild,\n        address _rlgm,\n        uint256 _mintRatio,\n        uint256 _rewardRatio\n    ) CoreRef(_core) {\n        profitManager = _profitManager;\n        credit = _credit;\n        guild = _guild;\n        rlgm = _rlgm;\n        mintRatio = _mintRatio;\n        rewardRatio = _rewardRatio;\n    }\n\n    /// @notice get a given user stake\n    function getUserStake(\n        address user,\n        address term\n    ) external view returns (UserStake memory) {\n        return _stakes[user][term];\n    }\n\n    /// @notice stake CREDIT tokens to start voting in a gauge.\n    function stake(address term, uint256 amount) external whenNotPaused {\n        // apply pending rewards\n        (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(\n            msg.sender,\n            term\n        );\n\n        require(\n            lastGaugeLoss != block.timestamp,\n            \"SurplusGuildMinter: loss in block\"\n        );\n        require(amount >= MIN_STAKE, \"SurplusGuildMinter: min stake\");\n\n        // pull CREDIT from user & transfer it to surplus buffer\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        CreditToken(credit).approve(address(profitManager), amount);\n        ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);\n\n        // self-mint GUILD tokens\n        uint256 _mintRatio = mintRatio;\n        uint256 guildAmount = (_mintRatio * amount) / 1e18;\n        RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n        GuildToken(guild).incrementGauge(term, guildAmount);\n\n        // update state\n        userStake = UserStake({\n            stakeTime: SafeCastLib.safeCastTo48(block.timestamp),\n            lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),\n            profitIndex: SafeCastLib.safeCastTo160(\n                ProfitManager(profitManager).userGaugeProfitIndex(\n                    address(this),\n                    term\n                )\n            ),\n            credit: userStake.credit + SafeCastLib.safeCastTo128(amount),\n            guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)\n        });\n        _stakes[msg.sender][term] = userStake;\n\n        // emit event\n        emit Stake(block.timestamp, term, amount);\n    }\n\n    /// @notice unstake CREDIT tokens and stop voting in a gauge.\n    function unstake(address term, uint256 amount) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(\n            msg.sender,\n            term\n        );\n\n        // if the user has been slashed, there is nothing to do\n        if (slashed) return;\n\n        // check that the user is at least staking `amount` CREDIT\n        require(\n            amount != 0 && userStake.credit >= amount,\n            \"SurplusGuildMinter: invalid amount\"\n        );\n\n        // update stake\n        uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /\n            userStake.credit; /// upcast guild to prevent overflow\n        uint256 guildAmount = (userMintRatio * amount) / 1e18;\n\n        if (amount == userStake.credit) guildAmount = userStake.guild;\n\n        userStake.credit -= SafeCastLib.safeCastTo128(amount);\n        userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);\n\n        if (userStake.credit == 0) {\n            userStake.stakeTime = 0;\n            userStake.lastGaugeLoss = 0;\n            userStake.profitIndex = 0;\n        } else {\n            // if not unstaking all, make sure the stake remains\n            // greater than the minimum stake\n            require(\n                userStake.credit >= MIN_STAKE,\n                \"SurplusGuildMinter: remaining stake below min\"\n            );\n        }\n        _stakes[msg.sender][term] = userStake;\n\n        // withdraw & transfer CREDIT\n        ProfitManager(profitManager).withdrawFromTermSurplusBuffer(\n            term,\n            msg.sender,\n            amount\n        );\n\n        // burn GUILD\n        GuildToken(guild).decrementGauge(term, guildAmount);\n        RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n        GuildToken(guild).burn(guildAmount);\n\n        // emit event\n        emit Unstake(block.timestamp, term, amount);\n    }\n\n    /// @notice get rewards from a staking position without unstaking.\n    /// This can be used to slash users that have an outstanding unapplied loss.\n    function getRewards(\n        address user,\n        address term\n    )\n        public\n        returns (\n            uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)\n            UserStake memory userStake, // stake state after execution of getRewards()\n            bool slashed // true if the user has been slashed\n        )\n    {\n        bool updateState;\n        lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);\n        if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {\n            slashed = true;\n        }\n\n        // if the user is not staking, do nothing\n        userStake = _stakes[user][term];\n        if (userStake.stakeTime == 0)\n            return (lastGaugeLoss, userStake, slashed);\n\n        // compute CREDIT rewards\n        ProfitManager(profitManager).claimRewards(address(this)); // this will update profit indexes\n        uint256 _profitIndex = ProfitManager(profitManager)\n            .userGaugeProfitIndex(address(this), term);\n        uint256 _userProfitIndex = uint256(userStake.profitIndex);\n\n        if (_profitIndex == 0) _profitIndex = 1e18;\n        if (_userProfitIndex == 0) _userProfitIndex = 1e18;\n\n        uint256 deltaIndex = _profitIndex - _userProfitIndex;\n\n        if (deltaIndex != 0) {\n            uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /\n                1e18;\n            uint256 guildReward = (creditReward * rewardRatio) / 1e18;\n            if (slashed) {\n                guildReward = 0;\n            }\n\n            // forward rewards to user\n            if (guildReward != 0) {\n                RateLimitedMinter(rlgm).mint(user, guildReward);\n                emit GuildReward(block.timestamp, user, guildReward);\n            }\n            if (creditReward != 0) {\n                CreditToken(credit).transfer(user, creditReward);\n            }\n\n            // save the updated profitIndex\n            userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);\n            updateState = true;\n        }\n\n        // if a loss occurred while the user was staking, the GuildToken.applyGaugeLoss(address(this))\n        // can be called by anyone to slash address(this) and decrement gauge weight etc.\n        // The contribution to the surplus buffer is also forfeited.\n        if (slashed) {\n            emit Unstake(block.timestamp, term, uint256(userStake.credit));\n            userStake = UserStake({\n                stakeTime: uint48(0),\n                lastGaugeLoss: uint48(0),\n                profitIndex: uint160(0),\n                credit: uint128(0),\n                guild: uint128(0)\n            });\n            updateState = true;\n        }\n\n        // store the updated stake, if needed\n        if (updateState) {\n            _stakes[user][term] = userStake;\n        }\n    }\n\n    /// @notice update the mint ratio for a given user.\n    function updateMintRatio(address user, address term) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(user, term);\n\n        // if the user has been slashed or isnt staking, there is nothing to do\n        if (userStake.stakeTime == 0 || slashed) return;\n\n        // update amount of GUILD tokens staked\n        uint256 guildBefore = uint256(userStake.guild);\n        uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18;\n        if (guildAfter > guildBefore) {\n            uint256 guildAmount = guildAfter - guildBefore;\n            RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n            GuildToken(guild).incrementGauge(term, guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        } else if (guildAfter < guildBefore) {\n            uint256 guildAmount = guildBefore - guildAfter;\n            GuildToken(guild).decrementGauge(term, guildAmount);\n            RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n            GuildToken(guild).burn(guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        }\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens minted\n    /// per CREDIT tokens contributed to the surplus buffer.\n    function setMintRatio(\n        uint256 _mintRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        mintRatio = _mintRatio;\n        emit MintRatioUpdate(block.timestamp, _mintRatio);\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens rewarded\n    /// per CREDIT tokens earned from GUILD staking.\n    function setRewardRatio(\n        uint256 _rewardRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        rewardRatio = _rewardRatio;\n        emit RewardRatioUpdate(block.timestamp, _rewardRatio);\n    }\n}"
    }
  ]
}