{
  "Title": "Changes to initialization contracts are not recommended after they are executed on-chain",
  "Content": "It is understood that certain modifications to BIP initialization contracts have been made retroactively with the intention that, if run again, any new deployments of the Beanstalk protocol by replaying this history will reflect the current state of Beanstalk. One particular [modification](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/beanstalk/init/InitDiamond.sol#L62) to `InitDiamond::init`, setting the `stemStartSeason` to zero, while seemingly benign as migration logic in `LibSilo` appears to be bypassed, would result in underdlow within `LibLegacyTokenSilo::_calcGrownStalkForDeposit` when calculating the [Season diff](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/libraries/Silo/LibLegacyTokenSilo.sol#L469). This issue will be present until `InitBipNewSilo::init` excutes, setting the `stemStartSeason` state to the [Season in which it is executed](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/beanstalk/init/InitBipNewSilo.sol#L76-L77). It is therefore recommended that initialization scripts are ossified after being executed on-chain to maintain an accurate history of the protocol: its mechanism developments, bugs and related upgrades/mitigations.\n\n**Beanstalk Farms:** The purpose of such changes is to future proof future deployments of Beanstalk. If someone were to deploy a fresh Beanstalk, it is important that the protocol continues to function as expected with all upgrades already implemented.\n\nThe expectation is that a new Beanstalk would be initialized only with `InitDiamond` and that Beanstalk would automatically be on the newest version. The other `Init` contracts are intended strictly to migrate from a previous version to the next.\n\nThe `LibLegacyTokenSilo` is only used to provide legacy support and migration functionality for Silo V2. This includes, the `MigrationFacet`, `LegacyClaimWithdrawalFacet` and `seasonToStem(address token, uint32 season)` in `SiloExit`. The expectation is that a new Beanstalk would be deployed immediately with the Silo V3 upgrade and thus have no reason to be backwards compatable with Silo V2 or support migration from V2 to V3 in any capacity.\n\n**Cyfrin:** Acknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/init/InitDiamond.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {AppStorage} from \"../AppStorage.sol\";\nimport {IERC165} from \"../../interfaces/IERC165.sol\";\nimport {IDiamondCut} from \"../../interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"../../interfaces/IDiamondLoupe.sol\";\nimport {LibDiamond} from \"../../libraries/LibDiamond.sol\";\nimport {LibIncentive} from \"../../libraries/LibIncentive.sol\";\nimport \"../../C.sol\";\nimport \"../../interfaces/IBean.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../mocks/MockToken.sol\";\n\n/**\n * @author Publius\n * @title Init Diamond initializes the Beanstalk Diamond.\n**/\ncontract InitDiamond {\n\n    event Incentivization(address indexed account, uint256 beans);\n\n    AppStorage internal s;\n\n    address private constant PEG_PAIR = address(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n\n    function init() external {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[0xd9b67a26] = true; // ERC1155\n        ds.supportedInterfaces[0x0e89341c] = true; // ERC1155Metadata\n\n\n        C.bean().approve(C.CURVE_BEAN_METAPOOL, type(uint256).max);\n        C.bean().approve(C.curveZapAddress(), type(uint256).max);\n        C.usdc().approve(C.curveZapAddress(), type(uint256).max);\n\n        s.cases = s.cases = [\n        // Dsc, Sdy, Inc, nul\n       int8(3),   1,   0,   0,  // Exs Low: P < 1\n            -1,  -3,  -3,   0,  //          P > 1\n             3,   1,   0,   0,  // Rea Low: P < 1\n            -1,  -3,  -3,   0,  //          P > 1\n             3,   3,   1,   0,  // Rea Hgh: P < 1\n             0,  -1,  -3,   0,  //          P > 1\n             3,   3,   1,   0,  // Exs Hgh: P < 1\n             0,  -1,  -3,   0   //          P > 1\n        ];\n        s.w.t = 1;\n\n        s.season.current = 1;\n        s.season.withdrawSeasons = 25;\n        s.season.period = C.getSeasonPeriod();\n        s.season.timestamp = block.timestamp;\n        s.season.stemStartSeason = 0;\n        s.season.start = s.season.period > 0 ?\n            (block.timestamp / s.season.period) * s.season.period :\n            block.timestamp;\n\n        s.w.thisSowTime = type(uint32).max;\n        s.w.lastSowTime = type(uint32).max;\n        s.isFarm = 1;\n        s.beanEthPrice = 1;\n        \n        C.bean().mint(msg.sender, LibIncentive.MAX_REWARD);\n        emit Incentivization(msg.sender, LibIncentive.MAX_REWARD);\n    }\n\n}"
    }
  ]
}