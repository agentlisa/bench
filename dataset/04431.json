{
  "Title": "Unnecessary setting of the active_recovery_end_time variable",
  "Content": "The variable `active_recovery_end_time` is consumed only in the `finish_recovery` function (on [line 120](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L120)), which has the `only_during_recovery` modifier. The `only_during_recovery` modifier passes only when `active_recovery_addressÂ != address(0)`. This occurs only after `start_recovery` has been called and before either `cancel_recovery` or `finish_recovery` has been called.\n\n\nSince `start_recovery` sets `active_recovery_end_time`, there is no need to set `active_recovery_end_time = uint256(-1)` on [line 67](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L67). Consider leaving the `active_recovery_end_time` variable uninitialized on [line 67](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L67).\n\n\nFor the same reason, it is unnecessary to set `active_recovery_end_time = uint256(-1);` in the `reset_recovery` function on [line 146](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L146). Consider removing the code at [line 146](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L146).\n\n\n***Update:*** *No changes have been made here. Setting* *`active_recovery_end_time`* *to* *`uint256(-1)`* *is intended to make code auditing and strict invariant checks easier.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/source/recoverable-wallet.sol",
      "content": "pragma solidity 0.5.8;\n\ninterface Erc1820Registry {\n\tfunction setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract Erc777TokensRecipient {\n\tconstructor() public {\n\t\tErc1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).setInterfaceImplementer(address(this), keccak256(abi.encodePacked(\"ERC777TokensRecipient\")), address(this));\n\t}\n\tfunction tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external { }\n\tfunction canImplementInterfaceForAddress(address, bytes32) external pure returns(bytes32) { return keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")); }\n}\n\ncontract Ownable {\n\tevent ownership_transfer_started(address indexed owner, address indexed pending_owner);\n\tevent ownership_transfer_cancelled(address indexed owner, address indexed pending_owner);\n\tevent ownership_transfer_finished(address indexed old_owner, address indexed new_owner);\n\n\taddress public owner;\n\taddress public pending_owner;\n\n\tconstructor(address _owner) public {\n\t\trequire(_owner != address(0), \"Contract must have an owner.\");\n\t\towner = _owner;\n\t}\n\n\tmodifier only_owner() {\n\t\trequire(msg.sender == owner, \"Only the owner may call this method.\");\n\t\t_;\n\t}\n\n\tmodifier only_pending_owner() {\n\t\trequire(msg.sender == pending_owner, \"Only the pending owner can call this method.\");\n\t\t_;\n\t}\n\n\tfunction start_ownership_transfer(address _pending_owner) external only_owner {\n\t\trequire(_pending_owner != address(0), \"Contract must have an owner.\");\n\t\tpending_owner = _pending_owner;\n\t\temit ownership_transfer_started(owner, pending_owner);\n\t}\n\n\tfunction cancel_ownership_transfer() external only_owner {\n\t\taddress _pending_owner = pending_owner;\n\t\tpending_owner = address(0);\n\t\temit ownership_transfer_cancelled(owner, _pending_owner);\n\t}\n\n\tfunction accept_ownership() external only_pending_owner {\n\t\taddress _old_owner = owner;\n\t\towner = pending_owner;\n\t\tpending_owner = address(0);\n\t\temit ownership_transfer_finished(_old_owner, owner);\n\t}\n}\n\ncontract RecoverableWallet is Ownable, Erc777TokensRecipient {\n\tevent recovery_address_added(address indexed new_recoverer, uint256 recovery_delay_in_days);\n\tevent recovery_address_removed(address indexed old_recoverer);\n\tevent recovery_started(address indexed new_owner);\n\tevent recovery_cancelled();\n\tevent recovery_finished(address indexed new_pending_owner);\n\n\tmapping(address => uint16) public recovery_delays;\n\taddress public active_recovery_address;\n\tuint256 public active_recovery_end_time = uint256(-1);\n\n\tmodifier only_during_recovery() {\n\t\trequire(active_recovery_address != address(0), \"This method can only be called during a recovery.\");\n\t\t_;\n\t}\n\n\tmodifier only_outside_recovery() {\n\t\trequire(active_recovery_address == address(0), \"This method cannot be called during a recovery.\");\n\t\t_;\n\t}\n\n\tconstructor(address _initial_owner) Ownable(_initial_owner) public {\n\t\treset_recovery();\n\t}\n\n\t// accept ETH into this contract\n\tfunction () external payable { }\n\n\tfunction add_recovery_address(address _new_recovery_address, uint16 _recovery_delay_in_days) external only_owner only_outside_recovery {\n\t\trequire(_recovery_delay_in_days > 0, \"Recovery delay must be at least 1 day.\");\n\t\trecovery_delays[_new_recovery_address] = _recovery_delay_in_days;\n\t\temit recovery_address_added(_new_recovery_address, _recovery_delay_in_days);\n\t}\n\n\tfunction remove_recovery_address(address _old_recovery_address) external only_owner only_outside_recovery {\n\t\trecovery_delays[_old_recovery_address] = 0;\n\t\temit recovery_address_removed(_old_recovery_address);\n\t}\n\n\tfunction start_recovery() external {\n\t\tuint16 _proposed_recovery_delay = recovery_delays[msg.sender];\n\t\trequire(_proposed_recovery_delay != 0, \"Only designated recovery addresseses can initiate the recovery process.\");\n\n\t\tbool _in_recovery = active_recovery_address != address(0);\n\t\tif (_in_recovery) {\n\t\t\t// NOTE: the recovery address cannot change during recovery, so we can rely on this being != 0\n\t\t\tuint16 _active_recovery_delay = recovery_delays[active_recovery_address];\n\t\t\trequire(_proposed_recovery_delay < _active_recovery_delay, \"Recovery is already under way and new recovery doesn't have a higher priority.\");\n\t\t}\n\n\t\tactive_recovery_address = msg.sender;\n\t\tactive_recovery_end_time = block.timestamp + _proposed_recovery_delay * 1 days;\n\t\temit recovery_started(msg.sender);\n\t}\n\n\tfunction cancel_recovery() external only_owner only_during_recovery {\n\t\treset_recovery();\n\t\temit recovery_cancelled();\n\t}\n\n\tfunction finish_recovery() external only_during_recovery {\n\t\trequire(active_recovery_address != address(0), \"No recovery in progress.\");\n\t\trequire(block.timestamp > active_recovery_end_time, \"You must wait until the recovery delay is over before finishing the recovery.\");\n\n\t\tpending_owner = active_recovery_address;\n\t\treset_recovery();\n\t\temit recovery_finished(pending_owner);\n\t}\n\n\tfunction deploy(uint256 _value, bytes calldata _data, uint256 _salt) external payable only_owner only_outside_recovery returns (address) {\n\t\tbytes memory _data2 = _data;\n\t\taddress new_contract;\n\t\t/* solium-disable-next-line */\n\t\tassembly {\n\t\t\tnew_contract := create2(_value, add(_data2, 32), mload(_data2), _salt)\n\t\t}\n\t\trequire(new_contract != address(0), \"Contract creation failed.\");\n\t\treturn new_contract;\n\t}\n\n\tfunction execute(address payable _to, uint256 _value, bytes calldata _data) external payable only_owner only_outside_recovery returns (bytes memory) {\n\t\t(bool _success, bytes memory _result) = _to.call.value(_value)(_data);\n\t\trequire(_success, \"Contract execution failed.\");\n\t\treturn _result;\n\t}\n\n\tfunction reset_recovery() private {\n\t\tactive_recovery_address = address(0);\n\t\tactive_recovery_end_time = uint256(-1);\n\t}\n}\n\ncontract RecoverableWalletFactory {\n\tevent wallet_created(address indexed owner, RecoverableWallet indexed wallet);\n\n\tfunction create_wallet() external returns (RecoverableWallet) {\n\t\tRecoverableWallet wallet = new RecoverableWallet(msg.sender);\n\t\temit wallet_created(msg.sender, wallet);\n\t\treturn wallet;\n\t}\n\n\tfunction exists() external pure returns (bytes32) {\n\t\treturn 0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef;\n\t}\n}"
    },
    {
      "filename": "contracts/source/recoverable-wallet.sol",
      "content": "pragma solidity 0.5.8;\n\ninterface Erc1820Registry {\n\tfunction setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract Erc777TokensRecipient {\n\tconstructor() public {\n\t\tErc1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).setInterfaceImplementer(address(this), keccak256(abi.encodePacked(\"ERC777TokensRecipient\")), address(this));\n\t}\n\tfunction tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external { }\n\tfunction canImplementInterfaceForAddress(address, bytes32) external pure returns(bytes32) { return keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")); }\n}\n\ncontract Ownable {\n\tevent ownership_transfer_started(address indexed owner, address indexed pending_owner);\n\tevent ownership_transfer_cancelled(address indexed owner, address indexed pending_owner);\n\tevent ownership_transfer_finished(address indexed old_owner, address indexed new_owner);\n\n\taddress public owner;\n\taddress public pending_owner;\n\n\tconstructor(address _owner) public {\n\t\trequire(_owner != address(0), \"Contract must have an owner.\");\n\t\towner = _owner;\n\t}\n\n\tmodifier only_owner() {\n\t\trequire(msg.sender == owner, \"Only the owner may call this method.\");\n\t\t_;\n\t}\n\n\tmodifier only_pending_owner() {\n\t\trequire(msg.sender == pending_owner, \"Only the pending owner can call this method.\");\n\t\t_;\n\t}\n\n\tfunction start_ownership_transfer(address _pending_owner) external only_owner {\n\t\trequire(_pending_owner != address(0), \"Contract must have an owner.\");\n\t\tpending_owner = _pending_owner;\n\t\temit ownership_transfer_started(owner, pending_owner);\n\t}\n\n\tfunction cancel_ownership_transfer() external only_owner {\n\t\taddress _pending_owner = pending_owner;\n\t\tpending_owner = address(0);\n\t\temit ownership_transfer_cancelled(owner, _pending_owner);\n\t}\n\n\tfunction accept_ownership() external only_pending_owner {\n\t\taddress _old_owner = owner;\n\t\towner = pending_owner;\n\t\tpending_owner = address(0);\n\t\temit ownership_transfer_finished(_old_owner, owner);\n\t}\n}\n\ncontract RecoverableWallet is Ownable, Erc777TokensRecipient {\n\tevent recovery_address_added(address indexed new_recoverer, uint256 recovery_delay_in_days);\n\tevent recovery_address_removed(address indexed old_recoverer);\n\tevent recovery_started(address indexed new_owner);\n\tevent recovery_cancelled();\n\tevent recovery_finished(address indexed new_pending_owner);\n\n\tmapping(address => uint16) public recovery_delays;\n\taddress public active_recovery_address;\n\tuint256 public active_recovery_end_time = uint256(-1);\n\n\tmodifier only_during_recovery() {\n\t\trequire(active_recovery_address != address(0), \"This method can only be called during a recovery.\");\n\t\t_;\n\t}\n\n\tmodifier only_outside_recovery() {\n\t\trequire(active_recovery_address == address(0), \"This method cannot be called during a recovery.\");\n\t\t_;\n\t}\n\n\tconstructor(address _initial_owner) Ownable(_initial_owner) public {\n\t\treset_recovery();\n\t}\n\n\t// accept ETH into this contract\n\tfunction () external payable { }\n\n\tfunction add_recovery_address(address _new_recovery_address, uint16 _recovery_delay_in_days) external only_owner only_outside_recovery {\n\t\trequire(_recovery_delay_in_days > 0, \"Recovery delay must be at least 1 day.\");\n\t\trecovery_delays[_new_recovery_address] = _recovery_delay_in_days;\n\t\temit recovery_address_added(_new_recovery_address, _recovery_delay_in_days);\n\t}\n\n\tfunction remove_recovery_address(address _old_recovery_address) external only_owner only_outside_recovery {\n\t\trecovery_delays[_old_recovery_address] = 0;\n\t\temit recovery_address_removed(_old_recovery_address);\n\t}\n\n\tfunction start_recovery() external {\n\t\tuint16 _proposed_recovery_delay = recovery_delays[msg.sender];\n\t\trequire(_proposed_recovery_delay != 0, \"Only designated recovery addresseses can initiate the recovery process.\");\n\n\t\tbool _in_recovery = active_recovery_address != address(0);\n\t\tif (_in_recovery) {\n\t\t\t// NOTE: the recovery address cannot change during recovery, so we can rely on this being != 0\n\t\t\tuint16 _active_recovery_delay = recovery_delays[active_recovery_address];\n\t\t\trequire(_proposed_recovery_delay < _active_recovery_delay, \"Recovery is already under way and new recovery doesn't have a higher priority.\");\n\t\t}\n\n\t\tactive_recovery_address = msg.sender;\n\t\tactive_recovery_end_time = block.timestamp + _proposed_recovery_delay * 1 days;\n\t\temit recovery_started(msg.sender);\n\t}\n\n\tfunction cancel_recovery() external only_owner only_during_recovery {\n\t\treset_recovery();\n\t\temit recovery_cancelled();\n\t}\n\n\tfunction finish_recovery() external only_during_recovery {\n\t\trequire(active_recovery_address != address(0), \"No recovery in progress.\");\n\t\trequire(block.timestamp > active_recovery_end_time, \"You must wait until the recovery delay is over before finishing the recovery.\");\n\n\t\tpending_owner = active_recovery_address;\n\t\treset_recovery();\n\t\temit recovery_finished(pending_owner);\n\t}\n\n\tfunction deploy(uint256 _value, bytes calldata _data, uint256 _salt) external payable only_owner only_outside_recovery returns (address) {\n\t\tbytes memory _data2 = _data;\n\t\taddress new_contract;\n\t\t/* solium-disable-next-line */\n\t\tassembly {\n\t\t\tnew_contract := create2(_value, add(_data2, 32), mload(_data2), _salt)\n\t\t}\n\t\trequire(new_contract != address(0), \"Contract creation failed.\");\n\t\treturn new_contract;\n\t}\n\n\tfunction execute(address payable _to, uint256 _value, bytes calldata _data) external payable only_owner only_outside_recovery returns (bytes memory) {\n\t\t(bool _success, bytes memory _result) = _to.call.value(_value)(_data);\n\t\trequire(_success, \"Contract execution failed.\");\n\t\treturn _result;\n\t}\n\n\tfunction reset_recovery() private {\n\t\tactive_recovery_address = address(0);\n\t\tactive_recovery_end_time = uint256(-1);\n\t}\n}\n\ncontract RecoverableWalletFactory {\n\tevent wallet_created(address indexed owner, RecoverableWallet indexed wallet);\n\n\tfunction create_wallet() external returns (RecoverableWallet) {\n\t\tRecoverableWallet wallet = new RecoverableWallet(msg.sender);\n\t\temit wallet_created(msg.sender, wallet);\n\t\treturn wallet;\n\t}\n\n\tfunction exists() external pure returns (bytes32) {\n\t\treturn 0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef;\n\t}\n}"
    },
    {
      "filename": "contracts/source/recoverable-wallet.sol",
      "content": "pragma solidity 0.5.8;\n\ninterface Erc1820Registry {\n\tfunction setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n}\n\ncontract Erc777TokensRecipient {\n\tconstructor() public {\n\t\tErc1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).setInterfaceImplementer(address(this), keccak256(abi.encodePacked(\"ERC777TokensRecipient\")), address(this));\n\t}\n\tfunction tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external { }\n\tfunction canImplementInterfaceForAddress(address, bytes32) external pure returns(bytes32) { return keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")); }\n}\n\ncontract Ownable {\n\tevent ownership_transfer_started(address indexed owner, address indexed pending_owner);\n\tevent ownership_transfer_cancelled(address indexed owner, address indexed pending_owner);\n\tevent ownership_transfer_finished(address indexed old_owner, address indexed new_owner);\n\n\taddress public owner;\n\taddress public pending_owner;\n\n\tconstructor(address _owner) public {\n\t\trequire(_owner != address(0), \"Contract must have an owner.\");\n\t\towner = _owner;\n\t}\n\n\tmodifier only_owner() {\n\t\trequire(msg.sender == owner, \"Only the owner may call this method.\");\n\t\t_;\n\t}\n\n\tmodifier only_pending_owner() {\n\t\trequire(msg.sender == pending_owner, \"Only the pending owner can call this method.\");\n\t\t_;\n\t}\n\n\tfunction start_ownership_transfer(address _pending_owner) external only_owner {\n\t\trequire(_pending_owner != address(0), \"Contract must have an owner.\");\n\t\tpending_owner = _pending_owner;\n\t\temit ownership_transfer_started(owner, pending_owner);\n\t}\n\n\tfunction cancel_ownership_transfer() external only_owner {\n\t\taddress _pending_owner = pending_owner;\n\t\tpending_owner = address(0);\n\t\temit ownership_transfer_cancelled(owner, _pending_owner);\n\t}\n\n\tfunction accept_ownership() external only_pending_owner {\n\t\taddress _old_owner = owner;\n\t\towner = pending_owner;\n\t\tpending_owner = address(0);\n\t\temit ownership_transfer_finished(_old_owner, owner);\n\t}\n}\n\ncontract RecoverableWallet is Ownable, Erc777TokensRecipient {\n\tevent recovery_address_added(address indexed new_recoverer, uint256 recovery_delay_in_days);\n\tevent recovery_address_removed(address indexed old_recoverer);\n\tevent recovery_started(address indexed new_owner);\n\tevent recovery_cancelled();\n\tevent recovery_finished(address indexed new_pending_owner);\n\n\tmapping(address => uint16) public recovery_delays;\n\taddress public active_recovery_address;\n\tuint256 public active_recovery_end_time = uint256(-1);\n\n\tmodifier only_during_recovery() {\n\t\trequire(active_recovery_address != address(0), \"This method can only be called during a recovery.\");\n\t\t_;\n\t}\n\n\tmodifier only_outside_recovery() {\n\t\trequire(active_recovery_address == address(0), \"This method cannot be called during a recovery.\");\n\t\t_;\n\t}\n\n\tconstructor(address _initial_owner) Ownable(_initial_owner) public {\n\t\treset_recovery();\n\t}\n\n\t// accept ETH into this contract\n\tfunction () external payable { }\n\n\tfunction add_recovery_address(address _new_recovery_address, uint16 _recovery_delay_in_days) external only_owner only_outside_recovery {\n\t\trequire(_recovery_delay_in_days > 0, \"Recovery delay must be at least 1 day.\");\n\t\trecovery_delays[_new_recovery_address] = _recovery_delay_in_days;\n\t\temit recovery_address_added(_new_recovery_address, _recovery_delay_in_days);\n\t}\n\n\tfunction remove_recovery_address(address _old_recovery_address) external only_owner only_outside_recovery {\n\t\trecovery_delays[_old_recovery_address] = 0;\n\t\temit recovery_address_removed(_old_recovery_address);\n\t}\n\n\tfunction start_recovery() external {\n\t\tuint16 _proposed_recovery_delay = recovery_delays[msg.sender];\n\t\trequire(_proposed_recovery_delay != 0, \"Only designated recovery addresseses can initiate the recovery process.\");\n\n\t\tbool _in_recovery = active_recovery_address != address(0);\n\t\tif (_in_recovery) {\n\t\t\t// NOTE: the recovery address cannot change during recovery, so we can rely on this being != 0\n\t\t\tuint16 _active_recovery_delay = recovery_delays[active_recovery_address];\n\t\t\trequire(_proposed_recovery_delay < _active_recovery_delay, \"Recovery is already under way and new recovery doesn't have a higher priority.\");\n\t\t}\n\n\t\tactive_recovery_address = msg.sender;\n\t\tactive_recovery_end_time = block.timestamp + _proposed_recovery_delay * 1 days;\n\t\temit recovery_started(msg.sender);\n\t}\n\n\tfunction cancel_recovery() external only_owner only_during_recovery {\n\t\treset_recovery();\n\t\temit recovery_cancelled();\n\t}\n\n\tfunction finish_recovery() external only_during_recovery {\n\t\trequire(active_recovery_address != address(0), \"No recovery in progress.\");\n\t\trequire(block.timestamp > active_recovery_end_time, \"You must wait until the recovery delay is over before finishing the recovery.\");\n\n\t\tpending_owner = active_recovery_address;\n\t\treset_recovery();\n\t\temit recovery_finished(pending_owner);\n\t}\n\n\tfunction deploy(uint256 _value, bytes calldata _data, uint256 _salt) external payable only_owner only_outside_recovery returns (address) {\n\t\tbytes memory _data2 = _data;\n\t\taddress new_contract;\n\t\t/* solium-disable-next-line */\n\t\tassembly {\n\t\t\tnew_contract := create2(_value, add(_data2, 32), mload(_data2), _salt)\n\t\t}\n\t\trequire(new_contract != address(0), \"Contract creation failed.\");\n\t\treturn new_contract;\n\t}\n\n\tfunction execute(address payable _to, uint256 _value, bytes calldata _data) external payable only_owner only_outside_recovery returns (bytes memory) {\n\t\t(bool _success, bytes memory _result) = _to.call.value(_value)(_data);\n\t\trequire(_success, \"Contract execution failed.\");\n\t\treturn _result;\n\t}\n\n\tfunction reset_recovery() private {\n\t\tactive_recovery_address = address(0);\n\t\tactive_recovery_end_time = uint256(-1);\n\t}\n}\n\ncontract RecoverableWalletFactory {\n\tevent wallet_created(address indexed owner, RecoverableWallet indexed wallet);\n\n\tfunction create_wallet() external returns (RecoverableWallet) {\n\t\tRecoverableWallet wallet = new RecoverableWallet(msg.sender);\n\t\temit wallet_created(msg.sender, wallet);\n\t\treturn wallet;\n\t}\n\n\tfunction exists() external pure returns (bytes32) {\n\t\treturn 0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef;\n\t}\n}"
    }
  ]
}