{
  "Title": "Ability to change the value of a private variable from another contract",
  "Content": "##### Description\nThe private variable `reserve` has a lot to do with the logic behind this smart contract. The value of this variable is changed in this contract. If you change the value of this variable from another contract, then the basic logic of the smart contract may be violated, up to the complete stop of the smart contract.\nConsidering that the setter for this variable `setReserve()` defined [here](https://github.com/iearn-finance/yearn-vaults/blob/54db126821c4d7aaaf5839be935cecb9b1bf088b/contracts/BaseStrategy.sol#L156) is an internal function and there is no event logging when the value of this variable is changed.\nIn addition, according to the rules of clean architecture and the principles of software development SOLID (single responsibility, open–closed, Liskov substitution, interface segregation и dependency inversion), each module should be responsible for only one functionality.\nIt is not correct when, in addition to the BaseStrategy contract, the logic of the `harvest()` and `setEmergencyExit()` functions will be changed by another contract created for other purposes.\n\n\n##### Recommendation\nWe recommend removing this functionality.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/BaseStrategy.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelinV3/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelinV3/contracts/math/SafeMath.sol\";\n\nstruct StrategyParams {\n    uint256 performanceFee;\n    uint256 activation;\n    uint256 debtLimit;\n    uint256 rateLimit;\n    uint256 lastReport;\n    uint256 totalDebt;\n    uint256 totalReturns;\n}\n\ninterface VaultAPI is IERC20 {\n    function apiVersion() external view returns (string memory);\n\n    function token() external view returns (address);\n\n    function strategies(address _strategy) external view returns (StrategyParams memory);\n\n    /*\n     * View how much the Vault would increase this strategy's borrow limit,\n     * based on it's present performance (since its last report). Can be used to\n     * determine expectedReturn in your strategy.\n     */\n    function creditAvailable() external view returns (uint256);\n\n    /*\n     * View how much the Vault would like to pull back from the Strategy,\n     * based on it's present performance (since its last report). Can be used to\n     * determine expectedReturn in your strategy.\n     */\n    function debtOutstanding() external view returns (uint256);\n\n    /*\n     * View how much the Vault expect this strategy to return at the current block,\n     * based on it's present performance (since its last report). Can be used to\n     * determine expectedReturn in your strategy.\n     */\n    function expectedReturn() external view returns (uint256);\n\n    /*\n     * This is the main contact point where the strategy interacts with the Vault.\n     * It is critical that this call is handled as intended by the Strategy.\n     * Therefore, this function will be called by BaseStrategy to make sure the\n     * integration is correct.\n     */\n    function report(uint256 _harvest) external returns (uint256);\n\n    /*\n     * This function is used in the scenario where there is a newer strategy that\n     * would hold the same positions as this one, and those positions are easily\n     * transferrable to the newer strategy. These positions must be able to be\n     * transferred at the moment this call is made, if any prep is required to\n     * execute a full transfer in one transaction, that must be accounted for\n     * separately from this call.\n     */\n    function migrateStrategy(address _newStrategy) external;\n\n    /*\n     * This function should only be used in the scenario where the strategy is\n     * being retired but no migration of the positions are possible, or in the\n     * extreme scenario that the Strategy needs to be put into \"Emergency Exit\"\n     * mode in order for it to exit as quickly as possible. The latter scenario\n     * could be for any reason that is considered \"critical\" that the Strategy\n     * exits it's position as fast as possible, such as a sudden change in market\n     * conditions leading to losses, or an imminent failure in an external\n     * dependency.\n     */\n    function revokeStrategy() external;\n\n    /*\n     * View the governance address of the Vault to assert privileged functions\n     * can only be called by governance. The Strategy serves the Vault, so it\n     * is subject to governance defined by the Vault.\n     *\n     */\n    function governance() external view returns (address);\n}\n\n/*\n * This interface is here for the keeper bot to use\n */\ninterface StrategyAPI {\n    function apiVersion() external pure returns (string memory);\n\n    function name() external pure returns (string memory);\n\n    function vault() external view returns (address);\n\n    function keeper() external view returns (address);\n\n    function tendTrigger(uint256 callCost) external view returns (bool);\n\n    function tend() external;\n\n    function harvestTrigger(uint256 callCost) external view returns (bool);\n\n    function harvest() external;\n\n    event Harvested(uint256 profit);\n}\n\n/*\n * BaseStrategy implements all of the required functionality to interoperate closely\n * with the core protocol. This contract should be inherited and the abstract methods\n * implemented to adapt the strategy to the particular needs it has to create a return.\n */\n\nabstract contract BaseStrategy {\n    using SafeMath for uint256;\n\n    // Version of this contract's StrategyAPI (must match Vault)\n    function apiVersion() public pure returns (string memory) {\n        return \"0.1.3\";\n    }\n\n    // Name of this contract's Strategy (Must override!)\n    // NOTE: You can use this field to manage the \"version\" of this strategy\n    //       e.g. `StrategySomethingOrOtherV1`. It's up to you!\n    function name() external virtual pure returns (string memory);\n\n    VaultAPI public vault;\n    address public strategist;\n    address public rewards;\n    address public keeper;\n\n    IERC20 public want;\n\n    // So indexers can keep track of this\n    event Harvested(uint256 profit);\n\n    // The minimum number of blocks between harvest calls\n    // NOTE: Override this value with your own, or set dynamically below\n    uint256 public minReportDelay = 6300; // ~ once a day\n\n    // The minimum multiple that `callCost` must be above the credit/profit to be \"justifiable\"\n    // NOTE: Override this value with your own, or set dynamically below\n    uint256 public profitFactor = 100;\n\n    // Use this to adjust the threshold at which running a debt causes a harvest trigger\n    uint256 public debtThreshold = 0;\n\n    // Adjust this using `setReserve(...)` to keep some of the position in reserve in the strategy,\n    // to accomodate larger variations needed to sustain the strategy's core positon(s)\n    uint256 private reserve = 0;\n\n    function getReserve() internal view returns (uint256) {\n        return reserve;\n    }\n\n    function setReserve(uint256 _reserve) internal {\n        if (_reserve != reserve) reserve = _reserve;\n    }\n\n    bool public emergencyExit;\n\n    constructor(address _vault) public {\n        vault = VaultAPI(_vault);\n        want = IERC20(vault.token());\n        want.approve(_vault, uint256(-1)); // Give Vault unlimited access (might save gas)\n        strategist = msg.sender;\n        rewards = msg.sender;\n        keeper = msg.sender;\n    }\n\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist || msg.sender == governance(), \"!authorized\");\n        strategist = _strategist;\n    }\n\n    function setKeeper(address _keeper) external {\n        require(msg.sender == strategist || msg.sender == governance(), \"!authorized\");\n        keeper = _keeper;\n    }\n\n    function setRewards(address _rewards) external {\n        require(msg.sender == strategist, \"!authorized\");\n        rewards = _rewards;\n    }\n\n    function setMinReportDelay(uint256 _delay) external {\n        require(msg.sender == strategist || msg.sender == governance(), \"!authorized\");\n        minReportDelay = _delay;\n    }\n\n    function setProfitFactor(uint256 _profitFactor) external {\n        require(msg.sender == strategist || msg.sender == governance(), \"!authorized\");\n        profitFactor = _profitFactor;\n    }\n\n    function setDebtThreshold(uint256 _debtThreshold) external {\n        require(msg.sender == strategist || msg.sender == governance(), \"!authorized\");\n        debtThreshold = _debtThreshold;\n    }\n\n    /*\n     * Resolve governance address from Vault contract, used to make\n     * assertions on protected functions in the Strategy\n     */\n    function governance() internal view returns (address) {\n        return vault.governance();\n    }\n\n    /*\n     * Provide an accurate estimate for the total amount of assets (principle + return)\n     * that this strategy is currently managing, denominated in terms of `want` tokens.\n     * This total should be \"realizable\" e.g. the total value that could *actually* be\n     * obtained from this strategy if it were to divest it's entire position based on\n     * current on-chain conditions.\n     *\n     * NOTE: care must be taken in using this function, since it relies on external\n     *       systems, which could be manipulated by the attacker to give an inflated\n     *       (or reduced) value produced by this function, based on current on-chain\n     *       conditions (e.g. this function is possible to influence through flashloan\n     *       attacks, oracle manipulations, or other DeFi attack mechanisms).\n     *\n     * NOTE: It is up to governance to use this function to correctly order this strategy\n     *       relative to its peers in the withdrawal queue to minimize losses for the Vault\n     *       based on sudden withdrawals. This value should be higher than the total debt of\n     *       the strategy and higher than it's expected value to be \"safe\".\n     */\n    function estimatedTotalAssets() public virtual view returns (uint256);\n\n    /*\n     * Perform any strategy unwinding or other calls necessary to capture\n     * the \"free return\" this strategy has generated since the last time it's\n     * core position(s) were adusted. Examples include unwrapping extra rewards.\n     * This call is only used during \"normal operation\" of a Strategy, and should\n     * be optimized to minimize losses as much as possible. It is okay to report\n     * \"no returns\", however this will affect the credit limit extended to the\n     * strategy and reduce it's overall position if lower than expected returns\n     * are sustained for long periods of time.\n     */\n    function prepareReturn(uint256 _debtOutstanding) internal virtual returns (uint256 _profit);\n\n    /*\n     * Perform any adjustments to the core position(s) of this strategy given\n     * what change the Vault made in the \"investable capital\" available to the\n     * strategy. Note that all \"free capital\" in the strategy after the report\n     * was made is available for reinvestment. Also note that this number could\n     * be 0, and you should handle that scenario accordingly.\n     */\n    function adjustPosition(uint256 _debtOutstanding) internal virtual;\n\n    /*\n     * Make as much capital as possible \"free\" for the Vault to take. Some slippage\n     * is allowed, since when this method is called the strategist is no longer receiving\n     * their performance fee. The goal is for the strategy to divest as quickly as possible\n     * while not suffering exorbitant losses. This function is used during emergency exit\n     * instead of `prepareReturn()`\n     */\n    function exitPosition() internal virtual;\n\n    /*\n     * Vault calls this function after shares are created during `Vault.report()`.\n     * You can customize this function to any share distribution mechanism you want.\n     */\n    function distributeRewards(uint256 _shares) external virtual {\n        // Send 100% of newly-minted shares to the rewards address.\n        vault.transfer(rewards, _shares);\n    }\n\n    /*\n     * Provide a signal to the keeper that `tend()` should be called. The keeper will provide\n     * the estimated gas cost that they would pay to call `tend()`, and this function should\n     * use that estimate to make a determination if calling it is \"worth it\" for the keeper.\n     * This is not the only consideration into issuing this trigger, for example if the position\n     * would be negatively affected if `tend()` is not called shortly, then this can return `true`\n     * even if the keeper might be \"at a loss\" (keepers are always reimbursed by Yearn)\n     *\n     * NOTE: `callCost` must be priced in terms of `want`\n     *\n     * NOTE: this call and `harvestTrigger` should never return `true` at the same time.\n     */\n    function tendTrigger(uint256 callCost) public virtual view returns (bool) {\n        // We usually don't need tend, but if there are positions that need active maintainence,\n        // overriding this function is how you would signal for that\n        return false;\n    }\n\n    function tend() external {\n        if (keeper != address(0)) {\n            require(msg.sender == keeper || msg.sender == strategist || msg.sender == governance(), \"!authorized\");\n        }\n\n        // Don't take profits with this call, but adjust for better gains\n        adjustPosition(vault.debtOutstanding());\n    }\n\n    /*\n     * Provide a signal to the keeper that `harvest()` should be called. The keeper will provide\n     * the estimated gas cost that they would pay to call `harvest()`, and this function should\n     * use that estimate to make a determination if calling it is \"worth it\" for the keeper.\n     * This is not the only consideration into issuing this trigger, for example if the position\n     * would be negatively affected if `harvest()` is not called shortly, then this can return `true`\n     * even if the keeper might be \"at a loss\" (keepers are always reimbursed by Yearn)\n     *\n     * NOTE: `callCost` must be priced in terms of `want`\n     *\n     * NOTE: this call and `tendTrigger` should never return `true` at the same time.\n     */\n    function harvestTrigger(uint256 callCost) public virtual view returns (bool) {\n        StrategyParams memory params = vault.strategies(address(this));\n\n        // Should not trigger if strategy is not activated\n        if (params.activation == 0) return false;\n\n        // Should trigger if hadn't been called in a while\n        if (block.number.sub(params.lastReport) >= minReportDelay) return true;\n\n        // If some amount is owed, pay it back\n        // NOTE: Since debt is adjusted in step-wise fashion, it is appropiate to always trigger here,\n        //       because the resulting change should be large (might not always be the case)\n        uint256 outstanding = vault.debtOutstanding();\n        if (outstanding > 0) return true;\n\n        // Check for profits and losses\n        uint256 total = estimatedTotalAssets();\n        // Trigger if we have a loss to report\n        if (total.add(debtThreshold) < params.totalDebt) return true;\n\n        uint256 profit = 0;\n        if (total > params.totalDebt) profit = total.sub(params.totalDebt); // We've earned a profit!\n\n        // Otherwise, only trigger if it \"makes sense\" economically (gas cost is <N% of value moved)\n        uint256 credit = vault.creditAvailable();\n        return (profitFactor * callCost < credit.add(profit));\n    }\n\n    function harvest() external {\n        if (keeper != address(0)) {\n            require(msg.sender == keeper || msg.sender == strategist || msg.sender == governance(), \"!authorized\");\n        }\n\n        uint256 profit = 0;\n        if (emergencyExit) {\n            exitPosition(); // Free up as much capital as possible\n            // NOTE: Don't take performance fee in this scenario\n        } else {\n            profit = prepareReturn(vault.debtOutstanding()); // Free up returns for Vault to pull\n        }\n\n        if (reserve > want.balanceOf(address(this))) reserve = want.balanceOf(address(this));\n\n        // Allow Vault to take up to the \"harvested\" balance of this contract, which is\n        // the amount it has earned since the last time it reported to the Vault\n        uint256 outstanding = vault.report(want.balanceOf(address(this)).sub(reserve));\n\n        // Check if free returns are left, and re-invest them\n        adjustPosition(outstanding);\n\n        emit Harvested(profit);\n    }\n\n    /*\n     * Liquidate as many assets as possible to `want`, irregardless of slippage,\n     * up to `_amountNeeded`. Any excess should be re-invested here as well.\n     */\n    function liquidatePosition(uint256 _amountNeeded) internal virtual returns (uint256 _amountFreed);\n\n    function withdraw(uint256 _amountNeeded) external {\n        require(msg.sender == address(vault), \"!vault\");\n        // Liquidate as much as possible to `want`, up to `_amount`\n        uint256 amountFreed = liquidatePosition(_amountNeeded);\n        // Send it directly back (NOTE: Using `msg.sender` saves some gas here)\n        want.transfer(msg.sender, amountFreed);\n        // Adjust reserve to what we have after the freed amount is sent to the Vault\n        reserve = want.balanceOf(address(this));\n    }\n\n    /*\n     * Do anything necesseary to prepare this strategy for migration, such\n     * as transfering any reserve or LP tokens, CDPs, or other tokens or stores of value.\n     */\n    function prepareMigration(address _newStrategy) internal virtual;\n\n    function migrate(address _newStrategy) external {\n        require(msg.sender == address(vault) || msg.sender == governance());\n        require(BaseStrategy(_newStrategy).vault() == vault);\n        prepareMigration(_newStrategy);\n        want.transfer(_newStrategy, want.balanceOf(address(this)));\n    }\n\n    function setEmergencyExit() external {\n        require(msg.sender == strategist || msg.sender == governance(), \"!authorized\");\n        emergencyExit = true;\n        exitPosition();\n        vault.revokeStrategy();\n        if (reserve > want.balanceOf(address(this))) reserve = want.balanceOf(address(this));\n    }\n\n    // Override this to add all tokens/tokenized positions this contract manages\n    // on a *persistant* basis (e.g. not just for swapping back to want ephemerally)\n    // NOTE: Do *not* include `want`, already included in `sweep` below\n    //\n    // Example:\n    //\n    //    function protectedTokens() internal override view returns (address[] memory) {\n    //      address[] memory protected = new address[](3);\n    //      protected[0] = tokenA;\n    //      protected[1] = tokenB;\n    //      protected[2] = tokenC;\n    //      return protected;\n    //    }\n    function protectedTokens() internal virtual view returns (address[] memory);\n\n    function sweep(address _token) external {\n        require(msg.sender == governance(), \"!authorized\");\n        require(_token != address(want), \"!want\");\n\n        address[] memory _protectedTokens = protectedTokens();\n        for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], \"!protected\");\n\n        IERC20(_token).transfer(governance(), IERC20(_token).balanceOf(address(this)));\n    }\n}"
    }
  ]
}