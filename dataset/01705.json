{
  "Title": "M-1: Lenders lose interests and pay deposit fees due to no slippage control",
  "Content": "# Issue M-1: Lenders lose interests and pay deposit fees due to no slippage control \n\nSource: https://github.com/sherlock-audit/2023-04-ajna-judging/issues/72 \n\n## Found by \nbranch\\_indigo\n## Summary\nWhen a lender deposits quote tokens below the minimum of LUP(Lowest Utilization Price) and HTP(Highest Threshold Price), the deposits will not earn interest and will also be charged deposit fees, according to [docs](https://www.ajna.finance/pdf/Ajna%20Protocol%20Whitepaper_03-24-2023.pdf). When a lender deposits to a bucket, they are vulnerable to pool LUP slippage which might cause them to lose funds due to fee charges against their will. \n## Vulnerability Detail\n\n\nA lender would call `addQuoteToken()` to deposit. This function only allows entering expiration time for transaction settlement, but there is no slippage protection. \n```solidity\n//Pool.sol\n    function addQuoteToken(\n        uint256 amount_,\n        uint256 index_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 bucketLP_) {\n        _revertAfterExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n        // round to token precision\n        amount_ = _roundToScale(amount_, poolState.quoteTokenScale);\n        uint256 newLup;\n        (bucketLP_, newLup) = LenderActions.addQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            AddQuoteParams({\n                amount: amount_,\n                index:  index_\n            })\n        );\n       ...\n```\nIn LenderActions.sol, `addQuoteToken()` takes current `DepositsState` in storage and current `poolState_.debt` in storage to calculate spot LUP prior to deposit. And this LUP is compared with user input bucket `index_` to determine if the lender will be punished with deposit fees. The deposit amount is then written to storage. \n```solidity\n//LenderActions.sol\n    function addQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        AddQuoteParams calldata params_\n    ) external returns (uint256 bucketLP_, uint256 lup_) {\n  ...\n          // charge unutilized deposit fee where appropriate\n |>       uint256 lupIndex = Deposits.findIndexOfSum(deposits_, poolState_.debt);\n        bool depositBelowLup = lupIndex != 0 && params_.index > lupIndex;\n        if (depositBelowLup) {\n            addedAmount = Maths.wmul(addedAmount, Maths.WAD - _depositFeeRate(poolState_.rate));\n        }\n...\n   Deposits.unscaledAdd(deposits_, params_.index, unscaledAmount);\n...\n```\nIt should be noted that current `deposits_` and `poolState_.debt` can be different from when the user invoked the transaction, which will result in a different LUP spot price unforeseen by the lender to determine deposit fees. Even though lenders can input a reasonable expiration time `expirty_`, this will only prevent stale transactions to be executed and not offer any slippage control. \n\nWhen there are many lenders depositing around the same time, LUP spot price can be increased and if the user transaction settles after a whale lender which moves the LUP spot price up significantly, the user might get accidentally punished for depositing below LUP. Or there could also be malicious lenders trying to ensure their transactions settle at a favorable LUP/HTP and front-run the user transaction, in which case the user transaction might still settle after the malicious lender and potentially get charged for fees.\n\n## Impact\nLenders might get charged deposit fees due to slippage against their will with or without MEV attacks, lenders might also lose on interest by depositing below HTP. \n\n## Code Snippet\n[https://github.com/ajna-finance/ajna-core/blob/e3632f6d0b196fb1bf1e59c05fb85daf357f2386/src/base/Pool.sol#L146-L150](https://github.com/ajna-finance/ajna-core/blob/e3632f6d0b196fb1bf1e59c05fb85daf357f2386/src/base/Pool.sol#L146-L150)\n\n[https://github.com/ajna-finance/ajna-core/blob/e3632f6d0b196fb1bf1e59c05fb85daf357f2386/src/libraries/external/LenderActions.sol](https://github.com/ajna-finance/ajna-core/blob/e3632f6d0b196fb1bf1e59c05fb85daf357f2386/src/libraries/external/LenderActions.sol#L173)\n\n[https://github.com/ajna-finance/ajna-core/blob/e3632f6d0b196fb1bf1e59c05fb85daf357f2386/src/libraries/external/LenderActions.sol#L195](https://github.com/ajna-finance/ajna-core/blob/e3632f6d0b196fb1bf1e59c05fb85daf357f2386/src/libraries/external/LenderActions.sol#L195)\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd slippage protection in Pool.sol `addQuoteToken()`. A lender can enable slippage protection, which will enable comparing deposit `index_` with `lupIndex` in LenderActions.sol.\n\n\n\n## Discussion\n\n**ith-harvey**\n\nWe think this should be a low. Although not explicitly stated that this can happen in docs it is assumed based off of implementation. We were aware, not concerned.\n\n**grandizzy**\n\nhttps://github.com/ajna-finance/contracts/pull/915\n\n**0xffff11**\n\nI can still see the issue as a medium. Sponsor agreed to the issue and it has some impact on the fees that lender might have to pay\n\n**dmitriia**\n\n> [ajna-finance/contracts#915](https://github.com/ajna-finance/contracts/pull/915)\n\nLooks ok, but shouldn't the same flag be introduced to `moveQuoteToken()`, e.g.:\n\nhttps://github.com/ajna-finance/contracts/blob/0332f341856e1efe4da8bb675886c8cfbee57b71/src/libraries/external/LenderActions.sol#L290-L292\n\n```diff\n    if (vars.fromBucketPrice >= lup_ && vars.toBucketPrice < lup_) {\n+       if (params_.revertIfBelowLup) revert PriceBelowLUP();\n        movedAmount_ = Maths.wmul(movedAmount_, Maths.WAD - _depositFeeRate(poolState_.rate));\n    }\n```\n\n**grandizzy**\n\n> > [ajna-finance/contracts#915](https://github.com/ajna-finance/contracts/pull/915)\n> \n> Looks ok, but shouldn't the same flag be introduced to `moveQuoteToken()`, e.g.:\n> \n> https://github.com/ajna-finance/contracts/blob/0332f341856e1efe4da8bb675886c8cfbee57b71/src/libraries/external/LenderActions.sol#L290-L292\n> \n> ```diff\n>     if (vars.fromBucketPrice >= lup_ && vars.toBucketPrice < lup_) {\n> +       if (params_.revertIfBelowLup) revert PriceBelowLUP();\n>         movedAmount_ = Maths.wmul(movedAmount_, Maths.WAD - _depositFeeRate(poolState_.rate));\n>     }\n> ```\n\nimplemented with https://github.com/ajna-finance/contracts/pull/918\nBeside suggested change there are 2 additional updates\n- `MoveQuoteParams` struct moved from inline in order to avoid stack too deep error\n- shrink `Pool` contract size by reading structs in view functions only once\n\n**dmitriia**\n\n> implemented with [ajna-finance/contracts#918](https://github.com/ajna-finance/contracts/pull/918)\n\nLooks ok, the above logic now added.\n\n**ctf-sec**\n\nEscalate for 10 USDC.\n\nAs the sponsor said\n\n> We think this should be a low. Although not explicitly stated that this can happen in docs it is assumed based off of implementation. We were aware, not concerned.\n\nthis is more like a feature request, not bug\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> As the sponsor said\n> \n> > We think this should be a low. Although not explicitly stated that this can happen in docs it is assumed based off of implementation. We were aware, not concerned.\n> \n> this is more like a feature request, not bug\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**bzpassersby**\n\nI think this issue is a valid medium. It points to a possible scenario where a lender has to pay fees and lose interest against their will due to no slippage protection, which can be exploited through MEV attack. Because of the scenario of lenders losing funds against their intention, it should be medium.\n\nDue to the fact that slippage can be exploited to cause users to lose funds, this should be considered a vulnerability or bug.\n\n**0xffff11**\n\nI disagree with the escalation in this case. I think it should be a medium. Despite being a design decision, allows users to be exposed to high slippage on behalf of their decision. \n\n**dmitriia**\n\nLooks like valid medium to me, the probability of the material impact can be said to be medium, so is the impact itself.\n\n**MLON33**\n\n> > implemented with [ajna-finance/contracts#918](https://github.com/ajna-finance/contracts/pull/918)\n> \n> Looks ok, the above logic now added.\n\nMoving sign-off by @dmitriia here for clarity.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering a valid medium based on the above comments\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ctf-sec](https://github.com/sherlock-audit/2023-04-ajna-judging/issues/72/#issuecomment-1616656759): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/75",
  "Code": [
    {
      "filename": "src/libraries/external/LenderActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { Math } from '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport {\n    AddQuoteParams,\n    MoveQuoteParams,\n    RemoveQuoteParams\n}                     from '../../interfaces/pool/commons/IPoolInternals.sol';\nimport {\n    Bucket,\n    DepositsState,\n    Lender,\n    PoolState\n}                     from '../../interfaces/pool/commons/IPoolState.sol';\n\nimport { _depositFeeRate, _priceAt, MAX_FENWICK_INDEX } from '../helpers/PoolHelper.sol';\n\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  LenderActions library\n    @notice External library containing logic for lender actors:\n            - `Lenders`: add, remove and move quote tokens;\n            - `Traders`: add, remove and move quote tokens; add and remove collateral\n */\nlibrary LenderActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `moveQuoteToken` function local vars.\n    struct MoveQuoteLocalVars {\n        uint256 fromBucketPrice;            // [WAD] Price of the bucket to move amount from.\n        uint256 fromBucketCollateral;       // [WAD] Total amount of collateral in from bucket.\n        uint256 fromBucketLP;               // [WAD] Total amount of LP in from bucket.\n        uint256 fromBucketLenderLP;         // [WAD] Amount of LP owned by lender in from bucket.\n        uint256 fromBucketDepositTime;      // Time of lender deposit in the bucket to move amount from.\n        uint256 fromBucketRemainingLP;      // Amount of LP remaining in from bucket after move.\n        uint256 fromBucketRemainingDeposit; // Amount of scaled deposit remaining in from bucket after move.\n        uint256 toBucketPrice;              // [WAD] Price of the bucket to move amount to.\n        uint256 toBucketBankruptcyTime;     // Time the bucket to move amount to was marked as insolvent.\n        uint256 toBucketDepositTime;        // Time of lender deposit in the bucket to move amount to.\n        uint256 toBucketUnscaledDeposit;    // Amount of unscaled deposit in to bucket.\n        uint256 toBucketDeposit;            // Amount of scaled deposit in to bucket.\n        uint256 toBucketScale;              // Scale deposit of to bucket.\n        uint256 htp;                        // [WAD] Highest Threshold Price.\n    }\n\n    /// @dev Struct used for `removeQuoteToken` function local vars.\n    struct RemoveDepositParams {\n        uint256 depositConstraint; // [WAD] Constraint on deposit in quote token.\n        uint256 lpConstraint;      // [WAD] Constraint in LPB terms.\n        uint256 bucketLP;          // [WAD] Total LPB in the bucket.\n        uint256 bucketCollateral;  // [WAD] Claimable collateral in the bucket.\n        uint256 price;             // [WAD] Price of bucket.\n        uint256 index;             // Bucket index.\n        uint256 dustLimit;         // Minimum amount of deposit which may reside in a bucket.\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AddQuoteToken(address indexed lender, uint256 indexed index, uint256 amount, uint256 lpAwarded, uint256 lup);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    event MoveQuoteToken(address indexed lender, uint256 indexed from, uint256 indexed to, uint256 amount, uint256 lpRedeemedFrom, uint256 lpAwardedTo, uint256 lup);\n    event RemoveQuoteToken(address indexed lender, uint256 indexed index, uint256 amount, uint256 lpRedeemed, uint256 lup);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error BucketBankruptcyBlock();\n    error CannotMergeToHigherPrice();\n    error DustAmountNotExceeded();\n    error InvalidIndex();\n    error InvalidAmount();\n    error LUPBelowHTP();\n    error NoClaim();\n    error InsufficientLP();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error MoveToSameIndex();\n    error PriceBelowLUP();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IERC20PoolLenderActions` and `IERC721PoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `Buckets.addCollateral`:\n     *  @dev      increment `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev      `addLenderLP`: increment `lender.lps` accumulator and `lender.depositTime `state\n     *  @dev    === Reverts on ===\n     *  @dev    invalid bucket index `InvalidIndex()`\n     *  @dev    no LP awarded in bucket `InsufficientLP()`\n     */\n    function addCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 collateralAmountToAdd_,\n        uint256 index_\n    ) external returns (uint256 bucketLP_) {\n        // revert if no amount to be added\n        if (collateralAmountToAdd_ == 0) revert InvalidAmount();\n        // revert if adding at invalid index\n        if (index_ == 0 || index_ > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n        uint256 bucketDeposit = Deposits.valueAt(deposits_, index_);\n        uint256 bucketPrice   = _priceAt(index_);\n\n        bucketLP_ = Buckets.addCollateral(\n            buckets_[index_],\n            msg.sender,\n            bucketDeposit,\n            collateralAmountToAdd_,\n            bucketPrice\n        );\n\n        // revert if (due to rounding) the awarded LP is 0\n        if (bucketLP_ == 0) revert InsufficientLP();\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.unscaledAdd` (add new amount in `Fenwick` tree): update `values` array state \n     *  @dev    - increment `bucket.lps` accumulator\n     *  @dev    - increment `lender.lps` accumulator and `lender.depositTime` state\n     *  @dev    === Reverts on ===\n     *  @dev    invalid bucket index `InvalidIndex()`\n     *  @dev    same block when bucket becomes insolvent `BucketBankruptcyBlock()`\n     *  @dev    no LP awarded in bucket `InsufficientLP()`\n     *  @dev    calculated unscaled amount to add is 0 `InvalidAmount()`\n     *  @dev    === Emit events ===\n     *  @dev    - `AddQuoteToken`\n     */\n    function addQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        AddQuoteParams calldata params_\n    ) external returns (uint256 bucketLP_, uint256 lup_) {\n        // revert if no amount to be added\n        if (params_.amount == 0) revert InvalidAmount();\n        // revert if adding to an invalid index\n        if (params_.index == 0 || params_.index > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n        Bucket storage bucket = buckets_[params_.index];\n\n        uint256 bankruptcyTime = bucket.bankruptcyTime;\n\n        // cannot deposit in the same block when bucket becomes insolvent\n        if (bankruptcyTime == block.timestamp) revert BucketBankruptcyBlock();\n\n        uint256 unscaledBucketDeposit = Deposits.unscaledValueAt(deposits_, params_.index);\n        uint256 bucketScale           = Deposits.scale(deposits_, params_.index);\n        uint256 bucketDeposit         = Maths.wmul(bucketScale, unscaledBucketDeposit);\n        uint256 bucketPrice           = _priceAt(params_.index);\n        uint256 addedAmount           = params_.amount;\n\n        // charge unutilized deposit fee where appropriate\n        uint256 lupIndex = Deposits.findIndexOfSum(deposits_, poolState_.debt);\n        bool depositBelowLup = lupIndex != 0 && params_.index > lupIndex;\n\n        if (depositBelowLup) {\n            if (params_.revertIfBelowLup) revert PriceBelowLUP();\n\n            addedAmount = Maths.wmul(addedAmount, Maths.WAD - _depositFeeRate(poolState_.rate));\n        }\n\n        bucketLP_ = Buckets.quoteTokensToLP(\n            bucket.collateral,\n            bucket.lps,\n            bucketDeposit,\n            addedAmount,\n            bucketPrice,\n            Math.Rounding.Down\n        );\n\n        // revert if (due to rounding) the awarded LP is 0\n        if (bucketLP_ == 0) revert InsufficientLP();\n\n        uint256 unscaledAmount = Maths.wdiv(addedAmount, bucketScale);\n        // revert if unscaled amount is 0\n        if (unscaledAmount == 0) revert InvalidAmount();\n\n        Deposits.unscaledAdd(deposits_, params_.index, unscaledAmount);\n\n        // update lender LP\n        Buckets.addLenderLP(bucket, bankruptcyTime, msg.sender, bucketLP_);\n\n        // update bucket LP\n        bucket.lps += bucketLP_;\n\n        // only need to recalculate LUP if the deposit was above it\n        if (!depositBelowLup) {\n            lupIndex = Deposits.findIndexOfSum(deposits_, poolState_.debt);\n        }\n        lup_ = _priceAt(lupIndex);\n\n        emit AddQuoteToken(\n            msg.sender,\n            params_.index,\n            addedAmount,\n            bucketLP_,\n            lup_\n        );\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `_removeMaxDeposit`:\n     *  @dev      `Deposits.unscaledRemove` (remove amount in `Fenwick` tree, from index): update `values` array state\n     *  @dev    - `Deposits.unscaledAdd` (add amount in `Fenwick` tree, to index): update `values` array state\n     *  @dev    - decrement `lender.lps` accumulator for from bucket\n     *  @dev    - increment `lender.lps` accumulator and `lender.depositTime` state for to bucket\n     *  @dev    - decrement `bucket.lps` accumulator for from bucket\n     *  @dev    - increment `bucket.lps` accumulator for to bucket\n     *  @dev    === Reverts on ===\n     *  @dev    same index `MoveToSameIndex()`\n     *  @dev    dust amount `DustAmountNotExceeded()`\n     *  @dev    invalid index `InvalidIndex()`\n     *  @dev    no LP awarded in to bucket `InsufficientLP()`\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     *  @dev    - `MoveQuoteToken`\n     */\n    function moveQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        MoveQuoteParams calldata params_\n    ) external returns (uint256 fromBucketRedeemedLP_, uint256 toBucketLP_, uint256 movedAmount_, uint256 lup_) {\n        if (params_.maxAmountToMove == 0)\n            revert InvalidAmount();\n        if (params_.fromIndex == params_.toIndex)\n            revert MoveToSameIndex();\n        if (params_.maxAmountToMove != 0 && params_.maxAmountToMove < poolState_.quoteTokenScale)\n            revert DustAmountNotExceeded();\n        if (params_.toIndex == 0 || params_.toIndex > MAX_FENWICK_INDEX) \n            revert InvalidIndex();\n\n        Bucket storage toBucket = buckets_[params_.toIndex];\n\n        MoveQuoteLocalVars memory vars;\n        vars.toBucketBankruptcyTime = toBucket.bankruptcyTime;\n\n        // cannot move in the same block when target bucket becomes insolvent\n        if (vars.toBucketBankruptcyTime == block.timestamp) revert BucketBankruptcyBlock();\n\n        Bucket storage fromBucket       = buckets_[params_.fromIndex];\n        Lender storage fromBucketLender = fromBucket.lenders[msg.sender];\n\n        vars.fromBucketPrice       = _priceAt(params_.fromIndex);\n        vars.fromBucketCollateral  = fromBucket.collateral;\n        vars.fromBucketLP          = fromBucket.lps;\n        vars.fromBucketDepositTime = fromBucketLender.depositTime;\n\n        vars.toBucketPrice         = _priceAt(params_.toIndex);\n\n        if (fromBucket.bankruptcyTime < vars.fromBucketDepositTime) vars.fromBucketLenderLP = fromBucketLender.lps;\n\n        (movedAmount_, fromBucketRedeemedLP_, vars.fromBucketRemainingDeposit) = _removeMaxDeposit(\n            deposits_,\n            RemoveDepositParams({\n                depositConstraint: params_.maxAmountToMove,\n                lpConstraint:      vars.fromBucketLenderLP,\n                bucketLP:          vars.fromBucketLP,\n                bucketCollateral:  vars.fromBucketCollateral,\n                price:             vars.fromBucketPrice,\n                index:             params_.fromIndex,\n                dustLimit:         poolState_.quoteTokenScale\n            })\n        );\n\n        lup_ = Deposits.getLup(deposits_, poolState_.debt);\n        // apply unutilized deposit fee if quote token is moved from above the LUP to below the LUP\n        if (vars.fromBucketPrice >= lup_ && vars.toBucketPrice < lup_) {\n            movedAmount_ = Maths.wmul(movedAmount_, Maths.WAD - _depositFeeRate(poolState_.rate));\n        }\n\n        vars.toBucketUnscaledDeposit = Deposits.unscaledValueAt(deposits_, params_.toIndex);\n        vars.toBucketScale           = Deposits.scale(deposits_, params_.toIndex);\n        vars.toBucketDeposit         = Maths.wmul(vars.toBucketUnscaledDeposit, vars.toBucketScale);\n\n        toBucketLP_ = Buckets.quoteTokensToLP(\n            toBucket.collateral,\n            toBucket.lps,\n            vars.toBucketDeposit,\n            movedAmount_,\n            vars.toBucketPrice,\n            Math.Rounding.Down\n        );\n\n        // revert if (due to rounding) the awarded LP in to bucket is 0\n        if (toBucketLP_ == 0) revert InsufficientLP();\n\n        Deposits.unscaledAdd(deposits_, params_.toIndex, Maths.wdiv(movedAmount_, vars.toBucketScale));\n\n        // recalculate LUP after adding amount in to bucket only if to bucket price is greater than LUP\n        if (vars.toBucketPrice > lup_) lup_ = Deposits.getLup(deposits_, poolState_.debt);\n\n        vars.htp = Maths.wmul(params_.thresholdPrice, poolState_.inflator);\n\n        // check loan book's htp against new lup, revert if move drives LUP below HTP\n        if (\n            params_.fromIndex < params_.toIndex\n            &&\n            (\n                // check loan book's htp doesn't exceed new lup\n                vars.htp > lup_\n                ||\n                // ensure that pool debt < deposits after move\n                // this can happen if deposit fee is applied when moving amount\n                (poolState_.debt != 0 && poolState_.debt > Deposits.treeSum(deposits_))\n            )\n        ) revert LUPBelowHTP();\n\n        // update lender and bucket LP balance in from bucket\n        vars.fromBucketRemainingLP = vars.fromBucketLP - fromBucketRedeemedLP_;\n\n        // check if from bucket healthy after move quote tokens - set bankruptcy if collateral and deposit are 0 but there's still LP\n        if (vars.fromBucketCollateral == 0 && vars.fromBucketRemainingDeposit == 0 && vars.fromBucketRemainingLP != 0) {\n            fromBucket.lps            = 0;\n            fromBucket.bankruptcyTime = block.timestamp;\n\n            emit BucketBankruptcy(\n                params_.fromIndex,\n                vars.fromBucketRemainingLP\n            );\n        } else {\n            // update lender and bucket LP balance\n            fromBucketLender.lps -= fromBucketRedeemedLP_;\n\n            fromBucket.lps = vars.fromBucketRemainingLP;\n        }\n\n        // update lender and bucket LP balance in target bucket\n        Lender storage toBucketLender = toBucket.lenders[msg.sender];\n\n        vars.toBucketDepositTime = toBucketLender.depositTime;\n        if (vars.toBucketBankruptcyTime >= vars.toBucketDepositTime) {\n            // bucket is bankrupt and deposit was done before bankruptcy time, reset lender lp amount\n            toBucketLender.lps = toBucketLP_;\n\n            // set deposit time of the lender's to bucket as bucket's last bankruptcy timestamp + 1 so deposit won't get invalidated\n            vars.toBucketDepositTime = vars.toBucketBankruptcyTime + 1;\n        } else {\n            toBucketLender.lps += toBucketLP_;\n        }\n\n        // set deposit time to the greater of the lender's from bucket and the target bucket\n        toBucketLender.depositTime = Maths.max(vars.fromBucketDepositTime, vars.toBucketDepositTime);\n\n        // update bucket LP balance\n        toBucket.lps += toBucketLP_;\n\n        emit MoveQuoteToken(\n            msg.sender,\n            params_.fromIndex,\n            params_.toIndex,\n            movedAmount_,\n            fromBucketRedeemedLP_,\n            toBucketLP_,\n            lup_\n        );\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `_removeMaxDeposit`:\n     *  @dev      `Deposits.unscaledRemove` (remove amount in `Fenwick` tree, from index): update `values` array state\n     *  @dev    - decrement `lender.lps` accumulator\n     *  @dev    - decrement `bucket.lps` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    no `LP` `NoClaim()`;\n     *  @dev    `LUP` lower than `HTP` `LUPBelowHTP()`\n     *  @dev    === Emit events ===\n     *  @dev    - `RemoveQuoteToken`\n     *  @dev    - `BucketBankruptcy`\n     */\n    function removeQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        RemoveQuoteParams calldata params_\n    ) external returns (uint256 removedAmount_, uint256 redeemedLP_, uint256 lup_) {\n        // revert if no amount to be removed\n        if (params_.maxAmount == 0) revert InvalidAmount();\n\n        Bucket storage bucket = buckets_[params_.index];\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        uint256 depositTime = lender.depositTime;\n\n        RemoveDepositParams memory removeParams;\n\n        if (bucket.bankruptcyTime < depositTime) removeParams.lpConstraint = lender.lps;\n\n        // revert if no LP to claim\n        if (removeParams.lpConstraint == 0) revert NoClaim();\n\n        removeParams.depositConstraint = params_.maxAmount;\n        removeParams.price             = _priceAt(params_.index);\n        removeParams.bucketLP          = bucket.lps;\n        removeParams.bucketCollateral  = bucket.collateral;\n        removeParams.index             = params_.index;\n        removeParams.dustLimit         = poolState_.quoteTokenScale;\n\n        uint256 unscaledRemaining;\n\n        (removedAmount_, redeemedLP_, unscaledRemaining) = _removeMaxDeposit(\n            deposits_,\n            removeParams\n        );\n\n        lup_ = Deposits.getLup(deposits_, poolState_.debt);\n\n        uint256 htp = Maths.wmul(params_.thresholdPrice, poolState_.inflator);\n\n        if (\n            // check loan book's htp doesn't exceed new lup\n            htp > lup_\n            ||\n            // ensure that pool debt < deposits after removal\n            // this can happen if lup and htp are less than min bucket price and htp > lup (since LUP is capped at min bucket price)\n            (poolState_.debt != 0 && poolState_.debt > Deposits.treeSum(deposits_))\n        ) revert LUPBelowHTP();\n\n        uint256 lpRemaining = removeParams.bucketLP - redeemedLP_;\n\n        // check if bucket healthy after remove quote tokens - set bankruptcy if collateral and deposit are 0 but there's still LP\n        if (removeParams.bucketCollateral == 0 && unscaledRemaining == 0 && lpRemaining != 0) {\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n\n            emit BucketBankruptcy(\n                params_.index,\n                lpRemaining\n            );\n        } else {\n            // update lender and bucket LP balances\n            lender.lps -= redeemedLP_;\n\n            bucket.lps = lpRemaining;\n        }\n\n        emit RemoveQuoteToken(\n            msg.sender,\n            params_.index,\n            removedAmount_,\n            redeemedLP_,\n            lup_\n        );\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    decrement `lender.lps` accumulator\n     *  @dev    decrement `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    not enough collateral `InsufficientCollateral()`\n     *  @dev    no `LP` redeemed `InsufficientLP()`\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     */\n    function removeCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 amount_,\n        uint256 index_\n    ) external returns (uint256 lpAmount_) {\n        // revert if no amount to be removed\n        if (amount_ == 0) revert InvalidAmount();\n\n        Bucket storage bucket = buckets_[index_];\n\n        uint256 bucketCollateral = bucket.collateral;\n\n        if (amount_ > bucketCollateral) revert InsufficientCollateral();\n\n        uint256 bucketPrice   = _priceAt(index_);\n        uint256 bucketLP      = bucket.lps;\n        uint256 bucketDeposit = Deposits.valueAt(deposits_, index_);\n\n        lpAmount_ = Buckets.collateralToLP(\n            bucketCollateral,\n            bucketLP,\n            bucketDeposit,\n            amount_,\n            bucketPrice,\n            Math.Rounding.Up\n        );\n\n        // revert if (due to rounding) required LP is 0\n        if (lpAmount_ == 0) revert InsufficientLP();\n\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        uint256 lenderLpBalance;\n        if (bucket.bankruptcyTime < lender.depositTime) lenderLpBalance = lender.lps;\n        if (lenderLpBalance == 0 || lpAmount_ > lenderLpBalance) revert InsufficientLP();\n\n        // update bucket LP and collateral balance\n        bucketLP -= lpAmount_;\n\n        // If clearing out the bucket collateral, ensure it's zeroed out\n        if (bucketLP == 0 && bucketDeposit == 0) {\n            amount_ = bucketCollateral;\n        }\n\n        bucketCollateral  -= amount_;\n        bucket.collateral = bucketCollateral;\n\n        // check if bucket healthy after collateral remove - set bankruptcy if collateral and deposit are 0 but there's still LP\n        if (bucketCollateral == 0 && bucketDeposit == 0 && bucketLP != 0) {\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n\n            emit BucketBankruptcy(\n                index_,\n                bucketLP\n            );\n        } else {\n            // update lender and bucket LP balances\n            lender.lps -= lpAmount_;\n            bucket.lps = bucketLP;\n        }\n    }\n\n    /**\n     *  @notice Removes max collateral amount from a given bucket index.\n     *  @dev    === Write state ===\n     *  @dev    - `_removeMaxCollateral`:\n     *  @dev      decrement `lender.lps` accumulator\n     *  @dev      decrement `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    not enough collateral `InsufficientCollateral()`\n     *  @dev    no claim `NoClaim()`\n     *  @dev    leaves less than dust limit in bucket `DustAmountNotExceeded()`\n     *  @return Amount of collateral that was removed.\n     *  @return Amount of LP redeemed for removed collateral amount.\n     */\n    function removeMaxCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 dustLimit_,\n        uint256 maxAmount_,\n        uint256 index_\n    ) external returns (uint256, uint256) {\n        // revert if no amount to remove\n        if (maxAmount_ == 0) revert InvalidAmount();\n\n        return _removeMaxCollateral(\n            buckets_,\n            deposits_,\n            dustLimit_,\n            maxAmount_,\n            index_\n        );\n    }\n\n    /**\n     *  @notice See `IERC721PoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `Buckets.addCollateral`:\n     *  @dev      increment `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev      increment `lender.lps` accumulator and `lender.depositTime` state\n     *  @dev    === Reverts on ===\n     *  @dev    invalid merge index `CannotMergeToHigherPrice()`\n     *  @dev    no `LP` awarded in `toIndex_` bucket `InsufficientLP()`\n     *  @dev    no collateral removed from bucket `InvalidAmount()`\n     */\n    function mergeOrRemoveCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256[] calldata removalIndexes_,\n        uint256 collateralAmount_,\n        uint256 toIndex_\n    ) external returns (uint256 collateralToMerge_, uint256 bucketLP_) {\n        uint256 i;\n        uint256 fromIndex;\n        uint256 collateralRemoved;\n        uint256 noOfBuckets = removalIndexes_.length;\n        uint256 collateralRemaining = collateralAmount_;\n\n        // Loop over buckets, exit if collateralAmount is reached or max noOfBuckets is reached\n        while (collateralToMerge_ < collateralAmount_ && i < noOfBuckets) {\n            fromIndex = removalIndexes_[i];\n\n            if (fromIndex > toIndex_) revert CannotMergeToHigherPrice();\n\n            (collateralRemoved, ) = _removeMaxCollateral(\n                buckets_,\n                deposits_,\n                1,                   // dust limit is same as collateral scale\n                collateralRemaining,\n                fromIndex\n            );\n\n            // revert if calculated amount of collateral to remove is 0\n            if (collateralRemoved == 0) revert InvalidAmount();\n\n            collateralToMerge_ += collateralRemoved;\n\n            collateralRemaining = collateralRemaining - collateralRemoved;\n\n            unchecked { ++i; }\n        }\n\n        if (collateralToMerge_ != collateralAmount_) {\n            // Merge totalled collateral to specified bucket, toIndex_\n            uint256 toBucketDeposit = Deposits.valueAt(deposits_, toIndex_);\n            uint256 toBucketPrice   = _priceAt(toIndex_);\n\n            bucketLP_ = Buckets.addCollateral(\n                buckets_[toIndex_],\n                msg.sender,\n                toBucketDeposit,\n                collateralToMerge_,\n                toBucketPrice\n            );\n\n            // revert if (due to rounding) the awarded LP is 0\n            if (bucketLP_ == 0) revert InsufficientLP();\n        }\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Removes max collateral amount from a given bucket index.\n     *  @dev    === Write state ===\n     *  @dev    decrement `lender.lps` accumulator\n     *  @dev    decrement `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    not enough collateral `InsufficientCollateral()`\n     *  @dev    no claim `NoClaim()`\n     *  @dev    no `LP` redeemed `InsufficientLP()`\n     *  @dev    leaves less than dust limit in bucket `DustAmountNotExceeded()`\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     *  @return collateralAmount_ Amount of collateral that was removed.\n     *  @return lpAmount_         Amount of `LP` redeemed for removed collateral amount.\n     */\n    function _removeMaxCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 dustLimit_,\n        uint256 maxAmount_,\n        uint256 index_\n    ) internal returns (uint256 collateralAmount_, uint256 lpAmount_) {\n        Bucket storage bucket = buckets_[index_];\n\n        uint256 bucketCollateral = bucket.collateral;\n        // revert if there's no collateral in bucket\n        if (bucketCollateral == 0) revert InsufficientCollateral();\n\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        uint256 lenderLpBalance;\n\n        if (bucket.bankruptcyTime < lender.depositTime) lenderLpBalance = lender.lps;\n        // revert if no LP to redeem\n        if (lenderLpBalance == 0) revert NoClaim();\n\n        uint256 bucketPrice   = _priceAt(index_);\n        uint256 bucketLP     = bucket.lps;\n        uint256 bucketDeposit = Deposits.valueAt(deposits_, index_);\n\n        // limit amount by what is available in the bucket\n        collateralAmount_ = Maths.min(maxAmount_, bucketCollateral);\n\n        // determine how much LP would be required to remove the requested amount\n        uint256 requiredLP = Buckets.collateralToLP(\n            bucketCollateral,\n            bucketLP,\n            bucketDeposit,\n            collateralAmount_,\n            bucketPrice,\n            Math.Rounding.Up\n        );\n\n        // revert if (due to rounding) the required LP is 0\n        if (requiredLP == 0) revert InsufficientLP();\n\n        // limit withdrawal by the lender's LPB\n        if (requiredLP <= lenderLpBalance) {\n            // withdraw collateralAmount_ as is\n            lpAmount_ = requiredLP;\n        } else {\n            lpAmount_         = lenderLpBalance;\n            collateralAmount_ = Math.mulDiv(lenderLpBalance, collateralAmount_, requiredLP);\n\n            if (collateralAmount_ == 0) revert InsufficientLP();\n        }\n\n        // update bucket LP and collateral balance\n        bucketLP -= Maths.min(bucketLP, lpAmount_);\n\n        // If clearing out the bucket collateral, ensure it's zeroed out\n        if (bucketLP == 0 && bucketDeposit == 0) collateralAmount_ = bucketCollateral;\n\n        collateralAmount_ = Maths.min(bucketCollateral, collateralAmount_);\n        bucketCollateral  -= collateralAmount_;\n        if (bucketCollateral != 0 && bucketCollateral < dustLimit_) revert DustAmountNotExceeded();\n        bucket.collateral = bucketCollateral;\n\n        // check if bucket healthy after collateral remove - set bankruptcy if collateral and deposit are 0 but there's still LP\n        if (bucketCollateral == 0 && bucketDeposit == 0 && bucketLP != 0) {\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n\n            emit BucketBankruptcy(\n                index_,\n                bucketLP\n            );\n        } else {\n            // update lender and bucket LP balances\n            lender.lps -= lpAmount_;\n            bucket.lps = bucketLP;\n        }\n    }\n\n    /**\n     *  @notice Removes the amount of quote tokens calculated for the given amount of LP.\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.unscaledRemove` (remove amount in `Fenwick` tree, from index):\n     *  @dev      update `values` array state\n     *  @dev    === Reverts on ===\n     *  @dev    no `LP` redeemed `InsufficientLP()`\n     *  @dev    no unscaled amount removed` `InvalidAmount()`\n     *  @return removedAmount_     Amount of scaled deposit removed.\n     *  @return redeemedLP_        Amount of bucket `LP` corresponding for calculated scaled deposit amount.\n     *  @return unscaledRemaining_ Amount of unscaled deposit remaining.\n     */\n    function _removeMaxDeposit(\n        DepositsState storage deposits_,\n        RemoveDepositParams memory params_\n    ) internal returns (uint256 removedAmount_, uint256 redeemedLP_, uint256 unscaledRemaining_) {\n\n        uint256 unscaledDepositAvailable = Deposits.unscaledValueAt(deposits_, params_.index);\n\n        // revert if there's no liquidity available to remove\n        if (unscaledDepositAvailable == 0) revert InsufficientLiquidity();\n\n        uint256 depositScale           = Deposits.scale(deposits_, params_.index);\n        uint256 scaledDepositAvailable = Maths.wmul(unscaledDepositAvailable, depositScale);\n\n        // Below is pseudocode explaining the logic behind finding the constrained amount of deposit and LPB\n        // scaledRemovedAmount is constrained by the scaled maxAmount(in QT), the scaledDeposit constraint, and\n        // the lender LPB exchange rate in scaled deposit-to-LPB for the bucket:\n        // scaledRemovedAmount = min ( maxAmount_, scaledDeposit, lenderLPBalance*exchangeRate)\n        // redeemedLP_ = min ( maxAmount_/scaledExchangeRate, scaledDeposit/exchangeRate, lenderLPBalance)\n\n        uint256 scaledLpConstraint = Buckets.lpToQuoteTokens(\n            params_.bucketCollateral,\n            params_.bucketLP,\n            scaledDepositAvailable,\n            params_.lpConstraint,\n            params_.price,\n            Math.Rounding.Down\n        );\n        uint256 unscaledRemovedAmount;\n        if (\n            params_.depositConstraint < scaledDepositAvailable &&\n            params_.depositConstraint < scaledLpConstraint\n        ) {\n            // depositConstraint is binding constraint\n            removedAmount_ = params_.depositConstraint;\n            redeemedLP_    = Buckets.quoteTokensToLP(\n                params_.bucketCollateral,\n                params_.bucketLP,\n                scaledDepositAvailable,\n                removedAmount_,\n                params_.price,\n                Math.Rounding.Up\n            );\n            redeemedLP_ = Maths.min(redeemedLP_, params_.lpConstraint);\n            unscaledRemovedAmount = Maths.wdiv(removedAmount_, depositScale);\n        } else if (scaledDepositAvailable < scaledLpConstraint) {"
    }
  ]
}