{
  "Title": "[M-10]  Incorrect implementation of the ETHPoolLPFactory.sol#rotateLPTokens let user stakes ETH more than maxStakingAmountPerValidator in StakingFundsVault, and DOS the stake function in LiquidStakingManager",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L380\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L122\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L130\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L83\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L551\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L940\n\n\n# Vulnerability details\n\n## Impact\n\nThe user is not able to stake the 32 ETH for validators because the staking fund vault LP total supply exceeds 4 ETHER.\n\nAfter the smart wallet, staking fund vault and savETH vault has 32 ETH, the user should be able to call:\n\n```solidity\n/// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication\n/// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)\n/// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain\n/// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup\n/// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature\n/// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract\nfunction stake(\n\tbytes[] calldata _blsPublicKeyOfKnots,\n\tbytes[] calldata _ciphertexts,\n\tbytes[] calldata _aesEncryptorKeys,\n\tIDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n\tbytes32[] calldata _dataRoots\n) external {\n```\n\nbefore the staking, the validation function is called:\n\n```solidity\n// check minimum balance of smart wallet, dao staking fund vault and savETH vault\n_assertEtherIsReadyForValidatorStaking(blsPubKey);\n```\n\nwhich calls:\n\n```solidity\n/// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved\nfunction _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n\taddress associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n\trequire(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n\tLPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n\trequire(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n\trequire(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n\tLPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n\trequire(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n\trequire(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n}\n```\n\nnote that the code requires the total supply of the stakingFundsLP to be equal to 4 ETHER\n\n```solidity\nrequire(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n```\n\nhowever, user can call the function rotateLPTokens to mint more than 4 ETHER of the stakingFundsLP because of the incorrect implementation of the ETHPoolLPFactory.sol#rotateLPTokens\n\nnote that stakingFundVault inherits from ETHPoolFactory.sol\n\n```solidity\ncontract StakingFundsVault is\n    Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory,\n```\n\nso user call rotateLPTokens on StakingFundsVault\n\n```solidity\n/// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked\n/// @param _oldLPToken Instance of the old LP token (to be burnt)\n/// @param _newLPToken Instane of the new LP token (to be minted)\n/// @param _amount Amount of LP tokens to be rotated/converted from old to new\nfunction rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n\trequire(address(_oldLPToken) != address(0), \"Zero address\");\n\trequire(address(_newLPToken) != address(0), \"Zero address\");\n\trequire(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");\n\trequire(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n\trequire(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");\n\trequire(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");\n\trequire(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n```\n\nnote the line:\n\n```solidity\nrequire(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n```\n\nthe correct implementaton should be:\n\n```solidity\nrequire(_amount + _newLPToken.totalSupply() <= maxStakingAmountPerValidator, \"Not enough mintable tokens\");\n```\n\nThe 24 ETH is hardcoded, but when the stakingFundsVault.sol is init, the maxStakingAmountPerValidator is set to 4 ETH.\n\n```solidity\n/// @dev Initialization logic\nfunction _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {\n\trequire(address(_liquidStakingNetworkManager) != address(0), \"Zero Address\");\n\trequire(address(_lpTokenFactory) != address(0), \"Zero Address\");\n\n\tliquidStakingNetworkManager = _liquidStakingNetworkManager;\n\tlpTokenFactory = _lpTokenFactory;\n\n\tbaseLPTokenName = \"ETHLPToken_\";\n\tbaseLPTokenSymbol = \"ETHLP_\";\n\tmaxStakingAmountPerValidator = 4 ether;\n}\n```\n\nnote the line:\n\n```solidity\nmaxStakingAmountPerValidator = 4 ether;\n```\n\nthis parameter maxStakingAmountPerValidator restrict user's ETH deposit amount\n\n```solidity\n    /// @dev Internal business logic for processing staking deposits for single or batch deposits\nfunction _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {\n\trequire(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");\n\trequire(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");\n\n\t// LP token issued for the KNOT\n\t// will be zero for a new KNOT because the mapping doesn't exist\n\tLPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];\n\tif(address(lpToken) != address(0)) {\n\t\t// KNOT and it's LP token is already registered\n\t\t// mint the respective LP tokens for the user\n\n\t\t// total supply after minting the LP token must not exceed maximum staking amount per validator\n\t\trequire(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n\n\t\t// mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n\t\tlpToken.mint(msg.sender, _amount);\n\t\temit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);\n\t}\n\telse {\n\t\t// check that amount doesn't exceed max staking amount per validator\n\t\trequire(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");  \n```\n\nnote the line:\n\n```solidity\nrequire(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\"); \n```\n\nHowever, such restriction when rotating LP is changed to\n\n```solidity\nrequire(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n```\n\n**so to sum it up:**\n\nWhen user stakes, the code strictly requires the stakingFundVault LP total supply is equal to 4 ETH:\n\n```solidity\nrequire(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n```\n\nHowever, when rotating the LP, the maxStakingAmountPerValidator for staking fund LP becomes 24 ETH, which exceeds 4 ETH (the expected maxStakingAmountPerValidator)\n\n## Proof of Concept\n\nFirst we need to add the import in LiquidStakingManager.t.sol\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12\n\n```solidity\nimport { MockAccountManager } from \"../../contracts/testing/stakehouse/MockAccountManager.sol\";\n\nimport \"../../contracts/liquid-staking/StakingFundsVault.sol\";\nimport \"../../contracts/liquid-staking/LPToken.sol\";\n```\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35\n\n**then we add the POC:**\n\n```solidity\nfunction test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() public {\n\n\taddress user = vm.addr(21312);\n\n\tbytes memory blsPubKeyOne = fromHex(\"94fdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5\");\n\tbytes memory blsPubKeyTwo = fromHex(\"9AAdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5\");\n\n\tbytes[] memory publicKeys = new bytes[](2);\n\tpublicKeys[0] = blsPubKeyOne;\n\tpublicKeys[1] = blsPubKeyTwo;\n\n\tbytes[] memory signature = new bytes[](2);\n\tsignature[0] = \"signature\";\n\tsignature[1] = \"signature\";\n\n\t// user spends 8 ether and register two keys to become the public operator\n\tvm.prank(user);\n\tvm.deal(user, 8 ether);\n\tmanager.registerBLSPublicKeys{value: 8 ether}(\n\t\tpublicKeys,\n\t\tsignature,\n\t\tuser\n\t);\n\n\t// active two keys\n\tMockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);\n\tMockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo, 1);\n\n\t// deposit 4 ETH for public key one and public key two\n\tStakingFundsVault stakingFundsVault = manager.stakingFundsVault();\n\tstakingFundsVault.depositETHForStaking{value: 4 ether}(blsPubKeyOne, 4 ether);\n\tstakingFundsVault.depositETHForStaking{value: 4 ether}(blsPubKeyTwo, 4 ether);\n\n\t// to bypass the error: \"Liquidity is still fresh\"\n\tvm.warp(1 days);\n\n\t// rotate staking amount from public key one to public key two\n\t// LP total supply for public key two exceed 4 ETHER\n\tLPToken LPTokenForPubKeyOne = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyOne);\n\tLPToken LPTokenForPubKeyTwo = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyTwo);\n\tstakingFundsVault.rotateLPTokens(LPTokenForPubKeyOne, LPTokenForPubKeyTwo, 4 ether);\n\n\tuint256 totalSupply = LPTokenForPubKeyTwo.totalSupply();\n\tconsole.log(\"total supply of the Staking fund LP exists 4 ETHER.\");\n\tconsole.log(totalSupply);\n\n\t// calling TestUtils.sol#stakeSingleBlsPubKey, revert\n\tstakeSingleBlsPubKey(blsPubKeyTwo);\n\n}\n```\n\nWe run the POC:\n\n```solidity\nforge test -vv --match test_rotateLP_Exceed_maxStakingAmountPerValidator_POC\n```\n\nthe output is:\n\n```solidity\nRunning 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests\n[FAIL. Reason: DAO staking funds vault balance must be at least 4 ether] test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() (gas: 1510454)\nLogs:\n  total supply of the Staking fund LP exists 4 ETHER.\n  8000000000000000000\n\nTest result: FAILED. 0 passed; 1 failed; finished in 15.73ms\n\nFailing tests:\nEncountered 1 failing test in test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests\n[FAIL. Reason: DAO staking funds vault balance must be at least 4 ether] test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() (gas: 1510454)\n```\n\nthe total supply of the LP exceeds 4 ETH and the transaction precisely reverts in:\n\n```solidity\nrequire(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n```\n\n## Tools Used\n\nManual Review, Foundry\n\n## Recommended Mitigation Steps\n\nWe recommend the project change from\n\n```solidity\nrequire(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n```\n\nto\n\n```solidity\nrequire(_amount + _newLPToken.totalSupply() <= maxStakingAmountPerValidator, \"Not enough mintable tokens\");\n```\n\nand change from\n\n```solidity\n/// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved\nfunction _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n\taddress associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n\trequire(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n\tLPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n\trequire(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n\trequire(stakingFundsLP.totalSupply() >= 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n\tLPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n\trequire(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n\trequire(savETHVaultLP.totalSupply() >= 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n}\n```\n\nwe change from == balance check to >=, because == balance check is too strict in this case.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/ETHPoolLPFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\n\n/// @dev For pools accepting ETH for validator staking, this contract will manage issuing LPs for deposits\nabstract contract ETHPoolLPFactory is StakehouseAPI {\n\n    /// @notice signalize withdrawing of ETH by depositor\n    event ETHWithdrawnByDepositor(address depositor, uint256 amount);\n\n    /// @notice signalize burning of LP token\n    event LPTokenBurnt(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @notice signalize issuance of new LP token\n    event NewLPTokenIssued(bytes blsPublicKeyOfKnot, address token, address firstDepositor, uint256 amount);\n\n    /// @notice signalize issuance of existing LP token\n    event LPTokenMinted(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @dev Base name and symbol used for deploying new LP tokens per KNOT\n    string internal baseLPTokenName;\n    string internal baseLPTokenSymbol;\n\n    /// @notice count of unique LP tokens issued for ETH deposits\n    uint256 public numberOfLPTokensIssued;\n\n    /// @notice Maximum amount that can be staked per validator in WEI\n    uint256 public maxStakingAmountPerValidator;\n\n    /// @notice Minimum amount that can be staked per validator in WEI\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Factory for the deployment of KNOT<>LP Tokens that can be used to redeem dETH\n    LPTokenFactory public lpTokenFactory;\n\n    /// @notice LP token address deployed for a KNOT's BLS public key\n    mapping(bytes => LPToken) public lpTokenForKnot;\n\n    /// @notice KNOT BLS public key associated with the LP token\n    mapping(LPToken => bytes) public KnotAssociatedWithLPToken;\n\n    /// @notice Allow users to rotate the ETH from many LP to another in the event that a BLS key is never staked\n    /// @param _oldLPTokens Array of old LP tokens to be burnt\n    /// @param _newLPTokens Array of new LP tokens to be minted in exchange of old LP tokens\n    /// @param _amounts Array of amount of tokens to be exchanged\n    function batchRotateLPTokens(\n        LPToken[] calldata _oldLPTokens,\n        LPToken[] calldata _newLPTokens,\n        uint256[] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _oldLPTokens.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n\n        for (uint256 i; i < numOfRotations; ++i) {\n            rotateLPTokens(\n                _oldLPTokens[i],\n                _newLPTokens[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked\n    /// @param _oldLPToken Instance of the old LP token (to be burnt)\n    /// @param _newLPToken Instane of the new LP token (to be minted)\n    /// @param _amount Amount of LP tokens to be rotated/converted from old to new\n    function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n        require(address(_oldLPToken) != address(0), \"Zero address\");\n        require(address(_newLPToken) != address(0), \"Zero address\");\n        require(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");\n        require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n\n        bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];\n        bytes memory blsPublicKeyOfNewKnot = KnotAssociatedWithLPToken[_newLPToken];\n\n        require(blsPublicKeyOfPreviousKnot.length == 48, \"Incorrect BLS public key\");\n        require(blsPublicKeyOfNewKnot.length == 48, \"Incorrect BLS public key\");\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfNewKnot) ==IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        // burn old tokens and mint new ones\n        _oldLPToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfPreviousKnot, address(_oldLPToken), msg.sender, _amount);\n\n        _newLPToken.mint(msg.sender, _amount);\n        emit LPTokenMinted(KnotAssociatedWithLPToken[_newLPToken], address(_newLPToken), msg.sender, _amount);\n    }\n\n    /// @dev Internal business logic for processing staking deposits for single or batch deposits\n    function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");\n        require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");\n\n        // LP token issued for the KNOT\n        // will be zero for a new KNOT because the mapping doesn't exist\n        LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if(address(lpToken) != address(0)) {\n            // KNOT and it's LP token is already registered\n            // mint the respective LP tokens for the user\n\n            // total supply after minting the LP token must not exceed maximum staking amount per validator\n            require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            lpToken.mint(msg.sender, _amount);\n            emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);\n        }\n        else {\n            // check that amount doesn't exceed max staking amount per validator\n            require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n            \n            // mint new LP tokens for the new KNOT\n            // add the KNOT in the mapping\n            string memory tokenNumber = Strings.toString(numberOfLPTokensIssued);\n            string memory tokenName = string(abi.encodePacked(baseLPTokenName, tokenNumber));\n            string memory tokenSymbol = string(abi.encodePacked(baseLPTokenSymbol, tokenNumber));\n\n            // deploy new LP token and optionally enable transfer notifications\n            LPToken newLPToken = _enableTransferHook ?\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(this), tokenSymbol, tokenName)) :\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(0), tokenSymbol, tokenName));\n\n            // increase the count of LP tokens\n            numberOfLPTokensIssued++;\n\n            // register the BLS Public Key with the LP token\n            lpTokenForKnot[_blsPublicKeyOfKnot] = newLPToken;\n            KnotAssociatedWithLPToken[newLPToken] = _blsPublicKeyOfKnot;\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            newLPToken.mint(msg.sender, _amount);\n            emit NewLPTokenIssued(_blsPublicKeyOfKnot, address(newLPToken), msg.sender, _amount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/liquid-staking/StakingFundsVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { ETHPoolLPFactory } from \"./ETHPoolLPFactory.sol\";\nimport { LiquidStakingManager } from \"./LiquidStakingManager.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\n\n/// @title MEV and fees vault for a specified liquid staking network\ncontract StakingFundsVault is\n    Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory, SyndicateRewardsProcessor, ReentrancyGuard\n{\n\n    /// @notice signalize that the vault received ETH\n    event ETHDeposited(address sender, uint256 amount);\n\n    /// @notice signalize ETH withdrawal from the vault\n    event ETHWithdrawn(address receiver, address admin, uint256 amount);\n\n    /// @notice signalize ERC20 token recovery by the admin\n    event ERC20Recovered(address admin, address recipient, uint256 amount);\n\n    /// @notice signalize unwrapping of WETH in the vault\n    event WETHUnwrapped(address admin, uint256 amount);\n\n    /// @notice Address of the network manager\n    LiquidStakingManager public liquidStakingNetworkManager;\n\n    /// @notice Total number of LP tokens issued in WEI\n    uint256 public totalShares;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _liquidStakingNetworkManager address of the liquid staking network manager\n    function init(address _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) external virtual initializer {\n        _init(LiquidStakingManager(payable(_liquidStakingNetworkManager)), _lpTokenFactory);\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == address(liquidStakingNetworkManager), \"Only network manager\");\n        _;\n    }\n\n    /// @notice Allows the liquid staking manager to notify funds vault about new derivatives minted to enable MEV claiming\n    function updateDerivativesMinted() external onlyManager {\n        // We know 4 ETH for the KNOT came from this vault so increase the shares to get a % of vault rewards\n        totalShares += 4 ether;\n    }\n\n    /// @notice For knots that have minted derivatives, update accumulated ETH per LP\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(totalShares);\n    }\n\n    /// @notice Batch deposit ETH for staking against multiple BLS public keys\n    /// @param _blsPublicKeyOfKnots List of BLS public keys being staked\n    /// @param _amounts Amounts of ETH being staked for each BLS public key\n    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"Empty arrays\");\n        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        uint256 totalAmount;\n        for (uint256 i; i < numOfValidators; ++i) {\n            require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n\n            LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            if (address(tokenForKnot) != address(0)) {\n                // Give anything owed to the user before making updates to user state\n                _distributeETHRewardsToUserForToken(\n                    msg.sender,\n                    address(tokenForKnot),\n                    tokenForKnot.balanceOf(msg.sender),\n                    msg.sender\n                );\n            }\n\n            uint256 amount = _amounts[i];\n            totalAmount += amount;\n\n            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, true);\n\n            // Ensure user cannot get historical rewards\n            tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n        }\n\n        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract\n        require(msg.value == totalAmount, \"Invalid ETH amount attached\");\n    }\n\n    /// @notice Deposit ETH against a BLS public key for staking\n    /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner\n    /// @param _amount Amount of ETH being staked\n    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n        require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(msg.value == _amount, \"Must provide correct amount of ETH\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        // Give anything owed to the user before making updates to user state\n        LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if (address(tokenForKnot) != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                msg.sender,\n                address(tokenForKnot),\n                tokenForKnot.balanceOf(msg.sender),\n                msg.sender\n            );\n        }\n\n        _depositETHForStaking(_blsPublicKeyOfKnot, _amount, true);\n\n        // Ensure user cannot get historical rewards\n        tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n\n        return _amount;\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked by BLS public key\n    /// @param _blsPublicKeys List of BLS public keys that received ETH for staking\n    /// @param _amounts List of amounts of LP tokens being burnt\n    function burnLPTokensForETHByBLS(bytes[] calldata _blsPublicKeys, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _blsPublicKeys.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            LPToken token = lpTokenForKnot[_blsPublicKeys[i]];\n            require(address(token) != address(0), \"No ETH staked for specified BLS key\");\n            burnLPForETH(token, _amounts[i]);\n        }\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked\n    /// @param _lpTokens Address of LP tokens being burnt\n    /// @param _amounts Amount of LP tokens being burnt\n    function burnLPTokensForETH(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _lpTokens.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            burnLPForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice For a user that has deposited ETH that has not been staked, allow them to burn LP to get ETH back\n    /// @param _lpToken Address of the LP token being burnt\n    /// @param _amount Amount of LP token being burnt\n    function burnLPForETH(LPToken _lpToken, uint256 _amount) public nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _lpToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(address(_lpToken) != address(0), \"Zero address specified\");\n\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Cannot burn LP tokens\"\n        );\n        require(_lpToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Too new\");\n\n        updateAccumulatedETHPerLP();\n\n        _lpToken.burn(msg.sender, _amount);\n\n        (bool result,) = msg.sender.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n        emit ETHWithdrawnByDepositor(msg.sender, _amount);\n\n        emit LPTokenBurnt(blsPublicKeyOfKnot, address(_lpToken), msg.sender, _amount);\n    }\n\n    /// @notice Any LP tokens for BLS keys that have had their derivatives minted can claim ETH from the syndicate contract\n    /// @param _blsPubKeys List of BLS public keys being processed\n    function claimRewards(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            require(\n                liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,\n                \"Unknown BLS public key\"\n            );\n\n            // Ensure that the BLS key has its derivatives minted\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n                \"Derivatives not minted\"\n            );\n\n            if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {\n                // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract\n                // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched\n                _claimFundsFromSyndicateForDistribution(\n                    liquidStakingNetworkManager.syndicate(),\n                    _blsPubKeys\n                );\n\n                // Distribute ETH per LP\n                updateAccumulatedETHPerLP();\n            }\n\n            // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            require(address(token) != address(0), \"Invalid BLS key\");\n            require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");\n            _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);\n        }\n    }\n\n    /// @notice function to allow admins to withdraw ETH from the vault for staking purpose\n    /// @param _wallet address of the smart wallet that receives ETH\n    /// @param _amount number of ETH withdrawn\n    /// @return number of ETH withdrawn\n    function withdrawETH(address _wallet, uint256 _amount) public onlyManager nonReentrant returns (uint256) {\n        require(_amount >= 4 ether, \"Amount cannot be less than 4 ether\");\n        require(_amount <= address(this).balance, \"Not enough ETH to withdraw\");\n        require(_wallet != address(0), \"Zero address\");\n\n        (bool result,) = _wallet.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n\n        emit ETHWithdrawn(_wallet, msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice For any knots that are no longer part of syndicate facilitate unstaking so that knot can rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function unstakeSyndicateSharesForRageQuit(\n        address _sETHRecipient,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyManager nonReentrant {\n        Syndicate syndicate = Syndicate(payable(liquidStakingNetworkManager.syndicate()));\n\n        _claimFundsFromSyndicateForDistribution(address(syndicate), _blsPublicKeys);\n\n        updateAccumulatedETHPerLP();\n\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            require(syndicate.isNoLongerPartOfSyndicate(_blsPublicKeys[i]), \"Knot is still active in syndicate\");\n        }\n\n        syndicate.unstake(address(this), _sETHRecipient, _blsPublicKeys, _amounts);\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETHByBLSKeys(address _user, bytes[] calldata _blsPubKeys) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            totalAccumulated += previewAccumulatedETH(_user, token);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETH(address _user, LPToken[] calldata _token) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _token.length; ++i) {\n            totalAccumulated += previewAccumulatedETH(_user, _token[i]);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with a KNOT that has minted derivatives\n    function previewAccumulatedETH(address _user, LPToken _token) public view returns (uint256) {\n        // if token maps to BLS public key that has not been minted derivatives then return zero as it's not eligible\n        bytes memory associatedBLSPublicKeyOfLpToken = KnotAssociatedWithLPToken[_token];\n        if (getAccountManager().blsPublicKeyToLifecycleStatus(associatedBLSPublicKeyOfLpToken) != IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n            return 0;\n        }\n\n        // Looking at this contract balance and the ETH that is yet to be transferred from the syndicate, then tell the user how much ETH they have earned\n        address payable syndicate = payable(liquidStakingNetworkManager.syndicate());\n        return _previewAccumulatedETH(\n            _user,\n            address(_token),\n            _token.balanceOf(_user),\n            totalShares,\n            Syndicate(syndicate).previewUnclaimedETHAsFreeFloatingStaker(\n                address(this),\n                associatedBLSPublicKeyOfLpToken\n            )\n        );\n    }\n\n    /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards\n    function beforeTokenTransfer(address _from, address _to, uint256) external override {\n        address syndicate = liquidStakingNetworkManager.syndicate();\n        if (syndicate != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            bytes memory blsPubKey = KnotAssociatedWithLPToken[token];\n            require(blsPubKey.length > 0, \"Invalid token\");\n\n            if (getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n                // Claim any ETH for the BLS key mapped to this token\n                bytes[] memory keys = new bytes[](1);\n                keys[0] = blsPubKey;\n                _claimFundsFromSyndicateForDistribution(syndicate, keys);\n\n                // Update the accumulated ETH per minted derivative LP share\n                updateAccumulatedETHPerLP();\n\n                // distribute any due rewards for the `from` user\n                if (_from != address(0)) {\n                    _distributeETHRewardsToUserForToken(_from, address(token), token.balanceOf(_from), _from);\n                }\n\n                // in case the new user has existing rewards - give it to them so that the after transfer hook does not wipe pending rewards\n                _distributeETHRewardsToUserForToken(_to, address(token), token.balanceOf(_to), _to);\n            }\n        }\n    }\n\n    /// @notice After an LP token is transferred, ensure that the new account cannot claim historical rewards\n    function afterTokenTransfer(address, address _to, uint256) external override {\n        if (LiquidStakingManager(payable(liquidStakingNetworkManager)).syndicate() != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            require(KnotAssociatedWithLPToken[token].length > 0, \"Invalid token\");\n\n            // claim is calculated on full balance not amount being transferred so that double claims are not possible\n            claimed[_to][address(token)] = (token.balanceOf(_to) * accumulatedETHPerLPShare) / PRECISION;\n        }\n    }\n\n    /// @notice Claim ETH to this contract from the syndicate that was accrued by a list of actively staked validators\n    /// @param _blsPubKeys List of BLS public key identifiers of validators that have sETH staked in the syndicate for the vault\n    function claimFundsFromSyndicateForDistribution(bytes[] memory _blsPubKeys) external {\n        _claimFundsFromSyndicateForDistribution(liquidStakingNetworkManager.syndicate(), _blsPubKeys);\n    }\n\n    /// @dev Claim ETH from syndicate for a list of BLS public keys for later distribution amongst LPs\n    function _claimFundsFromSyndicateForDistribution(address _syndicate, bytes[] memory _blsPubKeys) internal {\n        require(_syndicate != address(0), \"Invalid configuration\");\n\n        // Claim all of the ETH due from the syndicate for the auto-staked sETH\n        Syndicate syndicateContract = Syndicate(payable(_syndicate));\n        syndicateContract.claimAsStaker(address(this), _blsPubKeys);\n\n        updateAccumulatedETHPerLP();\n    }\n\n    /// @dev Initialization logic\n    function _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {\n        require(address(_liquidStakingNetworkManager) != address(0), \"Zero Address\");\n        require(address(_lpTokenFactory) != address(0), \"Zero Address\");\n\n        liquidStakingNetworkManager = _liquidStakingNetworkManager;\n        lpTokenFactory = _lpTokenFactory;\n\n        baseLPTokenName = \"ETHLPToken_\";\n        baseLPTokenSymbol = \"ETHLP_\";\n        maxStakingAmountPerValidator = 4 ether;\n    }\n}"
    },
    {
      "filename": "contracts/liquid-staking/ETHPoolLPFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\n\n/// @dev For pools accepting ETH for validator staking, this contract will manage issuing LPs for deposits\nabstract contract ETHPoolLPFactory is StakehouseAPI {\n\n    /// @notice signalize withdrawing of ETH by depositor\n    event ETHWithdrawnByDepositor(address depositor, uint256 amount);\n\n    /// @notice signalize burning of LP token\n    event LPTokenBurnt(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @notice signalize issuance of new LP token\n    event NewLPTokenIssued(bytes blsPublicKeyOfKnot, address token, address firstDepositor, uint256 amount);\n\n    /// @notice signalize issuance of existing LP token\n    event LPTokenMinted(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @dev Base name and symbol used for deploying new LP tokens per KNOT\n    string internal baseLPTokenName;\n    string internal baseLPTokenSymbol;\n\n    /// @notice count of unique LP tokens issued for ETH deposits\n    uint256 public numberOfLPTokensIssued;\n\n    /// @notice Maximum amount that can be staked per validator in WEI\n    uint256 public maxStakingAmountPerValidator;\n\n    /// @notice Minimum amount that can be staked per validator in WEI\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Factory for the deployment of KNOT<>LP Tokens that can be used to redeem dETH\n    LPTokenFactory public lpTokenFactory;\n\n    /// @notice LP token address deployed for a KNOT's BLS public key\n    mapping(bytes => LPToken) public lpTokenForKnot;\n\n    /// @notice KNOT BLS public key associated with the LP token\n    mapping(LPToken => bytes) public KnotAssociatedWithLPToken;\n\n    /// @notice Allow users to rotate the ETH from many LP to another in the event that a BLS key is never staked\n    /// @param _oldLPTokens Array of old LP tokens to be burnt\n    /// @param _newLPTokens Array of new LP tokens to be minted in exchange of old LP tokens\n    /// @param _amounts Array of amount of tokens to be exchanged\n    function batchRotateLPTokens(\n        LPToken[] calldata _oldLPTokens,\n        LPToken[] calldata _newLPTokens,\n        uint256[] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _oldLPTokens.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n\n        for (uint256 i; i < numOfRotations; ++i) {\n            rotateLPTokens(\n                _oldLPTokens[i],\n                _newLPTokens[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked\n    /// @param _oldLPToken Instance of the old LP token (to be burnt)\n    /// @param _newLPToken Instane of the new LP token (to be minted)\n    /// @param _amount Amount of LP tokens to be rotated/converted from old to new\n    function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n        require(address(_oldLPToken) != address(0), \"Zero address\");\n        require(address(_newLPToken) != address(0), \"Zero address\");\n        require(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");\n        require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n\n        bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];\n        bytes memory blsPublicKeyOfNewKnot = KnotAssociatedWithLPToken[_newLPToken];\n\n        require(blsPublicKeyOfPreviousKnot.length == 48, \"Incorrect BLS public key\");\n        require(blsPublicKeyOfNewKnot.length == 48, \"Incorrect BLS public key\");\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfNewKnot) ==IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        // burn old tokens and mint new ones\n        _oldLPToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfPreviousKnot, address(_oldLPToken), msg.sender, _amount);\n\n        _newLPToken.mint(msg.sender, _amount);\n        emit LPTokenMinted(KnotAssociatedWithLPToken[_newLPToken], address(_newLPToken), msg.sender, _amount);\n    }\n\n    /// @dev Internal business logic for processing staking deposits for single or batch deposits\n    function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");\n        require(_blsPublicKeyOfKno"
    }
  ]
}