{
  "Title": "M-15: `ExternalLending`",
  "Content": "# Issue M-15: `ExternalLending` \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/65 \n\n## Found by \neol\n## Summary\nWhen the Treasury rebalances and has to redeem aTokens from AaveV3, it checks that the actual amount withdrawn is greater than or equal to the set `withdrawAmount`. This check will always fail for fee-on-transfer tokens since the `withdrawAmount` does not account for the transfer fee.\n\n## Vulnerability Detail\nWhen the Treasury rebalances and has to redeem aWETH from AaveV3 it executes calls that were encoded in `AaveV3HoldingsOracle._getRedemptionCalldata()`:\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/external/pCash/AaveV3HoldingsOracle.sol#L61-L81\n```solidity\n        address[] memory targets = new address[](UNDERLYING_IS_ETH ? 2 : 1);\n        bytes[] memory callData = new bytes[](UNDERLYING_IS_ETH ? 2 : 1);\n        targets[0] = LENDING_POOL;\n        callData[0] = abi.encodeWithSelector(\n            ILendingPool.withdraw.selector, underlyingToken, withdrawAmount, address(NOTIONAL)\n        );\n\n        if (UNDERLYING_IS_ETH) {\n            // Aave V3 returns WETH instead of native ETH so we have to unwrap it here\n            targets[1] = address(Deployments.WETH);\n            callData[1] = abi.encodeWithSelector(WETH9.withdraw.selector, withdrawAmount);\n        }\n\n        data = new RedeemData[](1);\n        // Tokens with less than or equal to 8 decimals sometimes have off by 1 issues when depositing\n        // into Aave V3. Aave returns one unit less than has been deposited. This adjustment is applied\n        // to ensure that this unit of token is credited back to prime cash holders appropriately.\n        uint8 rebasingTokenBalanceAdjustment = UNDERLYING_DECIMALS <= 8 ? 1 : 0;\n        data[0] = RedeemData(\n            targets, callData, withdrawAmount, ASSET_TOKEN, rebasingTokenBalanceAdjustment\n        );\n```\n\nNote that the third field in the `RedeemData` struct is the `expectedUnderlying` field which is set to the `withdrawAmount` and that `withdrawAmount` is a value greater than zero. \n\nExecution of redemption is done in `ExternalLending.executeMoneyMarketRedemptions()`.\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/balances/ExternalLending.sol#L163-L172\n```solidity\n            for (uint256 j; j < data.targets.length; j++) {\n                GenericToken.executeLowLevelCall(data.targets[j], 0, data.callData[j]);\n            }\n\n            // Ensure that we get sufficient underlying on every redemption\n            uint256 newUnderlyingBalance = TokenHandler.balanceOf(underlyingToken, address(this));\n            uint256 underlyingBalanceChange = newUnderlyingBalance.sub(oldUnderlyingBalance);\n            // If the call is not the final redemption, then expectedUnderlying should\n            // be set to zero.\n            require(data.expectedUnderlying <= underlyingBalanceChange);\n```\n\nThe `require` statement expects that the change in token balance is always greater than or equal to `data.expectedUnderlying`. However, `data.expectedUnderlying` was calculated with:\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/external/actions/TreasuryAction.sol#L452\n```solidity\nredeemAmounts[0] = currentAmount - targetAmount;\n```\n\nIt does not account for transfer fees. In effect, that check will always revert when the underlying being withdrawn is a fee-on-transfer token.\n\n## Impact\nRebalancing will always fail when redemption of a fee-on-transfer token is executed. This will also break withdrawals of prime cash from Notional of fee-on-transfer tokens that require redemption from AaveV3.\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/balances/TokenHandler.sol#L243-L244\n```solidity\n    uint256 withdrawAmount = uint256(netTransferExternal.neg());\n    ExternalLending.redeemMoneyMarketIfRequired(currencyId, underlying, withdrawAmount);\n```\nThis means that these tokens can only be deposited into AaveV3 but can never redeemed. This can lead to insolvency of the protocol.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/external/pCash/AaveV3HoldingsOracle.sol#L61-L81\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/external/actions/TreasuryAction.sol#L452\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/balances/ExternalLending.sol#L163-L172\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/balances/TokenHandler.sol#L243-L244\n\n## Tool used\nManual Review\n\n## Recommendation\nWhen computing for the `withdrawAmount / data.expectedUnderlying`, it should account for the transfer fees. The pseudocode for the computation may look like so:\n```pseudocode\nwithdrawAmount = currentAmount - targetAmount\nif (underlyingToken.hasTransferFee) {\n  withdrawAmount = withdrawAmount / (100% - underlyingToken.transferFeePercent)\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { valid medium findings}\n\n\n\n**jeffywu**\n\nWhile this is true, I think the protocol would simply opt to not have external lending for fee on transfer tokens. Since this feature is turned on or off by the protocol I don't see how this warrants a high severity.\n\n**nevillehuang**\n\n@jeffywu would this be a duplicate of #58? If I'm not wrong the fix seems different so could be separate.\n\n**jeffywu**\n\nNo, it is separate code.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "contracts-v3/contracts/external/pCash/AaveV3HoldingsOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {UnderlyingHoldingsOracle} from \"./UnderlyingHoldingsOracle.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {DepositData, RedeemData, OracleData} from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\nimport {ILendingPool} from \"../../../interfaces/aave/ILendingPool.sol\";\nimport {IPoolDataProvider} from \"../../../interfaces/aave/IPoolDataProvider.sol\";\nimport {WETH9} from \"../../../interfaces/WETH9.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\ncontract AaveV3HoldingsOracle is UnderlyingHoldingsOracle {\n    using SafeUint256 for uint256;\n\n    address internal immutable ASSET_TOKEN;\n    address internal immutable LENDING_POOL;\n    address internal immutable POOL_DATA_PROVIDER;\n\n    constructor(NotionalProxy notional, address underlying, address lendingPool, address aToken, address poolDataProvider)\n        UnderlyingHoldingsOracle(notional, underlying)\n    {\n        LENDING_POOL = lendingPool;\n        ASSET_TOKEN = aToken;\n        POOL_DATA_PROVIDER = poolDataProvider;\n    }\n\n    function _holdings() internal view virtual override returns (address[] memory) {\n        address[] memory result = new address[](1);\n        result[0] = ASSET_TOKEN;\n        return result;\n    }\n\n    function _holdingValuesInUnderlying() internal view virtual override returns (uint256[] memory) {\n        address[] memory tokens = new address[](1);\n        tokens[0] = ASSET_TOKEN;\n        return NOTIONAL.getStoredTokenBalances(tokens);\n    }\n\n    function _getTotalUnderlyingValueView() internal view virtual override returns (uint256) {\n        // Aave v3 asset tokens are in the same decimals and denomination as underlying and\n        // therefore we can add them together directly.\n        address[] memory tokens = new address[](2);\n        tokens[0] = UNDERLYING_TOKEN;\n        tokens[1] = ASSET_TOKEN;\n\n        uint256[] memory balances = NOTIONAL.getStoredTokenBalances(tokens);\n        return balances[0].add(balances[1]);\n    }\n\n    /// @notice Returns calldata for how to withdraw an amount\n    function _getRedemptionCalldata(uint256 withdrawAmount)\n        internal view virtual override returns (RedeemData[] memory data)\n    {\n        address underlyingToken = UNDERLYING_IS_ETH ? address(Deployments.WETH) : UNDERLYING_TOKEN;\n\n        if (withdrawAmount == 0) return data;\n\n        address[] memory targets = new address[](UNDERLYING_IS_ETH ? 2 : 1);\n        bytes[] memory callData = new bytes[](UNDERLYING_IS_ETH ? 2 : 1);\n        targets[0] = LENDING_POOL;\n        callData[0] = abi.encodeWithSelector(\n            ILendingPool.withdraw.selector, underlyingToken, withdrawAmount, address(NOTIONAL)\n        );\n\n        if (UNDERLYING_IS_ETH) {\n            // Aave V3 returns WETH instead of native ETH so we have to unwrap it here\n            targets[1] = address(Deployments.WETH);\n            callData[1] = abi.encodeWithSelector(WETH9.withdraw.selector, withdrawAmount);\n        }\n\n        data = new RedeemData[](1);\n        // Tokens with less than or equal to 8 decimals sometimes have off by 1 issues when depositing\n        // into Aave V3. Aave returns one unit less than has been deposited. This adjustment is applied\n        // to ensure that this unit of token is credited back to prime cash holders appropriately.\n        uint8 rebasingTokenBalanceAdjustment = UNDERLYING_DECIMALS <= 8 ? 1 : 0;\n        data[0] = RedeemData(\n            targets, callData, withdrawAmount, ASSET_TOKEN, rebasingTokenBalanceAdjustment\n        );\n\n    }\n\n    function _getRedemptionCalldataForRebalancing(address[] calldata holdings, uint256[] calldata withdrawAmounts)\n        internal view virtual override returns (RedeemData[] memory redeemData)\n    {\n        require(holdings.length == 1 && holdings[0] == ASSET_TOKEN);\n        return _getRedemptionCalldata(withdrawAmounts[0]);\n    }\n\n    function _getDepositCalldataForRebalancing(address[] calldata holdings, uint256[] calldata depositAmounts)\n        internal view virtual override returns (DepositData[] memory data)\n    {\n        require(holdings.length == 1 && holdings[0] == ASSET_TOKEN);\n\n        address from = address(NOTIONAL);\n        uint256 depositUnderlyingAmount = depositAmounts[0];\n        if (depositUnderlyingAmount == 0) return data;\n\n        address[] memory targets = new address[](UNDERLYING_IS_ETH ? 3 : 2);\n        bytes[] memory callData = new bytes[](UNDERLYING_IS_ETH ? 3 : 2);\n        uint256[] memory msgValue = new uint256[](UNDERLYING_IS_ETH ? 3 : 2);\n\n        if (UNDERLYING_IS_ETH) {\n            targets[0] = address(Deployments.WETH);\n            msgValue[0] = depositUnderlyingAmount;\n            callData[0] = abi.encodeWithSelector(WETH9.deposit.selector, depositUnderlyingAmount);\n\n            targets[1] = address(Deployments.WETH);\n            callData[1] = abi.encodeWithSelector(IERC20.approve.selector, LENDING_POOL, depositUnderlyingAmount);\n\n            targets[2] = LENDING_POOL;\n            callData[2] = abi.encodeWithSelector(\n                ILendingPool.deposit.selector,\n                address(Deployments.WETH),\n                depositUnderlyingAmount,\n                from,\n                0 // referralCode\n            );\n        } else {\n            targets[0] = UNDERLYING_TOKEN;\n            callData[0] = abi.encodeWithSelector(IERC20.approve.selector, LENDING_POOL, depositUnderlyingAmount);\n\n            targets[1] = LENDING_POOL;\n            callData[1] = abi.encodeWithSelector(\n                ILendingPool.deposit.selector,\n                UNDERLYING_TOKEN,\n                depositUnderlyingAmount,\n                from,\n                0 // referralCode\n            );\n        }\n\n        data = new DepositData[](1);\n\n        // See a similar comment in getRedemptionCalldata\n        uint8 rebasingTokenBalanceAdjustment = UNDERLYING_DECIMALS <= 8 ? 1 : 0;\n        data[0] = DepositData(\n            targets, callData, msgValue, depositUnderlyingAmount, ASSET_TOKEN, rebasingTokenBalanceAdjustment\n        );\n    }\n\n    /// @notice Returns the oracle data during rebalancing\n    function getOracleData() external view override returns (OracleData memory oracleData) {\n        address underlying = UNDERLYING_IS_ETH ? address(Deployments.WETH) : UNDERLYING_TOKEN;\n\n        (/* */, uint256 supplyCap) = IPoolDataProvider(POOL_DATA_PROVIDER).getReserveCaps(underlying);\n        // Supply caps are returned as whole token values\n        supplyCap = supplyCap * UNDERLYING_PRECISION;\n        uint256 aTokenSupply = IPoolDataProvider(POOL_DATA_PROVIDER).getATokenTotalSupply(underlying);\n\n        // If supply cap is zero, that means there is no cap on the pool\n        if (supplyCap == 0) {\n            oracleData.maxExternalDeposit = type(uint256).max;\n        } else if (supplyCap <= aTokenSupply) {\n            oracleData.maxExternalDeposit = 0;\n        } else {\n            // underflow checked as consequence of if / else statement\n            oracleData.maxExternalDeposit = supplyCap - aTokenSupply;\n        }\n\n        oracleData.holding = ASSET_TOKEN;\n        // The balance of the underlying on the aToken contract is the maximum that can be withdrawn\n        oracleData.externalUnderlyingAvailableForWithdraw = IERC20(underlying).balanceOf(ASSET_TOKEN);\n        // This is the returned stored token balance of the aToken\n        oracleData.currentExternalUnderlyingLend = _holdingValuesInUnderlying()[0];\n    }\n}"
    },
    {
      "filename": "contracts-v3/contracts/internal/balances/ExternalLending.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    PrimeRate,\n    PrimeCashFactors,\n    RebalancingTargetData\n} from \"../../global/Types.sol\";\nimport {\n    IPrimeCashHoldingsOracle,\n    OracleData,\n    RedeemData,\n    DepositData\n} from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\nimport {TokenHandler} from \"./TokenHandler.sol\";\n\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\n\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {GenericToken} from \"./protocols/GenericToken.sol\";\n\n\nlibrary ExternalLending {\n    using PrimeRateLib for PrimeRate;\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using TokenHandler for Token;\n\n    function getTargetExternalLendingAmount(\n        Token memory underlyingToken,\n        PrimeCashFactors memory factors,\n        RebalancingTargetData memory rebalancingTargetData,\n        OracleData memory oracleData,\n        PrimeRate memory pr\n    ) internal pure returns (uint256 targetAmount) {\n        // Short circuit a zero target\n        if (rebalancingTargetData.targetUtilization == 0) return 0;\n\n        int256 totalPrimeCashInUnderlying = pr.convertToUnderlying(int256(factors.totalPrimeSupply));\n        int256 totalPrimeDebtInUnderlying = pr.convertDebtStorageToUnderlying(int256(factors.totalPrimeDebt).neg()).abs();\n\n        // The target amount to lend is based on a target \"utilization\" of the total prime supply. For example, for\n        // a target utilization of 80%, if the prime cash utilization is 70% (totalPrimeSupply / totalPrimeDebt) then\n        // we want to lend 10% of the total prime supply. This ensures that 20% of the totalPrimeSupply will not be held\n        // in external money markets which run the risk of becoming unredeemable.\n        int256 targetExternalUnderlyingLend = totalPrimeCashInUnderlying\n            .mul(rebalancingTargetData.targetUtilization)\n            .div(Constants.PERCENTAGE_DECIMALS)\n            .sub(totalPrimeDebtInUnderlying);\n        // Floor this value at zero. This will be negative above the target utilization. We do not want to be lending at\n        // all above the target.\n        if (targetExternalUnderlyingLend < 0) targetExternalUnderlyingLend = 0;\n\n        // To ensure redeemability of Notional’s funds on external lending markets,\n        // Notional requires there to be redeemable funds on the external lending market\n        // that are a multiple of the funds that Notional has lent on that market itself.\n        //\n        // The max amount that Notional can lend on that market is a function\n        // of the excess redeemable funds on that market\n        // (funds that are redeemable in excess of Notional’s own funds on that market)\n        // and the externalWithdrawThreshold.\n        //\n        // excessFunds = externalUnderlyingAvailableForWithdraw - currentExternalUnderlyingLend\n        //\n        // maxExternalUnderlyingLend * (externalWithdrawThreshold + 1) = maxExternalUnderlyingLend + excessFunds\n        //\n        // maxExternalUnderlyingLend * (externalWithdrawThreshold + 1) - maxExternalUnderlyingLend = excessFunds\n        //\n        // maxExternalUnderlyingLend * externalWithdrawThreshold = excessFunds\n        //\n        // maxExternalUnderlyingLend = excessFunds / externalWithdrawThreshold\n        uint256 maxExternalUnderlyingLend;\n        if (oracleData.currentExternalUnderlyingLend < oracleData.externalUnderlyingAvailableForWithdraw) {\n            maxExternalUnderlyingLend =\n                (oracleData.externalUnderlyingAvailableForWithdraw - oracleData.currentExternalUnderlyingLend)\n                .mul(uint256(Constants.PERCENTAGE_DECIMALS))\n                .div(rebalancingTargetData.externalWithdrawThreshold);\n        } else {\n            maxExternalUnderlyingLend = 0;\n        }\n\n        targetAmount = SafeUint256.min(\n            // totalPrimeCashInUnderlying and totalPrimeDebtInUnderlying are in 8 decimals, convert it to native\n            // token precision here for accurate comparison. No underflow possible since targetExternalUnderlyingLend\n            // is floored at zero.\n            uint256(underlyingToken.convertToExternal(targetExternalUnderlyingLend)),\n            // maxExternalUnderlyingLend is limit enforced by setting externalWithdrawThreshold\n            // maxExternalDeposit is limit due to the supply cap on external pools\n            SafeUint256.min(maxExternalUnderlyingLend, oracleData.maxExternalDeposit)\n        );\n        // in case of redemption, make sure there is enough to withdraw, important for health check so that\n        // it does not trigger rebalances (redemptions) when there is nothing to redeem\n        if (targetAmount < oracleData.currentExternalUnderlyingLend) {\n            uint256 forRedemption = oracleData.currentExternalUnderlyingLend - targetAmount;\n            if (oracleData.externalUnderlyingAvailableForWithdraw < forRedemption) {\n                // increase target amount so that redemptions amount match externalUnderlyingAvailableForWithdraw\n                targetAmount = targetAmount.add(\n                    // unchecked - is safe here, overflow is not possible due to above if conditional\n                    forRedemption - oracleData.externalUnderlyingAvailableForWithdraw\n                );\n            }\n        }\n    }\n\n    /// @notice Prime cash holdings may be in underlying tokens or they may be held in other money market\n    /// protocols like Compound, Aave or Euler. If there is insufficient underlying tokens to withdraw on\n    /// the contract, this method will redeem money market tokens in order to gain sufficient underlying\n    /// to withdraw from the contract.\n    /// @param currencyId associated currency id\n    /// @param underlying underlying token information\n    /// @param withdrawAmountExternal amount of underlying to withdraw in external token precision\n    function redeemMoneyMarketIfRequired(\n        uint16 currencyId,\n        Token memory underlying,\n        uint256 withdrawAmountExternal\n    ) internal {\n        // If there is sufficient balance of the underlying to withdraw from the contract\n        // immediately, just return.\n        mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\n        uint256 currentBalance = store[underlying.tokenAddress];\n        if (withdrawAmountExternal <= currentBalance) return;\n\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        // Redemption data returns an array of contract calls to make from the Notional proxy (which\n        // is holding all of the money market tokens).\n        (RedeemData[] memory data) = oracle.getRedemptionCalldata(withdrawAmountExternal - currentBalance);\n\n        // This is the total expected underlying that we should redeem after all redemption calls\n        // are executed.\n        uint256 totalUnderlyingRedeemed = executeMoneyMarketRedemptions(underlying, data);\n\n        // Ensure that we have sufficient funds before we exit\n        require(withdrawAmountExternal <= currentBalance.add(totalUnderlyingRedeemed)); // dev: insufficient redeem\n    }\n\n    /// @notice It is critical that this method measures and records the balanceOf changes before and after\n    /// every token change. If not, then external donations can affect the valuation of pCash and pDebt\n    /// tokens which may be exploitable.\n    /// @param redeemData parameters from the prime cash holding oracle\n    function executeMoneyMarketRedemptions(\n        Token memory underlyingToken,\n        RedeemData[] memory redeemData\n    ) internal returns (uint256 totalUnderlyingRedeemed) {\n        for (uint256 i; i < redeemData.length; i++) {\n            RedeemData memory data = redeemData[i];\n            // Measure the token balance change if the `assetToken` value is set in the\n            // current redemption data struct. \n            uint256 oldAssetBalance = IERC20(data.assetToken).balanceOf(address(this));\n\n            // Measure the underlying balance change before and after the call.\n            uint256 oldUnderlyingBalance = TokenHandler.balanceOf(underlyingToken, address(this));\n\n            // Some asset tokens may require multiple calls to redeem if there is an unstake\n            // or redemption from WETH involved. We only measure the asset token balance change\n            // on the final redemption call, as dictated by the prime cash holdings oracle.\n            for (uint256 j; j < data.targets.length; j++) {\n                GenericToken.executeLowLevelCall(data.targets[j], 0, data.callData[j]);\n            }\n\n            // Ensure that we get sufficient underlying on every redemption\n            uint256 newUnderlyingBalance = TokenHandler.balanceOf(underlyingToken, address(this));\n            uint256 underlyingBalanceChange = newUnderlyingBalance.sub(oldUnderlyingBalance);\n            // If the call is not the final redemption, then expectedUnderlying should\n            // be set to zero.\n            require(data.expectedUnderlying <= underlyingBalanceChange);\n\n            // Measure and update the asset token\n            uint256 newAssetBalance = IERC20(data.assetToken).balanceOf(address(this));\n            require(newAssetBalance <= oldAssetBalance);\n\n            if (\n                (data.rebasingTokenBalanceAdjustment != 0) &&\n                // This equation only makes sense when the \"asset token\" is a rebasing token\n                // in the same denomination as the underlying token. This will only be reached\n                // if the rebasingTokenBalanceAdjustment is set to a non-zero value\n                (underlyingBalanceChange != oldAssetBalance.sub(newAssetBalance))\n            ) {\n                newAssetBalance = newAssetBalance.add(data.rebasingTokenBalanceAdjustment);\n            }\n\n            TokenHandler.updateStoredTokenBalance(data.assetToken, oldAssetBalance, newAssetBalance);\n\n            // Update the total value with the net change\n            totalUnderlyingRedeemed = totalUnderlyingRedeemed.add(underlyingBalanceChange);\n\n            // totalUnderlyingRedeemed is always positive or zero.\n            TokenHandler.updateStoredTokenBalance(underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance);\n        }\n    }\n\n    /// @notice Executes deposits to an external lending protocol. Only called during a rebalance executed\n    /// by the TreasuryAction contract.\n    function executeDeposits(Token memory underlyingToken, DepositData[] memory deposits) internal {\n        for (uint256 i; i < deposits.length; i++) {\n            DepositData memory depositData = deposits[i];\n            // Measure the token balance change if the `assetToken` value is set in the\n            // current deposit data struct.\n            uint256 oldAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n\n            // Measure the underlying balance change before and after the call.\n            uint256 oldUnderlyingBalance = underlyingToken.balanceOf(address(this));\n\n            for (uint256 j; j < depositData.targets.length; ++j) {\n                GenericToken.executeLowLevelCall(\n                    depositData.targets[j],\n                    depositData.msgValue[j],\n                    depositData.callData[j]\n                );\n            }\n\n            // Ensure that the underlying balance change matches the deposit amount\n            uint256 newUnderlyingBalance = underlyingToken.balanceOf(address(this));\n            uint256 underlyingBalanceChange = oldUnderlyingBalance.sub(newUnderlyingBalance);\n            // Ensure that only the specified amount of underlying has left the protocol\n            require(underlyingBalanceChange <= depositData.underlyingDepositAmount);\n\n            // Measure and update the asset token\n            uint256 newAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n            require(oldAssetBalance <= newAssetBalance);\n\n            if (\n                (depositData.rebasingTokenBalanceAdjustment != 0) &&\n                // This equation only makes sense when the \"asset token\" is a rebasing token\n                // in the same denomination as the underlying token. This will only be reached\n                // if the rebasingTokenBalanceAdjustment is set to a non-zero value\n                (underlyingBalanceChange != newAssetBalance.sub(oldAssetBalance))\n            ) {\n                newAssetBalance = newAssetBalance.add(depositData.rebasingTokenBalanceAdjustment);\n            }\n\n            TokenHandler.updateStoredTokenBalance(depositData.assetToken, oldAssetBalance, newAssetBalance);\n            TokenHandler.updateStoredTokenBalance(\n                underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance\n            );\n        }\n    }\n\n}"
    },
    {
      "filename": "contracts-v3/contracts/external/actions/TreasuryAction.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    PrimeRate,\n    PrimeCashFactorsStorage,\n    PrimeCashFactors,\n    RebalancingTargetData,\n    RebalancingContextStorage\n} from \"../../global/Types.sol\";\nimport {StorageLayoutV2} from \"../../global/StorageLayoutV2.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\nimport {Emitter} from \"../../internal/Emitter.sol\";\nimport {BalanceHandler} from \"../../internal/balances/BalanceHandler.sol\";\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {TokenHandler} from \"../../internal/balances/TokenHandler.sol\";\nimport {ExternalLending} from \"../../internal/balances/ExternalLending.sol\";\nimport {nTokenHandler} from \"../../internal/nToken/nTokenHandler.sol\";\nimport {nTokenSupply} from \"../../internal/nToken/nTokenSupply.sol\";\nimport {PrimeCashExchangeRate} from \"../../internal/pCash/PrimeCashExchangeRate.sol\";\nimport {GenericToken} from \"../../internal/balances/protocols/GenericToken.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {NotionalTreasury} from \"../../../interfaces/notional/NotionalTreasury.sol\";\nimport {IRewarder} from \"../../../interfaces/notional/IRewarder.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {IPrimeCashHoldingsOracle, DepositData, RedeemData, OracleData}\n    from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\n\ncontract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {\n    using PrimeRateLib for PrimeRate;\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using SafeERC20 for IERC20;\n    using TokenHandler for Token;\n\n    struct RebalancingData {\n        RedeemData[] redeemData;\n        DepositData[] depositData;\n    }\n\n    /// @dev Harvest methods are only callable by the authorized treasury manager contract\n    modifier onlyManagerContract() {\n        require(treasuryManagerContract == msg.sender, \"Treasury manager required\");\n        _;\n    }\n\n    /*****************************************\n     * Governance Methods                    *\n     *****************************************/\n\n    /// @notice Sets the new treasury manager contract\n    function setTreasuryManager(address manager) external override onlyOwner {\n        emit TreasuryManagerChanged(treasuryManagerContract, manager);\n        treasuryManagerContract = manager;\n    }\n\n    /// @notice Set the rebalancing bot to call the rebalance method.\n    function setRebalancingBot(address _rebalancingBot) external override onlyOwner {\n        rebalancingBot = _rebalancingBot;\n    }\n\n    /// @notice Sets the reserve buffer. This is the amount of reserve balance to keep denominated in 1e8\n    /// The reserve cannot be harvested if it's below this amount. This portion of the reserve will remain on\n    /// the contract to act as a buffer against potential insolvency.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param bufferAmount reserve buffer amount to keep in internal token precision (1e8)\n    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n        reserveBuffer[currencyId] = bufferAmount;\n        emit ReserveBufferUpdated(currencyId, bufferAmount);\n    }\n\n    /// @notice Updates the emission rate of incentives for a given currency\n    /// @dev emit:UpdateIncentiveEmissionRate\n    /// @param currencyId the currency id that the nToken references\n    /// @param newEmissionRate Target total incentives to emit for an nToken over an entire year\n    /// denominated in WHOLE TOKENS (i.e. setting this to 1 means 1e8 tokens). The rate will not be\n    /// exact due to multiplier effects and fluctuating token supply.\n    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(nTokenAddress != address(0));\n        // Sanity check that emissions rate is not specified in 1e8 terms.\n        require(newEmissionRate < Constants.INTERNAL_TOKEN_PRECISION, \"Invalid rate\");\n\n        nTokenSupply.setIncentiveEmissionRate(nTokenAddress, newEmissionRate, block.timestamp);\n        emit UpdateIncentiveEmissionRate(currencyId, newEmissionRate);\n    }\n\n    /// @notice This is used in the case of insolvency. It allows the owner to re-align the reserve with its correct balance.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param newBalance new reserve balance to set, must be less than the current balance\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n        // newBalance cannot be negative and is checked inside BalanceHandler.setReserveCashBalance\n        BalanceHandler.setReserveCashBalance(currencyId, newBalance);\n    }\n\n    /// @notice Sets the rebalancing parameters that define how often a token is rebalanced. Rebalancing targets a\n    /// specific Prime Cash utilization while ensuring that we have the ability to withdraw from an external money\n    /// market if we need to.\n    function setRebalancingTargets(\n        uint16 currencyId,\n        RebalancingTargetConfig[] calldata targets\n    ) external override onlyOwner {\n        address holding =\n            PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId).holdings()[0];\n\n        // Currently, the functionality only supports lending on a single external money market. If we want to expand beyond\n        // that then how we calculate the rebalancing amounts will have to change.\n        require(targets.length == 1);\n\n        mapping(address => RebalancingTargetData) storage rebalancingTargets = LibStorage.getRebalancingTargets()[currencyId];\n\n        RebalancingTargetConfig memory config = targets[0];\n\n        require(config.holding == holding);\n        require(config.targetUtilization < 100);\n        require(100 <= config.externalWithdrawThreshold);\n\n        rebalancingTargets[holding] = RebalancingTargetData(config.targetUtilization, config.externalWithdrawThreshold);\n\n        emit RebalancingTargetsUpdated(currencyId, targets);\n\n        // Rebalance the currency immediately after we set targets. This allows the owner to immediately exit money\n        // markets by setting all the targets to zero. The cooldown check is skipped in this case.\n        _rebalanceCurrency({currencyId: currencyId, useCooldownCheck: false});\n    }\n\n    /// @notice Sets the time between calls to the rebalance method by the rebalancing bot.\n    function setRebalancingCooldown(uint16 currencyId, uint40 cooldownTimeInSeconds) external override onlyOwner {\n        mapping(uint16 => RebalancingContextStorage) storage store = LibStorage.getRebalancingContext();\n        store[currencyId].rebalancingCooldownInSeconds = cooldownTimeInSeconds;\n        emit RebalancingCooldownUpdated(currencyId, cooldownTimeInSeconds);\n    }\n\n    /*****************************************\n     * Treasury Manager Methods              *\n     *****************************************/\n\n    /// @notice Transfers some amount of reserve assets to the treasury manager contract. Reserve assets are\n    /// the result of collecting fCash trading fees and vault fees and denominated in Prime Cash. Redeems prime cash\n    /// to underlying as it is transferred off the protocol.\n    /// @param currencies an array of currencies to transfer from Notional\n    function transferReserveToTreasury(uint16[] calldata currencies) external override onlyManagerContract \n        nonReentrant returns (uint256[] memory)\n    {\n        uint256[] memory amountsTransferred = new uint256[](currencies.length);\n\n        for (uint256 i; i < currencies.length; ++i) {\n            // Prevents duplicate currency IDs\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n\n            // Reserve buffer amount in INTERNAL_TOKEN_PRECISION\n            int256 bufferInternal = SafeInt256.toInt(reserveBuffer[currencyId]);\n\n            // Reserve requirement not defined\n            if (bufferInternal == 0) continue;\n\n            int256 reserveInternal = BalanceHandler.getPositiveCashBalance(Constants.FEE_RESERVE, currencyId);\n\n            // Do not withdraw anything if reserve is below or equal to reserve requirement\n            if (reserveInternal <= bufferInternal) continue;\n\n            // Actual reserve amount allowed to be redeemed and transferred\n            // NOTE: overflow not possible with the check above\n            int256 primeCashRedeemed = reserveInternal - bufferInternal;\n\n            // Redeems prime cash and transfer underlying to treasury manager contract\n            amountsTransferred[i] = _redeemAndTransfer(currencyId, primeCashRedeemed);\n\n            // Updates the reserve balance\n            BalanceHandler.harvestExcessReserveBalance(\n                currencyId,\n                reserveInternal,\n                primeCashRedeemed\n            );\n        }\n\n        // NOTE: TreasuryManager contract will emit an AssetsHarvested event\n        return amountsTransferred;\n    }\n\n    /// @notice Harvests interest income from rebalancing. Interest income is different from reserve assets because they\n    /// are not accounted for with in stored token balances and therefore are not accessible by Prime Cash holders. Any\n    /// interest will be transferred to the treasury manager.\n    function harvestAssetInterest(uint16[] calldata currencies) external override onlyManagerContract nonReentrant {\n        for (uint256 i; i < currencies.length; ++i) {\n            // Prevents duplicate currency IDs\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n            _skimInterest(currencyId, PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId));\n        }\n    }\n\n    /// @notice Redeems and transfers tokens to the treasury manager contract. This method is distinct from _skimInterest\n    /// because it redeems prime cash held by the protocol, _skimInterest transfers external lending tokens held by the\n    /// protocol.\n    function _redeemAndTransfer(uint16 currencyId, int256 primeCashRedeemAmount) private returns (uint256) {\n        PrimeRate memory primeRate = PrimeRateLib.buildPrimeRateStateful(currencyId);\n        Emitter.emitTransferPrimeCash(Constants.FEE_RESERVE, treasuryManagerContract, currencyId, primeCashRedeemAmount);\n\n        int256 actualTransferExternal = TokenHandler.withdrawPrimeCash(\n            treasuryManagerContract,\n            treasuryManagerContract,\n            currencyId,\n            primeCashRedeemAmount.neg(),\n            primeRate,\n            true // if ETH, transfers it as WETH\n        ).neg();\n\n        require(actualTransferExternal > 0);\n        return uint256(actualTransferExternal);\n    }\n\n    /// @notice Transfers any excess balance above the stored token balance to the treasury manager. This\n    /// balance is not accessible by Prime Cash holders and represents interest earned by the protocol\n    // from lending on external money markets.\n    function _skimInterest(uint16 currencyId, IPrimeCashHoldingsOracle oracle) private {\n        address[] memory asse"
    }
  ]
}