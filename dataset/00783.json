{
  "Title": "H-2: Wrong parameter when retrieving causes a complete DoS of the protocol",
  "Content": "# Issue H-2: Wrong parameter when retrieving causes a complete DoS of the protocol \n\nSource: https://github.com/sherlock-audit/2024-01-telcoin-judging/issues/139 \n\n## Found by \n0xadrii, Arz, Tricko, eeshenggoh, fibonacci\n## Summary\n\nA wrong parameter in the `_retrieve()` prevents the protocol from properly interacting with Sablier, causing a Denial of Service in all functions calling `_retrieve()`.\n\n## Vulnerability Detail\n\nThe `CouncilMember` contract is designed to interact with a Sablier stream. As time passes, the Sablier stream will unlock more TELCOIN tokens which will be available to be retrieved from `CouncilMember`.\n\nThe `_retrieve()` internal function will be used in order to fetch the rewards from the stream and distribute them among the Council Member NFT holders (snippet reduced for simplicity):\n\n```solidity\n// CouncilMember.sol\n\nfunction _retrieve() internal {\n        ...\n        // Execute the withdrawal from the _target, which might be a Sablier stream or another protocol\n        _stream.execute(\n            _target,\n            abi.encodeWithSelector(\n                ISablierV2ProxyTarget.withdrawMax.selector, \n                _target, \n                _id,\n                address(this)\n            )\n        );\n\n        ...\n    }\n```\n\nThe most important part in `_retrieve()` regarding the vulnerability that we’ll dive into is the  `_stream.execute()` interaction and the params it receives. In order to understand such interaction, we first need understand the importance of the `_stream` and the `_target` variables.\n\nSablier allows developers to integrate Sablier via [Periphery contracts](https://github.com/sablier-labs/v2-periphery/tree/main), which prevents devs from dealing with the complexity of directly integrating Sablier’s [Core contracts](https://github.com/sablier-labs/v2-core). Telcoin developers have decided to use these periphery contracts. Concretely, the following contracts have been used:\n\n- [ProxyTarget](https://github.com/sablier-labs/v2-periphery/blob/ba3926d2c3e059a230211077087b73afe46acf64/src/SablierV2ProxyTargetApprove.sol) (link points to an older commit because **[the proxy target contracts have now been deprecated from Sablier](https://github.com/sablier-labs/v2-periphery/pull/226)**): stored in the `_target` variable, this contract acts as the target for a PRBProxy contract. It contains all the complex interactions with the underlying stream. Concretely, Telcoin uses the `[withdrawMax()](https://github.com/sablier-labs/v2-periphery/blob/ba3926d2c3e059a230211077087b73afe46acf64/src/abstracts/SablierV2ProxyTarget.sol#L141C5-L143C6)` function in the proxy target to withdraw all the available funds from the stream (as seen in the previous code snippet).\n- [PRBProxy](https://github.com/PaulRBerg/prb-proxy/blob/main/src/PRBProxy.sol): stored in the `_stream` variable, this contract acts as a forwarding (non-upgradable) proxy, acting as a smart wallet that enables multiple contract calls within a single transaction.\n\n> NOTE: It is important to understand that the actual lockup linear stream will be deployed as well. The difference is that the Telcoin protocol  will not interact with that contract directly. Instead, the PRBProxy and proxy target contracts will be leveraged to perform such interactions.\n> \n\nKnowing this, we can now move on to explaining Telcoin’s approach to withdrawing the available tokens from the stream. As seen in the code snippet above, the `_retrieve()` function will perform two steps to actually perform a withdraw from the stream:\n\nIt will first call the `_stream`'s  `execute()` function (remember `_stream` is a PRBProxy). This function receives a `target` and some `data` as parameter, and performs a delegatecall aiming at the `target`:\n\n```solidity\n// https://github.com/PaulRBerg/prb-proxy/blob/main/src/PRBProxy.sol\n\n/// @inheritdoc IPRBProxy\n   function execute(address target, bytes calldata data) external payable override returns (bytes memory response) {\n        ...\n\n        // Delegate call to the target contract, and handle the response.\n        response = _execute(target, data);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                          INTERNAL NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Executes a DELEGATECALL to the provided target with the provided data.\n    /// @dev Shared logic between the constructor and the `execute` function.\n    function _execute(address target, bytes memory data) internal returns (bytes memory response) {\n        // Check that the target is a contract.\n        if (target.code.length == 0) {\n            revert PRBProxy_TargetNotContract(target);\n        }\n\n        // Delegate call to the target contract.\n        bool success;\n        (success, response) = target.delegatecall(data);\n\n        ...\n    }\n```\n\nIn the `_retrieve()` function, the target where the call will be forwarded to is the `_target` parameter, which is a [ProxyTarget](https://github.com/sablier-labs/v2-periphery/blob/ba3926d2c3e059a230211077087b73afe46acf64/src/SablierV2ProxyTargetApprove.sol) contract. Concretely, the delegatecall function that will be triggered in the [ProxyTarget](https://github.com/sablier-labs/v2-periphery/blob/ba3926d2c3e059a230211077087b73afe46acf64/src/SablierV2ProxyTargetApprove.sol) will be `withdrawMax()`:\n\n```solidity\n// https://github.com/sablier-labs/v2-periphery/blob/ba3926d2c3e059a230211077087b73afe46acf64/src/abstracts/SablierV2ProxyTarget.sol#L141C5-L143C6\n\nfunction withdrawMax(ISablierV2Lockup lockup, uint256 streamId, address to) external onlyDelegateCall {\n\tlockup.withdrawMax(streamId, to);\n}\n```\n\nAs we can see, the `withdrawMax()` function has as parameters the `lockup` stream contract to withdraw from, the `streamId` and the address `to` which will receive the available funds from the stream. The vulnerability lies in the parameters passed when calling the `withdrawMax()` function in `_retrieve()`. As we can see, the first encoded parameter in the `encodeWithSelector()` call after the selector is the `_target`:\n\n```solidity\n// CouncilMember.sol\n\nfunction _retrieve() internal {\n        ...\n        // Execute the withdrawal from the _target, which might be a Sablier stream or another protocol\n        _stream.execute(\n            _target,\n            abi.encodeWithSelector(\n                ISablierV2ProxyTarget.withdrawMax.selector, \n                _target,   // <------- This is incorrect\n                _id,\n                address(this)\n            )\n        );\n\n        ...\n    }\n```\n\nThis means that the proxy target’s `withdrawMax()` function will be triggered with the `_target` contract as the `lockup` parameter, which is incorrect. This will make all calls eventually execute `withdrawMax()` on the PRBProxy contract, always reverting.\n\nThe parameter needed to perform the `withdrawMax()` call correctly is the actual Sablier lockup contract, which is currently not stored in the `CouncilMember` contract.\n\nThe following diagram also summarizes the current wrong interactions for clarity:\n![vulnerability](https://github.com/sherlock-audit/2024-01-telcoin-judging/assets/1048185/abe4d636-fdd4-4ec8-897a-6d2daf737d95)\n\n\n## Impact\n\nHigh. ALL withdrawals from the Sablier stream will revert, effectively causing a DoS in the _retrieve() function. Because the _retrieve() function is called in all the main protocol functions, this vulnerability essentially prevents the protocol from ever functioning correctly.\n\n## Proof of Concept\n\nBecause the current Telcoin repo does not include actual tests with the real Sablier contracts (instead, a `TestStream` contract is used, which has led to not unveiling this vulnerability), [[I’ve created a repository](https://github.com/0xadrii/telcoin-proof-of-concept)](https://github.com/0xadrii/telcoin-proof-of-concept) where the poc can be executed (the repository will be public after the audit finishes (on 15 jan. 2024 at 16:00 CET)). The `testPoc()` function  shows how any interaction (in this case, a call to the `mint()` function) will fail because the proper Sablier contracts are used (PRBProxy and proxy target):\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {SablierV2Comptroller} from \"@sablier/v2-core/src/SablierV2Comptroller.sol\";\nimport {SablierV2NFTDescriptor} from \"@sablier/v2-core/src/SablierV2NFTDescriptor.sol\";\nimport {SablierV2LockupLinear} from \"@sablier/v2-core/src/SablierV2LockupLinear.sol\";\nimport {ISablierV2Comptroller} from \"@sablier/v2-core/src/interfaces/ISablierV2Comptroller.sol\";\nimport {ISablierV2NFTDescriptor} from \"@sablier/v2-core/src/interfaces/ISablierV2NFTDescriptor.sol\";\nimport {ISablierV2LockupLinear} from \"@sablier/v2-core/src/interfaces/ISablierV2LockupLinear.sol\";\n\nimport {CouncilMember, IPRBProxy} from \"../src/core/CouncilMember.sol\";\nimport {TestTelcoin} from \"./mock/TestTelcoin.sol\";\nimport {MockProxyTarget} from \"./mock/MockProxyTarget.sol\";\nimport {PRBProxy} from \"./mock/MockPRBProxy.sol\";\nimport {PRBProxyRegistry} from \"./mock/MockPRBProxyRegistry.sol\";\n\nimport {UD60x18} from \"@prb/math/src/UD60x18.sol\";\nimport {LockupLinear, Broker, IERC20} from \"@sablier/v2-core/src/types/DataTypes.sol\";\nimport {IERC20 as IERC20OZ} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract PocTest is Test {\n\n    ////////////////////////////////////////////////////////////////\n    //                        CONSTANTS                           //\n    ////////////////////////////////////////////////////////////////\n\n   bytes32 public constant GOVERNANCE_COUNCIL_ROLE =\n        keccak256(\"GOVERNANCE_COUNCIL_ROLE\");\n    bytes32 public constant SUPPORT_ROLE = keccak256(\"SUPPORT_ROLE\");\n\n    ////////////////////////////////////////////////////////////////\n    //                         STORAGE                            //\n    ////////////////////////////////////////////////////////////////\n\n    /// @notice Poc Users\n    address public sablierAdmin;\n    address public user;\n\n    /// @notice Sablier contracts\n    SablierV2Comptroller public comptroller;\n    SablierV2NFTDescriptor public nftDescriptor;\n    SablierV2LockupLinear public lockupLinear;\n\n    /// @notice Telcoin contracts\n    PRBProxyRegistry public proxyRegistry;\n    PRBProxy public stream;\n    MockProxyTarget public target;\n    CouncilMember public councilMember;\n    TestTelcoin public telcoin;\n\n    function setUp() public {\n        // Setup users\n        _setupUsers();\n\n        // Deploy token\n        telcoin = new TestTelcoin(address(this));\n\n        // Deploy Sablier \n        _deploySablier();\n\n        // Deploy council member\n        councilMember = new CouncilMember();\n\n        // Setup stream\n        _setupStream();\n\n        // Setup the council member\n        _setupCouncilMember();\n    }\n\n    function testPoc() public {\n      // Step 1: Mint council NFT to user\n      councilMember.mint(user);\n      assertEq(councilMember.balanceOf(user), 1);\n\n      // Step 2: Forward time 1 days\n      vm.warp(block.timestamp + 1 days);\n      \n      // Step 3: All functions calling _retrieve() (mint(), burn(), removeFromOffice()) will fail\n      vm.expectRevert(abi.encodeWithSignature(\"PRBProxy_ExecutionReverted()\")); \n      councilMember.mint(user);\n    }\n\n    function _setupUsers() internal {\n        sablierAdmin = makeAddr(\"sablierAdmin\");\n        user = makeAddr(\"user\");\n    }\n\n    function _deploySablier() internal {\n        // Deploy protocol\n        comptroller = new SablierV2Comptroller(sablierAdmin);\n        nftDescriptor = new SablierV2NFTDescriptor();\n        lockupLinear = new SablierV2LockupLinear(\n            sablierAdmin,\n            ISablierV2Comptroller(address(comptroller)),\n            ISablierV2NFTDescriptor(address(nftDescriptor))\n        );\n    }\n\n    function _setupStream() internal {\n\n        // Deploy proxies\n        proxyRegistry = new PRBProxyRegistry();\n        stream = PRBProxy(payable(address(proxyRegistry.deploy())));\n        target = new MockProxyTarget();\n\n        // Setup stream\n        LockupLinear.Durations memory durations = LockupLinear.Durations({\n            cliff: 0,\n            total: 1 weeks\n        });\n\n        UD60x18 fee = UD60x18.wrap(0);\n\n        Broker memory broker = Broker({account: address(0), fee: fee});\n        LockupLinear.CreateWithDurations memory params = LockupLinear\n            .CreateWithDurations({\n                sender: address(this),\n                recipient: address(stream),\n                totalAmount: 100e18,\n                asset: IERC20(address(telcoin)),\n                cancelable: false,\n                transferable: false,\n                durations: durations,\n                broker: broker\n            });\n\n        bytes memory data = abi.encodeWithSelector(target.createWithDurations.selector, address(lockupLinear), params, \"\");\n\n        // Create the stream through the PRBProxy\n        telcoin.approve(address(stream), type(uint256).max);\n        bytes memory response = stream.execute(address(target), data);\n        assertEq(lockupLinear.ownerOf(1), address(stream));\n    }\n\n    function _setupCouncilMember() internal {\n      // Initialize\n      councilMember.initialize(\n            IERC20OZ(address(telcoin)),\n            \"Test Council\",\n            \"TC\",\n            IPRBProxy(address(stream)), // stream_\n            address(target), // target_\n            1, // id_\n            address(lockupLinear)\n        );\n\n        // Grant roles\n        councilMember.grantRole(GOVERNANCE_COUNCIL_ROLE, address(this));\n        councilMember.grantRole(SUPPORT_ROLE, address(this));\n    }\n  \n}\n```\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-telcoin/blob/main/telcoin-audit/contracts/sablier/core/CouncilMember.sol#L275\n\n## Tool used\n\nManual Review, foundry\n\n## Recommendation\n\nIn order to fix the vulnerability, the proper address needs to be passed when calling `withdrawMax()`. \n\n> Note that the actual stream address is currently NOT stored in `CouncilMember.sol`, so it will need to be stored (my example shows a new `actualStream` variable)\n> \n\n```diff\nfunction _retrieve() internal {\n        ...\n        // Execute the withdrawal from the _target, which might be a Sablier stream or another protocol\n        _stream.execute(\n            _target,\n            abi.encodeWithSelector(\n                ISablierV2ProxyTarget.withdrawMax.selector, \n-                _target, \n+\t\tactualStream\n                _id,\n                address(this)\n            )\n        );\n\n        ...\n    }\n```\n\n\n\n## Discussion\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/43\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { This is valid a a dupp of 086; the watson claims its hight but will still make it meduim due to the impact mentioned in issue 086; but making it the best report as the POC  is well written and implemented}\n\n\n\n**nevillehuang**\n\n@amshirif Is there anyway the admin can unblock DoS in withdrawals?\n\n**amshirif**\n\n@nevillehuang No, a new contract with these fixes would need to be deployed to prevent DoS because those two values had to be the same prior to the fix.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/156",
  "Code": [
    {
      "filename": "src/abstracts/SablierV2ProxyTarget.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.19;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IPRBProxy } from \"@prb/proxy/src/interfaces/IPRBProxy.sol\";\nimport { ISablierV2Lockup } from \"@sablier/v2-core/src/interfaces/ISablierV2Lockup.sol\";\nimport { ISablierV2LockupLinear } from \"@sablier/v2-core/src/interfaces/ISablierV2LockupLinear.sol\";\nimport { ISablierV2LockupDynamic } from \"@sablier/v2-core/src/interfaces/ISablierV2LockupDynamic.sol\";\nimport { LockupDynamic, LockupLinear } from \"@sablier/v2-core/src/types/DataTypes.sol\";\n\nimport { OnlyDelegateCall } from \"./OnlyDelegateCall.sol\";\nimport { ISablierV2ProxyTarget } from \"../interfaces/ISablierV2ProxyTarget.sol\";\nimport { IWrappedNativeAsset } from \"../interfaces/IWrappedNativeAsset.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { Batch } from \"../types/DataTypes.sol\";\n\n/*\n\n███████╗ █████╗ ██████╗ ██╗     ██╗███████╗██████╗     ██╗   ██╗██████╗\n██╔════╝██╔══██╗██╔══██╗██║     ██║██╔════╝██╔══██╗    ██║   ██║╚════██╗\n███████╗███████║██████╔╝██║     ██║█████╗  ██████╔╝    ██║   ██║ █████╔╝\n╚════██║██╔══██║██╔══██╗██║     ██║██╔══╝  ██╔══██╗    ╚██╗ ██╔╝██╔═══╝\n███████║██║  ██║██████╔╝███████╗██║███████╗██║  ██║     ╚████╔╝ ███████╗\n╚══════╝╚═╝  ╚═╝╚═════╝ ╚══════╝╚═╝╚══════╝╚═╝  ╚═╝      ╚═══╝  ╚══════╝\n\n██████╗ ██████╗  ██████╗ ██╗  ██╗██╗   ██╗    ████████╗ █████╗ ██████╗  ██████╗ ███████╗████████╗\n██╔══██╗██╔══██╗██╔═══██╗╚██╗██╔╝╚██╗ ██╔╝    ╚══██╔══╝██╔══██╗██╔══██╗██╔════╝ ██╔════╝╚══██╔══╝\n██████╔╝██████╔╝██║   ██║ ╚███╔╝  ╚████╔╝        ██║   ███████║██████╔╝██║  ███╗█████╗     ██║\n██╔═══╝ ██╔══██╗██║   ██║ ██╔██╗   ╚██╔╝         ██║   ██╔══██║██╔══██╗██║   ██║██╔══╝     ██║\n██║     ██║  ██║╚██████╔╝██╔╝ ██╗   ██║          ██║   ██║  ██║██║  ██║╚██████╔╝███████╗   ██║\n╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝          ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝   ╚═╝\n\n*/\n\n/// @title SablierV2ProxyTarget\n/// @notice See the documentation in {ISablierV2ProxyTarget}.\nabstract contract SablierV2ProxyTarget is\n    ISablierV2ProxyTarget, // 0 inherited components\n    OnlyDelegateCall // 0 inherited components\n{\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 SABLIER-V2-LOCKUP\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function batchCancelMultiple(\n        Batch.CancelMultiple[] calldata batch,\n        IERC20[] calldata assets\n    )\n        external\n        onlyDelegateCall\n    {\n        // Check that the batch size is not zero.\n        uint256 batchSize = batch.length;\n        if (batchSize == 0) {\n            revert Errors.SablierV2ProxyTarget_BatchSizeZero();\n        }\n\n        // Load the balances before the cancellations.\n        uint256[] memory initialBalances = _getBalances(assets);\n\n        for (uint256 i = 0; i < batchSize;) {\n            // Cancel the streams.\n            batch[i].lockup.cancelMultiple(batch[i].streamIds);\n\n            // Increment the for loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n\n        // Transfer the balance differences to the proxy owner.\n        _postMultipleCancellations(initialBalances, assets);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function burn(ISablierV2Lockup lockup, uint256 streamId) external onlyDelegateCall {\n        lockup.burn(streamId);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function cancel(ISablierV2Lockup lockup, uint256 streamId) public onlyDelegateCall {\n        // Retrieve the asset used for streaming.\n        IERC20 asset = lockup.getAsset(streamId);\n\n        // Load the balance before the cancellation.\n        uint256 initialBalance = asset.balanceOf(address(this));\n\n        // Cancel the stream.\n        lockup.cancel(streamId);\n\n        // Calculate the difference between the final and the initial balance.\n        uint256 finalBalance = asset.balanceOf(address(this));\n        uint256 deltaBalance = finalBalance - initialBalance;\n\n        // Forward the delta to the proxy owner. This cannot be zero because settled streams cannot be canceled.\n        asset.safeTransfer({ to: _getOwner(), value: deltaBalance });\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function cancelMultiple(\n        ISablierV2Lockup lockup,\n        IERC20[] calldata assets,\n        uint256[] calldata streamIds\n    )\n        external\n        onlyDelegateCall\n    {\n        // Load the balances before the cancellations.\n        uint256[] memory initialBalances = _getBalances(assets);\n\n        // Cancel the streams.\n        lockup.cancelMultiple(streamIds);\n\n        // Transfer the balance differences to the proxy owner.\n        _postMultipleCancellations(initialBalances, assets);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function renounce(ISablierV2Lockup lockup, uint256 streamId) external onlyDelegateCall {\n        lockup.renounce(streamId);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function withdraw(\n        ISablierV2Lockup lockup,\n        uint256 streamId,\n        address to,\n        uint128 amount\n    )\n        external\n        onlyDelegateCall\n    {\n        lockup.withdraw(streamId, to, amount);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function withdrawMax(ISablierV2Lockup lockup, uint256 streamId, address to) external onlyDelegateCall {\n        lockup.withdrawMax(streamId, to);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function withdrawMaxAndTransfer(\n        ISablierV2Lockup lockup,\n        uint256 streamId,\n        address newRecipient\n    )\n        external\n        onlyDelegateCall\n    {\n        lockup.withdrawMaxAndTransfer(streamId, newRecipient);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function withdrawMultiple(\n        ISablierV2Lockup lockup,\n        uint256[] calldata streamIds,\n        address to,\n        uint128[] calldata amounts\n    )\n        external\n        onlyDelegateCall\n    {\n        lockup.withdrawMultiple(streamIds, to, amounts);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                              SABLIER-V2-LOCKUP-LINEAR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function batchCreateWithDurations(\n        ISablierV2LockupLinear lockupLinear,\n        IERC20 asset,\n        Batch.CreateWithDurations[] calldata batch,\n        bytes calldata transferData\n    )\n        external\n        override\n        onlyDelegateCall\n        returns (uint256[] memory streamIds)\n    {\n        // Check that the batch size is not zero.\n        uint256 batchSize = batch.length;\n        if (batchSize == 0) {\n            revert Errors.SablierV2ProxyTarget_BatchSizeZero();\n        }\n\n        // Calculate the sum of all of stream amounts. It is safe to use unchecked addition because one of the create\n        // transactions will revert if there is overflow.\n        uint256 i;\n        uint160 transferAmount;\n        for (i = 0; i < batchSize;) {\n            unchecked {\n                transferAmount += batch[i].totalAmount;\n                i += 1;\n            }\n        }\n\n        // Transfers the assets to the proxy and approves the Sablier contract to spend them.\n        _handleTransfer(address(lockupLinear), asset, transferAmount, transferData);\n\n        // Create a stream for each element in the parameter array.\n        streamIds = new uint256[](batchSize);\n        for (i = 0; i < batchSize;) {\n            // Create the stream.\n            streamIds[i] = lockupLinear.createWithDurations(\n                LockupLinear.CreateWithDurations({\n                    asset: asset,\n                    broker: batch[i].broker,\n                    cancelable: batch[i].cancelable,\n                    durations: batch[i].durations,\n                    recipient: batch[i].recipient,\n                    sender: batch[i].sender,\n                    totalAmount: batch[i].totalAmount,\n                    transferable: batch[i].transferable\n                })\n            );\n\n            // Increment the for loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function batchCreateWithRange(\n        ISablierV2LockupLinear lockupLinear,\n        IERC20 asset,\n        Batch.CreateWithRange[] calldata batch,\n        bytes calldata transferData\n    )\n        external\n        override\n        onlyDelegateCall\n        returns (uint256[] memory streamIds)\n    {\n        // Check that the batch is not empty.\n        uint256 batchSize = batch.length;\n        if (batchSize == 0) {\n            revert Errors.SablierV2ProxyTarget_BatchSizeZero();\n        }\n\n        // Calculate the sum of all of stream amounts. It is safe to use unchecked addition because one of the create\n        // transactions will revert if there is overflow.\n        uint256 i;\n        uint160 transferAmount;\n        for (i = 0; i < batchSize;) {\n            unchecked {\n                transferAmount += batch[i].totalAmount;\n                i += 1;\n            }\n        }\n\n        // Transfers the assets to the proxy and approve the Sablier contract to spend them.\n        _handleTransfer(address(lockupLinear), asset, transferAmount, transferData);\n\n        // Create a stream for each element in the parameter array.\n        streamIds = new uint256[](batchSize);\n        for (i = 0; i < batchSize;) {\n            // Create the stream.\n            streamIds[i] = lockupLinear.createWithRange(\n                LockupLinear.CreateWithRange({\n                    asset: asset,\n                    broker: batch[i].broker,\n                    cancelable: batch[i].cancelable,\n                    range: batch[i].range,\n                    recipient: batch[i].recipient,\n                    sender: batch[i].sender,\n                    totalAmount: batch[i].totalAmount,\n                    transferable: batch[i].transferable\n                })\n            );\n\n            // Increment the for loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function cancelAndCreateWithDurations(\n        ISablierV2Lockup lockup,\n        uint256 streamId,\n        ISablierV2LockupLinear lockupLinear,\n        LockupLinear.CreateWithDurations calldata createParams,\n        bytes calldata transferData\n    )\n        external\n        override\n        onlyDelegateCall\n        returns (uint256 newStreamId)\n    {\n        cancel(lockup, streamId);\n        newStreamId = createWithDurations(lockupLinear, createParams, transferData);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function cancelAndCreateWithRange(\n        ISablierV2Lockup lockup,\n        uint256 streamId,\n        ISablierV2LockupLinear lockupLinear,\n        LockupLinear.CreateWithRange calldata createParams,\n        bytes calldata transferData\n    )\n        external\n        override\n        onlyDelegateCall\n        returns (uint256 newStreamId)\n    {\n        cancel(lockup, streamId);\n        newStreamId = createWithRange(lockupLinear, createParams, transferData);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function createWithDurations(\n        ISablierV2LockupLinear lockupLinear,\n        LockupLinear.CreateWithDurations calldata createParams,\n        bytes calldata transferData\n    )\n        public\n        override\n        onlyDelegateCall\n        returns (uint256 streamId)\n    {\n        _handleTransfer(address(lockupLinear), createParams.asset, createParams.totalAmount, transferData);\n        streamId = lockupLinear.createWithDurations(createParams);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function createWithRange(\n        ISablierV2LockupLinear lockupLinear,\n        LockupLinear.CreateWithRange calldata createParams,\n        bytes calldata transferData\n    )\n        public\n        override\n        onlyDelegateCall\n        returns (uint256 streamId)\n    {\n        _handleTransfer(address(lockupLinear), createParams.asset, createParams.totalAmount, transferData);\n        streamId = lockupLinear.createWithRange(createParams);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function wrapAndCreateWithDurations(\n        ISablierV2LockupLinear lockupLinear,\n        LockupLinear.CreateWithDurations memory createParams\n    )\n        external\n        payable\n        override\n        onlyDelegateCall\n        returns (uint256 streamId)\n    {\n        // All production chains have a native asset with a circulating supply much smaller than 2^128.\n        createParams.totalAmount = uint128(msg.value);\n\n        // Safely wrap the native asset payment in ERC-20 form.\n        _safeWrap(createParams.asset);\n\n        // Approve the Sablier contract to spend funds.\n        _approve(address(lockupLinear), createParams.asset, createParams.totalAmount);\n\n        // Create the stream.\n        streamId = lockupLinear.createWithDurations(createParams);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function wrapAndCreateWithRange(\n        ISablierV2LockupLinear lockupLinear,\n        LockupLinear.CreateWithRange memory createParams\n    )\n        external\n        payable\n        override\n        onlyDelegateCall\n        returns (uint256 streamId)\n    {\n        // All production chains have a native asset with a circulating supply much smaller than 2^128.\n        createParams.totalAmount = uint128(msg.value);\n\n        // Safely wrap the native asset payment in ERC-20 form.\n        _safeWrap(createParams.asset);\n\n        // Approve the Sablier contract to spend funds.\n        _approve(address(lockupLinear), createParams.asset, createParams.totalAmount);\n\n        // Create the stream.\n        streamId = lockupLinear.createWithRange(createParams);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                             SABLIER-V2-LOCKUP-DYNAMIC\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function batchCreateWithDeltas(\n        ISablierV2LockupDynamic dynamic,\n        IERC20 asset,\n        Batch.CreateWithDeltas[] calldata batch,\n        bytes calldata transferData\n    )\n        external\n        override\n        onlyDelegateCall\n        returns (uint256[] memory streamIds)\n    {\n        // Check that the batch size is not zero.\n        uint256 batchSize = batch.length;\n        if (batchSize == 0) {\n            revert Errors.SablierV2ProxyTarget_BatchSizeZero();\n        }\n\n        // Calculate the sum of all of stream amounts. It is safe to use unchecked addition because one of the create\n        // transactions will revert if there is overflow.\n        uint256 i;\n        uint160 transferAmount;\n        for (i = 0; i < batchSize;) {\n            unchecked {\n                transferAmount += batch[i].totalAmount;\n                i += 1;\n            }\n        }\n\n        // Perform the ERC-20 transfer and approve {SablierV2LockupDynamic} to spend the amount of assets.\n        _handleTransfer(address(dynamic), asset, transferAmount, transferData);\n\n        // Create a stream for each element in the parameter array.\n        streamIds = new uint256[](batchSize);\n        for (i = 0; i < batchSize;) {\n            // Create the stream.\n            streamIds[i] = dynamic.createWithDeltas(\n                LockupDynamic.CreateWithDeltas({\n                    asset: asset,\n                    broker: batch[i].broker,\n                    cancelable: batch[i].cancelable,\n                    recipient: batch[i].recipient,\n                    segments: batch[i].segments,\n                    sender: batch[i].sender,\n                    totalAmount: batch[i].totalAmount,\n                    transferable: batch[i].transferable\n                })\n            );\n\n            // Increment the for loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function batchCreateWithMilestones(\n        ISablierV2LockupDynamic dynamic,\n        IERC20 asset,\n        Batch.CreateWithMilestones[] calldata batch,\n        bytes calldata transferData\n    )\n        external\n        override\n        onlyDelegateCall\n        returns (uint256[] memory streamIds)\n    {\n        // Check that the batch size is not zero.\n        uint256 batchSize = batch.length;\n        if (batchSize == 0) {\n            revert Errors.SablierV2ProxyTarget_BatchSizeZero();\n        }\n\n        // Calculate the sum of all of stream amounts. It is safe to use unchecked addition because one of the create\n        // transactions will revert if there is overflow.\n        uint256 i;\n        uint160 transferAmount;\n        for (i = 0; i < batchSize;) {\n            unchecked {\n                transferAmount += batch[i].totalAmount;\n                i += 1;\n            }\n        }\n\n        // Perform the ERC-20 transfer and approve {SablierV2LockupDynamic} to spend the amount of assets.\n        _handleTransfer(address(dynamic), asset, transferAmount, transferData);\n\n        // Create a stream for each element in the parameter array.\n        streamIds = new uint256[](batchSize);\n        for (i = 0; i < batchSize;) {\n            // Create the stream.\n            streamIds[i] = dynamic.createWithMilestones(\n                LockupDynamic.CreateWithMilestones({\n                    asset: asset,\n                    broker: batch[i].broker,\n                    cancelable: batch[i].cancelable,\n                    recipient: batch[i].recipient,\n                    segments: batch[i].segments,\n                    sender: batch[i].sender,\n                    startTime: batch[i].startTime,\n                    totalAmount: batch[i].totalAmount,\n                    transferable: batch[i].transferable\n                })\n            );\n\n            // Increment the for loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function cancelAndCreateWithDeltas(\n        ISablierV2Lockup lockup,\n        uint256 streamId,\n        ISablierV2LockupDynamic dynamic,\n        LockupDynamic.CreateWithDeltas calldata createParams,\n        bytes calldata transferData\n    )\n        external\n        override\n        onlyDelegateCall\n        returns (uint256 newStreamId)\n    {\n        cancel(lockup, streamId);\n        newStreamId = createWithDeltas(dynamic, createParams, transferData);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function cancelAndCreateWithMilestones(\n        ISablierV2Lockup lockup,\n        uint256 streamId,\n        ISablierV2LockupDynamic dynamic,\n        LockupDynamic.CreateWithMilestones calldata createParams,\n        bytes calldata transferData\n    )\n        external\n        override\n        onlyDelegateCall\n        returns (uint256 newStreamId)\n    {\n        cancel(lockup, streamId);\n        newStreamId = createWithMilestones(dynamic, createParams, transferData);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function createWithDeltas(\n        ISablierV2LockupDynamic dynamic,\n        LockupDynamic.CreateWithDeltas calldata createParams,\n        bytes calldata transferData\n    )\n        public\n        override\n        onlyDelegateCall\n        returns (uint256 streamId)\n    {\n        _handleTransfer(address(dynamic), createParams.asset, createParams.totalAmount, transferData);\n        streamId = dynamic.createWithDeltas(createParams);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function createWithMilestones(\n        ISablierV2LockupDynamic dynamic,\n        LockupDynamic.CreateWithMilestones calldata createParams,\n        bytes calldata transferData\n    )\n        public\n        override\n        onlyDelegateCall\n        returns (uint256 streamId)\n    {\n        _handleTransfer(address(dynamic), createParams.asset, createParams.totalAmount, transferData);\n        streamId = dynamic.createWithMilestones(createParams);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function wrapAndCreateWithDeltas(\n        ISablierV2LockupDynamic dynamic,\n        LockupDynamic.CreateWithDeltas memory createParams\n    )\n        external\n        payable\n        override\n        onlyDelegateCall\n        returns (uint256 streamId)\n    {\n        // All production chains have a native asset with a circulating supply much smaller than 2^128.\n        createParams.totalAmount = uint128(msg.value);\n\n        // Safely wrap the native asset payment in ERC-20 form.\n        _safeWrap(createParams.asset);\n\n        // Approve the Sablier contract to spend funds.\n        _approve(address(dynamic), createParams.asset, createParams.totalAmount);\n\n        // Create the stream.\n        streamId = dynamic.createWithDeltas(createParams);\n    }\n\n    /// @inheritdoc ISablierV2ProxyTarget\n    function wrapAndCreateWithMilestones(\n        ISablierV2LockupDynamic dynamic,\n        LockupDynamic.CreateWithMilestones memory createParams\n    )\n        external\n        payable\n        override\n        onlyDelegateCall\n        returns (uint256 streamId)\n    {\n        // All production chains have a native asset with a circulating supply much smaller than 2^128.\n        createParams.totalAmount = uint128(msg.value);\n\n        // Safely wrap the native asset payment in ERC-20 form.\n        _safeWrap(createParams.asset);\n\n        // Approve the Sablier contract to spend funds.\n        _approve(address(dynamic), createParams.asset, createParams.totalAmount);\n\n        // Create the stream.\n        streamId = dynamic.createWithMilestones(createParams);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  HELPER FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Helper function to approve a Sablier contract to spend funds from the proxy. If the current allowance\n    /// is insufficient, this function approves Sablier to spend the exact `amount`.\n    /// The {SafeERC20.forceApprove} function is used to handle special ERC-20 assets (e.g. USDT) that require the\n    /// current allowance to be zero before setting it to a non-zero value.\n    function _approve(address sablierContract, IERC20 asset, uint256 amount) internal {\n        uint256 allowance = asset.allowance({ owner: address(this), spender: sablierContract });\n        if (allowance < amount) {\n            asset.forceApprove({ spender: sablierContract, value: amount });\n        }\n    }\n\n    /// @dev Helper function to retrieve the proxy's balance for the provided assets.\n    function _getBalances(IERC20[] calldata assets) internal view returns (uint256[] memory initialBalances) {\n        uint256 assetCount = assets.length;\n        initialBalances = new uint256[](assetCount);\n        for (uint256 i = 0; i < assetCount;) {\n            initialBalances[i] = assets[i].balanceOf(address(this));\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /// @dev Helper function to retrieve the proxy's owner, which is stored as an immutable variable in the proxy.\n    function _getOwner() internal view returns (address) {\n        return IPRBProxy(address(this)).owner();\n    }\n\n    /// @dev Handler function meant to be inherited by child contracts that implement the transfer logic. This function\n    /// may also approve the Sablier contract to spend to spend funds from the proxy if the allowance is insufficient.\n    function _handleTransfer(\n        address sablierContract,\n        IERC20 asset,\n        uint160 amount,\n        bytes calldata transferData\n    )\n        internal\n        virtual;\n\n    /// @dev Shared logic between {cancelMultiple} and {batchCancelMultiple}.\n    function _postMultipleCancellations(uint256[] memory initialBalances, IERC20[] calldata assets) internal {\n        uint256 assetCount = assets.length;\n        uint256 finalBalance;\n        uint256 deltaBalance;\n        for (uint256 i = 0; i < assetCount;) {\n            // Calculate the difference between the final and initial balances.\n            finalBalance = assets[i].balanceOf(address(this));\n            deltaBalance = finalBalance - initialBalances[i];\n\n            // Forward the delta to the proxy owner. This cannot be zero because settled streams cannot be canceled.\n            assets[i].safeTransfer({ to: _getOwner(), value: deltaBalance });\n\n            // Increment the for loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /// @dev Safely wraps the native asset payment in ERC-20 form, checking that the credit amount is greater than or\n    /// equal to `msg.value`.\n    function _safeWrap(IERC20 asset) internal {\n        // Load the balance before the wrap.\n        uint256 initialBalance = asset.balanceOf(address(this));\n\n        // Wrap the native asset payment in ERC-20 form.\n        IWrappedNativeAsset(address(asset)).deposit{ value: msg.value }();\n\n        // Calculate the credit amount.\n        uint256 finalBalance = asset.balanceOf(address(this));\n        uint256 creditAmount = finalBalance - initialBalance;\n\n        // Check that the credit amount is equal to `msg.value`.\n        if (creditAmount != msg.value) {\n            revert Errors.SablierV2ProxyTarget_CreditAmountMismatch({ msgValue: msg.value, creditAmount: creditAmount });\n        }\n    }\n}"
    },
    {
      "filename": "telcoin-audit/contracts/sablier/core/CouncilMember.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"../interfaces/ISablierV2ProxyTarget.sol\";\nimport \"../interfaces/IPRBProxy.sol\";\n\n/**\n * @title CouncilMember\n * @author Amir M. Shirif\n * @notice A Telcoin Laboratories Contract\n * @notice A contract to signify ownership council membership\n * @dev Relies on OpenZeppelin's open source smart contracts\n */\ncontract CouncilMember is\n    ERC721EnumerableUpgradeable,\n    AccessControlEnumerableUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    /* ========== EVENTS ========== */\n    // Event fired when the stream is updated\n    event StreamUpdated(IPRBProxy newStream);\n    // Event fired when the target address is updated\n    event TargetUpdated(address newTarget);\n    // Event fired when the ID is updated\n    event IDUpdated(uint256 newID);\n\n    /* ========== STATE VARIABLES ========== */\n    // The main token of this ecosystem\n    IERC20 public TELCOIN;\n    // Stream proxy address for this contract\n    IPRBProxy public _stream;\n    // here is the implentation address\n    address public _target;\n    // the id associated with the sablier NFT\n    uint256 public _id;\n    // balance left over from last rebalancing\n    uint256 private runningBalance;\n    // current uncliamed members balances\n    uint256[] public balances;\n    // Mapping of who can send each NFT index\n    mapping(uint256 => address) private _tokenApproval;\n\n    /* ========== ROLES ========== */\n    // Role assigned for the governance council\n    bytes32 public constant GOVERNANCE_COUNCIL_ROLE =\n        keccak256(\"GOVERNANCE_COUNCIL_ROLE\");\n    // Support role for additional functionality\n    bytes32 public constant SUPPORT_ROLE = keccak256(\"SUPPORT_ROLE\");\n\n    /* ========== INITIALIZER ========== */\n    function initialize(\n        IERC20 telcoin,\n        string memory name_,\n        string memory symbol_,\n        IPRBProxy stream_,\n        address target_,\n        uint256 id_\n    ) external initializer {\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        __ERC721_init(name_, symbol_);\n        TELCOIN = telcoin;\n        _stream = stream_;\n        _target = target_;\n        _id = id_;\n    }\n\n    /************************************************\n     *   external functions\n     ************************************************/\n\n    /**\n     * @notice Allows authorized personnel to retrieve and distribute TELCOIN to council members\n     * @dev The main logic behind the TELCOIN distribution is encapsulated in this function.\n     * @dev This function should be called before any significant state changes to ensure accurate distribution.\n     * @dev Only the owner council members can call this function\n     */\n    function retrieve() external OnlyAuthorized {\n        _retrieve();\n    }\n\n    /**\n     * @notice Allows council members to claim their allocated amounts of TELCOIN\n     * @dev Checks if the caller is the owner of the provided tokenId and if the requested amount is available.\n     * @param tokenId The NFT index associated with a council member.\n     * @param amount Amount of TELCOIN the council member wants to withdraw.\n     */\n    function claim(uint256 tokenId, uint256 amount) external {\n        // Ensure the function caller is the owner of the token (council member) they're trying to claim for\n        require(\n            _msgSender() == ownerOf(tokenId),\n            \"CouncilMember: caller is not council member holding this NFT index\"\n        );\n        // Retrieve and distribute any pending TELCOIN for all council members\n        _retrieve();\n\n        // Ensure the requested amount doesn't exceed the balance of the council member\n        require(\n            amount <= balances[tokenId],\n            \"CouncilMember: withdrawal amount is higher than balance\"\n        );\n\n        // Deduct the claimed amount from the token's balance\n        balances[tokenId] -= amount;\n        // Safely transfer the claimed amount of TELCOIN to the function caller\n        TELCOIN.safeTransfer(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Replace an existing council member with a new one and withdraws the old member's TELCOIN allocation\n     * @dev This function is restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @dev Allows TEL reward to be sent to a different address\n     * @param from Address of the current council member to be replaced.\n     * @param to Address of the new council member.\n     * @param tokenId Token ID of the council member NFT.\n     * @param rewardRecipient Address where the old member's TELCOIN will be sent.\n     */\n    function removeFromOffice(\n        address from,\n        address to,\n        uint256 tokenId,\n        address rewardRecipient\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        // Retrieve and distribute any pending TELCOIN for all council members\n        _retrieve();\n        // Withdraw all the TELCOIN rewards for the specified token to the rewardRecipient\n        _withdrawAll(rewardRecipient, tokenId);\n        // Transfer the token (representing the council membership) from one address to another\n        _transfer(from, to, tokenId);\n    }\n\n    /************************************************\n     *   view functions\n     ************************************************/\n\n    /**\n     * @notice Check if the contract supports a specific interface\n     * @dev Overrides the supportsInterface function from OpenZeppelin.\n     * @param interfaceId ID of the interface to check for support.\n     * @return True if the contract supports the interface, false otherwise.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        pure\n        override(\n            AccessControlEnumerableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return\n            interfaceId ==\n            type(AccessControlEnumerableUpgradeable).interfaceId ||\n            interfaceId == type(ERC721EnumerableUpgradeable).interfaceId;\n    }\n\n    /************************************************\n     *   mutative functions\n     ************************************************/\n\n    /**\n     * @notice Mint new council member NFTs\n     * @dev This function also retrieves and distributes TELCOIN.\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param newMember Address of the new council member.\n     */\n    function mint(\n        address newMember\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        if (totalSupply() != 0) {\n            _retrieve();\n        }\n\n        balances.push(0);\n        _mint(newMember, totalSupply());\n    }\n\n    /**\n     * @notice Approve a specific address for a specific NFT\n     * @dev Overrides the appro"
    }
  ]
}