{
  "Title": "[M-01] Contract Owner Possesses Too Many Privileges",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-10-blur/blob/2fdaa6e13b544c8c11d1c022a575f16c3a72e3bf/contracts/ExecutionDelegate.sol#L119\n\n\n# Vulnerability details\n\n### Protocol can be easily rug-pulled by the owner\nTo use the protocol (buy/sell NFTs), users must approve the `ExecutionDelegate` to handle transfers for their `ERC721`, `ERC1155`, or `ERC20` tokens. \n\nThe safety mechanisms mentioned by the protocol do not protect users at all if the project's owner decides to rugpull.\n\nFrom the contest page, Safety Features:\n-   The calling contract must be approved on the `ExecutionDelegate`\n-   Users have the ability to revoke approval from the `ExecutionDelegate` without having to individually calling every token contract.\n\n#### POC\n```sol\nfunction transferERC20(address token, address from, address to, uint256 amount)\n        approvedContract\n        external\n        returns (bool)\n    {\n        require(revokedApproval[from] == false, \"User has revoked approval\");\n        return IERC20(token).transferFrom(from, to, amount);\n    }\n```\nThe owner can set `approvedContract`  to any address at any time with `approveContract(address _contract)`, and `revokeApproval()` can be frontrun. As a result, all user funds approved to the `ExecutionDelegate` contract can be lost via rugpull.\n\n#### Justification\nWhile rug-pulling may not be the project's intention, I find that this is still an inherently dangerous design.\n\nI am unsure about the validity of centralization risk findings on C4, but I argue this is a valid High risk issue as:\n- It is too easy to steal all of user funds as a project owner. A single Bored Ape NFT traded on the exchange would mean roughly \\$200,000 can be stolen based on current floor price (75.6 ETH as of writing, Source: https://nftpricefloor.com/bored-ape-yacht-club). \\$200k because 75.6ETH for NFT seller and at least 75.6ETH approved by buyer.\n- web3 security should not be based on \"trust\".\n- Assuming the project owner is not malicious and will never rug-pull:\n\t- 1 successful phishing attack (private key compromise) against the project's owner is all it takes to wipe the protocol out.\n\t- the protocol is still affected as user's will not want to trade on a platfrom knowing such an attack is possible.\n\n#### Recommendations\nThis is due to an insecure design of the protocol. So as far as recommendations go, the team should reconsider the protocol's design. \n\nI do not think `ExecutionDelegate` should be used. It would be better if `BlurExchange.sol` is approved by users instead. The exchange should require that the buyer has received their NFT and the seller has received their ETH/WETH or revert.\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-blur-exchange-contest",
  "Code": [
    {
      "filename": "contracts/ExecutionDelegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IExecutionDelegate} from \"./interfaces/IExecutionDelegate.sol\";\n\n/**\n * @title ExecutionDelegate\n * @dev Proxy contract to manage user token approvals\n */\ncontract ExecutionDelegate is IExecutionDelegate, Ownable {\n\n    mapping(address => bool) public contracts;\n    mapping(address => bool) public revokedApproval;\n\n    modifier approvedContract() {\n        require(contracts[msg.sender], \"Contract is not approved to make transfers\");\n        _;\n    }\n\n    event ApproveContract(address indexed _contract);\n    event DenyContract(address indexed _contract);\n\n    event RevokeApproval(address indexed user);\n    event GrantApproval(address indexed user);\n\n    /**\n     * @dev Approve contract to call transfer functions\n     * @param _contract address of contract to approve\n     */\n    function approveContract(address _contract) onlyOwner external {\n        contracts[_contract] = true;\n        emit ApproveContract(_contract);\n    }\n\n    /**\n     * @dev Revoke approval of contract to call transfer functions\n     * @param _contract address of contract to revoke approval\n     */\n    function denyContract(address _contract) onlyOwner external {\n        contracts[_contract] = false;\n        emit DenyContract(_contract);\n    }\n\n    /**\n     * @dev Block contract from making transfers on-behalf of a specific user\n     */\n    function revokeApproval() external {\n        revokedApproval[msg.sender] = true;\n        emit RevokeApproval(msg.sender);\n    }\n\n    /**\n     * @dev Allow contract to make transfers on-behalf of a specific user\n     */\n    function grantApproval() external {\n        revokedApproval[msg.sender] = false;\n        emit GrantApproval(msg.sender);\n    }\n\n    /**\n     * @dev Transfer ERC721 token using `transferFrom`\n     * @param collection address of the collection\n     * @param from address of the sender\n     * @param to address of the recipient\n     * @param tokenId tokenId\n     */\n    function transferERC721Unsafe(address collection, address from, address to, uint256 tokenId)\n        approvedContract\n        external\n    {\n        require(revokedApproval[from] == false, \"User has revoked approval\");\n        IERC721(collection).transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Transfer ERC721 token using `safeTransferFrom`\n     * @param collection address of the collection\n     * @param from address of the sender\n     * @param to address of the recipient\n     * @param tokenId tokenId\n     */\n    function transferERC721(address collection, address from, address to, uint256 tokenId)\n        approvedContract\n        external\n    {\n        require(revokedApproval[from] == false, \"User has revoked approval\");\n        IERC721(collection).safeTransferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Transfer ERC1155 token using `safeTransferFrom`\n     * @param collection address of the collection\n     * @param from address of the sender\n     * @param to address of the recipient\n     * @param tokenId tokenId\n     * @param amount amount\n     */\n    function transferERC1155(address collection, address from, address to, uint256 tokenId, uint256 amount)\n        approvedContract\n        external\n    {\n        require(revokedApproval[from] == false, \"User has revoked approval\");\n        IERC1155(collection).safeTransferFrom(from, to, tokenId, amount, \"\");\n    }\n\n    /**\n     * @dev Transfer ERC20 token\n     * @param token address of the token\n     * @param from address of the sender\n     * @param to address of the recipient\n     * @param amount amount\n     */\n    function transferERC20(address token, address from, address to, uint256 amount)\n        approvedContract\n        external\n        returns (bool)\n    {\n        require(revokedApproval[from] == false, \"User has revoked approval\");\n        return IERC20(token).transferFrom(from, to, amount);\n    }\n}"
    }
  ]
}