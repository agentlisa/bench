{
  "Title": "[M02] List of markets can endlessly grow",
  "Content": "In the [`HoldefiSettings` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol), the [`addMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L176) is used to introduce new markets to the system by adding them into the [`marketsAssets` mapping](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L63) and in the [`marketsList` array](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L64).\n\n\nGiven that the owner of the contract can add markets without any limit, and given that the [`removeMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L205) does not remove markets properly, as it was pointed out in the issue *“[H02] Markets are not being properly removed from the markets list”*, the `marketsList` array can grow endlessly. Then, when the array is iterated through, it would cause an out of gas error, as the loop would be too large to be handled in a single transaction. This would happen in the following scenarios:\n\n\n* When adding a new market, [as the `marketsList` array is iterated](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L190-L195)  to check whether a market already exists, preventing the market to be added\n* When [`clearing debts`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L410-L425) in the [`Holdefi` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol), preventing a borrower’s collateral to be liquidated.\n\n\nConsider limiting the size of the `marketsList` array to prevent out of gas errors. In addition to this, when removing a market using the `removeMarket` function, consider not only deactivating it in the `marketsAssets` struct, but also removing it from the `marketsList` array.\n\n\n**Update**: *Not fixed. Holdefi’s statement for this issue:*\n\n\n\n> We explained it in H02. Your suggestion to remove the market from marketsList not only can’t solve the issue but also will damage the platform.\n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/HoldefiSettings.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\n\r\ninterface HoldefiInterface {\r\n\r\n\tfunction updateSupplyIndex(address market) external;\r\n\r\n\tfunction updateBorrowIndex(address market) external;\r\n\r\n\tfunction updatePromotionReserve(address market) external;\r\n}\r\n\r\n// All these settings is callable by only owner\r\ncontract HoldefiSettings is Ownable {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint constant public ratesDecimal = 10 ** 4;\r\n\r\n\tuint constant public secondsPerTenDays = 864000;\r\n\r\n\tuint constant public maxBorrowRate = 4000;\t\t\t\t  //40%\r\n\r\n\tuint constant public borrowRateMaxIncrease = 500;\t\t  //5%\r\n\r\n\tuint constant public minSuppliersShareRate = 5000;\t\t  //50%\r\n\r\n\tuint constant public suppliersShareRateMaxDecrease = 500; //5%\r\n\r\n\tuint constant public maxValueToLoanRate = 20000; \t\t  //200%\r\n\r\n\tuint constant public valueToLoanRateMaxIncrease = 500;\t  //5%\r\n\r\n\tuint constant public maxPenaltyRate = 13000; \t\t\t  //130%\r\n\r\n\tuint constant public penaltyRateMaxIncrease = 500; \t\t  //5%\r\n\r\n\t// Markets Features \r\n\tstruct Market {\r\n\t\tbool isActive;\r\n\r\n\t\tuint borrowRate;\r\n\t\tuint borrowRateUpdateTime;\r\n\r\n\t\tuint suppliersShareRate;\r\n\t\tuint suppliersShareRateUpdateTime;\t\r\n\t}\r\n\r\n\t// Collaterals Features\r\n\tstruct Collateral {\r\n\t\tbool isActive;\r\n\t\tuint valueToLoanRate;   // Collateral liquidation threshold\r\n\t\tuint VTLUpdateTime;\r\n\t\tuint penaltyRate; \t\t// Portion of collateral being liquidated during liquidation\r\n\t\tuint penaltyUpdateTime;\r\n\t\tuint bonusRate;\t\t    // Bonus for buyers who buy liquidated collaterals\r\n\t}\r\n\r\n\t// Asset address => Market features \r\n\tmapping (address => Market) public marketAssets;\r\n\taddress[] public marketsList;\r\n\r\n\t// Asset address => Collateral features\r\n\tmapping (address => Collateral) public collateralAssets;\r\n\r\n\tHoldefiInterface public holdefiContract;\r\n\r\n\tevent BorrowRateChanged(address market, uint newRate);\r\n\r\n\tevent SuppliersShareRateChanged(address market, uint newRate);\r\n\r\n\tevent MarketAdded(address market);\r\n\r\n\tevent MarketRemoved(address market);\r\n\r\n\tevent CollateralAdded(address collateral, uint valueToLoanRate, uint penaltyRate, uint bonusRate);\r\n\r\n\tevent CollateralRemoved(address collateral);\r\n\r\n\tevent ValueToLoanRateChanged(address collateral, uint newRate);\r\n\r\n\tevent PenaltyRateChanged(address collateral, uint newRate);\r\n\r\n\tevent BonusRateChanged(address collateral, uint newRate);\r\n\t\r\n\tconstructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\r\n\t}\r\n\r\n\t// Disposable function to Get in touch with Holdefi contract\r\n\tfunction setHoldefiContract(HoldefiInterface holdefiContractAddress) external onlyOwner {\r\n\t\trequire (address(holdefiContract) == address(0),'Should be set once');\r\n\t\tholdefiContract = holdefiContractAddress;\r\n\t}\r\n\r\n\t// Returns supply rate and borrow rate \r\n\t// supply rate = ((total borrow * Borrow rate * suppliers share rate) / total supply\r\n\tfunction getInterests (address market, uint totalSupply, uint totalBorrow) external view returns(uint borrowRate, uint supplyRate) {\r\n\t\tborrowRate = marketAssets[market].borrowRate;\r\n\t\tuint suppliersShareRate = marketAssets[market].suppliersShareRate;\r\n\t\tif (totalSupply == 0){\r\n\t\t\tsupplyRate = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint totalInterestFromBorrow = totalBorrow.mul(borrowRate);\r\n\t\t\tuint suppliersShare = totalInterestFromBorrow.mul(suppliersShareRate);\r\n\t\t\tsuppliersShare = suppliersShare.div(ratesDecimal);\r\n\t\t\tsupplyRate = suppliersShare.div(totalSupply);\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns list of all markets\r\n\tfunction getMarketsList() external view returns (address[] memory res){\r\n\t\tres = marketsList;\r\n\t}\r\n\r\n\t// Returns true if an asset is in the market list\r\n\tfunction getMarket(address market) external view returns (bool active){\r\n\t\tactive = marketAssets[market].isActive;\r\n\t}\r\n\r\n\t// Returns the features of a collateral (Is active- VTL rate- Penalty rate- Bonus rate)\r\n\tfunction getCollateral(address collateral) external view returns (bool, uint, uint, uint){\r\n\t\treturn(\r\n\t\t\tcollateralAssets[collateral].isActive,\r\n\t\t\tcollateralAssets[collateral].valueToLoanRate,\r\n\t\t\tcollateralAssets[collateral].penaltyRate,\r\n\t\t\tcollateralAssets[collateral].bonusRate\t\t\r\n\t\t\t);\r\n\t}\r\n\t\r\n\t// Owner can set a new borrow rate\r\n\tfunction setBorrowRate (address market, uint newBorrowRate) external onlyOwner {\r\n\t\trequire (newBorrowRate <= maxBorrowRate,'Rate should be less than max');\r\n\t\tuint currentTime = block.timestamp;\r\n\r\n\t\tif (newBorrowRate > marketAssets[market].borrowRate){\r\n\t\t\tuint deltaTime = currentTime.sub(marketAssets[market].borrowRateUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = marketAssets[market].borrowRate.add(borrowRateMaxIncrease);\r\n\t\t\trequire (newBorrowRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\r\n\t\tholdefiContract.updateBorrowIndex(market);\r\n\t\tholdefiContract.updateSupplyIndex(market);\r\n\t\tholdefiContract.updatePromotionReserve(market);\r\n\t\tmarketAssets[market].borrowRate = newBorrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = currentTime;\r\n\r\n\t\temit BorrowRateChanged(market, newBorrowRate);\r\n\t}\r\n\r\n\t// Owner can set a new 'suppliers share rate' (Supplier's share of borrower's interest).\r\n\tfunction setSuppliersShareRate (address market, uint newSuppliersShareRate) external onlyOwner {\r\n\t\trequire (newSuppliersShareRate >= minSuppliersShareRate && newSuppliersShareRate <= ratesDecimal,'Rate should be in allowed range');\r\n\t\tuint currentTime = block.timestamp;\r\n\r\n\t\tif (newSuppliersShareRate < marketAssets[market].suppliersShareRate) {\r\n\t\t\tuint deltaTime = currentTime.sub(marketAssets[market].suppliersShareRateUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Decreasing rate is not allowed at this time');\r\n\t\t\tuint maxDecrease = marketAssets[market].suppliersShareRate.sub(suppliersShareRateMaxDecrease);\r\n\t\t\trequire (newSuppliersShareRate >= maxDecrease,'Rate should be decreased less than max allowed');\r\n\t\t}\r\n\r\n\t\tholdefiContract.updateSupplyIndex(market);\r\n\t\tholdefiContract.updatePromotionReserve(market);\r\n\t\tmarketAssets[market].suppliersShareRate = newSuppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = currentTime;\r\n\r\n\t\temit SuppliersShareRateChanged(market, newSuppliersShareRate);\r\n\t}\r\n\r\n\t// Owner can add a new asset as a market.\r\n\tfunction addMarket (address market, uint borrowRate, uint suppliersShareRate) external onlyOwner {\r\n\t\trequire(!marketAssets[market].isActive, \"Market exists\");\r\n\t\trequire (borrowRate <= maxBorrowRate\r\n\t\t\t&& suppliersShareRate >= minSuppliersShareRate\r\n\t\t\t&& suppliersShareRate <= ratesDecimal\r\n\t\t\t, 'Rate should be in allowed range');\r\n\t\t\r\n\t\tmarketAssets[market].isActive = true;\r\n\t\tmarketAssets[market].borrowRate = borrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = block.timestamp;\r\n\t\tmarketAssets[market].suppliersShareRate = suppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = block.timestamp;\r\n\t\r\n\t\tbool exist = false;\r\n\t\tfor (uint i=0; i<marketsList.length; i++) {\r\n\t\t\tif (marketsList[i] == market){\r\n\t\t\t\texist = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!exist) {\r\n\t\t\tmarketsList.push(market);\r\n\t\t}\r\n\r\n\t\temit MarketAdded(market);\r\n\t}\r\n\r\n\t// Owner can remove a market asset\r\n\tfunction removeMarket (address market) external onlyOwner {\t\t\r\n\t\tmarketAssets[market].isActive = false;\r\n\t\temit MarketRemoved(market);\r\n\t}\r\n\r\n\t// Owner can add a collateral asset with its VTL, penalty and bonus rate\r\n\tfunction addCollateral (address collateralAsset, uint valueToLoanRate, uint penaltyRate, uint bonusRate) external onlyOwner {\r\n\t\trequire(!collateralAssets[collateralAsset].isActive, \"Collateral exists\");\t\t\r\n\t\trequire (valueToLoanRate <= maxValueToLoanRate\r\n\t\t\t\t&& penaltyRate <= maxPenaltyRate\r\n\t\t\t\t&& penaltyRate <= valueToLoanRate\r\n\t\t\t\t&& bonusRate <= penaltyRate\r\n\t\t\t\t&& bonusRate >= ratesDecimal\r\n\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t\tcollateralAssets[collateralAsset].isActive = true;\r\n\t\tcollateralAssets[collateralAsset].valueToLoanRate = valueToLoanRate;\r\n\t\tcollateralAssets[collateralAsset].penaltyRate  = penaltyRate;\r\n\t    collateralAssets[collateralAsset].bonusRate = bonusRate;\r\n\t    collateralAssets[collateralAsset].VTLUpdateTime = block.timestamp;\r\n\t    collateralAssets[collateralAsset].penaltyUpdateTime = block.timestamp;\r\n\t    \t\r\n\t\temit CollateralAdded(collateralAsset, valueToLoanRate, penaltyRate, bonusRate);\r\n\t}\r\n\r\n\t// Owner can remove a collateral asset\r\n\tfunction removeCollateral (address collateralAsset) external onlyOwner {\r\n\t\tcollateralAssets[collateralAsset].isActive = false;\r\n\t\temit CollateralRemoved(collateralAsset);\r\n\t}\r\n\t\r\n\t// Owner can set a new VTL rate (Liquidation threshold) for each collateral asset\r\n\tfunction setValueToLoanRate (address collateralAsset, uint newValueToLoanRate) external onlyOwner {\r\n\t\trequire (newValueToLoanRate <= maxValueToLoanRate\r\n\t\t\t\t&& collateralAssets[collateralAsset].penaltyRate <= newValueToLoanRate\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t\tuint currentTime = block.timestamp;\r\n\t\tif (newValueToLoanRate > collateralAssets[collateralAsset].valueToLoanRate) {\r\n\t\t\tuint deltaTime = currentTime.sub(collateralAssets[collateralAsset].VTLUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = collateralAssets[collateralAsset].valueToLoanRate.add(valueToLoanRateMaxIncrease);\r\n\t\t\trequire (newValueToLoanRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\t    collateralAssets[collateralAsset].valueToLoanRate = newValueToLoanRate;\r\n\t    collateralAssets[collateralAsset].VTLUpdateTime = currentTime;\r\n\r\n\t    emit ValueToLoanRateChanged(collateralAsset, newValueToLoanRate);\r\n\t}\r\n\r\n\t// Owner can set penalty rate for each collateral asset\r\n\tfunction setPenaltyRate (address collateralAsset ,uint newPenaltyRate) external onlyOwner {\r\n\t\trequire (newPenaltyRate <= maxPenaltyRate\r\n\t\t\t\t&& newPenaltyRate <= collateralAssets[collateralAsset].valueToLoanRate\r\n\t\t\t\t&& collateralAssets[collateralAsset].bonusRate <= newPenaltyRate\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\r\n\t\tuint currentTime = block.timestamp;\r\n\t\tif (newPenaltyRate > collateralAssets[collateralAsset].penaltyRate){\r\n\t\t\tuint deltaTime = currentTime.sub(collateralAssets[collateralAsset].penaltyUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = collateralAssets[collateralAsset].penaltyRate.add(penaltyRateMaxIncrease);\r\n\t\t\trequire (newPenaltyRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\t    collateralAssets[collateralAsset].penaltyRate  = newPenaltyRate;\r\n\t    collateralAssets[collateralAsset].penaltyUpdateTime = currentTime;\r\n\r\n\t    emit PenaltyRateChanged(collateralAsset, newPenaltyRate);\r\n\t}\r\n\r\n\t// Owner can set bonus rate for each collateral asset\r\n\tfunction setBonusRate (address collateralAsset, uint newBonusRate) external onlyOwner {\r\n\t\trequire (newBonusRate <= collateralAssets[collateralAsset].penaltyRate\r\n\t\t\t\t&& newBonusRate >= ratesDecimal\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t    collateralAssets[collateralAsset].bonusRate = newBonusRate;\r\n\r\n\t    emit BonusRateChanged(collateralAsset, newBonusRate);\r\n\t}\r\n\r\n\tfunction() payable external {\r\n        revert();\r\n    }\r\n}"
    },
    {
      "filename": "contracts/HoldefiSettings.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\n\r\ninterface HoldefiInterface {\r\n\r\n\tfunction updateSupplyIndex(address market) external;\r\n\r\n\tfunction updateBorrowIndex(address market) external;\r\n\r\n\tfunction updatePromotionReserve(address market) external;\r\n}\r\n\r\n// All these settings is callable by only owner\r\ncontract HoldefiSettings is Ownable {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint constant public ratesDecimal = 10 ** 4;\r\n\r\n\tuint constant public secondsPerTenDays = 864000;\r\n\r\n\tuint constant public maxBorrowRate = 4000;\t\t\t\t  //40%\r\n\r\n\tuint constant public borrowRateMaxIncrease = 500;\t\t  //5%\r\n\r\n\tuint constant public minSuppliersShareRate = 5000;\t\t  //50%\r\n\r\n\tuint constant public suppliersShareRateMaxDecrease = 500; //5%\r\n\r\n\tuint constant public maxValueToLoanRate = 20000; \t\t  //200%\r\n\r\n\tuint constant public valueToLoanRateMaxIncrease = 500;\t  //5%\r\n\r\n\tuint constant public maxPenaltyRate = 13000; \t\t\t  //130%\r\n\r\n\tuint constant public penaltyRateMaxIncrease = 500; \t\t  //5%\r\n\r\n\t// Markets Features \r\n\tstruct Market {\r\n\t\tbool isActive;\r\n\r\n\t\tuint borrowRate;\r\n\t\tuint borrowRateUpdateTime;\r\n\r\n\t\tuint suppliersShareRate;\r\n\t\tuint suppliersShareRateUpdateTime;\t\r\n\t}\r\n\r\n\t// Collaterals Features\r\n\tstruct Collateral {\r\n\t\tbool isActive;\r\n\t\tuint valueToLoanRate;   // Collateral liquidation threshold\r\n\t\tuint VTLUpdateTime;\r\n\t\tuint penaltyRate; \t\t// Portion of collateral being liquidated during liquidation\r\n\t\tuint penaltyUpdateTime;\r\n\t\tuint bonusRate;\t\t    // Bonus for buyers who buy liquidated collaterals\r\n\t}\r\n\r\n\t// Asset address => Market features \r\n\tmapping (address => Market) public marketAssets;\r\n\taddress[] public marketsList;\r\n\r\n\t// Asset address => Collateral features\r\n\tmapping (address => Collateral) public collateralAssets;\r\n\r\n\tHoldefiInterface public holdefiContract;\r\n\r\n\tevent BorrowRateChanged(address market, uint newRate);\r\n\r\n\tevent SuppliersShareRateChanged(address market, uint newRate);\r\n\r\n\tevent MarketAdded(address market);\r\n\r\n\tevent MarketRemoved(address market);\r\n\r\n\tevent CollateralAdded(address collateral, uint valueToLoanRate, uint penaltyRate, uint bonusRate);\r\n\r\n\tevent CollateralRemoved(address collateral);\r\n\r\n\tevent ValueToLoanRateChanged(address collateral, uint newRate);\r\n\r\n\tevent PenaltyRateChanged(address collateral, uint newRate);\r\n\r\n\tevent BonusRateChanged(address collateral, uint newRate);\r\n\t\r\n\tconstructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\r\n\t}\r\n\r\n\t// Disposable function to Get in touch with Holdefi contract\r\n\tfunction setHoldefiContract(HoldefiInterface holdefiContractAddress) external onlyOwner {\r\n\t\trequire (address(holdefiContract) == address(0),'Should be set once');\r\n\t\tholdefiContract = holdefiContractAddress;\r\n\t}\r\n\r\n\t// Returns supply rate and borrow rate \r\n\t// supply rate = ((total borrow * Borrow rate * suppliers share rate) / total supply\r\n\tfunction getInterests (address market, uint totalSupply, uint totalBorrow) external view returns(uint borrowRate, uint supplyRate) {\r\n\t\tborrowRate = marketAssets[market].borrowRate;\r\n\t\tuint suppliersShareRate = marketAssets[market].suppliersShareRate;\r\n\t\tif (totalSupply == 0){\r\n\t\t\tsupplyRate = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint totalInterestFromBorrow = totalBorrow.mul(borrowRate);\r\n\t\t\tuint suppliersShare = totalInterestFromBorrow.mul(suppliersShareRate);\r\n\t\t\tsuppliersShare = suppliersShare.div(ratesDecimal);\r\n\t\t\tsupplyRate = suppliersShare.div(totalSupply);\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns list of all markets\r\n\tfunction getMarketsList() external view returns (address[] memory res){\r\n\t\tres = marketsList;\r\n\t}\r\n\r\n\t// Returns true if an asset is in the market list\r\n\tfunction getMarket(address market) external view returns (bool active){\r\n\t\tactive = marketAssets[market].isActive;\r\n\t}\r\n\r\n\t// Returns the features of a collateral (Is active- VTL rate- Penalty rate- Bonus rate)\r\n\tfunction getCollateral(address collateral) external view returns (bool, uint, uint, uint){\r\n\t\treturn(\r\n\t\t\tcollateralAssets[collateral].isActive,\r\n\t\t\tcollateralAssets[collateral].valueToLoanRate,\r\n\t\t\tcollateralAssets[collateral].penaltyRate,\r\n\t\t\tcollateralAssets[collateral].bonusRate\t\t\r\n\t\t\t);\r\n\t}\r\n\t\r\n\t// Owner can set a new borrow rate\r\n\tfunction setBorrowRate (address market, uint newBorrowRate) external onlyOwner {\r\n\t\trequire (newBorrowRate <= maxBorrowRate,'Rate should be less than max');\r\n\t\tuint currentTime = block.timestamp;\r\n\r\n\t\tif (newBorrowRate > marketAssets[market].borrowRate){\r\n\t\t\tuint deltaTime = currentTime.sub(marketAssets[market].borrowRateUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = marketAssets[market].borrowRate.add(borrowRateMaxIncrease);\r\n\t\t\trequire (newBorrowRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\r\n\t\tholdefiContract.updateBorrowIndex(market);\r\n\t\tholdefiContract.updateSupplyIndex(market);\r\n\t\tholdefiContract.updatePromotionReserve(market);\r\n\t\tmarketAssets[market].borrowRate = newBorrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = currentTime;\r\n\r\n\t\temit BorrowRateChanged(market, newBorrowRate);\r\n\t}\r\n\r\n\t// Owner can set a new 'suppliers share rate' (Supplier's share of borrower's interest).\r\n\tfunction setSuppliersShareRate (address market, uint newSuppliersShareRate) external onlyOwner {\r\n\t\trequire (newSuppliersShareRate >= minSuppliersShareRate && newSuppliersShareRate <= ratesDecimal,'Rate should be in allowed range');\r\n\t\tuint currentTime = block.timestamp;\r\n\r\n\t\tif (newSuppliersShareRate < marketAssets[market].suppliersShareRate) {\r\n\t\t\tuint deltaTime = currentTime.sub(marketAssets[market].suppliersShareRateUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Decreasing rate is not allowed at this time');\r\n\t\t\tuint maxDecrease = marketAssets[market].suppliersShareRate.sub(suppliersShareRateMaxDecrease);\r\n\t\t\trequire (newSuppliersShareRate >= maxDecrease,'Rate should be decreased less than max allowed');\r\n\t\t}\r\n\r\n\t\tholdefiContract.updateSupplyIndex(market);\r\n\t\tholdefiContract.updatePromotionReserve(market);\r\n\t\tmarketAssets[market].suppliersShareRate = newSuppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = currentTime;\r\n\r\n\t\temit SuppliersShareRateChanged(market, newSuppliersShareRate);\r\n\t}\r\n\r\n\t// Owner can add a new asset as a market.\r\n\tfunction addMarket (address market, uint borrowRate, uint suppliersShareRate) external onlyOwner {\r\n\t\trequire(!marketAssets[market].isActive, \"Market exists\");\r\n\t\trequire (borrowRate <= maxBorrowRate\r\n\t\t\t&& suppliersShareRate >= minSuppliersShareRate\r\n\t\t\t&& suppliersShareRate <= ratesDecimal\r\n\t\t\t, 'Rate should be in allowed range');\r\n\t\t\r\n\t\tmarketAssets[market].isActive = true;\r\n\t\tmarketAssets[market].borrowRate = borrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = block.timestamp;\r\n\t\tmarketAssets[market].suppliersShareRate = suppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = block.timestamp;\r\n\t\r\n\t\tbool exist = false;\r\n\t\tfor (uint i=0; i<marketsList.length; i++) {\r\n\t\t\tif (marketsList[i] == market){\r\n\t\t\t\texist = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!exist) {\r\n\t\t\tmarketsList.push(market);\r\n\t\t}\r\n\r\n\t\temit MarketAdded(market);\r\n\t}\r\n\r\n\t// Owner can remove a market asset\r\n\tfunction removeMarket (address market) external onlyOwner {\t\t\r\n\t\tmarketAssets[market].isActive = false;\r\n\t\temit MarketRemoved(market);\r\n\t}\r\n\r\n\t// Owner can add a collateral asset with its VTL, penalty and bonus rate\r\n\tfunction addCollateral (address collateralAsset, uint valueToLoanRate, uint penaltyRate, uint bonusRate) external onlyOwner {\r\n\t\trequire(!collateralAssets[collateralAsset].isActive, \"Collateral exists\");\t\t\r\n\t\trequire (valueToLoanRate <= maxValueToLoanRate\r\n\t\t\t\t&& penaltyRate <= maxPenaltyRate\r\n\t\t\t\t&& penaltyRate <= valueToLoanRate\r\n\t\t\t\t&& bonusRate <= penaltyRate\r\n\t\t\t\t&& bonusRate >= ratesDecimal\r\n\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t\tcollateralAssets[collateralAsset].isActive = true;\r\n\t\tcollateralAssets[collateralAsset].valueToLoanRate = valueToLoanRate;\r\n\t\tcollateralAssets[collateralAsset].penaltyRate  = penaltyRate;\r\n\t    collateralAssets[collateralAsset].bonusRate = bonusRate;\r\n\t    collateralAssets[collateralAsset].VTLUpdateTime = block.timestamp;\r\n\t    collateralAssets[collateralAsset].penaltyUpdateTime = block.timestamp;\r\n\t    \t\r\n\t\temit CollateralAdded(collateralAsset, valueToLoanRate, penaltyRate, bonusRate);\r\n\t}\r\n\r\n\t// Owner can remove a collateral asset\r\n\tfunction removeCollateral (address collateralAsset) external onlyOwner {\r\n\t\tcollateralAssets[collateralAsset].isActive = false;\r\n\t\temit CollateralRemoved(collateralAsset);\r\n\t}\r\n\t\r\n\t// Owner can set a new VTL rate (Liquidation threshold) for each collateral asset\r\n\tfunction setValueToLoanRate (address collateralAsset, uint newValueToLoanRate) external onlyOwner {\r\n\t\trequire (newValueToLoanRate <= maxValueToLoanRate\r\n\t\t\t\t&& collateralAssets[collateralAsset].penaltyRate <= newValueToLoanRate\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t\tuint currentTime = block.timestamp;\r\n\t\tif (newValueToLoanRate > collateralAssets[collateralAsset].valueToLoanRate) {\r\n\t\t\tuint deltaTime = currentTime.sub(collateralAssets[collateralAsset].VTLUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = collateralAssets[collateralAsset].valueToLoanRate.add(valueToLoanRateMaxIncrease);\r\n\t\t\trequire (newValueToLoanRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\t    collateralAssets[collateralAsset].valueToLoanRate = newValueToLoanRate;\r\n\t    collateralAssets[collateralAsset].VTLUpdateTime = currentTime;\r\n\r\n\t    emit ValueToLoanRateChanged(collateralAsset, newValueToLoanRate);\r\n\t}\r\n\r\n\t// Owner can set penalty rate for each collateral asset\r\n\tfunction setPenaltyRate (address collateralAsset ,uint newPenaltyRate) external onlyOwner {\r\n\t\trequire (newPenaltyRate <= maxPenaltyRate\r\n\t\t\t\t&& newPenaltyRate <= collateralAssets[collateralAsset].valueToLoanRate\r\n\t\t\t\t&& collateralAssets[collateralAsset].bonusRate <= newPenaltyRate\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\r\n\t\tuint currentTime = block.timestamp;\r\n\t\tif (newPenaltyRate > collateralAssets[collateralAsset].penaltyRate){\r\n\t\t\tuint deltaTime = currentTime.sub(collateralAssets[collateralAsset].penaltyUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = collateralAssets[collateralAsset].penaltyRate.add(penaltyRateMaxIncrease);\r\n\t\t\trequire (newPenaltyRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\t    collateralAssets[collateralAsset].penaltyRate  = newPenaltyRate;\r\n\t    collateralAssets[collateralAsset].penaltyUpdateTime = currentTime;\r\n\r\n\t    emit PenaltyRateChanged(collateralAsset, newPenaltyRate);\r\n\t}\r\n\r\n\t// Owner can set bonus rate for each collateral asset\r\n\tfunction setBonusRate (address collateralAsset, uint newBonusRate) external onlyOwner {\r\n\t\trequire (newBonusRate <= collateralAssets[collateralAsset].penaltyRate\r\n\t\t\t\t&& newBonusRate >= ratesDecimal\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t    collateralAssets[collateralAsset].bonusRate = newBonusRate;\r\n\r\n\t    emit BonusRateChanged(collateralAsset, newBonusRate);\r\n\t}\r\n\r\n\tfunction() payable external {\r\n        revert();\r\n    }\r\n}"
    },
    {
      "filename": "contracts/Holdefi.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./HoldefiPauser.sol\";\r\n\r\n//"
    },
    {
      "filename": "contracts/HoldefiPrices.sol",
      "content": "interface HoldefiPricesInterface {\r\n\tfunction getPrice(address token) external view returns(uint price);\t\r\n}\r\n\r\n//"
    },
    {
      "filename": "contracts/HoldefiSettings.sol",
      "content": "interface HoldefiSettingsInterface {\r\n\tfunction getInterests(address market, uint totalSupply, uint totalBorrow) external view returns(uint borrowRate, uint supplyRate);\r\n\tfunction getMarket(address market) external view returns(bool isActive);\r\n\tfunction getCollateral(address collateral) external view returns(bool isActive, uint valueToLoanRate, uint penaltyRate, uint bonusRate);\r\n\tfunction getMarketsList() external view returns(address[] memory marketsList);\r\n}\r\n\r\n//"
    },
    {
      "filename": "contracts/CollateralsWallet.sol",
      "content": "interface CollateralsWalletInterface {\r\n\tfunction withdraw(address collateral, address payable recipient, uint amount) external;\r\n}\r\n\r\ninterface ERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns(bool success);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool success);\r\n}\r\n\r\n\r\n\r\n // Main Holdefi contract.\r\n // The address of ETH asset considered as 0x00 in this contract.\r\ncontract Holdefi is HoldefiPauser {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\t// All rates in this contract are scaled by ratesDecimal.\r\n\tuint constant public ratesDecimal = 10 ** 4;\r\n\r\n\t// All Indexes in this contract are scaled by (secondsPerYear * ratesDecimal) \r\n\tuint constant public secondsPerYear = 31536000;\r\n\r\n\tuint constant public maxPromotionRate = 3000;\r\n\r\n\t// Markets are assets that can be supplied and borrowed\r\n\tstruct Market {\r\n\t\tuint totalSupply;\r\n\t\tuint supplyIndex;      //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint supplyIndexUpdateTime;\r\n\r\n\t\tuint totalBorrow;\r\n\t\tuint borrowIndex;      //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint borrowIndexUpdateTime;\r\n\r\n\t\tuint promotionRate;\r\n\t\tuint promotionReserveScaled; //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint promotionReserveLastUpdateTime;\r\n\t\tuint promotionDebtScaled;    //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint promotionDebtLastUpdateTime;\r\n\t}\r\n\r\n\t// Collaterals are assets that can be use only as collateral (no interest)\r\n\tstruct Collateral {\r\n\t\tuint totalCollateral;\r\n\t\tuint totalLiquidatedCollateral;\r\n\t}\r\n\r\n\t// Users profile for each market\r\n\tstruct MarketAccount {\r\n\t\tuint balance;\r\n\t\tuint accumulatedInterest; \r\n\t\tuint lastInterestIndex; //Scaled by: secondsPerYear * ratesDecimal\r\n\t}\r\n\t// Users profile for each collateral\r\n\tstruct CollateralAccount {\r\n\t\tuint balance;\r\n\t\tuint lastUpdateTime;\r\n\t}\r\n\r\n\t// Markets: marketAddress => Market\r\n\tmapping (address => Market) public marketAssets;\r\n\r\n\t// Collaterals: collateralAddress => Collateral\r\n\tmapping (address => Collateral) public collateralAssets;\r\n\r\n\t// Users Supplies: userAddress => marketAddress => supplyDetails\r\n\tmapping (address => mapping (address => MarketAccount)) private supplies;\r\n\r\n\t// Users Borrows: userAddress => collateralAddress => marketAddress => borrowDetails \r\n\tmapping (address => mapping (address => mapping (address => MarketAccount))) private borrows;\r\n\r\n\t// Users Collaterals: userAddress => collateralAddress => collateralDetails \r\n\tmapping (address => mapping (address => CollateralAccount)) private collaterals;\r\n\t\r\n\t// Markets Debt after liquidation: collateralAddress => marketAddress => marketDebtBalance \r\n\tmapping (address => mapping (address => uint)) public marketDebt;\r\n\r\n\r\n\t// Contract for getting markets supply rate and borrow rate \r\n\tHoldefiSettingsInterface public holdefiSettings;\r\n\r\n\t// Contract for getting token price \r\n\tHoldefiPricesInterface public holdefiPrices;\r\n\r\n\t// Wallet Contract for Collaterals \r\n\tCollateralsWalletInterface public holdefiCollaterals;\r\n\r\n\t// Price contract can be unchangeable\r\n\tbool public fixPrices = false;\r\n\r\n\t// ----------- Events -----------\r\n\r\n\tevent Supply(address supplier, address market, uint amount);\r\n\r\n\tevent WithdrawSupply(address supplier, address market, uint amount);\r\n\r\n\tevent Collateralize(address collateralizer, address collateral, uint amount);\r\n\r\n\tevent WithdrawCollateral(address collateralizer, address collateral, uint amount);\r\n\r\n\tevent Borrow(address borrower, address market, address collateral, uint amount);\r\n\r\n\tevent RepayBorrow(address borrower, address market, address collateral, uint amount);\r\n\r\n\tevent UpdateSupplyIndex(address market, uint newSupplyIndex, uint supplyRate);\r\n\r\n\tevent UpdateBorrowIndex(address market, uint newBorrowIndex);\r\n\r\n\tevent CollateralLiquidated(address borrower, address collateral, uint amount);\r\n\r\n\tevent NewMarketDebt(address borrower, address market, address collateral, uint amount);\r\n\r\n\tevent BuyLiquidatedCollateral(address market, address collateral, uint marketAmount);\r\n\r\n\tevent PromotionRateChanged(address market, uint newRate);\r\n\r\n\tevent HoldefiPricesContractChanged(HoldefiPricesInterface newAddress, HoldefiPricesInterface oldAddress);\r\n\t\r\n\tconstructor (address newOwnerChanger, CollateralsWalletInterface holdefiCollateralsAddress, HoldefiSettingsInterface holdefiSettingsAddress, HoldefiPricesInterface holdefiPricesAddress) HoldefiPauser(newOwnerChanger) public {\r\n\t\tholdefiCollaterals = holdefiCollateralsAddress;\r\n\t\tholdefiSettings = holdefiSettingsAddress;\r\n\t\tholdefiPrices = holdefiPricesAddress;\r\n\t}\r\n\t\r\n\tfunction supplyInternal (address market, uint amount) internal {\r\n\t\t(uint balance,uint interest,uint currentSupplyIndex) = getAccountSupply(msg.sender, market);\r\n\t\t\r\n\t\tsupplies[msg.sender][market].accumulatedInterest = interest;\r\n\t\tsupplies[msg.sender][market].balance = balance.add(amount);\r\n\t\tsupplies[msg.sender][market].lastInterestIndex = currentSupplyIndex;\r\n\r\n\t\tupdatePromotion(market);\r\n\t\t\r\n\t\tmarketAssets[market].totalSupply = marketAssets[market].totalSupply.add(amount);\r\n\r\n\t\temit Supply(msg.sender, market, amount);\r\n\t}\r\n\r\n\t// Deposit ERC20 assets for supplying (except ETH).\r\n\tfunction supply (address market, uint amount) external whenNotPaused(0) {\r\n\t\trequire (market != address(0), 'Supply asset should not be zero address');\r\n\t\tbool isActive = holdefiSettings.getMarket(market);\r\n\t\trequire (isActive,'Market is not active');\r\n\r\n\t\tERC20 token = ERC20(market);\r\n\t\tbool success = token.transferFrom(msg.sender, address(this), amount);\r\n\t\trequire (success, 'Cannot transfer token');\r\n\r\n\t\tsupplyInternal(market, amount);\r\n\t}\r\n\r\n\t// Deposit ETH for supplying\r\n\tfunction supply () payable external whenNotPaused(0) {\r\n\t\taddress market = address(0);\r\n\t\tuint amount = msg.value;\r\n\t\tbool isActive = holdefiSettings.getMarket(market);\r\n\t\trequire (isActive, 'Market is not active');\r\n\t\t\r\n\t\tsupplyInternal(market, amount);\r\n\t}\r\n\r\n\t// Withdraw ERC20 assets from a market (include interests).\r\n\tfunction withdrawSupply (address market, uint amount) external whenNotPaused(1) {\r\n\t\t(uint balance,uint interest,uint currentSupplyIndex) = getAccountSupply(msg.sender, market);\r\n\t\t\r\n\t\tuint transferAmount;\r\n\t\tuint totalBalance = balance.add(interest);\r\n\r\n\t\trequire (totalBalance != 0, 'Total balance should not be zero');\r\n\t\tif (amount <= totalBalance){\r\n\t\t\ttransferAmount = amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttransferAmount = totalBalance;\r\n\t\t}\r\n\r\n\t\tuint remaining;\r\n\t\tif (transferAmount <= interest) {\r\n\t\t\tsupplies[msg.sender][market].accumulatedInterest = interest.sub(transferAmount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tremaining = transferAmount.sub(interest);\r\n\t\t\tsupplies[msg.sender][market].accumulatedInterest = 0;\r\n\t\t\tsupplies[msg.sender][market].balance = balance.sub(remaining);\r\n\t\t}\r\n\t\tsupplies[msg.sender][market].lastInterestIndex = currentSupplyIndex;\r\n\r\n\t\tupdatePromotion(market);\r\n\t\t\r\n\t\tmarketAssets[market].totalSupply = marketAssets[market].totalSupply.sub(remaining);\t\r\n\t\t\t\t\r\n\t\tif (market == address(0)){\r\n\t\t\tmsg.sender.transfer(transferAmount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tERC20 token = ERC20(market);\r\n\t\t\tbool success = token.transfer(msg.sender, transferAmount);\r\n\t\t\trequire (success, 'Cannot transfer token');\r\n\t\t}\r\n\t\r\n\t\temit WithdrawSupply(msg.sender, market, transferAmount);\r\n\t}\r\n\r\n\tfunction collateralizeInternal (address collateral, uint amount) internal {\r\n\t\tcollaterals[msg.sender][collateral].balance = collaterals[msg.sender][collateral].balance.add(amount);\r\n\t\tcollaterals[msg.sender][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tcollateralAssets[collateral].totalCollateral = collateralAssets[collateral].totalCollateral.add(amount);\t\r\n\t\t\r\n\t\temit Collateralize(msg.sender, collateral, amount);\r\n\t}\r\n\r\n\t// Deposit ERC20 assets as collateral(except ETH) \r\n\tfunction collateralize (address collateral, uint amount) external whenNotPaused(2) {\r\n\t\trequire (collateral != address(0), 'Collateral asset should not be zero address');\r\n\t\t(bool isActive,,,) = holdefiSettings.getCollateral(collateral);\r\n\t\trequire (isActive, 'Collateral asset is not active');\r\n\r\n\t\tERC20 token = ERC20(collateral);\r\n\t\tbool success = token.transferFrom(msg.sender, address(holdefiCollaterals), amount);\r\n\t\trequire (success, 'Cannot Transfer Token');\r\n\r\n\t\tcollateralizeInternal(collateral, amount);\r\n\t}\r\n\r\n\t// Deposit ETH as collateral\r\n\tfunction collateralize () payable external whenNotPaused(2) {\r\n\t\taddress collateral = address(0);\r\n\t\tuint amount = msg.value;\r\n\t\t(bool isActive,,,) = holdefiSettings.getCollateral(collateral);\r\n\t\trequire (isActive, 'Collateral asset is not active');\r\n\r\n\t\t(bool success, ) = address(holdefiCollaterals).call.value(amount)(\"\");\r\n\t\trequire (success, 'Cannot Transfer ETH');\r\n\r\n\t\tcollateralizeInternal(collateral, amount);\r\n\t}\r\n\r\n\t// Withdraw collateral assets\r\n\tfunction withdrawCollateral (address collateral, uint amount) external whenNotPaused(3) {\r\n\t\t(uint balance, ,uint borrowPowerScaled,uint totalBorrowValueScaled,) = getAccountCollateral(msg.sender, collateral);\t\r\n\t\trequire (borrowPowerScaled != 0, 'Borrow power should not be zero');\r\n\r\n\t\tuint maxWithdraw;\r\n\t\tif (totalBorrowValueScaled == 0) {\r\n\t\t\tmaxWithdraw = balance;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint collateralPriceScaled = holdefiPrices.getPrice(collateral);\r\n\t\t\t(,uint valueToLoanRate,,) = holdefiSettings.getCollateral(collateral);\r\n\t\t\tuint totalCollateral"
    }
  ]
}