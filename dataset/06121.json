{
  "Title": "[G-10] Unnecessary Casting of Variables",
  "Content": "- Severity: Gas Optimization\n- Confidence: High\n\n### Description\nThis detector scans for instances where a variable is casted to its own type. This is unnecessary and can be safely removed to improve code readability.\n\n<details>\n\n<summary>\nThere are 5 instances of this issue:\n\n</summary>\n\n###\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 42          _msgSender() != address(pauser)\n```\nUnnecessary cast: `address(pauser)` it cast to the same type.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L42](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L42)\n\n- File: solidity/contracts/core/VaultController.sol\n```\n \nLine: 946          uint192 _e18FactorIncrease = _safeu192(\n      _truncate(\n        _truncate((uint256(_timeDifference) * uint256(1e18) * uint256(_curveVal)) / (365 days + 6 hours))\n          * uint256(interest.factor)\n      )\n    )\n```\nUnnecessary cast: `uint256(1e18)` it cast to the same type.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L946-L951](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L946-L951)\n\n- File: solidity/contracts/periphery/oracles/ChainlinkOracleRelay.sol\n```\n \nLine: 75          _value = (uint256(_latest) * MULTIPLY) / DIVIDE\n```\nUnnecessary cast: `uint256(_latest)` it cast to the same type.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/ChainlinkOracleRelay.sol#L75](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/ChainlinkOracleRelay.sol#L75)\n\n- File: solidity/contracts/periphery/oracles/ChainlinkTokenOracleRelay.sol\n```\n \nLine: 24          AGGREGATOR = ChainlinkOracleRelay(_feedAddress)\n```\nUnnecessary cast: `ChainlinkOracleRelay(_feedAddress)` it cast to the same type.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/ChainlinkTokenOracleRelay.sol#L24](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/ChainlinkTokenOracleRelay.sol#L24)\n\n- File: solidity/contracts/periphery/oracles/ChainlinkTokenOracleRelay.sol\n```\n \nLine: 25          BASE_AGGREGATOR = ChainlinkOracleRelay(_baseFeedAddress)\n```\nUnnecessary cast: `ChainlinkOracleRelay(_baseFeedAddress)` it cast to the same type.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/ChainlinkTokenOracleRelay.sol#L25](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/ChainlinkTokenOracleRelay.sol#L25)\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/core/USDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\nimport {Roles} from '@contracts/utils/Roles.sol';\nimport {UFragments} from '@contracts/utils/UFragments.sol';\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\n\nimport {IERC20Metadata, IERC20} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n/// @notice USDA token contract, handles all minting/burning of usda\n/// @dev extends UFragments\ncontract USDA is Pausable, UFragments, IUSDA, ExponentialNoError, Roles {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  bytes32 public constant VAULT_CONTROLLER_ROLE = keccak256('VAULT_CONTROLLER');\n\n  EnumerableSet.AddressSet internal _vaultControllers;\n\n  /// @dev The reserve token\n  IERC20 public sUSD;\n\n  /// @dev The address of the pauser\n  address public pauser;\n\n  /// @dev The reserve amount\n  uint256 public reserveAmount;\n\n  /// @notice Checks if _msgSender() is a valid VaultController\n  modifier onlyVaultController() {\n    _checkRole(VAULT_CONTROLLER_ROLE, _msgSender());\n    _;\n  }\n\n  /// @notice Checks if _msgSender() is pauser\n  modifier onlyPauser() {\n    if (_msgSender() != address(pauser)) revert USDA_OnlyPauser();\n    _;\n  }\n\n  /// @notice Any function with this modifier will call the pay_interest() function before any function logic is called\n  modifier paysInterest() {\n    for (uint256 _i; _i < _vaultControllers.length();) {\n      IVaultController(_vaultControllers.at(_i)).calculateInterest();\n      unchecked {\n        _i++;\n      }\n    }\n    _;\n  }\n\n  constructor(IERC20 _sUSDAddr) UFragments('USDA Token', 'USDA') {\n    sUSD = _sUSDAddr;\n  }\n\n  /// @notice Sets the pauser for both USDA and VaultController\n  /// @dev The pauser is a separate role from the owner\n  function setPauser(address _pauser) external override onlyOwner {\n    pauser = _pauser;\n\n    emit PauserSet(_pauser);\n  }\n\n  /// @notice Pause contract\n  /// @dev Can only be called by the pauser\n  function pause() external override onlyPauser {\n    _pause();\n  }\n\n  /// @notice Unpause contract, pauser only\n  /// @dev Can only be called by the pauser\n  function unpause() external override onlyPauser {\n    _unpause();\n  }\n\n  /// @notice Deposit sUSD to mint USDA\n  /// @dev Caller should obtain 1 USDA for each sUSD\n  /// the calculations for deposit mimic the calculations done by mint in the ampleforth contract, simply with the susd transfer\n  /// 'fragments' are the units that we see, so 1000 fragments == 1000 USDA\n  /// 'gons' are the internal accounting unit, used to keep scale.\n  /// We use the variable _gonsPerFragment in order to convert between the two\n  /// try dimensional analysis when doing the math in order to verify units are correct\n  /// @param _susdAmount The amount of sUSD to deposit\n  function deposit(uint256 _susdAmount) external override {\n    _deposit(_susdAmount, _msgSender());\n  }\n\n  /// @notice Deposits sUSD to mint USDA and transfer to a different address\n  /// @param _susdAmount The amount of sUSD to deposit\n  /// @param _target The address to receive the USDA tokens\n  function depositTo(uint256 _susdAmount, address _target) external override {\n    _deposit(_susdAmount, _target);\n  }\n\n  /// @notice Business logic to deposit sUSD and mint USDA for the caller\n  function _deposit(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _mint(_target, _susdAmount);\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n\n    emit Deposit(_target, _susdAmount);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @param _susdAmount The amount of sUSD to withdraw\n  function withdraw(uint256 _susdAmount) external override {\n    _withdraw(_susdAmount, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD to a specific address by burning USDA from the caller\n  /// @dev The _target address should obtain 1 sUSD for every 1 USDA burned from the caller\n  /// @param _susdAmount amount of sUSD to withdraw\n  /// @param _target address to receive the sUSD\n  function withdrawTo(uint256 _susdAmount, address _target) external override {\n    _withdraw(_susdAmount, _target);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the sender\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAll() external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the _target\n  /// @param _target should obtain 1 sUSD for every 1 USDA burned from caller\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAllTo(address _target) external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _target);\n  }\n\n  /// @notice business logic to withdraw sUSD and burn USDA from the caller\n  function _withdraw(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (reserveAmount == 0) revert USDA_EmptyReserve();\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    if (_susdAmount > this.balanceOf(_msgSender())) revert USDA_InsufficientFunds();\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    sUSD.transfer(_target, _susdAmount);\n    _burn(_msgSender(), _susdAmount);\n\n    emit Withdraw(_target, _susdAmount);\n  }\n\n  /// @notice Admin function to mint USDA\n  /// @param _susdAmount The amount of USDA to mint, denominated in sUSD\n  function mint(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _mint(_msgSender(), _susdAmount);\n  }\n\n  /// @dev mint a specific `amount` of tokens to the `target`\n  function _mint(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // the gonbalances of the sender is in gons, therefore we must multiply the deposit amount, which is in fragments, by gonsperfragment\n    _gonBalances[_target] += _amount * __gonsPerFragment;\n    // total supply is in fragments, and so we add amount\n    _totalSupply += _amount;\n    // and totalgons of course is in gons, and so we multiply amount by gonsperfragment to get the amount of gons we must add to totalGons\n    _totalGons += _amount * __gonsPerFragment;\n    // emit both a mint and transfer event\n    emit Transfer(address(0), _target, _amount);\n    emit Mint(_target, _amount);\n  }\n\n  /// @notice Admin function to burn USDA\n  /// @param _susdAmount The amount of USDA to burn, denominated in sUSD\n  function burn(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _burn(_msgSender(), _susdAmount);\n  }\n\n  /// @dev burn a specific `amount` of tokens from the `target`\n  function _burn(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // modify the gonbalances of the sender, subtracting the amount of gons, therefore amount * gonsperfragment\n    _gonBalances[_target] -= (_amount * __gonsPerFragment);\n    // modify totalSupply and totalGons\n    _totalSupply -= _amount;\n    _totalGons -= (_amount * __gonsPerFragment);\n    // emit both a burn and transfer event\n    emit Transfer(_target, address(0), _amount);\n    emit Burn(_target, _amount);\n  }\n\n  /// @notice Donates susd to the protocol reserve\n  /// @param _susdAmount The amount of sUSD to donate\n  function donate(uint256 _susdAmount) external override paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _donation(_susdAmount);\n  }\n\n  /// @notice Recovers accidentally sent sUSD to this contract\n  /// @param _to The receiver of the dust\n  function recoverDust(address _to) external onlyOwner {\n    // All sUSD sent directly to the contract is not accounted into the reserveAmount\n    // This function allows governance to recover it\n    uint256 _amount = sUSD.balanceOf(address(this)) - reserveAmount;\n    sUSD.transfer(_to, _amount);\n\n    emit RecoveredDust(owner(), _amount);\n  }\n\n  /// @notice Function for the vaultController to mint\n  /// @param _target The address to mint the USDA to\n  /// @param _amount The amount of USDA to mint\n  function vaultControllerMint(address _target, uint256 _amount) external override onlyVaultController whenNotPaused {\n    _mint(_target, _amount);\n  }\n\n  /// @notice Function for the vaultController to burn\n  /// @param _target The address to burn the USDA from\n  /// @param _amount The amount of USDA to burn\n  function vaultControllerBurn(address _target, uint256 _amount) external override onlyVaultController {\n    if (_gonBalances[_target] < (_amount * _gonsPerFragment)) revert USDA_NotEnoughBalance();\n    _burn(_target, _amount);\n  }\n\n  /// @notice Allows VaultController to send sUSD from the reserve\n  /// @param _target The address to receive the sUSD from reserve\n  /// @param _susdAmount The amount of sUSD to send\n  function vaultControllerTransfer(\n    address _target,\n    uint256 _susdAmount\n  ) external override onlyVaultController whenNotPaused {\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    // ensure transfer success\n    sUSD.transfer(_target, _susdAmount);\n\n    emit VaultControllerTransfer(_target, _susdAmount);\n  }\n\n  /// @notice Function for the vaultController to scale all USDA balances\n  /// @param _amount The amount of USDA (e18) to donate\n  function vaultControllerDonate(uint256 _amount) external override onlyVaultController {\n    _donation(_amount);\n  }\n\n  /// @notice Function for distributing the donation to all USDA holders\n  /// @param _amount The amount of USDA to donate\n  function _donation(uint256 _amount) internal {\n    _totalSupply += _amount;\n    if (_totalSupply > MAX_SUPPLY) _totalSupply = MAX_SUPPLY;\n    _gonsPerFragment = _totalGons / _totalSupply;\n    emit Donation(_msgSender(), _amount, _totalSupply);\n  }\n\n  /// @notice Returns the reserve ratio\n  /// @return _e18reserveRatio The USDA reserve ratio\n  function reserveRatio() external view override returns (uint192 _e18reserveRatio) {\n    _e18reserveRatio = _safeu192((reserveAmount * EXP_SCALE) / _totalSupply);\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                                ROLES\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Adds a new vault controller\n  /// @param _vaultController The new vault controller to add\n  function addVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.add(_vaultController);\n    _grantRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerAdded(_vaultController);\n  }\n\n  /// @notice Removes a vault controller\n  /// @param _vaultController The vault controller to remove\n  function removeVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n    _revokeRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerRemoved(_vaultController);\n  }\n\n  /// @notice Removes a vault controller from the list\n  /// @param _vaultController The vault controller to remove\n  /// @dev The vault controller is removed from the list but keeps the role as to not brick it\n  function removeVaultControllerFromList(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n\n    emit VaultControllerRemovedFromList(_vaultController);\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/core/VaultController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\nimport {CurveMaster} from '@contracts/periphery/CurveMaster.sol';\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVault} from '@interfaces/core/IVault.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\nimport {IOracleRelay} from '@interfaces/periphery/IOracleRelay.sol';\nimport {IBooster} from '@interfaces/utils/IBooster.sol';\nimport {IBaseRewardPool} from '@interfaces/utils/IBaseRewardPool.sol';\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\nimport {IVaultDeployer} from '@interfaces/core/IVaultDeployer.sol';\n\nimport {IERC20, IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\n\n/// @notice Controller of all vaults in the USDA borrow/lend system\n///         VaultController contains all business logic for borrowing and lending through the protocol.\n///         It is also in charge of accruing interest.\ncontract VaultController is Pausable, IVaultController, ExponentialNoError, Ownable {\n  /// @dev The max decimals allowed for a listed token\n  uint8 public constant MAX_DECIMALS = 18;\n\n  /// @dev The max allowed to be set as borrowing fee\n  uint192 public constant MAX_INIT_BORROWING_FEE = 0.05e18;\n\n  /// @dev The convex booster interface\n  IBooster public immutable BOOSTER;\n\n  /// @dev The vault deployer interface\n  IVaultDeployer public immutable VAULT_DEPLOYER;\n\n  /// @dev Mapping of vault id to vault address\n  mapping(uint96 => address) public vaultIdVaultAddress;\n\n  /// @dev Mapping of wallet address to vault IDs arrays\n  mapping(address => uint96[]) public walletVaultIDs;\n\n  /// @dev Mapping of token address to collateral info\n  mapping(address => CollateralInfo) public tokenAddressCollateralInfo;\n\n  /// @dev Array of enabled tokens addresses\n  address[] public enabledTokens;\n\n  /// @dev The curve master contract\n  CurveMaster public curveMaster;\n\n  /// @dev The interest contract\n  Interest public interest;\n\n  /// @dev The usda interface\n  IUSDA public usda;\n\n  /// @dev The amphora claimer interface\n  IAMPHClaimer public claimerContract;\n\n  /// @dev Total number of minted vaults\n  uint96 public vaultsMinted;\n  /// @dev Total number of tokens registered\n  uint256 public tokensRegistered;\n  /// @dev Total base liability\n  uint192 public totalBaseLiability;\n  /// @dev The protocol's fee\n  uint192 public protocolFee;\n  /// @dev The initial borrowing fee (1e18 == 100%)\n  uint192 public initialBorrowingFee;\n  /// @dev The fee taken from the liquidator profit (1e18 == 100%)\n  uint192 public liquidationFee;\n\n  /// @notice Any function with this modifier will call the _payInterest() function before\n  modifier paysInterest() {\n    _payInterest();\n    _;\n  }\n\n  ///@notice Any function with this modifier can be paused or unpaused by USDA._pauser() in the case of an emergency\n  modifier onlyPauser() {\n    if (_msgSender() != usda.pauser()) revert VaultController_OnlyPauser();\n    _;\n  }\n\n  /// @notice Can initialize collaterals from an older vault controller\n  /// @param _oldVaultController The old vault controller\n  /// @param _tokenAddresses The addresses of the collateral we want to take information for\n  /// @param _claimerContract The claimer contract\n  /// @param _vaultDeployer The deployer contract\n  /// @param _initialBorrowingFee The initial borrowing fee\n  /// @param _booster The convex booster address\n  /// @param _liquidationFee The liquidation fee\n  constructor(\n    IVaultController _oldVaultController,\n    address[] memory _tokenAddresses,\n    IAMPHClaimer _claimerContract,\n    IVaultDeployer _vaultDeployer,\n    uint192 _initialBorrowingFee,\n    address _booster,\n    uint192 _liquidationFee\n  ) {\n    VAULT_DEPLOYER = _vaultDeployer;\n    interest = Interest(uint64(block.timestamp), 1 ether);\n    protocolFee = 1e14;\n    initialBorrowingFee = _initialBorrowingFee;\n    liquidationFee = _liquidationFee;\n\n    claimerContract = _claimerContract;\n\n    BOOSTER = IBooster(_booster);\n\n    if (address(_oldVaultController) != address(0)) _migrateCollateralsFrom(_oldVaultController, _tokenAddresses);\n  }\n\n  /// @notice Returns the latest interest factor\n  /// @return _interestFactor The latest interest factor\n  function interestFactor() external view override returns (uint192 _interestFactor) {\n    _interestFactor = interest.factor;\n  }\n\n  /// @notice Returns the block timestamp when pay interest was last called\n  /// @return _lastInterestTime The block timestamp when pay interest was last called\n  function lastInterestTime() external view override returns (uint64 _lastInterestTime) {\n    _lastInterestTime = interest.lastTime;\n  }\n\n  /// @notice Returns an array of all the vault ids a specific wallet has\n  /// @param _wallet The address of the wallet to target\n  /// @return _vaultIDs The ids of the vaults the wallet has\n  function vaultIDs(address _wallet) external view override returns (uint96[] memory _vaultIDs) {\n    _vaultIDs = walletVaultIDs[_wallet];\n  }\n\n  /// @notice Returns an array of all enabled tokens\n  /// @return _enabledTokens The array containing the token addresses\n  function getEnabledTokens() external view override returns (address[] memory _enabledTokens) {\n    _enabledTokens = enabledTokens;\n  }\n\n  /// @notice Returns the token id given a token's address\n  /// @param _tokenAddress The address of the token to target\n  /// @return _tokenId The id of the token\n  function tokenId(address _tokenAddress) external view override returns (uint256 _tokenId) {\n    _tokenId = tokenAddressCollateralInfo[_tokenAddress].tokenId;\n  }\n\n  /// @notice Returns the oracle given a token's address\n  /// @param _tokenAddress The id of the token\n  /// @return _oracle The address of the token's oracle\n  function tokensOracle(address _tokenAddress) external view override returns (IOracleRelay _oracle) {\n    _oracle = tokenAddressCollateralInfo[_tokenAddress].oracle;\n  }\n\n  /// @notice Returns the ltv of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _ltv The loan-to-value of a token\n  function tokenLTV(address _tokenAddress) external view override returns (uint256 _ltv) {\n    _ltv = tokenAddressCollateralInfo[_tokenAddress].ltv;\n  }\n\n  /// @notice Returns the liquidation incentive of an accepted token collateral\n  /// @param _tokenAddress The address of the token\n  /// @return _liquidationIncentive The liquidation incentive of the token\n  function tokenLiquidationIncentive(address _tokenAddress)\n    external\n    view\n    override\n    returns (uint256 _liquidationIncentive)\n  {\n    _liquidationIncentive = tokenAddressCollateralInfo[_tokenAddress].liquidationIncentive;\n  }\n\n  /// @notice Returns the cap of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _cap The cap of the token\n  function tokenCap(address _tokenAddress) external view override returns (uint256 _cap) {\n    _cap = tokenAddressCollateralInfo[_tokenAddress].cap;\n  }\n\n  /// @notice Returns the total deposited of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _totalDeposited The total deposited of a token\n  function tokenTotalDeposited(address _tokenAddress) external view override returns (uint256 _totalDeposited) {\n    _totalDeposited = tokenAddressCollateralInfo[_tokenAddress].totalDeposited;\n  }\n\n  /// @notice Returns the collateral type of a token\n  /// @param _tokenAddress The address of the token\n  /// @return _type The collateral type of a token\n  function tokenCollateralType(address _tokenAddress) external view override returns (CollateralType _type) {\n    _type = tokenAddressCollateralInfo[_tokenAddress].collateralType;\n  }\n\n  /// @notice Returns the address of the crvRewards contract\n  /// @param _tokenAddress The address of the token\n  /// @return _crvRewardsContract The address of the crvRewards contract\n  function tokenCrvRewardsContract(address _tokenAddress)\n    external\n    view\n    override\n    returns (IBaseRewardPool _crvRewardsContract)\n  {\n    _crvRewardsContract = tokenAddressCollateralInfo[_tokenAddress].crvRewardsContract;\n  }\n\n  /// @notice Returns the pool id of a curve LP type token\n  /// @dev    If the token is not of type CurveLPStakedOnConvex then it returns 0\n  /// @param _tokenAddress The address of the token\n  /// @return _poolId The pool id of a curve LP type token\n  function tokenPoolId(address _tokenAddress) external view override returns (uint256 _poolId) {\n    _poolId = tokenAddressCollateralInfo[_tokenAddress].poolId;\n  }\n\n  /// @notice Returns the collateral info of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _collateralInfo The complete collateral info of the token\n  function tokenCollateralInfo(address _tokenAddress)\n    external\n    view\n    override\n    returns (CollateralInfo memory _collateralInfo)\n  {\n    _collateralInfo = tokenAddressCollateralInfo[_tokenAddress];\n  }\n\n  /// @notice Returns the selected collaterals info. Will iterate from `_start` (included) until `_end` (not included)\n  /// @param _start The start number to loop on the array\n  /// @param _end The end number to loop on the array\n  /// @return _collateralsInfo The array containing all the collateral info\n  function getCollateralsInfo(\n    uint256 _start,\n    uint256 _end\n  ) external view override returns (CollateralInfo[] memory _collateralsInfo) {\n    // check if `_end` is bigger than the tokens length\n    uint256 _enabledTokensLength = enabledTokens.length;\n    _end = _enabledTokensLength < _end ? _enabledTokensLength : _end;\n\n    _collateralsInfo = new CollateralInfo[](_end - _start);\n\n    for (uint256 _i = _start; _i < _end;) {\n      _collateralsInfo[_i - _start] = tokenAddressCollateralInfo[enabledTokens[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /// @notice Migrates all collateral information from previous vault controller\n  /// @param _oldVaultController The address of the vault controller to take the information from\n  /// @param _tokenAddresses The addresses of the tokens we want to target\n  function _migrateCollateralsFrom(IVaultController _oldVaultController, address[] memory _tokenAddresses) internal {\n    uint256 _tokenId;\n    uint256 _tokensRegistered;\n    for (uint256 _i; _i < _tokenAddresses.length;) {\n      _tokenId = _oldVaultController.tokenId(_tokenAddresses[_i]);\n      if (_tokenId == 0) revert VaultController_WrongCollateralAddress();\n      _tokensRegistered++;\n\n      CollateralInfo memory _collateral = _oldVaultController.tokenCollateralInfo(_tokenAddresses[_i]);\n      _collateral.tokenId = _tokensRegistered;\n      _collateral.totalDeposited = 0;\n\n      enabledTokens.push(_tokenAddresses[_i]);\n      tokenAddressCollateralInfo[_tokenAddresses[_i]] = _collateral;\n\n      unchecked {\n        ++_i;\n      }\n    }\n    tokensRegistered += _tokensRegistered;\n\n    emit CollateralsMigratedFrom(_oldVaultController, _tokenAddresses);\n  }\n\n  /// @notice Creates a new vault and returns it's address\n  /// @return _vaultAddress The address of the newly created vault\n  function mintVault() public override whenNotPaused returns (address _vaultAddress) {\n    // increment  minted vaults\n    vaultsMinted += 1;\n    // mint the vault itself, deploying the contract\n    _vaultAddress = _createVault(vaultsMinted, _msgSender());\n    // add the vault to our system\n    vaultIdVaultAddress[vaultsMinted] = _vaultAddress;\n\n    //push new vault ID onto mapping\n    walletVaultIDs[_msgSender()].push(vaultsMinted);\n\n    // emit the event\n    emit NewVault(_vaultAddress, vaultsMinted, _msgSender());\n  }\n\n  /// @notice Pauses the functionality of the contract\n  function pause() external override onlyPauser {\n    _pause();\n  }\n\n  /// @notice Unpauses the functionality of the contract\n  function unpause() external override onlyPauser {\n    _unpause();\n  }\n\n  /// @notice Registers the USDA contract\n  /// @param _usdaAddress The address to register as USDA\n  function registerUSDA(address _usdaAddress) external override onlyOwner {\n    usda = IUSDA(_usdaAddress);\n    emit RegisterUSDA(_usdaAddress);\n  }\n\n  /// @notice Emited when the owner registers a curve master\n  /// @param _masterCurveAddress The address of the curve master\n  function registerCurveMaster(address _masterCurveAddress) external override onlyOwner {\n    curveMaster = CurveMaster(_masterCurveAddress);\n    emit RegisterCurveMaster(_masterCurveAddress);\n  }\n\n  /// @notice Updates the protocol fee\n  /// @param _newProtocolFee The new protocol fee in terms of 1e18=100%\n  function changeProtocolFee(uint192 _newProtocolFee) external override onlyOwner {\n    if (_newProtocolFee >= 1e18) revert VaultController_FeeTooLarge();\n    protocolFee = _newProtocolFee;\n    emit NewProtocolFee(_newProtocolFee);\n  }\n\n  /// @notice Register a new token to be used as collateral\n  /// @param _tokenAddress The address of the token to register\n  /// @param _ltv The ltv of the token, 1e18=100%\n  /// @param _oracleAddress The address of oracle to fetch the price of the token\n  /// @param _liquidationIncentive The liquidation penalty for the token, 1e18=100%\n  /// @param _cap The maximum amount to be deposited\n  function registerErc20(\n    address _tokenAddress,\n    uint256 _ltv,\n    address _oracleAddress,\n    uint256 _liquidationIncentive,\n    uint256 _cap,\n    uint256 _poolId\n  ) external override onlyOwner {\n    CollateralInfo storage _collateral = tokenAddressCollateralInfo[_tokenAddress];\n    if (_collateral.tokenId != 0) revert VaultController_TokenAlreadyRegistered();\n    uint8 _tokenDecimals = IERC20Metadata(_tokenAddress).decimals();\n    if (_tokenDecimals > MAX_DECIMALS) revert VaultController_TooManyDecimals();\n    if (_poolId != 0) {\n      (address _lpToken,,, address _crvRewards,,) = BOOSTER.poolInfo(_poolId);\n      if (_lpToken != _tokenAddress) revert VaultController_TokenAddressDoesNotMatchLpAddress();\n      _collateral.collateralType = CollateralType.CurveLPStakedOnConvex;\n      _collateral.crvRewardsContract = IBaseRewardPool(_crvRewards);\n      _collateral.poolId = _poolId;\n    } else {\n      _collateral.collateralType = CollateralType.Single;\n      _collateral.crvRewardsContract = IBaseRewardPool(address(0));\n      _collateral.poolId = 0;\n    }\n    // ltv must be compatible with liquidation incentive\n    if (_ltv >= (EXP_SCALE - _liquidationIncentive)) revert VaultController_LTVIncompatible();\n    // increment the amount of registered token\n    tokensRegistered = tokensRegistered + 1;\n    // set & give the token an id\n    _collateral.tokenId = tokensRegistered;\n    // set the token's oracle\n    _collateral.oracle = IOracleRelay(_oracleAddress);\n    // set the token's ltv\n    _collateral.ltv = _ltv;\n    // set the token's liquidation incentive\n    _collateral.liquidationIncentive = _liquidationIncentive;\n    // set the cap\n    _collateral.cap = _cap;\n    // save the decimals\n    _collateral.decimals = _tokenDecimals;\n    // finally, add the token to the array of enabled tokens\n    enabledTokens.push(_tokenAddress);\n\n    emit RegisteredErc20(_tokenAddress, _ltv, _oracleAddress, _liquidationIncentive, _cap);\n  }\n\n  /// @notice Updates an existing collateral with new collateral parameters\n  /// @param _tokenAddress The address of the token to modify\n  /// @param _ltv The new loan-to-value of the token, 1e18=100%\n  /// @param _oracleAddress The address of oracle to modify for the price of the token\n  /// @param _liquidationIncentive The new liquidation penalty for the token, 1e18=100%\n  /// @param _cap The maximum amount to be deposited\n  /// @param _poolId The convex pool id of a crv lp token\n  function updateRegisteredErc20(\n    address _tokenAddress,\n    uint256 _ltv,\n    address _oracleAddress,\n    uint256 _liquidationIncentive,\n    uint256 _cap,\n    uint256 _poolId\n  ) external override onlyOwner {\n    CollateralInfo storage _collateral = tokenAddressCollateralInfo[_tokenAddress];\n    if (_collateral.tokenId == 0) revert VaultController_TokenNotRegistered();\n    // _ltv must be compatible with liquidation incentive\n    if (_ltv >= (EXP_SCALE - _liquidationIncentive)) revert VaultController_LTVIncompatible();\n    if (_poolId != 0) {\n      (address _lpToken,,, address _crvRewards,,) = BOOSTER.poolInfo(_poolId);\n      if (_lpToken != _tokenAddress) revert VaultController_TokenAddressDoesNotMatchLpAddress();\n      _collateral.collateralType = CollateralType.CurveLPStakedOnConvex;\n      _collateral.crvRewardsContract = IBaseRewardPool(_crvRewards);\n      _collateral.poolId = _poolId;\n    }\n    // set the oracle of the token\n    _collateral.oracle = IOracleRelay(_oracleAddress);\n    // set the ltv of the token\n    _collateral.ltv = _ltv;\n    // set the liquidation incentive of the token\n    _collateral.liquidationIncentive = _liquidationIncentive;\n    // set the cap\n    _collateral.cap = _cap;\n\n    emit UpdateRegisteredErc20(_tokenAddress, _ltv, _oracleAddress, _liquidationIncentive, _cap, _poolId);\n  }\n\n  /// @notice Change the claimer contract, used to exchange a fee from curve lp rewards for AMPH tokens\n  /// @param _newClaimerContract The new claimer contract\n  function changeClaimerContract(IAMPHClaimer _newClaimerContract) external override onlyOwner {\n    IAMPHClaimer _oldClaimerContract = claimerContract;\n    claimerContract = _newClaimerContract;\n\n    emit ChangedClaimerContract(_oldClaimerContract, _newClaimerContract);\n  }\n\n  /// @notice Change the initial borrowing fee\n  /// @param _newBorrowingFee The new borrowing fee\n  function changeInitialBorrowingFee(uint192 _newBorrowingFee) external override onlyOwner {\n    if (_newBorrowingFee >= MAX_INIT_BORROWING_FEE) revert VaultController_FeeTooLarge();\n    uint192 _oldBorrowingFee = initialBorrowingFee;\n    initialBorrowingFee = _newBorrowingFee;\n\n    emit ChangedInitialBorrowingFee(_oldBorrowingFee, _newBorrowingFee);\n  }\n\n  /// @notice Change the liquidation fee\n  /// @param _newLiquidationFee The new liquidation fee\n  function changeLiquidationFee(uint192 _newLiquidationFee) external override onlyOwner {\n    if (_newLiquidationFee >= 1e18) revert VaultController_FeeTooLarge();\n    uint192 _oldLiquidationFee = liquidationFee;\n    liquidationFee = _newLiquidationFee;\n\n    emit ChangedLiquidationFee(_oldLiquidationFee, _newLiquidationFee);\n  }\n\n  /// @notice Check a vault for over-collateralization\n  /// @dev This function calls peekVaultBorrowingPower so no state change is done\n  /// @param _id The id of vault we want to target\n  /// @return _overCollateralized Returns true if vault over-collateralized; false if vault under-collaterlized\n  function peekCheckVault(uint96 _id) public view override returns (bool _overCollateralized) {\n    // grab the vault by id if part of our system. revert if not\n    IVault _vault = _getVault(_id);\n    // calculate the total value of the vault's liquidity\n    uint256 _totalLiquidityValue = _peekVaultBorrowingPower(_vault);\n    // calculate the total liability of the vault\n    uint256 _usdaLiability = _truncate((_vault.baseLiability() * interest.factor));\n    // if the ltv >= liability, the vault is solvent\n    _overCollateralized = (_totalLiquidityValue >= _usdaLiability);\n  }\n\n  /// @notice Check a vault for over-collateralization\n  /// @dev This function calls getVaultBorrowingPower to allow state changes to happen if an oracle need them\n  /// @param _id The id of vault we want to target\n  /// @return _overCollateralized Returns true if vault over-collateralized; false if vault under-collaterlized\n  function checkVault(uint96 _id) public returns (bool _overCollateralized) {\n    // grab the vault by id if part of our system. revert if not\n    IVault _vault = _getVault(_id);\n    // calculate the total value of the vault's liquidity\n    uint256 _totalLiquidityValue = _getVaultBorrowingPower(_vault);\n    // calculate the total liability of the vault\n    uint256 _usdaLiability = _truncate((_vault.baseLiability() * interest.factor));\n    // if the ltv >= liability, the vault is solvent\n    _overCol"
    }
  ]
}