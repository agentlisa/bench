{
  "Title": "[M-29] `BribesFactory::createBribeFlywheel` can be completely blocked from creating any `Flywheel` by a malicious actor",
  "Content": "\nA malicious actor can completely block the creation of any bribe `flywheel` that is created via `BribesFactory::createBribeFlywheel` because of the way the `FlywheelBribeRewards` parameter is set.\nInitially, it is set [to the zero address in its constructor](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BribesFactory.sol#L84) and then reset to [a different address via the `FlywheelCore::setFlywheelRewards` call](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BribesFactory.sol#L96) (in the same transaction).\n\n```Solidity\n    function createBribeFlywheel(address bribeToken) public {\n        // ...\n\n        FlywheelCore flywheel = new FlywheelCore(\n            bribeToken,\n            FlywheelBribeRewards(address(0)),\n            flywheelGaugeWeightBooster,\n            address(this)\n        );\n\n        // ...\n\n        flywheel.setFlywheelRewards(address(new FlywheelBribeRewards(flywheel, rewardsCycleLength)));\n        \n        // ...\n    }\n```\n\nThe `FlywheelCore::setFlywheelRewards` function verifies if the current `flywheelRewards` address has any balance of the provided reward token and, if so, [transfers it to the new `flywheelRewards` address](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/base/FlywheelCore.sol#L125-L129).\n\n```Solidity\n    function setFlywheelRewards(address newFlywheelRewards) external onlyOwner {\n        uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\n        if (oldRewardBalance > 0) {\n            rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\n        }\n```\n\nThe issue is, that `FlywheelCore::setFlywheelRewards` does not check if the current `FlywheelCore::flywheelRewards` address is `0` and thus attempts to transfer from `0` address if that address has any reward token in it. A malicious actor can simply send 1 wei of `rewardToken` to the zero address and all `BribesFactory::createBribeFlywheel` will fail because of the attempted transfer of tokens from the `0` address.\n\nThis is also an issue for any 3rd party project that wishes to use MaiaDAO's `BribesFactory` implementation, that uses a burnable reward token, because most likely normal users (non-malicious) have already burned (sent to zero address) tokens; so the creating of the bribe factories would fail by default.\n\nAnother observation is, because all MaiaDAO project tokens use the `Solmate ERC20` implementation, they [all can transfer to 0 (burn)](https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol#L76-L83), which makes this scenario real even if using project tokens as reward tokens.\n\n### Proof of Concept\n\nA coded POC follows, add it to `test\\gauges\\factories\\BribesFactoryTest.t.sol`:\n\n```Solidity\n    import {stdError} from \"forge-std/Test.sol\";\n\n    function testDosCreateBribeFlywheel() public {\n        MockERC20 bribeToken3 = new MockERC20(\"Bribe Token3\", \"BRIBE3\", 18);\n        bribeToken3.mint(address(this), 1000);\n        \n        // transfer 1 wei to zero address (or \"burn\" on other contracts)\n        bribeToken3.transfer(address(0), 1);\n        assertEq(bribeToken3.balanceOf(address(0)), 1);\n                \n        // hevm.expectRevert(stdError.arithmeticError); // for some reason this does not work, foundry error        \n        // function reverts regardless with \"Arithmetic over/underflow\" because the way Solmate ERC20::transferFrom is implemented\n        factory.createBribeFlywheel(address(bribeToken3)); \n    }\n```\n\nObservation: Because the `MockERC20` contract uses `Solmate ERC20` implementation, the error is `\"Arithmetic over/underflow\"` since `address(0)` did not pre-approve the token swap (evidently).\n\n### Recommended Mitigation Steps\n\n- If project tokens are to be used as reward tokens, consider using `OpenZeppelin ERC20` implementation (as [it does not allow transfer to 0 address](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L225-L233) if burn is not intended), or add checks to all project token contracts that transfer, as the `to` argument must never be `address(0)`.\n- Modify `FlywheelCore::setFlywheelRewards` to not attempt any token transfer if the previous `flywheelRewards` is `address(0)`. Example implementation:\n\n```diff\ndiff --git a/src/rewards/base/FlywheelCore.sol b/src/rewards/base/FlywheelCore.sol\nindex 308b804..eaa0093 100644\n--- a/src/rewards/base/FlywheelCore.sol\n+++ b/src/rewards/base/FlywheelCore.sol\n@@ -123,9 +123,11 @@ abstract contract FlywheelCore is Ownable, IFlywheelCore {\n \n     /// @inheritdoc IFlywheelCore\n     function setFlywheelRewards(address newFlywheelRewards) external onlyOwner {\n-        uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\n-        if (oldRewardBalance > 0) {\n-            rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\n+        if (address(flywheelRewards) != address(0)) {\n+            uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\n+            if (oldRewardBalance > 0) {\n+                rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\n+            }\n         }\n \n         flywheelRewards = newFlywheelRewards;\n\n```\n\n### Assessed type\n\nDoS\n\n**[Trust (judge) decreased severity to Medium](https://github.com/code-423n4/2023-05-maia-findings/issues/362#issuecomment-1631204172)**\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/362#issuecomment-1655677963)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/362#issuecomment-1709173636):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/362).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/gauges/factories/BribesFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BaseV2Gauge} from \"@gauges/BaseV2Gauge.sol\";\n\nimport {FlywheelBoosterGaugeWeight} from \"@rewards/booster/FlywheelBoosterGaugeWeight.sol\";\nimport {FlywheelBribeRewards} from \"@rewards/rewards/FlywheelBribeRewards.sol\";\nimport {FlywheelCore} from \"@rewards/FlywheelCoreStrategy.sol\";\n\nimport {BaseV2GaugeFactory, BaseV2GaugeManager} from \"./BaseV2GaugeManager.sol\";\nimport {IBribesFactory} from \"../interfaces/IBribesFactory.sol\";\n\n/// @title Gauge Bribes Factory\ncontract BribesFactory is Ownable, IBribesFactory {\n    /*///////////////////////////////////////////////////////////////\n                        BRIBES FACTORY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBribesFactory\n    uint256 public immutable rewardsCycleLength;\n\n    FlywheelBoosterGaugeWeight private immutable flywheelGaugeWeightBooster;\n\n    /// @inheritdoc IBribesFactory\n    FlywheelCore[] public bribeFlywheels;\n\n    /// @inheritdoc IBribesFactory\n    mapping(FlywheelCore => uint256) public bribeFlywheelIds;\n\n    /// @inheritdoc IBribesFactory\n    mapping(FlywheelCore => bool) public activeBribeFlywheels;\n\n    /// @inheritdoc IBribesFactory\n    mapping(address => FlywheelCore) public flywheelTokens;\n\n    /// @inheritdoc IBribesFactory\n    BaseV2GaugeManager public immutable gaugeManager;\n\n    /**\n     * @notice Creates a new bribes factory\n     * @param _gaugeManager Gauge Factory manager\n     * @param _flywheelGaugeWeightBooster Flywheel Gauge Weight Booster\n     * @param _rewardsCycleLength Rewards Cycle Length\n     * @param _owner Owner of this contract\n     */\n    constructor(\n        BaseV2GaugeManager _gaugeManager,\n        FlywheelBoosterGaugeWeight _flywheelGaugeWeightBooster,\n        uint256 _rewardsCycleLength,\n        address _owner\n    ) {\n        _initializeOwner(_owner);\n        gaugeManager = _gaugeManager;\n        flywheelGaugeWeightBooster = _flywheelGaugeWeightBooster;\n        rewardsCycleLength = _rewardsCycleLength;\n    }\n\n    /// @inheritdoc IBribesFactory\n    function getBribeFlywheels() external view returns (FlywheelCore[] memory) {\n        return bribeFlywheels;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        CREATE BRIBE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBribesFactory\n    function addGaugetoFlywheel(address gauge, address bribeToken) external onlyGaugeFactory {\n        if (address(flywheelTokens[bribeToken]) == address(0)) createBribeFlywheel(bribeToken);\n\n        flywheelTokens[bribeToken].addStrategyForRewards(ERC20(gauge));\n    }\n\n    /// @inheritdoc IBribesFactory\n    function createBribeFlywheel(address bribeToken) public {\n        if (address(flywheelTokens[bribeToken]) != address(0)) revert BribeFlywheelAlreadyExists();\n\n        FlywheelCore flywheel = new FlywheelCore(\n            bribeToken,\n            FlywheelBribeRewards(address(0)),\n            flywheelGaugeWeightBooster,\n            address(this)\n        );\n\n        flywheelTokens[bribeToken] = flywheel;\n\n        uint256 id = bribeFlywheels.length;\n        bribeFlywheels.push(flywheel);\n        bribeFlywheelIds[flywheel] = id;\n        activeBribeFlywheels[flywheel] = true;\n\n        flywheel.setFlywheelRewards(address(new FlywheelBribeRewards(flywheel, rewardsCycleLength)));\n\n        emit BribeFlywheelCreated(bribeToken, flywheel);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyGaugeFactory() {\n        if (!gaugeManager.activeGaugeFactories(BaseV2GaugeFactory(msg.sender))) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/rewards/base/FlywheelCore.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by Tribe DAO Contracts (flywheel-v2/src/FlywheelCore.sol)\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IFlywheelBooster} from \"../interfaces/IFlywheelBooster.sol\";\nimport {IFlywheelCore} from \"../interfaces/IFlywheelCore.sol\";\n\n/// @title Flywheel Core Incentives Manager\nabstract contract FlywheelCore is Ownable, IFlywheelCore {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                        FLYWHEEL CORE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelCore\n    address public immutable override rewardToken;\n\n    /// @inheritdoc IFlywheelCore\n    ERC20[] public override allStrategies;\n\n    /// @inheritdoc IFlywheelCore\n    mapping(ERC20 => uint256) public override strategyIds;\n\n    /// @inheritdoc IFlywheelCore\n    address public override flywheelRewards;\n\n    /// @inheritdoc IFlywheelCore\n    IFlywheelBooster public override flywheelBooster;\n\n    /**\n     * @notice Flywheel Core constructor.\n     *  @param _rewardToken the reward token\n     *  @param _flywheelRewards the flywheel rewards contract\n     *  @param _flywheelBooster the flywheel booster contract\n     *  @param _owner the owner of this contract\n     */\n    constructor(address _rewardToken, address _flywheelRewards, IFlywheelBooster _flywheelBooster, address _owner) {\n        _initializeOwner(_owner);\n        rewardToken = _rewardToken;\n        flywheelRewards = _flywheelRewards;\n        flywheelBooster = _flywheelBooster;\n    }\n\n    /// @inheritdoc IFlywheelCore\n    function getAllStrategies() external view returns (ERC20[] memory) {\n        return allStrategies;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ACCRUE/CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelCore\n    mapping(address => uint256) public override rewardsAccrued;\n\n    /// @inheritdoc IFlywheelCore\n    function accrue(address user) external returns (uint256) {\n        return _accrue(ERC20(msg.sender), user);\n    }\n\n    /// @inheritdoc IFlywheelCore\n    function accrue(ERC20 strategy, address user) external returns (uint256) {\n        return _accrue(strategy, user);\n    }\n\n    function _accrue(ERC20 strategy, address user) internal returns (uint256) {\n        uint256 index = strategyIndex[strategy];\n\n        if (index == 0) return 0;\n\n        index = accrueStrategy(strategy, index);\n        return accrueUser(strategy, user, index);\n    }\n\n    /// @inheritdoc IFlywheelCore\n    function accrue(ERC20 strategy, address user, address secondUser) public returns (uint256, uint256) {\n        uint256 index = strategyIndex[strategy];\n\n        if (index == 0) return (0, 0);\n\n        index = accrueStrategy(strategy, index);\n        return (accrueUser(strategy, user, index), accrueUser(strategy, secondUser, index));\n    }\n\n    /// @inheritdoc IFlywheelCore\n    function claimRewards(address user) external {\n        uint256 accrued = rewardsAccrued[user];\n\n        if (accrued != 0) {\n            rewardsAccrued[user] = 0;\n\n            rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);\n\n            emit ClaimRewards(user, accrued);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelCore\n    function addStrategyForRewards(ERC20 strategy) external onlyOwner {\n        _addStrategyForRewards(strategy);\n    }\n\n    function _addStrategyForRewards(ERC20 strategy) internal {\n        require(strategyIndex[strategy] == 0, \"strategy\");\n        strategyIndex[strategy] = ONE;\n\n        strategyIds[strategy] = allStrategies.length;\n        allStrategies.push(strategy);\n        emit AddStrategy(address(strategy));\n    }\n\n    /// @inheritdoc IFlywheelCore\n    function setFlywheelRewards(address newFlywheelRewards) external onlyOwner {\n        uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\n        if (oldRewardBalance > 0) {\n            rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\n        }\n\n        flywheelRewards = newFlywheelRewards;\n\n        emit FlywheelRewardsUpdate(address(newFlywheelRewards));\n    }\n\n    /// @inheritdoc IFlywheelCore\n    function setBooster(IFlywheelBooster newBooster) external onlyOwner {\n        flywheelBooster = newBooster;\n\n        emit FlywheelBoosterUpdate(address(newBooster));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INTERNAL ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice the fixed point factor of flywheel\n    uint256 private constant ONE = 1e18;\n\n    /// @inheritdoc IFlywheelCore\n    mapping(ERC20 => uint256) public strategyIndex;\n\n    /// @inheritdoc IFlywheelCore\n    mapping(ERC20 => mapping(address => uint256)) public userIndex;\n\n    /// @notice accumulate global rewards on a strategy\n    function accrueStrategy(ERC20 strategy, uint256 state) private returns (uint256 rewardsIndex) {\n        // calculate accrued rewards through rewards module\n        uint256 strategyRewardsAccrued = _getAccruedRewards(strategy);\n\n        rewardsIndex = state;\n        if (strategyRewardsAccrued > 0) {\n            // use the booster or token supply to calculate the reward index denominator\n            uint256 supplyTokens = address(flywheelBooster) != address(0)\n                ? flywheelBooster.boostedTotalSupply(strategy)\n                : strategy.totalSupply();\n\n            uint224 deltaIndex;\n\n            if (supplyTokens != 0) {\n                deltaIndex = ((strategyRewardsAccrued * ONE) / supplyTokens).toUint224();\n            }\n\n            // accumulate rewards per token onto the index, multiplied by a fixed-point factor\n            rewardsIndex += deltaIndex;\n            strategyIndex[strategy] = rewardsIndex;\n        }\n    }\n\n    /// @notice accumulate rewards on a strategy for a specific user\n    function accrueUser(ERC20 strategy, address user, uint256 index) private returns (uint256) {\n        // load indices\n        uint256 supplierIndex = userIndex[strategy][user];\n\n        // sync user index to global\n        userIndex[strategy][user] = index;\n\n        // if user hasn't yet accrued rewards, grant them interest from the strategy beginning if they have a balance\n        // zero balances will have no effect other than syncing to global index\n        if (supplierIndex == 0) {\n            supplierIndex = ONE;\n        }\n\n        uint256 deltaIndex = index - supplierIndex;\n        // use the booster or token balance to calculate reward balance multiplier\n        uint256 supplierTokens = address(flywheelBooster) != address(0)\n            ? flywheelBooster.boostedBalanceOf(strategy, user)\n            : strategy.balanceOf(user);\n\n        // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\n        uint256 supplierDelta = (supplierTokens * deltaIndex) / ONE;\n        uint256 supplierAccrued = rewardsAccrued[user] + supplierDelta;\n\n        rewardsAccrued[user] = supplierAccrued;\n\n        emit AccrueRewards(strategy, user, supplierDelta, index);\n\n        return supplierAccrued;\n    }\n\n    function _getAccruedRewards(ERC20 strategy) internal virtual returns (uint256);\n}"
    },
    {
      "filename": "src/tokens/ERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}"
    },
    {
      "filename": "contracts/token/ERC20/ERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}"
    }
  ]
}