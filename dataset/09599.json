{
  "Title": "[M-06] `NonCustodialPSM` can become insolvent as CPI index rises",
  "Content": "_Submitted by hyh_\n\n[NonCustodialPSM.sol#L236-L248](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/peg/NonCustodialPSM.sol#L236-L248)<br>\n\nNonCustodialPSM mints and redeems VOLT to a chosen stablecoin at the current market rate minus a fixed fee. It is assumed that the difference to be covered with pcvDeposit funds. That assumption is similar to one used in FEI protocol, but there no rate growth takes place as FEI to USD rate supposed to be stable, while VOLT to USD rate will rise over time.\n\nVOLT market rate is tied to the off-chain published CPI index. The growth of this index can easily surpass the yield of the pcvDeposit used, so its interest cannot be guaranteed to be always greater than CPI index advancement. The contract can end up in the situation when no redeem be possible, i.e. NonCustodialPSM can become insolvent.\n\nFor example, let's say the stablecoin is USDC, and now investors are worried about inflation and buy/mint 100m VOLT for 100m USDC. Fast forward 1 year, and investors were generally right, as due to rise of the oil prices happening simultaneously with logistics issues the CPI index growth end up being 30% APR for the year.\n\nThen, inflation fears abated and, say, stocks become stronger, and investors want their funds now to put them there and sell/redeem 100m VOLT expecting 125m USDC in return (for simplicity say 5m USDC goes to mint and redeem fees combined). USDC deposit strategy used in pcvDeposit yielded 10% APR for the year. The contract cannot redeem all the funds due as it is 125 - 100 \\* 1.1 = 15m USDC short.\n\nPutting severity to high as the contract serves requests sequentially and the last investors' funds are lost this way, i.e. in the example above all the users, who came in to redeem when contract has 15m USDC in obligations and no funds, will lose their entire deposits.\n\n### Proof of Concept\n\nContinuing the example, current low risk USDC deposit rates are circa 2.5 lower than US CPI:\n\nAAVE: <https://classic.aave.com/#/markets>\n\nCompound: <https://compound.finance/markets/USDC>\n\nUS CPI: <https://www.bls.gov/cpi/>\n\nNonCustodialPSM.redeem uses current oracle price to determine what amount of stablecoins to be paid for 1 VOLT:\n\n<https://github.com/code-423n4/2022-03-volt/blob/main/contracts/peg/NonCustodialPSM.sol#L236>\n\n<https://github.com/code-423n4/2022-03-volt/blob/main/contracts/peg/NonCustodialPSM.sol#L378-L390>\n\nNonCustodialPSM.mint does the same:\n\n<https://github.com/code-423n4/2022-03-volt/blob/main/contracts/peg/NonCustodialPSM.sol#L274>\n\n<https://github.com/code-423n4/2022-03-volt/blob/main/contracts/peg/NonCustodialPSM.sol#L357-L365>\n\nFor example, FEI protocol use a wide range of pcvDeposits, whose yields vary depending on the underlying strategy:\n\n<https://github.com/fei-protocol/fei-protocol-core/blob/develop/protocol-configuration/mainnetAddresses.ts#L164-L568>\n\nBut there are no PCV deposits whose returns are linked to CPI of any country, so mismatch (basis) risk exists, which has to be addressed.\n\n### Recommended Mitigation Steps\n\nConsider providing a way to directly inject funds from a separately held stability fund (possibly shared across all the stablecoins and corresponding pcvDeposits) in addition to pcvDeposit as its strategy alone cannot guarantee the returns needed.\n\nIdeally, the redeem and mint fees collected should go to this stability fund as well, with the possibility to retrieve them when there is a total surplus big enough.\n\nMore important, consider limiting the redeem amount to total user's share of the pcvDeposit and its stability fund part, so the deficit be visible and shared between all the users. A user can then choose either to withdraw now, obtaining less than CPI index due to current liquidity situation, or to wait for stability fund to be filled up or for pcvDeposit yield to catch up. This way no user will lose the whole deposit.\n\n**[ElliotFriedman (Volt) disputed, disagreed with High severity, and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/83#issuecomment-1091995380):**\n > There is a risk of the system not being able to make everyone whole if the PCV grows too rapidly and onchain yields cannot keep up with or outcompete inflation; however, this is not a code issue, so marking as invalid.\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-03-volt-findings/issues/83#issuecomment-1104682677):**\n > This is a valid concern. The warden explained why it's possible to happen and how the current implementation handled it improperly, which can make some of the users suffer an unexpected and unfair loss.\n> \n> The recommended fix is reasonable.\n> \n> I'll keep this as a `High`.\n\n**[ElliotFriedman (Volt) commented](https://github.com/code-423n4/2022-03-volt-findings/issues/83#issuecomment-1120046828):**\n > There is a 10m FEI liquidity backstop provided by the Tribe DAO, so the system would need to be live for many years without earning any yield to finally become insolvent.\n\n**[Jack the Pug (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/83#issuecomment-1120441273):**\n > With the new information provided by the sponsor, I now agree that the likelihood of the situation described by the warden is low. And therefore, I'm downgrading the issue from High to Medium.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-volt-protocol-contest",
  "Code": [
    {
      "filename": "contracts/peg/NonCustodialPSM.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Decimal} from \"../external/Decimal.sol\";\nimport {Constants} from \"../Constants.sol\";\nimport {OracleRef} from \"./../refs/OracleRef.sol\";\nimport {TribeRoles} from \"./../core/TribeRoles.sol\";\nimport {RateLimited} from \"./../utils/RateLimited.sol\";\nimport {IPCVDeposit, PCVDeposit} from \"./../pcv/PCVDeposit.sol\";\nimport {INonCustodialPSM} from \"./INonCustodialPSM.sol\";\nimport {GlobalRateLimitedMinter} from \"./../utils/GlobalRateLimitedMinter.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @notice Peg Stability Module that holds no funds.\n/// On a mint, it transfers all proceeds to a PCV Deposit\n/// When funds are needed for a redemption, they are simply pulled from the PCV Deposit\ncontract NonCustodialPSM is\n    OracleRef,\n    RateLimited,\n    ReentrancyGuard,\n    INonCustodialPSM\n{\n    using Decimal for Decimal.D256;\n    using SafeCast for *;\n    using SafeERC20 for IERC20;\n\n    /// @notice the fee in basis points for selling an asset into VOLT\n    uint256 public override mintFeeBasisPoints;\n\n    /// @notice the fee in basis points for buying the asset for VOLT\n    uint256 public override redeemFeeBasisPoints;\n\n    /// @notice the PCV deposit target to deposit and withdraw from\n    IPCVDeposit public override pcvDeposit;\n\n    /// @notice the token this PSM will exchange for VOLT\n    /// Must be a stable token pegged to $1\n    IERC20 public immutable override underlyingToken;\n\n    /// @notice Rate Limited Minter contract that will be called when VOLT needs to be minted\n    GlobalRateLimitedMinter public override rateLimitedMinter;\n\n    /// @notice the max mint and redeem fee in basis points\n    /// Governance cannot change the maximum fee\n    uint256 public immutable override MAX_FEE = 300;\n\n    /// @notice boolean switch that indicates whether redeeming is paused\n    bool public redeemPaused;\n\n    /// @notice boolean switch that indicates whether minting is paused\n    bool public mintPaused;\n\n    /// @notice struct for passing constructor parameters related to OracleRef\n    struct OracleParams {\n        address coreAddress;\n        address oracleAddress;\n        address backupOracle;\n        int256 decimalsNormalizer;\n    }\n\n    /// @notice struct for passing constructor parameters related to MultiRateLimited\n    struct RateLimitedParams {\n        uint256 maxRateLimitPerSecond;\n        uint256 rateLimitPerSecond;\n        uint256 bufferCap;\n    }\n\n    /// @notice struct for passing constructor parameters related to the non custodial PSM\n    struct PSMParams {\n        uint256 mintFeeBasisPoints;\n        uint256 redeemFeeBasisPoints;\n        IERC20 underlyingToken;\n        IPCVDeposit pcvDeposit;\n        GlobalRateLimitedMinter rateLimitedMinter;\n    }\n\n    /// @notice construct the non custodial PSM. Structs are used to prevent stack too deep errors\n    /// @param params oracle ref constructor data\n    /// @param rateLimitedParams rate limited constructor data\n    /// @param psmParams non custodial PSM constructor data\n    constructor(\n        OracleParams memory params,\n        RateLimitedParams memory rateLimitedParams,\n        PSMParams memory psmParams\n    )\n        OracleRef(\n            params.coreAddress,\n            params.oracleAddress,\n            params.backupOracle,\n            params.decimalsNormalizer,\n            true /// hardcode doInvert to true to allow swaps to work correctly\n        )\n        /// rate limited replenishable passes false as the last param as there can be no partial actions\n        RateLimited(\n            rateLimitedParams.maxRateLimitPerSecond,\n            rateLimitedParams.rateLimitPerSecond,\n            rateLimitedParams.bufferCap,\n            false\n        )\n    {\n        underlyingToken = psmParams.underlyingToken;\n\n        _setGlobalRateLimitedMinter(psmParams.rateLimitedMinter);\n        _setMintFee(psmParams.mintFeeBasisPoints);\n        _setRedeemFee(psmParams.redeemFeeBasisPoints);\n        _setPCVDeposit(psmParams.pcvDeposit);\n    }\n\n    // ----------- Mint & Redeem pausing modifiers -----------\n\n    /// @notice modifier that allows execution when redemptions are not paused\n    modifier whileRedemptionsNotPaused() {\n        require(!redeemPaused, \"PegStabilityModule: Redeem paused\");\n        _;\n    }\n\n    /// @notice modifier that allows execution when minting is not paused\n    modifier whileMintingNotPaused() {\n        require(!mintPaused, \"PegStabilityModule: Minting paused\");\n        _;\n    }\n\n    // ----------- Governor & Guardian only pausing api -----------\n\n    /// @notice set secondary pausable methods to paused\n    function pauseRedeem() external onlyGuardianOrGovernor {\n        redeemPaused = true;\n        emit RedemptionsPaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to unpaused\n    function unpauseRedeem() external onlyGuardianOrGovernor {\n        redeemPaused = false;\n        emit RedemptionsUnpaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to paused\n    function pauseMint() external onlyGuardianOrGovernor {\n        mintPaused = true;\n        emit MintingPaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to unpaused\n    function unpauseMint() external onlyGuardianOrGovernor {\n        mintPaused = false;\n        emit MintingUnpaused(msg.sender);\n    }\n\n    // ----------- Governor, psm admin and parameter admin only state changing api -----------\n\n    /// @notice set the mint fee vs oracle price in basis point terms\n    /// @param newMintFeeBasisPoints the new fee in basis points for minting\n    function setMintFee(uint256 newMintFeeBasisPoints)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)\n    {\n        _setMintFee(newMintFeeBasisPoints);\n    }\n\n    /// @notice set the redemption fee vs oracle price in basis point terms\n    /// @param newRedeemFeeBasisPoints the new fee in basis points for redemptions\n    function setRedeemFee(uint256 newRedeemFeeBasisPoints)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)\n    {\n        _setRedeemFee(newRedeemFeeBasisPoints);\n    }\n\n    /// @notice set the target for sending all PCV\n    /// @param newTarget new PCV Deposit target for this PSM\n    function setPCVDeposit(IPCVDeposit newTarget)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)\n    {\n        _setPCVDeposit(newTarget);\n    }\n\n    /// @notice set the target to call for VOLT minting\n    /// @param newMinter new Global Rate Limited Minter for this PSM\n    function setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)\n    {\n        _setGlobalRateLimitedMinter(newMinter);\n    }\n\n    // ----------- PCV Controller only state changing api -----------\n\n    /// @notice withdraw ERC20 from the contract\n    /// @param token address of the ERC20 to send\n    /// @param to address destination of the ERC20\n    /// @param amount quantity of ERC20 to send\n    function withdrawERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyPCVController {\n        IERC20(token).safeTransfer(to, amount);\n        emit WithdrawERC20(msg.sender, token, to, amount);\n    }\n\n    // ----------- Public State Changing API -----------\n\n    /// @notice function to redeem VOLT for an underlying asset\n    /// We do not burn VOLT; this allows the contract's balance of VOLT to be used before the buffer is used\n    /// In practice, this helps prevent artificial cycling of mint-burn cycles and prevents DOS attacks.\n    /// This function will deplete the buffer based on the amount of VOLT that is being redeemed.\n    /// @param to the destination address for proceeds\n    /// @param amountVoltIn the amount of VOLT to sell\n    /// @param minAmountOut the minimum amount out otherwise the TX will fail\n    function redeem(\n        address to,\n        uint256 amountVoltIn,\n        uint256 minAmountOut\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        whileRedemptionsNotPaused\n        returns (uint256 amountOut)\n    {\n        _depleteBuffer(amountVoltIn); /// deplete buffer first to save gas on buffer exhaustion sad path\n\n        updateOracle();\n\n        amountOut = _getRedeemAmountOut(amountVoltIn);\n        require(\n            amountOut >= minAmountOut,\n            \"PegStabilityModule: Redeem not enough out\"\n        );\n\n        IERC20(volt()).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountVoltIn\n        );\n\n        pcvDeposit.withdraw(to, amountOut);\n\n        emit Redeem(to, amountVoltIn, amountOut);\n    }\n\n    /// @notice function to buy VOLT for an underlying asset that is pegged to $1\n    /// We first transfer any contract-owned VOLT, then mint the remaining if necessary\n    /// This function will replenish the buffer based on the amount of VOLT that is being sent out.\n    /// @param to the destination address for proceeds\n    /// @param amountIn the amount of external asset to sell to the PSM\n    /// @param minVoltAmountOut the minimum amount of VOLT out otherwise the TX will fail\n    function mint(\n        address to,\n        uint256 amountIn,\n        uint256 minVoltAmountOut\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        whileMintingNotPaused\n        returns (uint256 amountVoltOut)\n    {\n        updateOracle();\n\n        amountVoltOut = _getMintAmountOut(amountIn);\n        require(\n            amountVoltOut >= minVoltAmountOut,\n            \"PegStabilityModule: Mint not enough out\"\n        );\n\n        underlyingToken.safeTransferFrom(\n            msg.sender,\n            address(pcvDeposit),\n            amountIn\n        );\n\n        uint256 amountFeiToTransfer = Math.min(\n            volt().balanceOf(address(this)),\n            amountVoltOut\n        );\n        uint256 amountFeiToMint = amountVoltOut - amountFeiToTransfer;\n\n        if (amountFeiToTransfer != 0) {\n            IERC20(volt()).safeTransfer(to, amountFeiToTransfer);\n        }\n\n        if (amountFeiToMint != 0) {\n            rateLimitedMinter.mintVolt(to, amountFeiToMint);\n        }\n\n        _replenishBuffer(amountVoltOut);\n\n        emit Mint(to, amountIn, amountVoltOut);\n    }\n\n    // ----------- Public View-Only API ----------\n\n    /// @notice calculate the amount of VOLT out for a given `amountIn` of underlying\n    /// First get oracle price of token\n    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.\n    /// ensure decimals are normalized if on underlying they are not 18\n    /// @param amountIn the amount of external asset to sell to the PSM\n    /// @return amountVoltOut the amount of VOLT received for the amountIn of external asset\n    function getMintAmountOut(uint256 amountIn)\n        public\n        view\n        override\n        returns (uint256 amountVoltOut)\n    {\n        amountVoltOut = _getMintAmountOut(amountIn);\n    }\n\n    /// @notice calculate the amount of underlying out for a given `amountVoltIn` of VOLT\n    /// First get oracle price of token\n    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.\n    /// ensure decimals are normalized if on underlying they are not 18\n    /// @param amountVoltIn the amount of VOLT to redeem\n    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed\n    function getRedeemAmountOut(uint256 amountVoltIn)\n        public\n        view\n        override\n        returns (uint256 amountTokenOut)\n    {\n        amountTokenOut = _getRedeemAmountOut(amountVoltIn);\n    }\n\n    /// @notice getter to return the maximum amount of VOLT that could be purchased at once\n    /// @return the maximum amount of VOLT available for purchase at once through this PSM\n    function getMaxMintAmountOut() external view override returns (uint256) {\n        return\n            volt().balanceOf(address(this)) +\n            rateLimitedMinter.individualBuffer(address(this));\n    }\n\n    // ----------- Internal Methods -----------\n\n    /// @notice helper function to get mint amount out based on current market prices\n    /// @dev will revert if price is outside of bounds and price bound PSM is being used\n    /// @param amountIn the amount of stable asset in\n    /// @return amountVoltOut the amount of VOLT received for the amountIn of stable assets\n    function _getMintAmountOut(uint256 amountIn)\n        internal\n        view\n        virtual\n        returns (uint256 amountVoltOut)\n    {\n        Decimal.D256 memory price = readOracle();\n        _validatePriceRange(price);\n\n        Decimal.D256 memory adjustedAmountIn = price.mul(amountIn);\n\n        amountVoltOut = adjustedAmountIn\n            .mul(Constants.BASIS_POINTS_GRANULARITY - mintFeeBasisPoints)\n            .div(Constants.BASIS_POINTS_GRANULARITY)\n            .asUint256();\n    }\n\n    /// @notice helper function to get redeem amount out based on current market prices\n    /// @dev will revert if price is outside of bounds and price bound PSM is being used\n    /// @param amountVoltIn the amount of VOLT to redeem\n    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed\n    function _getRedeemAmountOut(uint256 amountVoltIn)\n        internal\n        view\n        virtual\n        returns (uint256 amountTokenOut)\n    {\n        Decimal.D256 memory price = readOracle();\n        _validatePriceRange(price);\n\n        /// get amount of VOLT being provided being redeemed after fees\n        Decimal.D256 memory adjustedAmountIn = Decimal.from(\n            (amountVoltIn *\n                (Constants.BASIS_POINTS_GRANULARITY - redeemFeeBasisPoints)) /\n                Constants.BASIS_POINTS_GRANULARITY\n        );\n\n        /// now turn the VOLT into the underlying token amounts\n        /// amount VOLT in / VOLT you receive for $1 = how much stable token to pay out\n        amountTokenOut = adjustedAmountIn.div(price).asUint256();\n    }\n\n    // ----------- Helper methods to change state -----------\n\n    /// @notice set the global rate limited minter this PSM calls to mint VOLT\n    /// @param newMinter the new minter contract that this PSM will reference\n    function _setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)\n        internal\n    {\n        require(\n            address(newMinter) != address(0),\n            \"PegStabilityModule: Invalid new GlobalRateLimitedMinter\"\n        );\n        GlobalRateLimitedMinter oldMinter = rateLimitedMinter;\n        rateLimitedMinter = newMinter;\n\n        emit GlobalRateLimitedMinterUpdate(oldMinter, newMinter);\n    }\n\n    /// @notice set the mint fee vs oracle price in basis point terms\n    /// @param newMintFeeBasisPoints the new fee for minting in basis points\n    function _setMintFee(uint256 newMintFeeBasisPoints) internal {\n        require(\n            newMintFeeBasisPoints <= MAX_FEE,\n            \"PegStabilityModule: Mint fee exceeds max fee\"\n        );\n        uint256 _oldMintFee = mintFeeBasisPoints;\n        mintFeeBasisPoints = newMintFeeBasisPoints;\n\n        emit MintFeeUpdate(_oldMintFee, newMintFeeBasisPoints);\n    }\n\n    /// @notice internal helper function to set the redemption fee\n    /// @param newRedeemFeeBasisPoints the new fee for redemptions in basis points\n    function _setRedeemFee(uint256 newRedeemFeeBasisPoints) internal {\n        require(\n            newRedeemFeeBasisPoints <= MAX_FEE,\n            \"PegStabilityModule: Redeem fee exceeds max fee\"\n        );\n        uint256 _oldRedeemFee = redeemFeeBasisPoints;\n        redeemFeeBasisPoints = newRedeemFeeBasisPoints;\n\n        emit RedeemFeeUpdate(_oldRedeemFee, newRedeemFeeBasisPoints);\n    }\n\n    /// @notice helper function to set the PCV deposit\n    /// @param newPCVDeposit the new PCV deposit that this PSM will pull assets from and deposit assets into\n    function _setPCVDeposit(IPCVDeposit newPCVDeposit) internal {\n        require(\n            address(newPCVDeposit) != address(0),\n            \"PegStabilityModule: Invalid new PCVDeposit\"\n        );\n        require(\n            newPCVDeposit.balanceReportedIn() == address(underlyingToken),\n            \"PegStabilityModule: Underlying token mismatch\"\n        );\n        IPCVDeposit oldTarget = pcvDeposit;\n        pcvDeposit = newPCVDeposit;\n\n        emit PCVDepositUpdate(oldTarget, newPCVDeposit);\n    }\n\n    // ----------- Hooks -----------\n\n    /// @notice overriden function in the price bound PSM\n    function _validatePriceRange(Decimal.D256 memory price)\n        internal\n        view\n        virtual\n    {}\n}"
    },
    {
      "filename": "contracts/peg/NonCustodialPSM.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Decimal} from \"../external/Decimal.sol\";\nimport {Constants} from \"../Constants.sol\";\nimport {OracleRef} from \"./../refs/OracleRef.sol\";\nimport {TribeRoles} from \"./../core/TribeRoles.sol\";\nimport {RateLimited} from \"./../utils/RateLimited.sol\";\nimport {IPCVDeposit, PCVDeposit} from \"./../pcv/PCVDeposit.sol\";\nimport {INonCustodialPSM} from \"./INonCustodialPSM.sol\";\nimport {GlobalRateLimitedMinter} from \"./../utils/GlobalRateLimitedMinter.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @notice Peg Stability Module that holds no funds.\n/// On a mint, it transfers all proceeds to a PCV Deposit\n/// When funds are needed for a redemption, they are simply pulled from the PCV Deposit\ncontract NonCustodialPSM is\n    OracleRef,\n    RateLimited,\n    ReentrancyGuard,\n    INonCustodialPSM\n{\n    using Decimal for Decimal.D256;\n    using SafeCast for *;\n    using SafeERC20 for IERC20;\n\n    /// @notice the fee in basis points for selling an asset into VOLT\n    uint256 public override mintFeeBasisPoints;\n\n    /// @notice the fee in basis points for buying the asset for VOLT\n    uint256 public override redeemFeeBasisPoints;\n\n    /// @notice the PCV deposit target to deposit and withdraw from\n    IPCVDeposit public override pcvDeposit;\n\n    /// @notice the token this PSM will exchange for VOLT\n    /// Must be a stable token pegged to $1\n    IERC20 public immutable override underlyingToken;\n\n    /// @notice Rate Limited Minter contract that will be called when VOLT needs to be minted\n    GlobalRateLimitedMinter public override rateLimitedMinter;\n\n    /// @notice the max mint and redeem fee in basis points\n    /// Governance cannot change the maximum fee\n    uint256 public immutable override MAX_FEE = 300;\n\n    /// @notice boolean switch that indicates whether redeeming is paused\n    bool public redeemPaused;\n\n    /// @notice boolean switch that indicates whether minting is paused\n    bool public mintPaused;\n\n    /// @notice struct for passing constructor parameters related to OracleRef\n    struct OracleParams {\n        address coreAddress;\n        address oracleAddress;\n        address backupOracle;\n        int256 decimalsNormalizer;\n    }\n\n    /// @notice struct for passing constructor parameters related to MultiRateLimited\n    struct RateLimitedParams {\n        uint256 maxRateLimitPerSecond;\n        uint256 rateLimitPerSecond;\n        uint256 bufferCap;\n    }\n\n    /// @notice struct for passing constructor parameters related to the non custodial PSM\n    struct PSMParams {\n        uint256 mintFeeBasisPoints;\n        uint256 redeemFeeBasisPoints;\n        IERC20 underlyingToken;\n        IPCVDeposit pcvDeposit;\n        GlobalRateLimitedMinter rateLimitedMinter;\n    }\n\n    /// @notice construct the non custodial PSM. Structs are used to prevent stack too deep errors\n    /// @param params oracle ref constructor data\n    /// @param rateLimitedParams rate limited constructor data\n    /// @param psmParams non custodial PSM constructor data\n    constructor(\n        OracleParams memory params,\n        RateLimitedParams memory rateLimitedParams,\n        PSMParams memory psmParams\n    )\n        OracleRef(\n            params.coreAddress,\n            params.oracleAddress,\n            params.backupOracle,\n            params.decimalsNormalizer,\n            true /// hardcode doInvert to true to allow swaps to work correctly\n        )\n        /// rate limited replenishable passes false as the last param as there can be no partial actions\n        RateLimited(\n            rateLimitedParams.maxRateLimitPerSecond,\n            rateLimitedParams.rateLimitPerSecond,\n            rateLimitedParams.bufferCap,\n            false\n        )\n    {\n        underlyingToken = psmParams.underlyingToken;\n\n        _setGlobalRateLimitedMinter(psmParams.rateLimitedMinter);\n        _setMintFee(psmParams.mintFeeBasisPoints);\n        _setRedeemFee(psmParams.redeemFeeBasisPoints);\n        _setPCVDeposit(psmParams.pcvDeposit);\n    }\n\n    // ----------- Mint & Redeem pausing modifiers -----------\n\n    /// @notice modifier that allows execution when redemptions are not paused\n    modifier whileRedemptionsNotPaused() {\n        require(!redeemPaused, \"PegStabilityModule: Redeem paused\");\n        _;\n    }\n\n    /// @notice modifier that allows execution when minting is not paused\n    modifier whileMintingNotPaused() {\n        require(!mintPaused, \"PegStabilityModule: Minting paused\");\n        _;\n    }\n\n    // ----------- Governor & Guardian only pausing api -----------\n\n    /// @notice set secondary pausable methods to paused\n    function pauseRedeem() external onlyGuardianOrGovernor {\n        redeemPaused = true;\n        emit RedemptionsPaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to unpaused\n    function unpauseRedeem() external onlyGuardianOrGovernor {\n        redeemPaused = false;\n        emit RedemptionsUnpaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to paused\n    function pauseMint() external onlyGuardianOrGovernor {\n        mintPaused = true;\n        emit MintingPaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to unpaused\n    function unpauseMint() external onlyGuardianOrGovernor {\n        mintPaused = false;\n        emit MintingUnpaused(msg.sender);\n    }\n\n    // ----------- Governor, psm admin and parameter admin only state changing api -----------\n\n    /// @notice set the mint fee vs oracle price in basis point terms\n    /// @param newMintFeeBasisPoints the new fee in basis points for minting\n    function setMintFee(uint256 newMintFeeBasisPoints)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)\n    {\n        _setMintFee(newMintFeeBasisPoints);\n    }\n\n    /// @notice set the redemption fee vs oracle price in basis point terms\n    /// @param newRedeemFeeBasisPoints the new fee in basis points for redemptions\n    function setRedeemFee(uint256 newRedeemFeeBasisPoints)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)\n    {\n        _setRedeemFee(newRedeemFeeBasisPoints);\n    }\n\n    /// @notice set the target for sending all PCV\n    /// @param newTarget new PCV Deposit target for this PSM\n    function setPCVDeposit(IPCVDeposit newTarget)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)\n    {\n        _setPCVDeposit(newTarget);\n    }\n\n    /// @notice set the target to call for VOLT minting\n    /// @param newMinter new Global Rate Limited Minter for this PSM\n    function setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)\n    {\n        _setGlobalRateLimitedMinter(newMinter);\n    }\n\n    // ----------- PCV Controller only state changing api -----------\n\n    /// @notice withdraw ERC20 from the contract\n    /// @param token address of the ERC20 to send\n    /// @param to address destination of the ERC20\n    /// @param amount quantity of ERC20 to send\n    function withdrawERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyPCVController {\n        IERC20(token).safeTransfer(to, amount);\n        emit WithdrawERC20(msg.sender, token, to, amount);\n    }\n\n    // ----------- Public State Changing API -----------\n\n    /// @notice function to redeem VOLT for an underlying asset\n    /// We do not burn VOLT; this allows the contract's balance of VOLT to be used before the buffer is used\n    /// In practice, this helps prevent artificial cycling of mint-burn cycles and prevents DOS attacks.\n    /// This function will deplete the buffer based on the amount of VOLT that is being redeemed.\n    /// @param to the destination address for proceeds\n    /// @param amountVoltIn the amount of VOLT to sell\n    /// @param minAmountOut the minimum amount out otherwise the TX will fail\n    function redeem(\n        address to,\n        uint256 amountVoltIn,\n        uint256 minAmountOut\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        whileRedemptionsNotPaused\n        returns (uint256 amountOut)\n    {\n        _depleteBuffer(amountVoltIn); /// deplete buffer first to save gas on buffer exhaustion sad path\n\n        updateOracle();\n\n        amountOut = _getRedeemAmountOut(amountVoltIn);\n        require(\n            amountOut >= minAmountOut,\n            \"PegStabilityModule: Redeem not enough out\"\n        );\n\n        IERC20(volt()).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountVoltIn\n        );\n\n        pcvDeposit.withdraw(to, amountOut);\n\n        emit Redeem(to, amountVoltIn, amountOut);\n    }\n\n    /// @notice function to buy VOLT for an underlying asset that is pegged to $1\n    /// We first transfer any contract-owned VOLT, then mint the remaining if necessary\n    /// This function will replenish the buffer based on the amount of VOLT that is being sent out.\n    /// @param to the destination address for proceeds\n    /// @param amountIn the amount of external asset to sell to the PSM\n    /// @param minVoltAmountOut the minimum amount of VOLT out otherwise the TX will fail\n    function mint(\n        address to,\n        uint256 amountIn,\n        uint256 minVoltAmountOut\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        whileMintingNotPaused\n        returns (uint256 amountVoltOut)\n    {\n        updateOracle();\n\n        amountVoltOut = _getMintAmountOut(amountIn);\n        require(\n            amountVoltOut >= minVoltAmountOut,\n            \"PegStabilityModule: Mint not enough out\"\n        );\n\n        underlyingToken.safeTransferFrom(\n            msg.sender,\n            address(pcvDeposit),\n            amountIn\n        );\n\n        uint256 amountFeiToTransfer = Math.min(\n            volt().balanceOf(address(this)),\n            amountVoltOut\n        );\n        uint256 amountFeiToMint = amountVoltOut - amountFeiToTransfer;\n\n        if (amountFeiToTransfer != 0) {\n            IERC20(volt()).safeTransfer(to, amountFeiToTransfer);\n        }\n\n        if (amountFeiToMint != 0) {\n            rateLimitedMinter.mintVolt(to, amountFeiToMint);\n        }\n\n        _replenishBuffer(amountVoltOut);\n\n        emit Mint(to, amountIn, amountVoltOut);\n    }\n\n    // ----------- Public View-Only API ----------\n\n    /// @notice calculate the amount of VOLT out for a given `amountIn` of underlying\n    /// First get oracle price of token\n    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.\n    /// ensure decimals are normalized if on underlying they are not 18\n    /// @param amountIn the amount of external asset to sell to the PSM\n    /// @return amountVoltOut the amount of VOLT received for the amountIn of external asset\n    function getMintAmountOut(uint256 amountIn)\n        public\n        view\n        override\n        returns (uint256 amountVoltOut)\n    {\n        amountVoltOut = _getMintAmountOut(amountIn);\n    }\n\n    /// @notice calculate the amount of underlying out for a given `amountVoltIn` of VOLT\n    /// First get oracle price of token\n    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.\n    /// ensure decimals are normalized if on underlying they are not 18\n    /// @param amountVoltIn the amount of VOLT to redeem\n    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed\n    function getRedeemAmountOut(uint256 amountVoltIn)\n        public\n        view\n        override\n        returns (uint256 amountTokenOut)\n    {\n        amountTokenOut = _getRedeemAmountOut(amountVoltIn);\n    }\n\n    /// @notice getter to return the maximum amount of VOLT that could be purchased at once\n    /// @return the maximum amount of VOLT available for purchase at once through this PSM\n    function getMaxMintAmountOut() external view override returns (uint256) {\n        return\n            volt().balanceOf(address(this)) +\n            rateLimitedMinter.individualBuffer(address(this));\n    }\n\n    // ----------- Internal Methods -----------\n\n    /// @notice helper function to get mint amount out based on current market prices\n    /// @dev will revert if price is outside of bounds and price bound PSM is being used\n    /// @param amountIn the amount of stable asset in\n    /// @return amountVoltOut the amount of VOLT received for the amountIn of stable assets\n    function _getMintAmountOut(uint256 amountIn)\n        internal\n        view\n        virtual\n        returns (uint256 amountVoltOut)\n    {\n        Decimal.D256 memory price = readOracle();\n        _validatePriceRange(price);\n\n        Decimal.D256 memory adjustedAmountIn = price.mul(amountIn);\n\n        amountVoltOut = adjustedAmountIn\n            .mul(Constants.BASIS_POINTS_GRANULARITY - mintFeeBasisPoints)\n            .div(Constants.BASIS_POINTS_GRANULARITY)\n            .asUint256();\n    }\n\n    /// @notice helper function to get redeem amount out based on current market prices\n    /// @dev will revert if price is outside of bounds and price bound PSM is being used\n    /// @param amountVoltIn the amount of VOLT to redeem\n    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed\n    function _getRedeemAmountOut(uint256 amountVoltIn)\n        internal\n        view\n        virtual\n        returns (uint256 amountTokenOut)\n    {\n        Decimal.D256 memory price = readOracle();\n        _validatePriceRange(price);\n\n        /// get amount of VOLT being provided being redeemed after fees\n        Decimal.D256 memory adjustedAmountIn = Decimal.from(\n            (amountVoltIn *\n                (Constants.BASIS_POINTS_GRANULARITY - redeemFeeBasisPoints)) /\n                Constants.BASIS_POINTS_GRANULARITY\n        );\n\n        /// now turn the VOLT into the underlying token amounts\n        /// amount VOLT in / VOLT you receive for $1 = how much stable token to pay out\n        amountTokenOut = adjustedAmountIn.div(price).asUint256();\n    }\n\n    // ----------- Helper methods to change state -----------\n\n    /// @notice set the global rate limited minter this PSM calls to mint VOLT\n    /// @param newMinter the new minter contract that this PSM will reference\n    function _setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)\n        internal\n    {\n        require(\n            address(newMinter) != address(0),\n            \"PegStabilityModule: Invalid new GlobalRateLimitedMinter\"\n        );\n        GlobalRateLimitedMinter oldMinter = rateLimitedMinter;\n        rateLimitedMinter = newMinter;\n\n        emit GlobalRateLimitedMinterUpdate(oldMinter, newMinter);\n    }\n\n    /// @notice set the mint fee vs oracle price in basis point terms\n    /// @param newMintFeeBasisPoints the new fee for minting in basis points\n    function _setMintFee(uint256 newMintFeeBasisPoints) internal {\n        require(\n            newMintFeeBasisPoints <= MAX_FEE,\n            \""
    }
  ]
}