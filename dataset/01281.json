{
  "Title": "M-1: During oracle provider switch, if previous provider feed stops working completely, oracle and market will be stuck with user funds locked in the contract",
  "Content": "# Issue M-1: During oracle provider switch, if previous provider feed stops working completely, oracle and market will be stuck with user funds locked in the contract \n\nSource: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/10 \n\n## Found by \npanprog\n\nThe [issue 46 of the main contest](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/46) after the fix still stands with a more severe condition as described by WatchPug in fix review:\n> If we assume it's possible for the previous Python feed to experience a more severe issue: instead of not having an eligible price for the requested oracleVersion, the feed completely stopped working after the requested time, making it impossible to find ANY valid price at a later time than the last requested time, this issue would still exist.\n\nSponsor response still implies that the previous provider feed **is available**, as they say non-requested version could be posted, but if this feed is no longer available, it will be impossible to commit unrequested, because there will be no pyth price and signature to commit.\n\n> if the previous oracleâ€™s underlying off-chain feed goes down permanently, once the grace period has passed, a non-requested version could be posted to the previous oracle, moving its latest() forward to that point, allowing the switchover to complete.\n\n## Vulnerability Detail\n\nWhen the oracle provider is updated (switched to a new provider), the latest status (price) returned by the oracle will come from the previous provider until the last request is commited for it, only then the price feed from the new provider will be used. However, it can happen that pyth price feed stops working completely before (or just after) the oracle is updated to a new provider. This means that valid price with signature for **any timestamp after the last request** is not available. In this case, the oracle price will be stuck, because it will ignore new provider, but the previous provider can never finalize (commit a fresh price). As such, the oracle price will get stuck and will never update, breaking the whole protocol with user funds stuck in the protocol.\n\n## Impact\n\nSwitching oracle provider can make the oracle stuck and stop updating new prices. This will mean the market will become stale and will revert on all requests from user, disallowing to withdraw funds, bricking the contract entirely.\n\n## Code Snippet\n\n`Oracle._latestStale` will always return false due to this line (since `latest().timestamp` can never advance without a price feed):\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/Oracle.sol#L128\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider ignoring line 128 in `Oracle._latestStale` if a certain timeout has passed after the switch (`block.timestamp - oracles[global.latest].timestamp > SWITCH_TIMEOUT`). This will allow the switch to proceed after some timeout even if previous provider remains uncommited.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**polarzero** commented:\n> Medium. The issue is also preoccupying. It does also require a few unlikely conditions, yet it could incur a significant loss of funds for the users.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/112",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/Oracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\";\nimport \"./interfaces/IOracle.sol\";\n\n/// @title Oracle\n/// @notice The top-level oracle contract that implements an oracle provider interface.\n/// @dev Manages swapping between different underlying oracle provider interfaces over time.\ncontract Oracle is IOracle, Instance {\n    /// @notice A historical mapping of underlying oracle providers\n    mapping(uint256 => Epoch) public oracles;\n\n    /// @notice The global state of the oracle\n    Global public global;\n\n    /// @notice Initializes the contract state\n    /// @param initialProvider The initial oracle provider\n    function initialize(IOracleProvider initialProvider) external initializer(1) {\n        __Instance__initialize();\n        _updateCurrent(initialProvider);\n        _updateLatest(initialProvider.latest());\n    }\n\n    /// @notice Updates the current oracle provider\n    /// @dev Both the current and new oracle provider must have the same current\n    /// @param newProvider The new oracle provider\n    function update(IOracleProvider newProvider) external {\n        if (msg.sender != address(factory())) revert OracleNotFactoryError();\n        _updateCurrent(newProvider);\n        _updateLatest(newProvider.latest());\n    }\n\n    /// @notice Requests a new version at the current timestamp\n    /// @param account Original sender to optionally use for callbacks\n    function request(address account) external onlyAuthorized {\n        (OracleVersion memory latestVersion, uint256 currentTimestamp) = oracles[global.current].provider.status();\n\n        oracles[\n            (currentTimestamp > oracles[global.latest].timestamp) ? global.current : global.latest\n        ].provider.request(account);\n\n        oracles[global.current].timestamp = uint96(currentTimestamp);\n        _updateLatest(latestVersion);\n    }\n\n    /// @notice Returns the latest committed version as well as the current timestamp\n    /// @return latestVersion The latest committed version\n    /// @return currentTimestamp The current timestamp\n    function status() external view returns (OracleVersion memory latestVersion, uint256 currentTimestamp) {\n        (latestVersion, currentTimestamp) = oracles[global.current].provider.status();\n        latestVersion = _handleLatest(latestVersion);\n    }\n\n    /// @notice Returns the latest committed version\n    function latest() public view returns (OracleVersion memory) {\n        return _handleLatest(oracles[global.current].provider.latest());\n    }\n\n    /// @notice Returns the current value\n    function current() public view returns (uint256) {\n        return oracles[global.current].provider.current();\n    }\n\n    /// @notice Returns the oracle version at a given timestamp\n    /// @param timestamp The timestamp to query\n    /// @return atVersion The oracle version at the given timestamp\n    function at(uint256 timestamp) public view returns (OracleVersion memory atVersion) {\n        if (timestamp == 0) return atVersion;\n        IOracleProvider provider = oracles[global.current].provider;\n        for (uint256 i = global.current - 1; i > 0; i--) {\n            if (timestamp > uint256(oracles[i].timestamp)) break;\n            provider = oracles[i].provider;\n        }\n        return provider.at(timestamp);\n    }\n\n    /// @notice Handles update the oracle to the new provider\n    /// @param newProvider The new oracle provider\n    function _updateCurrent(IOracleProvider newProvider) private {\n        // oracle must not already be updating\n        if (global.current != global.latest) revert OracleOutOfSyncError();\n\n        // if the latest version of the underlying oracle is further ahead than its latest request update its timestamp\n        if (global.current != 0) {\n            OracleVersion memory latestVersion = oracles[global.current].provider.latest();\n            if (latestVersion.timestamp > oracles[global.current].timestamp)\n                oracles[global.current].timestamp = uint96(latestVersion.timestamp);\n        }\n\n        // add the new oracle registration\n        oracles[++global.current] = Epoch(newProvider, uint96(newProvider.current()));\n        emit OracleUpdated(newProvider);\n    }\n\n    /// @notice Handles updating the latest oracle to the current if it is ready\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    function _updateLatest(OracleVersion memory currentOracleLatestVersion) private {\n        if (_latestStale(currentOracleLatestVersion)) global.latest = global.current;\n    }\n\n    /// @notice Handles overriding the latest version\n    /// @dev Applicable if we haven't yet switched over to the current oracle from the latest oracle\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    /// @return latestVersion The latest version\n    function _handleLatest(\n        OracleVersion memory currentOracleLatestVersion\n    ) private view returns (OracleVersion memory latestVersion) {\n        if (global.current == global.latest) return currentOracleLatestVersion;\n\n        bool isLatestStale = _latestStale(currentOracleLatestVersion);\n        latestVersion = isLatestStale ? currentOracleLatestVersion : oracles[global.latest].provider.latest();\n\n        uint256 latestOracleTimestamp =\n            uint256(isLatestStale ? oracles[global.current].timestamp : oracles[global.latest].timestamp);\n        if (!isLatestStale && latestVersion.timestamp > latestOracleTimestamp)\n            return at(latestOracleTimestamp);\n    }\n\n    /// @notice Returns whether the latest oracle is ready to be updated\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    /// @return Whether the latest oracle is ready to be updated\n    function _latestStale(OracleVersion memory currentOracleLatestVersion) private view returns (bool) {\n        if (global.current == global.latest) return false;\n        if (global.latest == 0) return true;\n\n        if (uint256(oracles[global.latest].timestamp) > oracles[global.latest].provider.latest().timestamp) return false;\n        if (uint256(oracles[global.latest].timestamp) >= currentOracleLatestVersion.timestamp) return false;\n\n        return true;\n    }\n\n    /// @dev Only if the caller is authorized by the factory\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender))\n            revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    }
  ]
}