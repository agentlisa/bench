{
  "Title": "[10] LowLevelHelpers enforce a stricter ABI standard for `returndatasize`",
  "Content": "\n**Context**: [LowLevelHelpers.sol#L110](https://github.com/ProjectOpenSea/seaport/blob/878121af65be408462f3eae04ab81018b4e199da/contracts/lib/LowLevelHelpers.sol#L110)\n\n```solidity\n        assembly {\n            // Only put result on stack if return data is exactly one word.\n            if eq(returndatasize(), OneWord) {\n```\n\nThis is not compliant with the ABI standard, as the ABI standard allows for returning more data than needed. The proper one should `if iszero(lt(returndatasize(), OneWord))`.\n\nThis is currently used in \n1. `_assertValidEIP1271Signature`: to check the returnvalue `bytes4 magicValue` of `isValidSignature`.\n2. ` _assertIsValidOrderStaticcallSuccess` for checking `ZoneInterface` returnvalue.\n\nThe ABI standard allows for extra data everywhere. That is, given a correct 32-byte value, having more data at the end is valid. Therefore, this function returns `false` for complaint contracts.\n\nHowever, most contracts wouldn't return more than 32-bytes when only 32-bytes are needed. A notable exception is some versions of proxy contracts in Vyper. This proxy always returned 128 bytes, with any extra data padded with zeros ([source](https://github.com/vyperlang/vyper/blob/069936fa3fee8646ff362145593128d7ef07da38/vyper/functions/functions.py#L1471)). This has caused issues with SolMate's `SafeTransferLib`, leading to DOS issues on chain ([source](https://github.com/Rari-Capital/solmate/issues/141)).\n\nThis is at least a low severity issue, and may even be considered Medium if there are known EIP1271 wallets in existence with the aforementioned issue. Note: for ERC20 tokens, there are known tokens with the problem (certain Curve tokens). Considering that this is a trivial fix, it's better to be on the side of caution and make the above change.\n\n### Proof of Concept\n\nFor a simple proof of concept, consider a minimal proxy contract that does `return(0, 0x1000)` (instead of the usual `return(0, returndatasize())`) where the 'implementation' is a EIP1271 wallet contract. The low level helper would revert when verifying the `_assertValidEIP1271Signature`, whereas a high level solidity implementation would succeed.\n\n### Recommended Mitigation Steps\n\nChange the strict equality check to a `>=` check.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/LowLevelHelpers.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title LowLevelHelpers\n * @author 0age\n * @notice LowLevelHelpers contains logic for performing various low-level\n *         operations.\n */\ncontract LowLevelHelpers {\n    /**\n     * @dev Internal view function to staticcall an arbitrary target with given\n     *      calldata. Note that no data is written to memory and no contract\n     *      size check is performed.\n     *\n     * @param target   The account to staticcall.\n     * @param callData The calldata to supply when staticcalling the target.\n     *\n     * @return success The status of the staticcall to the target.\n     */\n    function _staticcall(address target, bytes memory callData)\n        internal\n        view\n        returns (bool success)\n    {\n        assembly {\n            // Perform the staticcall.\n            success := staticcall(\n                gas(),\n                target,\n                add(callData, OneWord),\n                mload(callData),\n                0,\n                0\n            )\n        }\n    }\n\n    /**\n     * @dev Internal view function to revert and pass along the revert reason if\n     *      data was returned by the last call and that the size of that data\n     *      does not exceed the currently allocated memory size.\n     */\n    function _revertWithReasonIfOneIsReturned() internal view {\n        assembly {\n            // If it returned a message, bubble it up as long as sufficient gas\n            // remains to do so:\n            if returndatasize() {\n                // Ensure that sufficient gas is available to copy returndata\n                // while expanding memory where necessary. Start by computing\n                // the word size of returndata and allocated memory.\n                let returnDataWords := div(returndatasize(), OneWord)\n\n                // Note: use the free memory pointer in place of msize() to work\n                // around a Yul warning that prevents accessing msize directly\n                // when the IR pipeline is activated.\n                let msizeWords := div(mload(FreeMemoryPointerSlot), OneWord)\n\n                // Next, compute the cost of the returndatacopy.\n                let cost := mul(CostPerWord, returnDataWords)\n\n                // Then, compute cost of new memory allocation.\n                if gt(returnDataWords, msizeWords) {\n                    cost := add(\n                        cost,\n                        add(\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\n                            div(\n                                sub(\n                                    mul(returnDataWords, returnDataWords),\n                                    mul(msizeWords, msizeWords)\n                                ),\n                                MemoryExpansionCoefficient\n                            )\n                        )\n                    )\n                }\n\n                // Finally, add a small constant and compare to gas remaining;\n                // bubble up the revert data if enough gas is still available.\n                if lt(add(cost, ExtraGasBuffer), gas()) {\n                    // Copy returndata to memory; overwrite existing memory.\n                    returndatacopy(0, 0, returndatasize())\n\n                    // Revert, specifying memory region with copied returndata.\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to determine if the first word of returndata\n     *      matches an expected magic value.\n     *\n     * @param expected The expected magic value.\n     *\n     * @return A boolean indicating whether the expected value matches the one\n     *         located in the first word of returndata.\n     */\n    function _doesNotMatchMagic(bytes4 expected) internal pure returns (bool) {\n        // Declare a variable for the value held by the return data buffer.\n        bytes4 result;\n\n        // Utilize assembly in order to read directly from returndata buffer.\n        assembly {\n            // Only put result on stack if return data is exactly one word.\n            if eq(returndatasize(), OneWord) {\n                // Copy the word directly from return data into scratch space.\n                returndatacopy(0, 0, OneWord)\n\n                // Take value from scratch space and place it on the stack.\n                result := mload(0)\n            }\n        }\n\n        // Return a boolean indicating whether expected and located value match.\n        return result != expected;\n    }\n}"
    },
    {
      "filename": "vyper/functions/functions.py",
      "content": "import hashlib\nimport math\nimport operator\nfrom decimal import Decimal\n\nfrom vyper import ast as vy_ast\nfrom vyper.ast.validation import validate_call_args\nfrom vyper.context.types.abstract import (\n    ArrayValueAbstractType,\n    BytesAbstractType,\n    IntegerAbstractType,\n    NumericAbstractType,\n)\nfrom vyper.context.types.bases import DataLocation, ValueTypeDefinition\nfrom vyper.context.types.indexable.sequence import ArrayDefinition\nfrom vyper.context.types.utils import get_type_from_annotation\nfrom vyper.context.types.value.address import AddressDefinition\nfrom vyper.context.types.value.array_value import (\n    BytesArrayDefinition,\n    BytesArrayPrimitive,\n    StringDefinition,\n    StringPrimitive,\n)\nfrom vyper.context.types.value.bytes_fixed import Bytes32Definition\nfrom vyper.context.types.value.numeric import (\n    DecimalDefinition,\n    Int128Definition,\n    Uint256Definition,\n)\nfrom vyper.context.validation.utils import (\n    get_common_types,\n    get_possible_types_from_node,\n    validate_expected_type,\n)\nfrom vyper.exceptions import (\n    ArgumentException,\n    CompilerPanic,\n    InvalidLiteral,\n    InvalidType,\n    StateAccessViolation,\n    StructureException,\n    TypeMismatch,\n    UnfoldableNode,\n    VyperException,\n    ZeroDivisionException,\n)\nfrom vyper.functions.convert import convert\nfrom vyper.opcodes import version_check\nfrom vyper.parser.arg_clamps import int128_clamp\nfrom vyper.parser.expr import Expr\nfrom vyper.parser.keccak256_helper import keccak256_helper\nfrom vyper.parser.parser_utils import (\n    LLLnode,\n    add_variable_offset,\n    get_length,\n    getpos,\n    make_byte_array_copier,\n    make_byte_slice_copier,\n    unwrap_location,\n)\nfrom vyper.signatures.function_signature import VariableRecord\nfrom vyper.types import BaseType, ByteArrayLike, ByteArrayType, ListType\nfrom vyper.types import StringType as OldStringType\nfrom vyper.types import is_base_type\nfrom vyper.utils import (\n    DECIMAL_DIVISOR,\n    MemoryPositions,\n    SizeLimits,\n    bytes_to_int,\n    fourbytes_to_int,\n    keccak256,\n)\n\nfrom .signatures import Optional, validate_inputs\n\nSHA256_ADDRESS = 2\nSHA256_BASE_GAS = 60\nSHA256_PER_WORD_GAS = 12\n\n\nclass _SimpleBuiltinFunction:\n    def fetch_call_return(self, node):\n        validate_call_args(node, len(self._inputs), getattr(self, \"_kwargs\", []))\n        for arg, (_, expected) in zip(node.args, self._inputs):\n            validate_expected_type(arg, expected)\n\n        if self._return_type:\n            return self._return_type\n\n\nclass Floor(_SimpleBuiltinFunction):\n\n    _id = \"floor\"\n    _inputs = [(\"value\", DecimalDefinition())]\n    _return_type = Int128Definition()\n\n    def evaluate(self, node):\n        validate_call_args(node, 1)\n        if not isinstance(node.args[0], vy_ast.Decimal):\n            raise UnfoldableNode\n\n        value = math.floor(node.args[0].value)\n        return vy_ast.Int.from_node(node, value=value)\n\n    @validate_inputs\n    def build_LLL(self, expr, args, kwargs, context):\n        return LLLnode.from_list(\n            [\n                \"if\",\n                [\"slt\", args[0], 0],\n                [\"sdiv\", [\"sub\", args[0], DECIMAL_DIVISOR - 1], DECIMAL_DIVISOR],\n                [\"sdiv\", args[0], DECIMAL_DIVISOR],\n            ],\n            typ=BaseType(\"int128\"),\n            pos=getpos(expr),\n        )\n\n\nclass Ceil(_SimpleBuiltinFunction):\n\n    _id = \"ceil\"\n    _inputs = [(\"value\", DecimalDefinition())]\n    _return_type = Int128Definition()\n\n    def evaluate(self, node):\n        validate_call_args(node, 1)\n        if not isinstance(node.args[0], vy_ast.Decimal):\n            raise UnfoldableNode\n\n        value = math.ceil(node.args[0].value)\n        return vy_ast.Int.from_node(node, value=value)\n\n    @validate_inputs\n    def build_LLL(self, expr, args, kwargs, context):\n        return LLLnode.from_list(\n            [\n                \"if\",\n                [\"slt\", args[0], 0],\n                [\"sdiv\", args[0], DECIMAL_DIVISOR],\n                [\"sdiv\", [\"add\", args[0], DECIMAL_DIVISOR - 1], DECIMAL_DIVISOR],\n            ],\n            typ=BaseType(\"int128\"),\n            pos=getpos(expr),\n        )\n\n\nclass Convert:\n\n    # TODO this is just a wireframe, expand it with complete functionality\n    # https://github.com/vyperlang/vyper/issues/1093\n\n    _id = \"convert\"\n\n    def fetch_call_return(self, node):\n        validate_call_args(node, 2)\n        target_type = get_type_from_annotation(node.args[1], DataLocation.MEMORY)\n\n        validate_expected_type(node.args[0], ValueTypeDefinition())\n        try:\n            validate_expected_type(node.args[0], target_type)\n        except VyperException:\n            pass\n        else:\n            # TODO remove this once it's possible in parser\n            if not isinstance(target_type, Uint256Definition):\n                raise InvalidType(f\"Value and target type are both '{target_type}'\", node)\n\n        # TODO!\n        # try:\n        #     validation_fn = getattr(self, f\"validate_to_{target_type._id}\")\n        # except AttributeError:\n        #     raise InvalidType(\n        #         f\"Unsupported destination type '{target_type}'\", node.args[1]\n        #     ) from None\n\n        # validation_fn(initial_type)\n\n        return target_type\n\n    def validate_to_bool(self, initial_type):\n        pass\n\n    def validate_to_decimal(self, initial_type):\n        pass\n\n    def validate_to_int128(self, initial_type):\n        pass\n\n    def validate_to_uint256(self, initial_type):\n        pass\n\n    def validate_to_bytes32(self, initial_type):\n        pass\n\n    def validate_to_string(self, initial_type):\n        pass\n\n    def validate_to_bytes(self, initial_type):\n        pass\n\n    def validate_to_address(self, initial_type):\n        pass\n\n    def build_LLL(self, expr, context):\n        return convert(expr, context)\n\n\nclass Slice:\n\n    _id = \"slice\"\n    _inputs = [(\"b\", (\"Bytes\", \"bytes32\", \"String\")), (\"start\", \"uint256\"), (\"length\", \"uint256\")]\n    _return_type = None\n\n    def fetch_call_return(self, node):\n        validate_call_args(node, 3)\n\n        for arg in node.args[1:]:\n            validate_expected_type(arg, Uint256Definition())\n        if isinstance(node.args[2], vy_ast.Int) and node.args[2].value < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", node.args[2])\n\n        validate_expected_type(node.args[0], (BytesAbstractType(), StringPrimitive()))\n        type_list = get_possible_types_from_node(node.args[0])\n        try:\n            validate_expected_type(node.args[0], StringPrimitive())\n            return_type = StringDefinition()\n        except VyperException:\n            return_type = BytesArrayDefinition()\n\n        if isinstance(node.args[2], vy_ast.Int):\n            return_type.set_length(node.args[2].value)\n        else:\n            return_type.set_min_length(type_list[0].length)\n\n        return return_type\n\n    @validate_inputs\n    def build_LLL(self, expr, args, kwargs, context):\n\n        sub, start, length = args\n        if is_base_type(sub.typ, \"bytes32\"):\n            if (start.typ.is_literal and length.typ.is_literal) and not (\n                0 <= start.value + length.value <= 32\n            ):\n                raise InvalidLiteral(\n                    \"Invalid start / length values needs to be between 0 and 32.\", expr,\n                )\n            sub_typ_maxlen = 32\n        else:\n            sub_typ_maxlen = sub.typ.maxlen\n\n        # Get returntype string or bytes\n        if isinstance(args[0].typ, ByteArrayType) or is_base_type(sub.typ, \"bytes32\"):\n            ReturnType = ByteArrayType\n        else:\n            ReturnType = OldStringType\n\n        # Node representing the position of the output in memory\n        np = context.new_internal_variable(ReturnType(maxlen=sub_typ_maxlen + 32))\n        placeholder_node = LLLnode.from_list(np, typ=sub.typ, location=\"memory\")\n        placeholder_plus_32_node = LLLnode.from_list(np + 32, typ=sub.typ, location=\"memory\")\n        # Copies over bytearray data\n        if sub.location == \"storage\":\n            adj_sub = LLLnode.from_list(\n                [\"add\", [\"sha3_32\", sub], [\"add\", [\"div\", \"_start\", 32], 1]],\n                typ=sub.typ,\n                location=sub.location,\n            )\n        else:\n            adj_sub = LLLnode.from_list(\n                [\"add\", sub, [\"add\", [\"sub\", \"_start\", [\"mod\", \"_start\", 32]], 32]],\n                typ=sub.typ,\n                location=sub.location,\n            )\n\n        if is_base_type(sub.typ, \"bytes32\"):\n            adj_sub = LLLnode.from_list(sub.args[0], typ=sub.typ, location=\"memory\")\n\n        copier = make_byte_slice_copier(\n            placeholder_plus_32_node,\n            adj_sub,\n            [\"add\", \"_length\", 32],\n            sub_typ_maxlen,\n            pos=getpos(expr),\n        )\n        # New maximum length in the type of the result\n        newmaxlen = length.value if not len(length.args) else sub_typ_maxlen\n        if is_base_type(sub.typ, \"bytes32\"):\n            maxlen = 32\n        else:\n            maxlen = [\"mload\", Expr(sub, context=context).lll_node]  # Retrieve length of the bytes.\n\n        out = [\n            \"with\",\n            \"_start\",\n            start,\n            [\n                \"with\",\n                \"_length\",\n                length,\n                [\n                    \"with\",\n                    \"_opos\",\n                    [\"add\", placeholder_node, [\"mod\", \"_start\", 32]],\n                    [\n                        \"seq\",\n                        [\"assert\", [\"le\", [\"add\", \"_start\", \"_length\"], maxlen]],\n                        copier,\n                        [\"mstore\", \"_opos\", \"_length\"],\n                        \"_opos\",\n                    ],\n                ],\n            ],\n        ]\n        return LLLnode.from_list(\n            out, typ=ReturnType(newmaxlen), location=\"memory\", pos=getpos(expr)\n        )\n\n\nclass Len(_SimpleBuiltinFunction):\n\n    _id = \"len\"\n    _inputs = [(\"b\", ArrayValueAbstractType())]\n    _return_type = Uint256Definition()\n\n    def evaluate(self, node):\n        validate_call_args(node, 1)\n        arg = node.args[0]\n        if isinstance(arg, (vy_ast.Str, vy_ast.Bytes)):\n            length = len(arg.value)\n        elif isinstance(arg, vy_ast.Hex):\n            # 2 characters represent 1 byte and we subtract 1 to ignore the leading `0x`\n            length = len(arg.value) // 2 - 1\n        else:\n            raise UnfoldableNode\n\n        return vy_ast.Int.from_node(node, value=length)\n\n    def build_LLL(self, node, context):\n        arg = Expr(node.args[0], context).lll_node\n        return get_length(arg)\n\n\nclass Concat:\n\n    _id = \"concat\"\n\n    def fetch_call_return(self, node):\n        if len(node.args) < 2:\n            raise ArgumentException(\"Invalid argument count: expected at least 2\", node)\n\n        if node.keywords:\n            raise ArgumentException(\"Keyword arguments are not accepted here\", node.keywords[0])\n\n        type_ = None\n        for expected in (BytesAbstractType(), StringPrimitive()):\n            try:\n                validate_expected_type(node.args[0], expected)\n                type_ = expected\n            except (InvalidType, TypeMismatch):\n                pass\n        if type_ is None:\n            raise TypeMismatch(\"Concat values must be bytes or string\", node.args[0])\n\n        length = 0\n        for arg in node.args[1:]:\n            validate_expected_type(arg, type_)\n\n        length = 0\n        for arg in node.args:\n            length += get_possible_types_from_node(arg).pop().length\n\n        if isinstance(type_, BytesAbstractType):\n            return_type = BytesArrayDefinition()\n        else:\n            return_type = StringDefinition()\n        return_type.set_length(length)\n        return return_type\n\n    def build_LLL(self, expr, context):\n        args = [Expr(arg, context).lll_node for arg in expr.args]\n        if len(args) < 2:\n            raise StructureException(\"Concat expects at least two arguments\", expr)\n\n        prev_type = \"\"\n        for _, (expr_arg, arg) in enumerate(zip(expr.args, args)):\n            if not isinstance(arg.typ, ByteArrayLike) and not is_base_type(arg.typ, \"bytes32\"):\n                raise TypeMismatch(\"Concat expects string, bytes or bytes32 objects\", expr_arg)\n\n            current_type = (\n                \"Bytes\"\n                if isinstance(arg.typ, ByteArrayType) or is_base_type(arg.typ, \"bytes32\")\n                else \"String\"\n            )\n            if prev_type and current_type != prev_type:\n                raise TypeMismatch(\n                    (\n                        \"Concat expects consistant use of string or byte types, \"\n                        \"user either bytes or string.\"\n                    ),\n                    expr_arg,\n                )\n            prev_type = current_type\n\n        if current_type == \"String\":\n            ReturnType = OldStringType\n        else:\n            ReturnType = ByteArrayType\n\n        # Maximum length of the output\n        total_maxlen = sum(\n            [arg.typ.maxlen if isinstance(arg.typ, ByteArrayLike) else 32 for arg in args]\n        )\n        # Node representing the position of the output in memory\n        placeholder = context.new_internal_variable(ReturnType(total_maxlen))\n        # Object representing the output\n        seq = []\n        # For each argument we are concatenating...\n        for arg in args:\n            # Start pasting into a position the starts at zero, and keeps\n            # incrementing as we concatenate arguments\n            placeholder_node = LLLnode.from_list(\n                [\"add\", placeholder, \"_poz\"], typ=ReturnType(total_maxlen), location=\"memory\",\n            )\n            placeholder_node_plus_32 = LLLnode.from_list(\n                [\"add\", [\"add\", placeholder, \"_poz\"], 32],\n                typ=ReturnType(total_maxlen),\n                location=\"memory\",\n            )\n            if isinstance(arg.typ, ReturnType):\n                # Ignore empty strings\n                if arg.typ.maxlen == 0:\n                    continue\n                # Get the length of the current argument\n                if arg.location == \"memory\":\n                    length = LLLnode.from_list([\"mload\", \"_arg\"], typ=BaseType(\"int128\"))\n                    argstart = LLLnode.from_list(\n                        [\"add\", \"_arg\", 32], typ=arg.typ, location=arg.location,\n                    )\n                elif arg.location == \"storage\":\n                    length = LLLnode.from_list(\n                        [\"sload\", [\"sha3_32\", \"_arg\"]], typ=BaseType(\"int128\")\n                    )\n                    argstart = LLLnode.from_list(\n                        [\"add\", [\"sha3_32\", \"_arg\"], 1], typ=arg.typ, location=arg.location,\n                    )\n                # Make a copier to copy over data from that argument\n                seq.append(\n                    [\n                        \"with\",\n                        \"_arg\",\n                        arg,\n                        [\n                            \"seq\",\n                            make_byte_slice_copier(\n                                placeholder_node_plus_32,\n                                argstart,\n                                length,\n                                arg.typ.maxlen,\n                                pos=getpos(expr),\n                            ),\n                            # Change the position to start at the correct\n                            # place to paste the next value\n                            [\"set\", \"_poz\", [\"add\", \"_poz\", length]],\n                        ],\n                    ]\n                )\n            else:\n                seq.append(\n                    [\n                        \"seq\",\n                        [\"mstore\", [\"add\", placeholder_node, 32], unwrap_location(arg)],\n                        [\"set\", \"_poz\", [\"add\", \"_poz\", 32]],\n                    ]\n                )\n        # The position, after all arguments are processing, equals the total\n        # length. Paste this in to make the output a proper bytearray\n        seq.append([\"mstore\", placeholder, \"_poz\"])\n        # Memory location of the output\n        seq.append(placeholder)\n        return LLLnode.from_list(\n            [\"with\", \"_poz\", 0, [\"seq\"] + seq],\n            typ=ReturnType(total_maxlen),\n            location=\"memory\",\n            pos=getpos(expr),\n            annotation=\"concat\",\n        )\n\n\nclass Keccak256(_SimpleBuiltinFunction):\n\n    _id = \"keccak256\"\n    _inputs = [(\"value\", (Bytes32Definition(), BytesArrayPrimitive(), StringPrimitive()))]\n    _return_type = Bytes32Definition()\n\n    def evaluate(self, node):\n        validate_call_args(node, 1)\n        if isinstance(node.args[0], vy_ast.Bytes):\n            value = node.args[0].value\n        elif isinstance(node.args[0], vy_ast.Str):\n            value = node.args[0].value.encode()\n        elif isinstance(node.args[0], vy_ast.Hex):\n            length = len(node.args[0].value) // 2 - 1\n            value = int(node.args[0].value, 16).to_bytes(length, \"big\")\n        else:\n            raise UnfoldableNode\n\n        hash_ = f\"0x{keccak256(value).hex()}\"\n        return vy_ast.Hex.from_node(node, value=hash_)\n\n    @validate_inputs\n    def build_LLL(self, expr, args, kwargs, context):\n        return keccak256_helper(expr, args, kwargs, context)\n\n\ndef _make_sha256_call(inp_start, inp_len, out_start, out_len):\n    return [\n        \"assert\",\n        [\n            \"staticcall\",\n            [\"gas\"],  # gas\n            SHA256_ADDRESS,  # address\n            inp_start,\n            inp_len,\n            out_start,\n            out_len,\n        ],\n    ]\n\n\nclass Sha256(_SimpleBuiltinFunction):\n\n    _id = \"sha256\"\n    _inputs = [(\"value\", (Bytes32Definition(), BytesArrayPrimitive(), StringPrimitive()))]\n    _return_type = Bytes32Definition()\n\n    def evaluate(self, node):\n        validate_call_args(node, 1)\n        if isinstance(node.args[0], vy_ast.Bytes):\n            value = node.args[0].value\n        elif isinstance(node.args[0], vy_ast.Str):\n            value = node.args[0].value.encode()\n        elif isinstance(node.args[0], vy_ast.Hex):\n            length = len(node.args[0].value) // 2 - 1\n            value = int(node.args[0].value, 16).to_bytes(length, \"big\")\n        else:\n            raise UnfoldableNode\n\n        hash_ = f\"0x{hashlib.sha256(value).hexdigest()}\"\n        return vy_ast.Hex.from_node(node, value=hash_)\n\n    @validate_inputs\n    def build_LLL(self, expr, args, kwargs, context):\n        sub = args[0]\n        # bytes32 input\n        if is_base_type(sub.typ, \"bytes32\"):\n            return LLLnode.from_list(\n                [\n                    \"seq\",\n                    [\"mstore\", MemoryPositions.FREE_VAR_SPACE, sub],\n                    _make_sha256_call(\n                        inp_start=MemoryPositions.FREE_VAR_SPACE,\n                        inp_len=32,\n                        out_start=MemoryPositions.FREE_VAR_SPACE,\n                        out_len=32,\n                    ),\n                    [\"mload\", MemoryPositions.FREE_VAR_SPACE],  # push value onto stack\n                ],\n                typ=BaseType(\"bytes32\"),\n                pos=getpos(expr),\n                add_gas_estimate=SHA256_BASE_GAS + 1 * SHA256_PER_WORD_GAS,\n            )\n        # bytearay-like input\n        if sub.location == \"storage\":\n            # Copy storage to memory\n            placeholder = context.new_internal_variable(sub.typ)\n            placeholder_node = LLLnode.from_list(placeholder, typ=sub.typ, location=\"memory\")\n            copier = make_byte_array_copier(\n                placeholder_node, LLLnode.from_list(\"_sub\", typ=sub.typ, location=sub.location),\n            )\n            return LLLnode.from_list(\n                [\n                    \"with\",\n                    \"_sub\",\n                    sub,\n                    [\n                        \"seq\",\n                        copier,\n                        _make_sha256_call(\n                            inp_start=[\"add\", placeholder, 32],\n                            inp_len=[\"mload\", placeholder],\n                            out_start=MemoryPositions.FREE_VAR_SPACE,\n                            out_len=32,\n                        ),\n                        [\"mload\", MemoryPositions.FREE_VAR_SPACE],\n                    ],\n                ],\n                typ=BaseType(\"bytes32\"),\n                pos=getpos(expr),\n                add_gas_estimate=SHA256_BASE_GAS + sub.typ.maxlen * SHA256_PER_WORD_GAS,\n            )\n        elif sub.location == \"memory\":\n            return LLLnode.from_list(\n                [\n                    \"with\",\n                    \"_sub\",\n                    sub,\n                    [\n                        \"seq\",\n                        _make_sha256_call(\n                            inp_start=[\"add\", \"_sub\", 32],\n                            inp_len=[\"mload\", \"_sub\"],\n                            out_start=MemoryPositions.FREE_VAR_SPACE,\n                            out_len=32,\n                        ),\n                        [\"mload\", MemoryPositions.FREE_VAR_SPACE],\n                    ],\n                ],\n                typ=BaseType(\"bytes32\"),\n                pos=getpos(expr),\n                add_gas_estimate=SHA256_BASE_GAS + sub.typ.maxlen * SHA256_PER_WORD_GAS,\n            )\n        else:\n            # This should never happen, but just left here for future compiler-writers.\n            raise Exception(f\"Unsupported location: {sub.location}\")  # pragma: no test\n\n\nclass MethodID:\n\n    _id = \"method_id\"\n\n    def evaluate(self, node):\n        validate_call_args(node, 1, [\"output_type\"])\n\n        args = node.args\n        if not isinstance(args[0], vy_ast.Str):\n            raise InvalidType(\"method id must be given as a literal string\", args[0])\n        if \" \" in args[0].value:\n            raise InvalidLiteral(\"Invalid function signature - no spaces allowed.\")\n\n        if node.keywords:\n            return_type = get_type_from_annotation(node.keywords[0].value, DataLocation.UNSET)\n            if isinstance(return_type, Bytes32Definition):\n                length = 32\n            elif isinstance(return_type, BytesArrayDefinition) and return_type.length == 4:\n                length = 4\n            else:\n                raise ArgumentException(\"output_type must be bytes[4] or bytes32\", node.keywords[0])\n        else:\n            # if `output_type` is not given, default to `bytes[4]`\n            length = 4\n\n        method_id = fourbytes_to_int(keccak256(args[0].value.encode())[:4])\n        value = method_id.to_bytes(length, \"big\")\n\n        if length == 32:\n            return vy_ast.Hex.from_node(node, value=f\"0x{value.hex()}\")\n        elif length == 4:\n            return vy_ast.Bytes.from_node(node, value=value)\n        else:\n            raise CompilerPanic\n\n    def fetch_call_return(self, node):\n        raise CompilerPanic(\"method_id should always be folded\")\n\n    def build_LLL(self, *args, **kwargs):\n        raise CompilerPanic(\"method_id should always be folded\")\n\n\nclass ECRecover(_SimpleBuiltinFunction):\n\n    _id = \"ecrecover\"\n    _inputs = [\n        (\"hash\", Bytes32Definition()),\n        (\"v\", Uint256Definition()),\n        (\"r\", Uint256Definition()),\n        (\"s\", Uint256Definition()),\n    ]\n    _return_type = AddressDefinition()\n\n    @validate_inputs\n    def build_LLL(self, expr, args, kwargs, context):\n        placeholder_node = LLLnode.from_list(\n            context.new_internal_variable(ByteArrayType(128)),\n            typ=ByteArrayType(128),\n            location=\"memory\",\n        )\n        return LLLnode.from_list(\n            [\n                \"seq\",\n                [\"mstore\", placeholder_node, args[0]],\n                [\"mstore\", [\"add\", placeholder_node, 32], args[1]],\n                [\"mstore\", [\"add\", placeholder_node, 64], args[2]],\n                [\"mstore\", [\"add\", placeholder_node, 96], args[3]],\n                [\n                    \"pop\",\n                    [\n                        \"staticcall\",\n                        [\"gas\"],\n                        1,\n                        placeholder_node,\n                        128,\n                        MemoryPositions.FREE_VAR_SPACE,\n                        32,\n                    ],\n                ],\n                [\"mload\", MemoryPositions.FREE_VAR_SPACE],\n            ],\n            typ=BaseType(\"address\"),\n            pos=getpos(expr),\n        )\n\n\ndef avo(arg, ind, pos):\n    return unwrap_location(add_variable_offset(arg, LLLnode.from_list(ind, \"int128\"), pos=pos))\n\n\nclass ECAdd(_SimpleBuiltinFunction):\n\n    _id = \"ecadd\"\n    _inputs = [\n        (\"a\", ArrayDefinition(Uint256Definition(), 2)),\n        (\"b\", ArrayDefinition(Uint256Definition(), 2)),\n    ]\n    _return_type = ArrayDefinition(Uint256Definition(), 2)\n\n    @validate_inputs\n    def build_LLL(self, expr, args, kwargs, context):\n        placeholder_node = LLLnode.from_list(\n            context.new_internal_variable(ByteArrayType(128)),\n            typ=ByteArrayType(128),\n            location=\"memory\",\n        )\n        pos = getpos(expr)\n        o = LLLnode.from_list(\n            [\n                \"seq\",\n                [\"mstore\", placeholder_node, avo(args[0], 0, pos)],\n                [\"mstore\", [\"add\", placeholder_node, 32], avo(args[0], 1, pos)],\n                [\"mstore\", [\"add\", placeholder_node, 64], avo(args[1], 0, pos)],\n                [\"mstore\", [\"add\", placeholder_node, 96], avo(args[1], 1, pos)],\n                [\"assert\", [\"staticcall\", [\"gas\"], 6, placeholder_node, 128, placeholder_node, 64]],\n                placeholder_node,\n            ],\n            typ=ListType(BaseType(\"uint256\"), 2),\n            pos=getpos(expr),\n            location=\"memory\",\n        )\n        return o\n\n\nclass ECMul(_SimpleBuiltinFunction):\n\n    _id = \"ecmul\"\n    _inputs = [(\"point\", ArrayDefinition(Uint256Definition(), 2)), (\"scalar\", Uint256Definition())]\n    _return_type = ArrayDefinition(Uint256Definition(), 2)\n\n    @validate_inputs\n    def build_LLL(self, expr, args, kwargs, context):\n        placeholder_node = LLLnode.from_list(\n            context.new_internal_variable(ByteArrayType(128)),\n            typ=ByteArrayType(128),\n            location=\"memory\",\n        )\n        pos = getpos(expr)\n        o = LLLnode.from_list(\n            [\n                \"seq\",\n                [\"mstore\", placeholder_node, avo(args[0], 0, pos)],\n                [\"mstore\", [\"add\", placeholder_node, 32], avo(args[0], 1, pos)],\n                [\"mstore\", [\"add\", placeholder_node, 64], args[1]],\n                [\"assert\", [\"staticcall\", [\"gas\"], 7, placeholder_node, 96, placeholder_node, 64]],\n                placeholder_node,\n            ],\n            typ=ListType(BaseType(\"uint256\"), 2),\n            pos=pos,\n            location=\"memory\",\n        )\n        return o\n\n\ndef _memory_element_getter(index):\n    return LLLnode.from_list(\n        [\"mload\", [\"add\", \"_sub\", [\"add\", 32, [\"mul\", 32, index]]]], typ=BaseType(\"int128\"),\n    )\n\n\ndef _storage_element_getter(index):\n    return LLLnode.from_list(\n        [\"sload\", [\"add\", [\"sha3_32\", \"_sub\"], [\"add\", 1, index]]], typ=BaseType(\"int128\"),\n    )\n\n\nclass Extract32(_SimpleBuiltinFunction):\n\n    _id = \"extract32\"\n    _inputs = [(\"b\", BytesArrayPrimitive()), (\"start\", Int128Definition())]\n    _kwargs = {\"output_type\": Optional(\"name_literal\", \"bytes32\")}\n    _return_type = None\n\n    def fetch_call_return(self, node):\n        super().fetch_call_return(node)\n        if node.keywords:\n            return_type = get_type_from_annotation(node.keywords[0].value, DataLocation.MEMORY)\n            if not isinstance(\n                return_type, (AddressDefinition, Bytes32Definition, IntegerAbstractType)\n            ):\n                raise\n        else:\n            return_type = Bytes32Definition()\n\n        return return_type\n\n    @validate_inputs\n    def build_LLL(self, expr, args, kwargs, context):\n        sub, index = args\n        ret_type = kwargs[\"output_type\"]\n        # Get length and specific element\n        if sub.location == \"memory\":\n            lengetter = LLLnode.from_list([\"mload\", \"_sub\"], typ=BaseType("
    }
  ]
}