{
  "Title": "[G-19] Splitting `require()` statements that use `&&` saves gas",
  "Content": "\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper\n\n*There are 15 instances of this issue:*\n\n```solidity\nFile: contracts/ExtraRewardsDistributor.sol\n\n171:          require(_index > 0 && _index < rewardEpochs[_token].length - 1, \"!past\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/ExtraRewardsDistributor.sol#L171>\n\n```solidity\nFile: contracts/AuraStakingProxy.sol\n\n90:           require(_outputBps > 9000 && _outputBps < 10000, \"Invalid output bps\");\n\n159:          require(_token != crv && _token != cvx && _token != cvxCrv, \"not allowed\");\n\n203:          require(address(_token) != crv && address(_token) != cvxCrv, \"not allowed\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraStakingProxy.sol#L90>\n\n```solidity\nFile: contracts/BalLiquidityProvider.sol\n\n48:           require(_request.assets.length == 2 && _request.maxAmountsIn.length == 2, \"!valid\");\n\n57:               require(bal > 0 && bal == _request.maxAmountsIn[i], \"!bal\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/BalLiquidityProvider.sol#L48>\n\n```solidity\nFile: convex-platform/contracts/contracts/StashFactoryV2.sol\n\n83:           require(!isV1 && !isV2 && !isV3,\"stash version mismatch\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/StashFactoryV2.sol#L83>\n\n```solidity\nFile: convex-platform/contracts/contracts/PoolManagerSecondaryProxy.sol\n\n111:          require(!usedMap[_lptoken] && !usedMap[_gauge], \"cant force used pool\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/PoolManagerSecondaryProxy.sol#L111>\n\n```solidity\nFile: convex-platform/contracts/contracts/Booster.sol\n\n220:          require(lockRewards != address(0) && rewardFactory != address(0), \"!initialised\");\n\n222:          require(_feeToken != address(0) && _feeDistro != address(0), \"!addresses\");\n\n278:          require(_lockFees >= 300 && _lockFees <= 1500, \"!lockFees\");\n\n279:          require(_stakerFees >= 300 && _stakerFees <= 1500, \"!stakerFees\");\n\n280:          require(_callerFees >= 10 && _callerFees <= 100, \"!callerFees\");\n\n313:          require(msg.sender==poolManager && !isShutdown, \"!add\");\n\n314:          require(_gauge != address(0) && _lptoken != address(0),\"!param\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/Booster.sol#L220>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/ExtraRewardsDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IExtraRewardsDistributor, IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   ExtraRewardsDistributor\n * @author  adapted from ConvexFinance\n * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.\n */\ncontract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {\n    using SafeERC20 for IERC20;\n\n    IAuraLocker public immutable auraLocker;\n\n    // token -> epoch -> amount\n    mapping(address => mapping(uint256 => uint256)) public rewardData;\n    // token -> epochList\n    mapping(address => uint256[]) public rewardEpochs;\n    // token -> account -> last claimed epoch index\n    mapping(address => mapping(address => uint256)) public userClaims;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);\n    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);\n    event RewardForfeited(address indexed user, address indexed token, uint256 index);\n\n    /**\n     * @dev Simple constructoor\n     * @param _auraLocker Aura Locker address\n     */\n    constructor(address _auraLocker) {\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /* ========== ADD REWARDS ========== */\n\n    /**\n     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokenÏ€\n     */\n    function addReward(address _token, uint256 _amount) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        _addReward(_token, _amount, latestEpoch);\n    }\n\n    /**\n     * @notice Add reward token to a specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens to add\n     * @param _epoch    Which epoch to add to (must be less than the previous epoch)\n     */\n    function addRewardToEpoch(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        require(_epoch <= latestEpoch, \"Cannot assign to the future\");\n\n        if (_epoch == latestEpoch) {\n            _addReward(_token, _amount, latestEpoch);\n        } else {\n            uint256 len = rewardEpochs[_token].length;\n            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, \"Cannot backdate to this epoch\");\n\n            _addReward(_token, _amount, _epoch);\n        }\n    }\n\n    /**\n     * @notice  Transfer reward tokens from sender to contract for vlCVX holders\n     * @dev     Add reward token for specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens\n     * @param _epoch    Epoch to add tokens to\n     */\n    function _addReward(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) internal nonReentrant {\n        // Pull before reward accrual\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        //convert to reward per token\n        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n        uint256 rPerT = (_amount * 1e20) / supply;\n        rewardData[_token][_epoch] += rPerT;\n\n        //add epoch to list\n        uint256 len = rewardEpochs[_token].length;\n        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {\n            rewardEpochs[_token].push(_epoch);\n        }\n\n        //event\n        emit RewardAdded(_token, _epoch, _amount);\n    }\n\n    /* ========== GET REWARDS ========== */\n\n    /**\n     * @notice Claim rewards for a specific token since the first epoch.\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function getReward(address _account, address _token) public {\n        _getReward(_account, _token, 0);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account      Address of vlCVX holder\n     * @param _token        Reward token address\n     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        _getReward(_account, _token, _startIndex);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        //get claimable tokens\n        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);\n\n        if (claimableTokens > 0) {\n            //set claim checkpoint\n            userClaims[_token][_account] = index;\n\n            //send\n            IERC20(_token).safeTransfer(_account, claimableTokens);\n\n            //event\n            emit RewardPaid(_account, _token, claimableTokens, index);\n        }\n    }\n\n    /**\n     * @notice  Allow a user to set their claimed index forward without claiming rewards\n     *          Because claims cycle through all periods that a specific reward was given\n     *          there becomes a situation where, for example, a new user could lock\n     *          2 years from now and try to claim a token that was given out every week prior.\n     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)\n     * @param _token  Reward token to forfeit\n     * @param _index  Epoch index to forfeit from\n     */\n    function forfeitRewards(address _token, uint256 _index) external {\n        require(_index > 0 && _index < rewardEpochs[_token].length - 1, \"!past\");\n        require(_index >= userClaims[_token][msg.sender], \"already claimed\");\n\n        //set claim checkpoint. next claim starts from index+1\n        userClaims[_token][msg.sender] = _index + 1;\n\n        emit RewardForfeited(msg.sender, _token, _index);\n    }\n\n    /* ========== VIEW REWARDS ========== */\n\n    /**\n     * @notice Get claimable rewards (rewardToken) for vlCVX holder\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function claimableRewards(address _account, address _token) external view returns (uint256) {\n        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);\n        return rewards;\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function claimableRewardsAtEpoch(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) external view returns (uint256) {\n        return _claimableRewards(_account, _token, _epoch);\n    }\n\n    /**\n     * @notice  Get all claimable rewards by looping through each epoch starting with the latest\n     *          saved epoch the user last claimed from\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _allClaimableRewards(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) internal view returns (uint256, uint256) {\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        // e.g. tokenEpochs = 31, 21\n        uint256 tokenEpochs = rewardEpochs[_token].length;\n\n        // e.g. epochIndex = 0\n        uint256 epochIndex = userClaims[_token][_account];\n        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27\n        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;\n\n        if (epochIndex >= tokenEpochs) {\n            return (0, tokenEpochs);\n        }\n\n        uint256 claimableTokens = 0;\n\n        for (uint256 i = epochIndex; i < tokenEpochs; i++) {\n            //only claimable after rewards are \"locked in\"\n            if (rewardEpochs[_token][i] < latestEpoch) {\n                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);\n                //return index user claims should be set to\n                epochIndex = i + 1;\n            }\n        }\n        return (claimableTokens, epochIndex);\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function _claimableRewards(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) internal view returns (uint256) {\n        //get balance and calc share\n        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);\n        return (balance * rewardData[_token][_epoch]) / 1e20;\n    }\n\n    /**\n     * @notice Simply gets the current epoch count for a given reward token\n     * @param _token    Reward token address\n     * @return _epochs  Number of epochs\n     */\n    function rewardEpochsCount(address _token) external view returns (uint256) {\n        return rewardEpochs[_token].length;\n    }\n}"
    },
    {
      "filename": "contracts/AuraStakingProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { Address } from \"@openzeppelin/contracts-0.8/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\nimport { IAuraLocker } from \"./Interfaces.sol\";\n\ninterface ICrvDepositor {\n    function getMinOut(uint256, uint256) external view returns (uint256);\n\n    function deposit(\n        uint256,\n        uint256,\n        bool,\n        address _stakeAddress\n    ) external;\n}\n\n/**\n * @title   AuraStakingProxy\n * @author  adapted from ConvexFinance\n * @notice  Receives CRV from the Booster as overall reward, then convers to cvxCRV and distributes to vlCVX holders.\n * @dev     From CVX:\n *           - receive tokens to stake\n *           - get current staked balance\n *           - withdraw staked tokens\n *           - send rewards back to owner(cvx locker)\n *           - register token types that can be distributed\n */\ncontract AuraStakingProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    //tokens\n    address public immutable crv;\n    address public immutable cvx;\n    address public immutable cvxCrv;\n\n    address public keeper;\n    address public crvDepositorWrapper;\n    uint256 public outputBps;\n    uint256 public constant denominator = 10000;\n\n    address public rewards;\n\n    address public owner;\n    address public pendingOwner;\n    uint256 public callIncentive = 25;\n\n    event RewardsDistributed(address indexed token, uint256 amount);\n    event CallIncentiveChanged(uint256 incentive);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /**\n     * @param _rewards       vlCVX\n     * @param _crv           CRV token\n     * @param _cvx           CVX token\n     * @param _cvxCrv        cvxCRV token\n     * @param _crvDepositorWrapper    Wrapper that converts CRV to CRVBPT and deposits\n     * @param _outputBps     Configurable output bps where 100% == 10000\n     */\n    constructor(\n        address _rewards,\n        address _crv,\n        address _cvx,\n        address _cvxCrv,\n        address _crvDepositorWrapper,\n        uint256 _outputBps\n    ) {\n        rewards = _rewards;\n        owner = msg.sender;\n        crv = _crv;\n        cvx = _cvx;\n        cvxCrv = _cvxCrv;\n        crvDepositorWrapper = _crvDepositorWrapper;\n        outputBps = _outputBps;\n    }\n\n    /**\n     * @notice Set CrvDepositorWrapper\n     * @param   _crvDepositorWrapper CrvDepositorWrapper address\n     * @param   _outputBps Min output base points\n     */\n    function setCrvDepositorWrapper(address _crvDepositorWrapper, uint256 _outputBps) external {\n        require(msg.sender == owner, \"!auth\");\n        require(_outputBps > 9000 && _outputBps < 10000, \"Invalid output bps\");\n\n        crvDepositorWrapper = _crvDepositorWrapper;\n        outputBps = _outputBps;\n    }\n\n    /**\n     * @notice Set keeper\n     */\n    function setKeeper(address _keeper) external {\n        require(msg.sender == owner, \"!auth\");\n        keeper = _keeper;\n    }\n\n    /**\n     * @notice Set pending owner\n     */\n    function setPendingOwner(address _po) external {\n        require(msg.sender == owner, \"!auth\");\n        pendingOwner = _po;\n    }\n\n    /**\n     * @notice Apply pending owner\n     */\n    function applyPendingOwner() external {\n        require(msg.sender == owner, \"!auth\");\n        require(pendingOwner != address(0), \"invalid owner\");\n\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /**\n     * @notice Set call incentive\n     * @param _incentive Incentive base points\n     */\n    function setCallIncentive(uint256 _incentive) external {\n        require(msg.sender == owner, \"!auth\");\n        require(_incentive <= 100, \"too high\");\n        callIncentive = _incentive;\n        emit CallIncentiveChanged(_incentive);\n    }\n\n    /**\n     * @notice Set reward address\n     */\n    function setRewards(address _rewards) external {\n        require(msg.sender == owner, \"!auth\");\n        rewards = _rewards;\n    }\n\n    /**\n     * @notice  Approve crvDepositorWrapper to transfer contract CRV\n     *          and rewards to transfer cvxCrv\n     */\n    function setApprovals() external {\n        IERC20(crv).safeApprove(crvDepositorWrapper, 0);\n        IERC20(crv).safeApprove(crvDepositorWrapper, type(uint256).max);\n\n        IERC20(cvxCrv).safeApprove(rewards, 0);\n        IERC20(cvxCrv).safeApprove(rewards, type(uint256).max);\n    }\n\n    /**\n     * @notice Transfer stuck ERC20 tokens to `_to`\n     */\n    function rescueToken(address _token, address _to) external {\n        require(msg.sender == owner, \"!auth\");\n        require(_token != crv && _token != cvx && _token != cvxCrv, \"not allowed\");\n\n        uint256 bal = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(_to, bal);\n    }\n\n    /**\n     * @dev Collects cvxCRV rewards from cvxRewardPool, converts any CRV deposited directly from\n     *      the booster, and then applies the rewards to the cvxLocker, rewarding the caller in the process.\n     */\n    function distribute() external {\n        // If keeper enabled, require\n        if (keeper != address(0)) {\n            require(msg.sender == keeper, \"!auth\");\n        }\n\n        //convert crv to cvxCrv\n        uint256 crvBal = IERC20(crv).balanceOf(address(this));\n        if (crvBal > 0) {\n            uint256 minOut = ICrvDepositor(crvDepositorWrapper).getMinOut(crvBal, outputBps);\n            ICrvDepositor(crvDepositorWrapper).deposit(crvBal, minOut, true, address(0));\n        }\n\n        //distribute cvxcrv\n        uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));\n\n        if (cvxCrvBal > 0) {\n            uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);\n            cvxCrvBal = cvxCrvBal.sub(incentiveAmount);\n\n            //send incentives\n            IERC20(cvxCrv).safeTransfer(msg.sender, incentiveAmount);\n\n            //update rewards\n            IAuraLocker(rewards).queueNewRewards(cvxCrvBal);\n\n            emit RewardsDistributed(cvxCrv, cvxCrvBal);\n        }\n    }\n\n    /**\n     * @notice Allow generic token distribution in case a new reward is ever added\n     */\n    function distributeOther(IERC20 _token) external {\n        require(address(_token) != crv && address(_token) != cvxCrv, \"not allowed\");\n\n        uint256 bal = _token.balanceOf(address(this));\n\n        if (bal > 0) {\n            uint256 incentiveAmount = bal.mul(callIncentive).div(denominator);\n            bal = bal.sub(incentiveAmount);\n\n            //send incentives\n            _token.safeTransfer(msg.sender, incentiveAmount);\n\n            //approve\n            _token.safeApprove(rewards, 0);\n            _token.safeApprove(rewards, type(uint256).max);\n\n            //update rewards\n            IAuraLocker(rewards).notifyRewardAmount(address(_token), bal);\n\n            emit RewardsDistributed(address(_token), bal);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/BalLiquidityProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IVault } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title   BalLiquidityProvider\n * @notice  Provides initial liquidity to a Balancer pool on behalf of a given DAO\n */\ncontract BalLiquidityProvider {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable startToken;\n    IERC20 public immutable pairToken;\n    uint256 public minPairAmount;\n\n    address private immutable provider;\n    address public immutable dao;\n\n    IVault public immutable bVault;\n\n    event LiquidityProvided(uint256[] input, uint256 output);\n    event MinPairAmountChanged(uint256 oldMinPairAmount, uint256 newMinPairAmount);\n\n    constructor(\n        address _startToken,\n        address _pairToken,\n        uint256 _minPairAmount,\n        address _dao,\n        address _bVault\n    ) {\n        startToken = IERC20(_startToken);\n        pairToken = IERC20(_pairToken);\n        minPairAmount = _minPairAmount;\n        provider = msg.sender;\n        dao = _dao;\n        bVault = IVault(_bVault);\n    }\n\n    /**\n     * @dev Provides liquidity on behalf of the dao, in a non-custodial manner.\n     *      Has protections in place to ensure that no erroneous liquidity data gets added.\n     */\n    function provideLiquidity(bytes32 _poolId, IVault.JoinPoolRequest memory _request) public {\n        require(msg.sender == provider, \"!auth\");\n        require(_request.assets.length == 2 && _request.maxAmountsIn.length == 2, \"!valid\");\n        require(pairToken.balanceOf(address(this)) > minPairAmount, \"!minLiq\");\n\n        for (uint256 i = 0; i < 2; i++) {\n            address asset = address(_request.assets[i]);\n            require(asset == address(startToken) || asset == address(pairToken), \"!asset\");\n\n            IERC20 tkn = IERC20(asset);\n            uint256 bal = tkn.balanceOf(address(this));\n            require(bal > 0 && bal == _request.maxAmountsIn[i], \"!bal\");\n\n            tkn.safeApprove(address(bVault), 0);\n            tkn.safeApprove(address(bVault), bal);\n        }\n\n        (address pool, ) = bVault.getPool(_poolId);\n        uint256 supplyBefore = IERC20(pool).totalSupply();\n        require(supplyBefore == 0, \"!init\");\n\n        bVault.joinPool(_poolId, address(this), dao, _request);\n\n        uint256 balAfter = IERC20(pool).balanceOf(dao);\n        require(balAfter > 0, \"!mint\");\n\n        emit LiquidityProvided(_request.maxAmountsIn, balAfter);\n    }\n\n    /**\n     * @dev Allows the DAO to change the minimum amount of the pair token that must be added as liquidity\n     */\n    function changeMinPairAmount(uint256 _newAmount) external {\n        require(msg.sender == dao, \"!auth\");\n        emit MinPairAmountChanged(minPairAmount, _newAmount);\n        minPairAmount = _newAmount;\n    }\n\n    /**\n     * @dev Rescues a given token from the contract.\n     * Only provider or DAO can call this function.\n     */\n    function rescueToken(address _erc20) external {\n        require(msg.sender == provider || msg.sender == dao, \"!auth\");\n        IERC20 tkn = IERC20(_erc20);\n        tkn.safeTransfer(dao, tkn.balanceOf(address(this)));\n    }\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/StashFactoryV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/IProxyFactory.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title   StashFactoryV2\n * @author  ConvexFinance\n * @notice  Factory to deploy reward stash contracts that handle extra rewards\n */\ncontract StashFactoryV2 {\n    using Address for address;\n\n    bytes4 private constant rewarded_token = 0x16fa50b1; //rewarded_token()\n    bytes4 private constant reward_tokens = 0x54c49fe9; //reward_tokens(uint256)\n    bytes4 private constant rewards_receiver = 0x01ddabf1; //rewards_receiver(address)\n\n    address public immutable operator;\n    address public immutable rewardFactory;\n    address public immutable proxyFactory;\n\n    address public v1Implementation;\n    address public v2Implementation;\n    address public v3Implementation;\n\n    event StashCreated(address stash, uint256 stashVersion);\n\n    /**\n     * @param _operator       Operator is Booster\n     * @param _rewardFactory  Factory that creates reward contract that are \n     *                        VirtualBalanceRewardPool's used for extra pool rewards\n     * @param _proxyFactory   Deploy proxies with stash implementation\n     */\n    constructor(address _operator, address _rewardFactory, address _proxyFactory) public {\n        operator = _operator;\n        rewardFactory = _rewardFactory;\n        proxyFactory = _proxyFactory;\n    }\n\n    function setImplementation(address _v1, address _v2, address _v3) external{\n        require(msg.sender == IDeposit(operator).owner(),\"!auth\");\n\n        v1Implementation = _v1;\n        v2Implementation = _v2;\n        v3Implementation = _v3;\n    }\n\n    //Create a stash contract for the given gauge.\n    //function calls are different depending on the version of curve gauges so determine which stash type is needed\n    function CreateStash(uint256 _pid, address _gauge, address _staker, uint256 _stashVersion) external returns(address){\n        require(msg.sender == operator, \"!authorized\");\n\n        if(_stashVersion == uint256(3) && IsV3(_gauge)){\n            //v3\n            require(v3Implementation!=address(0),\"0 impl\");\n            address stash = IProxyFactory(proxyFactory).clone(v3Implementation);\n            IStash(stash).initialize(_pid,operator,_staker,_gauge,rewardFactory);\n            emit StashCreated(stash, _stashVersion);\n            return stash;\n        }else if(_stashVersion == uint256(1) && IsV1(_gauge)){\n            //v1\n            require(v1Implementation!=address(0),\"0 impl\");\n            address stash = IProxyFactory(proxyFactory).clone(v1Implementation);\n            IStash(stash).initialize(_pid,operator,_staker,_gauge,rewardFactory);\n            emit StashCreated(stash, _stashVersion);\n            return stash;\n        }else if(_stashVersion == uint256(2) && !IsV3(_gauge) && IsV2(_gauge)){\n            //v2\n            require(v2Implementation!=address(0),\"0 impl\");\n            address stash = IProxyFactory(proxyFactory).clone(v2Implementation);\n            IStash(stash).initialize(_pid,operator,_staker,_gauge,rewardFactory);\n            emit StashCreated(stash, _stashVersion);\n            return stash;\n        }\n        bool isV1 = IsV1(_gauge);\n        bool isV2 = IsV2(_gauge);\n        bool isV3 = IsV3(_gauge);\n        require(!isV1 && !isV2 && !isV3,\"stash version mismatch\");\n        return address(0);\n    }\n\n    function IsV1(address _gauge) private returns(bool){\n        bytes memory data = abi.encode(rewarded_token);\n        (bool success,) = _gauge.call(data);\n        return success;\n    }\n\n    function IsV2(address _gauge) private returns(bool){\n        bytes memory data = abi.encodeWithSelector(reward_tokens,uint256(0));\n        (bool success,) = _gauge.call(data);\n        return success;\n    }\n\n    function IsV3(address _gauge) private returns(bool){\n        bytes memory data = abi.encodeWithSelector(rewards_receiver,address(0));\n        (bool success,) = _gauge.call(data);\n        return success;\n    }\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/PoolManagerSecondaryProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/IGaugeController.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\n\n/**\n * @title   PoolManagerSecondaryProxy\n * @author  ConvexFinance\n * @notice  Basically a PoolManager that has a better shutdown and calls addPool on PoolManagerProxy. \n *          Immutable pool manager proxy to enforce that when a  pool is shutdown, the proper number\n *          of lp tokens are returned to the booster contract for withdrawal.\n */\ncontract PoolManagerSecondaryProxy{\n    using SafeMath for uint256;\n\n    address public immutable gaugeController;\n    address public immutable pools;\n    address public immutable booster;\n    address public owner;\n    address public operator;\n    bool public isShutdown;\n\n    mapping(address => bool) public usedMap;\n\n    /**\n     * @param _gaugeController Curve Gauge controller (0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB)\n     * @param _pools PoolManagerProxy (0x5F47010F230cE1568BeA53a06eBAF528D05c5c1B)\n     * @param _booster Booster\n     * @param _owner Executoor\n     */\n    constructor(\n        address _gaugeController,\n        address _pools,\n        address _booster,\n        address _owner\n    ) public {\n        gaugeController = _gaugeController;\n        pools = _pools;\n        booster = _booster;\n        owner = _owner; \n        operator = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"!owner\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operator == msg.sender, \"!op\");\n        _;\n    }\n\n    //set owner - only OWNER\n    function setOwner(address _owner) external onlyOwner{\n        owner = _owner;\n    }\n\n    //set operator - only OWNER\n    function setOperator(address _operator) external onlyOwner{\n        operator = _operator;\n    }\n\n    //manual set an address to used state\n    function setUsedAddress(address[] memory usedList) external onlyOwner{\n        for(uint i=0; i < usedList.length; i++){\n            usedMap[usedList[i]] = true;\n        }\n    }\n\n    //shutdown pool management and disallow new pools. change is immutable\n    function shutdownSystem() external onlyOwner{\n        isShutdown = true;\n    }\n\n    /**\n     * @notice  Shutdown a pool - only OPERATOR\n     * @dev     Shutdowns a pool and ensures all the LP tokens are properly\n     *          withdrawn to the Booster contract \n     */\n    function shutdownPool(uint256 _pid) external onlyOperator returns(bool){\n        //get pool info\n        (address lptoken, address depositToken,,,,bool isshutdown) = IPools(booster).poolInfo(_pid);\n        require(!isshutdown, \"already shutdown\");\n\n        //shutdown pool and get before and after amounts\n        uint256 beforeBalance = IERC20(lptoken).balanceOf(booster);\n        IPools(pools).shutdownPool(_pid);\n        uint256 afterBalance = IERC20(lptoken).balanceOf(booster);\n\n        //check that proper amount of tokens were withdrawn(will also fail if already shutdown)\n        require( afterBalance.sub(beforeBalance) >= IERC20(depositToken).totalSupply(), \"supply mismatch\");\n\n        return true;\n    }\n\n    //add a new pool if it has weight on the gauge controller - only OPERATOR\n    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external onlyOperator returns(bool){\n        //check that the pool as weight\n        uint256 weight = IGaugeController(gaugeController).get_gauge_weight(_gauge);\n        require(weight > 0, \"must have weight\");\n\n        return _addPool(_lptoken, _gauge, _stashVersion);\n    }\n\n    //force add a new pool, but only for addresses that have never been used before - only OPERATOR\n    function forceAddPool(address _lptoken, address _gauge, uint256 _stashVersion) external onlyOperator returns(bool){\n        require(!usedMap[_lptoken] && !usedMap[_gauge], \"cant force used pool\");\n\n        return _addPool(_lptoken, _gauge, _stashVersion);\n    }\n\n    //internal add pool and updated used list\n    function _addPool(address _lptoken, address _gauge, uint256 _stashVersion) internal returns(bool){\n        require(!isShutdown, \"shutdown\");\n\n        usedMap[_lptoken] = true;\n        usedMap[_gauge] = true;\n\n        return IPools(pools).addPool(_lptoken,_gauge,_stashVersion);\n    }\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/Booster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title   Booster\n * @author  ConvexFinance\n * @notice  Main deposit contract; keeps track of pool info & user deposits; distributes rewards.\n * @dev     They say all paths lead to Rome, and the cvxBooster is no different. This is where it all goes down.\n *          It is responsible for tracking all the pools, it collects rewards from all pools and redirects it.\n */\ncontract Booster{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable crv;\n    address public immutable voteOwnership;\n    address public immutable voteParameter;\n\n    uint256 public lockIncentive = 825; //incentive to crv stakers\n    uint256 public stakerIncentive = 825; //incentive to native token stakers\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    uint256 public platformFee = 0; //possible fee to build treasury\n    uint256 public constant MaxFees = 2500;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public owner;\n    address public feeManager;\n    address public poolManager;\n    address public immutable staker;\n    address public immutable minter;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public rewardArbitrator;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards; //cvx rewards\n    address public lockRewards; //cvxCrv rewards(crv)\n\n    mapping(address => FeeDistro) public feeTokens;\n    struct FeeDistro {\n        address distro;\n        address rewards;\n        bool active;\n    }\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address crvRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n    mapping(address => bool) public gaugeMap;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n\n    event PoolAdded(address lpToken, address gauge, address token, address rewardPool, address stash, uint256 pid);\n    event PoolShutdown(uint256 poolId);\n\n    event OwnerUpdated(address newOwner);\n    event FeeManagerUpdated(address newFeeManager);\n    event PoolManagerUpdated(address newPoolManager);\n    event FactoriesUpdated(address rewardFactory, address stashFactory, address tokenFactory);\n    event ArbitratorUpdated(address newArbitrator);\n    event VoteDelegateUpdated(address newVoteDelegate);\n    event RewardContractsUpdated(address lockRewards, address stakerRewards);\n    event FeesUpdated(uint256 lockIncentive, uint256 stakerIncentive, uint256 earmarkIncentive, uint256 platformFee);\n    event TreasuryUpdated(address newTreasury);\n    event FeeInfoUpdated(address feeDistro, address lockFees, address feeToken);\n    event FeeInfoChanged(address feeDistro, bool active);\n\n    /**\n     * @dev Constructor doing what constructors do. It is noteworthy that\n     *      a lot of basic config is set to 0 - expecting subsequent calls to setFeeInfo etc.\n     * @param _staker                 VoterProxy (locks the crv and adds to all gauges)\n     * @param _minter                 CVX token, or the thing that mints it\n     * @param _crv                    CRV\n     * @param _voteOwnership          Address of the Curve DAO responsible for ownership stuff\n     * @param _voteParameter          Address of the Curve DA"
    }
  ]
}