{
  "Title": "[M-01] Centralization risk: admin have privileges: admin can set address to mint any amount of frxETH, can set any address as validator, and change important state in frxETHMinter and withdraw fund from frcETHMinter",
  "Content": "\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/ERC20/ERC20PermitPermissionedMint.sol#L41>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/ERC20/ERC20PermitPermissionedMint.sol#L53>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/ERC20/ERC20PermitPermissionedMint.sol#L65>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/ERC20/ERC20PermitPermissionedMint.sol#L76>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/ERC20/ERC20PermitPermissionedMint.sol#L94>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/frxETHMinter.sol#L159>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/frxETHMinter.sol#L166>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/frxETHMinter.sol#L177>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/frxETHMinter.sol#L184>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/frxETHMinter.sol#L191>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/frxETHMinter.sol#L199>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/OperatorRegistry.sol#L53>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/OperatorRegistry.sol#L61>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/OperatorRegistry.sol#L69>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/OperatorRegistry.sol#L82>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/OperatorRegistry.sol#L93>\n\n### Impact\n\nAdmin have privileges: admin can set address to mint any amount of frxETH, can set any address as validator, and change important state in frxETHMinter and withdraw fund from frcETHMinter.\n\nNote the modifier below, either the timelock governance contract or the contract owner can access to all the high privilege function.\n\n        modifier onlyByOwnGov() {\n            require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n            _;\n        }\n\nThere are numerous methods that the admin could apply to rug pull the protocol and take all user funds.\n\nThe admin can\n\n    add or remove validator from OperatorRegistry.sol\n\n    set minter address or remove minter address in frxETH.sol\n\n    minter set by admin can mint or burn any amount of frxETH token.\n\n    set ETE deduction ratio, withdraw any amount of ETH or ERC20 token in frcETHMinter.sol\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nWithout significant redesign it is not possible to avoid the admin being able to rug pull the protocol.\n\nAs a result the recommendation is to set all admin functions behind either a timelocked DAO or at least a timelocked multisig contract.\n\n**[FortisFortuna (Frax) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/107#issuecomment-1257281609):**\n > We are well aware of the permission structure. The owner will most likely be a large multisig. We mentioned the Frax Multisig in the scope too.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/107#issuecomment-1276220502):**\n > Going to use this issue as the canonical issue for all \"malicious owner\" type reports.  The protocol does have some serious \"trust\" in the administrator and the highlighted issues are important for end users to understand and should be part of the report. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-09-frax",
  "Code": [
    {
      "filename": "src/ERC20/ERC20PermitPermissionedMint.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"../Utils/Owned.sol\";\n\n/// @title Parent contract for frxETH.sol\n/** @notice Combines Openzeppelin's ERC20Permit and ERC20Burnable with Synthetix's Owned. \n    Also includes a list of authorized minters */\n/// @dev frxETH adheres to EIP-712/EIP-2612 and can use permits\ncontract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n    // Core\n    address public timelock_address;\n\n    // Minters\n    address[] public minters_array; // Allowed to mint\n    mapping(address => bool) public minters; // Mapping is also used for faster verification\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _creator_address,\n        address _timelock_address,\n        string memory _name,\n        string memory _symbol\n    ) \n    ERC20(_name, _symbol)\n    ERC20Permit(_name) \n    Owned(_creator_address)\n    {\n      timelock_address = _timelock_address;\n    }\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyMinters() {\n       require(minters[msg.sender] == true, \"Only minters\");\n        _;\n    } \n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // Used by minters when user redeems\n    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {\n        super.burnFrom(b_address, b_amount);\n        emit TokenMinterBurned(b_address, msg.sender, b_amount);\n    }\n\n    // This function is what other minters will call to mint new tokens \n    function minter_mint(address m_address, uint256 m_amount) public onlyMinters {\n        super._mint(m_address, m_amount);\n        emit TokenMinterMinted(msg.sender, m_address, m_amount);\n    }\n\n    // Adds whitelisted minters \n    function addMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n\n        require(minters[minter_address] == false, \"Address already exists\");\n        minters[minter_address] = true; \n        minters_array.push(minter_address);\n\n        emit MinterAdded(minter_address);\n    }\n\n    // Remove a minter \n    function removeMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == true, \"Address nonexistant\");\n        \n        // Delete from the mapping\n        delete minters[minter_address];\n\n        // 'Delete' from the array by setting the address to 0x0\n        for (uint i = 0; i < minters_array.length; i++){ \n            if (minters_array[i] == minter_address) {\n                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                break;\n            }\n        }\n\n        emit MinterRemoved(minter_address);\n    }\n\n    function setTimelock(address _timelock_address) public onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\"); \n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    /* ========== EVENTS ========== */\n    \n    event TokenMinterBurned(address indexed from, address indexed to, uint256 amount);\n    event TokenMinterMinted(address indexed from, address indexed to, uint256 amount);\n    event MinterAdded(address minter_address);\n    event MinterRemoved(address minter_address);\n    event TimelockChanged(address timelock_address);\n}"
    },
    {
      "filename": "src/ERC20/ERC20PermitPermissionedMint.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"../Utils/Owned.sol\";\n\n/// @title Parent contract for frxETH.sol\n/** @notice Combines Openzeppelin's ERC20Permit and ERC20Burnable with Synthetix's Owned. \n    Also includes a list of authorized minters */\n/// @dev frxETH adheres to EIP-712/EIP-2612 and can use permits\ncontract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n    // Core\n    address public timelock_address;\n\n    // Minters\n    address[] public minters_array; // Allowed to mint\n    mapping(address => bool) public minters; // Mapping is also used for faster verification\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _creator_address,\n        address _timelock_address,\n        string memory _name,\n        string memory _symbol\n    ) \n    ERC20(_name, _symbol)\n    ERC20Permit(_name) \n    Owned(_creator_address)\n    {\n      timelock_address = _timelock_address;\n    }\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyMinters() {\n       require(minters[msg.sender] == true, \"Only minters\");\n        _;\n    } \n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // Used by minters when user redeems\n    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {\n        super.burnFrom(b_address, b_amount);\n        emit TokenMinterBurned(b_address, msg.sender, b_amount);\n    }\n\n    // This function is what other minters will call to mint new tokens \n    function minter_mint(address m_address, uint256 m_amount) public onlyMinters {\n        super._mint(m_address, m_amount);\n        emit TokenMinterMinted(msg.sender, m_address, m_amount);\n    }\n\n    // Adds whitelisted minters \n    function addMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n\n        require(minters[minter_address] == false, \"Address already exists\");\n        minters[minter_address] = true; \n        minters_array.push(minter_address);\n\n        emit MinterAdded(minter_address);\n    }\n\n    // Remove a minter \n    function removeMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == true, \"Address nonexistant\");\n        \n        // Delete from the mapping\n        delete minters[minter_address];\n\n        // 'Delete' from the array by setting the address to 0x0\n        for (uint i = 0; i < minters_array.length; i++){ \n            if (minters_array[i] == minter_address) {\n                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                break;\n            }\n        }\n\n        emit MinterRemoved(minter_address);\n    }\n\n    function setTimelock(address _timelock_address) public onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\"); \n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    /* ========== EVENTS ========== */\n    \n    event TokenMinterBurned(address indexed from, address indexed to, uint256 amount);\n    event TokenMinterMinted(address indexed from, address indexed to, uint256 amount);\n    event MinterAdded(address minter_address);\n    event MinterRemoved(address minter_address);\n    event TimelockChanged(address timelock_address);\n}"
    },
    {
      "filename": "src/ERC20/ERC20PermitPermissionedMint.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"../Utils/Owned.sol\";\n\n/// @title Parent contract for frxETH.sol\n/** @notice Combines Openzeppelin's ERC20Permit and ERC20Burnable with Synthetix's Owned. \n    Also includes a list of authorized minters */\n/// @dev frxETH adheres to EIP-712/EIP-2612 and can use permits\ncontract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n    // Core\n    address public timelock_address;\n\n    // Minters\n    address[] public minters_array; // Allowed to mint\n    mapping(address => bool) public minters; // Mapping is also used for faster verification\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _creator_address,\n        address _timelock_address,\n        string memory _name,\n        string memory _symbol\n    ) \n    ERC20(_name, _symbol)\n    ERC20Permit(_name) \n    Owned(_creator_address)\n    {\n      timelock_address = _timelock_address;\n    }\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyMinters() {\n       require(minters[msg.sender] == true, \"Only minters\");\n        _;\n    } \n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // Used by minters when user redeems\n    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {\n        super.burnFrom(b_address, b_amount);\n        emit TokenMinterBurned(b_address, msg.sender, b_amount);\n    }\n\n    // This function is what other minters will call to mint new tokens \n    function minter_mint(address m_address, uint256 m_amount) public onlyMinters {\n        super._mint(m_address, m_amount);\n        emit TokenMinterMinted(msg.sender, m_address, m_amount);\n    }\n\n    // Adds whitelisted minters \n    function addMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n\n        require(minters[minter_address] == false, \"Address already exists\");\n        minters[minter_address] = true; \n        minters_array.push(minter_address);\n\n        emit MinterAdded(minter_address);\n    }\n\n    // Remove a minter \n    function removeMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == true, \"Address nonexistant\");\n        \n        // Delete from the mapping\n        delete minters[minter_address];\n\n        // 'Delete' from the array by setting the address to 0x0\n        for (uint i = 0; i < minters_array.length; i++){ \n            if (minters_array[i] == minter_address) {\n                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                break;\n            }\n        }\n\n        emit MinterRemoved(minter_address);\n    }\n\n    function setTimelock(address _timelock_address) public onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\"); \n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    /* ========== EVENTS ========== */\n    \n    event TokenMinterBurned(address indexed from, address indexed to, uint256 amount);\n    event TokenMinterMinted(address indexed from, address indexed to, uint256 amount);\n    event MinterAdded(address minter_address);\n    event MinterRemoved(address minter_address);\n    event TimelockChanged(address timelock_address);\n}"
    },
    {
      "filename": "src/ERC20/ERC20PermitPermissionedMint.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"../Utils/Owned.sol\";\n\n/// @title Parent contract for frxETH.sol\n/** @notice Combines Openzeppelin's ERC20Permit and ERC20Burnable with Synthetix's Owned. \n    Also includes a list of authorized minters */\n/// @dev frxETH adheres to EIP-712/EIP-2612 and can use permits\ncontract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n    // Core\n    address public timelock_address;\n\n    // Minters\n    address[] public minters_array; // Allowed to mint\n    mapping(address => bool) public minters; // Mapping is also used for faster verification\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _creator_address,\n        address _timelock_address,\n        string memory _name,\n        string memory _symbol\n    ) \n    ERC20(_name, _symbol)\n    ERC20Permit(_name) \n    Owned(_creator_address)\n    {\n      timelock_address = _timelock_address;\n    }\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyMinters() {\n       require(minters[msg.sender] == true, \"Only minters\");\n        _;\n    } \n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // Used by minters when user redeems\n    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {\n        super.burnFrom(b_address, b_amount);\n        emit TokenMinterBurned(b_address, msg.sender, b_amount);\n    }\n\n    // This function is what other minters will call to mint new tokens \n    function minter_mint(address m_address, uint256 m_amount) public onlyMinters {\n        super._mint(m_address, m_amount);\n        emit TokenMinterMinted(msg.sender, m_address, m_amount);\n    }\n\n    // Adds whitelisted minters \n    function addMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n\n        require(minters[minter_address] == false, \"Address already exists\");\n        minters[minter_address] = true; \n        minters_array.push(minter_address);\n\n        emit MinterAdded(minter_address);\n    }\n\n    // Remove a minter \n    function removeMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == true, \"Address nonexistant\");\n        \n        // Delete from the mapping\n        delete minters[minter_address];\n\n        // 'Delete' from the array by setting the address to 0x0\n        for (uint i = 0; i < minters_array.length; i++){ \n            if (minters_array[i] == minter_address) {\n                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                break;\n            }\n        }\n\n        emit MinterRemoved(minter_address);\n    }\n\n    function setTimelock(address _timelock_address) public onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\"); \n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    /* ========== EVENTS ========== */\n    \n    event TokenMinterBurned(address indexed from, address indexed to, uint256 amount);\n    event TokenMinterMinted(address indexed from, address indexed to, uint256 amount);\n    event MinterAdded(address minter_address);\n    event MinterRemoved(address minter_address);\n    event TimelockChanged(address timelock_address);\n}"
    },
    {
      "filename": "src/ERC20/ERC20PermitPermissionedMint.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"../Utils/Owned.sol\";\n\n/// @title Parent contract for frxETH.sol\n/** @notice Combines Openzeppelin's ERC20Permit and ERC20Burnable with Synthetix's Owned. \n    Also includes a list of authorized minters */\n/// @dev frxETH adheres to EIP-712/EIP-2612 and can use permits\ncontract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n    // Core\n    address public timelock_address;\n\n    // Minters\n    address[] public minters_array; // Allowed to mint\n    mapping(address => bool) public minters; // Mapping is also used for faster verification\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _creator_address,\n        address _timelock_address,\n        string memory _name,\n        string memory _symbol\n    ) \n    ERC20(_name, _symbol)\n    ERC20Permit(_name) \n    Owned(_creator_address)\n    {\n      timelock_address = _timelock_address;\n    }\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyMinters() {\n       require(minters[msg.sender] == true, \"Only minters\");\n        _;\n    } \n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // Used by minters when user redeems\n    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {\n        super.burnFrom(b_address, b_amount);\n        emit TokenMinterBurned(b_address, msg.sender, b_amount);\n    }\n\n    // This function is what other minters will call to mint new tokens \n    function minter_mint(address m_address, uint256 m_amount) public onlyMinters {\n        super._mint(m_address, m_amount);\n        emit TokenMinterMinted(msg.sender, m_address, m_amount);\n    }\n\n    // Adds whitelisted minters \n    function addMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n\n        require(minters[minter_address] == false, \"Address already exists\");\n        minters[minter_address] = true; \n        minters_array.push(minter_address);\n\n        emit MinterAdded(minter_address);\n    }\n\n    // Remove a minter \n    function removeMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == true, \"Address nonexistant\");\n        \n        // Delete from the mapping\n        delete minters[minter_address];\n\n        // 'Delete' from the array by setting the address to 0x0\n        for (uint i = 0; i < minters_array.length; i++){ \n            if (minters_array[i] == minter_address) {\n                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                break;\n            }\n        }\n\n        emit MinterRemoved(minter_address);\n    }\n\n    function setTimelock(address _timelock_address) public onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\"); \n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    /* ========== EVENTS ========== */\n    \n    event TokenMinterBurned(address indexed from, address indexed to, uint256 amount);\n    event TokenMinterMinted(address indexed from, address indexed to, uint256 amount);\n    event MinterAdded(address minter_address);\n    event MinterRemoved(address minter_address);\n    event TimelockChanged(address timelock_address);\n}"
    },
    {
      "filename": "src/frxETHMinter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ============================ frxETHMinter ==========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Justin Moore: https://github.com/0xJM\n\n// Reviewer(s) / Contributor(s)\n// Travis Moore: https://github.com/FortisFortuna\n// Dennis: https://github.com/denett\n// Jamie Turley: https://github.com/jyturley\n\nimport { frxETH } from \"./frxETH.sol\";\nimport { IsfrxETH } from \"./IsfrxETH.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IDepositContract } from \"./DepositContract.sol\";\nimport \"./OperatorRegistry.sol\";\n\n/// @title Authorized minter contract for frxETH\n/// @notice Accepts user-supplied ETH and converts it to frxETH (submit()), and also optionally inline stakes it for sfrxETH (submitAndDeposit())\n/** @dev Has permission to mint frxETH. \n    Once +32 ETH has accumulated, adds it to a validator, which then deposits it for ETH 2.0 staking (depositEther())\n    Withhold ratio refers to what percentage of ETH this contract keeps whenever a user makes a deposit. 0% is kept initially */\ncontract frxETHMinter is OperatorRegistry, ReentrancyGuard {    \n    uint256 public constant DEPOSIT_SIZE = 32 ether; // ETH 2.0 minimum deposit size\n    uint256 public constant RATIO_PRECISION = 1e6; // 1,000,000 \n\n    uint256 public withholdRatio; // What we keep and don't deposit whenever someone submit()'s ETH\n    uint256 public currentWithheldETH; // Needed for internal tracking\n    mapping(bytes => bool) public activeValidators; // Tracks validators (via their pubkeys) that already have 32 ETH in them\n\n    IDepositContract public immutable depositContract; // ETH 2.0 deposit contract\n    frxETH public immutable frxETHToken;\n    IsfrxETH public immutable sfrxETHToken;\n\n    bool public submitPaused;\n    bool public depositEtherPaused;\n\n    constructor(\n        address depositContractAddress, \n        address frxETHAddress, \n        address sfrxETHAddress, \n        address _owner, \n        address _timelock_address,\n        bytes memory _withdrawalCredential\n    ) OperatorRegistry(_owner, _timelock_address, _withdrawalCredential) {\n        depositContract = IDepositContract(depositContractAddress);\n        frxETHToken = frxETH(frxETHAddress);\n        sfrxETHToken = IsfrxETH(sfrxETHAddress);\n        withholdRatio = 0; // No ETH is withheld initially\n        currentWithheldETH = 0;\n    }\n\n    /// @notice Mint frxETH and deposit it to receive sfrxETH in one transaction\n    /** @dev Could try using EIP-712 / EIP-2612 here in the future if you replace this contract,\n        but you might run into msg.sender vs tx.origin issues with the ERC4626 */\n    function submitAndDeposit(address recipient) external payable returns (uint256 shares) {\n        // Give the frxETH to this contract after it is generated\n        _submit(address(this));\n\n        // Approve frxETH to sfrxETH for staking\n        frxETHToken.approve(address(sfrxETHToken), msg.value);\n\n        // Deposit the frxETH and give the generated sfrxETH to the final recipient\n        uint256 sfrxeth_recieved = sfrxETHToken.deposit(msg.value, recipient);\n        require(sfrxeth_recieved > 0, 'No sfrxETH was returned');\n\n        return sfrxeth_recieved;\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds. Internal portion\n    function _submit(address recipient) internal nonReentrant {\n        // Initial pause and value checks\n        require(!submitPaused, \"Submit is paused\");\n        require(msg.value != 0, \"Cannot submit 0\");\n\n        // Give the sender frxETH\n        frxETHToken.minter_mint(recipient, msg.value);\n\n        // Track the amount of ETH that we are keeping\n        uint256 withheld_amt = 0;\n        if (withholdRatio != 0) {\n            withheld_amt = (msg.value * withholdRatio) / RATIO_PRECISION;\n            currentWithheldETH += withheld_amt;\n        }\n\n        emit ETHSubmitted(msg.sender, recipient, msg.value, withheld_amt);\n    }\n\n    /// @notice Mint frxETH to the sender depending on the ETH value sent\n    function submit() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds\n    function submitAndGive(address recipient) external payable {\n        _submit(recipient);\n    }\n\n    /// @notice Fallback to minting frxETH to the sender\n    receive() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Deposit batches of ETH to the ETH 2.0 deposit contract\n    /// @dev Usually a bot will call this periodically\n    function depositEther() external nonReentrant {\n        // Initial pause check\n        require(!depositEtherPaused, \"Depositing ETH is paused\");\n\n        // See how many deposits can be made. Truncation desired.\n        uint256 numDeposits = (address(this).balance - currentWithheldETH) / DEPOSIT_SIZE;\n        require(numDeposits > 0, \"Not enough ETH in contract\");\n\n        // Give each deposit chunk to an empty validator\n        for (uint256 i = 0; i < numDeposits; ++i) {\n            // Get validator information\n            (\n                bytes memory pubKey,\n                bytes memory withdrawalCredential,\n                bytes memory signature,\n                bytes32 depositDataRoot\n            ) = getNextValidator(); // Will revert if there are not enough free validators\n\n            // Make sure the validator hasn't been deposited into already, to prevent stranding an extra 32 eth\n            // until withdrawals are allowed\n            require(!activeValidators[pubKey], \"Validator already has 32 ETH\");\n\n            // Deposit the ether in the ETH 2.0 deposit contract\n            depositContract.deposit{value: DEPOSIT_SIZE}(\n                pubKey,\n                withdrawalCredential,\n                signature,\n                depositDataRoot\n            );\n\n            // Set the validator as used so it won't get an extra 32 ETH\n            activeValidators[pubKey] = true;\n\n            emit DepositSent(pubKey, withdrawalCredential);\n        }\n    }\n\n    /// @param newRatio of ETH that is sent to deposit contract vs withheld, 1e6 precision\n    /// @notice An input of 1e6 results in 100% of Eth deposited, 0% withheld\n    function setWithholdRatio(uint256 newRatio) external onlyByOwnGov {\n        require (newRatio <= RATIO_PRECISION, \"Ratio cannot surpass 100%\");\n        withholdRatio = newRatio;\n        emit WithholdRatioSet(newRatio);\n    }\n\n    /// @notice Give the withheld ETH to the \"to\" address\n    function moveWithheldETH(address payable to, uint256 amount) external onlyByOwnGov {\n        require(amount <= currentWithheldETH, \"Not enough withheld ETH in contract\");\n        currentWithheldETH -= amount;\n\n        (bool success,) = payable(to).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit WithheldETHMoved(to, amount);\n    }\n\n    /// @notice Toggle allowing submites\n    function togglePauseSubmits() external onlyByOwnGov {\n        submitPaused = !submitPaused;\n\n        emit SubmitPaused(submitPaused);\n    }\n\n    /// @notice Toggle allowing depositing ETH to validators\n    function togglePauseDepositEther() external onlyByOwnGov {\n        depositEtherPaused = !depositEtherPaused;\n\n        emit DepositEtherPaused(depositEtherPaused);\n    }\n\n    /// @notice For emergencies if something gets stuck\n    function recoverEther(uint256 amount) external onlyByOwnGov {\n        (bool success,) = address(owner).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit EmergencyEtherRecovered(amount);\n    }\n\n    /// @notice For emergencies if someone accidentally sent some ERC20 tokens here\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\n        require(IERC20(tokenAddress).transfer(owner, tokenAmount), \"recoverERC20: Transfer failed\");\n\n        emit EmergencyERC20Recovered(tokenAddress, tokenAmount);\n    }\n\n    event EmergencyEtherRecovered(uint256 amount);\n    event EmergencyERC20Recovered(address tokenAddress, uint256 tokenAmount);\n    event ETHSubmitted(address indexed sender, address indexed recipient, uint256 sent_amount, uint256 withheld_amt);\n    event DepositEtherPaused(bool new_status);\n    event DepositSent(bytes indexed pubKey, bytes withdrawalCredential);\n    event SubmitPaused(bool new_status);\n    event WithheldETHMoved(address indexed to, uint256 amount);\n    event WithholdRatioSet(uint256 newRatio);\n}"
    },
    {
      "filename": "src/frxETHMinter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ============================ frxETHMinter ==========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Justin Moore: https://github.com/0xJM\n\n// Reviewer(s) / Contributor(s)\n// Travis Moore: https://github.com/FortisFortuna\n// Dennis: https://github.com/denett\n// Jamie Turley: https://github.com/jyturley\n\nimport { frxETH } from \"./frxETH.sol\";\nimport { IsfrxETH } from \"./IsfrxETH.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IDepositContract } from \"./DepositContract.sol\";\nimport \"./OperatorRegistry.sol\";\n\n/// @title Authorized minter contract for frxETH\n/// @notice Accepts user-supplied ETH and converts it to frxETH (submit()), and also optionally inline stakes it for sfrxETH (submitAndDeposit())\n/** @dev Has permission to mint frxETH. \n    Once +32 ETH has accumulated, adds it to a validator, which then deposits it for ETH 2.0 staking (depositEther())\n    Withhold ratio refers to what percentage of ETH this contract keeps whenever a user makes a deposit. 0% is kept initially */\ncontract frxETHMinter is OperatorRegistry, ReentrancyGuard {    \n    uint256 public constant DEPOSIT_SIZE = 32 ether; // ETH 2.0 minimum deposit size\n    uint256 public constant RATIO_PRECISION = 1e6; // 1,000,000 \n\n    uint256 public withholdRatio; // What we keep and don't deposit whenever someone submit()'s ETH\n    uint256 public currentWithheldETH; // Needed for internal tracking\n    mapping(bytes => bool) public activeValidators; // Tracks validators (via their pubkeys) that already have 32 ETH in them\n\n    IDepositContract public immutable depositContract; // ETH 2.0 deposit contract\n    frxETH public immutable frxETHToken;\n    IsfrxETH public immutable sfrxETHToken;\n\n    bool public submitPaused;\n    bool public depositEtherPaused;\n\n    constructor(\n        address depositContractAddress, \n        address frxETHAddress, \n        address sfrxETHAddress, \n        address _owner, \n        address _timelock_address,\n        bytes memory _withdrawalCredential\n    ) OperatorRegistry(_owner, _timelock_address, _withdrawalCredential) {\n        depositContract = IDepositContract(depositContractAddress);\n        frxETHToken = frxETH(frxETHAddress);\n        sfrxETHToken = IsfrxETH(sfrxETHAddress);\n        withholdRatio = 0; // No ETH is withheld initially\n        currentWithheldETH = 0;\n    }\n\n    /// @notice Mint frxETH and deposit it to receive sfrxETH in one transaction\n    /** @dev Could try using EIP-712 / EIP-2612 here in the future if you replace this contract,\n        but you might run into msg.sender vs tx.origin issues with the ERC4626 */\n    function submitAndDeposit(address recipient) external payable returns (uint256 shares) {\n        // Give the frxETH to this contract after it is generated\n        _submit(address(this));\n\n        // Approve frxETH to sfrxETH for staking\n        frxETHToken.approve(address(sfrxETHToken), msg.value);\n\n        // Deposit the frxETH and give the generated sfrxETH to the final recipient\n        uint256 sfrxeth_recieved = sfrxETHToken.deposit(msg."
    }
  ]
}