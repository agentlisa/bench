{
  "Title": "[N-19] `OwnerProxy` can call `selfdestruct()`",
  "Content": "\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L9-L36\n\n### Impact\n\nOwnerProxy's selfdestruct\n\n### Proof of Concept\n\nWhile only the owner (the timelock) can call the execute function, this doesn't mean it can't be compromised or phished to call a malicious `_target`, which could contain a call to `selfdestruct()`.\n\nAs `selfdestruct()` would be a simple OPCODE in the context of the OwnerProxy contract (which is the one using `delegatecall()` in `execute()`), this would destroy the contract.\n\nThis is a known bug in the community (see the Parity Multisig Hack): delegatecalls from contracts are dangerous.\n\n### Recommended Mitigation Steps\n\nConsider making OwnerProxy a library instead of a contract to protect it from being selfdestructed and to further protect its state (that can also be manipulated as a contract)\n\nAlternatively, consider deploying the OwnerProxy contract using CREATE2 so that the contract could be re-created at the same pre-computed address, if need be.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-06-nested",
  "Code": [
    {
      "filename": "contracts/governance/OwnerProxy.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Owner proxy to run atomic actions.\n/// @notice DSProxy-like contract without a cache to simply run\n///         a sequence of atomic actions.\ncontract OwnerProxy is Ownable {\n    /// @notice Execute atomic actions. Only the owner can call this function (e.g. the timelock)\n    /// @param _target Address of the \"script\" to perform a delegatecall\n    /// @param _data The bytes calldata\n    /// @return response The delegatecall response\n    /// @dev Fork from https://github.com/dapphub/ds-proxy/blob/e17a2526ad5c9877ba925ff25c1119f519b7369b/src/proxy.sol#L53\n    /// @dev bytes4 selector must be included in the calldata (_data)\n    function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) {\n        require(_target != address(0), \"OP: INVALID_TARGET\");\n\n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\n            let size := returndatasize()\n\n            response := mload(0x40)\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                revert(add(response, 0x20), size)\n            }\n        }\n    }\n}"
    }
  ]
}