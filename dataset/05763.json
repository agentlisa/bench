{
  "Title": "[G-41] Save one negation by rewriting the statement in `DiamonProxy.sol`",
  "Content": "\n[File: ethereum/contracts/zksync/DiamondProxy.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/DiamondProxy.sol#L31)\n\n```\nrequire(!diamondStorage.isFrozen || !facet.isFreezable, \"q1\");\n```\n\n`!A || !B <=> !(A & B)` which means, it can be rewritten to:\n\n```\nrequire(!(diamondStorage.isFrozen && facet.isFreezable)), \"q1\");\n```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/338#issuecomment-1849048723):**\n > I believe that some penalty may have been applied by me due to repetitive titles. Overall the report is not bad, but I will not change the scoring.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/338).*\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/zksync/DiamondProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {Diamond} from \"./libraries/Diamond.sol\";\n\n/// @title Diamond Proxy Contract (EIP-2535)\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract DiamondProxy {\n    constructor(uint256 _chainId, Diamond.DiamondCutData memory _diamondCut) {\n        // Check that the contract is deployed on the expected chain.\n        // Thus, the contract deployed by the same Create2 factory on the different chain will have different addresses!\n        require(_chainId == block.chainid, \"pr\");\n        Diamond.diamondCut(_diamondCut);\n    }\n\n    /// @dev 1. Find the facet for the function that is called.\n    /// @dev 2. Delegate the execution to the found facet via `delegatecall`.\n    fallback() external payable {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n        // Check whether the data contains a \"full\" selector or it is empty.\n        // Required because Diamond proxy finds a facet by function signature,\n        // which is not defined for data length in range [1, 3].\n        require(msg.data.length >= 4 || msg.data.length == 0, \"Ut\");\n        // Get facet from function selector\n        Diamond.SelectorToFacet memory facet = diamondStorage.selectorToFacet[msg.sig];\n        address facetAddress = facet.facetAddress;\n\n        require(facetAddress != address(0), \"F\"); // Proxy has no facet for this selector\n        require(!diamondStorage.isFrozen || !facet.isFreezable, \"q1\"); // Facet is frozen\n\n        assembly {\n            // The pointer to the free memory slot\n            let ptr := mload(0x40)\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\n            calldatacopy(ptr, 0, calldatasize())\n            // Delegatecall method of the implementation contract returns 0 on error\n            let result := delegatecall(gas(), facetAddress, ptr, calldatasize(), 0, 0)\n            // Get the size of the last return data\n            let size := returndatasize()\n            // Copy the size length of bytes from return data at zero position to pointer position\n            returndatacopy(ptr, 0, size)\n            // Depending on the result value\n            switch result\n            case 0 {\n                // End execution and revert state changes\n                revert(ptr, size)\n            }\n            default {\n                // Return data with length of size at pointers position\n                return(ptr, size)\n            }\n        }\n    }\n}"
    }
  ]
}