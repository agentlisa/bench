{
  "Title": "[7]",
  "Content": "Code of `AccountCodeStorage.getCodeHash()` and `AccountCodeStorage.getCodeSize()` would return wrong values for inputs that are larger than `2^161-1` because code convert the input to uint160 and then return value for that address so if the input was bigger than max value of the uint160 then it when casting happens the calculated address can belong to another contract address. For example, there return value for `2^161 + Contract1_Address` will be the `Contract1_Address` information while there is no contract in `2^161 + Contract1_Address`. Code should make sure that the input uint256 is less than `2^161`.\n```solidity\n    function getCodeSize(uint256 _input) external view override returns (uint256 codeSize) {\n        // We consider the account bytecode size of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODESIZE of A is X, then EXTCODESIZE of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        bytes32 codeHash = getRawCodeHash(account);\n....\n....\n    function getCodeHash(uint256 _input) external view override returns (bytes32) {\n        // We consider the account bytecode hash of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODEHASH of A is X, then EXTCODEHASH of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS) {\n            return EMPTY_STRING_KECCAK;\n        }\n....\n....\n```\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/AccountCodeStorage.sol#L74-L77<br>\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/AccountCodeStorage.sol#L102-L106\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-zksync",
  "Code": [
    {
      "filename": "contracts/AccountCodeStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccountCodeStorage.sol\";\nimport \"./libraries/Utils.sol\";\nimport {DEPLOYER_SYSTEM_CONTRACT, NONCE_HOLDER_SYSTEM_CONTRACT, CURRENT_MAX_PRECOMPILE_ADDRESS} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @notice The storage of this contract serves as a mapping for the code hashes of the 32-byte account addresses.\n * @dev Code hash is not strictly a hash, it's a structure where the first byte denotes the version of the hash,\n * the second byte denotes whether the contract is constructed, and the next two bytes denote the length in 32-byte words.\n * And then the next 28 bytes are the truncated hash.\n * @dev In this version of zkSync, the first byte of the hash MUST be 1.\n * @dev The length of each bytecode MUST be odd.  It's internal code format requirements, due to padding of SHA256 function.\n * @dev It is also assumed that all the bytecode hashes are *known*, i.e. the full bytecodes\n * were published on L1 as calldata. This contract trusts the ContractDeployer and the KnownCodesStorage\n * system contracts to enforce the invariants mentioned above.\n */\ncontract AccountCodeStorage is IAccountCodeStorage {\n    bytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n    modifier onlyDeployer() {\n        require(msg.sender == address(DEPLOYER_SYSTEM_CONTRACT), \"Callable only by the deployer system contract\");\n        _;\n    }\n\n    /// @notice Stores the bytecodeHash of constructing contract.\n    /// @param _address The address of the account to set the codehash to.\n    /// @param _hash The new bytecode hash of the constructing account.\n    /// @dev This method trusts the ContractDeployer to make sure that the bytecode is known and well-formed,\n    /// but checks whether the bytecode hash corresponds to the constructing smart contract.\n    function storeAccountConstructingCodeHash(address _address, bytes32 _hash) external override onlyDeployer {\n        // Check that code hash corresponds to the deploying smart contract\n        require(Utils.isContractConstructing(_hash), \"Code hash is not for a contract on constructor\");\n\n        uint256 addressAsKey = uint256(uint160(_address));\n        assembly {\n            sstore(addressAsKey, _hash)\n        }\n    }\n\n    /// @notice Marks the account bytecodeHash as constructed.\n    /// @param _address The address of the account to mark as constructed\n    function markAccountCodeHashAsConstructed(address _address) external override onlyDeployer {\n        bytes32 codeHash = getRawCodeHash(_address);\n\n        // Check that the code hash corresponds to the deploying smart contract\n        require(Utils.isContractConstructing(codeHash), \"Code hash is not for a contract on constructor\");\n        // Get the bytecode hash with \"isConstructor\" flag equal to false\n        bytes32 constructedBytecodeHash = Utils.constructedBytecodeHash(codeHash);\n\n        uint256 addressAsKey = uint256(uint160(_address));\n        assembly {\n            sstore(addressAsKey, constructedBytecodeHash)\n        }\n    }\n\n    /// @notice Get the codehash stored for an address.\n    /// @param _address The address of the account of which the codehash to return\n    /// @return codeHash The codehash stored for this account.\n    function getRawCodeHash(address _address) public view override returns (bytes32 codeHash) {\n        uint256 addressAsKey = uint256(uint160(_address));\n\n        assembly {\n            codeHash := sload(addressAsKey)\n        }\n    }\n\n    /// @notice Simulate the behavior of the `extcodehash` EVM opcode.\n    /// @param _input The 256-bit account address.\n    /// @return codeHash - hash of the bytecode according to the EIP-1052 specification.\n    function getCodeHash(uint256 _input) external view override returns (bytes32) {\n        // We consider the account bytecode hash of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODEHASH of A is X, then EXTCODEHASH of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS) {\n            return EMPTY_STRING_KECCAK;\n        }\n\n        bytes32 codeHash = getRawCodeHash(account);\n\n        // The code hash is equal to the `keccak256(\"\")` if the account is an EOA with at least one transaction.\n        // Otherwise, the account is either deployed smart contract or an empty account,\n        // for both cases the code hash is equal to the raw code hash.\n        if (codeHash == 0x00 && NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(account) > 0) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n        // The contract is still on the constructor, which means it is not deployed yet,\n        // so set `keccak256(\"\")` as a code hash. The EVM has the same behavior.\n        else if (Utils.isContractConstructing(codeHash)) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n\n        return codeHash;\n    }\n\n    /// @notice Simulate the behavior of the `extcodesize` EVM opcode.\n    /// @param _input The 256-bit account address.\n    /// @return codeSize - the size of the deployed smart contract in bytes.\n    function getCodeSize(uint256 _input) external view override returns (uint256 codeSize) {\n        // We consider the account bytecode size of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODESIZE of A is X, then EXTCODESIZE of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        bytes32 codeHash = getRawCodeHash(account);\n\n        // If the contract is a default account or is on constructor the code size is zero,\n        // otherwise extract the proper value for it from the bytecode hash.\n        // NOTE: zero address and precompiles are a special case, they are contracts, but we\n        // want to preserve EVM invariants (see EIP-1052 specification). That's why we automatically\n        // return `0` length in the following cases:\n        // - `codehash(0) == 0`\n        // - `account` is a precompile.\n        // - `account` is currently being constructed\n        if (\n            uint160(account) > CURRENT_MAX_PRECOMPILE_ADDRESS &&\n            codeHash != 0x00 &&\n            !Utils.isContractConstructing(codeHash)\n        ) {\n            codeSize = Utils.bytecodeLenInBytes(codeHash);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/AccountCodeStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccountCodeStorage.sol\";\nimport \"./libraries/Utils.sol\";\nimport {DEPLOYER_SYSTEM_CONTRACT, NONCE_HOLDER_SYSTEM_CONTRACT, CURRENT_MAX_PRECOMPILE_ADDRESS} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @notice The storage of this contract serves as a mapping for the code hashes of the 32-byte account addresses.\n * @dev Code hash is not strictly a hash, it's a structure where the first byte denotes the version of the hash,\n * the second byte denotes whether the contract is constructed, and the next two bytes denote the length in 32-byte words.\n * And then the next 28 bytes are the truncated hash.\n * @dev In this version of zkSync, the first byte of the hash MUST be 1.\n * @dev The length of each bytecode MUST be odd.  It's internal code format requirements, due to padding of SHA256 function.\n * @dev It is also assumed that all the bytecode hashes are *known*, i.e. the full bytecodes\n * were published on L1 as calldata. This contract trusts the ContractDeployer and the KnownCodesStorage\n * system contracts to enforce the invariants mentioned above.\n */\ncontract AccountCodeStorage is IAccountCodeStorage {\n    bytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n    modifier onlyDeployer() {\n        require(msg.sender == address(DEPLOYER_SYSTEM_CONTRACT), \"Callable only by the deployer system contract\");\n        _;\n    }\n\n    /// @notice Stores the bytecodeHash of constructing contract.\n    /// @param _address The address of the account to set the codehash to.\n    /// @param _hash The new bytecode hash of the constructing account.\n    /// @dev This method trusts the ContractDeployer to make sure that the bytecode is known and well-formed,\n    /// but checks whether the bytecode hash corresponds to the constructing smart contract.\n    function storeAccountConstructingCodeHash(address _address, bytes32 _hash) external override onlyDeployer {\n        // Check that code hash corresponds to the deploying smart contract\n        require(Utils.isContractConstructing(_hash), \"Code hash is not for a contract on constructor\");\n\n        uint256 addressAsKey = uint256(uint160(_address));\n        assembly {\n            sstore(addressAsKey, _hash)\n        }\n    }\n\n    /// @notice Marks the account bytecodeHash as constructed.\n    /// @param _address The address of the account to mark as constructed\n    function markAccountCodeHashAsConstructed(address _address) external override onlyDeployer {\n        bytes32 codeHash = getRawCodeHash(_address);\n\n        // Check that the code hash corresponds to the deploying smart contract\n        require(Utils.isContractConstructing(codeHash), \"Code hash is not for a contract on constructor\");\n        // Get the bytecode hash with \"isConstructor\" flag equal to false\n        bytes32 constructedBytecodeHash = Utils.constructedBytecodeHash(codeHash);\n\n        uint256 addressAsKey = uint256(uint160(_address));\n        assembly {\n            sstore(addressAsKey, constructedBytecodeHash)\n        }\n    }\n\n    /// @notice Get the codehash stored for an address.\n    /// @param _address The address of the account of which the codehash to return\n    /// @return codeHash The codehash stored for this account.\n    function getRawCodeHash(address _address) public view override returns (bytes32 codeHash) {\n        uint256 addressAsKey = uint256(uint160(_address));\n\n        assembly {\n            codeHash := sload(addressAsKey)\n        }\n    }\n\n    /// @notice Simulate the behavior of the `extcodehash` EVM opcode.\n    /// @param _input The 256-bit account address.\n    /// @return codeHash - hash of the bytecode according to the EIP-1052 specification.\n    function getCodeHash(uint256 _input) external view override returns (bytes32) {\n        // We consider the account bytecode hash of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODEHASH of A is X, then EXTCODEHASH of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS) {\n            return EMPTY_STRING_KECCAK;\n        }\n\n        bytes32 codeHash = getRawCodeHash(account);\n\n        // The code hash is equal to the `keccak256(\"\")` if the account is an EOA with at least one transaction.\n        // Otherwise, the account is either deployed smart contract or an empty account,\n        // for both cases the code hash is equal to the raw code hash.\n        if (codeHash == 0x00 && NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(account) > 0) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n        // The contract is still on the constructor, which means it is not deployed yet,\n        // so set `keccak256(\"\")` as a code hash. The EVM has the same behavior.\n        else if (Utils.isContractConstructing(codeHash)) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n\n        return codeHash;\n    }\n\n    /// @notice Simulate the behavior of the `extcodesize` EVM opcode.\n    /// @param _input The 256-bit account address.\n    /// @return codeSize - the size of the deployed smart contract in bytes.\n    function getCodeSize(uint256 _input) external view override returns (uint256 codeSize) {\n        // We consider the account bytecode size of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODESIZE of A is X, then EXTCODESIZE of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        bytes32 codeHash = getRawCodeHash(account);\n\n        // If the contract is a default account or is on constructor the code size is zero,\n        // otherwise extract the proper value for it from the bytecode hash.\n        // NOTE: zero address and precompiles are a special case, they are contracts, but we\n        // want to preserve EVM invariants (see EIP-1052 specification). That's why we automatically\n        // return `0` length in the following cases:\n        // - `codehash(0) == 0`\n        // - `account` is a precompile.\n        // - `account` is currently being constructed\n        if (\n            uint160(account) > CURRENT_MAX_PRECOMPILE_ADDRESS &&\n            codeHash != 0x00 &&\n            !Utils.isContractConstructing(codeHash)\n        ) {\n            codeSize = Utils.bytecodeLenInBytes(codeHash);\n        }\n    }\n}"
    }
  ]
}