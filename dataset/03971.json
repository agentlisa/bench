{
  "Title": "[L14] Account’s name field may allow phishing scenarios",
  "Content": "The [`Accounts` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Accounts.sol#L13) allows any user to set a `name` for their account with the [`setName` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Accounts.sol#L98-L102). This function does not limit in any way the name an account can set, which could result in a lot of accounts using the name of famous people to deceive naive users.\n\n\nClients from the Celo network should not use this name as an unique identifier of the account or as a trusted piece of information. Moreover, this feature could be misused by attackers if there is no proper documentation on the risks this feature introduces to the network, such as phishing scenarios which are so common in the Blockchain space that there are [published scientific papers on how to recognize addresses associated with phishing](https://arxiv.org/pdf/1911.09259.pdf).\n\n\nConsider analyzing and publicly documenting the risks associated with the ability to set a name for the accounts, not only for developers generating clients but also for end-users of the Celo network.\n\n\n****Update:*** Not Fixed. cLabs’ statement for this issue:*\n\n\n\n> \n> It is correct that an account’s name is fundamentally impossible to verify. Therefore, the name should be considered untrusted by users and developers. This will be clarified explicitly in the documentation and consider renaming the field to `untrustedName`. In anticipation of this problem, verifiable identity attributes have been added to the Metadata feature (https://docs.celo.org/celo-codebase/protocol/identity/metadata). With this, users can verify attributes such as DNS record ownership themselves. The community should actively encourage that user-facing UIs will utilize Metadata to reduce the surface area for phishing.\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/Accounts.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\n\ncontract Accounts is IAccounts, Ownable, ReentrancyGuard, Initializable, UsingRegistry {\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct Account {\n    bool exists;\n    // Each account may authorize signing keys to use for voting, valdiating or attestation.\n    // These keys may not be keys of other accounts, and may not be authorized by any other\n    // account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  mapping(address => Account) private accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   */\n  function setAccount(string calldata name, bytes calldata dataEncryptionKey, address walletAddress)\n    external\n  {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender), \"Account exists\");\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    accounts[msg.sender].name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   */\n  function setWalletAddress(address walletAddress) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    accounts[msg.sender].walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    accounts[msg.sender].dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    accounts[msg.sender].metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.vote = signer;\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.validator = signer;\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(\n    address signer,\n    bytes calldata ecdsaPublicKey,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external nonReentrant {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.validator = signer;\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.attestation = signer;\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.attestation == signer,\n        \"not active authorized attestation signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.validator == signer,\n        \"not active authorized validator signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.vote == signer,\n        \"not active authorized vote signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.vote;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.validator;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.attestation;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return (stringLengths[] - the length of each string in bytes\n   *          data - all strings concatenated\n   *         )\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Authorizes some role of of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized or is an account.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `current`'s signature on `msg.sender`.\n   */\n  function authorize(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSigner(authorized),\n      \"delegate or account exists\"\n    );\n\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}"
    }
  ]
}