{
  "Title": "[G-04] Use != 0 instead of > 0",
  "Content": "<h2 id=\"g-04-use--0-instead-of--0\" style=\"position:relative;\"><a href=\"#g-04-use--0-instead-of--0\" aria-label=\"g 04 use  0 instead of  0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-04] Use != 0 instead of &gt; 0</h2>\n<p>Using <code>&gt; 0</code> uses slightly more gas than using <code>!= 0</code>. Use <code>!= 0</code> when comparing uint variables to zero, which cannot hold values below zero</p>\n<p>Locations where this was found include:<br>\n<a href=\"https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/external/PeripheryPayments.sol#L38\">PeripheryPayments.sol#L38</a><br>\n<a href=\"https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/external/PeripheryPayments.sol#L45\">PeripheryPayments.sol#L45</a><br>\n<a href=\"https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/external/PeripheryPayments.sol#L60\">PeripheryPayments.sol#L60</a><br>\n<a href=\"https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/external/PeripheryPayments.sol#L66\">PeripheryPayments.sol#L66</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L167\">FlywheelCore.sol#L167</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L218\">FlywheelCore.sol#L218</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L467\">ERC20Gauges.sol#L467</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L487\">ERC20Gauges.sol#L487</a><br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L287\">ERC20MultiVotes.sol#L287</a><br></p>\n<h3 id=\"recommended-mitigation-steps-10\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-10\" aria-label=\"recommended mitigation steps 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Replace <code>&gt; 0</code> with <code>!= 0</code> to save gas.</p>\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-04-xtribe-contest",
  "Code": [
    {
      "filename": "src/external/PeripheryPayments.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\nimport \"solmate/utils/SafeTransferLib.sol\";\n\n/**\n @title Periphery Payments\n @notice Immutable state used by periphery contracts\n Largely Forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/PeripheryPayments.sol \n Changes:\n * no interface\n * no inheritdoc\n * add immutable WETH9 in constructor instead of PeripheryImmutableState\n * receive from any address\n * Solmate interfaces and transfer lib\n * casting\n * add approve, wrapWETH9 and pullToken\n*/ \nabstract contract PeripheryPayments {\n    using SafeTransferLib for *;\n\n    IWETH9 public immutable WETH9;\n\n    constructor(IWETH9 _WETH9) {\n        WETH9 = _WETH9;\n    }\n\n    receive() external payable {}\n\n    function approve(ERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceWETH9 = WETH9.balanceOf(address(this));\n        require(balanceWETH9 >= amountMinimum, 'Insufficient WETH9');\n\n        if (balanceWETH9 > 0) {\n            WETH9.withdraw(balanceWETH9);\n            recipient.safeTransferETH(balanceWETH9);\n        }\n    }\n\n    function wrapWETH9() public payable {\n        if (address(this).balance > 0) WETH9.deposit{value: address(this).balance}(); // wrap everything\n    }\n\n    function pullToken(ERC20 token, uint256 amount, address recipient) public payable {\n        token.safeTransferFrom(msg.sender, recipient, amount);\n    }\n\n    function sweepToken(\n        ERC20 token,\n        uint256 amountMinimum,\n        address recipient\n    ) public payable {\n        uint256 balanceToken = token.balanceOf(address(this));\n        require(balanceToken >= amountMinimum, 'Insufficient token');\n\n        if (balanceToken > 0) {\n            token.safeTransfer(recipient, balanceToken);\n        }\n    }\n\n    function refundETH() external payable {\n        if (address(this).balance > 0) SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);\n    }\n}\n\nabstract contract IWETH9 is ERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable virtual;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external virtual;\n}"
    },
    {
      "filename": "src/external/PeripheryPayments.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\nimport \"solmate/utils/SafeTransferLib.sol\";\n\n/**\n @title Periphery Payments\n @notice Immutable state used by periphery contracts\n Largely Forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/PeripheryPayments.sol \n Changes:\n * no interface\n * no inheritdoc\n * add immutable WETH9 in constructor instead of PeripheryImmutableState\n * receive from any address\n * Solmate interfaces and transfer lib\n * casting\n * add approve, wrapWETH9 and pullToken\n*/ \nabstract contract PeripheryPayments {\n    using SafeTransferLib for *;\n\n    IWETH9 public immutable WETH9;\n\n    constructor(IWETH9 _WETH9) {\n        WETH9 = _WETH9;\n    }\n\n    receive() external payable {}\n\n    function approve(ERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceWETH9 = WETH9.balanceOf(address(this));\n        require(balanceWETH9 >= amountMinimum, 'Insufficient WETH9');\n\n        if (balanceWETH9 > 0) {\n            WETH9.withdraw(balanceWETH9);\n            recipient.safeTransferETH(balanceWETH9);\n        }\n    }\n\n    function wrapWETH9() public payable {\n        if (address(this).balance > 0) WETH9.deposit{value: address(this).balance}(); // wrap everything\n    }\n\n    function pullToken(ERC20 token, uint256 amount, address recipient) public payable {\n        token.safeTransferFrom(msg.sender, recipient, amount);\n    }\n\n    function sweepToken(\n        ERC20 token,\n        uint256 amountMinimum,\n        address recipient\n    ) public payable {\n        uint256 balanceToken = token.balanceOf(address(this));\n        require(balanceToken >= amountMinimum, 'Insufficient token');\n\n        if (balanceToken > 0) {\n            token.safeTransfer(recipient, balanceToken);\n        }\n    }\n\n    function refundETH() external payable {\n        if (address(this).balance > 0) SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);\n    }\n}\n\nabstract contract IWETH9 is ERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable virtual;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external virtual;\n}"
    },
    {
      "filename": "src/external/PeripheryPayments.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\nimport \"solmate/utils/SafeTransferLib.sol\";\n\n/**\n @title Periphery Payments\n @notice Immutable state used by periphery contracts\n Largely Forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/PeripheryPayments.sol \n Changes:\n * no interface\n * no inheritdoc\n * add immutable WETH9 in constructor instead of PeripheryImmutableState\n * receive from any address\n * Solmate interfaces and transfer lib\n * casting\n * add approve, wrapWETH9 and pullToken\n*/ \nabstract contract PeripheryPayments {\n    using SafeTransferLib for *;\n\n    IWETH9 public immutable WETH9;\n\n    constructor(IWETH9 _WETH9) {\n        WETH9 = _WETH9;\n    }\n\n    receive() external payable {}\n\n    function approve(ERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceWETH9 = WETH9.balanceOf(address(this));\n        require(balanceWETH9 >= amountMinimum, 'Insufficient WETH9');\n\n        if (balanceWETH9 > 0) {\n            WETH9.withdraw(balanceWETH9);\n            recipient.safeTransferETH(balanceWETH9);\n        }\n    }\n\n    function wrapWETH9() public payable {\n        if (address(this).balance > 0) WETH9.deposit{value: address(this).balance}(); // wrap everything\n    }\n\n    function pullToken(ERC20 token, uint256 amount, address recipient) public payable {\n        token.safeTransferFrom(msg.sender, recipient, amount);\n    }\n\n    function sweepToken(\n        ERC20 token,\n        uint256 amountMinimum,\n        address recipient\n    ) public payable {\n        uint256 balanceToken = token.balanceOf(address(this));\n        require(balanceToken >= amountMinimum, 'Insufficient token');\n\n        if (balanceToken > 0) {\n            token.safeTransfer(recipient, balanceToken);\n        }\n    }\n\n    function refundETH() external payable {\n        if (address(this).balance > 0) SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);\n    }\n}\n\nabstract contract IWETH9 is ERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable virtual;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external virtual;\n}"
    },
    {
      "filename": "src/external/PeripheryPayments.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\nimport \"solmate/utils/SafeTransferLib.sol\";\n\n/**\n @title Periphery Payments\n @notice Immutable state used by periphery contracts\n Largely Forked from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/PeripheryPayments.sol \n Changes:\n * no interface\n * no inheritdoc\n * add immutable WETH9 in constructor instead of PeripheryImmutableState\n * receive from any address\n * Solmate interfaces and transfer lib\n * casting\n * add approve, wrapWETH9 and pullToken\n*/ \nabstract contract PeripheryPayments {\n    using SafeTransferLib for *;\n\n    IWETH9 public immutable WETH9;\n\n    constructor(IWETH9 _WETH9) {\n        WETH9 = _WETH9;\n    }\n\n    receive() external payable {}\n\n    function approve(ERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceWETH9 = WETH9.balanceOf(address(this));\n        require(balanceWETH9 >= amountMinimum, 'Insufficient WETH9');\n\n        if (balanceWETH9 > 0) {\n            WETH9.withdraw(balanceWETH9);\n            recipient.safeTransferETH(balanceWETH9);\n        }\n    }\n\n    function wrapWETH9() public payable {\n        if (address(this).balance > 0) WETH9.deposit{value: address(this).balance}(); // wrap everything\n    }\n\n    function pullToken(ERC20 token, uint256 amount, address recipient) public payable {\n        token.safeTransferFrom(msg.sender, recipient, amount);\n    }\n\n    function sweepToken(\n        ERC20 token,\n        uint256 amountMinimum,\n        address recipient\n    ) public payable {\n        uint256 balanceToken = token.balanceOf(address(this));\n        require(balanceToken >= amountMinimum, 'Insufficient token');\n\n        if (balanceToken > 0) {\n            token.safeTransfer(recipient, balanceToken);\n        }\n    }\n\n    function refundETH() external payable {\n        if (address(this).balance > 0) SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);\n    }\n}\n\nabstract contract IWETH9 is ERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable virtual;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external virtual;\n}"
    },
    {
      "filename": "src/FlywheelCore.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\n\nimport {IFlywheelRewards} from \"./interfaces/IFlywheelRewards.sol\";\nimport {IFlywheelBooster} from \"./interfaces/IFlywheelBooster.sol\";\n\n/**\n @title Flywheel Core Incentives Manager\n @notice Flywheel is a general framework for managing token incentives.\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\n\n         The Core contract maintaings three important pieces of state:\n         * the rewards index which determines how many rewards are owed per token per strategy. User indexes track how far behind the strategy they are to lazily calculate all catch-up rewards.\n         * the accrued (unclaimed) rewards per user.\n         * references to the booster and rewards module described below.\n\n         Core does not manage any tokens directly. The rewards module maintains token balances, and approves core to pull transfer them to users when they claim.\n\n         SECURITY NOTE: For maximum accuracy and to avoid exploits, rewards accrual should be notified atomically through the accrue hook. \n         Accrue should be called any time tokens are transferred, minted, or burned.\n */\ncontract FlywheelCore is Auth {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    /// @notice The token to reward\n    ERC20 public immutable rewardToken;\n\n    /// @notice append-only list of strategies added\n    ERC20[] public allStrategies;\n\n    /// @notice the rewards contract for managing streams\n    IFlywheelRewards public flywheelRewards;\n\n    /// @notice optional booster module for calculating virtual balances on strategies\n    IFlywheelBooster public flywheelBooster;\n\n    constructor(\n        ERC20 _rewardToken,\n        IFlywheelRewards _flywheelRewards,\n        IFlywheelBooster _flywheelBooster,\n        address _owner,\n        Authority _authority\n    ) Auth(_owner, _authority) {\n        rewardToken = _rewardToken;\n        flywheelRewards = _flywheelRewards;\n        flywheelBooster = _flywheelBooster;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ACCRUE/CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** \n      @notice Emitted when a user's rewards accrue to a given strategy.\n      @param strategy the updated rewards strategy\n      @param user the user of the rewards\n      @param rewardsDelta how many new rewards accrued to the user\n      @param rewardsIndex the market index for rewards per token accrued\n    */\n    event AccrueRewards(ERC20 indexed strategy, address indexed user, uint256 rewardsDelta, uint256 rewardsIndex);\n\n    /** \n      @notice Emitted when a user claims accrued rewards.\n      @param user the user of the rewards\n      @param amount the amount of rewards claimed\n    */\n    event ClaimRewards(address indexed user, uint256 amount);\n\n    /// @notice The accrued but not yet transferred rewards for each user\n    mapping(address => uint256) public rewardsAccrued;\n\n    /** \n      @notice accrue rewards for a single user on a strategy\n      @param strategy the strategy to accrue a user's rewards on\n      @param user the user to be accrued\n      @return the cumulative amount of rewards accrued to user (including prior)\n    */\n    function accrue(ERC20 strategy, address user) public returns (uint256) {\n        RewardsState memory state = strategyState[strategy];\n\n        if (state.index == 0) return 0;\n\n        state = accrueStrategy(strategy, state);\n        return accrueUser(strategy, user, state);\n    }\n\n    /** \n      @notice accrue rewards for a two users on a strategy\n      @param strategy the strategy to accrue a user's rewards on\n      @param user the first user to be accrued\n      @param user the second user to be accrued\n      @return the cumulative amount of rewards accrued to the first user (including prior)\n      @return the cumulative amount of rewards accrued to the second user (including prior)\n    */\n    function accrue(\n        ERC20 strategy,\n        address user,\n        address secondUser\n    ) public returns (uint256, uint256) {\n        RewardsState memory state = strategyState[strategy];\n\n        if (state.index == 0) return (0, 0);\n\n        state = accrueStrategy(strategy, state);\n        return (accrueUser(strategy, user, state), accrueUser(strategy, secondUser, state));\n    }\n\n    /** \n      @notice claim rewards for a given user\n      @param user the user claiming rewards\n      @dev this function is public, and all rewards transfer to the user\n    */\n    function claimRewards(address user) external {\n        uint256 accrued = rewardsAccrued[user];\n\n        if (accrued != 0) {\n            rewardsAccrued[user] = 0;\n\n            rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);\n\n            emit ClaimRewards(user, accrued);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** \n      @notice Emitted when a new strategy is added to flywheel by the admin\n      @param newStrategy the new added strategy\n    */\n    event AddStrategy(address indexed newStrategy);\n\n    /// @notice initialize a new strategy\n    function addStrategyForRewards(ERC20 strategy) external requiresAuth {\n        _addStrategyForRewards(strategy);\n    }\n\n    function _addStrategyForRewards(ERC20 strategy) internal {\n        require(strategyState[strategy].index == 0, \"strategy\");\n        strategyState[strategy] = RewardsState({index: ONE, lastUpdatedTimestamp: block.timestamp.safeCastTo32()});\n\n        allStrategies.push(strategy);\n        emit AddStrategy(address(strategy));\n    }\n\n    function getAllStrategies() external view returns (ERC20[] memory) {\n        return allStrategies;\n    }\n\n    /** \n      @notice Emitted when the rewards module changes\n      @param newFlywheelRewards the new rewards module\n    */\n    event FlywheelRewardsUpdate(address indexed newFlywheelRewards);\n\n    /// @notice swap out the flywheel rewards contract\n    function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {\n        uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\n        if (oldRewardBalance > 0) {\n            rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\n        }\n\n        flywheelRewards = newFlywheelRewards;\n\n        emit FlywheelRewardsUpdate(address(newFlywheelRewards));\n    }\n\n    /** \n      @notice Emitted when the booster module changes\n      @param newBooster the new booster module\n    */\n    event FlywheelBoosterUpdate(address indexed newBooster);\n\n    /// @notice swap out the flywheel booster contract\n    function setBooster(IFlywheelBooster newBooster) external requiresAuth {\n        flywheelBooster = newBooster;\n\n        emit FlywheelBoosterUpdate(address(newBooster));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INTERNAL ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    struct RewardsState {\n        /// @notice The strategy's last updated index\n        uint224 index;\n        /// @notice The timestamp the index was last updated at\n        uint32 lastUpdatedTimestamp;\n    }\n\n    /// @notice the fixed point factor of flywheel\n    uint224 public constant ONE = 1e18;\n\n    /// @notice The strategy index and last updated per strategy\n    mapping(ERC20 => RewardsState) public strategyState;\n\n    /// @notice user index per strategy\n    mapping(ERC20 => mapping(address => uint224)) public userIndex;\n\n    /// @notice accumulate global rewards on a strategy\n    function accrueStrategy(ERC20 strategy, RewardsState memory state)\n        private\n        returns (RewardsState memory rewardsState)\n    {\n        // calculate accrued rewards through module\n        uint256 strategyRewardsAccrued = flywheelRewards.getAccruedRewards(strategy, state.lastUpdatedTimestamp);\n\n        rewardsState = state;\n        if (strategyRewardsAccrued > 0) {\n            // use the booster or token supply to calculate reward index denominator\n            uint256 supplyTokens = address(flywheelBooster) != address(0)\n                ? flywheelBooster.boostedTotalSupply(strategy)\n                : strategy.totalSupply();\n\n            uint224 deltaIndex;\n\n            if (supplyTokens != 0) deltaIndex = ((strategyRewardsAccrued * ONE) / supplyTokens).safeCastTo224();\n\n            // accumulate rewards per token onto the index, multiplied by fixed-point factor\n            rewardsState = RewardsState({\n                index: state.index + deltaIndex,\n                lastUpdatedTimestamp: block.timestamp.safeCastTo32()\n            });\n            strategyState[strategy] = rewardsState;\n        }\n    }\n\n    /// @notice accumulate rewards on a strategy for a specific user\n    function accrueUser(\n        ERC20 strategy,\n        address user,\n        RewardsState memory state\n    ) private returns (uint256) {\n        // load indices\n        uint224 strategyIndex = state.index;\n        uint224 supplierIndex = userIndex[strategy][user];\n\n        // sync user index to global\n        userIndex[strategy][user] = strategyIndex;\n\n        // if user hasn't yet accrued rewards, grant them interest from the strategy beginning if they have a balance\n        // zero balances will have no effect other than syncing to global index\n        if (supplierIndex == 0) {\n            supplierIndex = ONE;\n        }\n\n        uint224 deltaIndex = strategyIndex - supplierIndex;\n        // use the booster or token balance to calculate reward balance multiplier\n        uint256 supplierTokens = address(flywheelBooster) != address(0)\n            ? flywheelBooster.boostedBalanceOf(strategy, user)\n            : strategy.balanceOf(user);\n\n        // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\n        uint256 supplierDelta = (supplierTokens * deltaIndex) / ONE;\n        uint256 supplierAccrued = rewardsAccrued[user] + supplierDelta;\n\n        rewardsAccrued[user] = supplierAccrued;\n\n        emit AccrueRewards(strategy, user, supplierDelta, strategyIndex);\n\n        return supplierAccrued;\n    }\n}"
    },
    {
      "filename": "src/FlywheelCore.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\n\nimport {IFlywheelRewards} from \"./interfaces/IFlywheelRewards.sol\";\nimport {IFlywheelBooster} from \"./interfaces/IFlywheelBooster.sol\";\n\n/**\n @title Flywheel Core Incentives Manager\n @notice Flywheel is a general framework for managing token incentives.\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\n\n         The Core contract maintaings three important pieces of state:\n         * the rewards index which determines how many rewards are owed per token per strategy. User indexes track how far behind the strategy they are to lazily calculate all catch-up rewards.\n         * the accrued (unclaimed) rewards per user.\n         * references to the booster and rewards module described below.\n\n         Core does not manage any tokens directly. The rewards module maintains token balances, and approves core to pull transfer them to users when they claim.\n\n         SECURITY NOTE: For maximum accuracy and to avoid exploits, rewards accrual should be notified atomically through the accrue hook. \n         Accrue should be called any time tokens are transferred, minted, or burned.\n */\ncontract FlywheelCore is Auth {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    /// @notice The token to reward\n    ERC20 public immutable rewardToken;\n\n    /// @notice append-only list of strategies added\n    ERC20[] public allStrategies;\n\n    /// @notice the rewards contract for managing streams\n    IFlywheelRewards public flywheelRewards;\n\n    /// @notice optional booster module for calculating virtual balances on strategies\n    IFlywheelBooster public flywheelBooster;\n\n    constructor(\n        ERC20 _rewardToken,\n        IFlywheelRewards _flywheelRewards,\n        IFlywheelBooster _flywheelBooster,\n        address _owner,\n        Authority _authority\n    ) Auth(_owner, _authority) {\n        rewardToken = _rewardToken;\n        flywheelRewards = _flywheelRewards;\n        flywheelBooster = _flywheelBooster;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ACCRUE/CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** \n      @notice Emitted when a user's rewards accrue to a given strategy.\n      @param strategy the updated rewards strategy\n      @param user the user of the rewards\n      @param rewardsDelta how many new rewards accrued to the user\n      @param rewardsIndex the market index for rewards per token accrued\n    */\n    event AccrueRewards(ERC20 indexed strategy, address indexed user, uint256 rewardsDelta, uint256 rewardsIndex);\n\n    /** \n      @notice Emitted when a user claims accrued rewards.\n      @param user the user of the rewards\n      @param amount the amount of rewards claimed\n    */\n    event ClaimRewards(address indexed user, uint256 amount);\n\n    /// @notice The accrued but not yet transferred rewards for each user\n    mapping(address => uint256) public rewardsAccrued;\n\n    /** \n      @notice accrue rewards for a single user on a strategy\n      @param strategy the strategy to accrue a user's rewards on\n      @param user the user to be accrued\n      @return the cumulative amount of rewards accrued to user (including prior)\n    */\n    function accrue(ERC20 strategy, address user) public returns (uint256) {\n        RewardsState memory state = strategyState[strategy];\n\n        if (state.index == 0) return 0;\n\n        state = accrueStrategy(strategy, state);\n        return accrueUser(strategy, user, state);\n    }\n\n    /** \n      @notice accrue rewards for a two users on a strategy\n      @param strategy the strategy to accrue a user's rewards on\n      @param user the first user to be accrued\n      @param user the second user to be accrued\n      @return the cumulative amount of rewards accrued to the first user (including prior)\n      @return the cumulative amount of rewards accrued to the second user (including prior)\n    */\n    function accrue(\n        ERC20 strategy,\n        address user,\n        address secondUser\n    ) public returns (uint256, uint256) {\n        RewardsState memory state = strategyState[strategy];\n\n        if (state.index == 0) return (0, 0);\n\n        state = accrueStrategy(strategy, state);\n        return (accrueUser(strategy, user, state), accrueUser(strategy, secondUser, state));\n    }\n\n    /** \n      @notice claim rewards for a given user\n      @param user the user claiming rewards\n      @dev this function is public, and all rewards transfer to the user\n    */\n    function claimRewards(address user) external {\n        uint256 accrued = rewardsAccrued[user];\n\n        if (accrued != 0) {\n            rewardsAccrued[user] = 0;\n\n            rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);\n\n            emit ClaimRewards(user, accrued);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** \n      @notice Emitted when a new strategy is added to flywheel by the admin\n      @param newStrategy the new added strategy\n    */\n    event AddStrategy(address indexed newStrategy);\n\n    /// @notice initialize a new strategy\n    function addStrategyForRewards(ERC20 strategy) external requiresAuth {\n        _addStrategyForRewards(strategy);\n    }\n\n    function _addStrategyForRewards(ERC20 strategy) internal {\n        require(strategyState[strategy].index == 0, \"strategy\");\n        strategyState[strategy] = RewardsState({index: ONE, lastUpdatedTimestamp: block.timestamp.safeCastTo32()});\n\n        allStrategies.push(strategy);\n        emit AddStrategy(address(strategy));\n    }\n\n    function getAllStrategies() external view returns (ERC20[] memory) {\n        return allStrategies;\n    }\n\n    /** \n      @notice Emitted when the rewards module changes\n      @param newFlywheelRewards the new rewards module\n    */\n    event FlywheelRewardsUpdate(address indexed newFlywheelRewards);\n\n    /// @notice swap out the flywheel rewards contract\n    function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {\n        uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\n        if (oldRewardBalance > 0) {\n            rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\n        }\n\n        flywheelRewards = newFlywheelRewards;\n\n        emit FlywheelRewardsUpdate(address(newFlywheelRewards));\n    }\n\n    /** \n      @notice Emitted when the booster module changes\n      @param newBooster the new booster module\n    */\n    event FlywheelBoosterUpdate(address indexed newBooster);\n\n    /// @notice swap out the flywheel booster contract\n    function setBooster(IFlywheelBooster newBooster) external requiresAuth {\n        flywheelBooster = newBooster;\n\n        emit FlywheelBoosterUpdate(address(newBooster));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INTERNAL ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    struct RewardsState {\n        /// @notice The strategy's last updated index\n        uint224 index;\n        /// @notice The timestamp the index was last updated at\n        uint32 lastUpdatedTimestamp;\n    }\n\n    /// @notice the fixed point factor of flywheel\n    uint224 public constant ONE = 1e18;\n\n    /// @notice The strategy index and last updated per strategy\n    mapping(ERC20 => RewardsState) public strategyState;\n\n    /// @notice user index per strategy\n    mapping(ERC20 => mapping(address => uint224)) public userIndex;\n\n    /// @notice accumulate global rewards on a strategy\n    function accrueStrategy(ERC20 strategy, RewardsState memory state)\n        private\n        returns (RewardsState memory rewardsState)\n    {\n        // calculate accrued rewards through module\n        uint256 strategyRewardsAccrued = flywheelRewards.getAccruedRewards(strategy, state.lastUpdatedTimestamp);\n\n        rewardsState = state;\n        if (strategyRewardsAccrued > 0) {\n            // use the booster or token supply to calculate reward index denominator\n            uint256 supplyTokens = address(flywheelBooster) != address(0)\n                ? flywheelBooster.boostedTotalSupply(strategy)\n                : strategy.totalSupply();\n\n            uint224 deltaIndex;\n\n            if (supplyTokens != 0) deltaIndex = ((strategyRewardsAccrued * ONE) / supplyTokens).safeCastTo224();\n\n            // accumulate rewards per token onto the index, multiplied by fixed-point factor\n            rewardsState = RewardsState({\n                index: state.index + deltaIndex,\n                lastUpdatedTimestamp: block.timestamp.safeCastTo32()\n            });\n            strategyState[strategy] = rewardsState;\n        }\n    }\n\n    /// @notice accumulate rewards on a strategy for a specific user\n    function accrueUser(\n        ERC20 strategy,\n        address user,\n        RewardsState memory state\n    ) private returns (uint256) {\n        // load indices\n        uint224 strategyIndex = state.index;\n        uint224 supplierIndex = userIndex[strategy][user];\n\n        // sync user index to global\n        userIndex[strategy][user] = strategyIndex;\n\n        // if user hasn't yet accrued rewards, grant them interest from the strategy beginning if they have a balance\n        // zero balances will have no effect other than syncing to global index\n        if (supplierIndex == 0) {\n            supplierIndex = ONE;\n        }\n\n        uint224 deltaIndex = strategyIndex - supplierIndex;\n        // use the booster or token balance to calculate reward balance multiplier\n        uint256 supplierTokens = address(flywheelBooster) != address(0)\n            ? flywheelBooster.boostedBalanceOf(strategy, user)\n            : strategy.balanceOf(user);\n\n        // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\n        uint256 supplierDelta = (supplierTokens * deltaIndex) / ONE;\n        uint256 supplierAccrued = rewardsAccrued[user] + supplierDelta;\n\n        rewardsAccrued[user] = supplierAccrued;\n\n        emit AccrueRewards(strategy, user, supplierDelta, strategyIndex);\n\n        return supplierAccrued;\n    }\n}"
    },
    {
      "filename": "src/token/ERC20Gauges.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"solmate/auth/Auth.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeCastLib.sol\";\nimport \"../../lib/EnumerableSet.sol\";\nimport \"../interfaces/Errors.sol\";\n\n/** \n @title  An ERC20 with an embedded \"Gauge\" style vote with liquid weights\n @author Tribe DAO\n @notice This contract is meant to be used to support gauge style votes with weights associated with resource allocation.\n         Holders can allocate weight in any proportion to supported gauges.\n         A \"gauge\" is represented by an address which would receive the resources periodically or continuously.\n\n         For example, gauges can be used to direct token emissions, similar to Curve or Tokemak.\n         Alternatively, gauges can be used to direct another quantity such as relative access to a line of credit.\n\n         The contract's Authority <https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol> manages the gauge set and cap.\n         \"Live\" gauges are in the set.  \n         Users can only add weight to live gauges but can remove weight from live or deprecated gauges.\n         Gauges can be deprecated and reinstated, and will maintain any non-removed weight from before.\n\n @dev    SECURITY NOTES: `maxGauges` is a critical variable to protect against gas DOS attacks upon token transfer. \n         This must be low enough to allow complicated transactions to fit in a block.\n \n         Weight state is preserved on the gauge and user level even when a gauge is removed, in case it is re-added. \n         This maintains state efficiently, and global accounting is managed only on the `_totalWeight`\n*/\nabstract contract ERC20Gauges is ERC20, Auth {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    constructor(uint32 _gaugeCycleLength, uint32 _incrementFreezeWindow) {\n        if (_incrementFreezeWindow >= _gaugeCycleLength) revert IncrementFreezeError();\n        gaugeCycleLength = _gaugeCycleLength;"
    }
  ]
}