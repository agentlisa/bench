{
  "Title": "ChainlinkOracle integration problems",
  "Content": "##### Description\n\nThere are several shortcomings in the current implementation of the interaction with Chainlink.\n\n1. `ChainlinkOracle.isTokenSupported()` returns true if a Chainlink feed exists, but it does not consider the case when it has been abandoned (not updated for a long time):\n```\nfunction isTokenSupported(...) external view override returns (bool) {\n   ...\n   try _feedRegistry.getFeed(...) returns (IAggregatorV2V3) {\n      return true;\n   } catch Error(string memory) {\n      try _feedRegistry.getFeed(...) returns (IAggregatorV2V3) {\n         return true;\n```\nhttps://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/oracles/ChainlinkOracle.sol#L52-L56\n\n2. `ChainlinkOracle._getPrice()` uses the deprecated `answeredInRound`, see https://docs.chain.link/data-feeds/api-reference#latestrounddata\n```\nfunction _getPrice(\n    ...\n    require(answeredInRound_ >= roundID_, \"stale price\");\n```\nhttps://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/oracles/ChainlinkOracle.sol#L83\n\n3. `ChainlinkOracle._getPrice()` doesn't check for stale prices.\n\nEach feed has a `heartbeat`, and for each call to [`latestRoundData()`](https://docs.chain.link/data-feeds/feed-registry/feed-registry-functions#latestrounddata) the equation `updatedAt < block.timestamp - heartbeat` must be checked, see https://ethereum.stackexchange.com/questions/133890/chainlink-latestrounddata-security-fresh-data-check-usage.\n\n4. `ChainlinkOracle.getUSDPrice()` has a check for `price_ != 0` which should actually be `price_ > 0` since it is `int256` and could hypothetically be negative:\n```\nfunction _getPrice\n    ...\n    require(price_ != 0, \"negative price\");\n```\nhttps://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/oracles/ChainlinkOracle.sol#L82\n\n##### Recommendation\n\nRecommendations are as follows:\n1. Add a check for abandoned pools in `isTokenSupported()`.\n2. Remove the deprecated `answeredInRound` check.\n3. Implement checks for stale prices.\n4. Ensure the `price_ > 0`.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracles/ChainlinkOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@chainlink/contracts/Denominations.sol\";\nimport \"@chainlink/contracts/interfaces/FeedRegistryInterface.sol\";\n\nimport \"../../interfaces/IOracle.sol\";\n\ninterface IAggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    /// @notice `getRoundData` and `latestRoundData` should both raise \"No data present\"\n    /// if they do not have data to report, instead of returning unset values\n    /// which could be misinterpreted as actual reported values.\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ncontract ChainlinkOracle is IOracle {\n    FeedRegistryInterface internal constant _feedRegistry =\n        FeedRegistryInterface(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf);\n    address internal constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address internal constant _CURVE_ETH = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    function isTokenSupported(address token) external view override returns (bool) {\n        if (_isEth(token)) return true;\n        try _feedRegistry.getFeed(token, Denominations.ETH) returns (AggregatorV2V3Interface) {\n            return true;\n        } catch Error(string memory) {\n            try _feedRegistry.getFeed(token, Denominations.USD) returns (AggregatorV2V3Interface) {\n                return true;\n            } catch Error(string memory) {\n                return false;\n            }\n        }\n    }\n\n    // Prices are always provided with 18 decimals pecision\n    function getUSDPrice(address token) external view returns (uint256) {\n        return _getPrice(token, Denominations.USD, false);\n    }\n\n    function _getPrice(\n        address token,\n        address denomination,\n        bool shouldRevert\n    ) internal view returns (uint256) {\n        if (_isEth(token)) token = Denominations.ETH;\n        try _feedRegistry.latestRoundData(token, denomination) returns (\n            uint80 roundID_,\n            int256 price_,\n            uint256,\n            uint256 timeStamp_,\n            uint80 answeredInRound_\n        ) {\n            require(timeStamp_ != 0, \"round not complete\");\n            require(price_ != 0, \"negative price\");\n            require(answeredInRound_ >= roundID_, \"stale price\");\n            return _scaleFrom(uint256(price_), _feedRegistry.decimals(token, denomination));\n        } catch Error(string memory reason) {\n            if (shouldRevert) revert(reason);\n\n            if (denomination == Denominations.USD) {\n                return\n                    (_getPrice(token, Denominations.ETH, true) *\n                        _getPrice(Denominations.ETH, Denominations.USD, true)) / 1e18;\n            }\n            return\n                (_getPrice(token, Denominations.USD, true) * 1e18) /\n                _getPrice(Denominations.ETH, Denominations.USD, true);\n        }\n    }\n\n    function _scaleFrom(uint256 value, uint8 decimals) internal pure returns (uint256) {\n        if (decimals == 18) return value;\n        if (decimals > 18) return value / 10 ** (decimals - 18);\n        else return value * 10 ** (18 - decimals);\n    }\n\n    function _isEth(address token) internal pure returns (bool) {\n        return token == address(0) || token == _WETH || token == _CURVE_ETH;\n    }\n}"
    },
    {
      "filename": "contracts/oracles/ChainlinkOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@chainlink/contracts/Denominations.sol\";\nimport \"@chainlink/contracts/interfaces/FeedRegistryInterface.sol\";\n\nimport \"../../interfaces/IOracle.sol\";\n\ninterface IAggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    /// @notice `getRoundData` and `latestRoundData` should both raise \"No data present\"\n    /// if they do not have data to report, instead of returning unset values\n    /// which could be misinterpreted as actual reported values.\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ncontract ChainlinkOracle is IOracle {\n    FeedRegistryInterface internal constant _feedRegistry =\n        FeedRegistryInterface(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf);\n    address internal constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address internal constant _CURVE_ETH = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    function isTokenSupported(address token) external view override returns (bool) {\n        if (_isEth(token)) return true;\n        try _feedRegistry.getFeed(token, Denominations.ETH) returns (AggregatorV2V3Interface) {\n            return true;\n        } catch Error(string memory) {\n            try _feedRegistry.getFeed(token, Denominations.USD) returns (AggregatorV2V3Interface) {\n                return true;\n            } catch Error(string memory) {\n                return false;\n            }\n        }\n    }\n\n    // Prices are always provided with 18 decimals pecision\n    function getUSDPrice(address token) external view returns (uint256) {\n        return _getPrice(token, Denominations.USD, false);\n    }\n\n    function _getPrice(\n        address token,\n        address denomination,\n        bool shouldRevert\n    ) internal view returns (uint256) {\n        if (_isEth(token)) token = Denominations.ETH;\n        try _feedRegistry.latestRoundData(token, denomination) returns (\n            uint80 roundID_,\n            int256 price_,\n            uint256,\n            uint256 timeStamp_,\n            uint80 answeredInRound_\n        ) {\n            require(timeStamp_ != 0, \"round not complete\");\n            require(price_ != 0, \"negative price\");\n            require(answeredInRound_ >= roundID_, \"stale price\");\n            return _scaleFrom(uint256(price_), _feedRegistry.decimals(token, denomination));\n        } catch Error(string memory reason) {\n            if (shouldRevert) revert(reason);\n\n            if (denomination == Denominations.USD) {\n                return\n                    (_getPrice(token, Denominations.ETH, true) *\n                        _getPrice(Denominations.ETH, Denominations.USD, true)) / 1e18;\n            }\n            return\n                (_getPrice(token, Denominations.USD, true) * 1e18) /\n                _getPrice(Denominations.ETH, Denominations.USD, true);\n        }\n    }\n\n    function _scaleFrom(uint256 value, uint8 decimals) internal pure returns (uint256) {\n        if (decimals == 18) return value;\n        if (decimals > 18) return value / 10 ** (decimals - 18);\n        else return value * 10 ** (18 - decimals);\n    }\n\n    function _isEth(address token) internal pure returns (bool) {\n        return token == address(0) || token == _WETH || token == _CURVE_ETH;\n    }\n}"
    },
    {
      "filename": "contracts/oracles/ChainlinkOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@chainlink/contracts/Denominations.sol\";\nimport \"@chainlink/contracts/interfaces/FeedRegistryInterface.sol\";\n\nimport \"../../interfaces/IOracle.sol\";\n\ninterface IAggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    /// @notice `getRoundData` and `latestRoundData` should both raise \"No data present\"\n    /// if they do not have data to report, instead of returning unset values\n    /// which could be misinterpreted as actual reported values.\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ncontract ChainlinkOracle is IOracle {\n    FeedRegistryInterface internal constant _feedRegistry =\n        FeedRegistryInterface(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf);\n    address internal constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address internal constant _CURVE_ETH = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    function isTokenSupported(address token) external view override returns (bool) {\n        if (_isEth(token)) return true;\n        try _feedRegistry.getFeed(token, Denominations.ETH) returns (AggregatorV2V3Interface) {\n            return true;\n        } catch Error(string memory) {\n            try _feedRegistry.getFeed(token, Denominations.USD) returns (AggregatorV2V3Interface) {\n                return true;\n            } catch Error(string memory) {\n                return false;\n            }\n        }\n    }\n\n    // Prices are always provided with 18 decimals pecision\n    function getUSDPrice(address token) external view returns (uint256) {\n        return _getPrice(token, Denominations.USD, false);\n    }\n\n    function _getPrice(\n        address token,\n        address denomination,\n        bool shouldRevert\n    ) internal view returns (uint256) {\n        if (_isEth(token)) token = Denominations.ETH;\n        try _feedRegistry.latestRoundData(token, denomination) returns (\n            uint80 roundID_,\n            int256 price_,\n            uint256,\n            uint256 timeStamp_,\n            uint80 answeredInRound_\n        ) {\n            require(timeStamp_ != 0, \"round not complete\");\n            require(price_ != 0, \"negative price\");\n            require(answeredInRound_ >= roundID_, \"stale price\");\n            return _scaleFrom(uint256(price_), _feedRegistry.decimals(token, denomination));\n        } catch Error(string memory reason) {\n            if (shouldRevert) revert(reason);\n\n            if (denomination == Denominations.USD) {\n                return\n                    (_getPrice(token, Denominations.ETH, true) *\n                        _getPrice(Denominations.ETH, Denominations.USD, true)) / 1e18;\n            }\n            return\n                (_getPrice(token, Denominations.USD, true) * 1e18) /\n                _getPrice(Denominations.ETH, Denominations.USD, true);\n        }\n    }\n\n    function _scaleFrom(uint256 value, uint8 decimals) internal pure returns (uint256) {\n        if (decimals == 18) return value;\n        if (decimals > 18) return value / 10 ** (decimals - 18);\n        else return value * 10 ** (18 - decimals);\n    }\n\n    function _isEth(address token) internal pure returns (bool) {\n        return token == address(0) || token == _WETH || token == _CURVE_ETH;\n    }\n}"
    }
  ]
}