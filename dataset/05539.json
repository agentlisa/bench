{
  "Title": "[M-03] users still forced to follow previously set cooldownDuration even when cooldown is off (set to zero) before unstaking",
  "Content": "\nThe `StakedUSDeV2` contract can enforces coolDown periods for users before they are able to unstake/ take out their funds from the silo contract if coolDown is on. Based on the presence of the modifiers `ensureCooldownOff` and `ensureCooldownOn`, it is known that the coolDown state of the `StakedUSDeV2` contract can be toggled on or off.\nIn a scenario where coolDown is on (always turned on by default) and Alice and Bob deposits, two days after Alice wants to withdraw/redeem. Alice is forced to wait for 90 days before completing withdrawal/getting her tokens from the silo contract because Alice must call  coolDownAsset()/coolDownShares() fcns respectively. Bob decides to wait an extra day.\n\nOn the third day, Bob decides to withdraw/redeem. Contract admin also toggles the coolDown off (sets cooldownDuration to 0), meaning there is no longer a coolDown period and all withdrawals should be sent to the users immediately. Bob now calls calls the redeem()/withdraw() fcn to withdraw instantly to his address instead of the silo address since there is no coolDown.\n\nAlice sees Bob has gotten his tokens but Alice cant use the redeem()/withdraw() because her `StakedUSDeV2` were already burned and her underlying assets were sent to the silo contract for storage. Alice cannot sucessfully call `unstake()` because her `userCooldown.cooldownEnd`  value set to \\~ 90 days. Now Alice has to unfairly wait out the 90 days even though coolDowns have been turned off and everyone else has unrestricted access to their assets. Alice only crime is trying to withdraw earlier than Bob. This is a loss to Alice as Alice has no StakedUSDE or the underlying asset for the no longer necessary 90 days as if the assset is volatile, it may lose some fiat value during the unfair and no longer necessary wait period.\n\nIf cooldown is turned off, it should affect all contract processes and as such, withdrawals should become immediate to users. Tokens previously stored in the USDeSilo contract should become accessible to users when the cooldown state is off. Previous withdrawal requests that had a cooldown should no longer be restricted by a coolDown period since coolDown now off and the coolDownDuration of the contract is now 0.\n\n### Proof of Concept\n\n*   Since StakedUSDeV2 is ERC4626, user calls [deposit()](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/94697be8a3f0dfcd95dfb13ffbd39b5973f5c65d/contracts/token/ERC20/extensions/ERC4626.sol#L171C1-L181C6) to deposit the underlying token asset and get minted shares that signify the user's position size in the vault.\n\n*   The coolDown duration is set to 90 days on deployment of the `StakedUSDeV2` contract, meaning coolDown is toggled on by default.\n\n*   User cannot redeem/withdraw his funds via [withdraw()](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L52C1-L61C1) and [redeem()](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L65C1-L73C4) because coolDown is on. Both functions have the [ensureCooldownOff](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L27C1-L30C4) modifier which reverts if the coolDownDuration value is not 0.\n\n*   User tried to exit position, to withdraw when coolDown is on, user must call coolDownAsset()/coolDownShares(). This will cause :\n\n    *   For the user's underlyingAmount and cooldownEnd timestamp values to be set in the mapping `cooldowns`.  cooldownEnd timestamp values is set to 90 days from the present.\n    *   For the user's `StakedUSDeV2` ERC4626 position shares to be burnt and the positon underlying asset value to be sent to the USDeSilo contract.\n\n```\n\n        /// @notice redeem assets and starts a cooldown to claim the converted underlying asset\n        /// @param assets assets to redeem\n        /// @param owner address to redeem and start cooldown, owner must allowed caller to perform this action\n        function cooldownAssets(uint256 assets, address owner) external ensureCooldownOn returns (uint256) {\n         if (assets > maxWithdraw(owner)) revert ExcessiveWithdrawAmount();\n\n         uint256 shares = previewWithdraw(assets);\n\n         cooldowns[owner].cooldownEnd = uint104(block.timestamp) + cooldownDuration;\n         cooldowns[owner].underlyingAmount += assets;\n\n         _withdraw(_msgSender(), address(silo), owner, assets, shares);\n\n         return shares;\n        }\n\n        /// @notice redeem shares into assets and starts a cooldown to claim the converted underlying asset\n        /// @param shares shares to redeem\n        /// @param owner address to redeem and start cooldown, owner must allowed caller to perform this action\n        function cooldownShares(uint256 shares, address owner) external ensureCooldownOn returns (uint256) {\n         if (shares > maxRedeem(owner)) revert ExcessiveRedeemAmount();\n\n         uint256 assets = previewRedeem(shares);\n\n         cooldowns[owner].cooldownEnd = uint104(block.timestamp) + cooldownDuration;\n         cooldowns[owner].underlyingAmount += assets;\n\n         _withdraw(_msgSender(), address(silo), owner, assets, shares);\n\n         return assets;\n        }\n```\n\n*   User can only use unstake() to get the assets from the silo contract. unstake enforces that the block.timestamp (present time) is more than the 90 days cooldown period set during the execution of `cooldownAssets()` and `cooldownShares()` and reverts if 90 days time has not been reached yet.\n\n```\n\n      function unstake(address receiver) external {\n        UserCooldown storage userCooldown = cooldowns[msg.sender];\n        uint256 assets = userCooldown.underlyingAmount;\n\n        if (block.timestamp >= userCooldown.cooldownEnd) {\n          userCooldown.cooldownEnd = 0;\n          userCooldown.underlyingAmount = 0;\n\n          silo.withdraw(receiver, assets);\n        } else {\n          revert InvalidCooldown();\n        }\n      }\n```\n\n*   If contract admin decides to turn the coolDown period off, by setting the cooldownDuration to 0 via [setCooldownDuration()](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L126C1-L135C2), user who has his assets under the coolDown in the silo still wont be able to withdraw via [unstake()](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L78C1-L90C4) because the logic in `unstake()` doesnt allow for the user's coolDownEnd value which was set under the previous coolDown duration state to be bypassed as coolDowns are now turned off and the StakedUSDeV2 behavior is supposed to be changed to follow ERC4626 standard and allow for the user assets to get to them immediately with no coolDown period still enforced on withdrawals as seen in the comment [here](https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDeV2.sol#L124C38-L124C135).\n\n*   User who initiated withdrawal when the coolDown was toggled on will still continue to be restricted from his tokens/funds even after coolDown is toggled off. This should not be because restrictions are removed, all previous pending withdrawals should be allowed to be completed without wait for 90 days since the coolDownDuration of the contract is now 0.\n\n### Coded Proof of Concept\n\nRun with `forge test --mt test_UnstakeUnallowedAfterCooldownIsTurnedOff`.\n```\n\n    // SPDX-License-Identifier: MIT\n    pragma solidity >=0.8;\n\n    /* solhint-disable private-vars-leading-underscore  */\n    /* solhint-disable var-name-mixedcase  */\n    /* solhint-disable func-name-mixedcase  */\n\n    import \"forge-std/console.sol\";\n    import \"forge-std/Test.sol\";\n    import {SigUtils} from \"forge-std/SigUtils.sol\";\n\n    import \"../../../contracts/USDe.sol\";\n    import \"../../../contracts/StakedUSDeV2.sol\";\n    import \"../../../contracts/interfaces/IUSDe.sol\";\n    import \"../../../contracts/interfaces/IERC20Events.sol\";\n\n    contract StakedUSDeV2CooldownTest is Test, IERC20Events {\n      USDe public usdeToken;\n      StakedUSDeV2 public stakedUSDeV2;\n      SigUtils public sigUtilsUSDe;\n      SigUtils public sigUtilsStakedUSDe;\n      uint256 public _amount = 100 ether;\n\n      address public owner;\n      address public alice;\n      address public bob;\n      address public greg;\n\n      bytes32 SOFT_RESTRICTED_STAKER_ROLE;\n      bytes32 FULL_RESTRICTED_STAKER_ROLE;\n      bytes32 DEFAULT_ADMIN_ROLE;\n      bytes32 BLACKLIST_MANAGER_ROLE;\n      bytes32 REWARDER_ROLE;\n\n      event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n      event Withdraw(\n        address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n      );\n      event LockedAmountRedistributed(address indexed from, address indexed to, uint256 amountToDistribute);\n\n      function setUp() public virtual {\n        usdeToken = new USDe(address(this));\n\n        alice = makeAddr(\"alice\");\n        bob = makeAddr(\"bob\");\n        greg = makeAddr(\"greg\");\n        owner = makeAddr(\"owner\");\n\n        usdeToken.setMinter(address(this));\n\n        vm.startPrank(owner);\n        stakedUSDeV2 = new StakedUSDeV2(IUSDe(address(usdeToken)), makeAddr('rewarder'), owner);\n        vm.stopPrank();\n\n        FULL_RESTRICTED_STAKER_ROLE = keccak256(\"FULL_RESTRICTED_STAKER_ROLE\");\n        SOFT_RESTRICTED_STAKER_ROLE = keccak256(\"SOFT_RESTRICTED_STAKER_ROLE\");\n        DEFAULT_ADMIN_ROLE = 0x00;\n        BLACKLIST_MANAGER_ROLE = keccak256(\"BLACKLIST_MANAGER_ROLE\");\n        REWARDER_ROLE = keccak256(\"REWARDER_ROLE\");\n      }\n\n      function test_UnstakeUnallowedAfterCooldownIsTurnedOff () public {\n        address staker = address(20);\n        uint usdeTokenAmountToMint = 10000*1e18;\n\n        usdeToken.mint(staker, usdeTokenAmountToMint);\n\n        //at the deposit coolDownDuration is set to 90 days \n        assert(stakedUSDeV2.cooldownDuration() == 90 days);\n\n        vm.startPrank(staker);\n        usdeToken.approve(address(stakedUSDeV2), usdeTokenAmountToMint);\n        \n        stakedUSDeV2.deposit(usdeTokenAmountToMint / 2, staker);\n\n        vm.roll(block.number + 1);\n        uint assets  = stakedUSDeV2.maxWithdraw(staker);\n        stakedUSDeV2.cooldownAssets(assets , staker);\n        \n        vm.stopPrank();\n\n        //assert that cooldown for the staker is now set to 90 days from now \n        ( uint104 cooldownEnd, ) = stakedUSDeV2.cooldowns(staker);\n        assert(cooldownEnd == uint104( block.timestamp + 90 days));\n\n        vm.prank(owner);\n        //toggle coolDown off in the contract \n        stakedUSDeV2.setCooldownDuration(0);\n\n        //now try to unstake, \n        /** since cooldown duration is now 0 and contract is cooldown state is turned off. \n        it should allow unstake immediately but instead it will revert **/\n        vm.expectRevert(IStakedUSDeCooldown.InvalidCooldown.selector);\n        vm.prank(staker);\n        stakedUSDeV2.unstake(staker);\n      }\n    }\n```\n\n### Tools Used\n\nManual review, Foundry\n\n### Recommended Mitigation Steps\n\nModify the code in unstake() fcn to allow for withdrawals from the silo contract when the contract's coolDownDuration has become 0.\n\n### Assessed type\n\nError\n\n**[kayinnnn (Ethena) confirmed and commented](https://github.com/code-423n4/2023-10-ethena-findings/issues/198#issuecomment-1858131607):**\n> Acknowledge the issue, but revise to low severity finding as it causes minor inconvenience in the rare time we change cooldown period. However, it is still fixed - existing per user cooldown is ignored if the global cooldown is `0`.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-ethena",
  "Code": [
    {
      "filename": "contracts/token/ERC20/extensions/ERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";\nimport {SafeERC20} from \"../utils/SafeERC20.sol\";\nimport {IERC4626} from \"../../../interfaces/IERC4626.sol\";\nimport {Math} from \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation uses virtual assets and shares to mitigate that risk. The `_decimalsOffset()`\n * corresponds to an offset in the decimal representation between the underlying asset's decimals and the vault\n * decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which itself\n * determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default offset\n * (0) makes it non-profitable, as a result of the value being captured by the virtual shares (out of the attacker's\n * donation) matching the attacker's expected gains. With a larger offset, the attack becomes orders of magnitude more\n * expensive than it is profitable. More details about the underlying math can be found\n * xref:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _underlyingDecimals;\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool, uint8) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _underlyingDecimals + _decimalsOffset();\n    }\n\n    /** @dev See {IERC4626-asset}. */\n    function asset() public view virtual returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4626-totalAssets}. */\n    function totalAssets() public view virtual returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4626-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-maxDeposit}. */\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint}. */\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-previewMint}. */\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /** @dev See {IERC4626-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /** @dev See {IERC4626-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint}.\n     *\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\n     * In this case, the shares will be minted without requiring any assets to be deposited.\n     */\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw}. */\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem}. */\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If _asset is ERC777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}"
    },
    {
      "filename": "contracts/StakedUSDeV2.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport \"./StakedUSDe.sol\";\nimport \"./interfaces/IStakedUSDeCooldown.sol\";\nimport \"./USDeSilo.sol\";\n\n/**\n * @title StakedUSDeV2\n * @notice The StakedUSDeV2 contract allows users to stake USDe tokens and earn a portion of protocol LST and perpetual yield that is allocated\n * to stakers by the Ethena DAO governance voted yield distribution algorithm.  The algorithm seeks to balance the stability of the protocol by funding\n * the protocol's insurance fund, DAO activities, and rewarding stakers with a portion of the protocol's yield.\n * @dev If cooldown duration is set to zero, the StakedUSDeV2 behavior changes to follow ERC4626 standard and disables cooldownShares and cooldownAssets methods. If cooldown duration is greater than zero, the ERC4626 withdrawal and redeem functions are disabled, breaking the ERC4626 standard, and enabling the cooldownShares and the cooldownAssets functions.\n */\ncontract StakedUSDeV2 is IStakedUSDeCooldown, StakedUSDe {\n  using SafeERC20 for IERC20;\n\n  mapping(address => UserCooldown) public cooldowns;\n\n  USDeSilo public silo;\n\n  uint24 public MAX_COOLDOWN_DURATION = 90 days;\n\n  uint24 public cooldownDuration;\n\n  /// @notice ensure cooldownDuration is zero\n  modifier ensureCooldownOff() {\n    if (cooldownDuration != 0) revert OperationNotAllowed();\n    _;\n  }\n\n  /// @notice ensure cooldownDuration is gt 0\n  modifier ensureCooldownOn() {\n    if (cooldownDuration == 0) revert OperationNotAllowed();\n    _;\n  }\n\n  /// @notice Constructor for StakedUSDeV2 contract.\n  /// @param _asset The address of the USDe token.\n  /// @param initialRewarder The address of the initial rewarder.\n  /// @param owner The address of the admin role.\n  constructor(IERC20 _asset, address initialRewarder, address owner) StakedUSDe(_asset, initialRewarder, owner) {\n    silo = new USDeSilo(address(this), address(_asset));\n    cooldownDuration = MAX_COOLDOWN_DURATION;\n  }\n\n  /* ------------- EXTERNAL ------------- */\n\n  /**\n   * @dev See {IERC4626-withdraw}.\n   */\n  function withdraw(uint256 assets, address receiver, address owner)\n    public\n    virtual\n    override\n    ensureCooldownOff\n    returns (uint256)\n  {\n    return super.withdraw(assets, receiver, owner);\n  }\n\n  /**\n   * @dev See {IERC4626-redeem}.\n   */\n  function redeem(uint256 shares, address receiver, address owner)\n    public\n    virtual\n    override\n    ensureCooldownOff\n    returns (uint256)\n  {\n    return super.redeem(shares, receiver, owner);\n  }\n\n  /// @notice Claim the staking amount after the cooldown has finished. The address can only retire the full amount of assets.\n  /// @dev unstake can be called after cooldown have been set to 0, to let accounts to be able to claim remaining assets locked at Silo\n  /// @param receiver Address to send the assets by the staker\n  function unstake(address receiver) external {\n    UserCooldown storage userCooldown = cooldowns[msg.sender];\n    uint256 assets = userCooldown.underlyingAmount;\n\n    if (block.timestamp >= userCooldown.cooldownEnd) {\n      userCooldown.cooldownEnd = 0;\n      userCooldown.underlyingAmount = 0;\n\n      silo.withdraw(receiver, assets);\n    } else {\n      revert InvalidCooldown();\n    }\n  }\n\n  /// @notice redeem assets and starts a cooldown to claim the converted underlying asset\n  /// @param assets assets to redeem\n  /// @param owner address to redeem and start cooldown, owner must allowed caller to perform this action\n  function cooldownAssets(uint256 assets, address owner) external ensureCooldownOn returns (uint256) {\n    if (assets > maxWithdraw(owner)) revert ExcessiveWithdrawAmount();\n\n    uint256 shares = previewWithdraw(assets);\n\n    cooldowns[owner].cooldownEnd = uint104(block.timestamp) + cooldownDuration;\n    cooldowns[owner].underlyingAmount += assets;\n\n    _withdraw(_msgSender(), address(silo), owner, assets, shares);\n\n    return shares;\n  }\n\n  /// @notice redeem shares into assets and starts a cooldown to claim the converted underlying asset\n  /// @param shares shares to redeem\n  /// @param owner address to redeem and start cooldown, owner must allowed caller to perform this action\n  function cooldownShares(uint256 shares, address owner) external ensureCooldownOn returns (uint256) {\n    if (shares > maxRedeem(owner)) revert ExcessiveRedeemAmount();\n\n    uint256 assets = previewRedeem(shares);\n\n    cooldowns[owner].cooldownEnd = uint104(block.timestamp) + cooldownDuration;\n    cooldowns[owner].underlyingAmount += assets;\n\n    _withdraw(_msgSender(), address(silo), owner, assets, shares);\n\n    return assets;\n  }\n\n  /// @notice Set cooldown duration. If cooldown duration is set to zero, the StakedUSDeV2 behavior changes to follow ERC4626 standard and disables cooldownShares and cooldownAssets methods. If cooldown duration is greater than zero, the ERC4626 withdrawal and redeem functions are disabled, breaking the ERC4626 standard, and enabling the cooldownShares and the cooldownAssets functions.\n  /// @param duration Duration of the cooldown\n  function setCooldownDuration(uint24 duration) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (duration > MAX_COOLDOWN_DURATION) {\n      revert InvalidCooldown();\n    }\n\n    uint24 previousDuration = cooldownDuration;\n    cooldownDuration = duration;\n    emit CooldownDurationUpdated(previousDuration, cooldownDuration);\n  }\n}"
    },
    {
      "filename": "contracts/StakedUSDeV2.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport \"./StakedUSDe.sol\";\nimport \"./interfaces/IStakedUSDeCooldown.sol\";\nimport \"./USDeSilo.sol\";\n\n/**\n * @title StakedUSDeV2\n * @notice The StakedUSDeV2 contract allows users to stake USDe tokens and earn a portion of protocol LST and perpetual yield that is allocated\n * to stakers by the Ethena DAO governance voted yield distribution algorithm.  The algorithm seeks to balance the stability of the protocol by funding\n * the protocol's insurance fund, DAO activities, and rewarding stakers with a portion of the protocol's yield.\n * @dev If cooldown duration is set to zero, the StakedUSDeV2 behavior changes to follow ERC4626 standard and disables cooldownShares and cooldownAssets methods. If cooldown duration is greater than zero, the ERC4626 withdrawal and redeem functions are disabled, breaking the ERC4626 standard, and enabling the cooldownShares and the cooldownAssets functions.\n */\ncontract StakedUSDeV2 is IStakedUSDeCooldown, StakedUSDe {\n  using SafeERC20 for IERC20;\n\n  mapping(address => UserCooldown) public cooldowns;\n\n  USDeSilo public silo;\n\n  uint24 public MAX_COOLDOWN_DURATION = 90 days;\n\n  uint24 public cooldownDuration;\n\n  /// @notice ensure cooldownDuration is zero\n  modifier ensureCooldownOff() {\n    if (cooldownDuration != 0) revert OperationNotAllowed();\n    _;\n  }\n\n  /// @notice ensure cooldownDuration is gt 0\n  modifier ensureCooldownOn() {\n    if (cooldownDuration == 0) revert OperationNotAllowed();\n    _;\n  }\n\n  /// @notice Constructor for StakedUSDeV2 contract.\n  /// @param _asset The address of the USDe token.\n  /// @param initialRewarder The address of the initial rewarder.\n  /// @param owner The address of the admin role.\n  constructor(IERC20 _asset, address initialRewarder, address owner) StakedUSDe(_asset, initialRewarder, owner) {\n    silo = new USDeSilo(address(this), address(_asset));\n    cooldownDuration = MAX_COOLDOWN_DURATION;\n  }\n\n  /* ------------- EXTERNAL ------------- */\n\n  /**\n   * @dev See {IERC4626-withdraw}.\n   */\n  function withdraw(uint256 assets, address receiver, address owner)\n    public\n    virtual\n    override\n    ensureCooldownOff\n    returns (uint256)\n  {\n    return super.withdraw(assets, receiver, owner);\n  }\n\n  /**\n   * @dev See {IERC4626-redeem}.\n   */\n  function redeem(uint256 shares, address receiver, address owner)\n    public\n    virtual\n    override\n    ensureCooldownOff\n    returns (uint256)\n  {\n    return super.redeem(shares, receiver, owner);\n  }\n\n  /// @notice Claim the staking amount after the cooldown has finished. The address can only retire the full amount of assets.\n  /// @dev unstake can be called after cooldown have been set to 0, to let accounts to be able to claim remaining assets locked at Silo\n  /// @param receiver Address to send the assets by the staker\n  function unstake(address receiver) external {\n    UserCooldown storage userCooldown = cooldowns[msg.sender];\n    uint256 assets = userCooldown.underlyingAmount;\n\n    if (block.timestamp >= userCooldown.cooldownEnd) {\n      userCooldown.cooldownEnd = 0;\n      userCooldown.underlyingAmount = 0;\n\n      silo.withdraw(receiver, assets);\n    } else {\n      revert InvalidCooldown();\n    }\n  }\n\n  /// @notice redeem assets and starts a cooldown to claim the converted underlying asset\n  /// @param assets assets to redeem\n  /// @param owner address to redeem and start cooldown, owner must allowed caller to perform this action\n  function cooldownAssets(uint256 assets, address owner) external ensureCooldownOn returns (uint256) {\n    if (assets > maxWithdraw(owner)) revert ExcessiveWithdrawAmount();\n\n    uint256 shares = previewWithdraw(assets);\n\n    cooldowns[owner].cooldownEnd = uint104(block.timestamp) + cooldownDuration;\n    cooldowns[owner].underlyingAmount += assets;\n\n    _withdraw(_msgSender(), address(silo), owner, assets, shares);\n\n    return shares;\n  }\n\n  /// @notice redeem shares into assets and starts a cooldown to claim the converted underlying asset\n  /// @param shares shares to redeem\n  /// @param owner address to redeem and start cooldown, owner must allowed caller to perform this action\n  function cooldownShares(uint256 shares, address owner) external ensureCooldownOn returns (uint256) {\n    if (shares > maxRedeem(owner)) revert ExcessiveRedeemAmount();\n\n    uint256 assets = previewRedeem(shares);\n\n    cooldowns[owner].cooldownEnd = uint104(block.timestamp) + cooldownDuration;\n    cooldowns[owner].underlyingAmount += assets;\n\n    _withdraw(_msgSender(), address(silo), owner, assets, shares);\n\n    return assets;\n  }\n\n  /// @notice Set cooldown duration. If cooldown duration is set to zero, the StakedUSDeV2 behavior changes to follow ERC4626 standard and disables cooldownShares and cooldownAssets methods. If cooldown duration is greater than zero, the ERC4626 withdrawal and redeem functions are disabled, breaking the ERC4626 standard, and enabling the cooldownShares and the cooldownAssets functions.\n  /// @param duration Duration of the cooldown\n  function setCooldownDuration(uint24 duration) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (duration > MAX_COOLDOWN_DURATION) {\n      revert InvalidCooldown();\n    }\n\n    uint24 previousDuration = cooldownDuration;\n    cooldownDuration = duration;\n    emit CooldownDurationUpdated(previousDuration, cooldownDuration);\n  }\n}"
    }
  ]
}