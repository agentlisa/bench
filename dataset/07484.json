{
  "Title": "[M-13] One can become referral of hash 0x0 and because all users default referral hash is 0x0 so he would become all users referral by default and earn a lot of fees while users didnâ€™t approve it",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Referrals.sol#L20-L24\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/TradingExtension.sol#L148-L152\n\n\n# Vulnerability details\n\n## Impact\nBy default the value of `_referred[user]` is 0x0 for all users and if one set 0x0 as his referral hash then he would become referral for all the users who didn't set referral by default and he would earn a lot of referral funds that users didn't approve it.\n\n## Proof of Concept\nThis is `createReferralCode()` code:\n```\n    function createReferralCode(bytes32 _hash) external {\n        require(_referral[_hash] == address(0), \"Referral code already exists\");\n        _referral[_hash] = _msgSender();\n        emit ReferralCreated(_msgSender(), _hash);\n    }\n```\nAs you can see attacker can become set 0x0 as his hash referral by calling `createReferralCode(0x0)` and code would set `_referral[0x0] = attackerAddress` (attacker needs to be the first one calling this).\nThen in the `getRef()` code the logic would return `attackerAddress` as referral for all the users who didn't set referral.\n```\n    function getRef(\n        address _trader\n    ) external view returns(address) {\n        return referrals.getReferral(referrals.getReferred(_trader));\n    }\n```\nin the code, getReferred(trader) would return 0x0 because trader didn't set referred and getReferral(0x0) would return attackerAddress.\n`_handleOpenFees()` and `_handleCloseFees()` function in the Trading contract would use `getRef(trader)` and they would transfer referral fee to attackerAddress and attacker would receive fee form a lot of users which didn't set any referral, those users didn't set any referral and didn't approve attacker receiving referral fees from them and because most of the users wouldn't know about this and referral codes so attacker would receive a lot of funds.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nprevent some one from setting 0x0 hash for their referral code.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
  "Code": [
    {
      "filename": "contracts/Referrals.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IReferrals.sol\";\n\ncontract Referrals is Ownable, IReferrals {\n\n    bool private isInit;\n\n    address public protocol;\n\n    mapping(bytes32 => address) private _referral;\n    mapping(address => bytes32) private _referred;\n\n    /**\n    * @notice used by any address to create a ref code\n    * @param _hash hash of the string code\n    */\n    function createReferralCode(bytes32 _hash) external {\n        require(_referral[_hash] == address(0), \"Referral code already exists\");\n        _referral[_hash] = _msgSender();\n        emit ReferralCreated(_msgSender(), _hash);\n    }\n\n    /**\n    * @notice set the ref data\n    * @dev only callable by trading\n    * @param _referredTrader address of the trader\n    * @param _hash ref hash\n    */\n    function setReferred(address _referredTrader, bytes32 _hash) external onlyProtocol {\n        if (_referred[_referredTrader] != bytes32(0)) {\n            return;\n        }\n        if (_referredTrader == _referral[_hash]) {\n            return;\n        }\n        _referred[_referredTrader] = _hash;\n        emit Referred(_referredTrader, _hash);\n    }\n\n    function getReferred(address _trader) external view returns (bytes32) {\n        return _referred[_trader];\n    }\n\n    function getReferral(bytes32 _hash) external view returns (address) {\n        return _referral[_hash];\n    }\n\n    // Owner\n\n    function setProtocol(address _protocol) external onlyOwner {\n        protocol = _protocol;\n    }\n\n    /**\n    * @notice deprecated\n    */\n    function initRefs(\n        address[] memory _codeOwners,\n        bytes32[] memory _ownedCodes,\n        address[] memory _referredA,\n        bytes32[] memory _referredTo\n    ) external onlyOwner {\n        require(!isInit);\n        isInit = true;\n        uint _codeOwnersL = _codeOwners.length;\n        uint _referredAL = _referredA.length;\n        for (uint i=0; i<_codeOwnersL; i++) {\n            _referral[_ownedCodes[i]] = _codeOwners[i];\n        }\n        for (uint i=0; i<_referredAL; i++) {\n            _referred[_referredA[i]] = _referredTo[i];\n        }\n    }\n\n    // Modifiers\n\n    modifier onlyProtocol() {\n        require(_msgSender() == address(protocol), \"!Protocol\");\n        _;\n    }\n\n    event ReferralCreated(address _referrer, bytes32 _hash);\n    event Referred(address _referredTrader, bytes32 _hash);\n\n}"
    },
    {
      "filename": "contracts/TradingExtension.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IPairsContract.sol\";\nimport \"./utils/TradingLibrary.sol\";\nimport \"./interfaces/IReferrals.sol\";\nimport \"./interfaces/IPosition.sol\";\n\ncontract TradingExtension is Ownable{\n    uint constant private DIVISION_CONSTANT = 1e10; // 100%\n\n    address public trading;\n    uint256 public validSignatureTimer;\n    bool public chainlinkEnabled;\n\n    mapping(address => bool) private isNode;\n    mapping(address => uint) public minPositionSize;\n    mapping(address => bool) public allowedMargin;\n    bool public paused;\n\n    IPairsContract private pairsContract;\n    IReferrals private referrals;\n    IPosition private position;\n\n    uint public maxGasPrice = 1000000000000; // 1000 gwei\n\n    constructor(\n        address _trading,\n        address _pairsContract,\n        address _ref,\n        address _position\n    )\n    {\n        trading = _trading;\n        pairsContract = IPairsContract(_pairsContract);\n        referrals = IReferrals(_ref);\n        position = IPosition(_position);\n    }\n\n    /**\n    * @notice returns the minimum position size per collateral asset\n    * @param _asset address of the asset\n    */\n    function minPos(\n        address _asset\n    ) external view returns(uint) {\n        return minPositionSize[_asset];\n    }\n\n    /**\n    * @notice closePosition helper\n    * @dev only callable by trading contract\n    * @param _id id of the position NFT\n    * @param _price current asset price\n    * @param _percent close percentage\n    * @return _trade returns the trade struct from NFT contract\n    * @return _positionSize size of the position\n    * @return _payout amount of payout to the trader after closing\n    */\n    function _closePosition(\n        uint _id,\n        uint _price,\n        uint _percent\n    ) external onlyProtocol returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) {\n        _trade = position.trades(_id);\n        (_positionSize, _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);\n\n        unchecked {\n            if (_trade.direction) {\n                modifyLongOi(_trade.asset, _trade.tigAsset, false, (_trade.margin*_trade.leverage/1e18)*_percent/DIVISION_CONSTANT);\n            } else {\n                modifyShortOi(_trade.asset, _trade.tigAsset, false, (_trade.margin*_trade.leverage/1e18)*_percent/DIVISION_CONSTANT);     \n            }\n        }\n    }\n\n    /**\n    * @notice limitClose helper\n    * @dev only callable by trading contract\n    * @param _id id of the position NFT\n    * @param _tp true if long, else short\n    * @param _priceData price data object came from the price oracle\n    * @param _signature to verify the oracle\n    * @return _limitPrice price of sl or tp returned from positions contract\n    * @return _tigAsset address of the position collateral asset\n    */\n    function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external view returns(uint _limitPrice, address _tigAsset) {\n        _checkGas();\n        IPosition.Trade memory _trade = position.trades(_id);\n        _tigAsset = _trade.tigAsset;\n\n        getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        uint256 _price = _priceData.price;\n\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n\n        if (_tp) {\n            if (_trade.tpPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.tpPrice > _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.tpPrice < _price) revert(\"6\"); //LimitNotMet\n            }\n            _limitPrice = _trade.tpPrice;\n        } else {\n            if (_trade.slPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.slPrice < _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.slPrice > _price) revert(\"6\"); //LimitNotMet\n            }\n            _limitPrice = _trade.slPrice;\n        }\n    }\n\n    function _checkGas() public view {\n        if (tx.gasprice > maxGasPrice) revert(\"1\"); //GasTooHigh\n    }\n\n    function modifyShortOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) public onlyProtocol {\n        pairsContract.modifyShortOi(_asset, _tigAsset, _onOpen, _size);\n    }\n\n    function modifyLongOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) public onlyProtocol {\n        pairsContract.modifyLongOi(_asset, _tigAsset, _onOpen, _size);\n    }\n\n    function setMaxGasPrice(uint _maxGasPrice) external onlyOwner {\n        maxGasPrice = _maxGasPrice;\n    }\n\n    function getRef(\n        address _trader\n    ) external view returns(address) {\n        return referrals.getReferral(referrals.getReferred(_trader));\n    }\n\n    /**\n    * @notice verifies the signed price and returns it\n    * @param _asset id of position asset\n    * @param _priceData price data object came from the price oracle\n    * @param _signature to verify the oracle\n    * @param _withSpreadIsLong 0, 1, or 2 - to specify if we need the price returned to be after spread\n    * @return _price price after verification and with spread if _withSpreadIsLong is 1 or 2\n    * @return _spread spread after verification\n    */\n    function getVerifiedPrice(\n        uint _asset,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        uint _withSpreadIsLong\n    ) \n        public view\n        returns(uint256 _price, uint256 _spread) \n    {\n        TradingLibrary.verifyPrice(\n            validSignatureTimer,\n            _asset,\n            chainlinkEnabled,\n            pairsContract.idToAsset(_asset).chainlinkFeed,\n            _priceData,\n            _signature,\n            isNode\n        );\n        _price = _priceData.price;\n        _spread = _priceData.spread;\n\n        if(_withSpreadIsLong == 1) \n            _price += _price * _spread / DIVISION_CONSTANT;\n        else if(_withSpreadIsLong == 2) \n            _price -= _price * _spread / DIVISION_CONSTANT;\n    }\n\n    function _setReferral(\n        bytes32 _referral,\n        address _trader\n    ) external onlyProtocol {\n        \n        if (_referral != bytes32(0)) {\n            if (referrals.getReferral(_referral) != address(0)) {\n                if (referrals.getReferred(_trader) == bytes32(0)) {\n                    referrals.setReferred(_trader, _referral);\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev validates the inputs of trades\n     * @param _asset asset id\n     * @param _tigAsset margin asset\n     * @param _margin margin\n     * @param _leverage leverage\n     */\n    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view {\n        unchecked {\n            IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n            if (!allowedMargin[_tigAsset]) revert(\"!margin\");\n            if (paused) revert(\"paused\");\n            if (!pairsContract.allowedAsset(_asset)) revert(\"!allowed\");\n            if (_leverage < asset.minLeverage || _leverage > asset.maxLeverage) revert(\"!lev\");\n            if (_margin*_leverage/1e18 < minPositionSize[_tigAsset]) revert(\"!size\");\n        }\n    }\n\n    function setValidSignatureTimer(\n        uint _validSignatureTimer\n    )\n        external\n        onlyOwner\n    {\n        validSignatureTimer = _validSignatureTimer;\n    }\n\n    function setChainlinkEnabled(bool _bool) external onlyOwner {\n        chainlinkEnabled = _bool;\n    }\n\n    /**\n     * @dev whitelists a node\n     * @param _node node address\n     * @param _bool bool\n     */\n    function setNode(address _node, bool _bool) external onlyOwner {\n        isNode[_node] = _bool;\n    }\n\n    /**\n     * @dev Allows a tigAsset to be used\n     * @param _tigAsset tigAsset\n     * @param _bool bool\n     */\n    function setAllowedMargin(\n        address _tigAsset,\n        bool _bool\n    ) \n        external\n        onlyOwner\n    {\n        allowedMargin[_tigAsset] = _bool;\n    }\n\n    /**\n     * @dev changes the minimum position size\n     * @param _tigAsset tigAsset\n     * @param _min minimum position size 18 decimals\n     */\n    function setMinPositionSize(\n        address _tigAsset,\n        uint _min\n    ) \n        external\n        onlyOwner\n    {\n        minPositionSize[_tigAsset] = _min;\n    }\n\n    function setPaused(bool _paused) external onlyOwner {\n        paused = _paused;\n    }\n\n    modifier onlyProtocol { \n        require(msg.sender == trading, \"!protocol\");\n        _;\n    }\n}"
    }
  ]
}