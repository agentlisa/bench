{
  "Title": "M-9: Virtual swap balances don't take into account token prices",
  "Content": "# Issue M-9: Virtual swap balances don't take into account token prices \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/251 \n\n## Found by \nIllIllI\n## Summary\n\nVirtual swap balances don't take into the fact that an exchange between the collateral token and the virtual token is taking place, necessitating an exchange rate.\n\n\n## Vulnerability Detail\n\nVirtual position impacts are all based on the virtual token being the same token as the market's index token. With virtual swap impacts, they're not the same token - the market token is a market collateral token, and the virtual token is some other token, which likely has a different price. For example, the README mentions ETH/USDC as ETH/USDT, where USDC is paired with USDT. USDC and USDT sound like they should be equivalent, but looking at the [monthly chart](https://www.huobi.com/en-us/exchange/usdc_usdt) of the exchange rate between the two, it has been between 0.8601 and 1.2000 - a 20% difference at the margins. Further, if one of them were to de-peg, the difference may be even larger and for a much longer period of time.\n\nThis applies to swaps, as well as to position changes, since those also track virtual swap inventory, since the balance is changing.\n\n\n## Impact\n\nOrders on some markets will get larger/smaller virtual discounts/penalties than they should, as compared to other markets using the same virtual impact pool. In addition to the basic accounting/fee issues associated with the difference, if the price difference is large enough, someone can swap through the market where the impact is smaller due to the exchange rate in order to push the impact more negative, and then simultaneously swap through the other market, where the same amount of funds would result in a larger positive impact than was incurred negatively in the other market, unfairly draining any impact discounts available to legitimate traders.\n\n\n## Code Snippet\n\nThe delta being applied is a token amount:\n```solidity\n// File: gmx-synthetics/contracts/swap/SwapUtils.sol : SwapUtils._swap()   #1\n\n283            MarketUtils.applyDeltaToPoolAmount(\n284                params.dataStore,\n285                params.eventEmitter,\n286                _params.market.marketToken,\n287                _params.tokenIn,\n288 @>             (cache.amountIn + fees.feeAmountForPool).toInt256()\n289            );\n290    \n291            // the poolAmountOut excludes the positive price impact amount\n292            // as that is deducted from the swap impact pool instead\n293:           MarketUtils.applyDeltaToPoolAmount(\n```\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/swap/SwapUtils.sol#L273-L293\n\nand is stored [unaltered](https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L701-L721) as the virtual amount:\n\n\n```solidity\n// File: gmx-synthetics/contracts/market/MarketUtils.sol : MarketUtils.applyDeltaToVirtualInventoryForSwaps()   #2\n\n1471        function applyDeltaToVirtualInventoryForSwaps(\n1472            DataStore dataStore,\n1473            EventEmitter eventEmitter,\n1474            address market,\n1475            address token,\n1476            int256 delta\n1477        ) internal returns (bool, uint256) {\n1478            bytes32 marketId = dataStore.getBytes32(Keys.virtualMarketIdKey(market));\n1479            if (marketId == bytes32(0)) {\n1480                return (false, 0);\n1481            }\n1482    \n1483            uint256 nextValue = dataStore.applyBoundedDeltaToUint(\n1484                Keys.virtualInventoryForSwapsKey(marketId, token),\n1485 @>             delta\n1486            );\n1487    \n1488            MarketEventUtils.emitVirtualSwapInventoryUpdated(eventEmitter, market, token, marketId, delta, nextValue);\n1489    \n1490            return (true, nextValue);\n1491:       }\n```\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L1471-L1491\n\nThe same is true for [deposits](https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/deposit/ExecuteDepositUtils.sol#L318-L338), [decreases](https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L701-L721), [increases](https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L701-L721), and [withdrawals](https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol#L331-L351).\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nUse oracle prices and convert the collateral token to the specific virtual token\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/swap/SwapUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../token/TokenUtils.sol\";\nimport \"../fee/FeeUtils.sol\";\n\n/**\n * @title SwapUtils\n * @dev Library for swap functions\n */\nlibrary SwapUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    /**\n     * @param dataStore The contract that provides access to data stored on-chain.\n     * @param eventEmitter The contract that emits events.\n     * @param oracle The contract that provides access to price data from oracles.\n     * @param bank The contract providing the funds for the swap.\n     * @param key An identifying key for the swap.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param swapPathMarkets An array of market properties, specifying the markets in which the swap should be executed.\n     * @param minOutputAmount The minimum amount of tokens that should be received as part of the swap.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param uiFeeReceiver The address of the ui fee receiver.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct SwapParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        Oracle oracle;\n        Bank bank;\n        bytes32 key;\n        address tokenIn;\n        uint256 amountIn;\n        Market.Props[] swapPathMarkets;\n        uint256 minOutputAmount;\n        address receiver;\n        address uiFeeReceiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param market The market in which the swap should be executed.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct _SwapParams {\n        Market.Props market;\n        address tokenIn;\n        uint256 amountIn;\n        address receiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param tokenOut The address of the token that is being received as part of the swap.\n     * @param tokenInPrice The price of the token that is being swapped.\n     * @param tokenOutPrice The price of the token that is being received as part of the swap.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param amountOut The amount of the token that is being received as part of the swap.\n     * @param poolAmountOut The total amount of the token that is being received by all users in the swap pool.\n     */\n    struct SwapCache {\n        address tokenOut;\n        Price.Props tokenInPrice;\n        Price.Props tokenOutPrice;\n        uint256 amountIn;\n        uint256 amountOut;\n        uint256 poolAmountOut;\n    }\n\n    event SwapReverted(string reason, bytes reasonBytes);\n\n    /**\n     * @dev Swaps a given amount of a given token for another token based on a\n     * specified swap path.\n     * @param params The parameters for the swap.\n     * @return A tuple containing the address of the token that was received as\n     * part of the swap and the amount of the received token.\n     */\n    function swap(SwapParams memory params) external returns (address, uint256) {\n        if (params.swapPathMarkets.length == 0) {\n            if (params.amountIn < params.minOutputAmount) {\n                revert Errors.InsufficientOutputAmount(params.amountIn, params.minOutputAmount);\n            }\n\n            if (address(params.bank) != params.receiver) {\n                params.bank.transferOut(\n                    params.tokenIn,\n                    params.receiver,\n                    params.amountIn,\n                    params.shouldUnwrapNativeToken\n                );\n            }\n\n            return (params.tokenIn, params.amountIn);\n        }\n\n        if (address(params.bank) != params.swapPathMarkets[0].marketToken) {\n            params.bank.transferOut(\n                params.tokenIn,\n                params.swapPathMarkets[0].marketToken,\n                params.amountIn,\n                false\n            );\n        }\n\n        address tokenOut = params.tokenIn;\n        uint256 outputAmount = params.amountIn;\n\n        for (uint256 i; i < params.swapPathMarkets.length; i++) {\n            Market.Props memory market = params.swapPathMarkets[i];\n\n            bool flagExists = params.dataStore.getBool(Keys.swapPathMarketFlagKey(market.marketToken));\n            if (flagExists) {\n                revert Errors.DuplicatedMarketInSwapPath(market.marketToken);\n            }\n\n            params.dataStore.setBool(Keys.swapPathMarketFlagKey(market.marketToken), true);\n\n            uint256 nextIndex = i + 1;\n            address receiver;\n            if (nextIndex < params.swapPathMarkets.length) {\n                receiver = params.swapPathMarkets[nextIndex].marketToken;\n            } else {\n                receiver = params.receiver;\n            }\n\n            _SwapParams memory _params = _SwapParams(\n                market,\n                tokenOut,\n                outputAmount,\n                receiver,\n                i == params.swapPathMarkets.length - 1 ? params.shouldUnwrapNativeToken : false // only convert ETH on the last swap if needed\n            );\n\n            (tokenOut, outputAmount) = _swap(params, _params);\n        }\n\n        for (uint256 i; i < params.swapPathMarkets.length; i++) {\n            Market.Props memory market = params.swapPathMarkets[i];\n            params.dataStore.setBool(Keys.swapPathMarketFlagKey(market.marketToken), false);\n        }\n\n        if (outputAmount < params.minOutputAmount) {\n            revert Errors.InsufficientSwapOutputAmount(outputAmount, params.minOutputAmount);\n        }\n\n        return (tokenOut, outputAmount);\n    }\n\n    /**\n     * Performs a swap on a single market.\n     *\n     * @param params  The parameters for the swap.\n     * @param _params The parameters for the swap on this specific market.\n     * @return The token and amount that was swapped.\n     */\n    function _swap(SwapParams memory params, _SwapParams memory _params) internal returns (address, uint256) {\n        SwapCache memory cache;\n\n        if (_params.tokenIn != _params.market.longToken && _params.tokenIn != _params.market.shortToken) {\n            revert Errors.InvalidTokenIn(_params.tokenIn, _params.market.marketToken);\n        }\n\n        MarketUtils.validateSwapMarket(_params.market);\n\n        cache.tokenOut = MarketUtils.getOppositeToken(_params.tokenIn, _params.market);\n        cache.tokenInPrice = params.oracle.getLatestPrice(_params.tokenIn);\n        cache.tokenOutPrice = params.oracle.getLatestPrice(cache.tokenOut);\n\n        SwapPricingUtils.SwapFees memory fees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.amountIn,\n            params.uiFeeReceiver\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            fees.feeReceiverAmount,\n            Keys.SWAP_FEE\n        );\n\n        FeeUtils.incrementClaimableUiFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            params.uiFeeReceiver,\n            _params.market.marketToken,\n            _params.tokenIn,\n            fees.uiFeeAmount,\n            Keys.UI_SWAP_FEE\n        );\n\n        int256 priceImpactUsd = SwapPricingUtils.getPriceImpactUsd(\n            SwapPricingUtils.GetPriceImpactUsdParams(\n                params.dataStore,\n                _params.market,\n                _params.tokenIn,\n                cache.tokenOut,\n                cache.tokenInPrice.midPrice(),\n                cache.tokenOutPrice.midPrice(),\n                (fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256(),\n                -(fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256()\n            )\n        );\n\n        if (priceImpactUsd > 0) {\n            // when there is a positive price impact factor, additional tokens from the swap impact pool\n            // are withdrawn for the user\n            // for example, if 50,000 USDC is swapped out and there is a positive price impact\n            // an additional 100 USDC may be sent to the user\n            // the swap impact pool is decreased by the used amount\n\n            cache.amountIn = fees.amountAfterFees;\n            // round amountOut down\n            cache.amountOut = cache.amountIn * cache.tokenInPrice.min / cache.tokenOutPrice.max;\n            cache.poolAmountOut = cache.amountOut;\n\n            int256 positiveImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                cache.tokenOut,\n                cache.tokenOutPrice,\n                priceImpactUsd\n            );\n\n            cache.amountOut += positiveImpactAmount.toUint256();\n        } else {\n            // when there is a negative price impact factor,\n            // less of the input amount is sent to the pool\n            // for example, if 10 ETH is swapped in and there is a negative price impact\n            // only 9.995 ETH may be swapped in\n            // the remaining 0.005 ETH will be stored in the swap impact pool\n\n            int256 negativeImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                _params.tokenIn,\n                cache.tokenInPrice,\n                priceImpactUsd\n            );\n\n            cache.amountIn = fees.amountAfterFees - (-negativeImpactAmount).toUint256();\n            cache.amountOut = cache.amountIn * cache.tokenInPrice.min / cache.tokenOutPrice.max;\n            cache.poolAmountOut = cache.amountOut;\n        }\n\n        // the amountOut value includes the positive price impact amount\n        if (_params.receiver != _params.market.marketToken) {\n            MarketToken(payable(_params.market.marketToken)).transferOut(\n                cache.tokenOut,\n                _params.receiver,\n                cache.amountOut,\n                _params.shouldUnwrapNativeToken\n            );\n        }\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            (cache.amountIn + fees.feeAmountForPool).toInt256()\n        );\n\n        // the poolAmountOut excludes the positive price impact amount\n        // as that is deducted from the swap impact pool instead\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            cache.tokenOut,\n            -cache.poolAmountOut.toInt256()\n        );\n\n        MarketUtils.MarketPrices memory prices = MarketUtils.MarketPrices(\n            params.oracle.getLatestPrice(_params.market.indexToken),\n            _params.tokenIn == _params.market.longToken ? cache.tokenInPrice : cache.tokenOutPrice,\n            _params.tokenIn == _params.market.shortToken ? cache.tokenInPrice : cache.tokenOutPrice\n        );\n\n        MarketUtils.validatePoolAmount(\n            params.dataStore,\n            _params.market,\n            _params.tokenIn\n        );\n\n        // for single token markets cache.tokenOut will always equal _params.market.longToken\n        // so only the reserve for longs will be validated\n        // swaps should be disabled for single token markets so this should not be an issue\n        MarketUtils.validateReserve(\n            params.dataStore,\n            _params.market,\n            prices,\n            cache.tokenOut == _params.market.longToken\n        );\n\n        MarketUtils.validateMaxPnl(\n            params.dataStore,\n            _params.market,\n            prices,\n            _params.tokenIn == _params.market.longToken ? Keys.MAX_PNL_FACTOR_FOR_DEPOSITS : Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS,\n            cache.tokenOut == _params.market.shortToken ? Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS : Keys.MAX_PNL_FACTOR_FOR_DEPOSITS\n        );\n\n        SwapPricingUtils.emitSwapInfo(\n            params.eventEmitter,\n            params.key,\n            _params.market.marketToken,\n            _params.receiver,\n            _params.tokenIn,\n            cache.tokenOut,\n            cache.tokenInPrice.min,\n            cache.tokenOutPrice.max,\n            _params.amountIn,\n            cache.amountIn,\n            cache.amountOut,\n            priceImpactUsd\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            cache.tokenInPrice.min,\n            \"swap\",\n            fees\n        );\n\n        return (cache.tokenOut, cache.amountOut);\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/market/MarketUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../bank/StrictBank.sol\";\n\nimport \"./Market.sol\";\nimport \"./MarketPoolValueInfo.sol\";\nimport \"./MarketToken.sol\";\nimport \"./MarketEventUtils.sol\";\nimport \"./MarketStoreUtils.sol\";\n\nimport \"../position/Position.sol\";\nimport \"../order/Order.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../price/Price.sol\";\n\nimport \"../utils/Calc.sol\";\nimport \"../utils/Precision.sol\";\n\n// @title MarketUtils\n// @dev Library for market functions\nlibrary MarketUtils {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    using Market for Market.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev struct to store the prices of tokens of a market\n    // @param indexTokenPrice price of the market's index token\n    // @param longTokenPrice price of the market's long token\n    // @param shortTokenPrice price of the market's short token\n    struct MarketPrices {\n        Price.Props indexTokenPrice;\n        Price.Props longTokenPrice;\n        Price.Props shortTokenPrice;\n    }\n\n    // @dev struct for the result of the getNextFundingAmountPerSize call\n    // @param longsPayShorts whether longs pay shorts or shorts pay longs\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding amount per\n    // size for users with a long position using long collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding amount per\n    // size for users with a short position using long collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding amount per\n    // size for users with a long position using short collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding amount per\n    // size for users with a short position using short collateral\n    struct GetNextFundingAmountPerSizeResult {\n        bool longsPayShorts;\n        uint256 fundingFactorPerSecond;\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n    }\n\n    // @dev GetNextFundingAmountPerSizeCache struct used in getNextFundingAmountPerSize\n    // to avoid stack too deep errors\n    //\n    // @param durationInSeconds duration in seconds since the last funding update\n    //\n    // @param diffUsd the absolute difference in long and short open interest for the market\n    // @param totalOpenInterest the total long and short open interest for the market\n    // @param fundingUsd the funding amount in USD\n    //\n    // @param fundingUsdForLongCollateral the funding amount in USD for positions using the long token as collateral\n    // @param fundingUsdForShortCollateral the funding amount in USD for positions using the short token as collateral\n    struct GetNextFundingAmountPerSizeCache {\n        GetNextFundingAmountPerSizeOpenInterestCache oi;\n        GetNextFundingAmountPerSizeFundingPerSizeCache fps;\n\n        uint256 durationInSeconds;\n\n        uint256 diffUsd;\n        uint256 totalOpenInterest;\n        uint256 sizeOfLargerSide;\n        uint256 fundingUsd;\n\n        uint256 fundingUsdForLongCollateral;\n        uint256 fundingUsdForShortCollateral;\n\n        uint256 fundingAmountForLongCollateral;\n        uint256 fundingAmountForShortCollateral;\n    }\n\n    // @param longOpenInterestWithLongCollateral amount of long open interest using the long token as collateral\n    // @param longOpenInterestWithShortCollateral amount of long open interest using the short token as collateral\n    // @param shortOpenInterestWithLongCollateral amount of short open interest using the long token as collateral\n    // @param shortOpenInterestWithShortCollateral amount of short open interest using the short token as collateral\n    //\n    // @param longOpenInterest total long open interest for the market\n    // @param shortOpenInterest total short open interest for the market\n    struct GetNextFundingAmountPerSizeOpenInterestCache {\n        uint256 longOpenInterestWithLongCollateral;\n        uint256 longOpenInterestWithShortCollateral;\n        uint256 shortOpenInterestWithLongCollateral;\n        uint256 shortOpenInterestWithShortCollateral;\n\n        uint256 longOpenInterest;\n        uint256 shortOpenInterest;\n    }\n\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding per size for longs using the long token as collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding per size for shorts using the long token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding per size for longs using the short token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding per size for shorts using the short token as collateral\n    //\n    // @param fundingAmountPerSizeDelta_LongCollateral_LongPosition the next funding amount per size for longs using the long token as collateral\n    // @param fundingAmountPerSizeDelta_LongCollateral_ShortPosition the next funding amount per size for longs using the short token as collateral\n    // @param fundingAmountPerSizeDelta_ShortCollateral_LongPosition the next funding amount per size for shorts using the long token as collateral\n    // @param fundingAmountPerSizeDelta_ShortCollateral_ShortPosition the next funding amount per size for shorts using the short token as collateral\n    struct GetNextFundingAmountPerSizeFundingPerSizeCache {\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n\n        uint256 fundingAmountPerSizeDelta_LongCollateral_LongPosition;\n        uint256 fundingAmountPerSizeDelta_ShortCollateral_LongPosition;\n        uint256 fundingAmountPerSizeDelta_LongCollateral_ShortPosition;\n        uint256 fundingAmountPerSizeDelta_ShortCollateral_ShortPosition;\n    }\n\n    struct GetExpectedMinTokenBalanceCache {\n        uint256 poolAmount;\n        uint256 collateralForLongs;\n        uint256 collateralForShorts;\n        uint256 swapImpactPoolAmount;\n        uint256 claimableCollateralAmount;\n        uint256 claimableFeeAmount;\n        uint256 claimableUiFeeAmount;\n        uint256 affiliateRewardAmount;\n    }\n\n    // @dev get the market token's price\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longTokenPrice the price of the long token\n    // @param shortTokenPrice the price of the short token\n    // @param indexTokenPrice the price of the index token\n    // @param maximize whether to maximize or minimize the market token price\n    // @return returns the market token's price\n    function getMarketTokenPrice(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory indexTokenPrice,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) external view returns (int256, MarketPoolValueInfo.Props memory) {\n        MarketPoolValueInfo.Props memory poolValueInfo = getPoolValueInfo(\n            dataStore,\n            market,\n            indexTokenPrice,\n            longTokenPrice,\n            shortTokenPrice,\n            pnlFactorType,\n            maximize\n        );\n\n        if (poolValueInfo.poolValue == 0) { return (0, poolValueInfo); }\n\n        if (poolValueInfo.poolValue < 0) {\n            revert Errors.UnexpectedPoolValueForTokenPriceCalculation(poolValueInfo.poolValue);\n        }\n\n        uint256 supply = getMarketTokenSupply(MarketToken(payable(market.marketToken)));\n\n        if (supply == 0) {\n            revert Errors.UnexpectedSupplyForTokenPriceCalculation();\n        }\n\n        return (poolValueInfo.poolValue * Precision.WEI_PRECISION.toInt256() / supply.toInt256(), poolValueInfo);\n    }\n\n    // @dev get the total supply of the marketToken\n    // @param marketToken the marketToken\n    // @return the total supply of the marketToken\n    function getMarketTokenSupply(MarketToken marketToken) internal view returns (uint256) {\n        return marketToken.totalSupply();\n    }\n\n    // @dev get the opposite token of the market\n    // if the inputToken is the longToken return the shortToken and vice versa\n    // @param inputToken the input token\n    // @param market the market values\n    // @return the opposite token\n    function getOppositeToken(address inputToken, Market.Props memory market) internal pure returns (address) {\n        if (inputToken == market.longToken) {\n            return market.shortToken;\n        }\n\n        if (inputToken == market.shortToken) {\n            return market.longToken;\n        }\n\n        revert Errors.UnableToGetOppositeToken(inputToken, market.marketToken);\n    }\n\n    function validateSwapMarket(Market.Props memory market) internal pure {\n        if (market.longToken == market.shortToken) {\n            revert Errors.InvalidSwapMarket(market.marketToken);\n        }\n    }\n\n    // @dev get the token price from the stored MarketPrices\n    // @param token the token to get the price for\n    // @param the market values\n    // @param the market token prices\n    // @return the token price from the stored MarketPrices\n    function getCachedTokenPrice(address token, Market.Props memory market, MarketPrices memory prices) internal pure returns (Price.Props memory) {\n        if (token == market.longToken) {\n            return prices.longTokenPrice;\n        }\n        if (token == market.shortToken) {\n            return prices.shortTokenPrice;\n        }\n        if (token == market.indexToken) {\n            return prices.indexTokenPrice;\n        }\n\n        revert Errors.UnableToGetCachedTokenPrice(token, market.marketToken);\n    }\n\n    // @dev return the latest prices for the market tokens\n    // the secondary price for market.indexToken is overwritten for certain order\n    // types, use this value instead of the primary price for positions\n    // @param oracle Oracle\n    // @param market the market values\n    function getMarketPricesForPosition(Oracle oracle, Market.Props memory market) internal view returns (MarketPrices memory) {\n        return MarketPrices(\n            oracle.getLatestPrice(market.indexToken),\n            oracle.getLatestPrice(market.longToken),\n            oracle.getLatestPrice(market.shortToken)\n        );\n    }\n\n    // @dev return the primary prices for the market tokens\n    // @param oracle Oracle\n    // @param market the market values\n    function getMarketPrices(Oracle oracle, Market.Props memory market) internal view returns (MarketPrices memory) {\n        return MarketPrices(\n            oracle.getPrimaryPrice(market.indexToken),\n            oracle.getPrimaryPrice(market.longToken),\n            oracle.getPrimaryPrice(market.shortToken)\n        );\n    }\n\n    // @dev get the usd value of either the long or short tokens in the pool\n    // without accounting for the pnl of open positions\n    // @param dataStore DataStore\n    // @param market the market values\n    // @param prices the prices of the market tokens\n    // @param whether to return the value for the long or short token\n    // @return the usd value of either the long or short tokens in the pool\n    function getPoolUsdWithoutPnl(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketPrices memory prices,\n        bool isLong\n    ) internal view returns (uint256) {\n        address token = isLong ? market.longToken : market.shortToken;\n        uint256 poolAmount = getPoolAmount(dataStore, market, token);\n        uint256 tokenPrice = isLong ? prices.longTokenPrice.min : prices.shortTokenPrice.min;\n        return poolAmount * tokenPrice;\n    }\n\n    // @dev get the USD value of a pool\n    // the value of a pool is the worth of the liquidity provider tokens in the pool - pending trader pnl\n    // we use the token index prices to calculate this and ignore price impact since if all positions were closed the\n    // net price impact should be zero\n    // @param dataStore DataStore\n    // @param market the market values\n    // @param longTokenPrice price of the long token\n    // @param shortTokenPrice price of the short token\n    // @param indexTokenPrice price of the index token\n    // @param maximize whether to maximize or minimize the pool value\n    // @return the value information of a pool\n    function getPoolValueInfo(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory indexTokenPrice,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) public view returns (MarketPoolValueInfo.Props memory) {\n        MarketPoolValueInfo.Props memory result;\n\n        result.longTokenAmount = getPoolAmount(dataStore, market, market.longToken);\n        result.shortTokenAmount = getPoolAmount(dataStore, market, market.shortToken);\n\n        result.longTokenUsd = result.longTokenAmount * longTokenPrice.pickPrice(maximize);\n        result.shortTokenUsd = result.shortTokenAmount * shortTokenPrice.pickPrice(maximize);\n\n        uint256 poolValue = result.longTokenUsd + result.shortTokenUsd;\n\n        MarketPrices memory prices = MarketPrices(\n            indexTokenPrice,\n            longTokenPrice,\n            shortTokenPrice\n        );\n\n        result.totalBorrowingFees = getTotalPendingBorrowingFees(\n            dataStore,\n            market,\n            prices,\n            true\n        );\n\n        result.totalBorrowingFees += getTotalPendingBorrowingFees(\n            dataStore,\n            market,\n            prices,\n            false\n        );\n\n        result.borrowingFeePoolFactor = Precision.FLOAT_PRECISION - dataStore.getUint(Keys.BORROWING_FEE_RECEIVER_FACTOR);\n        poolValue += Precision.applyFactor(result.totalBorrowingFees, result.borrowingFeePoolFactor);\n\n        result.impactPoolAmount = getPositionImpactPoolAmount(dataStore, market.marketToken);\n        poolValue -= result.impactPoolAmount * indexTokenPrice.pickPrice(maximize);\n\n        // !maximize should be used for net pnl as a larger pnl leads to a smaller pool value\n        // and a smaller pnl leads to a larger pool value\n\n        result.longPnl = getPnl(\n            dataStore,\n            market,\n            indexTokenPrice,\n            true,\n            !maximize\n        );\n\n        result.longPnl = getCappedPnl(\n            dataStore,\n            market.marketToken,\n            true,\n            result.longPnl,\n            result.longTokenUsd,\n            pnlFactorType\n        );\n\n        result.shortPnl = getPnl(\n            dataStore,\n            market,\n            indexTokenPrice,\n            false,\n            !maximize\n        );\n\n        result.shortPnl = getCappedPnl(\n            dataStore,\n            market.marketToken,\n            false,\n            result.shortPnl,\n            result.shortTokenUsd,\n            pnlFactorType\n        );\n\n        result.netPnl = result.longPnl + result.shortPnl;\n\n        result.poolValue = Calc.sumReturnInt256(poolValue, -result.netPnl);\n        return result;\n    }\n\n    // @dev get the net pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param maximize whether to maximize or minimize the net pnl\n    // @return the net pending pnl for a market\n    function getNetPnl(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory indexTokenPrice,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 longPnl = getPnl(dataStore, market, indexTokenPrice, true, maximize);\n        int256 shortPnl = getPnl(dataStore, market, indexTokenPrice, false, maximize);\n\n        return longPnl + shortPnl;\n    }\n\n    // @dev get the capped pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param isLong whether to check for the long or short side\n    // @param pnl the uncapped pnl of the market\n    // @param poolUsd the USD value of the pool\n    // @param pnlFactorType the pnl factor type to use\n    function getCappedPnl(\n        DataStore dataStore,\n        address market,\n        bool isLong,\n        int256 pnl,\n        uint256 poolUsd,\n        bytes32 pnlFactorType\n    ) internal view returns (int256) {\n        if (pnl < 0) { return pnl; }\n\n        uint256 maxPnlFactor = getMaxPnlFactor(dataStore, pnlFactorType, market, isLong);\n        int256 maxPnl = Precision.applyFactor(poolUsd, maxPnlFactor).toInt256();\n\n        return pnl > maxPnl ? maxPnl : pnl;\n    }\n\n    // @dev get the pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param isLong whether to check for the long or short side\n    // @param maximize whether to maximize or minimize the pnl\n    function getPnl(\n        DataStore dataStore,\n        Market.Props memory market,\n        uint256 indexTokenPrice,\n        bool isLong,\n        bool maximize\n    ) internal view returns (int256) {\n        Price.Props memory _indexTokenPrice = Price.Props(indexTokenPrice, indexTokenPrice);\n\n        return getPnl(\n            dataStore,\n            market,\n            _indexTokenPrice,\n            isLong,\n            maximize\n        );\n    }\n\n    // @dev get the pending pnl for a market for either longs or shorts\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param isLong whether to get the pnl for longs or shorts\n    // @param maximize whether to maximize or minimize the net pnl\n    // @return the pending pnl for a market for either longs or shorts\n    function getPnl(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory indexTokenPrice,\n        bool isLong,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 openInterest = getOpenInterest(dataStore, market, isLong).toInt256();\n        uint256 openInterestInTokens = getOpenInterestInTokens(dataStore, market, isLong);\n        if (openInterest == 0 || open"
    }
  ]
}