{
  "Title": "M-17: Liquidation frontrunning can prevent debt repayment upon unpausing (restoring full router)",
  "Content": "# Issue M-17: Liquidation frontrunning can prevent debt repayment upon unpausing (restoring full router) \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/203 \n\n## Found by \n0x00ffDa\n## Summary\nDuring a period of time that the PauseRouter is in use, the valuations of a user's debt and collateral may make them subject to liquidation. But, in the first block after the normal Router is restored, MEV bots can preempt any transactions that could prevent the liquidation (e.g. repayment or adding collateral).\n\n## Vulnerability Detail\nPausing and unpausing the router is performed via a call to the active router's inherited [`UUPSUpgradeable.upgradeTo()`](https://github.com/notional-finance/contracts-v2/blob/b20a45c912785fab5f2b62992e5260f44dbae197/contracts/proxy/utils/UUPSUpgradeable.sol#L27) (or `upgradeToAndCall()`) function and supplying the address of the next router contract, which calls` GovernanceAction._authorizeUpgrade()` and then `ERC1967Upgrade._upgradeToAndCallSecure()` which ends with [`ERC1967Upgrade._upgradeTo()`](https://github.com/notional-finance/contracts-v2/blob/b20a45c912785fab5f2b62992e5260f44dbae197/contracts/proxy/ERC1967/ERC1967Upgrade.sol#L53) switching the implementation address to realize the desired change. Pausing may be performed by either the owner or the pause guardian role. Only the owner can unpause the system.\n\nNotional has forked governance logic from Compound. [In Compound](https://blog.openzeppelin.com/compound-finance-patch-audit/),  \"_Importantly, the pauseGuardian does not have the ability to prevent users from exiting their positions by calling redeem or repayBorrow\"_. However, in Notional this is not true. [The PauseRouter does not delegate account action functions](https://github.com/notional-finance/contracts-v2/blob/b20a45c912785fab5f2b62992e5260f44dbae197/contracts/external/PauseRouter.sol#L111) that would allow debt repayment. As such, without recourse to avoid it, user debt positions may become liquidatable during a pause.\n\nMEV bots are able to use view functions to monitor account health during a pause. So, while they may actively detect and frontrun debt repayment transactions upon system unpausing, it is not required. The normal operation of liquidators bots can have the same effect.\n\nNote that liquidations may be enabled during a pause as well. (That is determined by system configuration at the discretion of the owner or pause guardian and enabling it would pose additional liquidation risk to users.) The frontrunning vulnerability is present even if liquidations are not enabled during a pause.\n\nRef: [audit finding ](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/117)\n\n## Impact\n\nBy frontrunning any debt repayment (or collateral deposit) attempts after unpausing the router, MEV bots can unfairly liquidate all debt positions that became eligible for liquidation during the pause. This causes loss of funds to all affected users.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIf liquidation is not allowed during a pause, add a grace period after unpausing during which liquidation remains blocked to allow users to avoid unfair liquidation by repaying debt or supplying additional collateral.\n\n\n\n## Discussion\n\n**0x00ffDa**\n\nEscalate for 10 USDC\n\nI believe this finding should be reclassified as \"High\" severity because it meets all the current Sherlock criteria for \"High\" issues:\n\n> High: This vulnerability would result in a material loss of funds, and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\nSpecifically ... unfair liquidation is a material loss of user funds and can occur with low cost by any liquidator. Use of the `PauseRouter` is expected in any upgrade and it may also be used in other circumstances, so this is not \"stars must align\" scenario. The sponsor has already confirmed this is a valid finding.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I believe this finding should be reclassified as \"High\" severity because it meets all the current Sherlock criteria for \"High\" issues:\n> \n> > High: This vulnerability would result in a material loss of funds, and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n> \n> Specifically ... unfair liquidation is a material loss of user funds and can occur with low cost by any liquidator. Use of the `PauseRouter` is expected in any upgrade and it may also be used in other circumstances, so this is not \"stars must align\" scenario. The sponsor has already confirmed this is a valid finding.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xleastwood**\n\n> Escalate for 10 USDC\n> \n> I believe this finding should be reclassified as \"High\" severity because it meets all the current Sherlock criteria for \"High\" issues:\n> \n> > High: This vulnerability would result in a material loss of funds, and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n> \n> Specifically ... unfair liquidation is a material loss of user funds and can occur with low cost by any liquidator. Use of the `PauseRouter` is expected in any upgrade and it may also be used in other circumstances, so this is not \"stars must align\" scenario. The sponsor has already confirmed this is a valid finding.\n\nThe pause router is not expected in any upgrade to the Notional protocol. It is only used in an emergency situation, so by definition, this is already an unlikely scenario to occur. Additionally, it would be safer to allow for liquidations after the protocol has been unpaused because this is how the protocol is designed to stay solvent. Adding an arbitrary grace period only adds to the risk that a vault position may become undercollateralised. If anything, a better approach would be to allow for vault accounts to be liquidated from within the pause router because this functionality isn't currently enabled.\n\n**0xleastwood**\n\nI do think Notional prioritises protocol solvency in this emergency situations over user experience and I think this is the correct approach.\n\n**0x00ffDa**\n\n> The pause router is not expected in any upgrade to the Notional protocol.\n\n[From my reading of the V3 upgrade script](https://github.com/notional-finance/contracts-v2/blob/b20a45c912785fab5f2b62992e5260f44dbae197/scripts/mainnet/V3Environment.py#L250), it does plan to use the PauseRouter.\n\n\n**0xleastwood**\n\n> > The pause router is not expected in any upgrade to the Notional protocol.\n> \n> [From my reading of the V3 upgrade script](https://github.com/notional-finance/contracts-v2/blob/b20a45c912785fab5f2b62992e5260f44dbae197/scripts/mainnet/V3Environment.py#L250), it does plan to use the PauseRouter.\n\nI think this is unique to V3 migration because it takes a bit of time and requires multiple steps to perform. But generally speaking, most patch fixes can be done atomically.\n\n**jeffywu**\n\n> The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\nWe will take this risk during the upgrade. So if that is the definition of a high priority issue then this is not a high priority issue.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique \nConsidering this issue a valid medium given the circumstances under which this would occur and as mentioned by the Sponsor this can be considered an accepted risk. \n\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0x00ffDa](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203/#issuecomment-1570567625): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts/proxy/utils/UUPSUpgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is ERC1967Upgrade {\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}"
    },
    {
      "filename": "contracts/external/PauseRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./actions/ActionGuards.sol\";\nimport \"../global/StorageLayoutV2.sol\";\nimport \"../global/Constants.sol\";\nimport \"../proxy/utils/UUPSUpgradeable.sol\";\nimport \"../../interfaces/notional/NotionalProxy.sol\";\nimport \"../../interfaces/notional/NotionalCalculations.sol\";\nimport {IVaultAccountHealth} from \"../../interfaces/notional/IVaultController.sol\";\n\n/**\n * Read only version of the Router that can only be upgraded by governance. Used in emergency when the system must\n * be paused for some reason.\n */\ncontract PauseRouter is StorageLayoutV2, UUPSUpgradeable, ActionGuards {\n    address public immutable VIEWS;\n    address public immutable LIQUIDATE_CURRENCY;\n    address public immutable LIQUIDATE_FCASH;\n    address public immutable CALCULATION_VIEWS;\n    address public immutable VAULT_ACCOUNT_HEALTH;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor(\n        address views_,\n        address liquidateCurrency_,\n        address liquidatefCash_,\n        address calculationViews_,\n        address vaultAccountHealth_\n    ) {\n        VIEWS = views_;\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\n        LIQUIDATE_FCASH = liquidatefCash_;\n        CALCULATION_VIEWS = calculationViews_;\n        VAULT_ACCOUNT_HEALTH = vaultAccountHealth_;\n    }\n\n    /// @dev Internal method will be called during an UUPS upgrade, must return true to\n    /// authorize the upgrade. The UUPS check does a rollback check during the upgrade and\n    /// therefore we use the `rollbackRouterImplementation` to authorize the pauseGuardian\n    /// during this check. See GovernanceAction._authorizeUpgrade for where the rollbackRouterImplementation\n    /// storage slot is set.\n    function _authorizeUpgrade(address newImplementation) internal override {\n        // This is only true during a rollback check when the pause router is downgraded\n        bool isRollbackCheck = rollbackRouterImplementation != address(0) &&\n            newImplementation == rollbackRouterImplementation;\n\n        require(\n            owner == msg.sender || (msg.sender == pauseGuardian && isRollbackCheck),\n            \"Unauthorized upgrade\"\n        );\n\n        // Clear this storage slot so the guardian cannot upgrade back to the previous router,\n        // requires governance to do so.\n        rollbackRouterImplementation = address(0);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    function transferOwnership(\n        address newOwner,\n        bool direct\n    ) external onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0), \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    function claimOwnership() external {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Shows the current state of which liquidations are enabled\n    /// @return the current liquidation enable state as a bitmap\n    function getLiquidationEnabledState() external view returns (bytes1) {\n        return liquidationEnabledState;\n    }\n\n    /// @notice Sets a new liquidation enable state, only the owner or the guardian may do so\n    function setLiquidationEnabledState(bytes1 liquidationEnabledState_) external {\n        // Only authorized addresses can set the liquidation state\n        require(owner == msg.sender || msg.sender == pauseGuardian);\n        liquidationEnabledState = liquidationEnabledState_;\n    }\n\n    function isEnabled(bytes1 state) private view returns (bool) {\n        return (liquidationEnabledState & state == state);\n    }\n\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        // Liquidation calculation methods are stateful (they settle accounts if required)\n        // and therefore we prevent them from being called unless specifically authorized.\n        if (\n            (sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateCollateralCurrency.selector) &&\n            isEnabled(Constants.COLLATERAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\n                sig == NotionalProxy.liquidateLocalCurrency.selector) &&\n            isEnabled(Constants.LOCAL_CURRENCY_ENABLED)\n        ) {\n            return LIQUIDATE_CURRENCY;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashLocal.selector ||\n                sig == NotionalProxy.calculatefCashLocalLiquidation.selector) &&\n            isEnabled(Constants.LOCAL_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            (sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\n                sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector) &&\n            isEnabled(Constants.CROSS_CURRENCY_FCASH_ENABLED)\n        ) {\n            return LIQUIDATE_FCASH;\n        }\n\n        if (\n            sig == IVaultAccountHealth.getVaultAccountHealthFactors.selector ||\n            sig == IVaultAccountHealth.calculateDepositAmountInDeleverage.selector ||\n            sig == IVaultAccountHealth.checkVaultAccountCollateralRatio.selector ||\n            sig == IVaultAccountHealth.signedBalanceOfVaultTokenId.selector ||\n            sig == IVaultAccountHealth.getVaultAccount.selector ||\n            sig == IVaultAccountHealth.getVaultConfig.selector ||\n            sig == IVaultAccountHealth.getBorrowCapacity.selector ||\n            sig == IVaultAccountHealth.getSecondaryBorrow.selector ||\n            sig == IVaultAccountHealth.getVaultAccountSecondaryDebt.selector ||\n            sig == IVaultAccountHealth.getVaultState.selector\n        ) {\n            return VAULT_ACCOUNT_HEALTH;\n        } else if (\n            sig == NotionalCalculations.calculateNTokensToMint.selector ||\n            sig == NotionalCalculations.getfCashAmountGivenCashAmount.selector ||\n            sig == NotionalCalculations.getCashAmountGivenfCashAmount.selector ||\n            sig == NotionalCalculations.nTokenGetClaimableIncentives.selector\n        ) {\n            return CALCULATION_VIEWS;\n        }\n\n        // If not found then delegate to views. This will revert if there is no method on\n        // the view contract\n        return VIEWS;\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internal call site, it will return directly to the external caller.\n    function _delegate(address implementation) private {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    fallback() external payable {\n        _delegate(getRouterImplementation(msg.sig));\n    }\n\n    receive() external payable { }\n}"
    },
    {
      "filename": "scripts/mainnet/V3Environment.py",
      "content": "import json\nfrom brownie import (\n    accounts,\n    Contract, \n    interface, \n    MigratePrimeCash, \n    nProxy, \n    Router, \n    CompoundV2HoldingsOracle, \n    MockERC20, \n    ProportionalRebalancingStrategy\n)\nfrom tests.helpers import get_interest_rate_curve\nfrom scripts.primeCashOracle import CompoundConfig\nfrom scripts.deployment import deployNotionalContracts, deployBeacons\n\nwith open(\"v2.mainnet.json\", \"r\") as j:\n    MAINNET = json.load(j)\n\nclass V3Environment:\n    def __init__(self, accounts):\n        notionalInterfaceABI = interface.NotionalProxy.abi\n        self.deployer = accounts[0]\n        self.notional = Contract.from_abi(\n            \"Notional\", MAINNET[\"notional\"], abi=notionalInterfaceABI\n        )\n        self.proxy = Contract.from_abi(\n            \"Notional\", MAINNET[\"notional\"], abi=nProxy.abi\n        )\n        self.router = Contract.from_abi(\n            \"Notional\", MAINNET[\"notional\"], abi=Router.abi\n        )\n\n        deployBeacons(self.deployer, self.notional)\n    \n        self.rebalancingStrategy = ProportionalRebalancingStrategy.deploy(MAINNET[\"notional\"], {\"from\": self.deployer})\n\n        (self.finalRouter, self.pauseRouter, self.contracts) = deployNotionalContracts(\n            self.deployer, \n            Comptroller=MAINNET[\"compound\"][\"comptroller\"],\n            RebalancingStrategy=self.rebalancingStrategy\n        )\n\n        self.patchFix = MigratePrimeCash.deploy(\n            self.proxy.getImplementation(),\n            self.pauseRouter.address,\n            self.proxy.address,\n            {\"from\": self.deployer}\n        )\n\n        self.owner = self.notional.owner()\n        self.pauseRouter = self.router.pauseRouter()\n        self.guardian = self.router.pauseGuardian()\n        self.multisig = \"0x02479BFC7Dce53A02e26fE7baea45a0852CB0909\"\n\n        self.tokens = {\n            'DAI': Contract.from_abi('DAI', CompoundConfig['DAI']['underlying'], MockERC20.abi),\n            'USDC': Contract.from_abi('USDC', CompoundConfig['USDC']['underlying'], MockERC20.abi),\n            'WBTC': Contract.from_abi('WBTC', CompoundConfig['WBTC']['underlying'], MockERC20.abi),\n            'cETH': Contract.from_abi('cETH', CompoundConfig['ETH']['cToken'], MockERC20.abi),\n            'cDAI': Contract.from_abi('cDAI', CompoundConfig['DAI']['cToken'], MockERC20.abi),\n            'cUSDC': Contract.from_abi('cUSDC', CompoundConfig['USDC']['cToken'], MockERC20.abi),\n            'cWBTC': Contract.from_abi('cWBTC', CompoundConfig['WBTC']['cToken'], MockERC20.abi),\n        }\n\n        # Deploys Prime Cash Oracles\n        self.pETH = CompoundV2HoldingsOracle.deploy([\n            self.notional,\n            CompoundConfig[\"ETH\"][\"underlying\"],\n            CompoundConfig[\"ETH\"][\"cToken\"],\n            self.notional.getCurrencyAndRates(1)[\"assetRate\"][\"rateOracle\"],\n        ], {\"from\": self.deployer})\n\n        self.pDAI = CompoundV2HoldingsOracle.deploy([\n            self.notional,\n            CompoundConfig[\"DAI\"][\"underlying\"],\n            CompoundConfig[\"DAI\"][\"cToken\"],\n            self.notional.getCurrencyAndRates(2)[\"assetRate\"][\"rateOracle\"]\n        ], {\"from\": self.deployer})\n\n        self.pUSDC = CompoundV2HoldingsOracle.deploy([\n            self.notional,\n            CompoundConfig[\"USDC\"][\"underlying\"],\n            CompoundConfig[\"USDC\"][\"cToken\"],\n            self.notional.getCurrencyAndRates(3)[\"assetRate\"][\"rateOracle\"],\n        ], {\"from\": self.deployer})\n\n        self.pWBTC = CompoundV2HoldingsOracle.deploy([\n            self.notional,\n            CompoundConfig[\"WBTC\"][\"underlying\"],\n            CompoundConfig[\"WBTC\"][\"cToken\"],\n            self.notional.getCurrencyAndRates(4)[\"assetRate\"][\"rateOracle\"],\n        ], {\"from\": self.deployer})\n\n        self.primeCashOracles = { 'ETH': self.pETH, 'DAI': self.pDAI, 'USDC': self.pUSDC, 'WBTC': self.pWBTC }\n\n    def setMigrationSettings(self):\n        # TODO: change these...\n        self.patchFix.setMigrationSettings(\n            1,\n            [\n                get_interest_rate_curve(),\n                self.primeCashOracles['ETH'],\n                12, # 60 min oracle rate window\n                True,\n                'ETH',\n                'Ether',\n                [\n                    get_interest_rate_curve(\n                        kinkUtilization1=15,\n                        kinkUtilization2=80,\n                        kinkRate1=21,\n                        kinkRate2=60,\n                        maxRate25BPS=120,\n                        feeRatePercent=8,\n                        minFeeRateBPS=0,\n                        maxFeeRateBPS=100,\n                    ),\n                    get_interest_rate_curve(\n                        kinkUtilization1=15,\n                        kinkUtilization2=80,\n                        kinkRate1=21,\n                        kinkRate2=56,\n                        maxRate25BPS=120,\n                        feeRatePercent=10,\n                        minFeeRateBPS=15,\n                        maxFeeRateBPS=100,\n                    ),\n                ],\n                []\n            ],\n            {\"from\": self.owner}\n        )\n\n        self.patchFix.setMigrationSettings(\n            2,\n            [\n                get_interest_rate_curve(),\n                self.primeCashOracles['DAI'],\n                12, # 60 min oracle rate window\n                True,\n                'DAI',\n                'Dai Stablecoin',\n                [get_interest_rate_curve(\n                    kinkUtilization1=15,\n                    kinkUtilization2=80,\n                    kinkRate1=21,\n                    kinkRate2=48,\n                    maxRate25BPS=120,\n                    feeRatePercent=10,\n                    minFeeRateBPS=15,\n                    maxFeeRateBPS=100,\n                )] * 3,\n                []\n            ],\n            {\"from\": self.owner}\n        )\n\n        self.patchFix.setMigrationSettings(\n            3,\n            [\n                get_interest_rate_curve(),\n                self.primeCashOracles['USDC'],\n                12, # 60 min oracle rate window\n                True,\n                'USDC',\n                'USD Coin',\n                [get_interest_rate_curve(\n                    kinkUtilization1=15,\n                    kinkUtilization2=80,\n                    kinkRate1=21,\n                    kinkRate2=48,\n                    maxRate25BPS=120,\n                    feeRatePercent=10,\n                    minFeeRateBPS=15,\n                    maxFeeRateBPS=100,\n                )] * 3,\n                []\n            ],\n            {\"from\": self.owner}\n        )\n\n        self.patchFix.setMigrationSettings(\n            4,\n            [\n                get_interest_rate_curve(),\n                self.primeCashOracles['WBTC'],\n                12, # 60 min oracle rate window\n                True,\n                'WBTC',\n                'Wrapped Bitcoin',\n                [get_interest_rate_curve(\n                    kinkUtilization1=15,\n                    kinkUtilization2=80,\n                    kinkRate1=21,\n                    kinkRate2=30,\n                    maxRate25BPS=80,\n                    feeRatePercent=10,\n                    minFeeRateBPS=15,\n                    maxFeeRateBPS=100,\n                )] * 2,\n                []\n            ],\n            {\"from\": self.owner}\n        )\n\n    def runMigrationPrerequisites(self):\n        # Settle all outstanding accounts\n        # Settle all negative cash balances\n        pass\n\n    def upgradeToV3(self):\n        self.runMigrationPrerequisites()\n        self.setMigrationSettings()\n\n        # TODO: this is not listed on the current router so we can't set it\n        # need to upgrade the router to include the missing one\n        # self.notional.setPauseRouterAndGuardian(self.pauseRouter, self.guardian, {\"from\": self.owner})\n        self.notional.transferOwnership(self.patchFix, False, {\"from\": self.owner})\n\n        # Pause Notional using the new pauseRouter that allows claimOwnership\n        # self.notional.upgradeTo(self.pauseRouter, {\"from\": self.guardian})\n\n        # Inside here we can update totalfCash debts if required\n        manager = accounts.at(\"0x02479BFC7Dce53A02e26fE7baea45a0852CB0909\", force=True)\n        self.patchFix.updateTotalfCashDebt(1, [\n            [1679616000, 1003407512775],\n            [1687392000, 201970086079]\n        ], {\"from\": manager})\n        self.patchFix.updateTotalfCashDebt(2, [\n            [1679616000, 1072883461002390],\n            [1687392000, 789570035516478],\n            [1695168000, 52008307749624],\n            [1702944000, 275220459188932]\n        ], {\"from\": manager})\n        self.patchFix.updateTotalfCashDebt(3, [\n            [1679616000, 1457772038632780],\n            [1687392000, 1162183350991920],\n            [1695168000, 32997025882811],\n            [1702944000, 576507718708683]\n        ], {\"from\": manager})\n        self.patchFix.updateTotalfCashDebt(4, [\n            [1679616000, 3539631484],\n            [1687392000, 1300752453]\n        ], {\"from\": manager})\n\n        # Call Upgrade Patch Fix\n        self.patchFix.atomicPatchAndUpgrade({\"from\": self.owner})\n\n        # At this point, Notional V3 is upgraded but paused\n        self.notional.upgradeTo(self.finalRouter, {\"from\": self.owner})"
    },
    {
      "filename": "scripts/mainnet/V3Environment.py",
      "content": "import json\nfrom brownie import (\n    accounts,\n    Contract, \n    interface, \n    MigratePrimeCash, \n    nProxy, \n    Router, \n    CompoundV2HoldingsOracle, \n    MockERC20, \n    ProportionalRebalancingStrategy\n)\nfrom tests.helpers import get_interest_rate_curve\nfrom scripts.primeCashOracle import CompoundConfig\nfrom scripts.deployment import deployNotionalContracts, deployBeacons\n\nwith open(\"v2.mainnet.json\", \"r\") as j:\n    MAINNET = json.load(j)\n\nclass V3Environment:\n    def __init__(self, accounts):\n        notionalInterfaceABI = interface.NotionalProxy.abi\n        self.deployer = accounts[0]\n        self.notional = Contract.from_abi(\n            \"Notional\", MAINNET[\"notional\"], abi=notionalInterfaceABI\n        )\n        self.proxy = Contract.from_abi(\n            \"Notional\", MAINNET[\"notional\"], abi=nProxy.abi\n        )\n        self.router = Contract.from_abi(\n            \"Notional\", MAINNET[\"notional\"], abi=Router.abi\n        )\n\n        deployBeacons(self.deployer, self.notional)\n    \n        self.rebalancingStrategy = ProportionalRebalancingStrategy.deploy(MAINNET[\"notional\"], {\"from\": self.deployer})\n\n        (self.finalRouter, self.pauseRouter, self.contracts) = deployNotionalContracts(\n            self.deployer, \n            Comptroller=MAINNET[\"compound\"][\"comptroller\"],\n            RebalancingStrategy=self.rebalancingStrategy\n        )\n\n        self.patchFix = MigratePrimeCash.deploy(\n            self.proxy.getImplementation(),\n            self.pauseRouter.address,\n            self.proxy.address,\n            {\"from\": self.deployer}\n        )\n\n        self.owner = self.notional.owner()\n        self.pauseRouter = self.router.pauseRouter()\n        self.guardian = self.router.pauseGuardian()\n        self.multisig = \"0x02479BFC7Dce53A02e26fE7baea45a0852CB0909\"\n\n        self.tokens = {\n            'DAI': Contract.from_abi('DAI', CompoundConfig['DAI']['underlying'], MockERC20.abi),\n            'USDC': Contract.from_abi('USDC', CompoundConfig['USDC']['underlying'], MockERC20.abi),\n            'WBTC': Contract.from_abi('WBTC', CompoundConfig['WBTC']['underlying'], MockERC20.abi),\n            'cETH': Contract.from_abi('cETH', CompoundConfig['ETH']['cToken'], MockERC20.abi),\n            'cDAI': Contract.from_abi('cDAI', CompoundConfig['DAI']['cToken'], MockERC20.abi),\n            'cUSDC': Contract.from_abi('cUSDC', CompoundConfig['USDC']['cToken'], MockERC20.abi),\n            'cWBTC': Contract.from_abi('cWBTC', CompoundConfig['WBTC']['cToken'], MockERC20.abi),\n        }\n\n        # Deploys Prime Cash Oracles\n        self.pETH = CompoundV2HoldingsOracle.deploy([\n            self.notional,\n            CompoundConfig[\"ETH\"][\"underlying\"],\n            CompoundConfig[\"ETH\"][\"cToken\"],\n            self.notional.getCurrencyAndRates(1)[\"assetRate\"][\"rateOracle\"],\n        ], {\"from\": self.deployer})\n\n        self.pDAI = CompoundV2HoldingsOracle.deploy([\n            self.notional,\n            CompoundConfig[\"DAI\"][\"underlying\"],\n            CompoundConfig[\"DAI\"][\"cToken\"],\n            self.notional.getCurrencyAndRates(2)[\"assetRate\"][\"rateOracle\"]\n        ], {\"from\": self.deployer})\n\n        self.pUSDC = CompoundV2HoldingsOracle.deploy([\n            self.notional,\n            CompoundConfig[\"USDC\"][\"underlying\"],\n            CompoundConfig[\"USDC\"][\"cToken\"],\n            self.notional.getCurrencyAndRates(3)[\"assetRate\"][\"rateOracle\"],\n        ], {\"from\": self.deployer})\n\n        self.pWBTC = CompoundV2HoldingsOracle.deploy([\n            self.notional,\n            CompoundConfig[\"WBTC\"][\"underlying\"],\n            CompoundConfig[\"WBTC\"][\"cToken\"],\n            self.notional.getCurrencyAndRates(4)[\"assetRate\"][\"rateOracle\"],\n        ], {\"from\": self.deployer})\n\n        self.primeCashOracles = { 'ETH': self.pETH, 'DAI': self.pDAI, 'USDC': self.pUSDC, 'WBTC': self.pWBTC }\n\n    def setMigrationSettings(self):\n        # TODO: change these...\n        self.patchFix.setMigrationSettings(\n            1,\n            [\n                get_interest_rate_curve(),\n                self.primeCashOracles['ETH'],\n                12, # 60 min oracle rate window\n                True,\n                'ETH',\n                'Ether',\n                [\n                    get_interest_rate_curve(\n                        kinkUtilization1=15,\n                        kinkUtilization2=80,\n                        kinkRate1=21,\n                        kinkRate2=60,\n                        maxRate25BPS=120,\n                        feeRatePercent=8,\n                        minFeeRateBPS=0,\n                        maxFeeRateBPS=100,\n                    ),\n                    get_interest_rate_curve(\n                        kinkUtilization1=15,\n                        kinkUtilization2=80,\n                        kinkRate1=21,\n                        kinkRate2=56,\n                        maxRate25BPS=120,\n                        feeRatePercent=10,\n                        minFeeRateBPS=15,\n                        maxFeeRateBPS=100,\n                    ),\n                ],\n                []\n            ],\n            {\"from\": self.owner}\n        )\n\n        self.patchFix.setMigrationSettings(\n            2,\n            [\n                get_interest_rate_curve(),\n                self.primeCashOracles['DAI'],\n                12, # 60 min oracle rate window\n                True,\n                'DAI',\n                'Dai Stablecoin',\n                [get_interest_rate_curve(\n                    kinkUtilization1=15,\n                    kinkUtilization2=80,\n                    kinkRate1=21,\n                    kinkRate2=48,\n                    maxRate25BPS=120,\n                    feeRatePercent=10,\n                    minFeeRateBPS=15,\n                    maxFeeRateBPS=100,\n                )] * 3,\n                []\n            ],\n            {\"from\": self.owner}\n        )\n\n        self.patchFix.setMigrationSettings(\n            3,\n            [\n                get_interest_rate_curve(),\n                self.primeCashOracles['USDC'],\n                12, # 60 min oracle rate window\n                True,\n                'USDC',\n                'USD Coin',\n                [get_interest_rate_curve(\n                    kinkUtilization1=15,\n                    kinkUtilization2=80,\n                    kinkRate1=21,\n                    kinkRate2=48,\n                    maxRate25BPS=120,\n                    feeRatePercent=10,\n                    minFeeRateBPS=15,\n                    maxFeeRateBPS=100,\n                )] * 3,\n                []\n            ],\n            {\"from\": self.owner}\n        )\n\n        self.patchFix.setMigrationSettings(\n            4,\n            [\n                get_interest_rate_curve(),\n                self.primeCashOracles['WBTC'],\n                12, # 60 min oracle rate window\n                True,\n                'WBTC',\n                'Wrapped Bitcoin',\n                [get_interest_rate_curve(\n                    kinkUtilization1=15,\n                    kinkUtilization2=80,\n                    kinkRate1=21,\n                    kinkRate2=30,\n                    maxRate25BPS=80,\n                    feeRatePercent=10,\n                    minFeeRateBPS=15,\n                    maxFeeRateBPS=100,\n                )] * 2,\n                []\n            ],\n            {\"from\": self.owner}\n        )\n\n    def runMigrationPrerequisites(self):\n        # Settle all outstanding accounts\n        # Settle all negative cash balances\n        pass\n\n    def upgradeToV3(self):\n        self.runMigrationPrerequisites()\n        self.setMigrationSettings()\n\n        # TODO: this is not listed on the current router so we can't set it\n        # need to upgrade the router to include the missing one\n        # self.notional.setPauseRouterAndGuardian(self.pauseRouter, self.guardian, {\"from\": self.owner})\n        self.notional.transferOwnership(self.patchFix, False, {\"from\": self.owner})\n\n        # Pause Notional using the new pauseRouter that allows claimOwnership\n        # self.notional.upgradeTo(self.pauseRouter, {\"from\": self.guardian})\n\n        # Inside here we can update totalfCash debts if required\n        manager = accounts.at(\"0x02479BFC7Dce53A02e26fE7baea45a0852CB0909\", force=True)\n        self.patchFix.updateTotalfCashDebt(1, [\n            [1679616000, 1003407512775],\n            [1687392000, 201970086079]\n        ], {\"from\": manager})\n        self.patchFix.updateTotalfCashDebt(2, [\n            [1679616000, 1072883461002390],\n            [1687392000, 789570035516478],\n            [1695168000, 52008307749624],\n            [1702944000, 275220459188932]\n        ], {\"from\": manager})\n        self.patchFix.updateTotalfCashDebt(3, [\n            [1679616000, 1457772038632780],\n            [1687392000, 1162183350991920],\n            [1695168000, 32997025882811],\n            [1702944000, 576507718708683]\n        ], {\"from\": manager})\n        self.patchFix.updateTotalfCashDebt(4, [\n            [1679616000, 3539631484],\n            [1687392000, 1300752453]\n        ], {\"from\": manager})\n\n        # Call Upgrade Patch Fix\n        self.patchFix.atomicPatchAndUpgrade({\"from\": self.owner})\n\n        # At this point, Notional V3 is upgraded but paused\n        self.notional.upgradeTo(self.finalRouter, {\"from\": self.owner})"
    }
  ]
}