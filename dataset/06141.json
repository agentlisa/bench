{
  "Title": "[L-09] Setting `transactionExecutor` to `msg.sender` in `createProfile()` might limit functionality",
  "Content": "\nWhen `createProfile()` is called, the profile's follow module is initialized with `msg.sender` as its `transactionExecutor`:\n\n[ProfileLib.sol#L56-L61](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/ProfileLib.sol#L56-L61)\n\n```solidity\n            followModuleReturnData = _initFollowModule({\n                profileId: profileId,\n                transactionExecutor: msg.sender,\n                followModule: createProfileParams.followModule,\n                followModuleInitData: createProfileParams.followModuleInitData\n            });\n```\n\nThis could be extremely limiting if the follow module uses `transactionExecutor` during its initialization. \n\nFor example, consider a follow module that needs to be initialized with a certain amount of tokens:\n* If these tokens are transferred from `transactionExecutor`, the profile creator will bear the cost of the initialization. \n* If the profile's owner is meant to provide funds, he will have to transfer the tokens to the profile creator, which creates risk as he has to trust that the profile creator won't rug.\n\n### Recommendation\n\nConsider setting `transactionExecutor` to `createProfileParams.to` instead, which is the owner of the newly created profile:\n\n[ProfileLib.sol#L56-L61](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/ProfileLib.sol#L56-L61)\n\n```diff\n            followModuleReturnData = _initFollowModule({\n                profileId: profileId,\n-               transactionExecutor: msg.sender,\n+               transactionExecutor: createProfileParams.to,\n                followModule: createProfileParams.followModule,\n                followModuleInitData: createProfileParams.followModuleInitData\n            });\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/libraries/ProfileLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {Events} from 'contracts/libraries/constants/Events.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {IFollowModule} from 'contracts/interfaces/IFollowModule.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\n\nlibrary ProfileLib {\n    uint16 constant MAX_PROFILE_IMAGE_URI_LENGTH = 6000;\n\n    function ownerOf(uint256 profileId) internal view returns (address) {\n        address profileOwner = StorageLib.getTokenData(profileId).owner;\n        if (profileOwner == address(0)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return profileOwner;\n    }\n\n    function exists(uint256 profileId) internal view returns (bool) {\n        return StorageLib.getTokenData(profileId).owner != address(0);\n    }\n\n    /**\n     * @notice Creates a profile with the given parameters to the given address. Minting happens\n     * in the hub.\n     *\n     * @param createProfileParams The CreateProfileParams struct containing the following parameters:\n     *      to: The address receiving the profile.\n     *      imageURI: The URI to set for the profile image.\n     *      followModule: The follow module to use, can be the zero address.\n     *      followModuleInitData: The follow module initialization data, if any\n     * @param profileId The profile ID to associate with this profile NFT (token ID).\n     */\n    function createProfile(Types.CreateProfileParams calldata createProfileParams, uint256 profileId) external {\n        if (bytes(createProfileParams.imageURI).length > MAX_PROFILE_IMAGE_URI_LENGTH) {\n            revert Errors.ProfileImageURILengthInvalid();\n        }\n\n        Types.Profile storage _profile = StorageLib.getProfile(profileId);\n        _profile.imageURI = createProfileParams.imageURI;\n\n        bytes memory followModuleReturnData;\n        if (createProfileParams.followModule != address(0)) {\n            // Load the follow module to be used in the next assembly block.\n            address followModule = createProfileParams.followModule;\n\n            StorageLib.getProfile(profileId).followModule = followModule;\n\n            // We don't need to check for deprecated modules here because deprecated ones are no longer whitelisted.\n            // Initialize the follow module.\n            followModuleReturnData = _initFollowModule({\n                profileId: profileId,\n                transactionExecutor: msg.sender,\n                followModule: createProfileParams.followModule,\n                followModuleInitData: createProfileParams.followModuleInitData\n            });\n        }\n        emit Events.ProfileCreated(\n            profileId,\n            msg.sender,\n            createProfileParams.to,\n            createProfileParams.imageURI,\n            createProfileParams.followModule,\n            followModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Sets the profile image URI for a given profile.\n     *\n     * @param profileId The profile ID.\n     * @param imageURI The image URI to set.\n\n     */\n    function setProfileImageURI(uint256 profileId, string calldata imageURI) external {\n        _setProfileImageURI(profileId, imageURI);\n    }\n\n    /**\n     * @notice Sets the follow module for a given profile.\n     *\n     * @param profileId The profile ID to set the follow module for.\n     * @param followModule The follow module to set for the given profile, if any.\n     * @param followModuleInitData The data to pass to the follow module for profile initialization.\n     */\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external {\n        StorageLib.getProfile(profileId).followModule = followModule;\n        bytes memory followModuleReturnData;\n        if (followModule != address(0)) {\n            followModuleReturnData = _initFollowModule(profileId, msg.sender, followModule, followModuleInitData);\n        }\n        emit Events.FollowModuleSet(profileId, followModule, followModuleReturnData, block.timestamp);\n    }\n\n    function setProfileMetadataURI(uint256 profileId, string calldata metadataURI) external {\n        StorageLib.getProfile(profileId).metadataURI = metadataURI;\n        emit Events.ProfileMetadataSet(profileId, metadataURI, block.timestamp);\n    }\n\n    function _initFollowModule(\n        uint256 profileId,\n        address transactionExecutor,\n        address followModule,\n        bytes memory followModuleInitData\n    ) private returns (bytes memory) {\n        ValidationLib.validateFollowModuleWhitelisted(followModule);\n        return IFollowModule(followModule).initializeFollowModule(profileId, transactionExecutor, followModuleInitData);\n    }\n\n    function _setProfileImageURI(uint256 profileId, string calldata imageURI) private {\n        if (bytes(imageURI).length > MAX_PROFILE_IMAGE_URI_LENGTH) {\n            revert Errors.ProfileImageURILengthInvalid();\n        }\n        StorageLib.getProfile(profileId).imageURI = imageURI;\n        emit Events.ProfileImageURISet(profileId, imageURI, block.timestamp);\n    }\n\n    function setBlockStatus(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus\n    ) external {\n        if (idsOfProfilesToSetBlockStatus.length != blockStatus.length) {\n            revert Errors.ArrayMismatch();\n        }\n        address followNFT = StorageLib.getProfile(byProfileId).followNFT;\n        uint256 i;\n        uint256 idOfProfileToSetBlockStatus;\n        bool blockedStatus;\n        mapping(uint256 => bool) storage _blockedStatus = StorageLib.blockedStatus(byProfileId);\n        while (i < idsOfProfilesToSetBlockStatus.length) {\n            idOfProfileToSetBlockStatus = idsOfProfilesToSetBlockStatus[i];\n            ValidationLib.validateProfileExists(idOfProfileToSetBlockStatus);\n            if (byProfileId == idOfProfileToSetBlockStatus) {\n                revert Errors.SelfBlock();\n            }\n            blockedStatus = blockStatus[i];\n            if (followNFT != address(0) && blockedStatus) {\n                bool hasUnfollowed = IFollowNFT(followNFT).processBlock(idOfProfileToSetBlockStatus);\n                if (hasUnfollowed) {\n                    emit Events.Unfollowed(idOfProfileToSetBlockStatus, byProfileId, block.timestamp);\n                }\n            }\n            _blockedStatus[idOfProfileToSetBlockStatus] = blockedStatus;\n            if (blockedStatus) {\n                emit Events.Blocked(byProfileId, idOfProfileToSetBlockStatus, block.timestamp);\n            } else {\n                emit Events.Unblocked(byProfileId, idOfProfileToSetBlockStatus, block.timestamp);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function switchToNewFreshDelegatedExecutorsConfig(uint256 profileId) external {\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig({\n            delegatorProfileId: profileId\n        });\n        _changeDelegatedExecutorsConfig({\n            _delegatedExecutorsConfig: _delegatedExecutorsConfig,\n            delegatorProfileId: profileId,\n            delegatedExecutors: new address[](0),\n            approvals: new bool[](0),\n            configNumber: _delegatedExecutorsConfig.maxConfigNumberSet + 1,\n            switchToGivenConfig: true\n        });\n    }\n\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals\n    ) external {\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig(\n            delegatorProfileId\n        );\n        _changeDelegatedExecutorsConfig(\n            _delegatedExecutorsConfig,\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            _delegatedExecutorsConfig.configNumber,\n            false\n        );\n    }\n\n    function changeGivenDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external {\n        _changeDelegatedExecutorsConfig(\n            StorageLib.getDelegatedExecutorsConfig(delegatorProfileId),\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    function isExecutorApproved(uint256 delegatorProfileId, address delegatedExecutor) external view returns (bool) {\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig(\n            delegatorProfileId\n        );\n        return _delegatedExecutorsConfig.isApproved[_delegatedExecutorsConfig.configNumber][delegatedExecutor];\n    }\n\n    function _changeDelegatedExecutorsConfig(\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig,\n        uint256 delegatorProfileId,\n        address[] memory delegatedExecutors,\n        bool[] memory approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) private {\n        if (delegatedExecutors.length != approvals.length) {\n            revert Errors.ArrayMismatch();\n        }\n        bool configSwitched = _prepareStorageToApplyChangesUnderGivenConfig(\n            _delegatedExecutorsConfig,\n            configNumber,\n            switchToGivenConfig\n        );\n        uint256 i;\n        while (i < delegatedExecutors.length) {\n            _delegatedExecutorsConfig.isApproved[configNumber][delegatedExecutors[i]] = approvals[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit Events.DelegatedExecutorsConfigChanged(\n            delegatorProfileId,\n            configNumber,\n            delegatedExecutors,\n            approvals,\n            configSwitched,\n            block.timestamp\n        );\n    }\n\n    function _prepareStorageToApplyChangesUnderGivenConfig(\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) private returns (bool) {\n        uint64 nextAvailableConfigNumber = _delegatedExecutorsConfig.maxConfigNumberSet + 1;\n        if (configNumber > nextAvailableConfigNumber) {\n            revert Errors.InvalidParameter();\n        }\n        bool configSwitched;\n        if (configNumber == nextAvailableConfigNumber) {\n            // The next configuration available is being changed, it must be marked.\n            // Otherwise, on a profile transfer, the next owner can inherit a used/dirty configuration.\n            _delegatedExecutorsConfig.maxConfigNumberSet = nextAvailableConfigNumber;\n            configSwitched = switchToGivenConfig;\n            if (configSwitched) {\n                // The configuration is being switched, previous and current configuration numbers must be updated.\n                _delegatedExecutorsConfig.prevConfigNumber = _delegatedExecutorsConfig.configNumber;\n                _delegatedExecutorsConfig.configNumber = nextAvailableConfigNumber;\n            }\n        } else {\n            // The configuration corresponding to the given number is not a fresh/clean one.\n            uint64 currentConfigNumber = _delegatedExecutorsConfig.configNumber;\n            // If the given configuration matches the one that is already in use, we keep `configSwitched` as `false`.\n            if (configNumber != currentConfigNumber) {\n                configSwitched = switchToGivenConfig;\n            }\n            if (configSwitched) {\n                // The configuration is being switched, previous and current configuration numbers must be updated.\n                _delegatedExecutorsConfig.prevConfigNumber = currentConfigNumber;\n                _delegatedExecutorsConfig.configNumber = configNumber;\n            }\n        }\n        return configSwitched;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/ProfileLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {Events} from 'contracts/libraries/constants/Events.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {IFollowModule} from 'contracts/interfaces/IFollowModule.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\n\nlibrary ProfileLib {\n    uint16 constant MAX_PROFILE_IMAGE_URI_LENGTH = 6000;\n\n    function ownerOf(uint256 profileId) internal view returns (address) {\n        address profileOwner = StorageLib.getTokenData(profileId).owner;\n        if (profileOwner == address(0)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return profileOwner;\n    }\n\n    function exists(uint256 profileId) internal view returns (bool) {\n        return StorageLib.getTokenData(profileId).owner != address(0);\n    }\n\n    /**\n     * @notice Creates a profile with the given parameters to the given address. Minting happens\n     * in the hub.\n     *\n     * @param createProfileParams The CreateProfileParams struct containing the following parameters:\n     *      to: The address receiving the profile.\n     *      imageURI: The URI to set for the profile image.\n     *      followModule: The follow module to use, can be the zero address.\n     *      followModuleInitData: The follow module initialization data, if any\n     * @param profileId The profile ID to associate with this profile NFT (token ID).\n     */\n    function createProfile(Types.CreateProfileParams calldata createProfileParams, uint256 profileId) external {\n        if (bytes(createProfileParams.imageURI).length > MAX_PROFILE_IMAGE_URI_LENGTH) {\n            revert Errors.ProfileImageURILengthInvalid();\n        }\n\n        Types.Profile storage _profile = StorageLib.getProfile(profileId);\n        _profile.imageURI = createProfileParams.imageURI;\n\n        bytes memory followModuleReturnData;\n        if (createProfileParams.followModule != address(0)) {\n            // Load the follow module to be used in the next assembly block.\n            address followModule = createProfileParams.followModule;\n\n            StorageLib.getProfile(profileId).followModule = followModule;\n\n            // We don't need to check for deprecated modules here because deprecated ones are no longer whitelisted.\n            // Initialize the follow module.\n            followModuleReturnData = _initFollowModule({\n                profileId: profileId,\n                transactionExecutor: msg.sender,\n                followModule: createProfileParams.followModule,\n                followModuleInitData: createProfileParams.followModuleInitData\n            });\n        }\n        emit Events.ProfileCreated(\n            profileId,\n            msg.sender,\n            createProfileParams.to,\n            createProfileParams.imageURI,\n            createProfileParams.followModule,\n            followModuleReturnData,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Sets the profile image URI for a given profile.\n     *\n     * @param profileId The profile ID.\n     * @param imageURI The image URI to set.\n\n     */\n    function setProfileImageURI(uint256 profileId, string calldata imageURI) external {\n        _setProfileImageURI(profileId, imageURI);\n    }\n\n    /**\n     * @notice Sets the follow module for a given profile.\n     *\n     * @param profileId The profile ID to set the follow module for.\n     * @param followModule The follow module to set for the given profile, if any.\n     * @param followModuleInitData The data to pass to the follow module for profile initialization.\n     */\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external {\n        StorageLib.getProfile(profileId).followModule = followModule;\n        bytes memory followModuleReturnData;\n        if (followModule != address(0)) {\n            followModuleReturnData = _initFollowModule(profileId, msg.sender, followModule, followModuleInitData);\n        }\n        emit Events.FollowModuleSet(profileId, followModule, followModuleReturnData, block.timestamp);\n    }\n\n    function setProfileMetadataURI(uint256 profileId, string calldata metadataURI) external {\n        StorageLib.getProfile(profileId).metadataURI = metadataURI;\n        emit Events.ProfileMetadataSet(profileId, metadataURI, block.timestamp);\n    }\n\n    function _initFollowModule(\n        uint256 profileId,\n        address transactionExecutor,\n        address followModule,\n        bytes memory followModuleInitData\n    ) private returns (bytes memory) {\n        ValidationLib.validateFollowModuleWhitelisted(followModule);\n        return IFollowModule(followModule).initializeFollowModule(profileId, transactionExecutor, followModuleInitData);\n    }\n\n    function _setProfileImageURI(uint256 profileId, string calldata imageURI) private {\n        if (bytes(imageURI).length > MAX_PROFILE_IMAGE_URI_LENGTH) {\n            revert Errors.ProfileImageURILengthInvalid();\n        }\n        StorageLib.getProfile(profileId).imageURI = imageURI;\n        emit Events.ProfileImageURISet(profileId, imageURI, block.timestamp);\n    }\n\n    function setBlockStatus(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus\n    ) external {\n        if (idsOfProfilesToSetBlockStatus.length != blockStatus.length) {\n            revert Errors.ArrayMismatch();\n        }\n        address followNFT = StorageLib.getProfile(byProfileId).followNFT;\n        uint256 i;\n        uint256 idOfProfileToSetBlockStatus;\n        bool blockedStatus;\n        mapping(uint256 => bool) storage _blockedStatus = StorageLib.blockedStatus(byProfileId);\n        while (i < idsOfProfilesToSetBlockStatus.length) {\n            idOfProfileToSetBlockStatus = idsOfProfilesToSetBlockStatus[i];\n            ValidationLib.validateProfileExists(idOfProfileToSetBlockStatus);\n            if (byProfileId == idOfProfileToSetBlockStatus) {\n                revert Errors.SelfBlock();\n            }\n            blockedStatus = blockStatus[i];\n            if (followNFT != address(0) && blockedStatus) {\n                bool hasUnfollowed = IFollowNFT(followNFT).processBlock(idOfProfileToSetBlockStatus);\n                if (hasUnfollowed) {\n                    emit Events.Unfollowed(idOfProfileToSetBlockStatus, byProfileId, block.timestamp);\n                }\n            }\n            _blockedStatus[idOfProfileToSetBlockStatus] = blockedStatus;\n            if (blockedStatus) {\n                emit Events.Blocked(byProfileId, idOfProfileToSetBlockStatus, block.timestamp);\n            } else {\n                emit Events.Unblocked(byProfileId, idOfProfileToSetBlockStatus, block.timestamp);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function switchToNewFreshDelegatedExecutorsConfig(uint256 profileId) external {\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig({\n            delegatorProfileId: profileId\n        });\n        _changeDelegatedExecutorsConfig({\n            _delegatedExecutorsConfig: _delegatedExecutorsConfig,\n            delegatorProfileId: profileId,\n            delegatedExecutors: new address[](0),\n            approvals: new bool[](0),\n            configNumber: _delegatedExecutorsConfig.maxConfigNumberSet + 1,\n            switchToGivenConfig: true\n        });\n    }\n\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals\n    ) external {\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig(\n            delegatorProfileId\n        );\n        _changeDelegatedExecutorsConfig(\n            _delegatedExecutorsConfig,\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            _delegatedExecutorsConfig.configNumber,\n            false\n        );\n    }\n\n    function changeGivenDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external {\n        _changeDelegatedExecutorsConfig(\n            StorageLib.getDelegatedExecutorsConfig(delegatorProfileId),\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    function isExecutorApproved(uint256 delegatorProfileId, address delegatedExecutor) external view returns (bool) {\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig(\n            delegatorProfileId\n        );\n        return _delegatedExecutorsConfig.isApproved[_delegatedExecutorsConfig.configNumber][delegatedExecutor];\n    }\n\n    function _changeDelegatedExecutorsConfig(\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig,\n        uint256 delegatorProfileId,\n        address[] memory delegatedExecutors,\n        bool[] memory approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) private {\n        if (delegatedExecutors.length != approvals.length) {\n            revert Errors.ArrayMismatch();\n        }\n        bool configSwitched = _prepareStorageToApplyChangesUnderGivenConfig(\n            _delegatedExecutorsConfig,\n            configNumber,\n            switchToGivenConfig\n        );\n        uint256 i;\n        while (i < delegatedExecutors.length) {\n            _delegatedExecutorsConfig.isApproved[configNumber][delegatedExecutors[i]] = approvals[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit Events.DelegatedExecutorsConfigChanged(\n            delegatorProfileId,\n            configNumber,\n            delegatedExecutors,\n            approvals,\n            configSwitched,\n            block.timestamp\n        );\n    }\n\n    function _prepareStorageToApplyChangesUnderGivenConfig(\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) private returns (bool) {\n        uint64 nextAvailableConfigNumber = _delegatedExecutorsConfig.maxConfigNumberSet + 1;\n        if (configNumber > nextAvailableConfigNumber) {\n            revert Errors.InvalidParameter();\n        }\n        bool configSwitched;\n        if (configNumber == nextAvailableConfigNumber) {\n            // The next configuration available is being changed, it must be marked.\n            // Otherwise, on a profile transfer, the next owner can inherit a used/dirty configuration.\n            _delegatedExecutorsConfig.maxConfigNumberSet = nextAvailableConfigNumber;\n            configSwitched = switchToGivenConfig;\n            if (configSwitched) {\n                // The configuration is being switched, previous and current configuration numbers must be updated.\n                _delegatedExecutorsConfig.prevConfigNumber = _delegatedExecutorsConfig.configNumber;\n                _delegatedExecutorsConfig.configNumber = nextAvailableConfigNumber;\n            }\n        } else {\n            // The configuration corresponding to the given number is not a fresh/clean one.\n            uint64 currentConfigNumber = _delegatedExecutorsConfig.configNumber;\n            // If the given configuration matches the one that is already in use, we keep `configSwitched` as `false`.\n            if (configNumber != currentConfigNumber) {\n                configSwitched = switchToGivenConfig;\n            }\n            if (configSwitched) {\n                // The configuration is being switched, previous and current configuration numbers must be updated.\n                _delegatedExecutorsConfig.prevConfigNumber = currentConfigNumber;\n                _delegatedExecutorsConfig.configNumber = configNumber;\n            }\n        }\n        return configSwitched;\n    }\n}"
    }
  ]
}