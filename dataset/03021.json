{
  "Title": "H-3: CTokenOracle.sol#getCErc20Price contains critical math error",
  "Content": "# Issue H-3: CTokenOracle.sol#getCErc20Price contains critical math error \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/021-H \n## Found by \n0x52\n\n## Summary\n\nCTokenOracle.sol#getCErc20Price contains a math error that immensely overvalues CTokens\n\n## Vulnerability Detail\n\n[CTokenOracle.sol#L66-L76](https://github.com/sentimentxyz/oracle/blob/59b26a3d8c295208437aad36c470386c9729a4bc/src/compound/CTokenOracle.sol#L66-L76)\n\n    function getCErc20Price(ICToken cToken, address underlying) internal view returns (uint) {\n        /*\n            cToken Exchange rates are scaled by 10^(18 - 8 + underlying token decimals) so to scale\n            the exchange rate to 18 decimals we must multiply it by 1e8 and then divide it by the\n            number of decimals in the underlying token. Finally to find the price of the cToken we\n            must multiply this value with the current price of the underlying token\n        */\n        return cToken.exchangeRateStored()\n        .mulDivDown(1e8 , IERC20(underlying).decimals())\n        .mulWadDown(oracle.getPrice(underlying));\n    }\n\nIn L74, IERC20(underlying).decimals() is not raised to the power of 10. The results in the price of the LP being overvalued by many order of magnitudes. A user could deposit one CToken and drain the reserves of every liquidity pool.\n\n## Impact\n\nAll lenders could be drained of all their funds due to excessive over valuation of CTokens cause by this error\n\n## Code Snippet\n\n[CTokenOracle.sol#L66-L76](https://github.com/sentimentxyz/oracle/blob/59b26a3d8c295208437aad36c470386c9729a4bc/src/compound/CTokenOracle.sol#L66-L76)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFix the math error by changing L74:\n\n    return cToken.exchangeRateStored()\n    .mulDivDown(1e8 , 10 ** IERC20(underlying).decimals())\n    .mulWadDown(oracle.getPrice(underlying));\n       \n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/oracle/pull/43).\n\n## Lead Senior Watson\nConfirmed fix. \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "src/compound/CTokenOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {ICToken} from \"./ICToken.sol\";\nimport {IERC20} from \"../utils/IERC20.sol\";\nimport {IOracle} from \"../core/IOracle.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n/**\n    @title Compound cToken oracle\n    @notice Price oracle for cToken\n*/\ncontract CTokenOracle is IOracle {\n    using FixedPointMathLib for uint;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Oracle Facade\n    IOracle public immutable oracle;\n\n    /// @notice cEther\n    address public immutable cETHER;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract constructor\n        @param _oracle Oracle Facade\n        @param _cETHER cEther\n    */\n    constructor(IOracle _oracle, address _cETHER) {\n        oracle = _oracle;\n        cETHER = _cETHER;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IOracle\n    function getPrice(address token) external view returns (uint) {\n        return (token == cETHER) ?\n            getCEtherPrice() :\n            getCErc20Price(ICToken(token), ICToken(token).underlying());\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function getCEtherPrice() internal view returns (uint) {\n        /*\n            cToken Exchange rates are scaled by 10^(18 - 8 + underlying token decimals) which comes\n            out to 28 decimals for cEther. We must divide the exchange rate by 1e10 to scale it to\n            18 decimals. Finally we multiply this with the price of the underlying token, in this\n            case the price of ETH - 1e18. In the implementation below we combine these two ops and\n            thus the cEther price can be computed as --\n            exchangeRateStored() / 1e10 * 1e18 = exchangeRateStored * 1e8\n        */\n        return ICToken(cETHER).exchangeRateStored().mulWadDown(1e8);\n    }\n\n    function getCErc20Price(ICToken cToken, address underlying) internal view returns (uint) {\n        /*\n            cToken Exchange rates are scaled by 10^(18 - 8 + underlying token decimals) so to scale\n            the exchange rate to 18 decimals we must multiply it by 1e8 and then divide it by the\n            number of decimals in the underlying token. Finally to find the price of the cToken we\n            must multiply this value with the current price of the underlying token\n        */\n        return cToken.exchangeRateStored()\n        .mulDivDown(1e8 , IERC20(underlying).decimals())\n        .mulWadDown(oracle.getPrice(underlying));\n    }\n}"
    },
    {
      "filename": "src/compound/CTokenOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {ICToken} from \"./ICToken.sol\";\nimport {IERC20} from \"../utils/IERC20.sol\";\nimport {IOracle} from \"../core/IOracle.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n/**\n    @title Compound cToken oracle\n    @notice Price oracle for cToken\n*/\ncontract CTokenOracle is IOracle {\n    using FixedPointMathLib for uint;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Oracle Facade\n    IOracle public immutable oracle;\n\n    /// @notice cEther\n    address public immutable cETHER;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract constructor\n        @param _oracle Oracle Facade\n        @param _cETHER cEther\n    */\n    constructor(IOracle _oracle, address _cETHER) {\n        oracle = _oracle;\n        cETHER = _cETHER;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IOracle\n    function getPrice(address token) external view returns (uint) {\n        return (token == cETHER) ?\n            getCEtherPrice() :\n            getCErc20Price(ICToken(token), ICToken(token).underlying());\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function getCEtherPrice() internal view returns (uint) {\n        /*\n            cToken Exchange rates are scaled by 10^(18 - 8 + underlying token decimals) which comes\n            out to 28 decimals for cEther. We must divide the exchange rate by 1e10 to scale it to\n            18 decimals. Finally we multiply this with the price of the underlying token, in this\n            case the price of ETH - 1e18. In the implementation below we combine these two ops and\n            thus the cEther price can be computed as --\n            exchangeRateStored() / 1e10 * 1e18 = exchangeRateStored * 1e8\n        */\n        return ICToken(cETHER).exchangeRateStored().mulWadDown(1e8);\n    }\n\n    function getCErc20Price(ICToken cToken, address underlying) internal view returns (uint) {\n        /*\n            cToken Exchange rates are scaled by 10^(18 - 8 + underlying token decimals) so to scale\n            the exchange rate to 18 decimals we must multiply it by 1e8 and then divide it by the\n            number of decimals in the underlying token. Finally to find the price of the cToken we\n            must multiply this value with the current price of the underlying token\n        */\n        return cToken.exchangeRateStored()\n        .mulDivDown(1e8 , IERC20(underlying).decimals())\n        .mulWadDown(oracle.getPrice(underlying));\n    }\n}"
    }
  ]
}