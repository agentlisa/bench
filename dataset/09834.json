{
  "Title": "[M-08] Unbonding validator random selection can be predicted",
  "Content": "\nWhen unbonding, the `pick_validator` function is supposed to choose a random validator to unstake from.<br>\nHowever, this randomness can be predicted knowing the block height which is very easy to predict.\n\n```rust\nlet mut iteration_index = 0;\n\nwhile claimed.u128() > 0 {\n    let mut rng = XorShiftRng::seed_from_u64(block_height + iteration_index);\n    let random_index = rng.gen_range(0, deletable_delegations.len());\n    // ...\n}\n```\n\nAs validators are paid rewards proportional to their stake, choosing where to bond and unbond from directly impacts validator rewards.<br>\nCombined with being able to choose the validator when bonding (see [`execute_bond`](https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bAsset-contracts/contracts/anchor_basset_hub/src/bond.rs#L15)) a validator can steal rewards and increase their own.\n\n### Proof of Concept\n\n1.  Validator A wishes to increase their rewards. They call ` execute_bond(, validator = A)  ` with their validator.\n2.  Validator A precomputes the randomness for unbonding if the block was mined at the next block height. If it's a different validator, they call `unbond`. The stake is removed from some other validator and the user receives it back. Note that validator A's stake did not decrease and contains the initial bond amount.\n3.  They repeat this process until every single bond of the Anchor platform is now staked to validator A and they earn huge rewards while everyone else does not earn anything from Anchor bonds anymore.\n\n### Recommended Mitigation Steps\n\nAn `unbond` must always remove stake from the validator the stake was originally bonded to, otherwise, it's exploitable by the attack above.<br>\nConsider keeping track of all bonds with a `bond_id` and create a map of `bond_id -> validator`.<br>\nIf a validator's stake decreased due to slashing, take the remaining unstake amount proportionally from all other validators.<br>\n\n**[bitn8 (Anchor) disagreed with severity](https://github.com/code-423n4/2022-02-anchor-findings/issues/29)**\n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/29#issuecomment-1207282803):**\n > Looks like weak RNG, Medium or High seem proper.\n\n**[Albert Chon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/29#issuecomment-1251643195):**\n > Indeed, block height should definitely not be used as a source of randomness. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/anchor-bAsset-contracts/contracts/anchor_basset_hub/src/bond.rs",
      "content": "use crate::contract::{query_total_issued, slashing};\nuse crate::math::decimal_division;\nuse crate::state::{is_valid_validator, CONFIG, CURRENT_BATCH, PARAMETERS, STATE};\nuse basset::hub::State;\nuse cosmwasm_std::{\n    attr, to_binary, CosmosMsg, DepsMut, Env, MessageInfo, Response, StakingMsg, StdError,\n    StdResult, Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\npub fn execute_bond(\n    mut deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    validator: String,\n) -> StdResult<Response> {\n    // validator must be whitelisted\n    let is_valid = is_valid_validator(deps.storage, validator.clone())?;\n    if !is_valid {\n        return Err(StdError::generic_err(\n            \"The chosen validator is currently not supported\",\n        ));\n    }\n\n    let params = PARAMETERS.load(deps.storage)?;\n    let coin_denom = params.underlying_coin_denom;\n    let threshold = params.er_threshold;\n    let recovery_fee = params.peg_recovery_fee;\n\n    // current batch requested fee is need for accurate exchange rate computation.\n    let current_batch = CURRENT_BATCH.load(deps.storage)?;\n    let requested_with_fee = current_batch.requested_with_fee;\n\n    // coin must have be sent along with transaction and it should be in underlying coin denom\n    if info.funds.len() > 1usize {\n        return Err(StdError::generic_err(\n            \"More than one coin is sent; only one asset is supported\",\n        ));\n    }\n\n    let payment = info\n        .funds\n        .iter()\n        .find(|x| x.denom == coin_denom && x.amount > Uint128::zero())\n        .ok_or_else(|| {\n            StdError::generic_err(format!(\"No {} assets are provided to bond\", coin_denom))\n        })?;\n\n    // check slashing\n    slashing(&mut deps, env)?;\n\n    let state = STATE.load(deps.storage)?;\n    let sender = info.sender;\n\n    // get the total supply\n    let mut total_supply = query_total_issued(deps.as_ref()).unwrap_or_default();\n\n    // peg recovery fee should be considered\n    let mint_amount = decimal_division(payment.amount, state.exchange_rate);\n    let mut mint_amount_with_fee = mint_amount;\n    if state.exchange_rate < threshold {\n        let max_peg_fee = mint_amount * recovery_fee;\n        let required_peg_fee = ((total_supply + mint_amount + current_batch.requested_with_fee)\n            .checked_sub(state.total_bond_amount + payment.amount))?;\n        let peg_fee = Uint128::min(max_peg_fee, required_peg_fee);\n        mint_amount_with_fee = (mint_amount.checked_sub(peg_fee))?;\n    }\n\n    // total supply should be updated for exchange rate calculation.\n    total_supply += mint_amount_with_fee;\n\n    // exchange rate should be updated for future\n    STATE.update(deps.storage, |mut prev_state| -> StdResult<State> {\n        prev_state.total_bond_amount += payment.amount;\n        prev_state.update_exchange_rate(total_supply, requested_with_fee);\n        Ok(prev_state)\n    })?;\n\n    let mut messages: Vec<CosmosMsg> = vec![\n        // send the delegate message\n        CosmosMsg::Staking(StakingMsg::Delegate {\n            validator,\n            amount: payment.clone(),\n        }),\n    ];\n\n    // issue the basset token for sender\n    let mint_msg = Cw20ExecuteMsg::Mint {\n        recipient: sender.to_string(),\n        amount: mint_amount_with_fee,\n    };\n\n    let config = CONFIG.load(deps.storage)?;\n    let token_address = deps\n        .api\n        .addr_humanize(\n            &config\n                .token_contract\n                .expect(\"the token contract must have been registered\"),\n        )?\n        .to_string();\n\n    messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: token_address,\n        msg: to_binary(&mint_msg)?,\n        funds: vec![],\n    }));\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"mint\"),\n        attr(\"from\", sender),\n        attr(\"bonded\", payment.amount),\n        attr(\"minted\", mint_amount_with_fee),\n    ]))\n}"
    }
  ]
}