{
  "Title": "Immutable gas limit within `WormholeTransceiver` can lead to execution failures on the target chain",
  "Content": "**Description:** The Wormhole-specific Transceiver implementation uses an immutable [`gasLimit`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/Transceiver/WormholeTransceiver/WormholeTransceiverState.sol#L27) variable to calculate the Relayer delivery price. The underlying assumption here is that the gas consumed for transfers will always be static; however, this is not always the case, especially for L2 rollups such as Arbitrum, where gas is calculated as a function of the actual gas consumed on L2 and the L1 calldata cost that is effectively an L2 view of the L1 gas price. Please refer to the [Arbitrum docs](https://docs.arbitrum.io/inside-arbitrum-nitro#gas-and-fees) for more information on how gas is estimated.\n\nIn cases where L2 gas depends on the L1 gas price, extreme scenarios can occur where the delivery cost computed by the static gas limit is insufficient to execute a transfer on L2.\n\n**Impact:** An immutable gas limit can give an extremely stale view of the L2 gas needed to execute a transfer. In extreme scenarios, such stale gas estimates can be insufficient to execute messages on a target chain. If such a scenario occurs, all pending messages with a stale gas estimate will risk being stuck on the target chain. While the gas limit can be changed via an upgrade, there are two issues with this approach:\n1. Synchronizing a mass update across a large number of `NttManager` contracts might be difficult to execute.\n2. Changing the gas limit has no impact on pending transfers that are already ready for execution on the target chain.\n\n**Recommended Mitigation:** Consider making the gas limit mutable. If necessary, NTT Managers can keep track of L1 gas prices and change the gas limits accordingly.\n\n**Wormhole Foundation:** This failure case can be handled by requesting redelivery with a higher gas limit. The current logic is the same as we use in our automatic relayers and we are ok with the current limitations of this design.\n\n**Cyfrin:** Acknowledged.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/Transceiver/WormholeTransceiver/WormholeTransceiverState.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"wormhole-solidity-sdk/WormholeRelayerSDK.sol\";\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\nimport \"wormhole-solidity-sdk/interfaces/IWormhole.sol\";\n\nimport \"../../libraries/TransceiverHelpers.sol\";\nimport \"../../libraries/TransceiverStructs.sol\";\n\nimport \"../../interfaces/IWormholeTransceiver.sol\";\nimport \"../../interfaces/IWormholeTransceiverState.sol\";\nimport \"../../interfaces/ISpecialRelayer.sol\";\nimport \"../../interfaces/INttManager.sol\";\n\nimport \"../Transceiver.sol\";\n\nabstract contract WormholeTransceiverState is IWormholeTransceiverState, Transceiver {\n    using BytesParsing for bytes;\n\n    // ==================== Immutables ===============================================\n    uint8 public immutable consistencyLevel;\n    IWormhole public immutable wormhole;\n    IWormholeRelayer public immutable wormholeRelayer;\n    ISpecialRelayer public immutable specialRelayer;\n    uint256 immutable wormholeTransceiver_evmChainId;\n    uint256 public immutable gasLimit;\n\n    // ==================== Constants ================================================\n\n    /// @dev Prefix for all TransceiverMessage payloads\n    ///      This is 0x99'E''W''H'\n    /// @notice Magic string (constant value set by messaging provider) that idenfies the payload as an transceiver-emitted payload.\n    ///         Note that this is not a security critical field. It's meant to be used by messaging providers to identify which messages are Transceiver-related.\n    bytes4 constant WH_TRANSCEIVER_PAYLOAD_PREFIX = 0x9945FF10;\n\n    /// @dev Prefix for all Wormhole transceiver initialisation payloads\n    ///      This is bytes4(keccak256(\"WormholeTransceiverInit\"))\n    bytes4 constant WH_TRANSCEIVER_INIT_PREFIX = 0x9c23bd3b;\n\n    /// @dev Prefix for all Wormhole peer registration payloads\n    ///      This is bytes4(keccak256(\"WormholePeerRegistration\"))\n    bytes4 constant WH_PEER_REGISTRATION_PREFIX = 0x18fc67c2;\n\n    constructor(\n        address nttManager,\n        address wormholeCoreBridge,\n        address wormholeRelayerAddr,\n        address specialRelayerAddr,\n        uint8 _consistencyLevel,\n        uint256 _gasLimit\n    ) Transceiver(nttManager) {\n        wormhole = IWormhole(wormholeCoreBridge);\n        wormholeRelayer = IWormholeRelayer(wormholeRelayerAddr);\n        specialRelayer = ISpecialRelayer(specialRelayerAddr);\n        wormholeTransceiver_evmChainId = block.chainid;\n        consistencyLevel = _consistencyLevel;\n        gasLimit = _gasLimit;\n    }\n\n    enum RelayingType {\n        Standard,\n        Special,\n        Manual\n    }\n\n    function _initialize() internal override {\n        super._initialize();\n        _initializeTransceiver();\n    }\n\n    function _initializeTransceiver() internal {\n        TransceiverStructs.TransceiverInit memory init = TransceiverStructs.TransceiverInit({\n            transceiverIdentifier: WH_TRANSCEIVER_INIT_PREFIX,\n            nttManagerAddress: toWormholeFormat(nttManager),\n            nttManagerMode: INttManager(nttManager).getMode(),\n            tokenAddress: toWormholeFormat(nttManagerToken),\n            tokenDecimals: INttManager(nttManager).tokenDecimals()\n        });\n        wormhole.publishMessage(0, TransceiverStructs.encodeTransceiverInit(init), consistencyLevel);\n    }\n\n    function _checkImmutables() internal view override {\n        super._checkImmutables();\n        assert(this.wormhole() == wormhole);\n        assert(this.wormholeRelayer() == wormholeRelayer);\n        assert(this.specialRelayer() == specialRelayer);\n        assert(this.consistencyLevel() == consistencyLevel);\n    }\n\n    // =============== Storage ===============================================\n\n    bytes32 private constant WORMHOLE_CONSUMED_VAAS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.consumedVAAs\")) - 1);\n\n    bytes32 private constant WORMHOLE_PEERS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.peers\")) - 1);\n\n    bytes32 private constant WORMHOLE_RELAYING_ENABLED_CHAINS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.relayingEnabledChains\")) - 1);\n\n    bytes32 private constant SPECIAL_RELAYING_ENABLED_CHAINS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.specialRelayingEnabledChains\")) - 1);\n\n    bytes32 private constant WORMHOLE_EVM_CHAIN_IDS =\n        bytes32(uint256(keccak256(\"whTransceiver.evmChainIds\")) - 1);\n\n    // =============== Storage Setters/Getters ========================================\n\n    function _getWormholeConsumedVAAsStorage()\n        internal\n        pure\n        returns (mapping(bytes32 => bool) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_CONSUMED_VAAS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getWormholePeersStorage()\n        internal\n        pure\n        returns (mapping(uint16 => bytes32) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_PEERS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getWormholeRelayingEnabledChainsStorage()\n        internal\n        pure\n        returns (mapping(uint16 => uint256) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_RELAYING_ENABLED_CHAINS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getSpecialRelayingEnabledChainsStorage()\n        internal\n        pure\n        returns (mapping(uint16 => uint256) storage $)\n    {\n        uint256 slot = uint256(SPECIAL_RELAYING_ENABLED_CHAINS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getWormholeEvmChainIdsStorage()\n        internal\n        pure\n        returns (mapping(uint16 => uint256) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_EVM_CHAIN_IDS);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    // =============== Public Getters ======================================================\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isVAAConsumed(bytes32 hash) public view returns (bool) {\n        return _getWormholeConsumedVAAsStorage()[hash];\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function getWormholePeer(uint16 chainId) public view returns (bytes32) {\n        return _getWormholePeersStorage()[chainId];\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isWormholeRelayingEnabled(uint16 chainId) public view returns (bool) {\n        return toBool(_getWormholeRelayingEnabledChainsStorage()[chainId]);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isSpecialRelayingEnabled(uint16 chainId) public view returns (bool) {\n        return toBool(_getSpecialRelayingEnabledChainsStorage()[chainId]);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isWormholeEvmChain(uint16 chainId) public view returns (bool) {\n        return toBool(_getWormholeEvmChainIdsStorage()[chainId]);\n    }\n\n    // =============== Admin ===============================================================\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setWormholePeer(uint16 peerChainId, bytes32 peerContract) external onlyOwner {\n        if (peerChainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        if (peerContract == bytes32(0)) {\n            revert InvalidWormholePeerZeroAddress();\n        }\n\n        bytes32 oldPeerContract = _getWormholePeersStorage()[peerChainId];\n\n        // We don't want to allow updating a peer since this adds complexity in the accountant\n        // If the owner makes a mistake with peer registration they should deploy a new Wormhole\n        // transceiver and register this new transceiver with the NttManager\n        if (oldPeerContract != bytes32(0)) {\n            revert PeerAlreadySet(peerChainId, oldPeerContract);\n        }\n\n        _getWormholePeersStorage()[peerChainId] = peerContract;\n\n        // Publish a message for this transceiver registration\n        TransceiverStructs.TransceiverRegistration memory registration = TransceiverStructs\n            .TransceiverRegistration({\n            transceiverIdentifier: WH_PEER_REGISTRATION_PREFIX,\n            transceiverChainId: peerChainId,\n            transceiverAddress: peerContract\n        });\n        wormhole.publishMessage(\n            0, TransceiverStructs.encodeTransceiverRegistration(registration), consistencyLevel\n        );\n\n        emit SetWormholePeer(peerChainId, peerContract);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setIsWormholeEvmChain(uint16 chainId) external onlyOwner {\n        if (chainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        _getWormholeEvmChainIdsStorage()[chainId] = TRUE;\n\n        emit SetIsWormholeEvmChain(chainId);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setIsWormholeRelayingEnabled(uint16 chainId, bool isEnabled) external onlyOwner {\n        if (chainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        _getWormholeRelayingEnabledChainsStorage()[chainId] = toWord(isEnabled);\n\n        emit SetIsWormholeRelayingEnabled(chainId, isEnabled);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setIsSpecialRelayingEnabled(uint16 chainId, bool isEnabled) external onlyOwner {\n        if (chainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        _getSpecialRelayingEnabledChainsStorage()[chainId] = toWord(isEnabled);\n\n        emit SetIsSpecialRelayingEnabled(chainId, isEnabled);\n    }\n\n    // ============= Internal ===============================================================\n\n    function _checkInvalidRelayingConfig(uint16 chainId) internal view returns (bool) {\n        return isWormholeRelayingEnabled(chainId) && !isWormholeEvmChain(chainId);\n    }\n\n    function _shouldRelayViaStandardRelaying(uint16 chainId) internal view returns (bool) {\n        return isWormholeRelayingEnabled(chainId) && isWormholeEvmChain(chainId);\n    }\n\n    function _setVAAConsumed(bytes32 hash) internal {\n        _getWormholeConsumedVAAsStorage()[hash] = true;\n    }\n\n    // =============== MODIFIERS ===============================================\n\n    modifier onlyRelayer() {\n        if (msg.sender != address(wormholeRelayer)) {\n            revert CallerNotRelayer(msg.sender);\n        }\n        _;\n    }\n}"
    }
  ]
}