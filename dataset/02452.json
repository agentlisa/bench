{
  "Title": "H-6: Adversary can break any bounty they wish by depositing an NFT then refunding it",
  "Content": "# Issue H-6: Adversary can break any bounty they wish by depositing an NFT then refunding it \n\nSource: https://github.com/sherlock-audit/2023-02-openq-judging/issues/263 \n\n## Found by \nrvierdiiev, TrungOre, HollaDieWaldfee, bin2chen, Tricko, 0xbepresent, unforgiven, libratus, Robert, 0x52, HonorLt, usmannk, StErMi, cergyk, ctf\\_sec, Ruhum, Jeiwan, GimelSec, cccz, 8olidity\n\n## Summary\n\nRefunding an NFT doesn't remove the nftDeposit so the contract will try to payout an NFT it doesn't have if the NFT has been refunded.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/BountyCore.sol#L64-L93\n\nAll bounties use BountyCore#refundDeposit to process refunds to user. This simply transfers the NFT back to the funder but leaves the nftDeposit. \n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/ClaimManager/Implementations/ClaimManagerV1.sol#L150-L165\n\nWhen any bounty is claimed it loops through nftDeposits and attempts to transfer an NFT for each one. The problem is that if an NFT has been refunded the deposit receipt will still exist but the contract won't have the NFT. The result is that all payouts will be permanently broken. \n\nSubmitting as high risk because when combined with refund locking methods it will result in all deposited tokens being stuck forever.\n\n## Impact\n\nAdversary can permanently break payouts on any bounty\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/ClaimManager/Implementations/ClaimManagerV1.sol#L31-L67\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove the deposit receipt from nftDeposits when refunding NFT deposits\n\n## Discussion\n\n**FlacoJones**\n\nValid. Will fix by removing nfts for now\n\n**FlacoJones**\n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/113\n\nand \n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/114\n\n**kiseln**\n\nEscalate for 20 USDC\n\nThis completely bricks payouts just like #62. Shouldn't it be high?\n\n**sherlock-admin**\n\n > Escalate for 20 USDC\n> \n> This completely bricks payouts just like #62. Shouldn't it be high?\n\nYou've created a valid escalation for 20 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nThis issue is a valid high \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This issue is a valid high\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This issue is a valid high \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/39",
  "Code": [
    {
      "filename": "contracts/Bounty/Implementations/BountyCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/BountyStorageCore.sol';\n\n/// @title BountyCore\n/// @author FlacoJones\n/// @notice Shared methods common to all bounty types\n/// @dev BountyCore -> BountyStorageCore -> Core Dependencies (OZ + Custom)\nabstract contract BountyCore is BountyStorageCore {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /// @notice Creates a deposit and transfers tokens from msg.sender to this contract\n    /// @param _funder The funder's address\n    /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)\n    /// @param _volume The volume of token to transfer\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @return (depositId, volumeReceived) Returns the deposit id and the amount transferred to bounty\n    function receiveFunds(\n        address _funder,\n        address _tokenAddress,\n        uint256 _volume,\n        uint256 _expiration\n    )\n        external\n        payable\n        virtual\n        onlyDepositManager\n        nonReentrant\n        returns (bytes32, uint256)\n    {\n        require(_volume != 0, Errors.ZERO_VOLUME_SENT);\n        require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);\n        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);\n\n        bytes32 depositId = _generateDepositId();\n\n        uint256 volumeReceived;\n        if (_tokenAddress == address(0)) {\n            volumeReceived = msg.value;\n        } else {\n            volumeReceived = _receiveERC20(_tokenAddress, _funder, _volume);\n        }\n\n        funder[depositId] = _funder;\n        tokenAddress[depositId] = _tokenAddress;\n        volume[depositId] = volumeReceived;\n        depositTime[depositId] = block.timestamp;\n        expiration[depositId] = _expiration;\n        isNFT[depositId] = false;\n\n        deposits.push(depositId);\n        tokenAddresses.add(_tokenAddress);\n\n        return (depositId, volumeReceived);\n    }\n\n    /// @notice Transfers volume of deposit or NFT of deposit from bounty to funder\n    /// @param _depositId The deposit to refund\n    /// @param _funder The initial funder of the deposit\n    /// @param _volume The volume to be refunded (only relevant if deposit is not an NFT, otherwise is zero)\n    function refundDeposit(\n        bytes32 _depositId,\n        address _funder,\n        uint256 _volume\n    ) external virtual onlyDepositManager nonReentrant {\n        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);\n        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);\n        require(\n            block.timestamp >= depositTime[_depositId] + expiration[_depositId],\n            Errors.PREMATURE_REFUND_REQUEST\n        );\n\n        refunded[_depositId] = true;\n\n        if (tokenAddress[_depositId] == address(0)) {\n            _transferProtocolToken(funder[_depositId], _volume);\n        } else if (isNFT[_depositId]) {\n            _transferNft(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                tokenId[_depositId]\n            );\n        } else {\n            _transferERC20(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                _volume\n            );\n        }\n    }\n\n    /// @notice Extends deposit duration\n    /// @param _depositId The deposit to extend\n    /// @param _seconds Number of seconds to extend deposit\n    /// @param _funder The initial funder of the deposit\n    function extendDeposit(\n        bytes32 _depositId,\n        uint256 _seconds,\n        address _funder\n    ) external virtual onlyDepositManager nonReentrant returns (uint256) {\n        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);\n        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);\n        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);\n\n        if (\n            block.timestamp > depositTime[_depositId] + expiration[_depositId]\n        ) {\n            expiration[_depositId] =\n                block.timestamp -\n                depositTime[_depositId] +\n                _seconds;\n        } else {\n            expiration[_depositId] = expiration[_depositId] + _seconds;\n        }\n\n        return expiration[_depositId];\n    }\n\n    /// @notice Transfers NFT from bounty address to _payoutAddress\n    /// @param _payoutAddress The destination address for the NFT\n    /// @param _depositId The payout address of the bounty\n    function claimNft(address _payoutAddress, bytes32 _depositId)\n        external\n        virtual\n        onlyClaimManager\n        nonReentrant\n    {\n        _transferNft(\n            tokenAddress[_depositId],\n            _payoutAddress,\n            tokenId[_depositId]\n        );\n    }\n\n    /// @notice Sets the funding goal\n    /// @param _fundingToken Token address for funding goal\n    /// @param _fundingGoal Token volume for funding goal\n    function setFundingGoal(address _fundingToken, uint256 _fundingGoal)\n        external\n        virtual\n        onlyOpenQ\n    {\n        fundingGoal = _fundingGoal;\n        fundingToken = _fundingToken;\n        hasFundingGoal = true;\n    }\n\n    /// @notice Whether or not KYC is required to fund and claim the bounty\n    /// @param _kycRequired Whether or not KYC is required to fund and claim the bounty\n    function setKycRequired(bool _kycRequired) external virtual onlyOpenQ {\n        kycRequired = _kycRequired;\n    }\n\n    /// @notice Whether or not the Bounty is invoiceRequired\n    /// @param _invoiceRequired Whether or not the Bounty is invoiceRequired\n    function setInvoiceRequired(bool _invoiceRequired)\n        external\n        virtual\n        onlyOpenQ\n    {\n        invoiceRequired = _invoiceRequired;\n    }\n\n    /// @notice Whether or not KYC is required to fund and claim the bounty\n    /// @param _supportingDocumentsRequired Whether or not KYC is required to fund and claim the bounty\n    function setSupportingDocumentsRequired(bool _supportingDocumentsRequired)\n        external\n        virtual\n        onlyOpenQ\n    {\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n    }\n\n    /// @notice Transfers _volume of both ERC20 or protocol token to _payoutAddress\n    /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token\n    /// @param _volume Volume to transfer\n    /// @param _payoutAddress Destination address\n    function _transferToken(\n        address _tokenAddress,\n        uint256 _volume,\n        address _payoutAddress\n    ) internal virtual {\n        if (_tokenAddress == address(0)) {\n            _transferProtocolToken(_payoutAddress, _volume);\n        } else {\n            _transferERC20(_tokenAddress, _payoutAddress, _volume);\n        }\n    }\n\n    /// @notice Receives _volume of ERC20 at _tokenAddress from _funder to bounty address\n    /// @param _tokenAddress The ERC20 token address\n    /// @param _funder The funder of the bounty\n    /// @param _volume The volume of token to transfer\n    function _receiveERC20(\n        address _tokenAddress,\n        address _funder,\n        uint256 _volume\n    ) internal virtual returns (uint256) {\n        uint256 balanceBefore = getERC20Balance(_tokenAddress);\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        token.safeTransferFrom(_funder, address(this), _volume);\n        uint256 balanceAfter = getERC20Balance(_tokenAddress);\n        require(\n            balanceAfter >= balanceBefore,\n            Errors.TOKEN_TRANSFER_IN_OVERFLOW\n        );\n\n        //// The reason we take the balanceBefore and balanceAfter rather than the raw volume\n        /// is because certain ERC20 contracts ( e.g. USDT) take fees on transfers.\n        /// Therefore the volume received after transferFrom can be lower than the raw volume sent by the sender\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @notice Transfers _volume of ERC20 at _tokenAddress from bounty address to _funder\n    /// @param _tokenAddress The ERC20 token address\n    /// @param _payoutAddress The destination address of the funds\n    /// @param _volume The volume of token to transfer\n    function _transferERC20(\n        address _tokenAddress,\n        address _payoutAddress,\n        uint256 _volume\n    ) internal virtual {\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        token.safeTransfer(_payoutAddress, _volume);\n    }\n\n    /// @notice Transfers _volume of protocol token from bounty address to _payoutAddress\n    /// @param _payoutAddress The destination address of the funds\n    /// @param _volume The volume of token to transfer\n    function _transferProtocolToken(address _payoutAddress, uint256 _volume)\n        internal\n        virtual\n    {\n        payable(_payoutAddress).sendValue(_volume);\n    }\n\n    /// @notice Receives NFT of _tokenId on _tokenAddress from _funder to bounty address\n    /// @param _tokenAddress The ERC721 token address\n    /// @param _sender The sender of the NFT\n    /// @param _tokenId The tokenId\n    function _receiveNft(\n        address _tokenAddress,\n        address _sender,\n        uint256 _tokenId\n    ) internal virtual {\n        IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);\n        nft.safeTransferFrom(_sender, address(this), _tokenId);\n    }\n\n    /// @notice Transfers NFT of _tokenId on _tokenAddress from bounty address to _payoutAddress\n    /// @param _tokenAddress The ERC721 token address\n    /// @param _payoutAddress The sender of the NFT\n    /// @param _tokenId The tokenId\n    function _transferNft(\n        address _tokenAddress,\n        address _payoutAddress,\n        uint256 _tokenId\n    ) internal virtual {\n        IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);\n        nft.safeTransferFrom(address(this), _payoutAddress, _tokenId);\n    }\n\n    /// @notice Generates a unique deposit ID from bountyId and the current length of deposits\n    function _generateDepositId() internal view virtual returns (bytes32) {\n        return keccak256(abi.encode(bountyId, deposits.length));\n    }\n\n    /// TRANSFER HELPERS\n\n    /// @notice Returns token balance for both ERC20 or protocol token\n    /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token\n    function getTokenBalance(address _tokenAddress)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        if (_tokenAddress == address(0)) {\n            return address(this).balance;\n        } else {\n            return getERC20Balance(_tokenAddress);\n        }\n    }\n\n    /// @notice Returns the ERC20 balance for this bounty address\n    /// @param _tokenAddress The ERC20 token address\n    /// @return balance The ERC20 balance for this bounty address\n    function getERC20Balance(address _tokenAddress)\n        public\n        view\n        virtual\n        returns (uint256 balance)\n    {\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Returns an array of all deposits (ERC20, protocol token, and NFT) for this bounty\n    /// @return deposits The array of deposits including ERC20, protocol token, and NFT\n    function getDeposits() external view virtual returns (bytes32[] memory) {\n        return deposits;\n    }\n\n    /// @notice Returns an array of ONLY NFT deposits for this bounty\n    /// @return nftDeposits The array of NFT deposits\n    function getNftDeposits() external view virtual returns (bytes32[] memory) {\n        return nftDeposits;\n    }\n\n    /// @notice Returns an array of all ERC20 token addresses which have funded this bounty\n    /// @return tokenAddresses An array of all ERC20 token addresses which have funded this bounty\n    function getTokenAddresses()\n        public\n        view\n        virtual\n        returns (address[] memory)\n    {\n        return tokenAddresses.values();\n    }\n\n    /// @notice Returns the total number of unique tokens deposited on the bounty\n    /// @return tokenAddressesCount The length of the array of all ERC20 token addresses which have funded this bounty\n    function getTokenAddressesCount() external view virtual returns (uint256) {\n        return tokenAddresses.values().length;\n    }\n\n    /// @notice Returns the amount of locked tokens (of a specific token) on a bounty address, only available for claims but not for refunds\n    /// @param _depositId The depositId that determines which token is being looked at\n    /// @return uint256\n    function getLockedFunds(address _depositId)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 lockedFunds;\n        bytes32[] memory depList = this.getDeposits();\n        for (uint256 i = 0; i < depList.length; i++) {\n            if (\n                block.timestamp <\n                depositTime[depList[i]] + expiration[depList[i]] &&\n                tokenAddress[depList[i]] == _depositId\n            ) {\n                lockedFunds += volume[depList[i]];\n            }\n        }\n\n        return lockedFunds;\n    }\n}"
    },
    {
      "filename": "contracts/ClaimManager/Implementations/ClaimManagerV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/ClaimManagerStorage.sol';\nimport '../../Bounty/Interfaces/IAtomicBounty.sol';\nimport '../../Bounty/Interfaces/ITieredBounty.sol';\nimport '../../Bounty/Interfaces/IOngoingBounty.sol';\n\n/// @title ClaimManagerV1\n/// @author FlacoJones\n/// @notice Sole contract authorized to attempt claims on all bounty types\n/// @dev Emitter of all claim-related events\n/// @dev Some claim methods are onlyOracle protected, others have exclusively on-chain claim criteria\ncontract ClaimManagerV1 is ClaimManagerStorageV1 {\n    constructor() {}\n\n    /// @notice Initializes the ClaimManager implementation with oracle address\n    /// @param _oracle The address of the oracle authorized to call onlyOracle methods (e.g. claimBounty)\n    /// @dev Can only be called once thanks to initializer (https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers)\n    function initialize(address _oracle) external initializer onlyProxy {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        __Oraclize_init(_oracle);\n    }\n\n    /// @notice Calls appropriate claim method based on bounty type\n    /// @param _bountyAddress The payout address of the bounty\n    /// @param _closer The payout address of the claimant\n    /// @param _closerData ABI Encoded data associated with this claim\n    /// @dev see IAtomicBounty.close(_closerData) for _closerData ABI encoding schema\n    function claimBounty(\n        address _bountyAddress,\n        address _closer,\n        bytes calldata _closerData\n    ) external onlyOracle onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n        uint256 _bountyType = bounty.bountyType();\n\n        if (_bountyType == OpenQDefinitions.ATOMIC) {\n            // Decode to ensure data meets closerData schema before emitting any events\n            abi.decode(_closerData, (address, string, address, string));\n\n            _claimAtomicBounty(bounty, _closer, _closerData);\n            bounty.close(_closer, _closerData);\n\n            emit BountyClosed(\n                bounty.bountyId(),\n                _bountyAddress,\n                bounty.organization(),\n                _closer,\n                block.timestamp,\n                bounty.bountyType(),\n                _closerData,\n                VERSION_1\n            );\n        } else if (_bountyType == OpenQDefinitions.ONGOING) {\n            _claimOngoingBounty(bounty, _closer, _closerData);\n        } else if (_bountyType == OpenQDefinitions.TIERED_PERCENTAGE) {\n            _claimTieredPercentageBounty(bounty, _closer, _closerData);\n        } else if (_bountyType == OpenQDefinitions.TIERED_FIXED) {\n            _claimTieredFixedBounty(bounty, _closer, _closerData);\n        } else {\n            revert(Errors.UNKNOWN_BOUNTY_TYPE);\n        }\n\n        emit ClaimSuccess(block.timestamp, _bountyType, _closerData, VERSION_1);\n    }\n\n    /// @notice Used for claimants who have:\n    /// @notice A) Completed KYC with KYC DAO for their tier\n    /// @notice B) Uploaded invoicing information for their tier\n    /// @notice C) Uploaded any necessary financial forms for their tier\n    /// @param _bountyAddress The payout address of the bounty\n    /// @param _closerData ABI Encoded data associated with this claim\n    function permissionedClaimTieredBounty(\n        address _bountyAddress,\n        bytes calldata _closerData\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        (, , , , uint256 _tier) = abi.decode(\n            _closerData,\n            (address, string, address, string, uint256)\n        );\n\n        string memory closer = IOpenQ(openQ).addressToExternalUserId(\n            msg.sender\n        );\n\n        require(\n            keccak256(abi.encodePacked(closer)) !=\n                keccak256(abi.encodePacked('')),\n            Errors.NO_ASSOCIATED_ADDRESS\n        );\n\n        require(\n            keccak256(abi.encode(closer)) ==\n                keccak256(abi.encode(bounty.tierWinners(_tier))),\n            Errors.CLAIMANT_NOT_TIER_WINNER\n        );\n\n        if (bounty.bountyType() == OpenQDefinitions.TIERED_FIXED) {\n            _claimTieredFixedBounty(bounty, msg.sender, _closerData);\n        } else if (bounty.bountyType() == OpenQDefinitions.TIERED_PERCENTAGE) {\n            _claimTieredPercentageBounty(bounty, msg.sender, _closerData);\n        } else {\n            revert(Errors.NOT_A_COMPETITION_CONTRACT);\n        }\n\n        emit ClaimSuccess(\n            block.timestamp,\n            bounty.bountyType(),\n            _closerData,\n            VERSION_1\n        );\n    }\n\n    /// @notice Claim method for AtomicBounty\n    /// @param _bounty The payout address of the bounty\n    /// @param _closer The payout address of the claimant\n    /// @param _closerData ABI Encoded data associated with this claim\n    /// @dev See IAtomicBounty\n    function _claimAtomicBounty(\n        IAtomicBounty _bounty,\n        address _closer,\n        bytes calldata _closerData\n    ) internal {\n        _eligibleToClaimAtomicBounty(_bounty, _closer);\n\n        for (uint256 i = 0; i < _bounty.getTokenAddresses().length; i++) {\n            uint256 volume = _bounty.claimBalance(\n                _closer,\n                _bounty.getTokenAddresses()[i]\n            );\n\n            emit TokenBalanceClaimed(\n                _bounty.bountyId(),\n                address(_bounty),\n                _bounty.organization(),\n                _closer,\n                block.timestamp,\n                _bounty.getTokenAddresses()[i],\n                volume,\n                _bounty.bountyType(),\n                _closerData,\n                VERSION_1\n            );\n        }\n\n        for (uint256 i = 0; i < _bounty.getNftDeposits().length; i++) {\n            _bounty.claimNft(_closer, _bounty.nftDeposits(i));\n\n            emit NFTClaimed(\n                _bounty.bountyId(),\n                address(_bounty),\n                _bounty.organization(),\n                _closer,\n                block.timestamp,\n                _bounty.tokenAddress(_bounty.nftDeposits(i)),\n                _bounty.tokenId(_bounty.nftDeposits(i)),\n                _bounty.bountyType(),\n                _closerData,\n                VERSION_1\n            );\n        }\n    }\n\n    /// @notice Claim method for OngoingBounty\n    /// @param _bounty The payout address of the bounty\n    /// @param _closer The payout address of the claimant\n    /// @param _closerData ABI Encoded data associated with this claim\n    /// @dev see IBountyCore.claimOngoingPayout.(_closerData) for _closerData ABI encoding schema\n    function _claimOngoingBounty(\n        IOngoingBounty _bounty,\n        address _closer,\n        bytes calldata _closerData\n    ) internal {\n        _eligibleToClaimOngoingBounty(_bounty, _closer, _closerData);\n\n        (address tokenAddress, uint256 volume) = _bounty.claimOngoingPayout(\n            _closer,\n            _closerData\n        );\n\n        emit TokenBalanceClaimed(\n            _bounty.bountyId(),\n            address(_bounty),\n            _bounty.organization(),\n            _closer,\n            block.timestamp,\n            tokenAddress,\n            volume,\n            _bounty.bountyType(),\n            _closerData,\n            VERSION_1\n        );\n    }\n\n    /// @notice Claim method for TieredPercentageBounty\n    /// @param _bounty The payout address of the bounty\n    /// @param _closer The payout address of the claimant\n    /// @param _closerData ABI Encoded data associated with this claim\n    function _claimTieredPercentageBounty(\n        IBounty _bounty,\n        address _closer,\n        bytes calldata _closerData\n    ) internal {\n        (, , , , uint256 _tier) = abi.decode(\n            _closerData,\n            (address, string, address, string, uint256)\n        );\n\n        _eligibleToClaimTier(_bounty, _tier, _closer);\n\n        if (_bounty.status() == 0) {\n            _bounty.closeCompetition();\n\n            emit BountyClosed(\n                _bounty.bountyId(),\n                address(_bounty),\n                _bounty.organization(),\n                address(0),\n                block.timestamp,\n                _bounty.bountyType(),\n                new bytes(0),\n                VERSION_1\n            );\n        }\n\n        for (uint256 i = 0; i < _bounty.getTokenAddresses().length; i++) {\n            uint256 volume = _bounty.claimTiered(\n                _closer,\n                _tier,\n                _bounty.getTokenAddresses()[i]\n            );\n\n            emit TokenBalanceClaimed(\n                _bounty.bountyId(),\n                address(_bounty),\n                _bounty.organization(),\n                _closer,\n                block.timestamp,\n                _bounty.getTokenAddresses()[i],\n                volume,\n                _bounty.bountyType(),\n                _closerData,\n                VERSION_1\n            );\n        }\n\n        for (uint256 i = 0; i < _bounty.getNftDeposits().length; i++) {\n            bytes32 _depositId = _bounty.nftDeposits(i);\n            if (_bounty.tier(_depositId) == _tier) {\n                _bounty.claimNft(_closer, _depositId);\n\n                emit NFTClaimed(\n                    _bounty.bountyId(),\n                    address(_bounty),\n                    _bounty.organization(),\n                    _closer,\n                    block.timestamp,\n                    _bounty.tokenAddress(_depositId),\n                    _bounty.tokenId(_depositId),\n                    _bounty.bountyType(),\n                    _closerData,\n                    VERSION_1\n                );\n            }\n        }\n\n        _bounty.setTierClaimed(_tier);\n    }\n\n    /// @notice Claim method for TieredFixedBounty\n    /// @param _bounty The payout address of the bounty\n    /// @param _closer The payout address of the claimant\n    /// @param _closerData ABI Encoded data associated with this claim\n    function _claimTieredFixedBounty(\n        IBounty _bounty,\n        address _closer,\n        bytes calldata _closerData\n    ) internal {\n        (, , , , uint256 _tier) = abi.decode(\n            _closerData,\n            (address, string, address, string, uint256)\n        );\n\n        _eligibleToClaimTier(_bounty, _tier, _closer);\n\n        if (_bounty.status() == 0) {\n            _bounty.closeCompetition();\n\n            emit BountyClosed(\n                _bounty.bountyId(),\n                address(_bounty),\n                _bounty.organization(),\n                address(0),\n                block.timestamp,\n                _bounty.bountyType(),\n                new bytes(0),\n                VERSION_1\n            );\n        }\n\n        uint256 volume = _bounty.claimTieredFixed(_closer, _tier);\n\n        emit TokenBalanceClaimed(\n            _bounty.bountyId(),\n            address(_bounty),\n            _bounty.organization(),\n            _closer,\n            block.timestamp,\n            _bounty.payoutTokenAddress(),\n            volume,\n            _bounty.bountyType(),\n            _closerData,\n            VERSION_1\n        );\n\n        for (uint256 i = 0; i < _bounty.getNftDeposits().length; i++) {\n            bytes32 _depositId = _bounty.nftDeposits(i);\n            if (_bounty.tier(_depositId) == _tier) {\n                _bounty.claimNft(_closer, _depositId);\n\n                emit NFTClaimed(\n                    _bounty.bountyId(),\n                    address(_bounty),\n                    _bounty.organization(),\n                    _closer,\n                    block.timestamp,\n                    _bounty.tokenAddress(_depositId),\n                    _bounty.tokenId(_depositId),\n                    _bounty.bountyType(),\n                    _closerData,\n                    VERSION_1\n                );\n            }\n        }\n\n        _bounty.setTierClaimed(_tier);\n    }\n\n    /// @notice Checks if bounty associated with _bountyId is open\n    /// @return bool True if _bountyId is associated with an open bounty\n    function bountyIsClaimable(address _bountyAddress)\n        public\n        view\n        returns (bool)\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        uint256 status = bounty.status();\n        uint256 _bountyType = bounty.bountyType();\n\n        if (\n            _bountyType == OpenQDefinitions.ATOMIC ||\n            _bountyType == OpenQDefinitions.ONGOING ||\n            _bountyType == OpenQDefinitions.TIERED_PERCENTAGE ||\n            _bountyType == OpenQDefinitions.TIERED_FIXED\n        ) {\n            return status == 0;\n        } else {\n            return status == 1;\n        }\n    }\n\n    /// @notice Override for UUPSUpgradeable._authorizeUpgrade(address newImplementation) to enforce onlyOwner upgrades\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    /// @notice Exposes internal method Oraclize._transferOracle(address) restricted to onlyOwner called via proxy\n    /// @param _newOracle The new oracle address\n    function transferOracle(address _newOracle) external onlyProxy onlyOwner {\n        require(_newOracle != address(0), Errors.NO_ZERO_ADDRESS);\n        _transferOracle(_newOracle);\n    }\n\n    /// @notice Sets the OpenQProxy address used for checking IOpenQ(openQ).addressToExternalUserId\n    function setOpenQ(address _openQ) external onlyProxy onlyOwner {\n        openQ = _openQ;\n    }\n\n    /// @notice Sets the KYC DAO contract address\n    /// @param _kyc The KYC DAO contract address\n    function setKyc(address _kyc) external onlyProxy onlyOwner {\n        kyc = IKycValidity(_kyc);\n    }\n\n    /// @notice Checks the current KYC DAO contract address (kyc)to see if user has a valid KYC NFT or not\n    /// @return True if address is KYC with KYC DAO, false otherwise\n    function hasKYC(address _address) public view returns (bool) {\n        return kyc.hasValidToken(_address);\n    }\n\n    /// @notice Runs all require statements to determine if the claimant can claim the specified tier on the tiered bounty\n    function _eligibleToClaimTier(\n        ITieredBounty _bounty,\n        uint256 _tier,\n        address _closer\n    ) internal view {\n        require(!_bounty.tierClaimed(_tier), Errors.TIER_ALREADY_CLAIMED);\n\n        if (_bounty.invoiceRequired()) {\n            require(\n                _bounty.invoiceComplete(_tier),\n                Errors.INVOICE_NOT_COMPLETE\n            );\n        }\n\n        if (_bounty.supportingDocumentsRequired()) {\n            require(\n                _bounty.supportingDocumentsComplete(_tier),\n                Errors.SUPPORTING_DOCS_NOT_COMPLETE\n            );\n        }\n\n        if (_bounty.kycRequired()) {\n            require(hasKYC(_closer), Errors.ADDRESS_LACKS_KYC);\n        }\n    }\n\n    /// @notice Runs all require statements to determine if the claimant can claim the atomic bounty\n    function _eligibleToClaimAtomicBounty(IAtomicBounty bounty, address _closer)\n        internal\n        view\n    {\n        require(\n            bounty.status() == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_IS_NOT_CLAIMABLE\n        );\n\n        if (bounty.invoiceRequired()) {\n            bool _invoiceComplete = abi.decode(\n                bounty.getInvoiceComplete(),\n                (bool)\n            );\n            require(_invoiceComplete, Errors.INVOICE_NOT_COMPLETE);\n        }\n\n        if (bounty.supportingDocumentsRequired()) {\n            bool _supportingDocumentsComplete = abi.decode(\n                bounty.getSupportingDocumentsComplete(),\n                (bool)\n            );\n            require(\n                _supportingDocumentsComplete,\n                Errors.SUPPORTING_DOCS_NOT_COMPLETE\n            );\n        }\n\n        if (bounty.kycRequired()) {\n            require(hasKYC(_closer), Errors.ADDRESS_LACKS_KYC);\n        }\n    }\n\n    /// @notice Runs all require statements to determine if the claimant can claim an ongoing bounty payout\n    function _eligibleToClaimOngoingBounty(\n        IOngoingBounty bounty,\n        address _closer,\n        bytes memory _closerData\n    ) internal view {\n        require(\n            bounty.status() == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_IS_NOT_CLAIMABLE\n        );\n\n        (, string memory claimant, , string memory claimantAsset) = abi.decode(\n            _closerData,\n            (address, string, address, string)\n        );\n\n        bytes32 claimId = bounty.generateClaimId(claimant, claimantAsset);\n\n        if (bounty.invoiceRequired()) {\n            require(\n                bounty.invoiceComplete(claimId),\n                Errors.INVOICE_NOT_COMPLETE\n            );\n        }\n\n        if (bounty.supportingDocumentsRequired()) {\n            require(\n                bounty.supportingDocumentsComplete(claimId),\n                Errors.SUPPORTING_DOCS_NOT_COMPLETE\n            );\n        }\n\n        if (bounty.kycRequired()) {\n            require(hasKYC(_closer), Errors.ADDRESS_LACKS_KYC);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/ClaimManager/Implementations/ClaimManagerV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/ClaimManagerStorage.sol';\nimport '../../Bounty/Interfaces/IAtomicBounty.sol';\nimport '../../Bounty/Interfaces/ITieredBounty.sol';\nimport '../../Bounty/Interfaces/IOngoingBounty.sol';\n\n/// @title ClaimManagerV1\n/// @author FlacoJones\n/// @notice Sole contract authorized to attempt claims on all bounty types\n/// @dev Emitter of all claim-related events\n/// @dev Some claim methods are onlyOracle protected, others have exclusively on-chain claim criteria\ncontract ClaimManagerV1 is ClaimManagerStorageV1 {\n    constructor() {}\n\n    /// @notice Initializes the ClaimManager implementation with oracle address\n    /// @param _oracle The address of the oracle authorized to call onlyOracle methods (e.g. claimBounty)\n    /// @dev Can only be called once thanks to initializer (https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers)\n    function initialize(address _oracle) external initializer onlyProxy {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        __Oraclize_init(_oracle);\n    }\n\n    /// @notice Calls appropriate claim method based on bounty type\n    /// @param _bountyAddress The payout address of the bounty\n    /// @param _closer The payout address of the claimant\n    /// @param _closerData ABI Encoded data associated with this claim\n    /// @dev see IAtomicBounty.close(_closerData) for _closerData ABI encoding schema\n    function claimBounty(\n        address _bountyAddress,\n        address _closer,\n        bytes calldata _closerData\n    ) external onlyOracle onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n        uint256 _bountyType = bounty.bountyType();\n\n        if (_bountyType == OpenQDefinitions.ATOMIC) {\n            // Decode to ensure data meets closerData schema before emitting any events\n            abi.decode(_closerData, (address, string, address, string));\n\n            _claimAtomicBounty(bounty, _closer, _closerData);\n            bounty.close(_closer, _closerData);\n\n            emit BountyClosed(\n                bounty.bountyId(),\n                _bountyAddress,\n                bounty.organization(),\n                _closer,\n                block.timestamp,\n                bounty.bountyType(),\n                _closerData,\n                VERSION_1\n            );\n        } else if (_bountyType == OpenQDefinitions.ONGOING) {\n            _claimOngoingBounty(bounty, _closer, _closerData);\n        } else if (_bountyType == OpenQDefinitions.TIERED_PERCENTAGE) {\n            _claimTieredPercent"
    }
  ]
}