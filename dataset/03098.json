{
  "Title": "Extending the staking duration discards rewards",
  "Content": "In the [`OgvStaking`](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/OgvStaking.sol) contract, updating a user’s rewards is a two step process: First, the internal function [`_collectRewards`](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/OgvStaking.sol#L184) must be called, which updates the accumulated per share rewards for all users and then computes and transfers an individual user’s total outstanding rewards. The computation of a user’s outstanding rewards uses the mapping `rewardDebt` for internal bookkeeping. Because `rewardDebt` contains a user’s debt in absolute terms, it can only be updated as a second step outside of the `_collectRewards` function after a potential change of the user’s stake has been accounted for. In effect, user rewards can only be computed correctly if a call to `_collectRewards` is jointly used with an update of `rewardDebt`.\n\n\nThe function [`extend`](https://github.com/OriginProtocol/ousd-governance/blob/2b9761606d4ac4062b69367ebbad88220cea45ce/contracts/OgvStaking.sol#L127) only performs an update on `rewardDebt` without a prior call to `_collectRewards`. Hence, it always discards the rewards earned by a user instead of paying them out.\n\n\nWhile calling `_collectRewards` within the `extend` function would mitigate the issue, consider instead solving the root cause by migrating to a mapping `rewardDebtPerShare`. This mapping can be updated within the `_collectRewards` function, which does not need to account for changes in the user’s balance, thereby avoiding any future mismatches in reward accounting.\n\n\n**Update**: *Fixed by the changes made in pull requests [#88](https://github.com/OriginProtocol/ousd-governance/pull/88) and [#98](https://github.com/OriginProtocol/ousd-governance/pull/98).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/OgvStaking.sol",
      "content": "pragma solidity 0.8.10;\nimport {ERC20Votes} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport {ERC20Permit} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ERC20} from \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/ERC20.sol\";\nimport {PRBMathUD60x18} from \"paulrberg/prb-math@2.5.0/contracts/PRBMathUD60x18.sol\";\nimport {RewardsSource} from \"./RewardsSource.sol\";\n\ncontract OgvStaking is ERC20Votes {\n    // 1. Core Storage\n    uint256 public immutable epoch;\n\n    // 2. Staking and Lockup Storage\n    uint256 constant YEAR_BASE = 18e17;\n    struct Lockup {\n        uint128 amount;\n        uint128 end;\n        uint256 points;\n    }\n    mapping(address => Lockup[]) public lockups;\n\n    // 3. Reward Storage\n    ERC20 public immutable ogv;\n    RewardsSource public rewardsSource;\n    mapping(address => uint256) public rewardDebt;\n    uint256 public accRewardPerShare; // As of the start of the block\n\n    // Events\n    event Stake(\n        address indexed user,\n        uint256 lockupId,\n        uint256 amount,\n        uint256 end,\n        uint256 points\n    );\n    event Unstake(\n        address indexed user,\n        uint256 lockupId,\n        uint256 amount,\n        uint256 end,\n        uint256 points\n    );\n    event Reward(address indexed user, uint256 amount);\n\n    // 1. Core Functions\n\n    constructor(\n        address ogv_,\n        uint256 epoch_,\n        address rewardsSource_\n    ) ERC20(\"\", \"\") ERC20Permit(\"OGV Staking\") {\n        ogv = ERC20(ogv_);\n        epoch = epoch_;\n        rewardsSource = RewardsSource(rewardsSource_);\n    }\n\n    function name() public pure override returns (string memory) {\n        return \"OGVe\";\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return \"Staked OGV\";\n    }\n\n    function transfer(address, uint256) public override returns (bool) {\n        revert(\"Staking: Transfers disabled\");\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public override returns (bool) {\n        revert(\"Staking: Transfers disabled\");\n    }\n\n    // 2. Staking and Lockup Functions\n\n    function stake(\n        uint256 amount,\n        uint256 duration,\n        address to\n    ) external {\n        if (to == address(0)) {\n            to = msg.sender;\n        }\n        require(amount <= type(uint128).max, \"Staking: Too much\");\n        require(amount > 0, \"Staking: Not enough\");\n        // duration checked inside previewPoints\n        (uint256 points, uint256 end) = previewPoints(amount, duration);\n        require(\n            points + totalSupply() <= type(uint192).max,\n            \"Staking: Max points exceeded\"\n        );\n        _collectRewards(to);\n        lockups[to].push(\n            Lockup({\n                amount: uint128(amount), // max checked in require above\n                end: uint128(end),\n                points: points\n            })\n        );\n        _mint(to, points);\n        rewardDebt[to] = (balanceOf(to) * accRewardPerShare) / 1e12;\n        ogv.transferFrom(msg.sender, address(this), amount); // Important that it's sender\n        emit Stake(to, lockups[to].length - 1, amount, end, points);\n    }\n\n    function unstake(uint256 lockupId, bool noRewards) external {\n        Lockup memory lockup = lockups[msg.sender][lockupId];\n        uint256 amount = lockup.amount;\n        uint256 end = lockup.end;\n        uint256 points = lockup.points;\n        require(block.timestamp >= end, \"Staking: End of lockup not reached\");\n        require(end != 0, \"Staking: Already unstaked this lockup\");\n        if (!noRewards) {\n            _collectRewards(msg.sender);\n        }\n        delete lockups[msg.sender][lockupId]; // Keeps empty in array, so indexes are stable\n        _burn(msg.sender, points);\n        rewardDebt[msg.sender] =\n            (balanceOf(msg.sender) * accRewardPerShare) /\n            1e12;\n        ogv.transfer(msg.sender, amount);\n        emit Unstake(msg.sender, lockupId, amount, end, points);\n    }\n\n    function extend(uint256 lockupId, uint256 duration) external {\n        // duration checked inside previewPoints\n        Lockup memory lockup = lockups[msg.sender][lockupId];\n        uint256 oldAmount = lockup.amount;\n        uint256 oldEnd = lockup.end;\n        uint256 oldPoints = lockup.points;\n        (uint256 newPoints, uint256 newEnd) = previewPoints(\n            oldAmount,\n            duration\n        );\n        require(newEnd > oldEnd, \"New lockup must be longer\");\n        lockup.end = uint128(newEnd);\n        lockup.points = newPoints;\n        lockups[msg.sender][lockupId] = lockup;\n        _mint(msg.sender, newPoints - oldPoints);\n        rewardDebt[msg.sender] =\n            (balanceOf(msg.sender) * accRewardPerShare) /\n            1e12;\n        emit Unstake(msg.sender, lockupId, oldAmount, oldEnd, oldPoints);\n        emit Stake(msg.sender, lockupId, oldAmount, newEnd, newPoints);\n    }\n\n    function previewPoints(uint256 amount, uint256 duration)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        require(duration >= 7 days, \"Staking: Too short\");\n        require(duration <= 1461 days, \"Staking: Too long\");\n        uint256 start = block.timestamp > epoch ? block.timestamp : epoch;\n        uint256 end = start + duration;\n        uint256 endYearpoc = ((end - epoch) * 1e18) / 365 days;\n        uint256 multiplier = PRBMathUD60x18.pow(YEAR_BASE, endYearpoc);\n        return ((amount * multiplier) / 1e18, end);\n    }\n\n    // 3. Reward functions\n\n    function collectRewards() external {\n        _collectRewards(msg.sender);\n        rewardDebt[msg.sender] =\n            (balanceOf(msg.sender) * accRewardPerShare) /\n            1e12;\n    }\n\n    function previewRewards(address user) external view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return 0; // No one has any points to even get rewards\n        }\n        uint256 _accRewardPerShare = accRewardPerShare;\n        _accRewardPerShare += (rewardsSource.previewRewards() * 1e12) / supply;\n        uint256 balance = balanceOf(user);\n        uint256 grossReward = (balance * _accRewardPerShare) / 1e12;\n        return grossReward - rewardDebt[user];\n    }\n\n    function _collectRewards(address user) internal {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return; // Increasing accRewardPerShare would be meaningless.\n        }\n        accRewardPerShare += (rewardsSource.collectRewards() * 1e12) / supply;\n        uint256 balance = balanceOf(user);\n        if (balance == 0) {\n            return; // Do NOT move this check before `accRewardPerShare +=`\n        }\n        uint256 grossReward = (balance * accRewardPerShare) / 1e12;\n        uint256 netReward = grossReward - rewardDebt[user];\n        ogv.transfer(user, netReward);\n        emit Reward(user, netReward);\n    }\n}"
    }
  ]
}