{
  "Title": "[M-11] `PendlePowerManager` is incompatible with `PendleRouterV3`",
  "Content": "\n<https://github.com/pendle-finance/pendle-core-v2-public/blob/main/contracts/router/ActionAddRemoveLiqV3.sol#L166-L172>\n\n<https://github.com/pendle-finance/pendle-core-v2-public/blob/main/contracts/router/ActionAddRemoveLiqV3.sol#L444-L449>\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L467-L482> \n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L165-L171>\n\n### Impact\n\nWill cause revert when attempting to open a farm position.\n\n### Proof of Concept\n\nThe latest deployment of the Pendle router, `PendleRouterV3`, is incompatible with the `PendlePowerManager` contract. The sponsor is expecting full compatibility with both but this is not the case here. The problem stems from the calls made to `PENDLE_ROUTER.removeLiquiditySingleSy()` and `PENDLE_ROUTER.addLiquiditySingleSy()`:\n\n```solidity\nfunction _logicOpenPosition(\n    bool _isAave,\n    uint256 _nftId,\n    uint256 _depositAmount,\n    uint256 _totalDebtBalancer,\n    uint256 _allowedSpread\n)\n    internal\n{\n    // ...\n    (\n        uint256 netLpOut\n        ,\n    ) = PENDLE_ROUTER.addLiquiditySingleSy(\n        {\n            _receiver: address(this),\n            _market: address(PENDLE_MARKET),\n            _netSyIn: syReceived,\n            _minLpOut: 0,\n            _guessPtReceivedFromSy: ApproxParams(\n                {\n                    guessMin: netPtFromSwap - 100,\n                    guessMax: netPtFromSwap + 100,\n                    guessOffchain: 0,\n                    maxIteration: 50,\n                    eps: 1e15\n                }\n            )\n        }\n    );\n  // ...\n}\n\nfunction _logicClosePosition(\n    uint256 _nftId,\n    uint256 _borrowShares,\n    uint256 _lendingShares,\n    uint256 _totalDebtBalancer,\n    uint256 _allowedSpread,\n    address _caller,\n    bool _ethBack,\n    bool _isAave\n)\n    private\n{\n    // ...\n    (\n        uint256 netSyOut\n        ,\n    ) = PENDLE_ROUTER.removeLiquiditySingleSy(\n        {\n            _receiver: address(this),\n            _market: address(PENDLE_MARKET),\n            _netLpToRemove: withdrawnLpsAmount,\n            _minSyOut: 0\n        }\n    );\n  // ...\n}\n```\n\nThe issue is that the signatures of those have changed in V3:\n\n```solidity\nfunction addLiquiditySingleSy(\n    address receiver,\n    address market,\n    uint256 netSyIn,\n    uint256 minLpOut,\n    ApproxParams calldata guessPtReceivedFromSy,\n    LimitOrderData calldata limit\n) external returns (uint256 netLpOut, uint256 netSyFee);\n\nfunction removeLiquiditySingleSy(\n    address receiver,\n    address market,\n    uint256 netLpToRemove,\n    uint256 minSyOut,\n    LimitOrderData calldata limit\n) external returns (uint256 netSyOut, uint256 netSyFee);\n```\n\nThere's a new parameter called `limit` that's not accounted for in the calls in the `PendlePowerFarmLeverageLogic` helper contract. This will lead to calls always reverting with `RouterInvalidAction` due to Pendle's proxy not being able to locate the selector used.\n\nCoded POC (`PendlePowerFarmControllerBase.t.sol`):\n\n<details>\n\n```solidity\nfunction _setUpCustom(address _pendleRouter) private {\n    _setProperties();\n\n    pendleLockInstance = IPendleLock(AddressesMap[chainId].pendleLock);\n\n    wethInstance = IWETH(AddressesMap[chainId].weth);\n\n    wiseOracleHubInstance = WiseOracleHub(AddressesMap[chainId].oracleHub);\n\n    aaveHubInstance = IAaveHub(AddressesMap[chainId].aaveHub);\n\n    vm.startPrank(wiseLendingInstance.master());\n\n    controllerTester = new PendleControllerTester(\n        AddressesMap[chainId].vePendle,\n        AddressesMap[chainId].pendleTokenAddress,\n        AddressesMap[chainId].voterContract,\n        AddressesMap[chainId].voterRewardsClaimer,\n        AddressesMap[chainId].oracleHub\n    );\n\n    pendlePowerFarmTokenFactory = controllerTester.PENDLE_POWER_FARM_TOKEN_FACTORY();\n\n    PoolManager.CreatePool memory params = PoolManager.CreatePool({\n        allowBorrow: true,\n        poolToken: AddressesMap[chainId].aweth,\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 805000000000000000,\n        maxDepositAmount: 1800000000000000000000000\n    });\n\n    wiseLendingInstance.createPool(params);\n\n    IAaveHub(AddressesMap[chainId].aaveHub).setAaveTokenAddress(\n        AddressesMap[chainId].weth, AddressesMap[chainId].aweth\n    );\n\n    if (block.chainid == ETH_CHAIN_ID) {\n        wiseOracleHubInstance.addOracle(\n            AddressesMap[chainId].aweth,\n            wiseOracleHubInstance.priceFeed(AddressesMap[chainId].weth),\n            new address[](0)\n        );\n\n        wiseOracleHubInstance.recalibrate(AddressesMap[chainId].aweth);\n    }\n\n    _addPendleTokenOracle();\n\n    _addPendleMarketOracle(\n        AddressesMap[chainId].PendleMarketStEth,\n        address(wiseOracleHubInstance.priceFeed(AddressesMap[chainId].weth)),\n        AddressesMap[chainId].weth,\n        2 ether,\n        3 ether\n    );\n\n    IPendlePowerFarmToken derivativeToken =\n        _addPendleMarket(AddressesMap[chainId].PendleMarketStEth, \"name\", \"symbol\", MAX_CARDINALITY);\n\n    pendleChildLpOracleInstance = new PendleChildLpOracle(address(pendleLpOracleInstance), address(derivativeToken));\n\n    address[] memory underlyingTokens = new address[](1);\n    underlyingTokens[0] = AddressesMap[chainId].weth;\n\n    wiseOracleHubInstance.addOracle(\n        address(derivativeToken), IPriceFeed(address(pendleChildLpOracleInstance)), underlyingTokens\n    );\n\n    address[] memory underlyingTokensCurrent = new address[](0);\n\n    wiseOracleHubInstance.addOracle(CRV_TOKEN_ADDRESS, IPriceFeed(CRV_ETH_FEED), underlyingTokensCurrent);\n\n    wiseOracleHubInstance.recalibrate(CRV_TOKEN_ADDRESS);\n\n    curveUsdEthOracleInstance = new CurveUsdEthOracle(IPriceFeed(ETH_USD_FEED), IPriceFeed(CRVUSD_USD_FEED));\n\n    wiseOracleHubInstance.addOracle(\n        CRVUSD_TOKEN_ADDRESS, IPriceFeed(address(curveUsdEthOracleInstance)), new address[](0)\n    );\n\n    wiseOracleHubInstance.recalibrate(CRVUSD_TOKEN_ADDRESS);\n\n    wiseOracleHubInstance.addTwapOracle(\n        CRV_TOKEN_ADDRESS,\n        CRV_UNI_POOL_ADDRESS,\n        CRV_UNI_POOL_TOKEN0_ADDRESS,\n        CRV_UNI_POOL_TOKEN1_ADDRESS,\n        UNI_V3_FEE_CRV_UNI_POOL\n    );\n\n    wiseOracleHubInstance.addTwapOracleDerivative(\n        CRVUSD_TOKEN_ADDRESS,\n        CRVUSD_UNI_POOL_TOKEN0_ADDRESS,\n        [ETH_USDC_UNI_POOL_ADDRESS, CRVUSD_UNI_POOL_ADDRESS],\n        [ETH_USDC_UNI_POOL_TOKEN0_ADDRESS, CRVUSD_UNI_POOL_TOKEN0_ADDRESS],\n        [ETH_USDC_UNI_POOL_TOKEN1_ADDRESS, CRVUSD_UNI_POOL_TOKEN1_ADDRESS],\n        [UNI_V3_FEE_ETH_USDC_UNI_POOL, UNI_V3_FEE_CRVUSD_UNI_POOL]\n    );\n\n    address underlyingFeed = CRVUSD_TOKEN_ADDRESS;\n\n    _addPendleMarketOracle(\n        CRVUSD_PENDLE_28MAR_2024, address(curveUsdEthOracleInstance), underlyingFeed, 0.0008 ether, 0.0016 ether\n    );\n\n    derivativeToken = _addPendleMarket(CRVUSD_PENDLE_28MAR_2024, \"name\", \"symbol\", MAX_CARDINALITY);\n\n    pendleChildLpOracleInstance = new PendleChildLpOracle(address(pendleLpOracleInstance), address(derivativeToken));\n\n    underlyingTokens = new address[](1);\n    underlyingTokens[0] = underlyingFeed;\n\n    wiseOracleHubInstance.addOracle(\n        address(derivativeToken), IPriceFeed(address(pendleChildLpOracleInstance)), underlyingTokens\n    );\n\n    PoolManager.CreatePool[] memory createPoolArray = new PoolManager.CreatePool[](3);\n\n    createPoolArray[0] = PoolManager.CreatePool({\n        allowBorrow: true,\n        poolToken: CRVUSD_TOKEN_ADDRESS,\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 740000000000000000,\n        maxDepositAmount: 2000000000000000000000000\n    });\n\n    createPoolArray[1] = PoolManager.CreatePool({\n        allowBorrow: false,\n        poolToken: controllerTester.pendleChildAddress(AddressesMap[chainId].PendleMarketStEth),\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 740000000000000000,\n        maxDepositAmount: 2000000000000000000000000\n    });\n\n    createPoolArray[2] = PoolManager.CreatePool({\n        allowBorrow: false,\n        poolToken: controllerTester.pendleChildAddress(CRVUSD_PENDLE_28MAR_2024),\n        poolMulFactor: 17500000000000000,\n        poolCollFactor: 740000000000000000,\n        maxDepositAmount: 2000000000000000000000000\n    });\n\n    for (uint256 i = 0; i < createPoolArray.length; i++) {\n        wiseLendingInstance.createPool(createPoolArray[i]);\n    }\n\n    powerFarmNftsInstance = new PowerFarmNFTs(\"\", \"\");\n\n    powerFarmManagerInstance = new PendlePowerManager(\n        address(wiseLendingInstance),\n        controllerTester.pendleChildAddress(AddressesMap[chainId].PendleMarketStEth),\n        _pendleRouter,\n        AddressesMap[chainId].entryAssetPendleMarketStEth,\n        AddressesMap[chainId].PendleMarketStEthSy,\n        AddressesMap[chainId].PendleMarketStEth,\n        AddressesMap[chainId].pendleRouterStatic,\n        AddressesMap[chainId].dex,\n        950000000000000000,\n        address(powerFarmNftsInstance)\n    );\n\n    wiseLendingInstance.setVerifiedIsolationPool(address(powerFarmManagerInstance), true);\n\n    vm.stopPrank();\n\n    if (block.chainid == ETH_CHAIN_ID) {\n        address wethWhaleEthMain = 0x8EB8a3b98659Cce290402893d0123abb75E3ab28;\n\n        vm.startPrank(wethWhaleEthMain);\n\n        wethInstance.transfer(wiseLendingInstance.master(), 1000 ether);\n\n        vm.stopPrank();\n    }\n\n    vm.startPrank(wiseLendingInstance.master());\n\n    IERC20(AddressesMap[chainId].weth).approve(address(powerFarmManagerInstance), 1000000 ether);\n\n    wiseSecurityInstance = IWiseSecurity(wiseLendingInstance.WISE_SECURITY());\n\n    positionNftsInstance = IPositionNFTs(wiseLendingInstance.POSITION_NFT());\n}\n\nfunction testCompatibleWithRouter() public {\n    address pendleRouter = 0x0000000001E4ef00d069e71d6bA041b0A16F7eA0;\n    _decideChain(true);\n    _setUpCustom(pendleRouter);\n    _testFarmShouldEnterAndExitIntoToken();\n}\n\nfunction testFail_IncompatibleWithRouterV3() public {\n    address pendleRouterV3 = 0x00000000005BBB0EF59571E58418F9a4357b68A0;\n    _decideChain(true);\n    _setUpCustom(pendleRouterV3);\n    // Reverts with \"RouterInvalidAction\"\n    _testFarmShouldEnterAndExitIntoToken();\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nSupport only the latest router (V3) or add conditional checks to use the respective selector for each router version.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/133#issuecomment-2021111010):**\n > By definition a codebase can never be guaranteed to be compatible with the latest version. Requesting warden to provide evidence lack of integration with V3 achieves M+ severity.\n\n**[NentoR (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/133#issuecomment-2022631151):**\n > @Trust - The reason why I reported this was because the sponsor told me they expect compatibility with both. The problem is that an older version of pendle router is used here and the calls for `addLiquiditySingleSy()` and `removeLiquiditySingleSy()` are basically incompatible with the new one and will revert because of a missing parameter. To understand the rationale behind this submission, let's examine the deployed contracts:\n> \n> [Current router version](https://arbiscan.io/address/0x0000000001E4ef00d069e71d6bA041b0A16F7eA0) (taken from test files).\n>\n> [PendleRouterV3 (latest)](https://arbiscan.io/address/0x00000000005BBB0EF59571E58418F9a4357b68A0).\n> \n> Here's the code for both on Deth.net:\n> [Old router](https://arbiscan.deth.net/address/0xFc0617465474a6b1CA0E37ec4E67B3EEFf93bc63) and [New one](https://arbiscan.deth.net/address/0x00000000005BBB0EF59571E58418F9a4357b68A0).\n> \n> The functions can be found in`ActionAddRemoveLiq` and `ActionAddRemoveLiqV3`\n> \n> Old one:\n> ```solidity\n>   /// @dev swaps SY to PT, then adds liquidity\n>   function _addLiquiditySingleSy(\n>       address receiver,\n>       address market,\n>       IPYieldToken YT,\n>       uint256 netSyIn,\n>       uint256 minLpOut,\n>       ApproxParams calldata guessPtReceivedFromSy\n>   ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n>       MarketState memory state = IPMarket(market).readState(address(this));\n>       // ...\n>   }\n> ```\n> \n> New one:\n>\n><details>\n>\n> ```solidity\n> function addLiquiditySingleToken(\n>     address receiver,\n>     address market,\n>     uint256 minLpOut,\n>     ApproxParams calldata guessPtReceivedFromSy,\n>     TokenInput calldata input,\n>     LimitOrderData calldata limit\n> ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n>     (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n> \n>     netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n> \n>     (netLpOut, netSyFee) = _addLiquiditySingleSy(\n>         receiver,\n>         market,\n>         SY,\n>         YT,\n>         netSyInterm,\n>         minLpOut,\n>         guessPtReceivedFromSy,\n>         limit\n>     );\n>     \n>     // ...\n> }\n> \n> function _addLiquiditySingleSy(\n>     address receiver,\n>     address market,\n>     IStandardizedYield SY,\n>     IPYieldToken YT,\n>     uint256 netSyIn,\n>     uint256 minLpOut,\n>     ApproxParams calldata guessPtReceivedFromSy,\n>     LimitOrderData calldata limit\n> ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n>     uint256 netSyLeft = netSyIn;\n>     uint256 netPtReceived;\n> \n>     if (!_isEmptyLimit(limit)) {\n>         (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n>         _transferOut(address(SY), market, netSyLeft);\n>     }\n> \n>     (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n>         YT.newIndex(),\n>         netSyLeft,\n>         netPtReceived,\n>         block.timestamp,\n>         guessPtReceivedFromSy\n>     );\n>     \n>     // ...\n> }\n> ```\n> \n> `_readMarket()` comes from `ActionBase`, here's it's definition:\n> ```solidity\n>  function _readMarket(address market) internal view returns (MarketState memory) {\n>       return IPMarket(market).readState(address(this));\n>   }\n> ```\n> You can see that both call `readState()` from the underlying Pendle market. Here you can find all market deployments: https://docs.pendle.finance/Developers/Deployments/Arbitrum#markets\n> \n> I'll use the first one for the example.\n> Arbiscan: https://arbiscan.io/address/0x7D49E5Adc0EAAD9C027857767638613253eF125f\n> Deth.net: https://arbiscan.deth.net/address/0x7D49E5Adc0EAAD9C027857767638613253eF125f\n> \n> If you look at the definion of `readState()`, you'll see the following:\n> ```solidity\n> function readState(address router) public view returns (MarketState memory market) {\n>     market.totalPt = _storage.totalPt;\n>     market.totalSy = _storage.totalSy;\n>     market.totalLp = totalSupply().Int();\n> \n>     (market.treasury, market.lnFeeRateRoot, market.reserveFeePercent) = IPMarketFactory(\n>         factory\n>     ).getMarketConfig(router);\n> \n>     market.scalarRoot = scalarRoot;\n>     market.expiry = expiry;\n> \n>     market.lastLnImpliedRate = _storage.lastLnImpliedRate;\n> }\n> ```\n>\n></details>\n>\n> `readState()` on all markets reaches out to the factory contract it was deployed with to grab the market configuration. And there are two versions: `MarketFactory` and `MarketFactoryV3`. Again, both can be found in the docs but here are the links:\n> \n> [MarketFactory](https://arbiscan.io/address/0xf5a7De2D276dbda3EEf1b62A9E718EFf4d29dDC8) and [MarketFactory V3]( https://arbiscan.io/address/0x2FCb47B58350cD377f94d3821e7373Df60bD9Ced).\n> \n> You can take a market from the docs and query `Market::isValidMarket()`. Using the first one, the old factory will return true whereas the new one, false.\n> \n> So basically what this all means is that the protocol won't be able to use new markets. Pendle can start phasing out the old ones and migrating them over. The fix is rather easy on the protocol's end, they just need to account for the newly added parameter and can support both, if they wish, using a conditional check.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/133#issuecomment-2022744919):**\n > @vonMangoldt - can you confirm the warden's claims around your intentions?\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/133#issuecomment-2026828110):**\n > Without sponsor's take the warden's claim that V3 should be compatible with the design is accepted.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/133#issuecomment-2082918149):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/router/ActionAddRemoveLiqV3.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"./base/ActionBase.sol\";\nimport \"../interfaces/IPActionAddRemoveLiqV3.sol\";\n\ncontract ActionAddRemoveLiqV3 is IPActionAddRemoveLiqV3, ActionBase {\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert(\"Slippage: NOT_ALL_SY_USED\");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert(\"Slippage: INSUFFICIENT_LP_OUT\");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert(\"Slippage: INSUFFICIENT_LP_OUT\");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert(\"Slippage: INSUFFICIENT_LP_OUT\");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert(\"Slippage: INSUFFICIENT_LP_OUT\");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert(\"Slippage: INSUFFICIENT_LP_OUT\");\n        if (netYtOut < minYtOut) revert(\"Slippage: INSUFFICIENT_YT_OUT\");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert(\"Slippage: INSUFFICIENT_PT_OUT\");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert(\"Slippage: INSUFFICIENT_SY_OUT\");\n        if (netPtOut < minPtOut) revert(\"Slippage: INSUFFICIENT_PT_OUT\");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert(\"Slippage: INSUFFICIENT_PT_OUT\");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } else {\n            (netSyOut, netSyFee) = __removeLpToSyBeforeExpiry(receiver, market, netLpToRemove, limit);\n        }\n        if (netSyOut < minSyOut) revert(\"Slippage: INSUFFICIENT_SY_OUT\");\n    }\n\n    function __removeLpToSyAfterExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove\n    ) internal returns (uint256 netSyOut) {\n        (, , IPYieldToken YT) = IPMarket(market).readTokens();\n        (uint256 syFromBurn, ) = IPMarket(market).burn(receiver, address(YT), netLpToRemove);\n        netSyOut = syFromBurn + YT.redeemPY(receiver);\n    }\n\n    function __removeLpToSyBeforeExpiry(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        uint256 netPtLeft;\n\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            receiver,\n            _entry_swapExactPtForSy(market, limit),\n            netLpToRemove\n        );\n        netSyOut += netSyOutBurn;\n        netPtLeft += netPtOutBurn;\n\n        (uint256 netSyOutSwap, uint256 netSyFeeSwap) = _swapExactPtForSy(receiver, market, netPtLeft, 0, limit);\n        netSyOut += netSyOutSwap;\n        netSyFee += netSyFeeSwap;\n    }\n}"
    },
    {
      "filename": "contracts/router/ActionAddRemoveLiqV3.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"./base/ActionBase.sol\";\nimport \"../interfaces/IPActionAddRemoveLiqV3.sol\";\n\ncontract ActionAddRemoveLiqV3 is IPActionAddRemoveLiqV3, ActionBase {\n    using PMath for uint256;\n    using PMath for int256;\n    using MarketMathCore for MarketState;\n    using MarketApproxPtInLib for MarketState;\n    using MarketApproxPtOutLib for MarketState;\n    using PYIndexLib for IPYieldToken;\n    using PYIndexLib for PYIndex;\n\n    // ------------------ ADD LIQUIDITY DUAL ------------------\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external payable returns (uint256 netLpOut, uint256 netPtUsed, uint256 netSyInterm) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(market, address(SY), 1, input);\n        uint256 netSyUsed;\n\n        (, , netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(netSyInterm, netPtDesired, block.timestamp);\n\n        if (netSyInterm != netSyUsed) {\n            revert(\"Slippage: NOT_ALL_SY_USED\");\n        }\n\n        // SY has been minted and transferred to the market\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert(\"Slippage: INSUFFICIENT_LP_OUT\");\n\n        emit AddLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netPtUsed,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    ) external returns (uint256 netLpOut, uint256 netSyUsed, uint256 netPtUsed) {\n        (IStandardizedYield SY, IPPrincipalToken PT, ) = IPMarket(market).readTokens();\n\n        // calculate the amount of SY and PT to be used\n        (, netLpOut, netSyUsed, netPtUsed) = _readMarket(market).addLiquidity(\n            netSyDesired,\n            netPtDesired,\n            block.timestamp\n        );\n\n        _transferFrom(SY, msg.sender, market, netSyUsed);\n        _transferFrom(PT, msg.sender, market, netPtUsed);\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyUsed, netPtUsed);\n\n        if (netLpOut < minLpOut) revert(\"Slippage: INSUFFICIENT_LP_OUT\");\n\n        emit AddLiquidityDualSyAndPt(msg.sender, market, receiver, netSyUsed, netPtUsed, netLpOut);\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE PT ------------------\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (, IPPrincipalToken PT, IPYieldToken YT) = IPMarket(market).readTokens();\n        _transferFrom(PT, msg.sender, _entry_addLiquiditySinglePt(market, limit), netPtIn);\n\n        uint256 netPtLeft = netPtIn;\n        uint256 netSyReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netPtLeft, netSyReceived, netSyFee, ) = _fillLimit(market, PT, netPtLeft, limit);\n            _transferOut(address(PT), market, netPtLeft);\n        }\n\n        (uint256 netPtSwapMarket, , ) = _readMarket(market).approxSwapPtToAddLiquidity(\n            YT.newIndex(),\n            netPtLeft,\n            netSyReceived,\n            block.timestamp,\n            guessPtSwapToSy\n        );\n\n        // execute the swap\n        (uint256 netSyOutMarket, uint256 netSyFeeMarket) = IPMarket(market).swapExactPtForSy(\n            market,\n            netPtSwapMarket,\n            EMPTY_BYTES\n        );\n\n        netPtLeft -= netPtSwapMarket;\n        netSyReceived += netSyOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        // execute the addLiquidity\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyReceived, netPtLeft);\n\n        if (netLpOut < minLpOut) revert(\"Slippage: INSUFFICIENT_LP_OUT\");\n\n        emit AddLiquiditySinglePt(msg.sender, market, receiver, netPtIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySinglePt(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN ------------------\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(_entry_addLiquiditySingleSy(market, limit), address(SY), 1, input);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleToken(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netLpOut, uint256 netSyFee) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferFrom(SY, msg.sender, _entry_addLiquiditySingleSy(market, limit), netSyIn);\n\n        (netLpOut, netSyFee) = _addLiquiditySingleSy(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            guessPtReceivedFromSy,\n            limit\n        );\n\n        emit AddLiquiditySingleSy(msg.sender, market, receiver, netSyIn, netLpOut);\n    }\n\n    function _entry_addLiquiditySingleSy(address market, LimitOrderData calldata lim) internal view returns (address) {\n        return !_isEmptyLimit(lim) ? address(this) : market;\n    }\n\n    function _addLiquiditySingleSy(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netLpOut, uint256 netSyFee) {\n        uint256 netSyLeft = netSyIn;\n        uint256 netPtReceived;\n\n        if (!_isEmptyLimit(limit)) {\n            (netSyLeft, netPtReceived, netSyFee, ) = _fillLimit(market, SY, netSyLeft, limit);\n            _transferOut(address(SY), market, netSyLeft);\n        }\n\n        (uint256 netPtOutMarket, , ) = _readMarket(market).approxSwapSyToAddLiquidity(\n            YT.newIndex(),\n            netSyLeft,\n            netPtReceived,\n            block.timestamp,\n            guessPtReceivedFromSy\n        );\n\n        (uint256 netSySwapMarket, uint256 netSyFeeMarket) = IPMarket(market).swapSyForExactPt(\n            market,\n            netPtOutMarket,\n            EMPTY_BYTES\n        );\n\n        netSyLeft -= netSySwapMarket;\n        netPtReceived += netPtOutMarket;\n        netSyFee += netSyFeeMarket;\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyLeft, netPtReceived);\n\n        if (netLpOut < minLpOut) revert(\"Slippage: INSUFFICIENT_LP_OUT\");\n    }\n\n    // ------------------ ADD LIQUIDITY SINGLE TOKEN KEEP YT ------------------\n\n    function addLiquiditySingleTokenKeepYt(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        uint256 minYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy, uint256 netSyInterm) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        netSyInterm = _mintSyFromToken(address(this), address(SY), 1, input);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyInterm,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleTokenKeepYt(\n            msg.sender,\n            market,\n            input.tokenIn,\n            receiver,\n            input.netTokenIn,\n            netLpOut,\n            netYtOut,\n            netSyMintPy,\n            netSyInterm\n        );\n    }\n\n    function addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) external returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        (IStandardizedYield SY, , IPYieldToken YT) = IPMarket(market).readTokens();\n\n        _transferIn(address(SY), msg.sender, netSyIn);\n\n        (netLpOut, netYtOut, netSyMintPy) = _addLiquiditySingleSyKeepYt(\n            receiver,\n            market,\n            SY,\n            YT,\n            netSyIn,\n            minLpOut,\n            minYtOut\n        );\n\n        emit AddLiquiditySingleSyKeepYt(msg.sender, market, receiver, netSyIn, netSyMintPy, netLpOut, netYtOut);\n    }\n\n    function _addLiquiditySingleSyKeepYt(\n        address receiver,\n        address market,\n        IStandardizedYield SY,\n        IPYieldToken YT,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        uint256 minYtOut\n    ) internal returns (uint256 netLpOut, uint256 netYtOut, uint256 netSyMintPy) {\n        MarketState memory state = _readMarket(market);\n\n        PYIndex pyIndex = YT.newIndex();\n\n        netSyMintPy =\n            (netSyIn * state.totalPt.Uint()) /\n            (state.totalPt.Uint() + pyIndex.syToAsset(state.totalSy.Uint()));\n\n        uint256 netSyAddLiquidity = netSyIn - netSyMintPy;\n\n        // transfer SY to mint PY\n        _transferOut(address(SY), address(YT), netSyMintPy);\n\n        // the rest of SY goes to market\n        _transferOut(address(SY), market, netSyAddLiquidity);\n\n        // PT goes to market, YT goes to receiver\n        netYtOut = YT.mintPY(market, receiver);\n\n        (netLpOut, , ) = IPMarket(market).mint(receiver, netSyAddLiquidity, netYtOut);\n\n        if (netLpOut < minLpOut) revert(\"Slippage: INSUFFICIENT_LP_OUT\");\n        if (netYtOut < minYtOut) revert(\"Slippage: INSUFFICIENT_YT_OUT\");\n    }\n\n    // ------------------ REMOVE LIQUIDITY DUAL ------------------\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        // burn LP, SY sent to SY, PT sent to receiver\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netPtOut) = IPMarket(market).burn(address(SY), receiver, netLpToRemove);\n        if (netPtOut < minPtOut) revert(\"Slippage: INSUFFICIENT_PT_OUT\");\n\n        // redeem SY to token\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n        emit RemoveLiquidityDualTokenAndPt(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netPtOut,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netPtOut) = IPMarket(market).burn(receiver, receiver, netLpToRemove);\n\n        if (netSyOut < minSyOut) revert(\"Slippage: INSUFFICIENT_SY_OUT\");\n        if (netPtOut < minPtOut) revert(\"Slippage: INSUFFICIENT_PT_OUT\");\n\n        emit RemoveLiquidityDualSyAndPt(msg.sender, market, receiver, netLpToRemove, netPtOut, netSyOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE PT ------------------\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netPtOut, uint256 netSyFee) {\n        uint256 netSyLeft;\n\n        // execute the burn\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n        (uint256 netSyOutBurn, uint256 netPtOutBurn) = IPMarket(market).burn(\n            _entry_swapExactSyForPt(market, limit),\n            receiver,\n            netLpToRemove\n        );\n        netSyLeft += netSyOutBurn;\n        netPtOut += netPtOutBurn;\n\n        (uint256 netPtOutSwap, uint256 netSyFeeSwap) = _swapExactSyForPt(\n            receiver,\n            market,\n            netSyLeft,\n            0,\n            guessPtReceivedFromSy,\n            limit\n        );\n        netPtOut += netPtOutSwap;\n        netSyFee += netSyFeeSwap;\n\n        if (netPtOut < minPtOut) revert(\"Slippage: INSUFFICIENT_PT_OUT\");\n\n        emit RemoveLiquiditySinglePt(msg.sender, market, receiver, netLpToRemove, netPtOut);\n    }\n\n    // ------------------ REMOVE LIQUIDITY SINGLE TOKEN ------------------\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm) {\n        (IStandardizedYield SY, , ) = IPMarket(market).readTokens();\n\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyInterm, netSyFee) = _removeLiquiditySingleSy(address(SY), market, netLpToRemove, 1, limit);\n\n        netTokenOut = _redeemSyToToken(receiver, address(SY), netSyInterm, output, false);\n\n        emit RemoveLiquiditySingleToken(\n            msg.sender,\n            market,\n            output.tokenOut,\n            receiver,\n            netLpToRemove,\n            netTokenOut,\n            netSyInterm\n        );\n    }\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netSyOut, uint256 netSyFee) {\n        _transferFrom(IERC20(market), msg.sender, market, netLpToRemove);\n\n        (netSyOut, netSyFee) = _removeLiquiditySingleSy(receiver, market, netLpToRemove, minSyOut, limit);\n\n        emit RemoveLiquiditySingleSy(msg.sender, market, receiver, netLpToRemove, netSyOut);\n    }\n\n    // the entry of this will always be market\n    function _removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        LimitOrderData calldata limit\n    ) internal returns (uint256 netSyOut, uint256 netSyFee) {\n        if (IPMarket(market).isExpired()) {\n            netSyOut = __removeLpToSyAfterExpiry(receiver, market, netLpToRemove);\n        } e"
    }
  ]
}