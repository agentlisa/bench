{
  "Title": "[M-02] Attacker contract can avoid being blocked by BlockList.sol",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-08-fiatdao/blob/main/contracts/features/Blocklist.sol#L25\n\n\n# Vulnerability details\n\n## [M-00] Attacker contract can avoid being blocked by BlockList.sol\n### Problem\nTo block an address it must pass the `isContract(address)` check: \nhttps://github.com/code-423n4/2022-08-fiatdao/blob/main/contracts/features/Blocklist.sol#L25\n```\ncontracts/features/Blocklist.sol\n25:         require(_isContract(addr), \"Only contracts\");\n```\nWhich just checks code length at the address provided.\n```\ncontracts/features/Blocklist.sol\n37:     function _isContract(address addr) internal view returns (bool) {\n38:         uint256 size;\n39:         assembly {\n40:             size := extcodesize(addr)\n41:         }\n42:         return size > 0;\n43:     }\n```\nAttacker can interact with the system and selfdestruct his contract, and with help of CREATE2 recreate it at same address when he needs to interact with the system again. \n\n### Proof of concept\nBelow is a simple example of salted contract creation, which you can test against `_isContract(address)` function.\n```solidity\npragma solidity 0.8.15;\n\ncontract BlockList {\n    function _isContract(address addr) external view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}\n\ncontract AttackerContract {\n  function destroy() external {\n    selfdestruct(payable(0));\n  }\n}\n\ncontract AttackerFactory {\n    function deploy() external returns (address) {\n        return address(new AttackerContract{salt: bytes32(\"123\")}());\n    }\n}\n```\n\n### Mitigation\nOne of the goals of Ethereum is for humans and smart contracts to both be treated equally. This leads into a future where smart contracts interact seamlessly with humans and other contracts. It might change in the future , but for now an arbitrary address is ambiguous.\nWe should consider blacklisting addresses without checking if they are contracts.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-fiat-dao-vefdt-contest",
  "Code": [
    {
      "filename": "contracts/features/Blocklist.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport { IVotingEscrow } from \"../interfaces/IVotingEscrow.sol\";\n\n/// @title Blocklist Checker implementation.\n/// @notice Checks if an address is blocklisted\n/// @dev This is a basic implementation using a mapping for address => bool\ncontract Blocklist {\n    mapping(address => bool) private _blocklist;\n    address public manager;\n    address public ve;\n\n    constructor(address _manager, address _ve) {\n        manager = _manager;\n        ve = _ve;\n    }\n\n    /// @notice Add address to blocklist\n    /// @dev only callable by owner.\n    /// @dev Allows blocklisting only of smart contracts\n    /// @param addr The contract address to blocklist\n    function block(address addr) external {\n        require(msg.sender == manager, \"Only manager\");\n        require(_isContract(addr), \"Only contracts\");\n        _blocklist[addr] = true;\n        IVotingEscrow(ve).forceUndelegate(addr);\n    }\n\n    /// @notice Check an address\n    /// @dev This method will be called by the VotingEscrow contract\n    /// @param addr The contract address to check\n    function isBlocked(address addr) public view returns (bool) {\n        return _blocklist[addr];\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}"
    }
  ]
}