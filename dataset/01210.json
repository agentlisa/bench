{
  "Title": "Dutch Orders Without Duration Benefit the Filler",
  "Content": "\n\n\nThe Dutch order implements a [linear decay function](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lib/DutchDecayLib.sol#L26-L48). From `decayStartTime` to `decayEndTime` the amount of input or output tokens goes from `startAmount` (best rate for swapper) to `endAmount` (worst rate the swapper agrees with). \n\n\nHowever, in the current implementation, it is possible to provide the same value for the `decayStartTime` and `decayEndTime` . In this case, the Dutch order is acting like a limit order as the final amount will not change gradually over time. Instead, t[he final amount will be equal to the](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lib/DutchDecayLib.sol#L33-L34) `[endAmount](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lib/DutchDecayLib.sol#L33-L34)`, which ambiguously benefits the filler over the swapper. \n\n\nConsider changing the price of Dutch orders without duration to be equal to the `startAmount` instead of the `endAmount` by swapping [the two `else-if`](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lib/DutchDecayLib.sol#L33-L36) [blocks](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/lib/DutchDecayLib.sol#L33-L36) checking that the timeframe is in favor of the swapper. Alternatively, consider restricting the usage of Dutch orders to actual Dutch orders with a non-zero duration and price decay. \n\n\n\n\n\n***Update:** Resolved in [pull request #194](https://github.com/Uniswap/UniswapX/pull/194) at commit [068076f](https://github.com/Uniswap/UniswapX/commit/068076fc295d07bfdd72ad17012cd03067f87323). Dutch orders with zero duration are now disallowed to avoid this ambiguity.*\n\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/lib/DutchDecayLib.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {OutputToken, InputToken} from \"../base/ReactorStructs.sol\";\nimport {DutchOutput, DutchInput} from \"../lib/DutchOrderLib.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\n\n/// @notice helpers for handling dutch order objects\nlibrary DutchDecayLib {\n    using FixedPointMathLib for uint256;\n\n    /// @notice thrown if the decay direction is incorrect\n    /// - for DutchInput, startAmount must be less than or equal toendAmount\n    /// - for DutchOutput, startAmount must be greater than or equal to endAmount\n    error IncorrectAmounts();\n\n    /// @notice thrown if the endTime of an order is before startTime\n    error EndTimeBeforeStartTime();\n\n    /// @notice calculates an amount using linear decay over time from decayStartTime to decayEndTime\n    /// @dev handles both positive and negative decay depending on startAmount and endAmount\n    /// @param startAmount The amount of tokens at decayStartTime\n    /// @param endAmount The amount of tokens at decayEndTime\n    /// @param decayStartTime The time to start decaying linearly\n    /// @param decayEndTime The time to stop decaying linearly\n    function decay(uint256 startAmount, uint256 endAmount, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (uint256 decayedAmount)\n    {\n        if (decayEndTime < decayStartTime) {\n            revert EndTimeBeforeStartTime();\n        } else if (decayEndTime <= block.timestamp) {\n            decayedAmount = endAmount;\n        } else if (decayStartTime >= block.timestamp) {\n            decayedAmount = startAmount;\n        } else {\n            unchecked {\n                uint256 elapsed = block.timestamp - decayStartTime;\n                uint256 duration = decayEndTime - decayStartTime;\n                if (endAmount < startAmount) {\n                    decayedAmount = startAmount - (startAmount - endAmount).mulDivDown(elapsed, duration);\n                } else {\n                    decayedAmount = startAmount + (endAmount - startAmount).mulDivDown(elapsed, duration);\n                }\n            }\n        }\n    }\n\n    /// @notice returns a decayed output using the given dutch spec and times\n    /// @param output The output to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed output\n    function decay(DutchOutput memory output, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (OutputToken memory result)\n    {\n        if (output.startAmount < output.endAmount) {\n            revert IncorrectAmounts();\n        }\n\n        uint256 decayedOutput = DutchDecayLib.decay(output.startAmount, output.endAmount, decayStartTime, decayEndTime);\n        result = OutputToken(output.token, decayedOutput, output.recipient);\n    }\n\n    /// @notice returns a decayed output array using the given dutch spec and times\n    /// @param outputs The output array to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed output array\n    function decay(DutchOutput[] memory outputs, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (OutputToken[] memory result)\n    {\n        uint256 outputLength = outputs.length;\n        result = new OutputToken[](outputLength);\n        unchecked {\n            for (uint256 i = 0; i < outputLength; i++) {\n                result[i] = decay(outputs[i], decayStartTime, decayEndTime);\n            }\n        }\n    }\n\n    /// @notice returns a decayed input using the given dutch spec and times\n    /// @param input The input to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed input\n    function decay(DutchInput memory input, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (InputToken memory result)\n    {\n        if (input.startAmount > input.endAmount) {\n            revert IncorrectAmounts();\n        }\n\n        uint256 decayedInput = DutchDecayLib.decay(input.startAmount, input.endAmount, decayStartTime, decayEndTime);\n        result = InputToken(input.token, decayedInput, input.endAmount);\n    }\n}"
    },
    {
      "filename": "src/lib/DutchDecayLib.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {OutputToken, InputToken} from \"../base/ReactorStructs.sol\";\nimport {DutchOutput, DutchInput} from \"../lib/DutchOrderLib.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\n\n/// @notice helpers for handling dutch order objects\nlibrary DutchDecayLib {\n    using FixedPointMathLib for uint256;\n\n    /// @notice thrown if the decay direction is incorrect\n    /// - for DutchInput, startAmount must be less than or equal toendAmount\n    /// - for DutchOutput, startAmount must be greater than or equal to endAmount\n    error IncorrectAmounts();\n\n    /// @notice thrown if the endTime of an order is before startTime\n    error EndTimeBeforeStartTime();\n\n    /// @notice calculates an amount using linear decay over time from decayStartTime to decayEndTime\n    /// @dev handles both positive and negative decay depending on startAmount and endAmount\n    /// @param startAmount The amount of tokens at decayStartTime\n    /// @param endAmount The amount of tokens at decayEndTime\n    /// @param decayStartTime The time to start decaying linearly\n    /// @param decayEndTime The time to stop decaying linearly\n    function decay(uint256 startAmount, uint256 endAmount, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (uint256 decayedAmount)\n    {\n        if (decayEndTime < decayStartTime) {\n            revert EndTimeBeforeStartTime();\n        } else if (decayEndTime <= block.timestamp) {\n            decayedAmount = endAmount;\n        } else if (decayStartTime >= block.timestamp) {\n            decayedAmount = startAmount;\n        } else {\n            unchecked {\n                uint256 elapsed = block.timestamp - decayStartTime;\n                uint256 duration = decayEndTime - decayStartTime;\n                if (endAmount < startAmount) {\n                    decayedAmount = startAmount - (startAmount - endAmount).mulDivDown(elapsed, duration);\n                } else {\n                    decayedAmount = startAmount + (endAmount - startAmount).mulDivDown(elapsed, duration);\n                }\n            }\n        }\n    }\n\n    /// @notice returns a decayed output using the given dutch spec and times\n    /// @param output The output to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed output\n    function decay(DutchOutput memory output, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (OutputToken memory result)\n    {\n        if (output.startAmount < output.endAmount) {\n            revert IncorrectAmounts();\n        }\n\n        uint256 decayedOutput = DutchDecayLib.decay(output.startAmount, output.endAmount, decayStartTime, decayEndTime);\n        result = OutputToken(output.token, decayedOutput, output.recipient);\n    }\n\n    /// @notice returns a decayed output array using the given dutch spec and times\n    /// @param outputs The output array to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed output array\n    function decay(DutchOutput[] memory outputs, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (OutputToken[] memory result)\n    {\n        uint256 outputLength = outputs.length;\n        result = new OutputToken[](outputLength);\n        unchecked {\n            for (uint256 i = 0; i < outputLength; i++) {\n                result[i] = decay(outputs[i], decayStartTime, decayEndTime);\n            }\n        }\n    }\n\n    /// @notice returns a decayed input using the given dutch spec and times\n    /// @param input The input to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed input\n    function decay(DutchInput memory input, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (InputToken memory result)\n    {\n        if (input.startAmount > input.endAmount) {\n            revert IncorrectAmounts();\n        }\n\n        uint256 decayedInput = DutchDecayLib.decay(input.startAmount, input.endAmount, decayStartTime, decayEndTime);\n        result = InputToken(input.token, decayedInput, input.endAmount);\n    }\n}"
    },
    {
      "filename": "src/lib/DutchDecayLib.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {OutputToken, InputToken} from \"../base/ReactorStructs.sol\";\nimport {DutchOutput, DutchInput} from \"../lib/DutchOrderLib.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\n\n/// @notice helpers for handling dutch order objects\nlibrary DutchDecayLib {\n    using FixedPointMathLib for uint256;\n\n    /// @notice thrown if the decay direction is incorrect\n    /// - for DutchInput, startAmount must be less than or equal toendAmount\n    /// - for DutchOutput, startAmount must be greater than or equal to endAmount\n    error IncorrectAmounts();\n\n    /// @notice thrown if the endTime of an order is before startTime\n    error EndTimeBeforeStartTime();\n\n    /// @notice calculates an amount using linear decay over time from decayStartTime to decayEndTime\n    /// @dev handles both positive and negative decay depending on startAmount and endAmount\n    /// @param startAmount The amount of tokens at decayStartTime\n    /// @param endAmount The amount of tokens at decayEndTime\n    /// @param decayStartTime The time to start decaying linearly\n    /// @param decayEndTime The time to stop decaying linearly\n    function decay(uint256 startAmount, uint256 endAmount, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (uint256 decayedAmount)\n    {\n        if (decayEndTime < decayStartTime) {\n            revert EndTimeBeforeStartTime();\n        } else if (decayEndTime <= block.timestamp) {\n            decayedAmount = endAmount;\n        } else if (decayStartTime >= block.timestamp) {\n            decayedAmount = startAmount;\n        } else {\n            unchecked {\n                uint256 elapsed = block.timestamp - decayStartTime;\n                uint256 duration = decayEndTime - decayStartTime;\n                if (endAmount < startAmount) {\n                    decayedAmount = startAmount - (startAmount - endAmount).mulDivDown(elapsed, duration);\n                } else {\n                    decayedAmount = startAmount + (endAmount - startAmount).mulDivDown(elapsed, duration);\n                }\n            }\n        }\n    }\n\n    /// @notice returns a decayed output using the given dutch spec and times\n    /// @param output The output to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed output\n    function decay(DutchOutput memory output, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (OutputToken memory result)\n    {\n        if (output.startAmount < output.endAmount) {\n            revert IncorrectAmounts();\n        }\n\n        uint256 decayedOutput = DutchDecayLib.decay(output.startAmount, output.endAmount, decayStartTime, decayEndTime);\n        result = OutputToken(output.token, decayedOutput, output.recipient);\n    }\n\n    /// @notice returns a decayed output array using the given dutch spec and times\n    /// @param outputs The output array to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed output array\n    function decay(DutchOutput[] memory outputs, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (OutputToken[] memory result)\n    {\n        uint256 outputLength = outputs.length;\n        result = new OutputToken[](outputLength);\n        unchecked {\n            for (uint256 i = 0; i < outputLength; i++) {\n                result[i] = decay(outputs[i], decayStartTime, decayEndTime);\n            }\n        }\n    }\n\n    /// @notice returns a decayed input using the given dutch spec and times\n    /// @param input The input to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed input\n    function decay(DutchInput memory input, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (InputToken memory result)\n    {\n        if (input.startAmount > input.endAmount) {\n            revert IncorrectAmounts();\n        }\n\n        uint256 decayedInput = DutchDecayLib.decay(input.startAmount, input.endAmount, decayStartTime, decayEndTime);\n        result = InputToken(input.token, decayedInput, input.endAmount);\n    }\n}"
    }
  ]
}