{
  "Title": "Timestamp usage",
  "Content": "We verified that [the timestamp list included in the HackerGold constructor](https://github.com/ether-camp/virtual-accelerator/blob/2529ffe5efd5294b44f1bc89dc9a4721a7b16409/contracts/HackerGold.sol#L55-L64) correspond to the times stated in comments, and they check.\n\n\nThat said, there’s a problem with using timestamps and `now` (alias for `block.timestamp`) for contract logic, based on the fact that miners can perform some manipulation. In general, [it’s better not to rely on timestamps for contract logic](https://github.com/ConsenSys/smart-contract-best-practices#timestamp-dependence). The solutions is to use `block.number` instead, and approximate dates with expected block heights.\n\n\nGiven the nature of the contract, we think the risk of miner manipulation is really low. The potential damage is also limited: miners could only slightly manipulate price of HKG near the times where it changes (p1, p2, etc.). We recommend the EtherCamp team to consider the potential risk and switch to `block.number` if necessary.\n\n\nFor more info on this topic, see [this stack exchange question](https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp)\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/HackerGold.sol",
      "content": "import \"StandardToken.sol\";\n\npragma solidity ^0.4.0;\n\n/**\n *\n * Hacker gold is the official token of \n * the <hack.ether.camp> hackathon. \n *\n * todo: brief explained\n *\n * Whitepaper https://hack.ether.camp/whitepaper\n *\n */\n /// @title Hacker Gold\ncontract HackerGold is StandardToken {\n\n    \n    string public name = \"HackerGold\";\n\n    /// digits number after the point\n    uint8  public decimals = 3;          \n    string public symbol = \"HKG\";\n    \n    // 1 ether = 200 hkg\n    uint BASE_PRICE = 200;\n    \n    // total value in wei\n    uint totalValue;\n    \n    // multisig holding the value\n    address wallet;\n\n    struct milestones_struct {\n      uint p1;\n      uint p2; \n      uint p3;\n      uint p4;\n      uint p5;\n      uint p6;\n    }\n    milestones_struct milestones;\n    \n    /**\n     * Constructor\n     * \n     * @param multisig address of MultiSig wallet which will hold the value\n     */\n    function HackerGold(address multisig) {\n        \n        wallet = multisig;\n\n        // set time periods for sale\n        milestones = milestones_struct(\n        \n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \n                       //                                Hackathon Starts\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\n        );\n                \n    }\n    \n    \n    /**\n     * Fallback function: called on ether sent\n     */\n    function () payable {\n        createHKG(msg.sender);\n    }\n    \n    /**\n     * Creates HKG tokens\n     * \n     * @param holder token holder\n     */\n    function createHKG(address holder) payable {\n        \n        if (now < milestones.p1) throw;\n        if (now > milestones.p6) throw;\n        if (msg.value == 0) throw;\n    \n        // safety cap\n        if (getTotalValue() + msg.value > 4000000 ether) throw; \n    \n        uint tokens = msg.value / 1000000000000000 * getPrice();\n\n        totalSupply += tokens;\n        balances[holder] += tokens;\n        totalValue += msg.value;\n        \n        if (!wallet.send(msg.value)) throw;\n    }\n    \n    /**\n     * Denotes complete price structure during the sale.\n     *\n     * @return HKG amount per 1 ETH considering current moment in time\n     */\n    function getPrice() constant returns (uint result){\n        \n        if (now < milestones.p1) return 0;\n        \n        if (now >= milestones.p1 && now < milestones.p2){\n        \n            return BASE_PRICE;\n        }\n        \n        if (now >= milestones.p2 && now < milestones.p3){\n            \n        \n            uint days_in = 1 + (now - milestones.p2) / (60 * 60 *24); \n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\n        }\n\n        if (now >= milestones.p3 && now < milestones.p4){\n        \n            return BASE_PRICE / 4 * 3;\n        }\n        \n        if (now >= milestones.p4 && now < milestones.p5){\n            \n            days_in = 1 + (now - milestones.p4) / (60 * 60 *24); \n            return (BASE_PRICE / 4 * 3) - days_in * 25 / 7;  // daily decrease 3.5\n        }\n\n        if (now >= milestones.p5 && now < milestones.p6){\n        \n            return BASE_PRICE / 2;\n        }\n        \n        if (now >= milestones.p6){\n\n            return 0;\n        }\n\n     }\n    \n    /**\n     * Returns total HKG fractions amount (HKG amount * 1000)\n     * Pay attention to decimals variable defining number of digis after the point\n     * \n     * @return result HKG fractions amount\n     */\n    function getTotalSupply() constant returns (uint result){\n        return totalSupply;\n    } \n\n    function getNow() constant returns (uint result) {\n        return now;\n    }\n\n    /**\n     * Returns total value passed through the contract\n     * \n     * @return result total value in wei\n     */\n    function getTotalValue() constant returns (uint result) {\n        return totalValue;  \n    }\n}"
    }
  ]
}