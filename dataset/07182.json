{
  "Title": "[G-23] Setting the _constructor_ to `payable`",
  "Content": "\nYou can cut out 10 opcodes in the creation-time EVM bytecode if you declare a constructor payable. Making the constructor payable eliminates the need for an initial check of ```msg.value == 0``` and saves ```13 gas``` on deployment with no security risks.\n\n8 results - 8 files:\n\n```solidity\npackages\\v2-option\\src\\NoDelegateCall.sol:\n  19:     constructor() {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/NoDelegateCall.sol#L19\n\n\n```solidity\npackages\\v2-option\\src\\TimeswapV2Option.sol:\n  65:     constructor() NoDelegateCall() {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L65\n\n\n```solidity\npackages\\v2-pool\\src\\NoDelegateCall.sol:\n  19:     constructor() {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/NoDelegateCall.sol#L19\n\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2Pool.sol:\n  77:     constructor() NoDelegateCall() {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2Pool.sol#L77\n\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2PoolFactory.sol:\n  37:     constructor(address chosenOwner, uint256 chosenTransactionFee, uint256 chosenProtocolFee) OwnableTwoSteps(chosenOwner) {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2PoolFactory.sol#L37\n\n\n```solidity\npackages\\v2-pool\\src\\base\\OwnableTwoSteps.sol:\n  18:     constructor(address chosenOwner) {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/base/OwnableTwoSteps.sol#L18\n\n\n```solidity\npackages\\v2-token\\src\\TimeswapV2LiquidityToken.sol:\n  36:     constructor(address chosenOptionFactory, address chosenPoolFactory) ERC1155(\"Timeswap V2 uint160 address\") {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2LiquidityToken.sol#L36\n\n```solidity\npackages\\v2-token\\src\\TimeswapV2Token.sol:\n  41:     constructor(address chosenOptionFactory) ERC1155(\"Timeswap V2 address\") {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2Token.sol#L41\n\n\n\n**Recommendation:**\n\nSet the constructor to ```payable```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-option/src/NoDelegateCall.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\n/// @title Prevents delegatecall to a contract\n/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract.\ncontract NoDelegateCall {\n    /* ===== ERROR ===== */\n\n    /// @dev Reverts when called using delegatecall.\n    error CannotBeDelegateCalled();\n\n    /* ===== MODEL ===== */\n\n    /// @dev The original address of this contract.\n    address private immutable original;\n\n    /* ===== INIT ===== */\n\n    constructor() {\n        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\n        // In other words, this variable won't change when it's checked at runtime.\n        original = address(this);\n    }\n\n    /* ===== MODIFIER ===== */\n\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\n    /// and the use of immutable means the address bytes are copied in every place the modifier is used.\n    function checkNotDelegateCall() private view {\n        if (address(this) != original) revert CannotBeDelegateCalled();\n    }\n\n    /// @notice Prevents delegatecall into the modified method\n    modifier noDelegateCall() {\n        checkNotDelegateCall();\n        _;\n    }\n}"
    },
    {
      "filename": "packages/v2-option/src/TimeswapV2Option.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Option} from \"./interfaces/ITimeswapV2Option.sol\";\nimport {ITimeswapV2OptionDeployer} from \"./interfaces/ITimeswapV2OptionDeployer.sol\";\nimport {ITimeswapV2OptionMintCallback} from \"./interfaces/callbacks/ITimeswapV2OptionMintCallback.sol\";\nimport {ITimeswapV2OptionBurnCallback} from \"./interfaces/callbacks/ITimeswapV2OptionBurnCallback.sol\";\nimport {ITimeswapV2OptionSwapCallback} from \"./interfaces/callbacks/ITimeswapV2OptionSwapCallback.sol\";\nimport {ITimeswapV2OptionCollectCallback} from \"./interfaces/callbacks/ITimeswapV2OptionCollectCallback.sol\";\n\nimport {Option, OptionLibrary} from \"./structs/Option.sol\";\nimport {Process, ProcessLibrary} from \"./structs/Process.sol\";\nimport {StrikeAndMaturity} from \"./structs/StrikeAndMaturity.sol\";\n\nimport {TimeswapV2OptionPosition, PositionLibrary} from \"./enums/Position.sol\";\nimport {TimeswapV2OptionMint, TimeswapV2OptionBurn, TimeswapV2OptionSwap, TimeswapV2OptionCollect, TransactionLibrary} from \"./enums/Transaction.sol\";\n\nimport {TimeswapV2OptionMintParam, TimeswapV2OptionBurnParam, TimeswapV2OptionSwapParam, TimeswapV2OptionCollectParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2OptionMintCallbackParam, TimeswapV2OptionBurnCallbackParam, TimeswapV2OptionSwapCallbackParam, TimeswapV2OptionCollectCallbackParam} from \"./structs/CallbackParam.sol\";\n\n/// @title Timeswap V2 Options for a given pair\n/// @author Timeswap Labs\n/// @notice Holds the option of all strikes and maturies.\ncontract TimeswapV2Option is ITimeswapV2Option, NoDelegateCall {\n    using OptionLibrary for Option;\n    using ProcessLibrary for Process[];\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override optionFactory;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token0;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token1;\n\n    /// @dev mapping of all option state for all strikes and maturies.\n    mapping(uint256 => mapping(uint256 => Option)) private options;\n    /// @dev Always start and end as an empty array for every transaction.\n    /// Process the token requirement for every option interaction call.\n    Process[] private processing;\n\n    mapping(uint256 => mapping(uint256 => bool)) private hasInteracted;\n    StrikeAndMaturity[] private listOfOptions;\n\n    function addOptionEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (!hasInteracted[strike][maturity]) {\n            hasInteracted[strike][maturity] = true;\n            listOfOptions.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (optionFactory, token0, token1) = ITimeswapV2OptionDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp() internal view virtual returns (uint96) {\n        return uint96(block.timestamp); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfOptions[id];\n    }\n\n    function numberOfOptions() external view override returns (uint256) {\n        return listOfOptions.length;\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function totalPosition(uint256 strike, uint256 maturity, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].totalPosition(strike, position);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function positionOf(uint256 strike, uint256 maturity, address owner, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].positionOf(owner, position);\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    function transferPosition(uint256 strike, uint256 maturity, address to, TimeswapV2OptionPosition position, uint256 amount) external override {\n        if (!hasInteracted[strike][maturity]) Error.inactiveOptionChoice(strike, maturity);\n        if (to == address(0)) Error.zeroAddress();\n        if (amount == 0) Error.zeroInput();\n        PositionLibrary.check(position);\n\n        options[strike][maturity].transferPosition(to, position, amount);\n\n        emit TransferPosition(strike, maturity, msg.sender, to, position, amount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function mint(\n        TimeswapV2OptionMintParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        ParamLibrary.check(param, blockTimestamp());\n        addOptionEnumerationIfNecessary(param.strike, param.maturity);\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main mint logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.mint(param.strike, param.long0To, param.long1To, param.shortTo, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, true, true);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount\n        ));\n\n        // ask the msg.sender to transfer token0 and/or token1 to this contract.\n        data = ITimeswapV2OptionMintCallback(msg.sender).timeswapV2OptionMintCallback(\n            TimeswapV2OptionMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                shortAmount: shortAmount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 balance target is achieved.\n        if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n\n        // check if the token1 balance target is achieved.\n        if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n\n        // finish the process.\n        processing.pop();\n\n        emit Mint(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function burn(\n        TimeswapV2OptionBurnParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main burn logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.burn(param.strike, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0AndLong0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0AndLong0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1AndLong1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1AndLong1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionBurnCallback(msg.sender).timeswapV2OptionBurnCallback(\n                TimeswapV2OptionBurnCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0AndLong0Amount: token0AndLong0Amount,\n                    token1AndLong1Amount: token1AndLong1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.long0[msg.sender] -= token0AndLong0Amount;\n        option.long1[msg.sender] -= token1AndLong1Amount;\n        option.short[msg.sender] -= shortAmount;\n\n        emit Burn(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function swap(TimeswapV2OptionSwapParam calldata param) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main swap logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount) = option.swap(param.strike, param.longTo, param.isLong0ToLong1, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, !param.isLong0ToLong1, param.isLong0ToLong1);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            param.isLong0ToLong1 ? IERC20(token0).balanceOf(address(this)) - token0AndLong0Amount : IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            param.isLong0ToLong1 ? IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount : IERC20(token1).balanceOf(address(this)) - token1AndLong1Amount\n        ));\n\n        // transfer token to recipient.\n        IERC20(param.isLong0ToLong1 ? token0 : token1).safeTransfer(param.tokenTo, param.isLong0ToLong1 ? token0AndLong0Amount : token1AndLong1Amount);\n\n        // ask the msg.sender to transfer token0 or token1 to this contract.\n        data = ITimeswapV2OptionSwapCallback(msg.sender).timeswapV2OptionSwapCallback(\n            TimeswapV2OptionSwapCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                isLong0ToLong1: param.isLong0ToLong1,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 or token1 balance target is achieved.\n        Error.checkEnough(IERC20(param.isLong0ToLong1 ? token1 : token0).balanceOf(address(this)), param.isLong0ToLong1 ? currentProcess.balance1Target : currentProcess.balance0Target);\n\n        if (param.isLong0ToLong1) option.long0[msg.sender] -= token0AndLong0Amount;\n        else option.long1[msg.sender] -= token1AndLong1Amount;\n\n        // finish the process.\n        processing.pop();\n\n        emit Swap(param.strike, param.maturity, msg.sender, param.tokenTo, param.longTo, param.isLong0ToLong1, token0AndLong0Amount, token1AndLong1Amount);\n    }\n\n    function collect(TimeswapV2OptionCollectParam calldata param) external override noDelegateCall returns (uint256 token0Amount, uint256 token1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main collect logic calculation\n        (token0Amount, token1Amount, shortAmount) = option.collect(param.strike, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0Amount, token1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionCollectCallback(msg.sender).timeswapV2OptionCollectCallback(\n                TimeswapV2OptionCollectCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0Amount: token0Amount,\n                    token1Amount: token1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.short[msg.sender] -= shortAmount;\n\n        emit Collect(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0Amount, token1Amount, shortAmount);\n    }\n}"
    },
    {
      "filename": "packages/v2-pool/src/NoDelegateCall.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\n/// @title Prevents delegatecall to a contract\n/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract.\ncontract NoDelegateCall {\n    /* ===== ERROR ===== */\n\n    /// @dev Reverts when called using delegatecall.\n    error CannotBeDelegateCalled();\n\n    /* ===== MODEL ===== */\n\n    /// @dev The original address of this contract.\n    address private immutable original;\n\n    /* ===== INIT ===== */\n\n    constructor() {\n        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\n        // In other words, this variable won't change when it's checked at runtime.\n        original = address(this);\n    }\n\n    /* ===== MODIFIER ===== */\n\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\n    /// and the use of immutable means the address bytes are copied in every place the modifier is used.\n    function checkNotDelegateCall() private view {\n        if (address(this) != original) revert CannotBeDelegateCalled();\n    }\n\n    /// @notice Prevents delegatecall into the modified method\n    modifier noDelegateCall() {\n        checkNotDelegateCall();\n        _;\n    }\n}"
    },
    {
      "filename": "packages/v2-pool/src/TimeswapV2Pool.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Ownership} from \"@timeswap-labs/v2-library/src/Ownership.sol\";\n\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {TimeswapV2OptionPosition} from \"@timeswap-labs/v2-option/src/enums/Position.sol\";\n\nimport {StrikeAndMaturity} from \"@timeswap-labs/v2-option/src/structs/StrikeAndMaturity.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Pool} from \"./interfaces/ITimeswapV2Pool.sol\";\nimport {ITimeswapV2PoolFactory} from \"./interfaces/ITimeswapV2PoolFactory.sol\";\nimport {ITimeswapV2PoolDeployer} from \"./interfaces/ITimeswapV2PoolDeployer.sol\";\n\nimport {ITimeswapV2PoolMintCallback} from \"./interfaces/callbacks/ITimeswapV2PoolMintCallback.sol\";\nimport {ITimeswapV2PoolBurnCallback, ITimeswapV2PoolBurn2Callback} from \"./interfaces/callbacks/ITimeswapV2PoolBurnCallback.sol\";\nimport {ITimeswapV2PoolDeleverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolDeleverageCallback.sol\";\nimport {ITimeswapV2PoolLeverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolLeverageCallback.sol\";\nimport {ITimeswapV2PoolRebalanceCallback} from \"./interfaces/callbacks/ITimeswapV2PoolRebalanceCallback.sol\";\n\nimport {ReentrancyGuard} from \"./libraries/ReentrancyGuard.sol\";\n\nimport {LiquidityPosition, LiquidityPositionLibrary} from \"./structs/LiquidityPosition.sol\";\n\nimport {Pool, PoolLibrary} from \"./structs/Pool.sol\";\nimport {TimeswapV2PoolCollectParam, TimeswapV2PoolMintParam, TimeswapV2PoolBurnParam, TimeswapV2PoolDeleverageParam, TimeswapV2PoolLeverageParam, TimeswapV2PoolRebalanceParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolMintCallbackParam, TimeswapV2PoolBurnChoiceCallbackParam, TimeswapV2PoolBurnCallbackParam, TimeswapV2PoolDeleverageChoiceCallbackParam, TimeswapV2PoolDeleverageCallbackParam, TimeswapV2PoolLeverageCallbackParam, TimeswapV2PoolLeverageChoiceCallbackParam, TimeswapV2PoolRebalanceCallbackParam} from \"./structs/CallbackParam.sol\";\n\nimport {TimeswapV2PoolMint, TimeswapV2PoolBurn, TimeswapV2PoolDeleverage, TimeswapV2PoolLeverage, TimeswapV2PoolRebalance, TransactionLibrary} from \"./enums/Transaction.sol\";\n\ncontract TimeswapV2Pool is ITimeswapV2Pool, NoDelegateCall {\n    using PoolLibrary for Pool;\n    using Ownership for address;\n    using LiquidityPositionLibrary for LiquidityPosition;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override poolFactory;\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override optionPair;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override transactionFee;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override protocolFee;\n\n    mapping(uint256 => mapping(uint256 => uint96)) private reentrancyGuards;\n    mapping(uint256 => mapping(uint256 => Pool)) private pools;\n\n    StrikeAndMaturity[] private listOfPools;\n\n    function addPoolEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (reentrancyGuards[strike][maturity] == ReentrancyGuard.NOT_INTERACTED) {\n            reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n            listOfPools.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== MODIFIER ===== */\n\n    function raiseGuard(uint256 strike, uint256 maturity) private {\n        ReentrancyGuard.check(reentrancyGuards[strike][maturity]);\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.ENTERED;\n    }\n\n    function lowerGuard(uint256 strike, uint256 maturity) private {\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (poolFactory, optionPair, transactionFee, protocolFee) = ITimeswapV2PoolDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp(uint96 durationForward) internal view virtual returns (uint96) {\n        return uint96(block.timestamp + durationForward); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfPools[id];\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function numberOfPools() external view override returns (uint256) {\n        return listOfPools.length;\n    }\n\n    function hasLiquidity(uint256 strike, uint256 maturity) private view {\n        if (pools[strike][maturity].liquidity == 0) Error.requireLiquidity();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLiquidity(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function sqrtInterestRate(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].sqrtInterestRate;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function liquidityOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint160) {\n        return pools[strike][maturity].liquidityPositions[owner].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feeGrowth(uint256 strike, uint256 maturity) external view override returns (uint256 long0FeeGrowth, uint256 long1FeeGrowth, uint256 shortFeeGrowth) {\n        return pools[strike][maturity].feeGrowth();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feesEarnedOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) {\n        return pools[strike][maturity].feesEarnedOf(owner);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function protocolFeesEarned(uint256 strike, uint256 maturity) external view override returns (uint256 long0ProtocolFees, uint256 long1ProtocolFees, uint256 shortProtocolFees) {\n        return pools[strike][maturity].protocolFeesEarned();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLongBalance(uint256 strike, uint256 maturity) external view override returns (uint256 long0Amount, uint256 long1Amount) {\n        Pool storage pool = pools[strike][maturity];\n        long0Amount = pool.long0Balance;\n        long1Amount = pool.long1Balance;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLongBalanceAdjustFees(uint256 strike, uint256 maturity) external view override returns (uint256 long0Amount, uint256 long1Amount) {\n        (long0Amount, long1Amount) = pools[strike][maturity].totalLongBalanceAdjustFees(transactionFee);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalPositions(uint256 strike, uint256 maturity) external view override returns (uint256 longAmount, uint256 shortAmount) {\n        (longAmount, shortAmount) = pools[strike][maturity].totalPositions(maturity, blockTimestamp(0));\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    function transferLiquidity(uint256 strike, uint256 maturity, address to, uint160 liquidityAmount) external override {\n        hasLiquidity(strike, maturity);\n\n        if (blockTimestamp(0) > maturity) Error.alreadyMatured(maturity, blockTimestamp(0));\n        if (to == address(0)) Error.zeroAddress();\n        if (liquidityAmount == 0) Error.zeroInput();\n\n        pools[strike][maturity].transferLiquidity(to, liquidityAmount, blockTimestamp(0));\n\n        emit TransferLiquidity(strike, maturity, msg.sender, to, liquidityAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function transferFees(uint256 strike, uint256 maturity, address to, uint256 long0Fees, uint256 long1Fees, uint256 shortFees) external override {\n        if (to == address(0)) Error.zeroAddress();\n        if (long0Fees == 0 && long1Fees == 0 && shortFees == 0) Error.zeroInput();\n\n        pools[strike][maturity].transferFees(maturity, to, long0Fees, long1Fees, shortFees, blockTimestamp(0));\n\n        emit TransferFees(strike, maturity, msg.sender, to, long0Fees, long1Fees, shortFees);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function initialize(uint256 strike, uint256 maturity, uint160 rate) external override noDelegateCall {\n        if (maturity < blockTimestamp(0)) Error.alreadyMatured(maturity, blockTimestamp(0));\n        if (rate == 0) Error.cannotBeZero();\n        addPoolEnumerationIfNecessary(strike, maturity);\n\n        pools[strike][maturity].initialize(rate);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function collectProtocolFees(TimeswapV2PoolCollectParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        ParamLibrary.check(param);\n        raiseGuard(param.strike, param.maturity);\n\n        // Can only be called by the TimeswapV2Pool factory owner.\n        ITimeswapV2PoolFactory(poolFactory).owner().checkIfOwner();\n\n        // Calculate the main logic of protocol fee.\n        (long0Amount, long1Amount, shortAmount) = pools[param.strike][param.maturity].collectProtocolFees(param.long0Requested, param.long1Requested, param.shortRequested);\n\n        collect(param.strike, param.maturity, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit CollectProtocolFees(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function collectTransactionFees(TimeswapV2PoolCollectParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        ParamLibrary.check(param);\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of transaction fee.\n        (long0Amount, long1Amount, shortAmount) = pools[param.strike][param.maturity].collectTransactionFees(\n            param.maturity,\n            param.long0Requested,\n            param.long1Requested,\n            param.shortRequested,\n            blockTimestamp(0)\n        );\n\n        collect(param.strike, param.maturity, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit CollectTransactionFee(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @dev Transfer long0 positions, long1 positions, and/or short positions to the receipients.\n    /// @param strike The strike price of the pool.\n    /// @param maturity The maturity of the pool.\n    /// @param long0To The receipient of long0 positions.\n    /// @param long1To The receipient of long1 positions.\n    /// @param shortTo The receipient of short positions.\n    /// @param long0Amount The amount of long0 positions wanted.\n    /// @param long1Amount The amount of long1 positions wanted.\n    /// @param shortAmount The amount of short positions wanted.\n    function collect(uint256 strike, uint256 maturity, address long0To, address long1To, address shortTo, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) private {\n        if (long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, long0To, TimeswapV2OptionPosition.Long0, long0Amount);\n\n        if (long1Amount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, long1To, TimeswapV2OptionPosition.Long1, long1Amount);\n\n        if (shortAmount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, shortTo, TimeswapV2OptionPosition.Short, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function mint(TimeswapV2PoolMintParam calldata param) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return mint(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function mint(\n        TimeswapV2PoolMintParam calldata param,\n        uint96 durationForward\n    ) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return mint(param, true, durationForward);\n    }\n\n    function mint(\n        TimeswapV2PoolMintParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of mint function.\n        (liquidityAmount, long0Amount, long1Amount, shortAmount, data) = pools[param.strike][param.maturity].mint(param, blockTimestamp(durationForward));\n\n        // Calculate the amount of long0 position, long1 position, and short position required by the pool.\n\n        // long0Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long0BalanceTarget;\n        if (long0Amount != 0) long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + long0Amount;\n\n        // long1Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long1BalanceTarget;\n        if (long1Amount != 0) long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + long1Amount;\n\n        // shortAmount cannot be zero.\n        uint256 shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + shortAmount;\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolMintCallback(msg.sender).timeswapV2PoolMintCallback(\n            TimeswapV2PoolMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Amount: long0Amount,\n                long1Amount: long1Amount,\n                shortAmount: shortAmount,\n                liquidityAmount: liquidityAmount,\n                data: data\n            })\n        );\n\n        if (isQuote) revert Quote();\n\n        // Check when the position balance targets are reached.\n\n        if (long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n        if (long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n        Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Mint(param.strike, param.maturity, msg.sender, param.to, liquidityAmount, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function burn(TimeswapV2PoolBurnParam calldata param) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return burn(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function burn(\n        TimeswapV2PoolBurnParam calldata param,\n        uint96 durationForward\n    ) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return burn(param, true, durationForward);\n    }\n\n    function burn(\n        Time"
    }
  ]
}