{
  "Title": "[M-02] If DAO updates `forkEscrow` before `forkThreshold` is reached, the user's escrowed Nouns will be lost",
  "Content": "\nDuring the escrow period, users can escrow to or withdraw from forkEscrow their Nouns.\n\nDuring the escrow period, proposals can be executed.\n\n```solidity\n    function withdrawFromForkEscrow(NounsDAOStorageV3.StorageV3 storage ds, uint256[] calldata tokenIds) external {\n        if (isForkPeriodActive(ds)) revert ForkPeriodActive();\n\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n        forkEscrow.returnTokensToOwner(msg.sender, tokenIds);\n\n        emit WithdrawFromForkEscrow(forkEscrow.forkId(), msg.sender, tokenIds);\n    }\n```\n\nSince withdrawFromForkEscrow will only call the returnTokensToOwner function of ds.forkEscrow, and returnTokensToOwner is only allowed to be called by DAO.\n\nIf, during the escrow period, ds.forkEscrow is changed by the proposal's call to \\_setForkEscrow, then the user's escrowed Nouns will not be withdrawn by withdrawFromForkEscrow.\n\n```solidity\n    function returnTokensToOwner(address owner, uint256[] calldata tokenIds) external onlyDAO {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            if (currentOwnerOf(tokenIds[i]) != owner) revert NotOwner();\n\n            nounsToken.transferFrom(address(this), owner, tokenIds[i]);\n            escrowedTokensByForkId[forkId][tokenIds[i]] = address(0);\n        }\n\n        numTokensInEscrow -= tokenIds.length;\n    }\n```\n\nConsider that some Nouners is voting on a proposal that would change ds.forkEscrow.<br>\nThere are some escrowed Nouns in forkEscrow (some Nouners may choose to always escrow their Nouns to avoid missing fork).<br>\nThe proposal is executed, ds.forkEscrow is updated, and the escrowed Nouns cannot be withdrawn.\n\n### Proof of Concept\n\n<https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol#L95-L102><br>\n<https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/NounsDAOForkEscrow.sol#L116-L125><br>\n<https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol#L527-L531>\n\n### Recommended Mitigation Steps\n\nConsider allowing the user to call forkEscrow\\.returnTokensToOwner directly to withdraw escrowed Nouns, and need to move isForkPeriodActive from withdrawFromForkEscrow to returnTokensToOwner.\n\n**[eladmallel (Nouns DAO) acknowledged](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/56#issuecomment-1650607685)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-nounsdao",
  "Code": [
    {
      "filename": "packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title Library for NounsDAOLogicV3 contract containing the dao fork logic\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.19;\n\nimport { NounsDAOStorageV3, INounsDAOForkEscrow, INounsDAOExecutorV2 } from '../NounsDAOInterfaces.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { NounsTokenFork } from './newdao/token/NounsTokenFork.sol';\n\nlibrary NounsDAOV3Fork {\n    error ForkThresholdNotMet();\n    error ForkPeriodNotActive();\n    error ForkPeriodActive();\n    error AdminOnly();\n    error UseAlternativeWithdrawFunction();\n\n    /// @notice Emitted when someones adds nouns to the fork escrow\n    event EscrowedToFork(\n        uint32 indexed forkId,\n        address indexed owner,\n        uint256[] tokenIds,\n        uint256[] proposalIds,\n        string reason\n    );\n\n    /// @notice Emitted when the owner withdraws their nouns from the fork escrow\n    event WithdrawFromForkEscrow(uint32 indexed forkId, address indexed owner, uint256[] tokenIds);\n\n    /// @notice Emitted when the fork is executed and the forking period begins\n    event ExecuteFork(\n        uint32 indexed forkId,\n        address forkTreasury,\n        address forkToken,\n        uint256 forkEndTimestamp,\n        uint256 tokensInEscrow\n    );\n\n    /// @notice Emitted when someone joins a fork during the forking period\n    event JoinFork(\n        uint32 indexed forkId,\n        address indexed owner,\n        uint256[] tokenIds,\n        uint256[] proposalIds,\n        string reason\n    );\n\n    /// @notice Emitted when the DAO withdraws nouns from the fork escrow after a fork has been executed\n    event DAOWithdrawNounsFromEscrow(uint256[] tokenIds, address to);\n\n    /// @notice Emitted when withdrawing nouns from escrow increases adjusted total supply\n    event DAONounsSupplyIncreasedFromEscrow(uint256 numTokens, address to);\n\n    /**\n     * @notice Escrow Nouns to contribute to the fork threshold\n     * @dev Requires approving the tokenIds or the entire noun token to the DAO contract\n     * @param tokenIds the tokenIds to escrow. They will be sent to the DAO once the fork threshold is reached and the escrow is closed.\n     * @param proposalIds array of proposal ids which are the reason for wanting to fork. This will only be used to emit event.\n     * @param reason the reason for want to fork. This will only be used to emit event.\n     */\n    function escrowToFork(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256[] calldata tokenIds,\n        uint256[] calldata proposalIds,\n        string calldata reason\n    ) external {\n        if (isForkPeriodActive(ds)) revert ForkPeriodActive();\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ds.nouns.safeTransferFrom(msg.sender, address(forkEscrow), tokenIds[i]);\n        }\n\n        emit EscrowedToFork(forkEscrow.forkId(), msg.sender, tokenIds, proposalIds, reason);\n    }\n\n    /**\n     * @notice Withdraw Nouns from the fork escrow. Only possible if the fork has not been executed.\n     * Only allowed to withdraw tokens that the sender has escrowed.\n     * @param tokenIds the tokenIds to withdraw\n     */\n    function withdrawFromForkEscrow(NounsDAOStorageV3.StorageV3 storage ds, uint256[] calldata tokenIds) external {\n        if (isForkPeriodActive(ds)) revert ForkPeriodActive();\n\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n        forkEscrow.returnTokensToOwner(msg.sender, tokenIds);\n\n        emit WithdrawFromForkEscrow(forkEscrow.forkId(), msg.sender, tokenIds);\n    }\n\n    /**\n     * @notice Execute the fork. Only possible if the fork threshold has been exceeded.\n     * This will deploy a new DAO and send the prorated part of the treasury to the new DAO's treasury.\n     * This will also close the active escrow and all nouns in the escrow will belong to the original DAO.\n     * @return forkTreasury The address of the new DAO's treasury\n     * @return forkToken The address of the new DAO's token\n     */\n    function executeFork(NounsDAOStorageV3.StorageV3 storage ds)\n        external\n        returns (address forkTreasury, address forkToken)\n    {\n        if (isForkPeriodActive(ds)) revert ForkPeriodActive();\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n\n        uint256 tokensInEscrow = forkEscrow.numTokensInEscrow();\n        if (tokensInEscrow <= forkThreshold(ds)) revert ForkThresholdNotMet();\n\n        uint256 forkEndTimestamp = block.timestamp + ds.forkPeriod;\n\n        (forkTreasury, forkToken) = ds.forkDAODeployer.deployForkDAO(forkEndTimestamp, forkEscrow);\n        sendProRataTreasury(ds, forkTreasury, tokensInEscrow, adjustedTotalSupply(ds));\n        uint32 forkId = forkEscrow.closeEscrow();\n\n        ds.forkDAOTreasury = forkTreasury;\n        ds.forkDAOToken = forkToken;\n        ds.forkEndTimestamp = forkEndTimestamp;\n\n        emit ExecuteFork(forkId, forkTreasury, forkToken, forkEndTimestamp, tokensInEscrow);\n    }\n\n    /**\n     * @notice Joins a fork while a fork is active\n     * Sends the tokens to the timelock contract.\n     * Sends a prorated part of the treasury to the new fork DAO's treasury.\n     * Mints new tokens in the new fork DAO with the same token ids.\n     * @param tokenIds the tokenIds to send to the DAO in exchange for joining the fork\n     */\n    function joinFork(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256[] calldata tokenIds,\n        uint256[] calldata proposalIds,\n        string calldata reason\n    ) external {\n        if (!isForkPeriodActive(ds)) revert ForkPeriodNotActive();\n\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n        address timelock = address(ds.timelock);\n        sendProRataTreasury(ds, ds.forkDAOTreasury, tokenIds.length, adjustedTotalSupply(ds));\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ds.nouns.transferFrom(msg.sender, timelock, tokenIds[i]);\n        }\n\n        NounsTokenFork(ds.forkDAOToken).claimDuringForkPeriod(msg.sender, tokenIds);\n\n        emit JoinFork(forkEscrow.forkId() - 1, msg.sender, tokenIds, proposalIds, reason);\n    }\n\n    /**\n     * @notice Withdraws nouns from the fork escrow to the treasury after the fork has been executed\n     * @dev Only the DAO can call this function\n     * @param tokenIds the tokenIds to withdraw\n     */\n    function withdrawDAONounsFromEscrowToTreasury(NounsDAOStorageV3.StorageV3 storage ds, uint256[] calldata tokenIds)\n        external\n    {\n        withdrawDAONounsFromEscrow(ds, tokenIds, address(ds.timelock));\n    }\n\n    /**\n     * @notice Withdraws nouns from the fork escrow after the fork has been executed to an address other than the treasury\n     * @dev Only the DAO can call this function\n     * @param tokenIds the tokenIds to withdraw\n     * @param to the address to send the nouns to\n     */\n    function withdrawDAONounsFromEscrowIncreasingTotalSupply(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256[] calldata tokenIds,\n        address to\n    ) external {\n        if (to == address(ds.timelock)) revert UseAlternativeWithdrawFunction();\n\n        withdrawDAONounsFromEscrow(ds, tokenIds, to);\n\n        emit DAONounsSupplyIncreasedFromEscrow(tokenIds.length, to);\n    }\n\n    function withdrawDAONounsFromEscrow(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256[] calldata tokenIds,\n        address to\n    ) private {\n        if (msg.sender != ds.admin) {\n            revert AdminOnly();\n        }\n\n        ds.forkEscrow.withdrawTokens(tokenIds, to);\n\n        emit DAOWithdrawNounsFromEscrow(tokenIds, to);\n    }\n\n    /**\n     * @notice Returns the required number of tokens to escrow to trigger a fork\n     */\n    function forkThreshold(NounsDAOStorageV3.StorageV3 storage ds) public view returns (uint256) {\n        return (adjustedTotalSupply(ds) * ds.forkThresholdBPS) / 10_000;\n    }\n\n    /**\n     * @notice Returns the number of tokens currently in escrow, contributing to the fork threshold\n     */\n    function numTokensInForkEscrow(NounsDAOStorageV3.StorageV3 storage ds) public view returns (uint256) {\n        return ds.forkEscrow.numTokensInEscrow();\n    }\n\n    /**\n     * @notice Returns the number of nouns in supply minus nouns owned by the DAO, i.e. held in the treasury or in an\n     * escrow after it has closed.\n     * This is used when calculating proposal threshold, quorum, fork threshold & treasury split.\n     */\n    function adjustedTotalSupply(NounsDAOStorageV3.StorageV3 storage ds) internal view returns (uint256) {\n        return ds.nouns.totalSupply() - ds.nouns.balanceOf(address(ds.timelock)) - ds.forkEscrow.numTokensOwnedByDAO();\n    }\n\n    /**\n     * @notice Returns true if noun holders can currently join a fork\n     */\n    function isForkPeriodActive(NounsDAOStorageV3.StorageV3 storage ds) internal view returns (bool) {\n        return ds.forkEndTimestamp > block.timestamp;\n    }\n\n    /**\n     * @notice Sends part of the DAO's treasury to the `newDAOTreasury` address.\n     * The amount sent is proportional to the `tokenCount` out of `totalSupply`.\n     * Sends ETH and ERC20 tokens listed in `ds.erc20TokensToIncludeInFork`.\n     */\n    function sendProRataTreasury(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        address newDAOTreasury,\n        uint256 tokenCount,\n        uint256 totalSupply\n    ) internal {\n        INounsDAOExecutorV2 timelock = ds.timelock;\n        uint256 ethToSend = (address(timelock).balance * tokenCount) / totalSupply;\n\n        timelock.sendETH(newDAOTreasury, ethToSend);\n\n        uint256 erc20Count = ds.erc20TokensToIncludeInFork.length;\n        for (uint256 i = 0; i < erc20Count; ++i) {\n            IERC20 erc20token = IERC20(ds.erc20TokensToIncludeInFork[i]);\n            uint256 tokensToSend = (erc20token.balanceOf(address(timelock)) * tokenCount) / totalSupply;\n            if (tokensToSend > 0) {\n                timelock.sendERC20(newDAOTreasury, address(erc20token), tokensToSend);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "packages/nouns-contracts/contracts/governance/fork/NounsDAOForkEscrow.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title Escrow contract for Nouns to be used to trigger a fork\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.19;\n\nimport { NounsTokenLike } from '../NounsDAOInterfaces.sol';\nimport { IERC721Receiver } from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\n\ncontract NounsDAOForkEscrow is IERC721Receiver {\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   ERRORS\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    error OnlyDAO();\n    error OnlyNounsToken();\n    error NotOwner();\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   IMMUTABLES\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    /// @notice Nouns governance contract\n    address public immutable dao;\n\n    /// @notice Nouns token contract\n    NounsTokenLike public immutable nounsToken;\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   STORAGE VARIABLES\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    /// @notice Current fork id\n    uint32 public forkId;\n\n    /// @notice A mapping of which owner escrowed which token for which fork.\n    /// Later used in order to claim tokens in a forked DAO.\n    /// @dev forkId => tokenId => owner\n    mapping(uint32 => mapping(uint256 => address)) public escrowedTokensByForkId;\n\n    /// @notice Number of tokens in escrow in the current fork contributing to the fork threshold. They can be unescrowed.\n    uint256 public numTokensInEscrow;\n\n    constructor(address dao_, address nounsToken_) {\n        dao = dao_;\n        nounsToken = NounsTokenLike(nounsToken_);\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   MODIFIERS\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    modifier onlyDAO() {\n        if (msg.sender != dao) {\n            revert OnlyDAO();\n        }\n        _;\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   PUBLIC/EXTERNAL OnlyDAO Txs\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    /**\n     * @notice Escrows nouns tokens\n     * @dev Can only be called by the Nouns token contract, and initiated by the DAO contract\n     * @param operator The address which called the `safeTransferFrom` function, can only be the DAO contract\n     * @param from The address which previously owned the token\n     * @param tokenId The id of the token being escrowed\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory\n    ) public override returns (bytes4) {\n        if (msg.sender != address(nounsToken)) revert OnlyNounsToken();\n        if (operator != dao) revert OnlyDAO();\n\n        escrowedTokensByForkId[forkId][tokenId] = from;\n\n        numTokensInEscrow++;\n\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    /**\n     * @notice Unescrows nouns tokens\n     * @dev Can only be called by the DAO contract\n     * @param owner The address which asks to unescrow, must be the address which escrowed the tokens\n     * @param tokenIds The ids of the tokens being unescrowed\n     */\n    function returnTokensToOwner(address owner, uint256[] calldata tokenIds) external onlyDAO {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            if (currentOwnerOf(tokenIds[i]) != owner) revert NotOwner();\n\n            nounsToken.transferFrom(address(this), owner, tokenIds[i]);\n            escrowedTokensByForkId[forkId][tokenIds[i]] = address(0);\n        }\n\n        numTokensInEscrow -= tokenIds.length;\n    }\n\n    /**\n     * @notice Closes the escrow, and increments the fork id. Once the escrow is closed, all the escrowed tokens\n     * can no longer be unescrowed by the owner, but can be withdrawn by the DAO.\n     * @dev Can only be called by the DAO contract\n     * @return closedForkId The fork id which was closed\n     */\n    function closeEscrow() external onlyDAO returns (uint32 closedForkId) {\n        numTokensInEscrow = 0;\n\n        closedForkId = forkId;\n\n        forkId++;\n    }\n\n    /**\n     * @notice Withdraws nouns tokens to the DAO\n     * @dev Can only be called by the DAO contract\n     * @param tokenIds The ids of the tokens being withdrawn\n     * @param to The address which will receive the tokens\n     */\n    function withdrawTokens(uint256[] calldata tokenIds, address to) external onlyDAO {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            if (currentOwnerOf(tokenIds[i]) != dao) revert NotOwner();\n\n            nounsToken.transferFrom(address(this), to, tokenIds[i]);\n        }\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   VIEW FUNCTIONS\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    /**\n     * @notice Returns the number of tokens owned by the DAO, excluding the ones in escrow\n     */\n    function numTokensOwnedByDAO() external view returns (uint256) {\n        return nounsToken.balanceOf(address(this)) - numTokensInEscrow;\n    }\n\n    /**\n     * @notice Returns the original owner of a token, when it was escrowed\n     * @param forkId_ The fork id in which the token was escrowed\n     * @param tokenId The id of the token\n     * @return The address of the original owner, or address(0) if not found\n     */\n    function ownerOfEscrowedToken(uint32 forkId_, uint256 tokenId) external view returns (address) {\n        return escrowedTokensByForkId[forkId_][tokenId];\n    }\n\n    /**\n     * @notice Returns the current owner of a token, either the DAO or the account which escrowed it.\n     * If the token is currently in an active escrow, the original owner is still the owner.\n     * Otherwise, the DAO can withdraw it.\n     * @param tokenId The id of the token\n     * @return The address of the current owner, either the original owner or the address of the dao\n     */\n    function currentOwnerOf(uint256 tokenId) public view returns (address) {\n        address owner = escrowedTokensByForkId[forkId][tokenId];\n        if (owner == address(0)) {\n            return dao;\n        } else {\n            return owner;\n        }\n    }\n}"
    },
    {
      "filename": "packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title Library for NounsDAOLogicV3 contract containing admin related functions\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.19;\n\nimport './NounsDAOInterfaces.sol';\nimport { NounsDAOV3DynamicQuorum } from './NounsDAOV3DynamicQuorum.sol';\n\nlibrary NounsDAOV3Admin {\n    using NounsDAOV3DynamicQuorum for NounsDAOStorageV3.StorageV3;\n\n    error AdminOnly();\n    error VetoerOnly();\n    error PendingVetoerOnly();\n    error InvalidMinQuorumVotesBPS();\n    error InvalidMaxQuorumVotesBPS();\n    error MinQuorumBPSGreaterThanMaxQuorumBPS();\n    error ForkPeriodTooLong();\n    error ForkPeriodTooShort();\n    error InvalidObjectionPeriodDurationInBlocks();\n    error InvalidProposalUpdatablePeriodInBlocks();\n    error VoteSnapshotSwitchAlreadySet();\n    error DuplicateTokenAddress();\n\n    /// @notice Emitted when proposal threshold basis points is set\n    event ProposalThresholdBPSSet(uint256 oldProposalThresholdBPS, uint256 newProposalThresholdBPS);\n\n    /// @notice An event emitted when the voting delay is set\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n\n    /// @notice An event emitted when the voting period is set\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n\n    /// @notice An event emitted when the objection period duration is set\n    event ObjectionPeriodDurationSet(\n        uint32 oldObjectionPeriodDurationInBlocks,\n        uint32 newObjectionPeriodDurationInBlocks\n    );\n\n    /// @notice An event emitted when the objection period last minute window is set\n    event LastMinuteWindowSet(uint32 oldLastMinuteWindowInBlocks, uint32 newLastMinuteWindowInBlocks);\n\n    /// @notice An event emitted when the proposal updatable period is set\n    event ProposalUpdatablePeriodSet(\n        uint32 oldProposalUpdatablePeriodInBlocks,\n        uint32 newProposalUpdatablePeriodInBlocks\n    );\n\n    /// @notice Emitted when pendingAdmin is changed\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /// @notice Emitted when pendingVetoer is changed\n    event NewPendingVetoer(address oldPendingVetoer, address newPendingVetoer);\n\n    /// @notice Emitted when vetoer is changed\n    event NewVetoer(address oldVetoer, address newVetoer);\n\n    /// @notice Emitted when minQuorumVotesBPS is set\n    event MinQuorumVotesBPSSet(uint16 oldMinQuorumVotesBPS, uint16 newMinQuorumVotesBPS);\n\n    /// @notice Emitted when maxQuorumVotesBPS is set\n    event MaxQuorumVotesBPSSet(uint16 oldMaxQuorumVotesBPS, uint16 newMaxQuorumVotesBPS);\n\n    /// @notice Emitted when quorumCoefficient is set\n    event QuorumCoefficientSet(uint32 oldQuorumCoefficient, uint32 newQuorumCoefficient);\n\n    /// @notice Emitted when admin withdraws the DAO's balance.\n    event Withdraw(uint256 amount, bool sent);\n\n    /// @notice Emitted when the proposal id at which vote snapshot block changes is set\n    event VoteSnapshotBlockSwitchProposalIdSet(\n        uint256 oldVoteSnapshotBlockSwitchProposalId,\n        uint256 newVoteSnapshotBlockSwitchProposalId\n    );\n\n    /// @notice Emitted when the fork DAO deployer is set\n    event ForkDAODeployerSet(address oldForkDAODeployer, address newForkDAODeployer);\n\n    /// @notice Emitted when the erc20 tokens to include in a fork are set\n    event ERC20TokensToIncludeInForkSet(address[] oldErc20Tokens, address[] newErc20tokens);\n\n    /// @notice Emitted when the fork escrow contract address is set\n    event ForkEscrowSet(address oldForkEscrow, address newForkEscrow);\n\n    /// @notice Emitted when the during of the forking period is set\n    event ForkPeriodSet(uint256 oldForkPeriod, uint256 newForkPeriod);\n\n    /// @notice Emitted when the threhsold for forking is set\n    event ForkThresholdSet(uint256 oldForkThreshold, uint256 newForkThreshold);\n\n    /// @notice Emitted when the main timelock, timelockV1 and admin are set\n    event TimelocksAndAdminSet(address timelock, address timelockV1, address admin);\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\n\n    /// @notice The minimum setable voting period in blocks\n    uint256 public constant MIN_VOTING_PERIOD_BLOCKS = 1 days / 12;\n\n    /// @notice The max setable voting period in blocks\n    uint256 public constant MAX_VOTING_PERIOD_BLOCKS = 2 weeks / 12;\n\n    /// @notice The min setable voting delay in blocks\n    uint256 public constant MIN_VOTING_DELAY_BLOCKS = 1;\n\n    /// @notice The max setable voting delay in blocks\n    uint256 public constant MAX_VOTING_DELAY_BLOCKS = 2 weeks / 12;\n\n    /// @notice The lower bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_LOWER_BOUND = 200; // 200 basis points or 2%\n\n    /// @notice The upper bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_UPPER_BOUND = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The upper bound of maximum quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS_UPPER_BOUND = 6_000; // 6,000 basis points or 60%\n\n    /// @notice Upper bound for forking period. If forking period is too high it can block proposals for too long.\n    uint256 public constant MAX_FORK_PERIOD = 14 days;\n\n    /// @notice Lower bound for forking period\n    uint256 public constant MIN_FORK_PERIOD = 2 days;\n\n    /// @notice Upper bound for objection period duration in blocks.\n    uint256 public constant MAX_OBJECTION_PERIOD_BLOCKS = 7 days / 12;\n\n    /// @notice Upper bound for proposal updatable period duration in blocks.\n    uint256 public constant MAX_UPDATABLE_PERIOD_BLOCKS = 7 days / 12;\n\n    modifier onlyAdmin(NounsDAOStorageV3.StorageV3 storage ds) {\n        if (msg.sender != ds.admin) {\n            revert AdminOnly();\n        }\n        _;\n    }\n\n    /**\n     * @notice Admin function for setting the voting delay. Best to set voting delay to at least a few days, to give\n     * voters time to make sense of proposals, e.g. 21,600 blocks which should be at least 3 days.\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(NounsDAOStorageV3.StorageV3 storage ds, uint256 newVotingDelay) external onlyAdmin(ds) {\n        require(\n            newVotingDelay >= MIN_VOTING_DELAY_BLOCKS && newVotingDelay <= MAX_VOTING_DELAY_BLOCKS,\n            'NounsDAO::_setVotingDelay: invalid voting delay'\n        );\n        uint256 oldVotingDelay = ds.votingDelay;\n        ds.votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, newVotingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(NounsDAOStorageV3.StorageV3 storage ds, uint256 newVotingPeriod) external onlyAdmin(ds) {\n        require(\n            newVotingPeriod >= MIN_VOTING_PERIOD_BLOCKS && newVotingPeriod <= MAX_VOTING_PERIOD_BLOCKS,\n            'NounsDAO::_setVotingPeriod: invalid voting period'\n        );\n        uint256 oldVotingPeriod = ds.votingPeriod;\n        ds.votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, newVotingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold basis points\n     * @dev newProposalThresholdBPS must be in [`MIN_PROPOSAL_THRESHOLD_BPS`,`MAX_PROPOSAL_THRESHOLD_BPS`]\n     * @param newProposalThresholdBPS new proposal threshold\n     */\n    function _setProposalThresholdBPS(NounsDAOStorageV3.StorageV3 storage ds, uint256 newProposalThresholdBPS)\n        external\n        onlyAdmin(ds)\n    {\n        require(\n            newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\n                newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::_setProposalThreshold: invalid proposal threshold bps'\n        );\n        uint256 oldProposalThresholdBPS = ds.proposalThresholdBPS;\n        ds.proposalThresholdBPS = newProposalThresholdBPS;\n\n        emit ProposalThresholdBPSSet(oldProposalThresholdBPS, newProposalThresholdBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the objection period duration\n     * @param newObjectionPeriodDurationInBlocks new objection period duration, in blocks\n     */\n    function _setObjectionPeriodDurationInBlocks(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint32 newObjectionPeriodDurationInBlocks\n    ) external onlyAdmin(ds) {\n        if (newObjectionPeriodDurationInBlocks > MAX_OBJECTION_PERIOD_BLOCKS)\n            revert InvalidObjectionPeriodDurationInBlocks();\n\n        uint32 oldObjectionPeriodDurationInBlocks = ds.objectionPeriodDurationInBlocks;\n        ds.objectionPeriodDurationInBlocks = newObjectionPeriodDurationInBlocks;\n\n        emit ObjectionPeriodDurationSet(oldObjectionPeriodDurationInBlocks, newObjectionPeriodDurationInBlocks);\n    }\n\n    /**\n     * @notice Admin function for setting the objection period last minute window\n     * @param newLastMinuteWindowInBlocks new objection period last minute window, in blocks\n     */\n    function _setLastMinuteWindowInBlocks(NounsDAOStorageV3.StorageV3 storage ds, uint32 newLastMinuteWindowInBlocks)\n        external\n        onlyAdmin(ds)\n    {\n        uint32 oldLastMinuteWindowInBlocks = ds.lastMinuteWindowInBlocks;\n        ds.lastMinuteWindowInBlocks = newLastMinuteWindowInBlocks;\n\n        emit LastMinuteWindowSet(oldLastMinuteWindowInBlocks, newLastMinuteWindowInBlocks);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal updatable period\n     * @param newProposalUpdatablePeriodInBlocks the new proposal updatable period, in blocks\n     */\n    function _setProposalUpdatablePeriodInBlocks(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint32 newProposalUpdatablePeriodInBlocks\n    ) external onlyAdmin(ds) {\n        if (newProposalUpdatablePeriodInBlocks > MAX_UPDATABLE_PERIOD_BLOCKS)\n            revert InvalidProposalUpdatablePeriodInBlocks();\n\n        uint32 oldProposalUpdatablePeriodInBlocks = ds.proposalUpdatablePeriodInBlocks;\n        ds.proposalUpdatablePeriodInBlocks = newProposalUpdatablePeriodInBlocks;\n\n        emit ProposalUpdatablePeriodSet(oldProposalUpdatablePeriodInBlocks, newProposalUpdatablePeriodInBlocks);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     */\n    function _setPendingAdmin(NounsDAOStorageV3.StorageV3 storage ds, address newPendingAdmin) external onlyAdmin(ds) {\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = ds.pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        ds.pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     */\n    function _acceptAdmin(NounsDAOStorageV3.StorageV3 storage ds) external {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        require(\n            msg.sender == ds.pendingAdmin && msg.sender != address(0),\n            'NounsDAO::_acceptAdmin: pending admin only'\n        );\n\n        // Save current values for inclusion in log\n        address oldAdmin = ds.admin;\n        address oldPendingAdmin = ds.pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        ds.admin = ds.pendingAdmin;\n\n        // Clear the pending value\n        ds.pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, ds.admin);\n        emit NewPendingAdmin(oldPendingAdmin, address(0));\n    }\n\n    /**\n     * @notice Begins transition of vetoer. The newPendingVetoer must call _acceptVetoer to finalize the transfer.\n     * @param newPendingVetoer New Pending Vetoer\n     */\n    function _setPendingVetoer(NounsDAOStorageV3.StorageV3 storage ds, address newPendingVetoer) public {\n        if (msg.sender != ds.vetoer) {\n            revert VetoerOnly();\n        }\n\n        emit NewPendingVetoer(ds.pendingVetoer, newPendingVetoer);\n\n        ds.pendingVetoer = newPendingVetoer;\n    }\n\n    /**\n     * @notice Called by the pendingVetoer to accept role and update vetoer\n     */\n    function _acceptVetoer(NounsDAOStorageV3.StorageV3 storage ds) external {\n        if (msg.sender != ds.pendingVetoer) {\n            revert PendingVetoerOnly();\n        }\n\n        // Update vetoer\n        emit NewVetoer(ds.vetoer, ds.pendingVetoer);\n        ds.vetoer = ds.pendingVetoer;\n\n        // Clear the pending value\n        emit NewPendingVetoer(ds.pendingVetoer, address(0));\n        ds.pendingVetoer = address(0);\n    }\n\n    /**\n     * @notice Burns veto priviledges\n     * @dev Vetoer function destroying veto power forever\n     */\n    function _burnVetoPower(NounsDAOStorageV3.StorageV3 storage ds) public {\n        // Check caller is vetoer\n        require(msg.sender == ds.vetoer, 'NounsDAO::_burnVetoPower: vetoer only');\n\n        // Update vetoer to 0x0\n        emit NewVetoer(ds.vetoer, address(0));\n        ds.vetoer = address(0);\n\n        // Clear the pending value\n        emit NewPendingVetoer(ds.pendingVetoer, address(0));\n        ds.pendingVetoer = address(0);\n    }\n\n    /**\n     * @notice Admin function for setting the minimum quorum votes bps\n     * @param newMinQuorumVotesBPS minimum quorum votes bps\n     *     Must be between `MIN_QUORUM_VOTES_BPS_LOWER_BOUND` and `MIN_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be lower than or equal to maxQuorumVotesBPS\n     */\n    function _setMinQuorumVotesBPS(NounsDAOStorageV3.StorageV3 storage ds, uint16 newMinQuorumVotesBPS)\n        external\n        onlyAdmin(ds)\n    {\n        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n\n        require(\n            newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n                newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n            'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n        );\n        require(\n            newMinQuorumVotesBPS <= params.maxQuorumVotesBPS,\n            'NounsDAO::_setMinQuorumVotesBPS: min quorum votes bps greater than max'\n        );\n\n        uint16 oldMinQuorumVotesBPS = params.minQuorumVotesBPS;\n        params.minQuorumVotesBPS = newMinQuorumVotesBPS;\n\n        _writeQuorumParamsCheckpoint(ds, params);\n\n        emit MinQuorumVotesBPSSet(oldMinQuorumVotesBPS, newMinQuorumVotesBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the maximum quorum votes bps\n     * @param newMaxQuorumVotesBPS maximum quorum votes bps\n     *     Must be lower than `MAX_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be higher than or equal to minQuorumVotesBPS\n     */\n    function _setMaxQuorumVotesBPS(NounsDAOStorageV3.StorageV3 storage ds, uint16 newMaxQuorumVotesBPS)\n        externa"
    }
  ]
}