{
  "Title": "No parameter redundancy checks",
  "Content": "##### Description\n\nCertain setters in the `AlgebraCommunityVault` and `AlgebraPool` contracts are missing checks to ensure that the incoming parameter value isn't identical to the existing one. Specific instances include:\nhttps://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraCommunityVault.sol#L102\nhttps://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraCommunityVault.sol#L123\nhttps://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraCommunityVault.sol#L134\nhttps://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraPool.sol#L423.\n\n##### Recommendation\nWe recommend integrating the necessary redundancy checks into the mentioned functions to ensure no reassignment with identical values.\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/contracts/AlgebraCommunityVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport './libraries/SafeTransfer.sol';\nimport './libraries/FullMath.sol';\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IAlgebraCommunityVault.sol';\n\n/// @title Algebra community fee vault\n/// @notice Community fee from pools is sent here, if it is enabled\n/// @dev Role system is used to withdraw tokens\n/// @dev Version: Algebra Integral\ncontract AlgebraCommunityVault is IAlgebraCommunityVault {\n  /// @dev The role can be granted in AlgebraFactory\n  bytes32 public constant COMMUNITY_FEE_WITHDRAWER_ROLE = keccak256('COMMUNITY_FEE_WITHDRAWER');\n  address private immutable factory;\n\n  /// @notice Address to which community fees are sent from vault\n  address public communityFeeReceiver;\n  /// @notice The percentage of the protocol fee that Algebra will receive\n  /// @dev Value in thousandths,i.e. 1e-3\n  uint16 public algebraFee;\n  /// @notice Represents whether there is a new Algebra fee proposal or not\n  bool public hasNewAlgebraFeeProposal;\n  /// @notice Suggested Algebra fee value\n  uint16 public proposedNewAlgebraFee;\n  /// @notice Address of recipient Algebra part of community fee\n  address public algebraFeeReceiver;\n  /// @notice Address of Algebra fee manager\n  address public algebraFeeManager;\n  address private _pendingAlgebraFeeManager;\n\n  uint16 constant ALGEBRA_FEE_DENOMINATOR = 1000;\n\n  modifier onlyFactoryOwner() {\n    require(msg.sender == IAlgebraFactory(factory).owner());\n    _;\n  }\n\n  modifier onlyWithdrawer() {\n    require(msg.sender == algebraFeeManager || IAlgebraFactory(factory).hasRoleOrOwner(COMMUNITY_FEE_WITHDRAWER_ROLE, msg.sender));\n    _;\n  }\n\n  modifier onlyAlgebraFeeManager() {\n    require(msg.sender == algebraFeeManager);\n    _;\n  }\n\n  constructor(address _algebraFeeManager) {\n    (factory, algebraFeeManager) = (msg.sender, _algebraFeeManager);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdraw(address token, uint256 amount) external override onlyWithdrawer {\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n    _withdraw(token, _communityFeeReceiver, amount, _algebraFee, _algebraFeeReceiver);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdrawTokens(WithdrawTokensParams[] calldata params) external override onlyWithdrawer {\n    uint256 paramsLength = params.length;\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n\n    unchecked {\n      for (uint256 i; i < paramsLength; ++i) _withdraw(params[i].token, _communityFeeReceiver, params[i].amount, _algebraFee, _algebraFeeReceiver);\n    }\n  }\n\n  function _readAndVerifyWithdrawSettings() private view returns (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) {\n    if ((_algebraFee = algebraFee) != 0) require((_algebraFeeReceiver = algebraFeeReceiver) != address(0), 'invalid algebra fee receiver');\n    require((_communityFeeReceiver = communityFeeReceiver) != address(0), 'invalid receiver');\n  }\n\n  function _withdraw(address token, address to, uint256 amount, uint16 _algebraFee, address _algebraFeeReceiver) private {\n    uint256 withdrawAmount = amount;\n    if (_algebraFee != 0) {\n      uint256 algebraFeeAmount = FullMath.mulDivRoundingUp(withdrawAmount, _algebraFee, ALGEBRA_FEE_DENOMINATOR);\n      withdrawAmount -= algebraFeeAmount;\n      SafeTransfer.safeTransfer(token, _algebraFeeReceiver, algebraFeeAmount);\n      emit AlgebraTokensWithdrawal(token, _algebraFeeReceiver, algebraFeeAmount);\n    }\n\n    SafeTransfer.safeTransfer(token, to, withdrawAmount);\n    emit TokensWithdrawal(token, to, withdrawAmount);\n  }\n\n  // ### algebra factory owner permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeChangeProposal(uint16 newAlgebraFee) external override onlyFactoryOwner {\n    require(hasNewAlgebraFeeProposal, 'not proposed');\n    require(newAlgebraFee == proposedNewAlgebraFee, 'invalid new fee');\n\n    algebraFee = newAlgebraFee;\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n    emit AlgebraFee(newAlgebraFee);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeCommunityFeeReceiver(address newCommunityFeeReceiver) external override onlyFactoryOwner {\n    require(newCommunityFeeReceiver != address(0));\n    communityFeeReceiver = newCommunityFeeReceiver;\n    emit CommunityFeeReceiver(newCommunityFeeReceiver);\n  }\n\n  // ### algebra fee manager permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function transferAlgebraFeeManagerRole(address _newAlgebraFeeManager) external override onlyAlgebraFeeManager {\n    _pendingAlgebraFeeManager = _newAlgebraFeeManager;\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeManagerRole() external override {\n    require(msg.sender == _pendingAlgebraFeeManager);\n    (_pendingAlgebraFeeManager, algebraFeeManager) = (address(0), msg.sender);\n    emit AlgebraFeeManager(msg.sender);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function proposeAlgebraFeeChange(uint16 newAlgebraFee) external override onlyAlgebraFeeManager {\n    require(newAlgebraFee <= ALGEBRA_FEE_DENOMINATOR);\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (newAlgebraFee, true);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function cancelAlgebraFeeChangeProposal() external override onlyAlgebraFeeManager {\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeAlgebraFeeReceiver(address newAlgebraFeeReceiver) external override onlyAlgebraFeeManager {\n    require(newAlgebraFeeReceiver != address(0));\n    algebraFeeReceiver = newAlgebraFeeReceiver;\n    emit AlgebraFeeReceiver(newAlgebraFeeReceiver);\n  }\n}"
    },
    {
      "filename": "src/core/contracts/AlgebraCommunityVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport './libraries/SafeTransfer.sol';\nimport './libraries/FullMath.sol';\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IAlgebraCommunityVault.sol';\n\n/// @title Algebra community fee vault\n/// @notice Community fee from pools is sent here, if it is enabled\n/// @dev Role system is used to withdraw tokens\n/// @dev Version: Algebra Integral\ncontract AlgebraCommunityVault is IAlgebraCommunityVault {\n  /// @dev The role can be granted in AlgebraFactory\n  bytes32 public constant COMMUNITY_FEE_WITHDRAWER_ROLE = keccak256('COMMUNITY_FEE_WITHDRAWER');\n  address private immutable factory;\n\n  /// @notice Address to which community fees are sent from vault\n  address public communityFeeReceiver;\n  /// @notice The percentage of the protocol fee that Algebra will receive\n  /// @dev Value in thousandths,i.e. 1e-3\n  uint16 public algebraFee;\n  /// @notice Represents whether there is a new Algebra fee proposal or not\n  bool public hasNewAlgebraFeeProposal;\n  /// @notice Suggested Algebra fee value\n  uint16 public proposedNewAlgebraFee;\n  /// @notice Address of recipient Algebra part of community fee\n  address public algebraFeeReceiver;\n  /// @notice Address of Algebra fee manager\n  address public algebraFeeManager;\n  address private _pendingAlgebraFeeManager;\n\n  uint16 constant ALGEBRA_FEE_DENOMINATOR = 1000;\n\n  modifier onlyFactoryOwner() {\n    require(msg.sender == IAlgebraFactory(factory).owner());\n    _;\n  }\n\n  modifier onlyWithdrawer() {\n    require(msg.sender == algebraFeeManager || IAlgebraFactory(factory).hasRoleOrOwner(COMMUNITY_FEE_WITHDRAWER_ROLE, msg.sender));\n    _;\n  }\n\n  modifier onlyAlgebraFeeManager() {\n    require(msg.sender == algebraFeeManager);\n    _;\n  }\n\n  constructor(address _algebraFeeManager) {\n    (factory, algebraFeeManager) = (msg.sender, _algebraFeeManager);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdraw(address token, uint256 amount) external override onlyWithdrawer {\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n    _withdraw(token, _communityFeeReceiver, amount, _algebraFee, _algebraFeeReceiver);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdrawTokens(WithdrawTokensParams[] calldata params) external override onlyWithdrawer {\n    uint256 paramsLength = params.length;\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n\n    unchecked {\n      for (uint256 i; i < paramsLength; ++i) _withdraw(params[i].token, _communityFeeReceiver, params[i].amount, _algebraFee, _algebraFeeReceiver);\n    }\n  }\n\n  function _readAndVerifyWithdrawSettings() private view returns (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) {\n    if ((_algebraFee = algebraFee) != 0) require((_algebraFeeReceiver = algebraFeeReceiver) != address(0), 'invalid algebra fee receiver');\n    require((_communityFeeReceiver = communityFeeReceiver) != address(0), 'invalid receiver');\n  }\n\n  function _withdraw(address token, address to, uint256 amount, uint16 _algebraFee, address _algebraFeeReceiver) private {\n    uint256 withdrawAmount = amount;\n    if (_algebraFee != 0) {\n      uint256 algebraFeeAmount = FullMath.mulDivRoundingUp(withdrawAmount, _algebraFee, ALGEBRA_FEE_DENOMINATOR);\n      withdrawAmount -= algebraFeeAmount;\n      SafeTransfer.safeTransfer(token, _algebraFeeReceiver, algebraFeeAmount);\n      emit AlgebraTokensWithdrawal(token, _algebraFeeReceiver, algebraFeeAmount);\n    }\n\n    SafeTransfer.safeTransfer(token, to, withdrawAmount);\n    emit TokensWithdrawal(token, to, withdrawAmount);\n  }\n\n  // ### algebra factory owner permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeChangeProposal(uint16 newAlgebraFee) external override onlyFactoryOwner {\n    require(hasNewAlgebraFeeProposal, 'not proposed');\n    require(newAlgebraFee == proposedNewAlgebraFee, 'invalid new fee');\n\n    algebraFee = newAlgebraFee;\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n    emit AlgebraFee(newAlgebraFee);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeCommunityFeeReceiver(address newCommunityFeeReceiver) external override onlyFactoryOwner {\n    require(newCommunityFeeReceiver != address(0));\n    communityFeeReceiver = newCommunityFeeReceiver;\n    emit CommunityFeeReceiver(newCommunityFeeReceiver);\n  }\n\n  // ### algebra fee manager permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function transferAlgebraFeeManagerRole(address _newAlgebraFeeManager) external override onlyAlgebraFeeManager {\n    _pendingAlgebraFeeManager = _newAlgebraFeeManager;\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeManagerRole() external override {\n    require(msg.sender == _pendingAlgebraFeeManager);\n    (_pendingAlgebraFeeManager, algebraFeeManager) = (address(0), msg.sender);\n    emit AlgebraFeeManager(msg.sender);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function proposeAlgebraFeeChange(uint16 newAlgebraFee) external override onlyAlgebraFeeManager {\n    require(newAlgebraFee <= ALGEBRA_FEE_DENOMINATOR);\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (newAlgebraFee, true);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function cancelAlgebraFeeChangeProposal() external override onlyAlgebraFeeManager {\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeAlgebraFeeReceiver(address newAlgebraFeeReceiver) external override onlyAlgebraFeeManager {\n    require(newAlgebraFeeReceiver != address(0));\n    algebraFeeReceiver = newAlgebraFeeReceiver;\n    emit AlgebraFeeReceiver(newAlgebraFeeReceiver);\n  }\n}"
    },
    {
      "filename": "src/core/contracts/AlgebraCommunityVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport './libraries/SafeTransfer.sol';\nimport './libraries/FullMath.sol';\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IAlgebraCommunityVault.sol';\n\n/// @title Algebra community fee vault\n/// @notice Community fee from pools is sent here, if it is enabled\n/// @dev Role system is used to withdraw tokens\n/// @dev Version: Algebra Integral\ncontract AlgebraCommunityVault is IAlgebraCommunityVault {\n  /// @dev The role can be granted in AlgebraFactory\n  bytes32 public constant COMMUNITY_FEE_WITHDRAWER_ROLE = keccak256('COMMUNITY_FEE_WITHDRAWER');\n  address private immutable factory;\n\n  /// @notice Address to which community fees are sent from vault\n  address public communityFeeReceiver;\n  /// @notice The percentage of the protocol fee that Algebra will receive\n  /// @dev Value in thousandths,i.e. 1e-3\n  uint16 public algebraFee;\n  /// @notice Represents whether there is a new Algebra fee proposal or not\n  bool public hasNewAlgebraFeeProposal;\n  /// @notice Suggested Algebra fee value\n  uint16 public proposedNewAlgebraFee;\n  /// @notice Address of recipient Algebra part of community fee\n  address public algebraFeeReceiver;\n  /// @notice Address of Algebra fee manager\n  address public algebraFeeManager;\n  address private _pendingAlgebraFeeManager;\n\n  uint16 constant ALGEBRA_FEE_DENOMINATOR = 1000;\n\n  modifier onlyFactoryOwner() {\n    require(msg.sender == IAlgebraFactory(factory).owner());\n    _;\n  }\n\n  modifier onlyWithdrawer() {\n    require(msg.sender == algebraFeeManager || IAlgebraFactory(factory).hasRoleOrOwner(COMMUNITY_FEE_WITHDRAWER_ROLE, msg.sender));\n    _;\n  }\n\n  modifier onlyAlgebraFeeManager() {\n    require(msg.sender == algebraFeeManager);\n    _;\n  }\n\n  constructor(address _algebraFeeManager) {\n    (factory, algebraFeeManager) = (msg.sender, _algebraFeeManager);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdraw(address token, uint256 amount) external override onlyWithdrawer {\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n    _withdraw(token, _communityFeeReceiver, amount, _algebraFee, _algebraFeeReceiver);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdrawTokens(WithdrawTokensParams[] calldata params) external override onlyWithdrawer {\n    uint256 paramsLength = params.length;\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n\n    unchecked {\n      for (uint256 i; i < paramsLength; ++i) _withdraw(params[i].token, _communityFeeReceiver, params[i].amount, _algebraFee, _algebraFeeReceiver);\n    }\n  }\n\n  function _readAndVerifyWithdrawSettings() private view returns (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) {\n    if ((_algebraFee = algebraFee) != 0) require((_algebraFeeReceiver = algebraFeeReceiver) != address(0), 'invalid algebra fee receiver');\n    require((_communityFeeReceiver = communityFeeReceiver) != address(0), 'invalid receiver');\n  }\n\n  function _withdraw(address token, address to, uint256 amount, uint16 _algebraFee, address _algebraFeeReceiver) private {\n    uint256 withdrawAmount = amount;\n    if (_algebraFee != 0) {\n      uint256 algebraFeeAmount = FullMath.mulDivRoundingUp(withdrawAmount, _algebraFee, ALGEBRA_FEE_DENOMINATOR);\n      withdrawAmount -= algebraFeeAmount;\n      SafeTransfer.safeTransfer(token, _algebraFeeReceiver, algebraFeeAmount);\n      emit AlgebraTokensWithdrawal(token, _algebraFeeReceiver, algebraFeeAmount);\n    }\n\n    SafeTransfer.safeTransfer(token, to, withdrawAmount);\n    emit TokensWithdrawal(token, to, withdrawAmount);\n  }\n\n  // ### algebra factory owner permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeChangeProposal(uint16 newAlgebraFee) external override onlyFactoryOwner {\n    require(hasNewAlgebraFeeProposal, 'not proposed');\n    require(newAlgebraFee == proposedNewAlgebraFee, 'invalid new fee');\n\n    algebraFee = newAlgebraFee;\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n    emit AlgebraFee(newAlgebraFee);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeCommunityFeeReceiver(address newCommunityFeeReceiver) external override onlyFactoryOwner {\n    require(newCommunityFeeReceiver != address(0));\n    communityFeeReceiver = newCommunityFeeReceiver;\n    emit CommunityFeeReceiver(newCommunityFeeReceiver);\n  }\n\n  // ### algebra fee manager permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function transferAlgebraFeeManagerRole(address _newAlgebraFeeManager) external override onlyAlgebraFeeManager {\n    _pendingAlgebraFeeManager = _newAlgebraFeeManager;\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeManagerRole() external override {\n    require(msg.sender == _pendingAlgebraFeeManager);\n    (_pendingAlgebraFeeManager, algebraFeeManager) = (address(0), msg.sender);\n    emit AlgebraFeeManager(msg.sender);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function proposeAlgebraFeeChange(uint16 newAlgebraFee) external override onlyAlgebraFeeManager {\n    require(newAlgebraFee <= ALGEBRA_FEE_DENOMINATOR);\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (newAlgebraFee, true);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function cancelAlgebraFeeChangeProposal() external override onlyAlgebraFeeManager {\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeAlgebraFeeReceiver(address newAlgebraFeeReceiver) external override onlyAlgebraFeeManager {\n    require(newAlgebraFeeReceiver != address(0));\n    algebraFeeReceiver = newAlgebraFeeReceiver;\n    emit AlgebraFeeReceiver(newAlgebraFeeReceiver);\n  }\n}"
    },
    {
      "filename": "src/core/contracts/AlgebraPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\npragma abicoder v1;\n\nimport './base/AlgebraPoolBase.sol';\nimport './base/ReentrancyGuard.sol';\nimport './base/Positions.sol';\nimport './base/SwapCalculation.sol';\nimport './base/ReservesManager.sol';\nimport './base/TickStructure.sol';\n\nimport './libraries/FullMath.sol';\nimport './libraries/Constants.sol';\nimport './libraries/SafeCast.sol';\nimport './libraries/TickMath.sol';\nimport './libraries/LiquidityMath.sol';\nimport './libraries/Plugins.sol';\n\nimport './interfaces/IAlgebraFactory.sol';\n\n/// @title Algebra concentrated liquidity pool\n/// @notice This contract is responsible for liquidity positions, swaps and flashloans\n/// @dev Version: Algebra Integral\ncontract AlgebraPool is AlgebraPoolBase, TickStructure, ReentrancyGuard, Positions, SwapCalculation, ReservesManager {\n  using SafeCast for uint256;\n  using SafeCast for uint128;\n  using Plugins for uint8;\n  using Plugins for bytes4;\n\n  /// @inheritdoc IAlgebraPoolActions\n  function initialize(uint160 initialPrice) external override {\n    int24 tick = TickMath.getTickAtSqrtRatio(initialPrice); // getTickAtSqrtRatio checks validity of initialPrice inside\n    if (globalState.price != 0) revert alreadyInitialized(); // after initialization, the price can never become zero\n    globalState.price = initialPrice;\n\n    if (plugin != address(0)) {\n      IAlgebraPlugin(plugin).beforeInitialize(msg.sender, initialPrice).shouldReturn(IAlgebraPlugin.beforeInitialize.selector);\n    }\n\n    (uint16 _communityFee, int24 _tickSpacing, uint16 _fee) = _getDefaultConfiguration();\n    tickSpacing = _tickSpacing;\n\n    uint8 pluginConfig = globalState.pluginConfig;\n    globalState.tick = tick;\n    globalState.fee = _fee;\n    globalState.communityFee = _communityFee;\n\n    emit Initialize(initialPrice, tick);\n    emit TickSpacing(_tickSpacing);\n    emit CommunityFee(_communityFee);\n\n    if (pluginConfig.hasFlag(Plugins.AFTER_INIT_FLAG)) {\n      IAlgebraPlugin(plugin).afterInitialize(msg.sender, initialPrice, tick).shouldReturn(IAlgebraPlugin.afterInitialize.selector);\n    }\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function mint(\n    address leftoversRecipient,\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 liquidityDesired,\n    bytes calldata data\n  ) external override onlyValidTicks(bottomTick, topTick) returns (uint256 amount0, uint256 amount1, uint128 liquidityActual) {\n    if (liquidityDesired == 0) revert zeroLiquidityDesired();\n\n    _beforeModifyPos(recipient, bottomTick, topTick, liquidityDesired.toInt128(), data);\n    _lock();\n\n    unchecked {\n      int24 _tickSpacing = tickSpacing;\n      if (bottomTick % _tickSpacing | topTick % _tickSpacing != 0) revert tickIsNotSpaced();\n    }\n\n    (amount0, amount1, ) = LiquidityMath.getAmountsForLiquidity(\n      bottomTick,\n      topTick,\n      liquidityDesired.toInt128(),\n      globalState.tick,\n      globalState.price\n    );\n\n    (uint256 receivedAmount0, uint256 receivedAmount1) = _updateReserves();\n    _mintCallback(amount0, amount1, data); // IAlgebraMintCallback.algebraMintCallback to msg.sender\n\n    receivedAmount0 = amount0 == 0 ? 0 : _balanceToken0() - receivedAmount0;\n    receivedAmount1 = amount1 == 0 ? 0 : _balanceToken1() - receivedAmount1;\n\n    if (receivedAmount0 < amount0) {\n      liquidityActual = uint128(FullMath.mulDiv(uint256(liquidityDesired), receivedAmount0, amount0));\n    } else {\n      liquidityActual = liquidityDesired;\n    }\n    if (receivedAmount1 < amount1) {\n      uint128 liquidityForRA1 = uint128(FullMath.mulDiv(uint256(liquidityDesired), receivedAmount1, amount1));\n      if (liquidityForRA1 < liquidityActual) liquidityActual = liquidityForRA1;\n    }\n    if (liquidityActual == 0) revert zeroLiquidityActual();\n\n    // scope to prevent \"stack too deep\"\n    {\n      Position storage _position = getOrCreatePosition(recipient, bottomTick, topTick);\n      (amount0, amount1) = _updatePositionTicksAndFees(_position, bottomTick, topTick, liquidityActual.toInt128());\n    }\n\n    unchecked {\n      // return leftovers\n      if (amount0 > 0) {\n        if (receivedAmount0 > amount0) _transfer(token0, leftoversRecipient, receivedAmount0 - amount0);\n        else assert(receivedAmount0 == amount0); // must always be true\n      }\n      if (amount1 > 0) {\n        if (receivedAmount1 > amount1) _transfer(token1, leftoversRecipient, receivedAmount1 - amount1);\n        else assert(receivedAmount1 == amount1); // must always be true\n      }\n    }\n\n    _changeReserves(int256(amount0), int256(amount1), 0, 0);\n    emit Mint(msg.sender, recipient, bottomTick, topTick, liquidityActual, amount0, amount1);\n\n    _unlock();\n    _afterModifyPos(recipient, bottomTick, topTick, liquidityActual.toInt128(), amount0, amount1, data);\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function burn(\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount,\n    bytes calldata data\n  ) external override onlyValidTicks(bottomTick, topTick) returns (uint256 amount0, uint256 amount1) {\n    if (amount > uint128(type(int128).max)) revert arithmeticError();\n\n    int128 liquidityDelta = -int128(amount);\n\n    _beforeModifyPos(msg.sender, bottomTick, topTick, liquidityDelta, data);\n    _lock();\n\n    _updateReserves();\n    Position storage position = getOrCreatePosition(msg.sender, bottomTick, topTick);\n\n    (amount0, amount1) = _updatePositionTicksAndFees(position, bottomTick, topTick, liquidityDelta);\n\n    if (amount0 | amount1 != 0) {\n      (position.fees0, position.fees1) = (position.fees0 + uint128(amount0), position.fees1 + uint128(amount1));\n    }\n\n    if (amount | amount0 | amount1 != 0) emit Burn(msg.sender, bottomTick, topTick, amount, amount0, amount1);\n\n    _unlock();\n    _afterModifyPos(msg.sender, bottomTick, topTick, liquidityDelta, amount0, amount1, data);\n  }\n\n  function _beforeModifyPos(address owner, int24 bottomTick, int24 topTick, int128 liquidityDelta, bytes calldata data) internal {\n    if (globalState.pluginConfig.hasFlag(Plugins.BEFORE_POSITION_MODIFY_FLAG)) {\n      IAlgebraPlugin(plugin).beforeModifyPosition(msg.sender, owner, bottomTick, topTick, liquidityDelta, data).shouldReturn(\n        IAlgebraPlugin.beforeModifyPosition.selector\n      );\n    }\n  }\n\n  function _afterModifyPos(address owner, int24 bTick, int24 tTick, int128 deltaL, uint256 amount0, uint256 amount1, bytes calldata data) internal {\n    if (globalState.pluginConfig.hasFlag(Plugins.AFTER_POSITION_MODIFY_FLAG)) {\n      IAlgebraPlugin(plugin).afterModifyPosition(msg.sender, owner, bTick, tTick, deltaL, amount0, amount1, data).shouldReturn(\n        IAlgebraPlugin.afterModifyPosition.selector\n      );\n    }\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function collect(\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external override nonReentrant returns (uint128 amount0, uint128 amount1) {\n    // we don't check tick range validity, because if ticks are incorrect, the position will be empty\n    Position storage position = getOrCreatePosition(msg.sender, bottomTick, topTick);\n    (uint128 positionFees0, uint128 positionFees1) = (position.fees0, position.fees1);\n\n    if (amount0Requested > positionFees0) amount0Requested = positionFees0;\n    if (amount1Requested > positionFees1) amount1Requested = positionFees1;\n\n    if (amount0Requested | amount1Requested != 0) {\n      // use one if since fees0 and fees1 are tightly packed\n      (amount0, amount1) = (amount0Requested, amount1Requested);\n\n      unchecked {\n        // single SSTORE\n        (position.fees0, position.fees1) = (positionFees0 - amount0, positionFees1 - amount1);\n\n        if (amount0 > 0) _transfer(token0, recipient, amount0);\n        if (amount1 > 0) _transfer(token1, recipient, amount1);\n        _changeReserves(-int256(uint256(amount0)), -int256(uint256(amount1)), 0, 0);\n      }\n      emit Collect(msg.sender, recipient, bottomTick, topTick, amount0, amount1);\n    }\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function swap(\n    address recipient,\n    bool zeroToOne,\n    int256 amountRequired,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external override returns (int256 amount0, int256 amount1) {\n    _beforeSwap(recipient, zeroToOne, amountRequired, limitSqrtPrice, false, data);\n    _lock();\n\n    {\n      // scope to prevent \"stack too deep\"\n      uint160 currentPrice;\n      int24 currentTick;\n      uint128 currentLiquidity;\n      uint256 communityFee;\n      (amount0, amount1, currentPrice, currentTick, currentLiquidity, communityFee) = _calculateSwap(zeroToOne, amountRequired, limitSqrtPrice);\n      (uint256 balance0Before, uint256 balance1Before) = _updateReserves();\n      if (zeroToOne) {\n        unchecked {\n          if (amount1 < 0) _transfer(token1, recipient, uint256(-amount1)); // amount1 cannot be > 0\n        }\n        _swapCallback(amount0, amount1, data); // callback to get tokens from the msg.sender\n        if (balance0Before + uint256(amount0) > _balanceToken0()) revert insufficientInputAmount();\n        _changeReserves(amount0, amount1, communityFee, 0); // reflect reserve change and pay communityFee\n      } else {\n        unchecked {\n          if (amount0 < 0) _transfer(token0, recipient, uint256(-amount0)); // amount0 cannot be > 0\n        }\n        _swapCallback(amount0, amount1, data); // callback to get tokens from the msg.sender\n        if (balance1Before + uint256(amount1) > _balanceToken1()) revert insufficientInputAmount();\n        _changeReserves(amount0, amount1, 0, communityFee); // reflect reserve change and pay communityFee\n      }\n\n      emit Swap(msg.sender, recipient, amount0, amount1, currentPrice, currentLiquidity, currentTick);\n    }\n\n    _unlock();\n    _afterSwap(recipient, zeroToOne, amountRequired, limitSqrtPrice, amount0, amount1, data);\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function swapWithPaymentInAdvance(\n    address leftoversRecipient,\n    address recipient,\n    bool zeroToOne,\n    int256 amountToSell,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external override returns (int256 amount0, int256 amount1) {\n    if (amountToSell < 0) revert invalidAmountRequired(); // we support only exactInput here\n\n    _lock();\n    // firstly we are getting tokens from the original caller of the transaction\n    // since the pool can get less/more tokens then expected, _amountToSell_ can be changed\n    {\n      // scope to prevent \"stack too deep\"\n      int256 amountReceived;\n      if (zeroToOne) {\n        uint256 balanceBefore = _balanceToken0();\n        _swapCallback(amountToSell, 0, data); // callback to get tokens from the msg.sender\n        uint256 balanceAfter = _balanceToken0();\n        amountReceived = (balanceAfter - balanceBefore).toInt256();\n        _changeReserves(amountReceived, 0, 0, 0);\n      } else {\n        uint256 balanceBefore = _balanceToken1();\n        _swapCallback(0, amountToSell, data); // callback to get tokens from the msg.sender\n        uint256 balanceAfter = _balanceToken1();\n        amountReceived = (balanceAfter - balanceBefore).toInt256();\n        _changeReserves(0, amountReceived, 0, 0);\n      }\n      if (amountReceived != amountToSell) amountToSell = amountReceived;\n    }\n    if (amountToSell == 0) revert insufficientInputAmount();\n\n    _unlock();\n    _beforeSwap(recipient, zeroToOne, amountToSell, limitSqrtPrice, true, data);\n    _lock();\n\n    _updateReserves();\n\n    uint160 currentPrice;\n    int24 currentTick;\n    uint128 currentLiquidity;\n    uint256 communityFee;\n    (amount0, amount1, currentPrice, currentTick, currentLiquidity, communityFee) = _calculateSwap(zeroToOne, amountToSell, limitSqrtPrice);\n\n    unchecked {\n      // transfer to the recipient\n      if (zeroToOne) {\n        if (amount1 < 0) _transfer(token1, recipient, uint256(-amount1)); // amount1 cannot be > 0\n        uint256 leftover = uint256(amountToSell - amount0); // return the leftovers\n        if (leftover != 0) _transfer(token0, leftoversRecipient, leftover);\n        _changeReserves(-leftover.toInt256(), amount1, communityFee, 0); // reflect reserve change and pay communityFee\n      } else {\n        if (amount0 < 0) _transfer(token0, recipient, uint256(-amount0)); // amount0 cannot be > 0\n        uint256 leftover = uint256(amountToSell - amount1); // return the leftovers\n        if (leftover != 0) _transfer(token1, leftoversRecipient, leftover);\n        _changeReserves(amount0, -leftover.toInt256(), 0, communityFee); // reflect reserve change and pay communityFee\n      }\n    }\n\n    emit Swap(msg.sender, recipient, amount0, amount1, currentPrice, currentLiquidity, currentTick);\n\n    _unlock();\n    _afterSwap(recipient, zeroToOne, amountToSell, limitSqrtPrice, amount0, amount1, data);\n  }\n\n  function _beforeSwap(address recipient, bool zto, int256 amount, uint160 limitPrice, bool payInAdvance, bytes calldata data) internal {\n    if (globalState.pluginConfig.hasFlag(Plugins.BEFORE_SWAP_FLAG)) {\n      IAlgebraPlugin(plugin).beforeSwap(msg.sender, recipient, zto, amount, limitPrice, payInAdvance, data).shouldReturn(\n        IAlgebraPlugin.beforeSwap.selector\n      );\n    }\n  }\n\n  function _afterSwap(address recipient, bool zto, int256 amount, uint160 limitPrice, int256 amount0, int256 amount1, bytes calldata data) internal {\n    if (globalState.pluginConfig.hasFlag(Plugins.AFTER_SWAP_FLAG)) {\n      IAlgebraPlugin(plugin).afterSwap(msg.sender, recipient, zto, amount, limitPrice, amount0, amount1, data).shouldReturn(\n        IAlgebraPlugin.afterSwap.selector\n      );\n    }\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external override {\n    if (globalState.pluginConfig.hasFlag(Plugins.BEFORE_FLASH_FLAG)) {\n      IAlgebraPlugin(plugin).beforeFlash(msg.sender, recipient, amount0, amount1, data).shouldReturn(IAlgebraPlugin.beforeFlash.selector);\n    }\n    _lock();\n\n    uint256 paid0;\n    uint256 paid1;\n    {\n      (uint256 balance0Before, uint256 balance1Before) = _updateReserves();\n      uint256 fee0;\n      if (amount0 > 0) {\n        fee0 = FullMath.mulDivRoundingUp(amount0, Constants.FLASH_FEE, Constants.FEE_DENOMINATOR);\n        _transfer(token0, recipient, amount0);\n      }\n      uint256 fee1;\n      if (amount1 > 0) {\n        fee1 = FullMath.mulDivRoundingUp(amount1, Constants.FLASH_FEE, Constants.FEE_DENOMINATOR);\n        _transfer(token1, recipient, amount1);\n      }\n\n      _flashCallback(fee0, fee1, data); // IAlgebraFlashCallback.algebraFlashCallback to msg.sender\n\n      paid0 = _balanceToken0();\n      if (balance0Before + fee0 > paid0) revert flashInsufficientPaid0();\n      paid1 = _balanceToken1();\n      if (balance1Before + fee1 > paid1) revert flashInsufficientPaid1();\n\n      unchecked {\n        paid0 -= balance0Before;\n        paid1 -= balance1Before;\n      }\n\n      uint256 _communityFee = globalState.communityFee;\n      if (_communityFee > 0) {\n        uint256 communityFee0;\n        if (paid0 > 0) communityFee0 = FullMath.mulDiv("
    }
  ]
}