{
  "Title": "M-6: Inaccurate Perp debt calculation",
  "Content": "# Issue M-6: Inaccurate Perp debt calculation \n\nSource: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/346 \n\n## Found by \npeanuts, HollaDieWaldfee, hl\\_, berndartmueller\n\n## Summary\n\nThe anticipated Perp account debt value calculation via `PerpDepository.getDebtValue` is inaccurate and does not incorporate the (not yet settled) owed realized PnL `owedRealizedPnl`.\n\n## Vulnerability Detail\n\nThe `PerpDepository.getDebtValue` function calculates the account debt value by subtracting the pending funding payments and fees from the quote token balance and unrealized PnL. However, the owed realized PnL (`owedRealizedPnl`) is not considered in the calculation. The owed realized PnL is the realized PnL owed to the account but has **not yet been settled**.\n\nPerp provides the `Vault.getSettlementTokenValue()` function to calculate the settlement token value of an account and uses it to determine the accounts' debt (if < 0, [see docs](https://docs.perp.com/docs/contracts/Vault/#getsettlementtokenvalue)). For example, it is used to determine if an account is liquidable - see [Vault.isLiquidatable#L434](https://github.com/perpetual-protocol/perp-curie-contract/blob/27ea8e2c4be37d1dd58c1eed3b3cc269d398a091/contracts/Vault.sol#L434)\n\nPerps' specs define the value of an account as ([see here for reference](https://support.perp.com/hc/en-us/articles/5331515119001)):\n\n$$\n\\begin{aligned} accountValue &= \\underbrace{collateral + owedRealizedPnl + pendingFundingPayment + pendingFee}_{totalCollateralValue} + \\underbrace{\\sum_{market}{unrealizedPnl_{market}}}_{totalUnrealizedPnl} \\end{aligned}\n$$\n\n## Impact\n\nThe Perp account debt calculation is inaccurate and deviates from the calculation by the Perp protocol itself. Even though the `PerpDepository.getDebtValue` function is `external`, it could lead to issues when querying from another contract or off-chain to use as decision criteria or manifest as a serious issue when used in an upgraded version of the contract.\n\n## Code Snippet\n\n[integrations/perp/PerpDepository.sol#L773](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L773)\n\n```solidity\n/// @notice Get the quote token balance of this user\n/// @dev THe total debt is computed as:\n///     quote token balance + unrealized PnL - Pending fee - pending funding payments\n/// @param account The account to return the debt for\n/// @return debt The account debt, or zero if no debt.\nfunction getDebtValue(address account) external view returns (uint256) {\n    IAccountBalance perpAccountBalance = IAccountBalance(\n        clearingHouse.getAccountBalance()\n    );\n    IExchange perpExchange = IExchange(clearingHouse.getExchange());\n    int256 accountQuoteTokenBalance = vault.getBalance(account);\n    if (accountQuoteTokenBalance < 0) {\n        revert InvalidQuoteTokenBalance(accountQuoteTokenBalance);\n    }\n    int256 fundingPayment = perpExchange.getAllPendingFundingPayment(\n        account\n    );\n    uint256 quoteTokenBalance = uint256(accountQuoteTokenBalance)\n        .fromDecimalToDecimal(ERC20(quoteToken).decimals(), 18);\n    (\n        , // @audit-info `owedRealizedPnl` is omitted here and missing in the calculation below\n        int256 perpUnrealizedPnl,\n        uint256 perpPendingFee\n    ) = perpAccountBalance.getPnlAndPendingFee(account);\n    int256 debt = int256(quoteTokenBalance) +\n        perpUnrealizedPnl -\n        int256(perpPendingFee) -\n        fundingPayment;\n    return (debt > 0) ? 0 : _abs(debt);\n}\n```\n\n[Vault.\\_getSettlementTokenValue](https://github.com/perpetual-protocol/perp-curie-contract/blob/27ea8e2c4be37d1dd58c1eed3b3cc269d398a091/contracts/Vault.sol#L880-L884)\n\n`Vault._getSettlementTokenValue` is called internally by Perp's public `Vault.getSettlementTokenValue()` function.\n\n```solidity\nfunction _getSettlementTokenValue(address trader) internal view returns (int256 settlementTokenValueX10_18) {\n    (int256 settlementBalanceX10_18, int256 unrealizedPnlX10_18) =\n        _getSettlementTokenBalanceAndUnrealizedPnl(trader);\n    return settlementBalanceX10_18.add(unrealizedPnlX10_18);\n}\n```\n\n[Vault.\\_getSettlementTokenBalanceAndUnrealizedPnl](https://github.com/perpetual-protocol/perp-curie-contract/blob/27ea8e2c4be37d1dd58c1eed3b3cc269d398a091/contracts/Vault.sol#L852-L877)\n\n```solidity\n/// @notice Get the specified trader's settlement token balance, including pending fee, funding payment,\n///         owed realized PnL, but without unrealized PnL)\n/// @dev Note the difference between the return argument`settlementTokenBalanceX10_18` and\n///      the return value of `getSettlementTokenValue()`.\n///      The first one is settlement token balance with pending fee, funding payment, owed realized PnL;\n///      The second one is the first one plus unrealized PnL.\n/// @return settlementTokenBalanceX10_18 Settlement amount in 18 decimals\n/// @return unrealizedPnlX10_18 Unrealized PnL in 18 decimals\nfunction _getSettlementTokenBalanceAndUnrealizedPnl(address trader)\n    internal\n    view\n    returns (int256 settlementTokenBalanceX10_18, int256 unrealizedPnlX10_18)\n{\n    int256 fundingPaymentX10_18 = IExchange(_exchange).getAllPendingFundingPayment(trader);\n\n    int256 owedRealizedPnlX10_18;\n    uint256 pendingFeeX10_18;\n    (owedRealizedPnlX10_18, unrealizedPnlX10_18, pendingFeeX10_18) = IAccountBalance(_accountBalance)\n        .getPnlAndPendingFee(trader);\n\n    settlementTokenBalanceX10_18 = getBalance(trader).parseSettlementToken(_decimals).add(\n        pendingFeeX10_18.toInt256().sub(fundingPaymentX10_18).add(owedRealizedPnlX10_18) // @audit-info owed realized PnL is added here\n    );\n\n    return (settlementTokenBalanceX10_18, unrealizedPnlX10_18);\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using the `Vault.getSettlementTokenValue()` function to determine the accounts' debt ([see docs](https://docs.perp.com/docs/contracts/Vault/#getsettlementtokenvalue)).\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/33",
  "Code": [
    {
      "filename": "contracts/Vault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport { AddressUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { SafeMathUpgradeable } from \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport { SignedSafeMathUpgradeable } from \"@openzeppelin/contracts-upgradeable/math/SignedSafeMathUpgradeable.sol\";\nimport { MathUpgradeable } from \"@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol\";\nimport {\n    SafeERC20Upgradeable,\n    IERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport { FullMath } from \"@uniswap/v3-core/contracts/libraries/FullMath.sol\";\nimport { TransferHelper } from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport { PerpSafeCast } from \"./lib/PerpSafeCast.sol\";\nimport { SettlementTokenMath } from \"./lib/SettlementTokenMath.sol\";\nimport { PerpMath } from \"./lib/PerpMath.sol\";\nimport { IERC20Metadata } from \"./interface/IERC20Metadata.sol\";\nimport { IInsuranceFund } from \"./interface/IInsuranceFund.sol\";\nimport { IExchange } from \"./interface/IExchange.sol\";\nimport { IAccountBalance } from \"./interface/IAccountBalance.sol\";\nimport { IClearingHouseConfig } from \"./interface/IClearingHouseConfig.sol\";\nimport { IClearingHouse } from \"./interface/IClearingHouse.sol\";\nimport { BaseRelayRecipient } from \"./gsn/BaseRelayRecipient.sol\";\nimport { OwnerPausable } from \"./base/OwnerPausable.sol\";\nimport { VaultStorageV2 } from \"./storage/VaultStorage.sol\";\nimport { Collateral } from \"./lib/Collateral.sol\";\nimport { IVault } from \"./interface/IVault.sol\";\nimport { IWETH9 } from \"./interface/external/IWETH9.sol\";\nimport { ICollateralManager } from \"./interface/ICollateralManager.sol\";\n\n// never inherit any new stateful contract. never change the orders of parent stateful contracts\ncontract Vault is IVault, ReentrancyGuardUpgradeable, OwnerPausable, BaseRelayRecipient, VaultStorageV2 {\n    using SafeMathUpgradeable for uint256;\n    using PerpSafeCast for uint256;\n    using PerpSafeCast for int256;\n    using SignedSafeMathUpgradeable for int256;\n    using SettlementTokenMath for uint256;\n    using SettlementTokenMath for int256;\n    using PerpMath for int256;\n    using PerpMath for uint256;\n    using PerpMath for uint24;\n    using FullMath for uint256;\n    using AddressUpgradeable for address;\n\n    uint24 private constant _ONE_HUNDRED_PERCENT_RATIO = 1e6;\n\n    //\n    // MODIFIER\n    //\n\n    modifier onlySettlementOrCollateralToken(address token) {\n        // V_OSCT: only settlement or collateral token\n        require(token == _settlementToken || _isCollateral(token), \"V_OSCT\");\n        _;\n    }\n\n    //\n    // EXTERNAL NON-VIEW\n    //\n\n    /// @dev only used for unwrapping weth in withdrawETH\n    receive() external payable {\n        // V_SNW: sender is not WETH9\n        require(_msgSender() == _WETH9, \"V_SNW\");\n    }\n\n    function initialize(\n        address insuranceFundArg,\n        address clearingHouseConfigArg,\n        address accountBalanceArg,\n        address exchangeArg\n    ) external initializer {\n        address settlementTokenArg = IInsuranceFund(insuranceFundArg).getToken();\n        uint8 decimalsArg = IERC20Metadata(settlementTokenArg).decimals();\n\n        // invalid settlementToken decimals\n        require(decimalsArg <= 18, \"V_ISTD\");\n        // ClearingHouseConfig address is not contract\n        require(clearingHouseConfigArg.isContract(), \"V_CHCNC\");\n        // accountBalance address is not contract\n        require(accountBalanceArg.isContract(), \"V_ABNC\");\n        // exchange address is not contract\n        require(exchangeArg.isContract(), \"V_ENC\");\n\n        __ReentrancyGuard_init();\n        __OwnerPausable_init();\n\n        // update states\n        _decimals = decimalsArg;\n        _settlementToken = settlementTokenArg;\n        _insuranceFund = insuranceFundArg;\n        _clearingHouseConfig = clearingHouseConfigArg;\n        _accountBalance = accountBalanceArg;\n        _exchange = exchangeArg;\n    }\n\n    function setTrustedForwarder(address trustedForwarderArg) external onlyOwner {\n        // V_TFNC: TrustedForwarder address is not contract\n        require(trustedForwarderArg.isContract(), \"V_TFNC\");\n\n        _setTrustedForwarder(trustedForwarderArg);\n        emit TrustedForwarderChanged(trustedForwarderArg);\n    }\n\n    function setClearingHouse(address clearingHouseArg) external onlyOwner {\n        // V_CHNC: ClearingHouse is not contract\n        require(clearingHouseArg.isContract(), \"V_CHNC\");\n\n        _clearingHouse = clearingHouseArg;\n        emit ClearingHouseChanged(clearingHouseArg);\n    }\n\n    function setCollateralManager(address collateralManagerArg) external onlyOwner {\n        // V_CMNC: CollateralManager is not contract\n        require(collateralManagerArg.isContract(), \"V_CMNC\");\n\n        _collateralManager = collateralManagerArg;\n        emit CollateralManagerChanged(collateralManagerArg);\n    }\n\n    function setWETH9(address WETH9Arg) external onlyOwner {\n        // V_WNC: WETH9 is not contract\n        require(WETH9Arg.isContract(), \"V_WNC\");\n\n        _WETH9 = WETH9Arg;\n        emit WETH9Changed(WETH9Arg);\n    }\n\n    /// @inheritdoc IVault\n    function deposit(address token, uint256 amount)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlySettlementOrCollateralToken(token)\n    {\n        // input requirement checks:\n        //   token: here\n        //   amount: _deposit\n\n        address from = _msgSender();\n        _deposit(from, from, token, amount);\n    }\n\n    /// @inheritdoc IVault\n    function depositFor(\n        address to,\n        address token,\n        uint256 amount\n    ) external override whenNotPaused nonReentrant onlySettlementOrCollateralToken(token) {\n        // input requirement checks:\n        //   token: here\n        //   amount: _deposit\n\n        // V_DFZA: Deposit for zero address\n        require(to != address(0), \"V_DFZA\");\n\n        address from = _msgSender();\n        _deposit(from, to, token, amount);\n    }\n\n    /// @inheritdoc IVault\n    function depositEther() external payable override whenNotPaused nonReentrant {\n        address to = _msgSender();\n        _depositEther(to);\n    }\n\n    /// @inheritdoc IVault\n    function depositEtherFor(address to) external payable override whenNotPaused nonReentrant {\n        // input requirement checks:\n        //   to: here\n\n        // V_DFZA: Deposit for zero address\n        require(to != address(0), \"V_DFZA\");\n        _depositEther(to);\n    }\n\n    /// @inheritdoc IVault\n    // the full process of withdrawal:\n    // 1. settle funding payment to owedRealizedPnl\n    // 2. collect fee to owedRealizedPnl\n    // 3. call Vault.withdraw(token, amount)\n    // 4. settle pnl to trader balance in Vault\n    // 5. transfer the amount to trader\n    function withdraw(address token, uint256 amount)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlySettlementOrCollateralToken(token)\n    {\n        // input requirement checks:\n        //   token: here\n        //   amount: in _settleAndDecreaseBalance()\n\n        address to = _msgSender();\n        _withdraw(to, token, amount);\n    }\n\n    /// @inheritdoc IVault\n    function withdrawEther(uint256 amount) external override whenNotPaused nonReentrant {\n        // input requirement checks:\n        //   amount: in _settleAndDecreaseBalance()\n\n        _requireWETH9IsCollateral();\n\n        address to = _msgSender();\n\n        _withdrawEther(to, amount);\n    }\n\n    /// @inheritdoc IVault\n    function withdrawAll(address token)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlySettlementOrCollateralToken(token)\n        returns (uint256 amount)\n    {\n        // input requirement checks:\n        //   token: here\n\n        address to = _msgSender();\n        amount = getFreeCollateralByToken(to, token);\n\n        _withdraw(to, token, amount);\n        return amount;\n    }\n\n    /// @inheritdoc IVault\n    function withdrawAllEther() external override whenNotPaused nonReentrant returns (uint256 amount) {\n        _requireWETH9IsCollateral();\n\n        address to = _msgSender();\n        amount = getFreeCollateralByToken(to, _WETH9);\n\n        _withdrawEther(to, amount);\n        return amount;\n    }\n\n    /// @inheritdoc IVault\n    function liquidateCollateral(\n        address trader,\n        address token,\n        uint256 amount,\n        bool isDenominatedInSettlementToken\n    ) external override whenNotPaused nonReentrant returns (uint256) {\n        // input requirement checks:\n        //   trader: here\n        //   token: in _isCollateral()\n        //   amount: here\n        //   isDenominatedInSettlementToken: X\n\n        // V_NL: Not liquidatable\n        require(isLiquidatable(trader), \"V_NL\");\n\n        (uint256 maxRepaidSettlementX10_S, uint256 maxLiquidatableCollateral) =\n            getMaxRepaidSettlementAndLiquidatableCollateral(trader, token);\n\n        uint256 collateral;\n        uint256 settlementX10_S;\n        uint256 returnAmount;\n\n        if (isDenominatedInSettlementToken) {\n            settlementX10_S = amount;\n            // V_MSAE: Maximum settlement amount exceeded\n            require(settlementX10_S <= maxRepaidSettlementX10_S, \"V_MSAE\");\n            collateral = settlementX10_S == maxRepaidSettlementX10_S\n                ? maxLiquidatableCollateral\n                : getLiquidatableCollateralBySettlement(token, settlementX10_S);\n            returnAmount = collateral;\n        } else {\n            collateral = amount;\n            // V_MCAE: Maximum collateral amount exceeded\n            require(collateral <= maxLiquidatableCollateral, \"V_MCAE\");\n            settlementX10_S = collateral == maxLiquidatableCollateral\n                ? maxRepaidSettlementX10_S\n                : getRepaidSettlementByCollateral(token, collateral);\n            returnAmount = settlementX10_S;\n        }\n\n        _liquidateCollateral(trader, token, settlementX10_S, collateral);\n\n        return returnAmount;\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    /// @inheritdoc IVault\n    function getSettlementToken() external view override returns (address) {\n        return _settlementToken;\n    }\n\n    /// @inheritdoc IVault\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    /// @inheritdoc IVault\n    function getTotalDebt() external view override returns (uint256) {\n        return _totalDebt;\n    }\n\n    /// @inheritdoc IVault\n    function getClearingHouseConfig() external view override returns (address) {\n        return _clearingHouseConfig;\n    }\n\n    /// @inheritdoc IVault\n    function getAccountBalance() external view override returns (address) {\n        return _accountBalance;\n    }\n\n    /// @inheritdoc IVault\n    function getInsuranceFund() external view override returns (address) {\n        return _insuranceFund;\n    }\n\n    /// @inheritdoc IVault\n    function getExchange() external view override returns (address) {\n        return _exchange;\n    }\n\n    /// @inheritdoc IVault\n    function getClearingHouse() external view override returns (address) {\n        return _clearingHouse;\n    }\n\n    /// @inheritdoc IVault\n    function getCollateralManager() external view override returns (address) {\n        return _collateralManager;\n    }\n\n    /// @inheritdoc IVault\n    function getWETH9() external view override returns (address) {\n        return _WETH9;\n    }\n\n    /// @inheritdoc IVault\n    function getFreeCollateral(address trader) external view override returns (uint256) {\n        return _getFreeCollateral(trader).formatSettlementToken(_decimals);\n    }\n\n    /// @inheritdoc IVault\n    function getFreeCollateralByRatio(address trader, uint24 ratio) external view override returns (int256) {\n        return _getFreeCollateralByRatio(trader, ratio).formatSettlementToken(_decimals);\n    }\n\n    /// @inheritdoc IVault\n    function getSettlementTokenValue(address trader) external view override returns (int256) {\n        return _getSettlementTokenValue(trader).formatSettlementToken(_decimals);\n    }\n\n    /// @inheritdoc IVault\n    function getAccountValue(address trader) external view override returns (int256) {\n        (int256 accountValueX10_18, ) = _getAccountValueAndTotalCollateralValue(trader);\n        return accountValueX10_18.formatSettlementToken(_decimals);\n    }\n\n    /// @inheritdoc IVault\n    function getCollateralTokens(address trader) external view override returns (address[] memory) {\n        return _collateralTokensMap[trader];\n    }\n\n    //\n    // PUBLIC VIEW\n    //\n\n    /// @inheritdoc IVault\n    function getBalance(address trader) public view override returns (int256) {\n        return _balance[trader][_settlementToken];\n    }\n\n    /// @inheritdoc IVault\n    function getBalanceByToken(address trader, address token) public view override returns (int256) {\n        return _balance[trader][token];\n    }\n\n    /// @inheritdoc IVault\n    /// @dev getFreeCollateralByToken(token) = (getSettlementTokenValue() >= 0)\n    ///   ? min(getFreeCollateral() / indexPrice[token], getBalanceByToken(token))\n    ///   : 0\n    /// @dev if token is settlementToken, then indexPrice[token] = 1\n    function getFreeCollateralByToken(address trader, address token) public view override returns (uint256) {\n        // do not check settlementTokenValue == 0 because user's settlement token balance may be zero\n        if (_getSettlementTokenValue(trader) < 0) {\n            return 0;\n        }\n\n        uint256 freeCollateralX10_18 = _getFreeCollateral(trader);\n        if (freeCollateralX10_18 == 0) {\n            return 0;\n        }\n\n        if (token == _settlementToken) {\n            (int256 settlementTokenBalanceX10_18, ) = _getSettlementTokenBalanceAndUnrealizedPnl(trader);\n            return\n                settlementTokenBalanceX10_18 <= 0\n                    ? 0\n                    : MathUpgradeable\n                        .min(freeCollateralX10_18, settlementTokenBalanceX10_18.toUint256())\n                        .formatSettlementToken(_decimals);\n        }\n\n        (uint256 indexTwap, uint8 priceFeedDecimals) = _getIndexPriceAndDecimals(token);\n        uint24 collateralRatio = ICollateralManager(_collateralManager).getCollateralConfig(token).collateralRatio;\n        return\n            MathUpgradeable.min(\n                _getCollateralBySettlement(token, freeCollateralX10_18, indexTwap, priceFeedDecimals).divRatio(\n                    collateralRatio\n                ),\n                // non-settlement token is always positive number\n                getBalanceByToken(trader, token).toUint256()\n            );\n    }\n\n    /// @inheritdoc IVault\n    function isLiquidatable(address trader) public view override returns (bool) {\n        address[] storage collateralTokens = _collateralTokensMap[trader];\n        if (collateralTokens.length == 0) {\n            return false;\n        }\n\n        (int256 accountValueX10_18, ) = _getAccountValueAndTotalCollateralValue(trader);\n        if (accountValueX10_18 < getMarginRequirementForCollateralLiquidation(trader)) {\n            return true;\n        }\n\n        int256 settlementTokenValueX10_18 = _getSettlementTokenValue(trader);\n        uint256 settlementTokenDebtX10_18 =\n            settlementTokenValueX10_18 < 0 ? settlementTokenValueX10_18.neg256().toUint256() : 0;\n\n        if (\n            settlementTokenDebtX10_18 >\n            _getNonSettlementTokenValue(trader).mulRatio(\n                ICollateralManager(_collateralManager).getDebtNonSettlementTokenValueRatio()\n            )\n        ) {\n            return true;\n        }\n\n        if (\n            settlementTokenDebtX10_18.formatSettlementToken(_decimals) >\n            ICollateralManager(_collateralManager).getDebtThresholdByTrader(trader)\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// @inheritdoc IVault\n    function getMarginRequirementForCollateralLiquidation(address trader) public view override returns (int256) {\n        return\n            IAccountBalance(_accountBalance)\n                .getTotalAbsPositionValue(trader)\n                .mulRatio(getCollateralMmRatio())\n                .toInt256();\n    }\n\n    /// @inheritdoc IVault\n    function getCollateralMmRatio() public view override returns (uint24) {\n        uint24 collateralMmRatio =\n            ICollateralManager(_collateralManager).requireValidCollateralMmRatio(\n                ICollateralManager(_collateralManager).getMmRatioBuffer()\n            );\n        return collateralMmRatio;\n    }\n\n    /// @inheritdoc IVault\n    function getRepaidSettlementByCollateral(address token, uint256 collateral)\n        public\n        view\n        override\n        returns (uint256 settlementX10_S)\n    {\n        uint24 discountRatio = ICollateralManager(_collateralManager).getCollateralConfig(token).discountRatio;\n        (uint256 indexTwap, uint8 priceFeedDecimals) = _getIndexPriceAndDecimals(token);\n\n        return\n            _getSettlementByCollateral(\n                token,\n                collateral,\n                indexTwap.mulRatio(_ONE_HUNDRED_PERCENT_RATIO.subRatio(discountRatio)),\n                priceFeedDecimals\n            )\n                .formatSettlementToken(_decimals);\n    }\n\n    /// @inheritdoc IVault\n    function getLiquidatableCollateralBySettlement(address token, uint256 settlementX10_S)\n        public\n        view\n        override\n        returns (uint256 collateral)\n    {\n        uint24 discountRatio = ICollateralManager(_collateralManager).getCollateralConfig(token).discountRatio;\n        (uint256 indexTwap, uint8 priceFeedDecimals) = _getIndexPriceAndDecimals(token);\n\n        return\n            _getCollateralBySettlement(\n                token,\n                settlementX10_S.parseSettlementToken(_decimals),\n                indexTwap.mulRatio(_ONE_HUNDRED_PERCENT_RATIO.subRatio(discountRatio)),\n                priceFeedDecimals\n            );\n    }\n\n    /// @inheritdoc IVault\n    /// @dev formula:\n    /// maxRepaidSettlement = maxLiquidatableCollateral * (indexTwap * (1 - discountRatio))\n    /// maxLiquidatableCollateral =\n    ///     min(maxRepaidSettlement / (indexTwap * (1 - discountRatio)), getBalanceByToken(trader, token))\n    function getMaxRepaidSettlementAndLiquidatableCollateral(address trader, address token)\n        public\n        view\n        override\n        returns (uint256 maxRepaidSettlementX10_S, uint256 maxLiquidatableCollateral)\n    {\n        // V_TINAC: token is not a collateral\n        require(_isCollateral(token), \"V_TINAC\");\n\n        uint256 maxRepaidSettlementX10_18 = _getMaxRepaidSettlement(trader);\n        uint24 discountRatio = ICollateralManager(_collateralManager).getCollateralConfig(token).discountRatio;\n        (uint256 indexTwap, uint8 priceFeedDecimals) = _getIndexPriceAndDecimals(token);\n\n        uint256 discountedIndexTwap = indexTwap.mulRatio(_ONE_HUNDRED_PERCENT_RATIO.subRatio(discountRatio));\n        maxLiquidatableCollateral = _getCollateralBySettlement(\n            token,\n            maxRepaidSettlementX10_18,\n            discountedIndexTwap,\n            priceFeedDecimals\n        );\n\n        uint256 tokenBalance = getBalanceByToken(trader, token).toUint256();\n        if (maxLiquidatableCollateral > tokenBalance) {\n            maxLiquidatableCollateral = tokenBalance;\n\n            // Deliberately rounding down when calculating settlement. Thus, when calculating\n            // collateral with settlement, the result is always <= maxCollateral.\n            // This makes sure that collateral will always be <= user's collateral balance.\n            maxRepaidSettlementX10_18 = _getSettlementByCollateral(\n                token,\n                maxLiquidatableCollateral,\n                discountedIndexTwap,\n                priceFeedDecimals\n            );\n        }\n\n        maxRepaidSettlementX10_S = maxRepaidSettlementX10_18.formatSettlementToken(_decimals);\n\n        return (maxRepaidSettlementX10_S, maxLiquidatableCollateral);\n    }\n\n    /// @inheritdoc IVault\n    /// @dev will only settle the bad debt when trader didn't have position and non-settlement collateral\n    function settleBadDebt(address trader) public override {\n        // V_CSI: can't settle insuranceFund\n        require(trader != _insuranceFund, \"V_CSI\");\n\n        // trader has position or trader has non-settlement collateral\n        if (\n            IAccountBalance(_accountBalance).getBaseTokens(trader).length != 0 ||\n            _collateralTokensMap[trader].length != 0\n        ) {\n            return;\n        }\n\n        // assume trader has no position and no non-settlement collateral\n        // so accountValue = settlement token balance\n        (int256 accountValueX10_18, ) = _getSettlementTokenBalanceAndUnrealizedPnl(trader);\n        int256 accountValueX10_S = accountValueX10_18.formatSettlementToken(_decimals);\n\n        if (accountValueX10_S >= 0) {\n            return;\n        }\n\n        // settle bad debt for trader\n        int256 badDebt = accountValueX10_S.neg256();\n        address settlementToken = _settlementToken; // SLOAD gas saving\n        _modifyBalance(_insuranceFund, settlementToken, accountValueX10_S);\n        _modifyBalance(trader, settlementToken, badDebt);\n\n        uint256 absBadDebt = badDebt.toUint256();\n        emit BadDebtSettled(trader, absBadDebt);\n    }\n\n    //\n    // INTERNAL NON-VIEW\n    //\n\n    /// @param token the collateral token needs to be transferred into vault\n    /// @param from the address of account who owns the collateral token\n    /// @param amount the amount of collateral token needs to be transferred\n    function _transferTokenIn(\n        address token,\n        address from,\n        uint256 amount\n    ) internal {\n        // check for deflationary tokens by assuring balances before and after transferring to be the same\n        uint256 balanceBefore = IERC20Metadata(token).balanceOf(address(this));\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), from, address(this), amount);\n        // V_IBA: inconsistent balance amount, to prevent from deflationary tokens\n        require((IERC20Metadata(token).balanceOf(address(this)).sub(balanceBefore)) == amount, \"V_IBA\");\n    }\n\n    /// @param from deposit token from this address\n    /// @param to deposit token to this address\n    /// @param token the collateral token wish to deposit\n    /// @param amount the amount of token to deposit\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        // V_ZA: Zero amount\n        require(amount > 0, \"V_ZA\");\n        _transferTokenIn(token, from, amount);\n        _checkDepositCapAndRegister(token, to, amount);\n    }\n\n    /// @param to deposit ETH to this address\n    function _depositEther(address to) internal {\n        uint256 amount = msg.value;\n        // V_ZA: Zero amount\n        require(amount > 0, \"V_ZA\");\n        _requireWETH9IsCollateral();\n\n        // SLOAD for gas saving\n        address WETH9 = _WETH9;\n        // wrap ETH into WETH\n        IWETH9(WETH9).deposit{ value: amount }();\n        _checkDepositCapAndRegister(WETH9, to, amount);\n    }\n\n    /// @param token the collateral token needs to be transferred out of vault\n    /// @param to the address of account that the collateral token deposit to\n    /// @param amount the amount of collateral token to be deposited\n    function _checkDepositCapAndRegister(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (token == _settlementToken) {\n            uint256 settlementTokenBalanceCap =\n                IClearingHouseConfig(_clearingHouseConfig).getSettlementTokenBalanceCap();\n            // V_GTSTBC: greater than settlement token balance cap\n            require(IERC20Metadata(token).balanceOf(address(this)) <= settlementTokenBalanceCap, \"V_GTSTBC\");\n        } else {\n            uint256 depositCap = ICollateralManager(_collateralManager).getCollateralConfig(token).depositCap;\n            // V_GTDC: greater than deposit cap\n            require(IERC20Metadata(token).balanceOf(address(this)) <= depositCap, \"V_GTDC\");\n        }\n\n        _modifyBalance(to, token, amount.toInt256());\n        emit Deposited(token, to, amount);\n    }\n\n    function _settleAndDecreaseBalance(\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        // settle all funding payments owedRealizedPnl\n        // pending fee can be withdraw but won't be settled\n        IClearingHouse(_clearingHouse).settleAllFunding(to);\n\n        // incl. owedRealizedPnl\n        uint256 freeCollateral = getFreeCollateralByToken(to, token);\n        // V_NEFC: not enough freeCollateral\n        require(freeCollateral >= amount, \"V_NEFC\");\n\n        int256 deltaBalance = amount.toInt256().neg256();\n        if (token == _settlementToken) {\n            // settle both the withdrawn amount and owedRealizedPnl to collateral\n            int256 owedRealizedPnlX10_18 = IAccountBalance(_accountBalance).settleOwedRealizedPnl(to);\n            deltaBalance = deltaBalance.add(owedRealizedPnlX10_18.formatSettlementToken(_decimals));\n        }\n\n        _modifyBalance(to, token, deltaBalance);\n    }\n\n    function _withdraw(\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        _settleAndDecreaseBalance(to, token, amount);\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(token), to, amount);\n        emit Withdrawn(token, to, amount);\n    }\n\n    function _withdrawEther(address to, uint256 amount) internal {\n        // SLOAD for gas saving\n        address WETH9 = _WETH9;\n\n        _settleAndDecreaseBalance(to, WETH9, amount);\n\n        IWETH9(WETH9).withdraw(amount);\n        TransferHelper.safeTransferETH(to, amount);\n        emit Withdrawn(WETH9, to, amount);\n    }\n\n    /// @param amount can be 0; do not require this\n    function _modifyBalance(\n        address trader,\n        address token,\n        int256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        int256 oldBalance = _balance[trader][token];\n        int256 newBalance = oldBalance.add(amount);\n        _balance[trader][token] = newBalance;\n\n        if (token == _settlementToken) {\n            return;\n        }\n\n        // register/deregister non-settlement collateral tokens\n        if (oldBalance != 0 && newBalance == 0) {\n            address[] storage collateralTokens = _collateralTokensMap[trader];\n            uint256 tokenLen = collateralTokens.length;\n            uint256 lastTokenIndex = tokenLen - 1;\n            // find and deregister the token\n            for (uint256 i; i < tokenLen; i++) {\n                if (collateralTokens[i] == token) {\n                    // delete the token by replacing it with the last one and then pop it from there\n                    if (i != lastTokenIndex) {\n                        collateralTokens[i] = collateralTokens[lastTokenIndex];\n                    }\n                    collateralTokens.pop();\n                    break;\n                }\n            }\n        } else if (oldBalance == 0 && newBalance != 0) {\n            address[] storage collateralTokens = _collateralTokensMap[trader];\n            collateralTokens.push(token);\n            // V_CTNE: collateral tokens number exceeded\n            require(\n                collateralTokens.length <= ICollateralManager(_collateralManager).getMaxCollateralTokensPerAccount(),\n                \"V_CTNE\"\n            );\n        }\n    }\n\n    /// @dev liquidate trader's collateral token by repaying the trader's settlement token debt\n    ///      the amount of collateral token and settlement token should be calculated by using\n    ///      getLiquidatableCollateralBySettlement() and getRepaidSettlementByCollateral()\n    function _liquidateCollateral(\n        address trader,\n        address token,\n        uint256 settlementX10_S,\n        uint256 collateral\n    ) internal {\n        address liquidator = _msgSender();\n        address settlementToken = _settlementToken; // SLOAD gas saving\n\n        // transfer settlement token from liquidator before changing any internal states\n        _transferTokenIn(settlementToken, liquidator, settlementX10_S);\n\n        _modifyBalance(trader, token, collateral.neg256());\n\n        uint24 clInsuranceFundFeeRatio = ICollateralManager(_collateralManager).getCLInsuranceFundFeeRatio();\n        // round down in insurance fund fee calculation, so we can make sure all\n        // the user's debt can be repaid when fully collateral liquidation\n        uint256 insuranceFundFeeX10_S = settlementX10_S.mulRatio(clInsuranceFundFeeRatio);\n        _modifyBalance(_insuranceFund, settlementToken, insuranceFundFeeX10_S.toInt256());\n\n        uint256 repaidSettlementWithoutInsuranceFundFeeX10_S = settlementX10_S.sub(insuranceFundFeeX10_S);\n        _modifyBalance(trader, settlementToken, repaidSettlementWithoutInsuranceFundFeeX10_S.toInt256());\n\n        // transfer collateral token from vault to liquidator\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(token), liquidator, collateral);\n\n        uint24 discountRatio = ICollateralManager(_collateralManager).getCollateralConfig(token).discountRatio;\n\n        emit CollateralLiquidated(\n            trader,\n            token,\n            liquidator,\n            collateral,\n            repaidSettlementWithoutInsuranceFundFeeX10_S,\n            insuranceFundFeeX10_S,\n            discountRatio\n        );\n\n        settleBadDebt(trader);\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n\n    function _getTokenDecimals(address token) internal view returns (uint8) {\n        return IERC20Metadata(token).decimals();\n    }\n\n    function _getFreeCollateral(address trader) internal view returns (uint256 freeCollateralX10_18) {\n        return\n            PerpMath\n                .max(_getFreeCollateralByRatio(trader, IClearingHouseConfig(_clearingHouseConfig).getImRatio()), 0)\n                .toUint256();\n    }\n\n    function _getFreeCollateralByRatio(address trader, uint24 ratio)\n        internal\n        view\n        returns (int256 freeCollateralX10_18)\n    {\n        // conservative config: freeCollateral = min(totalCollateralValue, accountValue) - openOrderMarginReq\n        (int256 accountValueX10_18, int256 totalCollateralValueX10_18) =\n            _getAccountValueAndTotalCollateralValue(trader);\n        uint256 totalMarginRequirementX10_18 = _getTotalMarginRequirement(trader, ratio);\n\n        return\n            PerpMath.min(totalCollateralValueX10_18, accountValueX10_18).sub(totalMarginRequirementX10_18.toInt256());\n\n        // moderate config: freeCollateral = min(totalCollateralValue, accountValue - openOrderMarginReq)\n        // return\n        //     PerpMath.min(\n        //         totalCollateralValueX10_18,\n        //         accountValueX10_S.sub(totalMarginRequirementX10_18.toInt256())\n        //     );\n\n        // aggressive config: freeCollateral = accountValue - openOrderMarginReq\n        // note that the aggressive model depends entirely on unrealizedPnl, which depends on the index price\n        //      we should implement some sort of safety check before using this model; otherwise,\n        //      a trader could drain the entire vault if the index price deviates significantly.\n        // return accountValueX10_18.sub(totalMarginRequirementX10_18.toInt256());\n    }\n\n    function _getTotalCollateralValueAndUnrealizedPnl(address trader)\n        internal\n        view\n        returns (int256 totalCollateralValueX10_18, int256 unrealizedPnlX10_18)\n    {\n        int256 settlementTokenBalanceX10_18;\n        (settlementTokenBalanceX10_18, unrealizedPnlX10_18) = _getSettlementTokenBalanceAndUnrealizedPnl(trader);\n        uint256 nonSettlementTokenValueX10_18 = _getNonSettlementTokenValue(trader);\n        return (nonSettlementTokenValueX10_18.toInt256().add(settlementTokenBalanceX10_18), unrealizedPnlX10_18);\n    }\n\n    /// @notice Get the specified trader's settlement token balance, including pending fee, funding payment,\n    ///         owed realized PnL, but without unrealized PnL)\n    /// @dev Note the difference between the return argument`settlementTokenBalanceX10_18` and\n    ///      the return value of `getSettlementTokenValue()`.\n    ///      The first one is settlement token balance with pending fee, funding payment, owed realized PnL;\n    ///      The second one is the first one plus unrealized PnL.\n    /// @return settlementTokenBalanceX10_18 Settlement amount in 18 decimals\n    /// @return unrealizedPnlX10_18 Unrealized PnL in 18 decim"
    }
  ]
}