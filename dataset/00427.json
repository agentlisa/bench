{
  "Title": "M-8: The repaying action in `BBLeverage.sellCollateral` function pulls YieldBox shares of asset from wrong address",
  "Content": "# Issue M-8: The repaying action in `BBLeverage.sellCollateral` function pulls YieldBox shares of asset from wrong address \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/59 \n\n## Found by \nduc\n## Summary\nThe `sellCollateral` function is used to sell a user's collateral to obtain YieldBox shares of the asset and repay the user's loan. However, in the BBLeverage contract, it calls `_repay` with the `from` parameter set to the user, even though the asset shares have already been collected by this contract beforehand.\n## Vulnerability Detail\nIn `BBLeverage.sellCollateral`, the `from` variable (user)  is used as the repayer address.\n```solidity=\nif (memoryData.shareOwed <= memoryData.shareOut) {\n    _repay(from, from, memoryData.partOwed);\n} else {\n    //repay as much as we can\n    uint256 partOut = totalBorrow.toBase(amountOut, false);\n    _repay(from, from, partOut);\n}\n```\nTherefore, asset shares of user will be pulled in `BBLendingCommon._repay` function.\n```solidity=\nfunction _repay(address from, address to, uint256 part) internal returns (uint256 amount) {\n    ...\n    // @dev amount includes the opening & accrued fees\n    yieldBox.withdraw(assetId, from, address(this), amount, 0);\n    ...\n```\nThis is incorrect behavior since the necessary asset shares were already collected by the contract in the `BBLeverage.sellCollateral` function. The repayer address should be `address(this)` for `_repay`.\n\n## Impact\nMistakenly pulling user funds while the received asset shares remain stuck in the contract will result in losses for users who have sufficient allowance and balance when using the `BBLeverage.sellCollateral` functionality.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L156\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L160\n\n## Tool used\n\nManual Review\n\n## Recommendation\nShould fix as following:\n```solidity=\nif (memoryData.shareOwed <= memoryData.shareOut) {\n    _repay(address(this), from, memoryData.partOwed);\n} else {\n    //repay as much as we can\n    uint256 partOut = totalBorrow.toBase(amountOut, false);\n    _repay(address(this), from, partOut);\n}\n```\n\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nDuplicate of https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/42\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  the amount seem to be different, the first one is hardcoded zero and the second one is the amount; so i believe is intended behavior\n\n\n\n**huuducsc**\n\nEscalate\nI believe this issue is not a duplicate of #100 since they are very different in everything. This issue should be a valid high issue, and here are the reasons:\nAfter issue #42 and its fix, it becomes apparent that the `sellCollateral` function attempts to deposit asset tokens into the YieldBox and then utilize the received shares to repay users. However, even though the contract receives asset shares, this function still employs the `from` to pull asset shares when calling `_repay`. This behavior results in the extraction of additional funds from users, causing unexpected losses, while the unused funds (received asset shares from depositing into the YieldBox) become stuck within this contract.\nYou can review the commit fix of #42: https://github.com/Tapioca-DAO/Tapioca-bar/pull/352.\nThis issue pertains to a different problem involving the incorrect calling of `_repay`. You should refer to my recommendation to understand.\n\n**sherlock-admin2**\n\n> Escalate\n> I believe this issue is not a duplicate of #100 since they are very different in everything. This issue should be a valid high issue, and here are the reasons:\n> After issue #42 and its fix, it becomes apparent that the `sellCollateral` function attempts to deposit asset tokens into the YieldBox and then utilize the received shares to repay users. However, even though the contract receives asset shares, this function still employs the `from` to pull asset shares when calling `_repay`. This behavior results in the extraction of additional funds from users, causing unexpected losses, while the unused funds (received asset shares from depositing into the YieldBox) become stuck within this contract.\n> You can review the commit fix of #42: https://github.com/Tapioca-DAO/Tapioca-bar/pull/352.\n> This issue pertains to a different problem involving the incorrect calling of `_repay`. You should refer to my recommendation to understand.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nI believe this issue is correctly duplicated, in fact #100 is a more comprehensive report compared to this issue.\n\n**huuducsc**\n\n@nevillehuang I believe the 3 problems mentioned in #100 are not related to this issue. #100 represents incorrect uses of `getCollateral()`, `safeApprove()`, and `depositAsset()` functions in `buyCollateral()` function, which render the `buyCollateral()` function unable to work. It only has a medium impact. However, this issue represents the incorrect call of `_repay()` function in the `sellCollateral()` function when it attempts to pull funds from the user again. This is a different problem in a different function, and it has a high severity since users will be at risk of losing funds whenever they use `sellCollateral()` function. \nCould you please recheck it.\n\n**cvetanovv**\n\nI agree with the escalation not being a duplicate of #100, but disagree that it should be High severity. The loss of funds is limited to the allowance and balance the user has. That's why I think it should stay Medium.\n\n**nevillehuang**\n\n@cvetanovv @cryptotechmaker @huuducsc This seems like a duplicate of #141, might want to double check if a separate fix is required. Maybe a PoC can easily confirm this? I think #101 is a variation of this issue too and could also be duplicated\n\nMight also want to consider this comments [here](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/101#issuecomment-2000942927) by @maarcweiss on duplication status\n\n**cvetanovv**\n\nI decided to accept escalation to be a valid High but will duplicate it with #141. \nThe function is the same and the impact is the same. In this issue, the function pulls double funds, in the other double allowances. However, we need to check if the fix will fix both problems.\n\n**huuducsc**\n\n@cvetanovv I don't think this issue is similar to #141 since #141 only represents the way allowance of the user for sender is spent twice. There is no higher impact in that report, and the actual root cause is different from this issue. This issue describes that `_repay` will pull funds from the user again because of an incorrect `from` address, and it doesn't mention allowance spending. The impact is different because issue #141 doesn't result in a direct loss of funds for the user; it only requires more allowance for the `sellCollateral` function. Could you please recheck?\n\n\n**nevillehuang**\n\n@huuducsc @hyh Can you guys provide a PoC to prove #141 and #59 are not duplicates? They are way too similar for me to verify, and I just want to double confirm one issue doesn't lead to another.\n\nCC @maarcweiss @cryptotechmaker @0xRektora \n\n**cvetanovv**\n\nMy final decision is to accept the escalation and this issue will not have a duplicate and will remain unique, but will also remain Medium because of the new approval system.\n\n**huuducsc**\n\n@cvetanovv The new permit system is an additional functionality, it shouldn't be a reason to consider the likelihood of this issue as low. There are no restrictions regarding approval from users to the market before utilization, so it's expected from users. Therefore, I believe the likelihood should still be high, and this issue deserves a high severity\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Tapioca-DAO/Tapioca-bar/pull/386\n\n\n**cvetanovv**\n\nMy final decision is to accept the escalation this issue to be unique but remain Medium.\n\n**nevillehuang**\n\n@huuducsc Just to check is issue #101 a duplicate of your issue? I don't want to misduplicate issues here\n\n**Evert0x**\n\nResult:\nMedium\nUnique \n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [huuducsc](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/59/#issuecomment-2032007570): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLendingCommon} from \"./BBLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLeverage is BBLendingCommon {\n    using RebaseLibrary for Rebase;\n    using SafeApprove for address;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    struct _BuyCollateralMemoryData {\n        uint256 supplyShareToAmount;\n        uint256 borrowShareToAmount;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        _BuyCollateralMemoryData memory memoryData;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        {\n            uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n            if (supplyShare > 0) {\n                (memoryData.supplyShareToAmount,) =\n                    yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n            }\n        }\n\n        {\n            (, uint256 borrowShare) = _borrow(\n                calldata_.from,\n                address(this),\n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );\n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        {\n            amountOut = leverageExecutor.getCollateral(\n                collateralId,\n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralMemoryData {\n        uint256 obtainedShare;\n        uint256 leverageAmount;\n        uint256 shareOut;\n        uint256 partOwed;\n        uint256 amountOwed;\n        uint256 shareOwed;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n            _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLendingCommon} from \"./BBLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLeverage is BBLendingCommon {\n    using RebaseLibrary for Rebase;\n    using SafeApprove for address;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    struct _BuyCollateralMemoryData {\n        uint256 supplyShareToAmount;\n        uint256 borrowShareToAmount;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        _BuyCollateralMemoryData memory memoryData;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        {\n            uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n            if (supplyShare > 0) {\n                (memoryData.supplyShareToAmount,) =\n                    yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n            }\n        }\n\n        {\n            (, uint256 borrowShare) = _borrow(\n                calldata_.from,\n                address(this),\n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );\n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        {\n            amountOut = leverageExecutor.getCollateral(\n                collateralId,\n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralMemoryData {\n        uint256 obtainedShare;\n        uint256 leverageAmount;\n        uint256 shareOut;\n        uint256 partOwed;\n        uint256 amountOwed;\n        uint256 shareOwed;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n            _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n}"
    }
  ]
}