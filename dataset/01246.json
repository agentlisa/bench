{
  "Title": "Primary short liquidation can not be completed in the last hour of the liquidation timeline",
  "Content": "# Primary short liquidation can not be completed in the last hour of the liquidation timeline\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L387\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L387</a>\n\n\n## Summary\n\nShorts flagged for liquidation can not be liquidated in the last and final hour of the liquidation timeline, resulting in the liquidation flag being reset and requiring the short to be flagged again.\n\n## Vulnerability Details\n\nIf a short's collateral ratio is below the primary liquidation threshold (determined by the [`LibAsset.primaryLiquidationCR`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibAsset.sol#L67-L71) function, by default set to `400%`), anyone can flag the position for liquidation by calling the `MarginCallPrimaryFacet.flagShort` function.\n\nSubsequently, the short position owner has a certain amount of time, specifically, `10 hours` (configured and determined by the [`LibAsset.firstLiquidationTime` function](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibAsset.sol#L45-L48)), to repay the loan and bring the collateral ratio back above the primary liquidation threshold. If the short position owner fails to do so, the short position can be liquidated by calling the `MarginCallPrimaryFacet.liquidate` function.\n\nThe specific criteria for the liquidation eligibility are defined and determined in the `MarginCallPrimaryFacet._canLiquidate` function.\n\n[contracts/facets/MarginCallPrimaryFacet.sol#L387](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L387)\n\n```solidity\n351: function _canLiquidate(MTypes.MarginCallPrimary memory m)\n352:     private\n353:     view\n354:     returns (bool)\n355: {\n...      // [...]\n383:\n384:     uint256 timeDiff = LibOrders.getOffsetTimeHours() - m.short.updatedAt;\n385:     uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(m.asset);\n386:\n387: âŒ  if (timeDiff >= resetLiquidationTime) {\n388:         return false;\n389:     } else {\n390:         uint256 secondLiquidationTime = LibAsset.secondLiquidationTime(m.asset);\n391:         bool isBetweenFirstAndSecondLiquidationTime = timeDiff\n392:             > LibAsset.firstLiquidationTime(m.asset) && timeDiff <= secondLiquidationTime\n393:             && s.flagMapping[m.short.flaggerId] == msg.sender;\n394:         bool isBetweenSecondAndResetLiquidationTime =\n395:             timeDiff > secondLiquidationTime && timeDiff <= resetLiquidationTime;\n396:         if (\n397:             !(\n398:                 (isBetweenFirstAndSecondLiquidationTime)\n399:                     || (isBetweenSecondAndResetLiquidationTime)\n400:             )\n401:         ) {\n402:             revert Errors.MarginCallIneligibleWindow();\n403:         }\n404:\n405:         return true;\n406:     }\n407: }\n```\n\nThis function checks in lines 387-389 if the elapsed time (`timeDiff`) since the short was updated is **equal or greater than** the reset liquidation time (`resetLiquidationTime`), which is by default set to `16 hours`. In this case, the short position has not been liquidated in time and has to be flagged again.\n\nHowever, this condition conflicts with the `isBetweenSecondAndResetLiquidationTime` criteria in lines 394-395, specifically, the `timeDiff <= resetLiquidationTime` check. If the `timeDiff` value is equal to `resetLiquidationTime`, both conditions, in line 387 as well as the check in line 395, are `true`. Due to line 387 taking precedence, the liquidation is considered outdated and the [short position has to be flagged again](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L118-L122).\n\nBased on the check in lines 67-69 of the `flagShort` function, it is evident that a short position flagged for liquidation requires re-flagging only if the `timeDiff` value is **greater** (`>`) than the reset liquidation time (`resetLiquidationTime`):\n\n[contracts/facets/MarginCallPrimaryFacet.sol#L67-L69](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L67-L69)\n\n```solidity\n67: if (timeDiff <= resetLiquidationTime) {\n68:     revert Errors.MarginCallAlreadyFlagged();\n69: }\n```\n\nThus, the check in line 387 is incorrect, leading to prematurely resetting the short's liquidation flagging status.\n\nAs the timestamps are in `hours`, and the [liquidation timeline is relatively short](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L364-L382), having an off-by-one error in the liquidation timeline can lead to a significant impact on the liquidations. Concretely, attempting to liquidate a short position in the last hour of the timeline, i.e., `timeDiff = 16`, is not possible.\n\n## Impact\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nConsider using `>` instead of `>=` in line 387 to prevent the liquidation timeline from overlapping with the bounds check in line 395.\n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/MarginCallPrimaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallPrimaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Flags short under primaryLiquidationCR to be eligible for liquidation after time has passed\n     * @dev Used to flag for primary liquidation method\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     * @param flaggerHint Hint ID for gas-optimized update of short flagger\n     *\n     */\n    function flagShort(address asset, address shorter, uint8 id, uint16 flaggerHint)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n    {\n        if (msg.sender == shorter) revert Errors.CannotFlagSelf();\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][id];\n        short.updateErcDebt(asset);\n\n        if (\n            short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset))\n                >= LibAsset.primaryLiquidationCR(asset)\n        ) {\n            revert Errors.SufficientCollateral();\n        }\n\n        uint256 adjustedTimestamp = LibOrders.getOffsetTimeHours();\n\n        // check if already flagged\n        if (short.flaggerId != 0) {\n            uint256 timeDiff = adjustedTimestamp - short.updatedAt;\n            uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(asset);\n\n            if (timeDiff <= resetLiquidationTime) {\n                revert Errors.MarginCallAlreadyFlagged();\n            }\n        }\n\n        short.setFlagger(cusd, flaggerHint);\n        emit Events.FlagShort(asset, shorter, id, msg.sender, adjustedTimestamp);\n    }\n\n    /**\n     * @notice Liquidates short by forcing shorter to place bid on market\n     * @dev Primary liquidation method. Requires flag\n     * @dev Shorter will bear the cost of forcedBid on market\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     * @return gasFee Estimated cost of gas for the forcedBid\n     * @return ethFilled Amount of eth filled in forcedBid\n     */\n    function liquidate(\n        address asset,\n        address shorter,\n        uint8 id,\n        uint16[] memory shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n        returns (uint88, uint88)\n    {\n        if (msg.sender == shorter) revert Errors.CannotLiquidateSelf();\n\n        //@dev marginCall requires more up-to-date oraclePrice (15 min vs createLimitBid's 1 hour)\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            asset, OF.FifteenMinutes, shortHintArray\n        );\n\n        MTypes.MarginCallPrimary memory m = _setMarginCallStruct(asset, shorter, id);\n\n        if (m.cRatio >= LibAsset.primaryLiquidationCR(m.asset)) {\n            revert Errors.SufficientCollateral();\n        }\n\n        // revert if no asks, or price too high\n        _checklowestSell(m);\n\n        // check if within margin call time window\n        if (!_canLiquidate(m)) {\n            STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n            shortRecord.resetFlag();\n            return (0, 0);\n        }\n\n        _performForcedBid(m, shortHintArray);\n\n        _marginFeeHandler(m);\n\n        _fullorPartialLiquidation(m);\n        emit Events.Liquidate(asset, shorter, id, msg.sender, m.ercDebtMatched);\n\n        return (m.gasFee, m.ethFilled);\n    }\n\n    //PRIVATE FUNCTIONS\n\n    // Reverts if no eligible sells, or if lowest sell price is too high\n    // @dev startingShortId is updated via updateOracleAndStartingShortViaTimeBidOnly() prior to call\n    function _checklowestSell(MTypes.MarginCallPrimary memory m) private view {\n        uint16 lowestAskKey = s.asks[m.asset][Constants.HEAD].nextId;\n        uint16 startingShortId = s.asset[m.asset].startingShortId;\n        uint256 bufferPrice = m.oraclePrice.mul(m.forcedBidPriceBuffer);\n        if (\n            // Checks for no eligible asks\n            (\n                lowestAskKey == Constants.TAIL\n                    || s.asks[m.asset][lowestAskKey].price > bufferPrice\n            )\n            // Checks for no eligible shorts\n            && (\n                startingShortId == Constants.HEAD // means no short >= oracleprice\n                    || s.shorts[m.asset][startingShortId].price > bufferPrice\n            )\n        ) {\n            revert Errors.NoSells();\n        }\n    }\n\n    /**\n     * @notice Sets the memory struct m with initial data\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     *\n     * @return m Memory struct used throughout MarginCallPrimaryFacet.sol\n     */\n\n    function _setMarginCallStruct(address asset, address shorter, uint8 id)\n        private\n        returns (MTypes.MarginCallPrimary memory)\n    {\n        LibShortRecord.updateErcDebt(asset, shorter, id);\n        {\n            MTypes.MarginCallPrimary memory m;\n            m.asset = asset;\n            m.short = s.shortRecords[asset][shorter][id];\n            m.vault = s.asset[asset].vault;\n            m.shorter = shorter;\n            m.minimumCR = LibAsset.minimumCR(asset);\n            m.oraclePrice = LibOracle.getPrice(asset);\n            m.cRatio = m.short.getCollateralRatio(asset);\n            m.forcedBidPriceBuffer = LibAsset.forcedBidPriceBuffer(asset);\n            m.callerFeePct = LibAsset.callerFeePct(m.asset);\n            m.tappFeePct = LibAsset.tappFeePct(m.asset);\n            m.ethDebt = m.short.ercDebt.mul(m.oraclePrice).mul(m.forcedBidPriceBuffer).mul(\n                1 ether + m.tappFeePct + m.callerFeePct\n            ); // ethDebt accounts for forcedBidPriceBuffer and potential fees\n            return m;\n        }\n    }\n\n    /**\n     * @notice Handles the set up and execution of making a forcedBid\n     * @dev Shorter will bear the cost of forcedBid on market\n     * @dev Depending on shorter's cRatio, the TAPP can attempt to fund bid\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     */\n\n    function _performForcedBid(\n        MTypes.MarginCallPrimary memory m,\n        uint16[] memory shortHintArray\n    ) private {\n        uint256 startGas = gasleft();\n        uint88 ercAmountLeft;\n\n        //@dev Provide higher price to better ensure it can fully fill the margin call\n        uint80 _bidPrice = m.oraclePrice.mulU80(m.forcedBidPriceBuffer);\n\n        // Shorter loses leftover collateral to TAPP when unable to maintain CR above the minimum\n        m.loseCollateral = m.cRatio <= m.minimumCR;\n\n        //@dev Increase ethEscrowed by shorter's full collateral for forced bid\n        s.vaultUser[m.vault][address(this)].ethEscrowed += m.short.collateral;\n\n        // Check ability of TAPP plus short collateral to pay back ethDebt\n        if (s.vaultUser[m.vault][address(this)].ethEscrowed < m.ethDebt) {\n            uint96 ercDebtPrev = m.short.ercDebt;\n            if (s.asset[m.asset].ercDebt <= ercDebtPrev) {\n                // Occurs when only one shortRecord in the asset (market)\n                revert Errors.CannotSocializeDebt();\n            }\n            m.loseCollateral = true;\n            // @dev Max ethDebt can only be the ethEscrowed in the TAPP\n            m.ethDebt = s.vaultUser[m.vault][address(this)].ethEscrowed;\n            // Reduce ercDebt proportional to ethDebt\n            m.short.ercDebt = uint88(\n                m.ethDebt.div(_bidPrice.mul(1 ether + m.callerFeePct + m.tappFeePct))\n            ); // @dev(safe-cast)\n            uint96 ercDebtSocialized = ercDebtPrev - m.short.ercDebt;\n            // Update ercDebtRate to socialize loss (increase debt) to other shorts\n            s.asset[m.asset].ercDebtRate +=\n                ercDebtSocialized.divU64(s.asset[m.asset].ercDebt - ercDebtPrev);\n        }\n\n        // @dev MarginCall contract will be the caller. Virtual accounting done later for shorter or TAPP\n        (m.ethFilled, ercAmountLeft) = IDiamond(payable(address(this))).createForcedBid(\n            address(this), m.asset, _bidPrice, m.short.ercDebt, shortHintArray\n        );\n\n        m.ercDebtMatched = m.short.ercDebt - ercAmountLeft;\n\n        //@dev virtually burning the repurchased debt\n        s.assetUser[m.asset][address(this)].ercEscrowed -= m.ercDebtMatched;\n        s.asset[m.asset].ercDebt -= m.ercDebtMatched;\n\n        uint256 gasUsed = startGas - gasleft();\n        //@dev manually setting basefee to 1,000,000 in foundry.toml;\n        //@dev By basing gasFee off of baseFee instead of priority, adversaries are prevent from draining the TAPP\n        m.gasFee = uint88(gasUsed * block.basefee); // @dev(safe-cast)\n    }\n\n    /**\n     * @notice Handles the distribution of marginFee\n     * @dev MarginFee is taken into consideration when determining black swan\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _marginFeeHandler(MTypes.MarginCallPrimary memory m) private {\n        STypes.VaultUser storage VaultUser = s.vaultUser[m.vault][msg.sender];\n        STypes.VaultUser storage TAPP = s.vaultUser[m.vault][address(this)];\n        // distribute fees to TAPP and caller\n        uint88 tappFee = m.ethFilled.mulU88(m.tappFeePct);\n        uint88 callerFee = m.ethFilled.mulU88(m.callerFeePct) + m.gasFee;\n\n        m.totalFee += tappFee + callerFee;\n        //@dev TAPP already received the gasFee for being the forcedBid caller. tappFee nets out.\n        if (TAPP.ethEscrowed >= callerFee) {\n            TAPP.ethEscrowed -= callerFee;\n            VaultUser.ethEscrowed += callerFee;\n        } else {\n            // Give caller (portion of?) tappFee instead of gasFee\n            VaultUser.ethEscrowed += callerFee - m.gasFee + tappFee;\n            m.totalFee -= m.gasFee;\n            TAPP.ethEscrowed -= m.totalFee;\n        }\n    }\n\n    function min88(uint256 a, uint88 b) private pure returns (uint88) {\n        if (a > type(uint88).max) revert Errors.InvalidAmount();\n        return a < b ? uint88(a) : b;\n    }\n\n    /**\n     * @notice Handles accounting in event of full or partial liquidations\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _fullorPartialLiquidation(MTypes.MarginCallPrimary memory m) private {\n        uint88 decreaseCol = min88(m.totalFee + m.ethFilled, m.short.collateral);\n\n        if (m.short.ercDebt == m.ercDebtMatched) {\n            // Full liquidation\n            LibShortRecord.disburseCollateral(\n                m.asset,\n                m.shorter,\n                m.short.collateral,\n                m.short.zethYieldRate,\n                m.short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n            if (!m.loseCollateral) {\n                m.short.collateral -= decreaseCol;\n                s.vaultUser[m.vault][m.shorter].ethEscrowed += m.short.collateral;\n                s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            }\n        } else {\n            // Partial liquidation\n            m.short.ercDebt -= m.ercDebtMatched;\n            m.short.collateral -= decreaseCol;\n            s.shortRecords[m.asset][m.shorter][m.short.id] = m.short;\n\n            s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            LibShortRecord.disburseCollateral(\n                m.asset, m.shorter, decreaseCol, m.short.zethYieldRate, m.short.updatedAt\n            );\n\n            // TAPP absorbs leftover short, unless it already owns the short\n            if (m.loseCollateral && m.shorter != address(this)) {\n                // Delete partially liquidated short\n                LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n                // Absorb leftovers into TAPP short\n                LibShortRecord.fillShortRecord(\n                    m.asset,\n                    address(this),\n                    Constants.SHORT_STARTING_ID,\n                    SR.FullyFilled,\n                    m.short.collateral,\n                    m.short.ercDebt,\n                    s.asset[m.asset].ercDebtRate,\n                    m.short.zethYieldRate\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Helper that evaluates if a short is eligible for liquidation (i.e. flagged and within appropriate time frame)\n     * @dev Shorter has 10 hours after initial flag to bring cRatio up above maintainence margin...\n     * @dev ...After that, the flagger has 2 hours to liquidate the shorter. If short is not liquidated by shorter within that time, ANYBODY can then liquidate...\n     * @dev ...After 16 total hours have passed and the short has not been liquidated, the flag gets reset and the flagging process begins anew\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    // check if within margin call time window\n    function _canLiquidate(MTypes.MarginCallPrimary memory m)\n        private\n        view\n        returns (bool)\n    {\n        //@dev if cRatio is below the minimumCR, allow liquidation regardless of flagging\n        if (m.cRatio < m.minimumCR) return true;\n\n        //@dev Only check if flagger is empty, not updatedAt\n        if (m.short.flaggerId == 0) {\n            revert Errors.ShortNotFlagged();\n        }\n\n        /*\n         * Timeline: \n         * \n         * updatedAt (~0 hrs)\n         * ..\n         * [Errors.MarginCallIneligibleWindow]\n         * ..\n         * firstLiquidationTime (~10hrs, +10 hrs)\n         * ..\n         * [return msg.sender == short.flagger]\n         * ..\n         * secondLiquidationTime (~12hrs, +2 hrs)\n         * ..\n         * [return true (msg.sender is anyone)]\n         * ..\n         * resetLiquidationTime (~16hrs, +4 hrs)\n         * ..\n         * [return false (reset flag)]\n        */\n\n        uint256 timeDiff = LibOrders.getOffsetTimeHours() - m.short.updatedAt;\n        uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(m.asset);\n\n        if (timeDiff >= resetLiquidationTime) {\n            return false;\n        } else {\n            uint256 secondLiquidationTime = LibAsset.secondLiquidationTime(m.asset);\n            bool isBetweenFirstAndSecondLiquidationTime = timeDiff\n                > LibAsset.firstLiquidationTime(m.asset) && timeDiff <= secondLiquidationTime\n                && s.flagMapping[m.short.flaggerId] == msg.sender;\n            bool isBetweenSecondAndResetLiquidationTime =\n                timeDiff > secondLiquidationTime && timeDiff <= resetLiquidationTime;\n            if (\n                !(\n                    (isBetweenFirstAndSecondLiquidationTime)\n                        || (isBetweenSecondAndResetLiquidationTime)\n                )\n            ) {\n                revert Errors.MarginCallIneligibleWindow();\n            }\n\n            return true;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibAsset.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {IAsset} from \"interfaces/IAsset.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\nlibrary LibAsset {\n    // @dev used in ExitShortWallet and MarketShutDown\n    function burnMsgSenderDebt(address asset, uint88 debt) internal {\n        IAsset tokenContract = IAsset(asset);\n        uint256 walletBalance = tokenContract.balanceOf(msg.sender);\n        if (walletBalance < debt) revert Errors.InsufficientWalletBalance();\n        tokenContract.burnFrom(msg.sender, debt);\n        assert(tokenContract.balanceOf(msg.sender) < walletBalance);\n    }\n\n    // default of 16 hours, stored in uint16 as 16\n    // range of [1-48 hours],\n    // 2 decimal places, divide by 100\n    // i.e. 123 -> 1.23 hours\n    // @dev timestamp when it's past time to liquidate a ShortRecord using primary margin call\n    function resetLiquidationTime(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return uint256(s.asset[asset].resetLiquidationTime) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 12 hours, stored in uint16 as 12\n    // range of [1-48 hours],\n    // 2 decimal places, divide by 100\n    // i.e. 123 -> 1.23 hours\n    // @dev timestamp when anyone can liquidate a ShortRecord using primary margin call\n    function secondLiquidationTime(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return\n            uint256(s.asset[asset].secondLiquidationTime) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 10 hours, stored in uint16 as 10\n    // range of [1-48 hours],\n    // 2 decimal places, divide by 100\n    // i.e. 123 -> 1.23 hours\n    // @dev timestamp when only the flagger address can liquidate a ShortRecord using primary margin call\n    function firstLiquidationTime(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return uint256(s.asset[asset].firstLiquidationTime) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 5 ether, stored in uint16 as 500\n    // range of [1-10],\n    // 2 decimal places, divide by 100\n    // i.e. 123 -> 1.23 ether\n    // @dev cRatio that a short order has to begin at\n    function initialMargin(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].initialMargin) * 1 ether)\n            / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 4 ether, stored in uint16 as 400\n    // range of [1-5],\n    // 2 decimal places, divide by 100\n    // i.e. 120 -> 1.2 ether\n    // less than initialMargin\n    // @dev cRatio that a short order can be liquidated at\n    function primaryLiquidationCR(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].primaryLiquidationCR) * 1 ether)\n            / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 1.5 ether, stored in uint16 as 150\n    // range of [1-5],\n    // 2 decimal places, divide by 100\n    // i.e. 120 -> 1.2 ether\n    // @dev cRatio that allows for secondary liquidations to happen\n    // @dev via wallet or ercEscrowed (vault deposited usd)\n    function secondaryLiquidationCR(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].secondaryLiquidationCR) * 1 ether)\n            / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 1.1 ether, stored in uint8 as 110\n    // range of [1-2],\n    // 2 decimal places, divide by 100\n    // i.e. 120 -> 1.2 ether\n    // less than primaryLiquidationCR\n    // @dev buffer/slippage for forcedBid price\n    function forcedBidPriceBuffer(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].forcedBidPriceBuffer) * 1 ether)\n            / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 1.1 ether, stored in uint8 as 110\n    // range of [1-2],\n    // 2 decimal places, divide by 100\n    // i.e. 120 -> 1.2 ether\n    // @dev cRatio where a shorter loses all collateral on liquidation\n    function minimumCR(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return\n            (uint256(s.asset[asset].minimumCR) * 1 ether) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of .025 ether, stored in uint8 as 25\n    // range of [1-2],\n    // 3 decimal places, divide by 1000\n    // i.e. 1234 -> 1.234 ether\n    // @dev percentage of fees given to TAPP during liquidations\n    function tappFeePct(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].tappFeePct) * 1 ether)\n            / Constants.THREE_DECIMAL_PLACES;\n    }\n\n    // default of .005 ether, stored in uint8 as 5\n    // range of [1-2],\n    // 3 decimal places, divide by 1000\n    // i.e. 1234 -> 1.234 ether\n    // @dev percentage of fees given to the margin caller during liquidations\n    function callerFeePct(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].callerFeePct) * 1 ether)\n            / Constants.THREE_DECIMAL_PLACES;\n    }\n\n    // default of .001 ether, stored in uint8 as 1\n    // range of [.001 - .255],\n    // 3 decimal places, divide by 1000\n    // i.e. 125 -> 0.125 ether\n    // @dev dust amount\n    function minBidEth(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return\n            (uint256(s.asset[asset].minBidEth) * 1 ether) / Constants.THREE_DECIMAL_PLACES;\n    }\n\n    // default of .001 ether, stored in uint8 as 1\n    // range of [.001 - .255],\n    // 3 decimal places, divide by 1000\n    // i.e. 125 -> 0.125 ether\n    // @dev dust amount\n    function minAskEth(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return\n            (uint256(s.asset[asset].minAskEth) * 1 ether) / Constants.THREE_DECIMAL_PLACES;\n    }\n\n    // default of 2000 ether, stored in uint16 as 2000\n    // range of [1 - 65,535 (uint16 max)],\n    // i.e. 2000 -> 2000 ether\n    // @dev min short record debt\n    function minShortErc(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return uint256(s.asset[asset].minShortErc) * 1 ether;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibAsset.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {IAsset} from \"interfaces/IAsset.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\nlibrary LibAsset {\n    // @dev used in ExitShortWallet and MarketShutDown\n    function burnMsgSenderDebt(address asset, uint88 debt) internal {\n        IAsset tokenContract = IAsset(asset);\n        uint256 walletBalance = tokenContract.balanceOf(msg.sender);\n        if (walletBalance < debt) revert Errors.InsufficientWalletBalance();\n        tokenContract.burnFrom(msg.sender, debt);\n        assert(tokenContract.balanceOf(msg.sender) < walletBalance);\n    }\n\n    // default of 16 hours, stored in uint16 as 16\n    // range of [1-48 hours],\n    // 2 decimal places, divide by 100\n    // i.e. 123 -> 1.23 hours\n    // @dev timestamp when it's past time to liquidate a ShortRecord using primary margin call\n    function resetLiquidationTime(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return uint256(s.asset[asset].resetLiquidationTime) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 12 hours, stored in uint16 as 12\n    // range of [1-48 hours],\n    // 2 decimal places, divide by 100\n    // i.e. 123 -> 1.23 hours\n    // @dev timestamp when anyone can liquidate a ShortRecord using primary margin call\n    function secondLiquidationTime(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return\n            uint256(s.asset[asset].secondLiquidationTime) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 10 hours, stored in uint16 as 10\n    // range of [1-48 hours],\n    // 2 decimal places, divide by 100\n    // i.e. 123 -> 1.23 hours\n    // @dev timestamp when only the flagger address can liquidate a ShortRecord using primary margin call\n    function firstLiquidationTime(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return uint256(s.asset[asset].firstLiquidationTime) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 5 ether, stored in uint16 as 500\n    // range of [1-10],\n    // 2 decimal places, divide by 100\n    // i.e. 123 -> 1.23 ether\n    // @dev cRatio that a short order has to begin at\n    function initialMargin(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].initialMargin) * 1 ether)\n            / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 4 ether, stored in uint16 as 400\n    // range of [1-5],\n    // 2 decimal places, divide by 100\n    // i.e. 120 -> 1.2 ether\n    // less than initialMargin\n    // @dev cRatio that a short order can be liquidated at\n    function primaryLiquidationCR(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].primaryLiquidationCR) * 1 ether)\n            / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 1.5 ether, stored in uint16 as 150\n    // range of [1-5],\n    // 2 decimal places, divide by 100\n    // i.e. 120 -> 1.2 ether\n    // @dev cRatio that allows for secondary liquidations to happen\n    // @dev via wallet or ercEscrowed (vault deposited usd)\n    function secondaryLiquidationCR(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].secondaryLiquidationCR) * 1 ether)\n            / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 1.1 ether, stored in uint8 as 110\n    // range of [1-2],\n    // 2 decimal places, divide by 100\n    // i.e. 120 -> 1.2 ether\n    // less than primaryLiquidationCR\n    // @dev buffer/slippage for forcedBid price\n    function forcedBidPriceBuffer(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].forcedBidPriceBuffer) * 1 ether)\n            / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of 1.1 ether, stored in uint8 as 110\n    // range of [1-2],\n    // 2 decimal places, divide by 100\n    // i.e. 120 -> 1.2 ether\n    // @dev cRatio where a shorter loses all collateral on liquidation\n    function minimumCR(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return\n            (uint256(s.asset[asset].minimumCR) * 1 ether) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // default of .025 ether, stored in uint8 as 25\n    // range of [1-2],\n    // 3 decimal places, divide by 1000\n    // i.e. 1234 -> 1.234 ether\n    // @dev percentage of fees given to TAPP during liquidations\n    function tappFeePct(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].tappFeePct) * 1 ether)\n            / Constants.THREE_DECIMAL_PLACES;\n    }\n\n    // default of .005 ether, stored in uint8 as 5\n    // range of [1-2],\n    // 3 decimal places, divide by 1000\n    // i.e. 1234 -> 1.234 ether\n    // @dev percentage of fees given to the margin caller during liquidations\n    function callerFeePct(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.asset[asset].callerFeePct) * 1 ether)\n            / Constants.THREE_DECIMAL_PLACES;\n    }\n\n    // default of .001 ether, stored in uint8 as 1\n    // range of [.001 - .255],\n    // 3 decimal places, divide by 1000\n    // i.e. 125 -> 0.125 ether\n    // @dev dust amount\n    function minBidEth(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return\n            (uint256(s.asset[asset].minBidEth) * 1 ether) / Constants.THREE_DECIMAL_PLACES;\n    }\n\n    // default of .001 ether, stored in uint8 as 1\n    // range of [.001 - .255],\n    // 3 decimal places, divide by 1000\n    // i.e. 125 -> 0.125 ether\n    // @dev dust amount\n    function minAskEth(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return\n            (uint256(s.asset[asset].minAskEth) * 1 ether) / Constants.THREE_DECIMAL_PLACES;\n    }\n\n    // default of 2000 ether, stored in uint16 as 2000\n    // range of [1 - 65,535 (uint16 max)],\n    // i.e. 2000 -> 2000 ether\n    // @dev min short record debt\n    function minShortErc(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return uint256(s.asset[asset].minShortErc) * 1 ether;\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarginCallPrimaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallPrimaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Flags short under primaryLiquidationCR to be eligible for liquidation after time has passed\n     * @dev Used to flag for primary liquidation method\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     * @param flaggerHint Hint ID for gas-optimized update of short flagger\n     *\n     */\n    function flagShort(address asset, address shorter, uint8 id, uint16 flaggerHint)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n    {\n        if (msg.sender == shorter) revert Errors.CannotFlagSelf();\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][id];\n        short.updateErcDebt(asset);\n\n        if (\n            short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset))\n                >= LibAsset.primaryLiquidationCR(asset)\n        ) {\n            revert Errors.SufficientCollateral();\n        }\n\n        uint256 adjustedTimestamp = LibOrders.getOffsetTimeHours();\n\n        // check if already flagged\n        if (short.flaggerId != 0) {\n            uint256 timeDiff = adjustedTimestamp - short.updatedAt;\n            uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(asset);\n\n            if (timeDiff <= resetLiquidationTime) {\n                revert Errors.MarginCallAlreadyFlagged();\n            }\n        }\n\n        short.setFlagger(cusd, flaggerHint);\n        emit Events.FlagShort(asset, shorter, id, msg.sender, adjustedTimestamp);\n    }\n\n    /**\n     * @notice Liquidates short by forcing shorter to place bid on market\n     * @dev Primary liquidation method. Requires flag\n     * @dev Shorter will bear the cost of forcedBid on market\n     *\n     * @param asset The market that will be impacted\n     * @"
    }
  ]
}