{
  "Title": "Arbitration resolution can be modified",
  "Content": "The [`setArbitrationResolution`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/escalation-manager/FullPolicyEscalationManager.sol#L149) function in the `FullPolicyEscalationManager` contract can be called multiple times for the same `requestId`. This would allow the contract owner to change the price for a given `requestId`, invalidating the [`resolvedPrice` result](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol#L262) in the `OptimisticAsserter` that was used when the `settleAssertion` function was called.\n\n\nConsider restricting the `setArbitrationResolution` function to only allow setting the resolution once per `requestId`.\n\n\n***Update:** Resolved in [pull request #4319](https://github.com/UMAprotocol/protocol/pull/4319) with commit [76bed2a](https://github.com/UMAprotocol/protocol/commit/76bed2ab121488577c263d7b295a9faa2200060f).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/optimistic-asserter/implementation/escalation-manager/FullPolicyEscalationManager.sol",
      "content": "pragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BaseEscalationManager.sol\";\nimport \"../../interfaces/OptimisticAsserterInterface.sol\";\n\n/**\n * @title The FullPolicyEscalationManager enables the owner to configure all policy parameters and store the arbitration\n * resolutions for the Escalation Manager. Optionally, assertion blocking can be enabled using a whitelist of\n * assertingCallers or assertingCallers and asserters. On the other hand, it enables the determination of whether to\n * arbitrate via the escalation manager as opposed to the DVM, whether to disregard the resolution of a potential\n * dispute arbitrated by the Oracle, and whether to restrict who can register disputes via a whitelistedDisputeCallers.\n * @dev If nothing is configured using the setters and configureEscalationManager method upon deployment, the\n * FullPolicyEscalationManager will return a default policy with all values set to false.\n */\ncontract FullPolicyEscalationManager is BaseEscalationManager, Ownable {\n    struct ArbitrationResolution {\n        bool valueSet; // True if the resolution has been set.\n        bool resolution; // True or false depending on the resolution.\n    }\n\n    event EscalationManagerConfigured(\n        bool blockByAssertingCaller,\n        bool blockByAsserter,\n        bool validateDisputers,\n        bool arbitrateViaEscalationManager,\n        bool discardOracle\n    );\n\n    event ArbitrationResolutionSet(bytes32 indexed identifier, uint256 time, bytes ancillaryData, bool resolution);\n\n    event DisputeCallerWhitelistSet(address disputeCaller, bool whitelisted);\n\n    event AssertingCallerWhitelistSet(address assertingCaller, bool whitelisted);\n\n    event AsserterWhitelistSet(address asserter, bool whitelisted);\n\n    bool public blockByAssertingCaller; // True if assertions are allowed only by whitelisted asserting callers.\n\n    bool public blockByAsserter; // True if assertions are allowed only by whitelisted asserters.\n\n    bool public arbitrateViaEscalationManager; // True if it is determined that the escalation manager should arbitrate.\n\n    bool public discardOracle; // True if escalation manager should disregard the Oracle's resolution.\n\n    bool public validateDisputers; // True if escalation manager should validate disputers via whitelistedDisputeCallers.\n\n    mapping(bytes32 => ArbitrationResolution) public arbitrationResolutions; // Arbitration resolutions for a given identifier, time, and ancillary data.\n\n    mapping(address => bool) public whitelistedDisputeCallers; // Whitelisted disputer that can file disputes.\n\n    mapping(address => bool) public whitelistedAssertingCallers; // Whitelisted assertingCallers that can assert prices.\n\n    mapping(address => bool) public whitelistedAsserters; // Whitelisted asserters that can assert prices.\n\n    /**\n     * @notice Returns the Assertion Policy defined by this contract's parameters and functions.\n     * @param assertionId the ID of the assertion to get the policy for.\n     * @return the Assertion Policy defined by this contract's parameters and functions.\n     * @dev If no configuration is done after deployment, this function returns an all false default policy.\n     */\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\n        bool blocked = _checkIfAssertionBlocked(assertionId);\n        return\n            AssertionPolicy({\n                blockAssertion: blocked, // Block assertion if it is blocked.\n                arbitrateViaEscalationManager: arbitrateViaEscalationManager, // Arbitrate via escalation manager if configured.\n                discardOracle: discardOracle, // Ignore Oracle (DVM or EM) resolution if configured.\n                validateDisputers: validateDisputers // Validate disputers if configured.\n            });\n    }\n\n    /**\n     * @notice Gets the price for identifier and time if it has already been requested and resolved.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return int256 representing the resolved price for the given identifier and timestamp.\n     * @dev This function replicates the interface of the corresponding DVM function to allow the user to use his own\n     * dispute arbitration system when arbitrating via the escalation manager in a DVM-compatible manner. Refer to the\n     * UMA Voting and VotingV2 contracts for further details.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override returns (int256) {\n        bytes32 requestId = keccak256(abi.encode(identifier, time, ancillaryData));\n        require(arbitrationResolutions[requestId].valueSet, \"Arbitration resolution not set\");\n        if (arbitrationResolutions[requestId].resolution) return 1e18;\n        return 0;\n    }\n\n    /**\n     * @notice Returns, given an assertionId and a disputerCaller address, if the disputerCaller is authorised to\n     * dispute the assertion.\n     * @param assertionId the ID of the assertion to check the disputerCaller for.\n     * @param disputeCaller the address of the disputeCaller to check.\n     * @return true if the disputerCaller is authorised to dispute the assertion.\n     * @dev In order for this function to be used by the Optimistic Assertor, validateDisputers must be set to true.\n     */\n    function isDisputeAllowed(bytes32 assertionId, address disputeCaller) public view override returns (bool) {\n        return whitelistedDisputeCallers[disputeCaller];\n    }\n\n    /**\n     * @notice Defines how the assertion policy for each configuration's rules is to be defined.\n     * @param _blockByAssertingCaller true if assertions are allowed only by whitelisted asserting callers.\n     * @param _blockByAsserter true if assertions are allowed only by whitelisted asserters.\n     * @param _validateDisputers true if the escalation manager should validate disputers via whitelistedDisputeCallers.\n     * @param _arbitrateViaEscalationManager true if the escalation manager should arbitrate instead of the DVM.\n     * @param _discardOracle true if the escalation manager should disregard the Oracle's (DVM or EM) resolution.\n     * @dev This setting just activates the rules that will be executed; each rule must additionally be defined using\n     * the other functions.\n     */\n    function configureEscalationManager(\n        bool _blockByAssertingCaller,\n        bool _blockByAsserter,\n        bool _validateDisputers,\n        bool _arbitrateViaEscalationManager,\n        bool _discardOracle\n    ) public onlyOwner {\n        require(!_blockByAsserter || (_blockByAsserter && _blockByAssertingCaller), \"Cannot block only by asserter\");\n        blockByAssertingCaller = _blockByAssertingCaller;\n        blockByAsserter = _blockByAsserter;\n        validateDisputers = _validateDisputers;\n        arbitrateViaEscalationManager = _arbitrateViaEscalationManager;\n        discardOracle = _discardOracle;\n        emit EscalationManagerConfigured(\n            _blockByAssertingCaller,\n            _blockByAsserter,\n            _validateDisputers,\n            _arbitrateViaEscalationManager,\n            _discardOracle\n        );\n    }\n\n    /**\n     * @notice Set the arbitration resolution for a given identifier, time, and ancillary data.\n     * @param identifier uniquely identifies the price requested.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param arbitrationResolution true if the assertion should be resolved as true, false otherwise.\n     * @dev The owner should use this function whenever a dispute arises and it should be arbitrated by the Escalation\n     * Manager; it is up to the owner to determine how to resolve the dispute. See the requestPrice implementation in\n     * BaseEscalationManager, which escalates a dispute to the Escalation Manager for resolution.\n     */\n    function setArbitrationResolution(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bool arbitrationResolution\n    ) public onlyOwner {\n        bytes32 requestId = keccak256(abi.encode(identifier, time, ancillaryData));\n        arbitrationResolutions[requestId] = ArbitrationResolution(true, arbitrationResolution);\n        emit ArbitrationResolutionSet(identifier, time, ancillaryData, arbitrationResolution);\n    }\n\n    /**\n     * @notice Adds a disputerCaller to the whitelist of disputers that can file disputes.\n     * @param disputeCaller the address of the disputeCaller to add.\n     * @dev This function is only used if validateDisputers is set to true.\n     */\n    function setDisputeCallerInWhitelist(address disputeCaller, bool value) public onlyOwner {\n        whitelistedDisputeCallers[disputeCaller] = value;\n        emit DisputeCallerWhitelistSet(disputeCaller, value);\n    }\n\n    /**\n     * @notice Adds an asserter to the whitelist of assertingCallers that can make assertions.\n     * @param assertingCaller the address of the assertingCaller to add.\n     */\n    function setWhitelistedAssertingCallers(address assertingCaller, bool value) public onlyOwner {\n        whitelistedAssertingCallers[assertingCaller] = value;\n        emit AssertingCallerWhitelistSet(assertingCaller, value);\n    }\n\n    /**\n     * @notice Adds an asserter to the whitelist of asserters that can make assertions.\n     * @param asserter the address of the asserter to add.\n     * @dev This function must be used in conjunction with setWhitelistedAssertingCallers in order to have an effect.\n     */\n    function setWhitelistedAsserters(address asserter, bool value) public onlyOwner {\n        whitelistedAsserters[asserter] = value;\n        emit AsserterWhitelistSet(asserter, value);\n    }\n\n    // Checks if an assertion is blocked depending on the blockByAssertingCaller / blockByAsserter settings and the\n    // assertion's properties.\n    function _checkIfAssertionBlocked(bytes32 assertionId) internal view returns (bool) {\n        OptimisticAsserterInterface optimisticAsserter = OptimisticAsserterInterface(msg.sender);\n        OptimisticAsserterInterface.Assertion memory assertion = optimisticAsserter.getAssertion(assertionId);\n        return\n            (blockByAssertingCaller &&\n                !whitelistedAssertingCallers[assertion.escalationManagerSettings.assertingCaller]) ||\n            (blockByAsserter && !whitelistedAsserters[assertion.asserter]);\n    }\n}"
    }
  ]
}