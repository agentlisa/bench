{
  "Title": "[M-08] Burner role cannot be revoked",
  "Content": "\n<https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/GameItems.sol#L185-L188> \n\n<https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/GameItems.sol#L242-L245>\n\nIn `GameItems::setAllowedBurningAddresses` the admin can update the `allowedBurningAddresses` mapping.\n\n```solidity\n    function setAllowedBurningAddresses(address newBurningAddress) public {\n        require(isAdmin[msg.sender]);\n        allowedBurningAddresses[newBurningAddress] = true;\n    }\n```\n\nThis mapping is used to check if the `msg.sender` has permission to burn specific amount of game items from an account. This can happen through the `burn` function.\n\n```solidity\n    function burn(address account, uint256 tokenId, uint256 amount) public {\n        require(allowedBurningAddresses[msg.sender]);\n        _burn(account, tokenId, amount);\n    }\n```\n\nHowever `setAllowedBurningAddresses()` works only one way. I mean that the admin can give permission, but not revoke it.\n\n### Proof of Concept\n\nImagine the following scenario. Admin calls `setAllowedBurningAddresses` with wrong address. Now this address has the permission to burn any token from any user. Now no one can remove the wrong address from the mapping.\n\n### Recommended Mitigation Steps\n\nUse `adjustAdminAccess` function as an example:\n\n```solidity\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }\n```\n\nSo the new `setAllowedBurningAddresses` function should look something like this:\n\n```solidity\n    function adjustBurningAccess(address burningAddress, bool access) public {\n        require(isAdmin[msg.sender]);\n        allowedBurningAddresses[burningAddress] = access;\n    }\n```\n\nNow even if the admin sets the wrong address, he can immediately change it.\n\n**[hickuphh3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/47#issuecomment-1984979002):**\n > Similar to [M-02](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1507), but the root causes are different even though the effect is the same.\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/18\n\n**Status:** Not fully mitigated. Full details in report from [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/52), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/GameItems.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { Neuron } from \"./Neuron.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\n/// @title GameItems\n/// @author ArenaX Labs Inc.\n/// @notice This contract represents a collection of game items used in AI Arena.\ncontract GameItems is ERC1155 {\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when a game item is bought.\n    /// @param buyer The address of the buyer.\n    /// @param tokenId The id of the game item.\n    /// @param quantity The quantity of the game item.\n    event BoughtItem(address buyer, uint256 tokenId, uint256 quantity);\n\n    /// @notice Event emitted when an item is locked and thus cannot be traded.\n    /// @param tokenId The id of the game item.\n    event Locked(uint256 tokenId);\n\n    /// @notice Event emitted when an item is unlocked and can be traded.\n    /// @param tokenId The id of the game item.\n    event Unlocked(uint256 tokenId);\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /// @notice Struct for game item attributes\n    struct GameItemAttributes {\n        string name;\n        bool finiteSupply;\n        bool transferable;\n        uint256 itemsRemaining;\n        uint256 itemPrice;\n        uint256 dailyAllowance;\n    }  \n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The name of this smart contract.\n    string public name = \"AI Arena Game Items\";\n\n    /// @notice The symbol for this smart contract.\n    string public symbol = \"AGI\";\n\n    /// @notice List of all gameItemAttribute structs representing all game items.\n    GameItemAttributes[] public allGameItemAttributes;\n\n    /// @notice The address that recieves funds of purchased game items.\n    address public treasuryAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// Total number of game items.\n    uint256 _itemCount = 0;    \n\n    /// @dev The Neuron contract instance.\n    Neuron _neuronInstance;\n    \n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/ \n\n    /// @notice Mapping of address to tokenId to get remaining allowance.\n    mapping(address => mapping(uint256 => uint256)) public allowanceRemaining;\n\n    /// @notice Mapping of address to tokenId to get replenish timestamp.\n    mapping(address => mapping(uint256 => uint256)) public dailyAllowanceReplenishTime;\n\n    /// @notice Mapping tracking addresses allowed to burn game items.\n    mapping(address => bool) public allowedBurningAddresses;\n\n    /// @notice Mapping tracking addresses allowed to manage game items.\n    mapping(address => bool) public isAdmin;\n\n    /// @notice Mapping of token id to the token URI\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the owner address and the isAdmin mapping to true for the owner address.\n    /// @param ownerAddress Address of contract deployer.\n    /// @param treasuryAddress_ Address of admin signer for messages.\n    constructor(address ownerAddress, address treasuryAddress_) ERC1155(\"https://ipfs.io/ipfs/\") {\n        _ownerAddress = ownerAddress;\n        treasuryAddress = treasuryAddress_;\n        isAdmin[_ownerAddress] = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }  \n\n    /// @notice Adjusts whether the game item can be transferred or not\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param tokenId The token id for the specific game item being adjusted.\n    /// @param transferable Whether the game item is transferable or not\n    function adjustTransferability(uint256 tokenId, bool transferable) external {\n        require(msg.sender == _ownerAddress);\n        allGameItemAttributes[tokenId].transferable = transferable;\n        if (transferable) {\n          emit Unlocked(tokenId);\n        } else {\n          emit Locked(tokenId);\n        }\n    }\n\n    /// @notice Sets the Neuron contract address and instantiates the contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param nrnAddress The address of the Neuron contract.\n    function instantiateNeuronContract(address nrnAddress) external {\n        require(msg.sender == _ownerAddress);\n        _neuronInstance = Neuron(nrnAddress);\n    }\n\n    /// @notice Mints game items and assigns them to the caller.\n    /// @param tokenId The ID of the game item to mint.\n    /// @param quantity The quantity of game items to mint.\n    function mint(uint256 tokenId, uint256 quantity) external {\n        require(tokenId < _itemCount);\n        uint256 price = allGameItemAttributes[tokenId].itemPrice * quantity;\n        require(_neuronInstance.balanceOf(msg.sender) >= price, \"Not enough NRN for purchase\");\n        require(\n            allGameItemAttributes[tokenId].finiteSupply == false || \n            (\n                allGameItemAttributes[tokenId].finiteSupply == true && \n                quantity <= allGameItemAttributes[tokenId].itemsRemaining\n            )\n        );\n        require(\n            dailyAllowanceReplenishTime[msg.sender][tokenId] <= block.timestamp || \n            quantity <= allowanceRemaining[msg.sender][tokenId]\n        );\n\n        _neuronInstance.approveSpender(msg.sender, price);\n        bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, price);\n        if (success) {\n            if (dailyAllowanceReplenishTime[msg.sender][tokenId] <= block.timestamp) {\n                _replenishDailyAllowance(tokenId);\n            }\n            allowanceRemaining[msg.sender][tokenId] -= quantity;\n            if (allGameItemAttributes[tokenId].finiteSupply) {\n                allGameItemAttributes[tokenId].itemsRemaining -= quantity;\n            }\n            _mint(msg.sender, tokenId, quantity, bytes(\"random\"));\n            emit BoughtItem(msg.sender, tokenId, quantity);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Sets the allowed burning addresses.\n    /// @dev Only the admins are authorized to call this function.\n    /// @param newBurningAddress The address to allow for burning.\n    function setAllowedBurningAddresses(address newBurningAddress) public {\n        require(isAdmin[msg.sender]);\n        allowedBurningAddresses[newBurningAddress] = true;\n    }\n\n    /// @notice Sets the token URI for a game item\n    /// @dev Only the admins are authorized to call this function.\n    /// @param tokenId The token id for the specific game item being queried.    \n    /// @param _tokenURI The token id to be set\n    function setTokenURI(uint256 tokenId, string memory _tokenURI) public {\n        require(isAdmin[msg.sender]);\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /// @notice Creates a new game item with the specified attributes.\n    /// @dev Only the admins are authorized to call this function.\n    /// @param name_ The name of the game item.\n    /// @param tokenURI The URI of the game item.\n    /// @param finiteSupply Determines if the game item has a finite supply.\n    /// @param transferable Boolean of whether or not the game item can be transferred\n    /// @param itemsRemaining The number of remaining items for the game item.\n    /// @param itemPrice The price of the game item.\n    /// @param dailyAllowance The daily allowance for the game item.\n    function createGameItem(\n        string memory name_,\n        string memory tokenURI,\n        bool finiteSupply,\n        bool transferable,\n        uint256 itemsRemaining,\n        uint256 itemPrice,\n        uint16 dailyAllowance\n    ) \n        public \n    {\n        require(isAdmin[msg.sender]);\n        allGameItemAttributes.push(\n            GameItemAttributes(\n                name_,\n                finiteSupply,\n                transferable,\n                itemsRemaining,\n                itemPrice,\n                dailyAllowance\n            )\n        );\n        if (!transferable) {\n          emit Locked(_itemCount);\n        }\n        setTokenURI(_itemCount, tokenURI);\n        _itemCount += 1;\n    }\n\n    /// @notice Burns a specified amount of game items from an account.\n    /// @dev Only addresses listed in allowedBurningAddresses are authorized to call this function.\n    /// @param account The account from which the game items will be burned.\n    /// @param tokenId The ID of the game item.\n    /// @param amount The amount of game items to burn.\n    function burn(address account, uint256 tokenId, uint256 amount) public {\n        require(allowedBurningAddresses[msg.sender]);\n        _burn(account, tokenId, amount);\n    }\n\n    /// @notice Returns the URI where the contract metadata is stored.\n    /// @return URI where the contract metadata is stored.\n    function contractURI() public pure returns (string memory) {\n        return \"ipfs://bafybeih3witscmml3padf4qxbea5jh4rl2xp67aydqvqsxmyuzipwtpnii\";\n    }\n\n    /// @notice Override the uri function to return the custom URI for each token\n    /// @param tokenId The token id for the specific game item being queried.\n    /// @return tokenURI The URI for the game item metadata.\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        string memory customURI = _tokenURIs[tokenId];\n        if (bytes(customURI).length > 0) {\n            return customURI;\n        }\n        return super.uri(tokenId);\n    }        \n\n    /// @notice Gets the amount of a game item that a user is still able to mint for the day\n    /// @param owner The user's address.\n    /// @param tokenId The token id for the specific game item being queried.\n    /// @return remaining number of items that can be minted for the day.\n    function getAllowanceRemaining(address owner, uint256 tokenId) public view returns (uint256) {\n        uint256 remaining = allowanceRemaining[owner][tokenId];\n        if (dailyAllowanceReplenishTime[owner][tokenId] <= block.timestamp) {\n            remaining = allGameItemAttributes[tokenId].dailyAllowance;\n        }\n        return remaining;\n    }\n\n    /// @notice Returns the remaining supply of a game item with the specified tokenId.\n    /// @param tokenId The ID of the game item.\n    /// @return Remaining items for the queried token ID.\n    function remainingSupply(uint256 tokenId) public view returns (uint256) {\n        return allGameItemAttributes[tokenId].itemsRemaining;\n    }\n\n    /// @notice Returns the total number of unique game tokens outstanding.\n    /// @return Total number of unique game tokens.\n    function uniqueTokensOutstanding() public view returns (uint256) {\n        return allGameItemAttributes.length;\n    }\n\n    /// @notice Safely transfers an NFT from one address to another.\n    /// @dev Added a check to see if the game item is transferable.\n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId,\n        uint256 amount,\n        bytes memory data\n    ) \n        public \n        override(ERC1155)\n    {\n        require(allGameItemAttributes[tokenId].transferable);\n        super.safeTransferFrom(from, to, tokenId, amount, data);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Replenishes the daily allowance for the specified game item token.\n    /// @dev This function is called when a user buys a game item after the replenish interval has passed.\n    /// @param tokenId The ID of the game item token.\n    function _replenishDailyAllowance(uint256 tokenId) private {\n        allowanceRemaining[msg.sender][tokenId] = allGameItemAttributes[tokenId].dailyAllowance;\n        dailyAllowanceReplenishTime[msg.sender][tokenId] = uint32(block.timestamp + 1 days);\n    }    \n}"
    },
    {
      "filename": "src/GameItems.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { Neuron } from \"./Neuron.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\n/// @title GameItems\n/// @author ArenaX Labs Inc.\n/// @notice This contract represents a collection of game items used in AI Arena.\ncontract GameItems is ERC1155 {\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when a game item is bought.\n    /// @param buyer The address of the buyer.\n    /// @param tokenId The id of the game item.\n    /// @param quantity The quantity of the game item.\n    event BoughtItem(address buyer, uint256 tokenId, uint256 quantity);\n\n    /// @notice Event emitted when an item is locked and thus cannot be traded.\n    /// @param tokenId The id of the game item.\n    event Locked(uint256 tokenId);\n\n    /// @notice Event emitted when an item is unlocked and can be traded.\n    /// @param tokenId The id of the game item.\n    event Unlocked(uint256 tokenId);\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /// @notice Struct for game item attributes\n    struct GameItemAttributes {\n        string name;\n        bool finiteSupply;\n        bool transferable;\n        uint256 itemsRemaining;\n        uint256 itemPrice;\n        uint256 dailyAllowance;\n    }  \n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The name of this smart contract.\n    string public name = \"AI Arena Game Items\";\n\n    /// @notice The symbol for this smart contract.\n    string public symbol = \"AGI\";\n\n    /// @notice List of all gameItemAttribute structs representing all game items.\n    GameItemAttributes[] public allGameItemAttributes;\n\n    /// @notice The address that recieves funds of purchased game items.\n    address public treasuryAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// Total number of game items.\n    uint256 _itemCount = 0;    \n\n    /// @dev The Neuron contract instance.\n    Neuron _neuronInstance;\n    \n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/ \n\n    /// @notice Mapping of address to tokenId to get remaining allowance.\n    mapping(address => mapping(uint256 => uint256)) public allowanceRemaining;\n\n    /// @notice Mapping of address to tokenId to get replenish timestamp.\n    mapping(address => mapping(uint256 => uint256)) public dailyAllowanceReplenishTime;\n\n    /// @notice Mapping tracking addresses allowed to burn game items.\n    mapping(address => bool) public allowedBurningAddresses;\n\n    /// @notice Mapping tracking addresses allowed to manage game items.\n    mapping(address => bool) public isAdmin;\n\n    /// @notice Mapping of token id to the token URI\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the owner address and the isAdmin mapping to true for the owner address.\n    /// @param ownerAddress Address of contract deployer.\n    /// @param treasuryAddress_ Address of admin signer for messages.\n    constructor(address ownerAddress, address treasuryAddress_) ERC1155(\"https://ipfs.io/ipfs/\") {\n        _ownerAddress = ownerAddress;\n        treasuryAddress = treasuryAddress_;\n        isAdmin[_ownerAddress] = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }  \n\n    /// @notice Adjusts whether the game item can be transferred or not\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param tokenId The token id for the specific game item being adjusted.\n    /// @param transferable Whether the game item is transferable or not\n    function adjustTransferability(uint256 tokenId, bool transferable) external {\n        require(msg.sender == _ownerAddress);\n        allGameItemAttributes[tokenId].transferable = transferable;\n        if (transferable) {\n          emit Unlocked(tokenId);\n        } else {\n          emit Locked(tokenId);\n        }\n    }\n\n    /// @notice Sets the Neuron contract address and instantiates the contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param nrnAddress The address of the Neuron contract.\n    function instantiateNeuronContract(address nrnAddress) external {\n        require(msg.sender == _ownerAddress);\n        _neuronInstance = Neuron(nrnAddress);\n    }\n\n    /// @notice Mints game items and assigns them to the caller.\n    /// @param tokenId The ID of the game item to mint.\n    /// @param quantity The quantity of game items to mint.\n    function mint(uint256 tokenId, uint256 quantity) external {\n        require(tokenId < _itemCount);\n        uint256 price = allGameItemAttributes[tokenId].itemPrice * quantity;\n        require(_neuronInstance.balanceOf(msg.sender) >= price, \"Not enough NRN for purchase\");\n        require(\n            allGameItemAttributes[tokenId].finiteSupply == false || \n            (\n                allGameItemAttributes[tokenId].finiteSupply == true && \n                quantity <= allGameItemAttributes[tokenId].itemsRemaining\n            )\n        );\n        require(\n            dailyAllowanceReplenishTime[msg.sender][tokenId] <= block.timestamp || \n            quantity <= allowanceRemaining[msg.sender][tokenId]\n        );\n\n        _neuronInstance.approveSpender(msg.sender, price);\n        bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, price);\n        if (success) {\n            if (dailyAllowanceReplenishTime[msg.sender][tokenId] <= block.timestamp) {\n                _replenishDailyAllowance(tokenId);\n            }\n            allowanceRemaining[msg.sender][tokenId] -= quantity;\n            if (allGameItemAttributes[tokenId].finiteSupply) {\n                allGameItemAttributes[tokenId].itemsRemaining -= quantity;\n            }\n            _mint(msg.sender, tokenId, quantity, bytes(\"random\"));\n            emit BoughtItem(msg.sender, tokenId, quantity);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Sets the allowed burning addresses.\n    /// @dev Only the admins are authorized to call this function.\n    /// @param newBurningAddress The address to allow for burning.\n    function setAllowedBurningAddresses(address newBurningAddress) public {\n        require(isAdmin[msg.sender]);\n        allowedBurningAddresses[newBurningAddress] = true;\n    }\n\n    /// @notice Sets the token URI for a game item\n    /// @dev Only the admins are authorized to call this function.\n    /// @param tokenId The token id for the specific game item being queried.    \n    /// @param _tokenURI The token id to be set\n    function setTokenURI(uint256 tokenId, string memory _tokenURI) public {\n        require(isAdmin[msg.sender]);\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /// @notice Creates a new game item with the specified attributes.\n    /// @dev Only the admins are authorized to call this function.\n    /// @param name_ The name of the game item.\n    /// @param tokenURI The URI of the game item.\n    /// @param finiteSupply Determines if the game item has a finite supply.\n    /// @param transferable Boolean of whether or not the game item can be transferred\n    /// @param itemsRemaining The number of remaining items for the game item.\n    /// @param itemPrice The price of the game item.\n    /// @param dailyAllowance The daily allowance for the game item.\n    function createGameItem(\n        string memory name_,\n        string memory tokenURI,\n        bool finiteSupply,\n        bool transferable,\n        uint256 itemsRemaining,\n        uint256 itemPrice,\n        uint16 dailyAllowance\n    ) \n        public \n    {\n        require(isAdmin[msg.sender]);\n        allGameItemAttributes.push(\n            GameItemAttributes(\n                name_,\n                finiteSupply,\n                transferable,\n                itemsRemaining,\n                itemPrice,\n                dailyAllowance\n            )\n        );\n        if (!transferable) {\n          emit Locked(_itemCount);\n        }\n        setTokenURI(_itemCount, tokenURI);\n        _itemCount += 1;\n    }\n\n    /// @notice Burns a specified amount of game items from an account.\n    /// @dev Only addresses listed in allowedBurningAddresses are authorized to call this function.\n    /// @param account The account from which the game items will be burned.\n    /// @param tokenId The ID of the game item.\n    /// @param amount The amount of game items to burn.\n    function burn(address account, uint256 tokenId, uint256 amount) public {\n        require(allowedBurningAddresses[msg.sender]);\n        _burn(account, tokenId, amount);\n    }\n\n    /// @notice Returns the URI where the contract metadata is stored.\n    /// @return URI where the contract metadata is stored.\n    function contractURI() public pure returns (string memory) {\n        return \"ipfs://bafybeih3witscmml3padf4qxbea5jh4rl2xp67aydqvqsxmyuzipwtpnii\";\n    }\n\n    /// @notice Override the uri function to return the custom URI for each token\n    /// @param tokenId The token id for the specific game item being queried.\n    /// @return tokenURI The URI for the game item metadata.\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        string memory customURI = _tokenURIs[tokenId];\n        if (bytes(customURI).length > 0) {\n            return customURI;\n        }\n        return super.uri(tokenId);\n    }        \n\n    /// @notice Gets the amount of a game item that a user is still able to mint for the day\n    /// @param owner The user's address.\n    /// @param tokenId The token id for the specific game item being queried.\n    /// @return remaining number of items that can be minted for the day.\n    function getAllowanceRemaining(address owner, uint256 tokenId) public view returns (uint256) {\n        uint256 remaining = allowanceRemaining[owner][tokenId];\n        if (dailyAllowanceReplenishTime[owner][tokenId] <= block.timestamp) {\n            remaining = allGameItemAttributes[tokenId].dailyAllowance;\n        }\n        return remaining;\n    }\n\n    /// @notice Returns the remaining supply of a game item with the specified tokenId.\n    /// @param tokenId The ID of the game item.\n    /// @return Remaining items for the queried token ID.\n    function remainingSupply(uint256 tokenId) public view returns (uint256) {\n        return allGameItemAttributes[tokenId].itemsRemaining;\n    }\n\n    /// @notice Returns the total number of unique game tokens outstanding.\n    /// @return Total number of unique game tokens.\n    function uniqueTokensOutstanding() public view returns (uint256) {\n        return allGameItemAttributes.length;\n    }\n\n    /// @notice Safely transfers an NFT from one address to another.\n    /// @dev Added a check to see if the game item is transferable.\n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId,\n        uint256 amount,\n        bytes memory data\n    ) \n        public \n        override(ERC1155)\n    {\n        require(allGameItemAttributes[tokenId].transferable);\n        super.safeTransferFrom(from, to, tokenId, amount, data);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Replenishes the daily allowance for the specified game item token.\n    /// @dev This function is called when a user buys a game item after the replenish interval has passed.\n    /// @param tokenId The ID of the game item token.\n    function _replenishDailyAllowance(uint256 tokenId) private {\n        allowanceRemaining[msg.sender][tokenId] = allGameItemAttributes[tokenId].dailyAllowance;\n        dailyAllowanceReplenishTime[msg.sender][tokenId] = uint32(block.timestamp + 1 days);\n    }    \n}"
    }
  ]
}