{
  "Title": "[M-27] Tokens without properties can be minted and cannot be rendered",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/metadata/MetadataRenderer.sol#L172-L201\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L172\n\n\n# Vulnerability details\n\n## Impact\nIt's possible to mint tokens when properties haven't yet been set in `MetadataRenderer`. Such tokens won't be possible\nto render due to [this check](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/metadata/MetadataRenderer.sol#L222)\nin the `getAttributes` function of `MetaRenderer` contract. There's no way to fix such tokens after they were minted\nsince the number of properties of each token [is stored individually](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/metadata/MetadataRenderer.sol#L216-L219), thus a patched `MetadataRenderer`\nand a proxy contract need to be deployed.\n## Proof of Concept\nConsider this test case:\n```solidity\nfunction testRevert_MintedWithoutProperties() public {\n    // Deploying a token and a metadata renderer\n    address tknImpl = address(new Token(address(this)));\n    Token tkn = Token(address(new ERC1967Proxy(tknImpl, \"\")));\n\n    address rndrImpl = address(new MetadataRenderer(address(this)));\n    MetadataRenderer rndr = MetadataRenderer(address(new ERC1967Proxy(rndrImpl, \"\")));\n\n    bytes memory initString = abi.encode(\"Test\", \"Test\", \"Test\", \"Test\", \"Test\");\n    IManager.FounderParams[] memory founders = new IManager.FounderParams[](1);\n    founders[0] = IManager.FounderParams({ wallet: address(this), ownershipPct: 1, vestExpiry: 4 weeks });\n\n    tkn.initialize(founders, initString, address(rndr), address(this));\n    rndr.initialize(initString, address(tkn), address(this), address(this));\n\n    // Exploit starts here:\n\n    // Properties haven't been added yet...\n    assertEq(rndr.propertiesCount(), 0);\n\n    // but minting is still possible.\n    tkn.mint();\n    assertEq(tkn.totalSupply(), 2); // 1 to the founder, 1 to the auction\n\n    // When trying to render a token without properties, there's a revert.\n    vm.expectRevert(abi.encodeWithSignature(\"TOKEN_NOT_MINTED(uint256)\", 0));\n    rndr.getAttributes(0);\n}\n```\n\nThe call to `getAttributes()` reverts because the token's attributes were not set since properties hadn't been\nadded to the metadata renderer.\n## Recommended Mitigation Steps\nIn the [onMinted()](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/metadata/MetadataRenderer.sol#L171) function of `MetadataRenderer`, ensure that `properties.length` is greater than 0.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-nouns-builder-contest",
  "Code": [
    {
      "filename": "src/token/metadata/MetadataRenderer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Base64 } from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { LibUintToString } from \"sol2string/contracts/LibUintToString.sol\";\nimport { UriEncode } from \"sol-uriencode/src/UriEncode.sol\";\n\nimport { UUPS } from \"../../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../../lib/utils/Ownable.sol\";\n\nimport { MetadataRendererStorageV1 } from \"./storage/MetadataRendererStorageV1.sol\";\nimport { IPropertyIPFSMetadataRenderer } from \"./interfaces/IPropertyIPFSMetadataRenderer.sol\";\nimport { IManager } from \"../../manager/IManager.sol\";\n\n/// @title Metadata Renderer\n/// @author Iain Nash & Rohan Kulkarni\n/// @notice A DAO's artwork generator and renderer\ncontract MetadataRenderer is IPropertyIPFSMetadataRenderer, UUPS, Ownable, MetadataRendererStorageV1 {\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's token metadata renderer\n    /// @param _initStrings The encoded token and metadata initialization strings\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder address responsible for adding initial properties\n    /// @param _treasury The DAO treasury that will own the contract\n    function initialize(\n        bytes calldata _initStrings,\n        address _token,\n        address _founder,\n        address _treasury\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Decode the token initialization strings\n        (string memory _name, , string memory _description, string memory _contractImage, string memory _rendererBase) = abi.decode(\n            _initStrings,\n            (string, string, string, string, string)\n        );\n\n        // Store the renderer settings\n        settings.name = _name;\n        settings.description = _description;\n        settings.contractImage = _contractImage;\n        settings.rendererBase = _rendererBase;\n        settings.token = _token;\n        settings.treasury = _treasury;\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n    }\n\n    ///                                                          ///\n    ///                     PROPERTIES & ITEMS                   ///\n    ///                                                          ///\n\n    /// @notice The number of properties\n    function propertiesCount() external view returns (uint256) {\n        return properties.length;\n    }\n\n    /// @notice The number of items in a property\n    /// @param _propertyId The property id\n    function itemsCount(uint256 _propertyId) external view returns (uint256) {\n        return properties[_propertyId].items.length;\n    }\n\n    /// @notice Adds properties and/or items to be pseudo-randomly chosen from during token minting\n    /// @param _names The names of the properties to add\n    /// @param _items The items to add to each property\n    /// @param _ipfsGroup The IPFS base URI and extension\n    function addProperties(\n        string[] calldata _names,\n        ItemParam[] calldata _items,\n        IPFSGroup calldata _ipfsGroup\n    ) external onlyOwner {\n        // Cache the existing amount of IPFS data stored\n        uint256 dataLength = ipfsData.length;\n\n        // If this is the first time adding properties and/or items:\n        if (dataLength == 0) {\n            // Transfer ownership to the DAO treasury\n            transferOwnership(settings.treasury);\n        }\n\n        // Add the IPFS group information\n        ipfsData.push(_ipfsGroup);\n\n        // Cache the number of existing properties\n        uint256 numStoredProperties = properties.length;\n\n        // Cache the number of new properties\n        uint256 numNewProperties = _names.length;\n\n        // Cache the number of new items\n        uint256 numNewItems = _items.length;\n\n        unchecked {\n            // For each new property:\n            for (uint256 i = 0; i < numNewProperties; ++i) {\n                // Append storage space\n                properties.push();\n\n                // Get the new property id\n                uint256 propertyId = numStoredProperties + i;\n\n                // Store the property name\n                properties[propertyId].name = _names[i];\n\n                emit PropertyAdded(propertyId, _names[i]);\n            }\n\n            // For each new item:\n            for (uint256 i = 0; i < numNewItems; ++i) {\n                // Cache the id of the associated property\n                uint256 _propertyId = _items[i].propertyId;\n\n                // Offset the id if the item is for a new property\n                // Note: Property ids under the hood are offset by 1\n                if (_items[i].isNewProperty) {\n                    _propertyId += numStoredProperties;\n                }\n\n                // Get the pointer to the other items for the property\n                Item[] storage items = properties[_propertyId].items;\n\n                // Append storage space\n                items.push();\n\n                // Get the index of the new item\n                // Cannot underflow as the items array length is ensured to be at least 1\n                uint256 newItemIndex = items.length - 1;\n\n                // Store the new item\n                Item storage newItem = items[newItemIndex];\n\n                // Store the new item's name and reference slot\n                newItem.name = _items[i].name;\n                newItem.referenceSlot = uint16(dataLength);\n\n                emit ItemAdded(_propertyId, newItemIndex);\n            }\n        }\n    }\n\n    ///                                                          ///\n    ///                     ATTRIBUTE GENERATION                 ///\n    ///                                                          ///\n\n    /// @notice Generates attributes for a token upon mint\n    /// @param _tokenId The ERC-721 token id\n    function onMinted(uint256 _tokenId) external returns (bool) {\n        // Ensure the caller is the token contract\n        if (msg.sender != settings.token) revert ONLY_TOKEN();\n\n        // Compute some randomness for the token id\n        uint256 seed = _generateSeed(_tokenId);\n\n        // Get the pointer to store generated attributes\n        uint16[16] storage tokenAttributes = attributes[_tokenId];\n\n        // Cache the total number of properties available\n        uint256 numProperties = properties.length;\n\n        // Store the total as reference in the first slot of the token's array of attributes\n        tokenAttributes[0] = uint16(numProperties);\n\n        unchecked {\n            // For each property:\n            for (uint256 i = 0; i < numProperties; ++i) {\n                // Get the number of items to choose from\n                uint256 numItems = properties[i].items.length;\n\n                // Use the token's seed to select an item\n                tokenAttributes[i + 1] = uint16(seed % numItems);\n\n                // Adjust the randomness\n                seed >>= 16;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice The properties and query string for a generated token\n    /// @param _tokenId The ERC-721 token id\n    function getAttributes(uint256 _tokenId) public view returns (bytes memory aryAttributes, bytes memory queryString) {\n        // Get the token's query string\n        queryString = abi.encodePacked(\n            \"?contractAddress=\",\n            Strings.toHexString(uint256(uint160(address(this))), 20),\n            \"&tokenId=\",\n            Strings.toString(_tokenId)\n        );\n\n        // Get the token's generated attributes\n        uint16[16] memory tokenAttributes = attributes[_tokenId];\n\n        // Cache the number of properties when the token was minted\n        uint256 numProperties = tokenAttributes[0];\n\n        // Ensure the given token was minted\n        if (numProperties == 0) revert TOKEN_NOT_MINTED(_tokenId);\n\n        unchecked {\n            // Cache the index of the last property\n            uint256 lastProperty = numProperties - 1;\n\n            // For each of the token's properties:\n            for (uint256 i = 0; i < numProperties; ++i) {\n                // Check if this is the last property\n                bool isLast = i == lastProperty;\n\n                // Get a copy of the property\n                Property memory property = properties[i];\n\n                // Get the token's generated attribute\n                uint256 attribute = tokenAttributes[i + 1];\n\n                // Get the associated item data\n                Item memory item = property.items[attribute];\n\n                // Store the encoded attributes and query string\n                aryAttributes = abi.encodePacked(aryAttributes, '\"', property.name, '\": \"', item.name, '\"', isLast ? \"\" : \",\");\n                queryString = abi.encodePacked(queryString, \"&images=\", _getItemImage(item, property.name));\n            }\n        }\n    }\n\n    /// @dev Generates a psuedo-random seed for a token id\n    function _generateSeed(uint256 _tokenId) private view returns (uint256) {\n        return uint256(keccak256(abi.encode(_tokenId, blockhash(block.number), block.coinbase, block.timestamp)));\n    }\n\n    /// @dev Encodes the reference URI of an item\n    function _getItemImage(Item memory _item, string memory _propertyName) private view returns (string memory) {\n        return\n            UriEncode.uriEncode(\n                string(\n                    abi.encodePacked(ipfsData[_item.referenceSlot].baseUri, _propertyName, \"/\", _item.name, ipfsData[_item.referenceSlot].extension)\n                )\n            );\n    }\n\n    ///                                                          ///\n    ///                            URIs                          ///\n    ///                                                          ///\n\n    /// @notice The contract URI\n    function contractURI() external view returns (string memory) {\n        return\n            _encodeAsJson(\n                abi.encodePacked(\n                    '{\"name\": \"',\n                    settings.name,\n                    '\", \"description\": \"',\n                    settings.description,\n                    '\", \"image\": \"',\n                    settings.contractImage,\n                    '\"}'\n                )\n            );\n    }\n\n    /// @notice The token URI\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\n        (bytes memory aryAttributes, bytes memory queryString) = getAttributes(_tokenId);\n        return\n            _encodeAsJson(\n                abi.encodePacked(\n                    '{\"name\": \"',\n                    settings.name,\n                    \" #\",\n                    LibUintToString.toString(_tokenId),\n                    '\", \"description\": \"',\n                    settings.description,\n                    '\", \"image\": \"',\n                    settings.rendererBase,\n                    queryString,\n                    '\", \"properties\": {',\n                    aryAttributes,\n                    \"}}\"\n                )\n            );\n    }\n\n    /// @dev Encodes data to JSON\n    function _encodeAsJson(bytes memory _jsonBlob) private pure returns (string memory) {\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(_jsonBlob)));\n    }\n\n    ///                                                          ///\n    ///                       METADATA SETTINGS                  ///\n    ///                                                          ///\n\n    /// @notice The associated ERC-721 token\n    function token() external view returns (address) {\n        return settings.token;\n    }\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The contract image\n    function contractImage() external view returns (string memory) {\n        return settings.contractImage;\n    }\n\n    /// @notice The renderer base\n    function rendererBase() external view returns (string memory) {\n        return settings.rendererBase;\n    }\n\n    /// @notice The collection description\n    function description() external view returns (string memory) {\n        return settings.description;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the contract image\n    /// @param _newContractImage The new contract image\n    function updateContractImage(string memory _newContractImage) external onlyOwner {\n        emit ContractImageUpdated(settings.contractImage, _newContractImage);\n\n        settings.contractImage = _newContractImage;\n    }\n\n    /// @notice Updates the renderer base\n    /// @param _newRendererBase The new renderer base\n    function updateRendererBase(string memory _newRendererBase) external onlyOwner {\n        emit RendererBaseUpdated(settings.rendererBase, _newRendererBase);\n\n        settings.rendererBase = _newRendererBase;\n    }\n\n    /// @notice Updates the collection description\n    /// @param _newDescription The new description\n    function updateDescription(string memory _newDescription) external onlyOwner {\n        emit DescriptionUpdated(settings.description, _newDescription);\n\n        settings.description = _newDescription;\n    }\n\n    ///                                                          ///\n    ///                        METADATA UPGRADE                  ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract to a valid implementation\n    /// @dev This function is called in UUPS `upgradeTo` & `upgradeToAndCall`\n    /// @param _impl The address of the new implementation\n    function _authorizeUpgrade(address _impl) internal view override onlyOwner {\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _impl)) revert INVALID_UPGRADE(_impl);\n    }\n}"
    },
    {
      "filename": "src/token/Token.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { ERC721Votes } from \"../lib/token/ERC721Votes.sol\";\nimport { ERC721 } from \"../lib/token/ERC721.sol\";\n\nimport { TokenStorageV1 } from \"./storage/TokenStorageV1.sol\";\nimport { IBaseMetadata } from \"./metadata/interfaces/IBaseMetadata.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IToken } from \"./IToken.sol\";\n\n/// @title Token\n/// @author Rohan Kulkarni\n/// @notice A DAO's ERC-721 governance token\ncontract Token is IToken, UUPS, ReentrancyGuard, ERC721Votes, TokenStorageV1 {\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token contract\n    /// @param _founders The DAO founders\n    /// @param _initStrings The encoded token and metadata initialization strings\n    /// @param _metadataRenderer The token's metadata renderer\n    /// @param _auction The token's auction house\n    function initialize(\n        IManager.FounderParams[] calldata _founders,\n        bytes calldata _initStrings,\n        address _metadataRenderer,\n        address _auction\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Store the founders and compute their allocations\n        _addFounders(_founders);\n\n        // Decode the token name and symbol\n        (string memory _name, string memory _symbol, , , ) = abi.decode(_initStrings, (string, string, string, string, string));\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_name, _symbol);\n\n        // Store the metadata renderer and auction house\n        settings.metadataRenderer = IBaseMetadata(_metadataRenderer);\n        settings.auction = _auction;\n    }\n\n    /// @dev Called upon initialization to add founders and compute their vesting allocations\n    /// @param _founders The list of DAO founders\n    function _addFounders(IManager.FounderParams[] calldata _founders) internal {\n        // Cache the number of founders\n        uint256 numFounders = _founders.length;\n\n        // Used to store the total percent ownership among the founders\n        uint256 totalOwnership;\n\n        unchecked {\n            // For each founder:\n            for (uint256 i; i < numFounders; ++i) {\n                // Cache the percent ownership\n                uint256 founderPct = _founders[i].ownershipPct;\n\n                // Continue if no ownership is specified\n                if (founderPct == 0) continue;\n\n                // Update the total ownership and ensure it's valid\n                if ((totalOwnership += uint8(founderPct)) > 100) revert INVALID_FOUNDER_OWNERSHIP();\n\n                // Compute the founder's id\n                uint256 founderId = settings.numFounders++;\n\n                // Get the pointer to store the founder\n                Founder storage newFounder = founder[founderId];\n\n                // Store the founder's vesting details\n                newFounder.wallet = _founders[i].wallet;\n                newFounder.vestExpiry = uint32(_founders[i].vestExpiry);\n                newFounder.ownershipPct = uint8(founderPct);\n\n                // Compute the vesting schedule\n                uint256 schedule = 100 / founderPct;\n\n                // Used to store the base token id the founder will recieve\n                uint256 baseTokenId;\n\n                // For each token to vest:\n                for (uint256 j; j < founderPct; ++j) {\n                    // Get the available token id\n                    baseTokenId = _getNextTokenId(baseTokenId);\n\n                    // Store the founder as the recipient\n                    tokenRecipient[baseTokenId] = newFounder;\n\n                    emit MintScheduled(baseTokenId, founderId, newFounder);\n\n                    // Update the base token id\n                    (baseTokenId += schedule) % 100;\n                }\n            }\n\n            // Store the founders' details\n            settings.totalOwnership = uint8(totalOwnership);\n            settings.numFounders = uint8(numFounders);\n        }\n    }\n\n    /// @dev Finds the next available base token id for a founder\n    /// @param _tokenId The ERC-721 token id\n    function _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {\n        unchecked {\n            while (tokenRecipient[_tokenId].wallet != address(0)) ++_tokenId;\n\n            return _tokenId;\n        }\n    }\n\n    ///                                                          ///\n    ///                             MINT                         ///\n    ///                                                          ///\n\n    /// @notice Mints tokens to the auction house for bidding and handles founder vesting\n    function mint() external nonReentrant returns (uint256 tokenId) {\n        // Cache the auction address\n        address minter = settings.auction;\n\n        // Ensure the caller is the auction\n        if (msg.sender != minter) revert ONLY_AUCTION();\n\n        // Cannot realistically overflow\n        unchecked {\n            do {\n                // Get the next token to mint\n                tokenId = settings.totalSupply++;\n\n                // Lookup whether the token is for a founder, and mint accordingly if so\n            } while (_isForFounder(tokenId));\n        }\n\n        // Mint the next available token to the auction house for bidding\n        _mint(minter, tokenId);\n    }\n\n    /// @dev Overrides _mint to include attribute generation\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _mint(address _to, uint256 _tokenId) internal override {\n        // Mint the token\n        super._mint(_to, _tokenId);\n\n        // Generate the token attributes\n        if (!settings.metadataRenderer.onMinted(_tokenId)) revert NO_METADATA_GENERATED();\n    }\n\n    /// @dev Checks if a given token is for a founder and mints accordingly\n    /// @param _tokenId The ERC-721 token id\n    function _isForFounder(uint256 _tokenId) private returns (bool) {\n        // Get the base token id\n        uint256 baseTokenId = _tokenId % 100;\n\n        // If there is no scheduled recipient:\n        if (tokenRecipient[baseTokenId].wallet == address(0)) {\n            return false;\n\n            // Else if the founder is still vesting:\n        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n            // Mint the token to the founder\n            _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n\n            return true;\n\n            // Else the founder has finished vesting:\n        } else {\n            // Remove them from future lookups\n            delete tokenRecipient[baseTokenId];\n\n            return false;\n        }\n    }\n\n    ///                                                          ///\n    ///                             BURN                         ///\n    ///                                                          ///\n\n    /// @notice Burns a token that did not see any bids\n    /// @param _tokenId The ERC-721 token id\n    function burn(uint256 _tokenId) external {\n        // Ensure the caller is the auction house\n        if (msg.sender != settings.auction) revert ONLY_AUCTION();\n\n        // Burn the token\n        _burn(_tokenId);\n    }\n\n    ///                                                          ///\n    ///                           METADATA                       ///\n    ///                                                          ///\n\n    /// @notice The URI for a token\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.tokenURI(_tokenId);\n    }\n\n    /// @notice The URI for the contract\n    function contractURI() public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.contractURI();\n    }\n\n    ///                                                          ///\n    ///                           FOUNDERS                       ///\n    ///                                                          ///\n\n    /// @notice The number of founders\n    function totalFounders() external view returns (uint256) {\n        return settings.numFounders;\n    }\n\n    /// @notice The founders total percent ownership\n    function totalFounderOwnership() external view returns (uint256) {\n        return settings.totalOwnership;\n    }\n\n    /// @notice The vesting details of a founder\n    /// @param _founderId The founder id\n    function getFounder(uint256 _founderId) external view returns (Founder memory) {\n        return founder[_founderId];\n    }\n\n    /// @notice The vesting details of all founders\n    function getFounders() external view returns (Founder[] memory) {\n        // Cache the number of founders\n        uint256 numFounders = settings.numFounders;\n\n        // Get a temporary array to hold all founders\n        Founder[] memory founders = new Founder[](numFounders);\n\n        // Cannot realistically overflow\n        unchecked {\n            // Add each founder to the array\n            for (uint256 i; i < numFounders; ++i) founders[i] = founder[i];\n        }\n\n        return founders;\n    }\n\n    /// @notice The founder scheduled to receive the given token id\n    /// NOTE: If a founder is returned, there's no guarantee they'll receive the token as vesting expiration is not considered\n    /// @param _tokenId The ERC-721 token id\n    function getScheduledRecipient(uint256 _tokenId) external view returns (Founder memory) {\n        return tokenRecipient[_tokenId % 100];\n    }\n\n    ///                                                          ///\n    ///                           SETTINGS                       ///\n    ///                                                          ///\n\n    /// @notice The total supply of tokens\n    function totalSupply() external view returns (uint256) {\n        return settings.totalSupply;\n    }\n\n    /// @notice The address of the auction house\n    function auction() external view returns (address) {\n        return settings.auction;\n    }\n\n    /// @notice The address of the metadata renderer\n    function metadataRenderer() external view returns (address) {\n        return address(settings.metadataRenderer);\n    }\n\n    /// @notice The address of the owner\n    function owner() public view returns (address) {\n        return settings.metadataRenderer.owner();\n    }\n\n    ///                                                          ///\n    ///                         TOKEN UPGRADE                    ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override {\n        // Ensure the caller is the shared owner of the token and metadata renderer\n        if (msg.sender != owner()) revert ONLY_OWNER();\n\n        // Ensure the implementation is valid\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    }
  ]
}