{
  "Title": "Assembly and bytecode without extensive documentation",
  "Content": "The Marmo contracts include multiple [assembly blocks](https://github.com/ripio/marmo-contracts/blob/d3fb5922a4f01e47d585343d08cccfad659b3584/contracts/MarmoStork.sol#L98) and [a big amount of bytecode](https://github.com/ripio/marmo-contracts/blob/d3fb5922a4f01e47d585343d08cccfad659b3584/contracts/MarmoStork.sol#L19-L27). While it is not a security vulnerability right now, this is at the same time the most complicated and the most critical part of the system, it needs to be documented with extra care.\n\n\nThese assembly blocks and bytecode are not extensively documented. Developers may misunderstand the purpose of the code and cause unexpected errors when attempting to modify it.\n\n\nConsider clearly documenting the intent of each block of assembly code, as well as exhaustively documenting every opcode and every parameter. This will guide future contributors and reviewers when trying to understand, extend or fix the code.\n\n\n***Update:*** *Partially fixed. On* [*pull request #28*](https://github.com/ripio/marmo-contracts/pull/28/files) *the bytecode of the proxy was moved to a* [*library*](https://github.com/ripio/marmo-contracts/blob/cbe0388bd7a624f8ca73d805af4d31c5d0b53960/contracts/commons/MinimalProxy.sol)*, making the* [*MarmoStork constructor*](https://github.com/ripio/marmo-contracts/blob/cbe0388bd7a624f8ca73d805af4d31c5d0b53960/contracts/MarmoStork.sol#L34) *clearer.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/MarmoStork.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Marmo.sol\";\nimport \"./commons/Bytes.sol\";\n\n// MarmoStork creates all Marmo wallets\n// every address has a designated marmo wallet\n// and can send transactions by signing Meta-Tx (Intents)\n//\n// All wallets are proxies pointing to a single\n// source contract, to make deployment costs viable\ncontract MarmoStork {\n    using Bytes for address;\n    using Bytes for bytes1;\n    using Bytes for bytes;\n\n    // Minimal proxy contract\n    // by Agusx1211\n    bytes constant CODE1 = hex\"60\"; // + <size>                                   // Copy code to memory\n    bytes constant CODE2 = hex\"80600b6000396000f3\";                               // Return and deploy contract\n    bytes constant CODE3 = hex\"3660008037600080366000\";   // + <pushx> + <source> // Proxy, copy calldata and start delegatecall\n    bytes constant CODE4 = hex\"5af43d6000803e60003d9160\"; // + <return jump>      // Do delegatecall and return jump\n    bytes constant CODE5 = hex\"57fd5bf3\";                                         // Return proxy\n\n    bytes1 constant BASE_SIZE = 0x1d;\n    bytes1 constant PUSH_1 = 0x60;\n    bytes1 constant BASE_RETURN_JUMP = 0x1b;\n\n    // Bytecode to deploy marmo wallets\n    bytes public bytecode;\n\n    // Hash of the bytecode\n    // used to calculate create2 result\n    bytes32 public hash;\n\n    // Marmo Source contract\n    // all proxies point here\n    address public marmo;\n\n    // Creates a new MarmoStork (Marmo wallet Factory)\n    // with wallets pointing to the _source contract reference\n    // notice: _source may contain less than 20 bytes\n    // the difference will be filled with 0s at the beginning of the address\n    constructor(bytes memory _source) public {\n        // Generate and save wallet creator bytecode using the provided '_source'\n        bytecode = Bytes.concat(\n            CODE1,\n            BASE_SIZE.plus(_source.length).toBytes(),\n            CODE2,\n            CODE3.concat(PUSH_1.plus(_source.length - 1)).concat(_source),\n            CODE4.concat(BASE_RETURN_JUMP.plus(_source.length)),\n            CODE5\n        );\n\n        // Precalculate init_code hash\n        hash = keccak256(bytecode);\n        \n        // Destroy the '_source' provided, if is not destroyed\n        Marmo marmoc = Marmo(_source.toAddress());\n        if (marmoc.signer() == address(0)) {\n            marmoc.init(address(65536));\n        }\n\n        // Validate, the signer of _source should be \"INVALID_ADDRESS\" (destroyed)\n        require(marmoc.signer() == address(65536), \"Error init Marmo source\");\n\n        // Save the _source address, casting to address (160 bits)\n        marmo = address(marmoc);\n    }\n    \n    // Calculates the Marmo wallet for a given signer\n    // the wallet contract will be deployed in a deterministic manner\n    function marmoOf(address _signer) external view returns (address) {\n        // CREATE2 address\n        return address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        byte(0xff),\n                        address(this),\n                        bytes32(uint256(_signer)),\n                        hash\n                    )\n                )\n            )\n        );\n    }\n\n    // Deploys the Marmo wallet of a given _signer\n    // all ETH sent will be forwarded to the wallet\n    function reveal(address _signer) external payable {\n        // Load init code from storage\n        bytes memory proxyCode = bytecode;\n\n        // Create wallet proxy using CREATE2\n        // use _signer as salt\n        Marmo p;\n        assembly {\n            p := create2(0, add(proxyCode, 0x20), mload(proxyCode), _signer)\n        }\n\n        // Init wallet with provided _signer\n        // and forward all Ether\n        p.init.value(msg.value)(_signer);\n    }\n}"
    }
  ]
}