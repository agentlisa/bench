{
  "Title": "[H-05] Users can get immediate profit when deposit and redeem in `PerpetualAtlanticVaultLP`",
  "Content": "\nDue to wrong order between `previewDeposit` and `updateFunding` inside `PerpetualAtlanticVaultLP.deposit`. In some case, user can get immediate profit when call `deposit` and `redeem` in the same block.\n\n### Proof of Concept\n\nWhen `deposit` is called, first `previewDeposit` will be called to get the `shares` based on `assets` provided.\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L118-L135>\n\n```solidity\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n>>> require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n>>> perpetualAtlanticVault.updateFunding();\n\n    // Need to transfer before minting or ERC777s could reenter.\n    collateral.transferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    _totalCollateral += assets;\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n```\n\nInside  `previewDeposit`, it will call `convertToShares` to calculate the shares.\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L269-L271>\n\n```solidity\n  function previewDeposit(uint256 assets) public view returns (uint256) {\n    return convertToShares(assets);\n  }\n```\n\n`convertToShares` calculate shares based on the provided `assets`, `supply` and `totalVaultCollateral`. `_totalCollateral` is also part of `totalVaultCollateral` that will be used inside the calculation.\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L274-L284>\n\n```solidity\n  function convertToShares(\n    uint256 assets\n  ) public view returns (uint256 shares) {\n    uint256 supply = totalSupply;\n    uint256 rdpxPriceInAlphaToken = perpetualAtlanticVault.getUnderlyingPrice();\n\n    uint256 totalVaultCollateral = totalCollateral() +\n      ((_rdpxCollateral * rdpxPriceInAlphaToken) / 1e8);\n    return\n      supply == 0 ? assets : assets.mulDivDown(supply, totalVaultCollateral);\n  }\n```\n\nAfter the shares calculation, `perpetualAtlanticVault.updateFunding` will be called, this function will send collateral to vault LP if conditions are met and increase `_totalCollateral`.\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L502-L524>\n\n```solidity\n  function updateFunding() public {\n    updateFundingPaymentPointer();\n    uint256 currentFundingRate = fundingRates[latestFundingPaymentPointer];\n    uint256 startTime = lastUpdateTime == 0\n      ? (nextFundingPaymentTimestamp() - fundingDuration)\n      : lastUpdateTime;\n    lastUpdateTime = block.timestamp;\n\n>>> collateralToken.safeTransfer(\n      addresses.perpetualAtlanticVaultLP,\n      (currentFundingRate * (block.timestamp - startTime)) / 1e18\n    );\n\n>>> IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).addProceeds(\n      (currentFundingRate * (block.timestamp - startTime)) / 1e18\n    );\n\n    emit FundingPaid(\n      msg.sender,\n      ((currentFundingRate * (block.timestamp - startTime)) / 1e18),\n      latestFundingPaymentPointer\n    );\n  }\n```\n\nIt means if `_totalCollateral` is increased, user can get immediate profit when they call `redeem`.\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L145-L175>\n\n```solidity\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public returns (uint256 assets, uint256 rdpxAmount) {\n    perpetualAtlanticVault.updateFunding();\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n>>> (assets, rdpxAmount) = redeemPreview(shares);\n\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    _rdpxCollateral -= rdpxAmount;\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    collateral.transfer(receiver, assets);\n\n    IERC20WithBurn(rdpx).safeTransfer(receiver, rdpxAmount);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n  }\n```\n\nWhen `redeemPreview` is called and trigger `_convertToAssets`, it will used this newly increased `_totalCollateral`.\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L218-L229>\n\n```solidity\n  function _convertToAssets(\n    uint256 shares\n  ) internal view virtual returns (uint256 assets, uint256 rdpxAmount) {\n    uint256 supply = totalSupply;\n    return\n      (supply == 0)\n        ? (shares, 0)\n        : (\n>>>       shares.mulDivDown(totalCollateral(), supply),\n          shares.mulDivDown(_rdpxCollateral, supply)\n        );\n  }\n```\n\nThis will open sandwich and MEV attack opportunity inside vault LP.\n\nFoundry PoC :\n\nAdd this test to `Unit` contract inside `/tests/rdpxV2-core/Unit.t.sol`, also add `import \"forge-std/console.sol\";` in the contract :\n\n```solidity\n    function testSandwichProvideFunding() public {\n        rdpxV2Core.bond(20 * 1e18, 0, address(this));\n        rdpxV2Core.bond(20 * 1e18, 0, address(this));\n        skip(86400 * 7);\n        vault.addToContractWhitelist(address(rdpxV2Core));\n        vault.updateFundingPaymentPointer();\n\n        // test funding succesfully\n        uint256[] memory strikes = new uint256[](1);\n        strikes[0] = 15e6;\n        // calculate funding is done properly\n        vault.calculateFunding(strikes);\n\n        uint256 funding = vault.totalFundingForEpoch(\n            vault.latestFundingPaymentPointer()\n        );\n\n        // send funding to rdpxV2Core and call sync\n        weth.transfer(address(rdpxV2Core), funding);\n        rdpxV2Core.sync();\n        rdpxV2Core.provideFunding();\n        skip(86400 * 6);\n        uint256 balanceBefore = weth.balanceOf(address(this));\n        console.log(\"balance of eth before deposit and redeem:\");\n        console.log(balanceBefore);\n        weth.approve(address(vaultLp), type(uint256).max);\n        uint256 shares = vaultLp.deposit(1e18, address(this));\n        vaultLp.redeem(shares, address(this), address(this));\n        uint256 balanceAfter = weth.balanceOf(address(this));\n        console.log(\"balance after deposit and redeem:\");\n        console.log(balanceAfter);\n        console.log(\"immediate profit :\");\n        console.log(balanceAfter - balanceBefore);\n    }\n```\n\nRun the test :\n\n    forge test --match-contract Unit --match-test testSandwichProvideFunding -vvv\n\nLog Output :\n\n    Logs:\n      balance of eth before deposit and redeem:\n      18665279470073000000000\n\n      balance after deposit and redeem:\n      18665299797412715619861\n\n      immediate profit :\n      20327339715619861\n\n### Recommended Mitigation Steps\n\nMove `perpetualAtlanticVault.updateFunding` before `previewDeposit` is calculated.\n\n```diff\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public virtual returns (uint256 shares) {\n+    perpetualAtlanticVault.updateFunding();\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n-    perpetualAtlanticVault.updateFunding();\n\n    // Need to transfer before minting or ERC777s could reenter.\n    collateral.transferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    _totalCollateral += assets;\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n```\n\n**[witherblock (Dopex) disagreed with severity and commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/867#issuecomment-1734035693):**\n > Please bump this to high\n\n**[Alex the Entreprenerd (Judge) increased severity to High](https://github.com/code-423n4/2023-08-dopex-findings/issues/867#issuecomment-1759390605)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVaultLP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\n// Libraries\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\n\n/**\n * @title PerpetaulAtlanticVault LP Token\n */\ncontract PerpetualAtlanticVaultLP is ERC20, IPerpetualAtlanticVaultLP {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  // ================================ EVENTS ================================ //\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @dev The address of the perpetual Atlantic Vault contract creating the lp token\n  IPerpetualAtlanticVault public perpetualAtlanticVault;\n\n  /// @dev The collateral token\n  ERC20 public collateral;\n\n  /// @dev The symbol reperesenting the underlying asset of the perpetualatlanticvault lp\n  string public underlyingSymbol;\n\n  /// @dev The symbol representing the collateral token of the perpetualatlanticvault lp\n  string public collateralSymbol;\n\n  /// @dev Total collateral available\n  uint256 private _totalCollateral;\n\n  /// @dev Active collateral\n  uint256 private _activeCollateral;\n\n  /// @dev Total rdpx available\n  uint256 private _rdpxCollateral;\n\n  /// @dev address of rdpx token\n  address public rdpx;\n\n  /// @dev address of the rdpx rdpxV2Core contract\n  address public rdpxRdpxV2Core;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /**\n   * @param _perpetualAtlanticVault The address of the perpetual atlantic vault contract creating the lp token\n   * @param _rdpxRdpxV2Core The address of the rdpx rdpxV2Core contract\n   * @param _collateral The address of the collateral asset in the perpetualatlanticvault contract\n   * @param _collateralSymbol The symbol of the collateral asset token\n   * @param _rdpx The address of the rdpx token\n   */\n  constructor(\n    address _perpetualAtlanticVault,\n    address _rdpxRdpxV2Core,\n    address _collateral,\n    address _rdpx,\n    string memory _collateralSymbol\n  )\n    ERC20(\n      \"PerpetualAtlanticVault LP Token\",\n      _collateralSymbol,\n      ERC20(_collateral).decimals()\n    )\n  {\n    require(\n      _perpetualAtlanticVault != address(0) || _rdpx != address(0),\n      \"ZERO_ADDRESS\"\n    );\n    perpetualAtlanticVault = IPerpetualAtlanticVault(_perpetualAtlanticVault);\n    rdpxRdpxV2Core = _rdpxRdpxV2Core;\n    collateralSymbol = _collateralSymbol;\n    rdpx = _rdpx;\n    collateral = ERC20(_collateral);\n\n    symbol = string.concat(_collateralSymbol, \"-LP\");\n\n    collateral.approve(_perpetualAtlanticVault, type(uint256).max);\n    ERC20(rdpx).approve(_perpetualAtlanticVault, type(uint256).max);\n  }\n\n  // ================================ PUBLIC FUNCTIONS ================================ //\n\n  /**\n   * @notice deposit into ERC4626 token\n   * @param assets assets\n   * @param receiver receiver\n   * @return shares shares of LP tokens minted\n   */\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    perpetualAtlanticVault.updateFunding();\n\n    // Need to transfer before minting or ERC777s could reenter.\n    collateral.transferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    _totalCollateral += assets;\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n\n  /**\n   * @notice redeem ERC4626 token\n   * @param shares shares\n   * @param receiver receiver\n   * @param owner owner\n   * @return assets native tokens to be received\n   * @return rdpxAmount rdpx tokens to be received\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public returns (uint256 assets, uint256 rdpxAmount) {\n    perpetualAtlanticVault.updateFunding();\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n    (assets, rdpxAmount) = redeemPreview(shares);\n\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    _rdpxCollateral -= rdpxAmount;\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    collateral.transfer(receiver, assets);\n\n    IERC20WithBurn(rdpx).safeTransfer(receiver, rdpxAmount);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n  }\n\n  // ================================ PERP VAULT FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function lockCollateral(uint256 amount) public onlyPerpVault {\n    _activeCollateral += amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function unlockLiquidity(uint256 amount) public onlyPerpVault {\n    _activeCollateral -= amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addProceeds(uint256 proceeds) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) >= _totalCollateral + proceeds,\n      \"Not enough collateral token was sent\"\n    );\n    _totalCollateral += proceeds;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function subtractLoss(uint256 loss) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) == _totalCollateral - loss,\n      \"Not enough collateral was sent out\"\n    );\n    _totalCollateral -= loss;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addRdpx(uint256 amount) public onlyPerpVault {\n    require(\n      IERC20WithBurn(rdpx).balanceOf(address(this)) >= _rdpxCollateral + amount,\n      \"Not enough rdpx token was sent\"\n    );\n    _rdpxCollateral += amount;\n  }\n\n  // ================================ INTERNAL FUNCTUONS ================================ //\n\n  function _convertToAssets(\n    uint256 shares\n  ) internal view virtual returns (uint256 assets, uint256 rdpxAmount) {\n    uint256 supply = totalSupply;\n    return\n      (supply == 0)\n        ? (shares, 0)\n        : (\n          shares.mulDivDown(totalCollateral(), supply),\n          shares.mulDivDown(_rdpxCollateral, supply)\n        );\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address,\n    uint256\n  ) internal virtual {}\n\n  // ================================ VIEWS ================================ //\n\n  /// @notice Returns the total active collateral\n  function activeCollateral() public view returns (uint256) {\n    return _activeCollateral;\n  }\n\n  /// @notice Returns the total collateral\n  function totalCollateral() public view returns (uint256) {\n    return _totalCollateral;\n  }\n\n  /// @notice Returns the total rdpx collateral\n  function rdpxCollateral() public view returns (uint256) {\n    return _rdpxCollateral;\n  }\n\n  /// @notice Returns the total available collateral\n  function totalAvailableCollateral() public view returns (uint256) {\n    return _totalCollateral - _activeCollateral;\n  }\n\n  // ================================ PUBLIC VIEW FUNCTIONS ================================ //\n\n  /// @notice Returns the amount of collateral and rdpx per share\n  function redeemPreview(\n    uint256 shares\n  ) public view returns (uint256, uint256) {\n    return _convertToAssets(shares);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function previewDeposit(uint256 assets) public view returns (uint256) {\n    return convertToShares(assets);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function convertToShares(\n    uint256 assets\n  ) public view returns (uint256 shares) {\n    uint256 supply = totalSupply;\n    uint256 rdpxPriceInAlphaToken = perpetualAtlanticVault.getUnderlyingPrice();\n\n    uint256 totalVaultCollateral = totalCollateral() +\n      ((_rdpxCollateral * rdpxPriceInAlphaToken) / 1e8);\n    return\n      supply == 0 ? assets : assets.mulDivDown(supply, totalVaultCollateral);\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 /*shares*/) internal {\n    require(\n      assets <= totalAvailableCollateral(),\n      \"Not enough available assets to satisfy withdrawal\"\n    );\n    _totalCollateral -= assets;\n  }\n\n  // ================================ MODIFIERS ================================ //\n  modifier onlyPerpVault() {\n    require(\n      msg.sender == address(perpetualAtlanticVault),\n      \"Only the perp vault can call this function\"\n    );\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVaultLP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\n// Libraries\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\n\n/**\n * @title PerpetaulAtlanticVault LP Token\n */\ncontract PerpetualAtlanticVaultLP is ERC20, IPerpetualAtlanticVaultLP {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  // ================================ EVENTS ================================ //\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @dev The address of the perpetual Atlantic Vault contract creating the lp token\n  IPerpetualAtlanticVault public perpetualAtlanticVault;\n\n  /// @dev The collateral token\n  ERC20 public collateral;\n\n  /// @dev The symbol reperesenting the underlying asset of the perpetualatlanticvault lp\n  string public underlyingSymbol;\n\n  /// @dev The symbol representing the collateral token of the perpetualatlanticvault lp\n  string public collateralSymbol;\n\n  /// @dev Total collateral available\n  uint256 private _totalCollateral;\n\n  /// @dev Active collateral\n  uint256 private _activeCollateral;\n\n  /// @dev Total rdpx available\n  uint256 private _rdpxCollateral;\n\n  /// @dev address of rdpx token\n  address public rdpx;\n\n  /// @dev address of the rdpx rdpxV2Core contract\n  address public rdpxRdpxV2Core;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /**\n   * @param _perpetualAtlanticVault The address of the perpetual atlantic vault contract creating the lp token\n   * @param _rdpxRdpxV2Core The address of the rdpx rdpxV2Core contract\n   * @param _collateral The address of the collateral asset in the perpetualatlanticvault contract\n   * @param _collateralSymbol The symbol of the collateral asset token\n   * @param _rdpx The address of the rdpx token\n   */\n  constructor(\n    address _perpetualAtlanticVault,\n    address _rdpxRdpxV2Core,\n    address _collateral,\n    address _rdpx,\n    string memory _collateralSymbol\n  )\n    ERC20(\n      \"PerpetualAtlanticVault LP Token\",\n      _collateralSymbol,\n      ERC20(_collateral).decimals()\n    )\n  {\n    require(\n      _perpetualAtlanticVault != address(0) || _rdpx != address(0),\n      \"ZERO_ADDRESS\"\n    );\n    perpetualAtlanticVault = IPerpetualAtlanticVault(_perpetualAtlanticVault);\n    rdpxRdpxV2Core = _rdpxRdpxV2Core;\n    collateralSymbol = _collateralSymbol;\n    rdpx = _rdpx;\n    collateral = ERC20(_collateral);\n\n    symbol = string.concat(_collateralSymbol, \"-LP\");\n\n    collateral.approve(_perpetualAtlanticVault, type(uint256).max);\n    ERC20(rdpx).approve(_perpetualAtlanticVault, type(uint256).max);\n  }\n\n  // ================================ PUBLIC FUNCTIONS ================================ //\n\n  /**\n   * @notice deposit into ERC4626 token\n   * @param assets assets\n   * @param receiver receiver\n   * @return shares shares of LP tokens minted\n   */\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    perpetualAtlanticVault.updateFunding();\n\n    // Need to transfer before minting or ERC777s could reenter.\n    collateral.transferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    _totalCollateral += assets;\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n\n  /**\n   * @notice redeem ERC4626 token\n   * @param shares shares\n   * @param receiver receiver\n   * @param owner owner\n   * @return assets native tokens to be received\n   * @return rdpxAmount rdpx tokens to be received\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public returns (uint256 assets, uint256 rdpxAmount) {\n    perpetualAtlanticVault.updateFunding();\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n    (assets, rdpxAmount) = redeemPreview(shares);\n\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    _rdpxCollateral -= rdpxAmount;\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    collateral.transfer(receiver, assets);\n\n    IERC20WithBurn(rdpx).safeTransfer(receiver, rdpxAmount);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n  }\n\n  // ================================ PERP VAULT FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function lockCollateral(uint256 amount) public onlyPerpVault {\n    _activeCollateral += amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function unlockLiquidity(uint256 amount) public onlyPerpVault {\n    _activeCollateral -= amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addProceeds(uint256 proceeds) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) >= _totalCollateral + proceeds,\n      \"Not enough collateral token was sent\"\n    );\n    _totalCollateral += proceeds;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function subtractLoss(uint256 loss) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) == _totalCollateral - loss,\n      \"Not enough collateral was sent out\"\n    );\n    _totalCollateral -= loss;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addRdpx(uint256 amount) public onlyPerpVault {\n    require(\n      IERC20WithBurn(rdpx).balanceOf(address(this)) >= _rdpxCollateral + amount,\n      \"Not enough rdpx token was sent\"\n    );\n    _rdpxCollateral += amount;\n  }\n\n  // ================================ INTERNAL FUNCTUONS ================================ //\n\n  function _convertToAssets(\n    uint256 shares\n  ) internal view virtual returns (uint256 assets, uint256 rdpxAmount) {\n    uint256 supply = totalSupply;\n    return\n      (supply == 0)\n        ? (shares, 0)\n        : (\n          shares.mulDivDown(totalCollateral(), supply),\n          shares.mulDivDown(_rdpxCollateral, supply)\n        );\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address,\n    uint256\n  ) internal virtual {}\n\n  // ================================ VIEWS ================================ //\n\n  /// @notice Returns the total active collateral\n  function activeCollateral() public view returns (uint256) {\n    return _activeCollateral;\n  }\n\n  /// @notice Returns the total collateral\n  function totalCollateral() public view returns (uint256) {\n    return _totalCollateral;\n  }\n\n  /// @notice Returns the total rdpx collateral\n  function rdpxCollateral() public view returns (uint256) {\n    return _rdpxCollateral;\n  }\n\n  /// @notice Returns the total available collateral\n  function totalAvailableCollateral() public view returns (uint256) {\n    return _totalCollateral - _activeCollateral;\n  }\n\n  // ================================ PUBLIC VIEW FUNCTIONS ================================ //\n\n  /// @notice Returns the amount of collateral and rdpx per share\n  function redeemPreview(\n    uint256 shares\n  ) public view returns (uint256, uint256) {\n    return _convertToAssets(shares);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function previewDeposit(uint256 assets) public view returns (uint256) {\n    return convertToShares(assets);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function convertToShares(\n    uint256 assets\n  ) public view returns (uint256 shares) {\n    uint256 supply = totalSupply;\n    uint256 rdpxPriceInAlphaToken = perpetualAtlanticVault.getUnderlyingPrice();\n\n    uint256 totalVaultCollateral = totalCollateral() +\n      ((_rdpxCollateral * rdpxPriceInAlphaToken) / 1e8);\n    return\n      supply == 0 ? assets : assets.mulDivDown(supply, totalVaultCollateral);\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 /*shares*/) internal {\n    require(\n      assets <= totalAvailableCollateral(),\n      \"Not enough available assets to satisfy withdrawal\"\n    );\n    _totalCollateral -= assets;\n  }\n\n  // ================================ MODIFIERS ================================ //\n  modifier onlyPerpVault() {\n    require(\n      msg.sender == address(perpetualAtlanticVault),\n      \"Only the perp vault can call this function\"\n    );\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVaultLP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\n// Libraries\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\n\n/**\n * @title PerpetaulAtlanticVault LP Token\n */\ncontract PerpetualAtlanticVaultLP is ERC20, IPerpetualAtlanticVaultLP {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  // ================================ EVENTS ================================ //\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @dev The address of the perpetual Atlantic Vault contract creating the lp token\n  IPerpetualAtlanticVault public perpetualAtlanticVault;\n\n  /// @dev The collateral token\n  ERC20 public collateral;\n\n  /// @dev The symbol reperesenting the underlying asset of the perpetualatlanticvault lp\n  string public underlyingSymbol;\n\n  /// @dev The symbol representing the collateral token of the perpetualatlanticvault lp\n  string public collateralSymbol;\n\n  /// @dev Total collateral available\n  uint256 private _totalCollateral;\n\n  /// @dev Active collateral\n  uint256 private _activeCollateral;\n\n  /// @dev Total rdpx available\n  uint256 private _rdpxCollateral;\n\n  /// @dev address of rdpx token\n  address public rdpx;\n\n  /// @dev address of the rdpx rdpxV2Core contract\n  address public rdpxRdpxV2Core;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /**\n   * @param _perpetualAtlanticVault The address of the perpetual atlantic vault contract creating the lp token\n   * @param _rdpxRdpxV2Core The address of the rdpx rdpxV2Core contract\n   * @param _collateral The address of the collateral asset in the perpetualatlanticvault contract\n   * @param _collateralSymbol The symbol of the collateral asset token\n   * @param _rdpx The address of the rdpx token\n   */\n  constructor(\n    address _perpetualAtlanticVault,\n    address _rdpxRdpxV2Core,\n    address _collateral,\n    address _rdpx,\n    string memory _collateralSymbol\n  )\n    ERC20(\n      \"PerpetualAtlanticVault LP Token\",\n      _collateralSymbol,\n      ERC20(_collateral).decimals()\n    )\n  {\n    require(\n      _perpetualAtlanticVault != address(0) || _rdpx != address(0),\n      \"ZERO_ADDRESS\"\n    );\n    perpetualAtlanticVault = IPerpetualAtlanticVault(_perpetualAtlanticVault);\n    rdpxRdpxV2Core = _rdpxRdpxV2Core;\n    collateralSymbol = _collateralSymbol;\n    rdpx = _rdpx;\n    collateral = ERC20(_collateral);\n\n    symbol = string.concat(_collateralSymbol, \"-LP\");\n\n    collateral.approve(_perpetualAtlanticVault, type(uint256).max);\n    ERC20(rdpx).approve(_perpetualAtlanticVault, type(uint256).max);\n  }\n\n  // ================================ PUBLIC FUNCTIONS ================================ //\n\n  /**\n   * @notice deposit into ERC4626 token\n   * @param assets assets\n   * @param receiver receiver\n   * @return shares shares of LP tokens minted\n   */\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    perpetualAtlanticVault.updateFunding();\n\n    // Need to transfer before minting or ERC777s could reenter.\n    collateral.transferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    _totalCollateral += assets;\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n\n  /**\n   * @notice redeem ERC4626 token\n   * @param shares shares\n   * @param receiver receiver\n   * @param owner owner\n   * @return assets native tokens to be received\n   * @return rdpxAmount rdpx tokens to be received\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public returns (uint256 assets, uint256 rdpxAmount) {\n    perpetualAtlanticVault.updateFunding();\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n    (assets, rdpxAmount) = redeemPreview(shares);\n\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    _rdpxCollateral -= rdpxAmount;\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    collateral.transfer(receiver, assets);\n\n    IERC20WithBurn(rdpx).safeTransfer(receiver, rdpxAmount);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n  }\n\n  // ================================ PERP VAULT FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function lockCollateral(uint256 amount) public onlyPerpVault {\n    _activeCollateral += amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function unlockLiquidity(uint256 amount) public onlyPerpVault {\n    _activeCollateral -= amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addProceeds(uint256 proceeds) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) >= _totalCollateral + proceeds,\n      \"Not enough collateral token was sent\"\n    );\n    _totalCollateral += proceeds;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function subtractLoss(uint256 loss) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) == _totalCollateral - loss,\n      \"Not enough collateral was sent out\"\n    );\n    _totalCollateral -= loss;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addRdpx(uint256 amount) public onlyPerpVault {\n    require(\n      IERC20WithBurn(rdpx).balanceOf(address(this)) >= _rdpxCollateral + amount,\n      \"Not enough rdpx token was sent\"\n    );\n    _rdpxCollateral += amount;\n  }\n\n  // ================================ INTERNAL FUNCTUONS ================================ //\n\n  function _convertToAssets(\n    uint256 shares\n  ) internal view virtual returns (uint256 assets, uint256 rdpxAmount) {\n    uint256 supply = totalSupply;\n    return\n      (supply == 0)\n        ? (shares, 0)\n        : (\n          shares.mulDivDown(totalCollateral(), supply),\n          shares.mulDivDown(_rdpxCollateral, supply)\n        );\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address,\n    uint256\n  ) internal virtual {}\n\n  // ================================ VIEWS ================================ //\n\n  /// @notice Returns the total active collateral\n  function activeCollateral() public view returns (uint256) {\n    return _activeCollateral;\n  }\n\n  /// @notice Returns the total collateral\n  function totalCollateral() public view returns (uint256) {\n    return _totalCollateral;\n  }\n\n  /// @notice Returns the total rdpx collateral\n  function rdpxCollateral() public view returns (uint256) {\n    return _rdpxCollateral;\n  }\n\n  /// @notice Returns the total available collateral\n  function totalAvailableCollateral() public view returns (uint256) {\n    return _totalCollateral - _activeCollateral;\n  }\n\n  // ================================ PUBLIC VIEW FUNCTIONS ================================ //\n\n  /// @notice Returns the amount of collateral and rdpx per share\n  function redeemPreview(\n    uint256 shares\n  ) public view returns (uint256, uint256) {\n    return _convertToAssets(shares);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function previewDeposit(uint256 assets) public view returns (uint256) {\n    return convertToShares(assets);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function convertToShares(\n    uint256 assets\n  ) public view returns (uint256 shares) {\n    uint256 supply = totalSupply;\n    uint256 rdpxPriceInAlphaToken = perpetualAtlanticVault.getUnderlyingPrice();\n\n    uint256 totalVaultCollateral = totalCollateral() +\n      ((_rdpxCollateral * rdpxPriceInAlphaToken) / 1e8);\n    return\n      supply == 0 ? assets : assets.mulDivDown(supply, totalVaultCollateral);\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 /*shares*/) internal {\n    require(\n      assets <= totalAvailableCollateral(),\n      \"Not enough available assets to satisfy withdrawal\"\n    );\n    _totalCollateral -= assets;\n  }\n\n  // ================================ MODIFIERS ================================ //\n  modifier onlyPerpVault() {\n    require(\n      msg.sender == address(perpetualAtlanticVault),\n      \"Only the perp vault can call this function\"\n    );\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVault.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\nimport { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IOptionPricing } from \"../interfaces/IOptionPricing.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IVolatilityOracle } from \"../interfaces/IVolatilityOracle.sol\";\n\n/// @title Contract to offer perpetual atlantic rDPX PUT options to the rdpxV2Core contract\n/// @dev Option tokens are in erc20 18 decimals & Strikes are in 1e8 precision\ncontract PerpetualAtlanticVault is\n  IPerpetualAtlanticVault,\n  ReentrancyGuard,\n  Pausable,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  AccessControl,\n  ContractWhitelist\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  /// @dev Token ID counter for write positions\n  Counters.Counter private _tokenIdCounter;\n\n  /// @dev Manager role which handles bootstrapping\n  bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n\n  /// @dev Rdpx v2 core role which can purchase and settle options\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  /// @dev Underlying assets symbol\n  string public underlyingSymbol;\n\n  /// @dev Contract addresses\n  Addresses public addresses;\n\n  /// @dev Collateral Token\n  IERC20WithBurn public collateralToken;\n\n  /// @dev The precision of the collateral token\n  uint256 public collateralPrecision;\n\n  /// @dev tokenId => OptionPosition\n  mapping(uint256 => OptionPosition) public optionPositions;\n\n  /// @dev number of options funding has been accounted for the epoch\n  mapping(uint256 => uint256) public fundingPaymentsAccountedFor;\n\n  /// @dev the funding accounted for the epoch and strike\n  mapping(uint256 => mapping(uint256 => uint256))\n    public fundingPaymentsAccountedForPerStrike;\n\n  /// @dev the total funding for the epoch\n  mapping(uint256 => uint256) public totalFundingForEpoch;\n\n  /// @dev amount of options per strike\n  mapping(uint256 => uint256) public optionsPerStrike;\n\n  /// @dev latest funding update per strike\n  mapping(uint256 => uint256) public latestFundingPerStrike;\n\n  // @dev Funding rate for the epoch\n  mapping(uint256 => uint256) public fundingRates;\n\n  /// @dev the pointer to the lattest funding payment timestamp\n  /// @notice Explain to an end user what this does\n  /// @dev Explain to a developer any extra details\n  /// @return Documents the return variables of a contractâ€™s function state variable\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  uint256 public latestFundingPaymentPointer = 0;\n\n  /// @dev the total number of active options\n  uint256 public totalActiveOptions;\n\n  /// @dev genesis timestamp\n  uint256 public genesis;\n\n  /// @dev the timestamp of the last update where funding was paid for\n  uint256 public lastUpdateTime;\n\n  /// @dev the duration between funding payments\n  uint256 public fundingDuration = 7 days;\n\n  /// @dev the precision to round up to\n  uint256 public roundingPrecision = 1e6;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /// @notice Contract constructor\n  /// @param _name ERC721 name\n  /// @param _symbol ERC721 symbol\n  /// @param _collateralToken Collateral token of the perpetual atlantic vault\n  /// @param _gensis Gensis time for funding calculation\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _collateralToken,\n    uint256 _gensis\n  ) ERC721(_name, _symbol) {\n    _validate(_collateralToken != address(0), 1);\n\n    collateralToken = IERC20WithBurn(_collateralToken);\n    underlyingSymbol = collateralToken.symbol();\n    collateralPrecision = 10 ** collateralToken.decimals();\n    genesis = _gensis;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(MANAGER"
    }
  ]
}