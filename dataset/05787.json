{
  "Title": "[L-02] Mapping key-value pair names are reversed",
  "Content": "\nKeys are named with value names and Values are named with key names. This can be difficult to read and maintain as keys and values are referenced using their names. \n\n*There are 4 instances of this issue:*\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootPort.sol#L86C1-L101C37\n\nBelow in the 4 instances of the mappings, we can see that the key-value pair names are reversed. For example, in mapping `getGlobalTokenFromLocal`, the first key is named `address chainId` while the second key is named `uint256 localAddress`. As we know, chainIds cannot be addressed and `localAddress` cannot be an uint256.\n\n```solidity\nFile: RootPort.sol\n091:     /// @notice ChainId -> Local Address -> Global Address\n092:     mapping(address chainId => mapping(uint256 localAddress => address globalAddress)) public getGlobalTokenFromLocal;\n093: \n094:     /// @notice ChainId -> Global Address -> Local Address\n095:     mapping(address chainId => mapping(uint256 globalAddress => address localAddress)) public getLocalTokenFromGlobal;\n096: \n097:     /// @notice ChainId -> Underlying Address -> Local Address\n098:     mapping(address chainId => mapping(uint256 underlyingAddress => address localAddress)) public\n099:         getLocalTokenFromUnderlying;\n100: \n101:     /// @notice Mapping from Local Address to Underlying Address.\n102:     mapping(address chainId => mapping(uint256 localAddress => address underlyingAddress)) public\n103:         getUnderlyingTokenFromLocal;\n104: \n```\n\nAdditionally, if we check this getter function in the same contract, we can further prove that the namings are reversed in the original mappings above. (Note: The contracts function as expected since only names are reversed).\n\n```solidity\nFile: RootPort.sol\n195:     function _getLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n196:         internal\n197:         view\n198:         returns (address)\n199:     {\n200:         address globalAddress = getGlobalTokenFromLocal[_localAddress][_srcChainId];\n201:         return getLocalTokenFromGlobal[globalAddress][_dstChainId];\n202:     }\n```\n\n**Solution:**\n\n```solidity\nFile: RootPort.sol\n091:     /// @notice Local Address -> ChainId -> Global Address\n092:     mapping(address localAddress => mapping(uint256 chainId => address globalAddress)) public getGlobalTokenFromLocal;\n093: \n094:     /// @notice Global Address -> ChainId -> Local Address\n095:     mapping(address globalAddress => mapping(uint256 chainId => address localAddress)) public getLocalTokenFromGlobal;\n096: \n097:     /// @notice Underlying Address -> ChainId -> Local Address\n098:     mapping(address underlyingAddress => mapping(uint256 chainId => address localAddress)) public\n099:         getLocalTokenFromUnderlying;\n100: \n101:     /// @notice Mapping from Local Address to Underlying Address.\n102:     mapping(address localAddress => mapping(uint256 chainId => address underlyingAddress)) public\n103:         getUnderlyingTokenFromLocal;\n104: \n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/RootPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {IERC20hTokenRootFactory} from \"./interfaces/IERC20hTokenRootFactory.sol\";\nimport {IRootBridgeAgent as IBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootPort, ICoreRootRouter, GasParams, VirtualAccount} from \"./interfaces/IRootPort.sol\";\n\nimport {ERC20hTokenRoot} from \"./token/ERC20hTokenRoot.sol\";\n\n/// @title Root Port - Omnichain Token Management Contract\n/// @author MaiaDAO\ncontract RootPort is Ownable, IRootPort {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                            SETUP STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice True if setup is still ongoing, false otherwise.\n    bool internal _setup;\n\n    /// @notice True if core setup is still ongoing, false otherwise.\n    bool internal _setupCore;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT PORT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint256 public immutable localChainId;\n\n    /// @notice The address of local branch port responsible for handling local transactions.\n    address public localBranchPortAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootRouterAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootBridgeAgentAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        VIRTUAL ACCOUNT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from user address to Virtual Account.\n    mapping(address user => VirtualAccount account) public getUserAccount;\n\n    /// @notice Holds the mapping from Virtual account to router address => bool.\n    /// @notice Stores whether a router is approved to spend a virtual account.\n    mapping(VirtualAccount acount => mapping(address router => bool allowed)) public isRouterApproved;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from address to Bridge Agent.\n    mapping(uint256 chainId => bool isActive) public isChainId;\n\n    /// @notice Mapping from address to isBridgeAgent (bool).\n    mapping(address bridgeAgent => bool isActive) public isBridgeAgent;\n\n    /// @notice Bridge Agents deployed in root chain.\n    address[] public bridgeAgents;\n\n    /// @notice Mapping address Bridge Agent => address Bridge Agent Manager\n    mapping(address bridgeAgent => address bridgeAgentManager) public getBridgeAgentManager;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address bridgeAgentFactory => bool isActive) public isBridgeAgentFactory;\n\n    /// @notice Bridge Agents deployed in root chain.\n    address[] public bridgeAgentFactories;\n\n    /*///////////////////////////////////////////////////////////////\n                            hTOKENS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping with all global hTokens deployed in the system.\n    mapping(address token => bool isGlobalToken) public isGlobalAddress;\n\n    /// @notice ChainId -> Local Address -> Global Address\n    mapping(address chainId => mapping(uint256 localAddress => address globalAddress)) public getGlobalTokenFromLocal;\n\n    /// @notice ChainId -> Global Address -> Local Address\n    mapping(address chainId => mapping(uint256 globalAddress => address localAddress)) public getLocalTokenFromGlobal;\n\n    /// @notice ChainId -> Underlying Address -> Local Address\n    mapping(address chainId => mapping(uint256 underlyingAddress => address localAddress)) public\n        getLocalTokenFromUnderlying;\n\n    /// @notice Mapping from Local Address to Underlying Address.\n    mapping(address chainId => mapping(uint256 localAddress => address underlyingAddress)) public\n        getUnderlyingTokenFromLocal;\n\n    /*///////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Root Port.\n     * @param _localChainId layer zero chain id of the local chain.\n     */\n    constructor(uint256 _localChainId) {\n        localChainId = _localChainId;\n        isChainId[_localChainId] = true;\n\n        _initializeOwner(msg.sender);\n        _setup = true;\n        _setupCore = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     *  @notice Function to initialize the Root Port.\n     *   @param _bridgeAgentFactory The address of the Bridge Agent Factory.\n     *   @param _coreRootRouter The address of the Core Root Router.\n     */\n    function initialize(address _bridgeAgentFactory, address _coreRootRouter) external onlyOwner {\n        require(_bridgeAgentFactory != address(0), \"Bridge Agent Factory cannot be 0 address.\");\n        require(_coreRootRouter != address(0), \"Core Root Router cannot be 0 address.\");\n        require(_setup, \"Setup ended.\");\n        _setup = false;\n\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n\n        coreRootRouterAddress = _coreRootRouter;\n    }\n\n    /**\n     *  @notice Function to initialize the Root Chain Core Contracts in Port Storage.\n     *   @param _coreRootBridgeAgent The address of the Core Root Bridge Agent.\n     *   @param _coreLocalBranchBridgeAgent The address of the Core Arbitrum Branch Bridge Agent.\n     *   @param _localBranchPortAddress The address of the Arbitrum Branch Port.\n     */\n    function initializeCore(\n        address _coreRootBridgeAgent,\n        address _coreLocalBranchBridgeAgent,\n        address _localBranchPortAddress\n    ) external onlyOwner {\n        require(_coreRootBridgeAgent != address(0), \"Core Root Bridge Agent cannot be 0 address.\");\n        require(_coreLocalBranchBridgeAgent != address(0), \"Core Local Branch Bridge Agent cannot be 0 address.\");\n        require(_localBranchPortAddress != address(0), \"Local Branch Port Address cannot be 0 address.\");\n        require(isBridgeAgent[_coreRootBridgeAgent], \"Core Bridge Agent doesn't exist.\");\n        require(_setupCore, \"Core Setup ended.\");\n        _setupCore = false;\n\n        coreRootBridgeAgentAddress = _coreRootBridgeAgent;\n        localBranchPortAddress = _localBranchPortAddress;\n        IBridgeAgent(_coreRootBridgeAgent).syncBranchBridgeAgent(_coreLocalBranchBridgeAgent, localChainId);\n        getBridgeAgentManager[_coreRootBridgeAgent] = owner();\n    }\n\n    /// @notice Function being overriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function getLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _getLocalToken(_localAddress, _srcChainId, _dstChainId);\n    }\n\n    /**\n     * @notice View Function returns Local Token's Local Address on another chain.\n     * @param _localAddress The address of the token in the local chain.\n     * @param _srcChainId The chainId of the chain where the token is deployed.\n     * @param _dstChainId The chainId of the chain for which the token address is requested.\n     */\n    function _getLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        internal\n        view\n        returns (address)\n    {\n        address globalAddress = getGlobalTokenFromLocal[_localAddress][_srcChainId];\n        return getLocalTokenFromGlobal[globalAddress][_dstChainId];\n    }\n\n    /// @inheritdoc IRootPort\n    function getUnderlyingTokenFromGlobal(address _globalAddress, uint256 _srcChainId)\n        external\n        view\n        override\n        returns (address)\n    {\n        address localAddress = getLocalTokenFromGlobal[_globalAddress][_srcChainId];\n        return getUnderlyingTokenFromLocal[localAddress][_srcChainId];\n    }\n\n    /// @inheritdoc IRootPort\n    function isGlobalToken(address _globalAddress, uint256 _srcChainId) external view override returns (bool) {\n        return getLocalTokenFromGlobal[_globalAddress][_srcChainId] != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isLocalToken(address _localAddress, uint256 _srcChainId) external view override returns (bool) {\n        return getGlobalTokenFromLocal[_localAddress][_srcChainId] != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        external\n        view\n        returns (bool)\n    {\n        return _getLocalToken(_localAddress, _srcChainId, _dstChainId) != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isUnderlyingToken(address _underlyingToken, uint256 _srcChainId) external view override returns (bool) {\n        return getLocalTokenFromUnderlying[_underlyingToken][_srcChainId] != address(0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        hTOKEN MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function setAddresses(\n        address _globalAddress,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _srcChainId\n    ) external override requiresCoreRootRouter {\n        if (_globalAddress == address(0)) revert InvalidGlobalAddress();\n        if (_localAddress == address(0)) revert InvalidLocalAddress();\n        if (_underlyingAddress == address(0)) revert InvalidUnderlyingAddress();\n\n        isGlobalAddress[_globalAddress] = true;\n        getGlobalTokenFromLocal[_localAddress][_srcChainId] = _globalAddress;\n        getLocalTokenFromGlobal[_globalAddress][_srcChainId] = _localAddress;\n        getLocalTokenFromUnderlying[_underlyingAddress][_srcChainId] = _localAddress;\n        getUnderlyingTokenFromLocal[_localAddress][_srcChainId] = _underlyingAddress;\n\n        emit LocalTokenAdded(_underlyingAddress, _localAddress, _globalAddress, _srcChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function setLocalAddress(address _globalAddress, address _localAddress, uint256 _srcChainId)\n        external\n        override\n        requiresCoreRootRouter\n    {\n        if (_localAddress == address(0)) revert InvalidLocalAddress();\n\n        getGlobalTokenFromLocal[_localAddress][_srcChainId] = _globalAddress;\n        getLocalTokenFromGlobal[_globalAddress][_srcChainId] = _localAddress;\n\n        emit GlobalTokenAdded(_localAddress, _globalAddress, _srcChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        hTOKEN ACCOUNTING FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function bridgeToRoot(address _recipient, address _hToken, uint256 _amount, uint256 _deposit, uint256 _srcChainId)\n        external\n        override\n        requiresBridgeAgent\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        if (_amount - _deposit > 0) {\n            unchecked {\n                _hToken.safeTransfer(_recipient, _amount - _deposit);\n            }\n        }\n\n        if (_deposit > 0) if (!ERC20hTokenRoot(_hToken).mint(_recipient, _deposit, _srcChainId)) revert UnableToMint();\n    }\n\n    /// @inheritdoc IRootPort\n    function bridgeToRootFromLocalBranch(address _from, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        _hToken.safeTransferFrom(_from, address(this), _amount);\n    }\n\n    function bridgeToLocalBranchFromRoot(address _to, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        _hToken.safeTransfer(_to, _amount);\n    }\n\n    /// @inheritdoc IRootPort\n    function burn(address _from, address _hToken, uint256 _amount, uint256 _srcChainId)\n        external\n        override\n        requiresBridgeAgent\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n        ERC20hTokenRoot(_hToken).burn(_from, _amount, _srcChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function burnFromLocalBranch(address _from, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        ERC20hTokenRoot(_hToken).burn(_from, _amount, localChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function mintToLocalBranch(address _to, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n        if (!ERC20hTokenRoot(_hToken).mint(_to, _amount, localChainId)) revert UnableToMint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    VIRTUAL ACCOUNT MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function fetchVirtualAccount(address _user) external override returns (VirtualAccount account) {\n        account = getUserAccount[_user];\n        if (address(account) == address(0)) account = addVirtualAccount(_user);\n    }\n\n    /**\n     * @notice Creates a new virtual account for a user.\n     * @param _user address of the user to associate a virtual account with.\n     */\n    function addVirtualAccount(address _user) internal returns (VirtualAccount newAccount) {\n        if (_user == address(0)) revert InvalidUserAddress();\n\n        newAccount = new VirtualAccount{salt: keccak256(abi.encode(_user))}(_user, address(this));\n        getUserAccount[_user] = newAccount;\n\n        emit VirtualAccountCreated(_user, address(newAccount));\n    }\n\n    /// @inheritdoc IRootPort\n    function toggleVirtualAccountApproved(VirtualAccount _userAccount, address _router)\n        external\n        override\n        requiresBridgeAgent\n    {\n        isRouterApproved[_userAccount][_router] = !isRouterApproved[_userAccount][_router];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT ADDITION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function addBridgeAgent(address _manager, address _bridgeAgent) external override requiresBridgeAgentFactory {\n        if (isBridgeAgent[_bridgeAgent]) revert AlreadyAddedBridgeAgent();\n\n        bridgeAgents.push(_bridgeAgent);\n        getBridgeAgentManager[_bridgeAgent] = _manager;\n        isBridgeAgent[_bridgeAgent] = true;\n\n        emit BridgeAgentAdded(_bridgeAgent, _manager);\n    }\n\n    /// @inheritdoc IRootPort\n    function syncBranchBridgeAgentWithRoot(\n        address _newBranchBridgeAgent,\n        address _rootBridgeAgent,\n        uint256 _branchChainId\n    ) external override requiresCoreRootRouter {\n        if (IBridgeAgent(_rootBridgeAgent).getBranchBridgeAgent(_branchChainId) != address(0)) {\n            revert AlreadyAddedBridgeAgent();\n        }\n        if (!IBridgeAgent(_rootBridgeAgent).isBranchBridgeAgentAllowed(_branchChainId)) {\n            revert BridgeAgentNotAllowed();\n        }\n        IBridgeAgent(_rootBridgeAgent).syncBranchBridgeAgent(_newBranchBridgeAgent, _branchChainId);\n\n        emit BridgeAgentSynced(_newBranchBridgeAgent, _rootBridgeAgent, _branchChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function toggleBridgeAgent(address _bridgeAgent) external override onlyOwner {\n        isBridgeAgent[_bridgeAgent] = !isBridgeAgent[_bridgeAgent];\n\n        emit BridgeAgentToggled(_bridgeAgent);\n    }\n\n    /// @inheritdoc IRootPort\n    function addBridgeAgentFactory(address _bridgeAgentFactory) external override onlyOwner {\n        if (isBridgeAgentFactory[_bridgeAgentFactory]) revert AlreadyAddedBridgeAgentFactory();\n\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n\n        emit BridgeAgentFactoryAdded(_bridgeAgentFactory);\n    }\n\n    /// @inheritdoc IRootPort\n    function toggleBridgeAgentFactory(address _bridgeAgentFactory) external override onlyOwner {\n        isBridgeAgentFactory[_bridgeAgentFactory] = !isBridgeAgentFactory[_bridgeAgentFactory];\n\n        emit BridgeAgentFactoryToggled(_bridgeAgentFactory);\n    }\n\n    /// @inheritdoc IRootPort\n    function addNewChain(\n        address _coreBranchBridgeAgentAddress,\n        uint256 _chainId,\n        string memory _wrappedGasTokenName,\n        string memory _wrappedGasTokenSymbol,\n        uint8 _wrappedGasTokenDecimals,\n        address _newLocalBranchWrappedNativeTokenAddress,\n        address _newUnderlyingBranchWrappedNativeTokenAddress\n    ) external override onlyOwner {\n        // Check if chain already added\n        if (isChainId[_chainId]) revert AlreadyAddedChain();\n\n        // Create new global token for new chain's wrapped native token\n        address newGlobalToken = address(\n            IERC20hTokenRootFactory(ICoreRootRouter(coreRootRouterAddress).hTokenFactoryAddress()).createToken(\n                _wrappedGasTokenName, _wrappedGasTokenSymbol, _wrappedGasTokenDecimals\n            )\n        );\n\n        // Sync new branch bridge agent with root core bridge agent\n        IBridgeAgent(ICoreRootRouter(coreRootRouterAddress).bridgeAgentAddress()).syncBranchBridgeAgent(\n            _coreBranchBridgeAgentAddress, _chainId\n        );\n\n        // Update State\n\n        // 1. Add new chain to chainId mapping\n        isChainId[_chainId] = true;\n        // 2. Add new chain to global address mapping\n        isGlobalAddress[newGlobalToken] = true;\n        // 3. Add new branch local token to global token address mapping\n        getGlobalTokenFromLocal[_newLocalBranchWrappedNativeTokenAddress][_chainId] = newGlobalToken;\n        // 4. Add new global token to branch local token address mapping\n        getLocalTokenFromGlobal[newGlobalToken][_chainId] = _newLocalBranchWrappedNativeTokenAddress;\n        // 5. Add new branch underlying token to branch local token address mapping\n        getLocalTokenFromUnderlying[_newUnderlyingBranchWrappedNativeTokenAddress][_chainId] =\n            _newLocalBranchWrappedNativeTokenAddress;\n        // 6. Add new branch local token to branch underlying token address mapping\n        getUnderlyingTokenFromLocal[_newLocalBranchWrappedNativeTokenAddress][_chainId] =\n            _newUnderlyingBranchWrappedNativeTokenAddress;\n\n        emit NewChainAdded(_chainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function addEcosystemToken(address _ecoTokenGlobalAddress) external override onlyOwner {\n        // Check if token already added\n        if (isGlobalAddress[_ecoTokenGlobalAddress]) revert AlreadyAddedEcosystemToken();\n\n        // Check if token is already a underlying token in current chain\n        if (getUnderlyingTokenFromLocal[_ecoTokenGlobalAddress][localChainId] != address(0)) {\n            revert AlreadyAddedEcosystemToken();\n        }\n\n        // Check if token is already a local branch token in current chain\n        if (getLocalTokenFromUnderlying[_ecoTokenGlobalAddress][localChainId] != address(0)) {\n            revert AlreadyAddedEcosystemToken();\n        }\n\n        // Update State\n        // 1. Add new global token to global address mapping\n        isGlobalAddress[_ecoTokenGlobalAddress] = true;\n        // 2. Add new branch local token address to global token mapping\n        getGlobalTokenFromLocal[_ecoTokenGlobalAddress][localChainId] = _ecoTokenGlobalAddress;\n        // 3. Add new global token to branch local token address mapping\n        getLocalTokenFromGlobal[_ecoTokenGlobalAddress][localChainId] = _ecoTokenGlobalAddress;\n\n        emit EcosystemTokenAdded(_ecoTokenGlobalAddress);\n    }\n\n    /// @inheritdoc IRootPort\n    function setCoreRootRouter(address _coreRootRouter, address _coreRootBridgeAgent) external override onlyOwner {\n        if (_coreRootRouter == address(0)) revert InvalidCoreRootRouter();\n        if (_coreRootBridgeAgent == address(0)) revert InvalidCoreRootBridgeAgent();\n\n        coreRootRouterAddress = _coreRootRouter;\n        coreRootBridgeAgentAddress = _coreRootBridgeAgent;\n        getBridgeAgentManager[_coreRootBridgeAgent] = owner();\n\n        emit CoreRootSet(_coreRootRouter, _coreRootBridgeAgent);\n    }\n\n    /// @inheritdoc IRootPort\n    function setCoreBranchRouter(\n        address _refundee,\n        address _coreBranchRouter,\n        address _coreBranchBridgeAgent,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable override onlyOwner {\n        if (_coreBranchRouter == address(0)) revert InvalidCoreBranchRouter();\n        if (_coreBranchBridgeAgent == address(0)) revert InvalidCoreBrancBridgeAgent();\n\n        ICoreRootRouter(coreRootRouterAddress).setCoreBranch{value: msg.value}(\n            _refundee, _coreBranchRouter, _coreBranchBridgeAgent, _dstChainId, _gParams\n        );\n\n        emit CoreBranchSet(_coreBranchRouter, _coreBranchBridgeAgent, _dstChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function syncNewCoreBranchRouter(address _coreBranchRouter, address _coreBranchBridgeAgent, uint16 _dstChainId)\n        external\n        override\n        onlyOwner\n    {\n        if (_coreBranchRouter == address(0)) revert InvalidCoreBranchRouter();\n        if (_coreBranchBridgeAgent == address(0)) revert InvalidCoreBrancBridgeAgent();\n\n        IBridgeAgent(coreRootBridgeAgentAddress).syncBranchBridgeAgent(_coreBranchBridgeAgent, _dstChainId);\n\n        emit CoreBranchSynced(_coreBranchRouter, _coreBranchBridgeAgent, _dstChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent Factory.\n    modifier requiresBridgeAgentFactory() {\n        if (!isBridgeAgentFactory[msg.sender]) revert UnrecognizedBridgeAgentFactory();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent.\n    modifier requiresBridgeAgent() {\n        if (!isBridgeAgent[msg.sender]) revert UnrecognizedBridgeAgent();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is the Root Chain's Core Router.\n    modifier requiresCoreRootRouter() {\n        if (msg.sender != coreRootRouterAddress) revert UnrecognizedCoreRootRouter();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is the Root Chain's Local Branch Port.\n    modifier requiresLocalBranchPort() {\n        if (msg.sender != localBranchPortAddress) revert UnrecognizedLocalBranchPort();\n        _;\n    }\n}"
    }
  ]
}