{
  "Title": "Gas overflow during iteration (DoS)",
  "Content": "##### Description\nEach iteration of the cycle requires a gas flow.\nA moment may come when more gas is required than it is allocated to record one block. In this case, all iterations of the loop will fail.\nAffected lines:\n- https://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/ERC20Farmable.sol#L70\n- https://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/ERC20Farmable.sol#L117\n- https://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/ERC20Farmable.sol#L121\n- https://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/ERC20Farmable.sol#L137\n##### Recommendation\nIt is recommended to add a check for the maximum possible number of elements of the arrays.\n\n***\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ERC20Farmable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/AddressSet.sol\";\n\nimport \"./interfaces/IERC20Farmable.sol\";\nimport \"./accounting/UserAccounting.sol\";\nimport \"./accounting/FarmAccounting.sol\";\n\nabstract contract ERC20Farmable is ERC20, IERC20Farmable {\n    using AddressArray for AddressArray.Data;\n    using AddressSet for AddressSet.Data;\n    using UserAccounting for UserAccounting.Info;\n\n    mapping(address => UserAccounting.Info) private _userInfo;\n    mapping(address => uint256) private _farmTotalSupply;\n    mapping(address => AddressSet.Data) private _userFarms;\n\n    /// @dev Use this method for signaling on bad farms even in static calls (for stats)\n    function onError(string memory /* error */) external view {\n        require(msg.sender == address(this), \"ERC20F: access denied\");\n    }\n\n    function farmTotalSupply(address farm_) public view virtual returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function farmBalanceOf(address farm_, address account) public view virtual returns (uint256) {\n        return _userFarms[account].contains(farm_) ? balanceOf(account) : 0;\n    }\n\n    function userIsFarming(address account, address farm_) public view virtual returns(bool) {\n        return _userFarms[account].contains(farm_);\n    }\n\n    function userFarmsCount(address account) public view virtual returns(uint256) {\n        return _userFarms[account].length();\n    }\n\n    function userFarmsAt(address account, uint256 index) public view virtual returns(address) {\n        return _userFarms[account].at(index);\n    }\n\n    function userFarms(address account) public view virtual returns(address[] memory) {\n        return _userFarms[account].items.get();\n    }\n\n    function farmedPerToken(address farm_) public view virtual returns(uint256 fpt) {\n        return _userInfo[farm_].farmedPerToken(farm_, _lazyGetSupply, _lazyGetFarmed);\n    }\n\n    function farmed(address farm_, address account) public view virtual returns(uint256) {\n        return _userInfo[farm_].farmed(account, farmBalanceOf(farm_, account), farmedPerToken(farm_));\n    }\n\n    function join(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].add(farm_), \"ERC20F: already farming\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), address(0), msg.sender, balance, false, true);\n        _farmTotalSupply[farm_] += balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function quitAll() public virtual {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        for (uint256 i = 0; i < farms.length; i++) {\n            quit(farms[i]);\n        }\n    }\n\n    function quit(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].remove(address(farm_)), \"ERC20F: already exited\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), msg.sender, address(0), balance, true, false);\n        _farmTotalSupply[farm_] -= balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function claimAll() public virtual returns(uint256[] memory amounts) {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        amounts = new uint256[](farms.length);\n        for (uint256 i = 0; i < farms.length; i++) {\n            amounts[i] = claim(farms[i]);\n        }\n    }\n\n    function claim(address farm_) public virtual returns(uint256) {\n        uint256 fpt = farmedPerToken(farm_);\n        uint256 balance = farmBalanceOf(farm_, msg.sender);\n        uint256 amount = _userInfo[farm_].farmed(msg.sender, balance, fpt);\n        if (amount > 0) {\n            _userInfo[farm_].eraseFarmed(msg.sender, balance, fpt);\n            IFarm(farm_).claimFor(msg.sender, amount);\n        }\n        return amount;\n    }\n\n    function updateCheckpoint() public virtual {\n        _userInfo[msg.sender].updateCheckpoint(farmedPerToken(msg.sender));\n    }\n\n    // ERC20 overrides\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override virtual {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (amount > 0 && from != to) {\n            address[] memory a = _userFarms[from].items.get();\n            address[] memory b = _userFarms[to].items.get();\n\n            for (uint256 i = 0; i < a.length; i++) {\n                address farm_ = a[i];\n\n                uint256 j;\n                for (j = 0; j < b.length; j++) {\n                    if (farm_ == b[j]) {\n                        // Both parties are farming the same token\n                        _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, true);\n                        b[j] = address(0);\n                        break;\n                    }\n                }\n\n                if (j == b.length) {\n                    // Sender is farming a token, but receiver is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, false);\n                    _farmTotalSupply[farm_] -= amount;\n                }\n            }\n\n            for (uint256 j = 0; j < b.length; j++) {\n                address farm_ = b[j];\n                if (farm_ != address(0)) {\n                    // Receiver is farming a token, but sender is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, false, true);\n                    _farmTotalSupply[farm_] += amount;\n                }\n            }\n        }\n    }\n\n    // UserAccounting bindings\n\n    function _lazyGetSupply(address farm_) internal view returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function _lazyGetFarmed(address farm_, uint256 checkpoint) internal view returns(uint256) {\n        try IFarm(farm_).farmedSinceCheckpointScaled{ gas: 200_000 }(checkpoint) returns(uint256 amount) {\n            if (amount <= FarmAccounting._MAX_REWARD_AMOUNT * 1e18) {\n                return amount;\n            }\n            else {\n                this.onError(\"farm.farmedSinceCheckpoint() result overflowed\");\n            }\n        }\n        catch {\n            this.onError(\"farm.farmedSinceCheckpoint() failed\");\n        }\n        return 0;\n    }\n}"
    },
    {
      "filename": "contracts/ERC20Farmable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/AddressSet.sol\";\n\nimport \"./interfaces/IERC20Farmable.sol\";\nimport \"./accounting/UserAccounting.sol\";\nimport \"./accounting/FarmAccounting.sol\";\n\nabstract contract ERC20Farmable is ERC20, IERC20Farmable {\n    using AddressArray for AddressArray.Data;\n    using AddressSet for AddressSet.Data;\n    using UserAccounting for UserAccounting.Info;\n\n    mapping(address => UserAccounting.Info) private _userInfo;\n    mapping(address => uint256) private _farmTotalSupply;\n    mapping(address => AddressSet.Data) private _userFarms;\n\n    /// @dev Use this method for signaling on bad farms even in static calls (for stats)\n    function onError(string memory /* error */) external view {\n        require(msg.sender == address(this), \"ERC20F: access denied\");\n    }\n\n    function farmTotalSupply(address farm_) public view virtual returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function farmBalanceOf(address farm_, address account) public view virtual returns (uint256) {\n        return _userFarms[account].contains(farm_) ? balanceOf(account) : 0;\n    }\n\n    function userIsFarming(address account, address farm_) public view virtual returns(bool) {\n        return _userFarms[account].contains(farm_);\n    }\n\n    function userFarmsCount(address account) public view virtual returns(uint256) {\n        return _userFarms[account].length();\n    }\n\n    function userFarmsAt(address account, uint256 index) public view virtual returns(address) {\n        return _userFarms[account].at(index);\n    }\n\n    function userFarms(address account) public view virtual returns(address[] memory) {\n        return _userFarms[account].items.get();\n    }\n\n    function farmedPerToken(address farm_) public view virtual returns(uint256 fpt) {\n        return _userInfo[farm_].farmedPerToken(farm_, _lazyGetSupply, _lazyGetFarmed);\n    }\n\n    function farmed(address farm_, address account) public view virtual returns(uint256) {\n        return _userInfo[farm_].farmed(account, farmBalanceOf(farm_, account), farmedPerToken(farm_));\n    }\n\n    function join(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].add(farm_), \"ERC20F: already farming\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), address(0), msg.sender, balance, false, true);\n        _farmTotalSupply[farm_] += balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function quitAll() public virtual {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        for (uint256 i = 0; i < farms.length; i++) {\n            quit(farms[i]);\n        }\n    }\n\n    function quit(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].remove(address(farm_)), \"ERC20F: already exited\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), msg.sender, address(0), balance, true, false);\n        _farmTotalSupply[farm_] -= balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function claimAll() public virtual returns(uint256[] memory amounts) {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        amounts = new uint256[](farms.length);\n        for (uint256 i = 0; i < farms.length; i++) {\n            amounts[i] = claim(farms[i]);\n        }\n    }\n\n    function claim(address farm_) public virtual returns(uint256) {\n        uint256 fpt = farmedPerToken(farm_);\n        uint256 balance = farmBalanceOf(farm_, msg.sender);\n        uint256 amount = _userInfo[farm_].farmed(msg.sender, balance, fpt);\n        if (amount > 0) {\n            _userInfo[farm_].eraseFarmed(msg.sender, balance, fpt);\n            IFarm(farm_).claimFor(msg.sender, amount);\n        }\n        return amount;\n    }\n\n    function updateCheckpoint() public virtual {\n        _userInfo[msg.sender].updateCheckpoint(farmedPerToken(msg.sender));\n    }\n\n    // ERC20 overrides\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override virtual {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (amount > 0 && from != to) {\n            address[] memory a = _userFarms[from].items.get();\n            address[] memory b = _userFarms[to].items.get();\n\n            for (uint256 i = 0; i < a.length; i++) {\n                address farm_ = a[i];\n\n                uint256 j;\n                for (j = 0; j < b.length; j++) {\n                    if (farm_ == b[j]) {\n                        // Both parties are farming the same token\n                        _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, true);\n                        b[j] = address(0);\n                        break;\n                    }\n                }\n\n                if (j == b.length) {\n                    // Sender is farming a token, but receiver is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, false);\n                    _farmTotalSupply[farm_] -= amount;\n                }\n            }\n\n            for (uint256 j = 0; j < b.length; j++) {\n                address farm_ = b[j];\n                if (farm_ != address(0)) {\n                    // Receiver is farming a token, but sender is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, false, true);\n                    _farmTotalSupply[farm_] += amount;\n                }\n            }\n        }\n    }\n\n    // UserAccounting bindings\n\n    function _lazyGetSupply(address farm_) internal view returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function _lazyGetFarmed(address farm_, uint256 checkpoint) internal view returns(uint256) {\n        try IFarm(farm_).farmedSinceCheckpointScaled{ gas: 200_000 }(checkpoint) returns(uint256 amount) {\n            if (amount <= FarmAccounting._MAX_REWARD_AMOUNT * 1e18) {\n                return amount;\n            }\n            else {\n                this.onError(\"farm.farmedSinceCheckpoint() result overflowed\");\n            }\n        }\n        catch {\n            this.onError(\"farm.farmedSinceCheckpoint() failed\");\n        }\n        return 0;\n    }\n}"
    },
    {
      "filename": "contracts/ERC20Farmable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/AddressSet.sol\";\n\nimport \"./interfaces/IERC20Farmable.sol\";\nimport \"./accounting/UserAccounting.sol\";\nimport \"./accounting/FarmAccounting.sol\";\n\nabstract contract ERC20Farmable is ERC20, IERC20Farmable {\n    using AddressArray for AddressArray.Data;\n    using AddressSet for AddressSet.Data;\n    using UserAccounting for UserAccounting.Info;\n\n    mapping(address => UserAccounting.Info) private _userInfo;\n    mapping(address => uint256) private _farmTotalSupply;\n    mapping(address => AddressSet.Data) private _userFarms;\n\n    /// @dev Use this method for signaling on bad farms even in static calls (for stats)\n    function onError(string memory /* error */) external view {\n        require(msg.sender == address(this), \"ERC20F: access denied\");\n    }\n\n    function farmTotalSupply(address farm_) public view virtual returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function farmBalanceOf(address farm_, address account) public view virtual returns (uint256) {\n        return _userFarms[account].contains(farm_) ? balanceOf(account) : 0;\n    }\n\n    function userIsFarming(address account, address farm_) public view virtual returns(bool) {\n        return _userFarms[account].contains(farm_);\n    }\n\n    function userFarmsCount(address account) public view virtual returns(uint256) {\n        return _userFarms[account].length();\n    }\n\n    function userFarmsAt(address account, uint256 index) public view virtual returns(address) {\n        return _userFarms[account].at(index);\n    }\n\n    function userFarms(address account) public view virtual returns(address[] memory) {\n        return _userFarms[account].items.get();\n    }\n\n    function farmedPerToken(address farm_) public view virtual returns(uint256 fpt) {\n        return _userInfo[farm_].farmedPerToken(farm_, _lazyGetSupply, _lazyGetFarmed);\n    }\n\n    function farmed(address farm_, address account) public view virtual returns(uint256) {\n        return _userInfo[farm_].farmed(account, farmBalanceOf(farm_, account), farmedPerToken(farm_));\n    }\n\n    function join(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].add(farm_), \"ERC20F: already farming\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), address(0), msg.sender, balance, false, true);\n        _farmTotalSupply[farm_] += balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function quitAll() public virtual {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        for (uint256 i = 0; i < farms.length; i++) {\n            quit(farms[i]);\n        }\n    }\n\n    function quit(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].remove(address(farm_)), \"ERC20F: already exited\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), msg.sender, address(0), balance, true, false);\n        _farmTotalSupply[farm_] -= balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function claimAll() public virtual returns(uint256[] memory amounts) {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        amounts = new uint256[](farms.length);\n        for (uint256 i = 0; i < farms.length; i++) {\n            amounts[i] = claim(farms[i]);\n        }\n    }\n\n    function claim(address farm_) public virtual returns(uint256) {\n        uint256 fpt = farmedPerToken(farm_);\n        uint256 balance = farmBalanceOf(farm_, msg.sender);\n        uint256 amount = _userInfo[farm_].farmed(msg.sender, balance, fpt);\n        if (amount > 0) {\n            _userInfo[farm_].eraseFarmed(msg.sender, balance, fpt);\n            IFarm(farm_).claimFor(msg.sender, amount);\n        }\n        return amount;\n    }\n\n    function updateCheckpoint() public virtual {\n        _userInfo[msg.sender].updateCheckpoint(farmedPerToken(msg.sender));\n    }\n\n    // ERC20 overrides\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override virtual {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (amount > 0 && from != to) {\n            address[] memory a = _userFarms[from].items.get();\n            address[] memory b = _userFarms[to].items.get();\n\n            for (uint256 i = 0; i < a.length; i++) {\n                address farm_ = a[i];\n\n                uint256 j;\n                for (j = 0; j < b.length; j++) {\n                    if (farm_ == b[j]) {\n                        // Both parties are farming the same token\n                        _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, true);\n                        b[j] = address(0);\n                        break;\n                    }\n                }\n\n                if (j == b.length) {\n                    // Sender is farming a token, but receiver is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, false);\n                    _farmTotalSupply[farm_] -= amount;\n                }\n            }\n\n            for (uint256 j = 0; j < b.length; j++) {\n                address farm_ = b[j];\n                if (farm_ != address(0)) {\n                    // Receiver is farming a token, but sender is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, false, true);\n                    _farmTotalSupply[farm_] += amount;\n                }\n            }\n        }\n    }\n\n    // UserAccounting bindings\n\n    function _lazyGetSupply(address farm_) internal view returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function _lazyGetFarmed(address farm_, uint256 checkpoint) internal view returns(uint256) {\n        try IFarm(farm_).farmedSinceCheckpointScaled{ gas: 200_000 }(checkpoint) returns(uint256 amount) {\n            if (amount <= FarmAccounting._MAX_REWARD_AMOUNT * 1e18) {\n                return amount;\n            }\n            else {\n                this.onError(\"farm.farmedSinceCheckpoint() result overflowed\");\n            }\n        }\n        catch {\n            this.onError(\"farm.farmedSinceCheckpoint() failed\");\n        }\n        return 0;\n    }\n}"
    },
    {
      "filename": "contracts/ERC20Farmable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/AddressSet.sol\";\n\nimport \"./interfaces/IERC20Farmable.sol\";\nimport \"./accounting/UserAccounting.sol\";\nimport \"./accounting/FarmAccounting.sol\";\n\nabstract contract ERC20Farmable is ERC20, IERC20Farmable {\n    using AddressArray for AddressArray.Data;\n    using AddressSet for AddressSet.Data;\n    using UserAccounting for UserAccounting.Info;\n\n    mapping(address => UserAccounting.Info) private _userInfo;\n    mapping(address => uint256) private _farmTotalSupply;\n    mapping(address => AddressSet.Data) private _userFarms;\n\n    /// @dev Use this method for signaling on bad farms even in static calls (for stats)\n    function onError(string memory /* error */) external view {\n        require(msg.sender == address(this), \"ERC20F: access denied\");\n    }\n\n    function farmTotalSupply(address farm_) public view virtual returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function farmBalanceOf(address farm_, address account) public view virtual returns (uint256) {\n        return _userFarms[account].contains(farm_) ? balanceOf(account) : 0;\n    }\n\n    function userIsFarming(address account, address farm_) public view virtual returns(bool) {\n        return _userFarms[account].contains(farm_);\n    }\n\n    function userFarmsCount(address account) public view virtual returns(uint256) {\n        return _userFarms[account].length();\n    }\n\n    function userFarmsAt(address account, uint256 index) public view virtual returns(address) {\n        return _userFarms[account].at(index);\n    }\n\n    function userFarms(address account) public view virtual returns(address[] memory) {\n        return _userFarms[account].items.get();\n    }\n\n    function farmedPerToken(address farm_) public view virtual returns(uint256 fpt) {\n        return _userInfo[farm_].farmedPerToken(farm_, _lazyGetSupply, _lazyGetFarmed);\n    }\n\n    function farmed(address farm_, address account) public view virtual returns(uint256) {\n        return _userInfo[farm_].farmed(account, farmBalanceOf(farm_, account), farmedPerToken(farm_));\n    }\n\n    function join(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].add(farm_), \"ERC20F: already farming\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), address(0), msg.sender, balance, false, true);\n        _farmTotalSupply[farm_] += balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function quitAll() public virtual {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        for (uint256 i = 0; i < farms.length; i++) {\n            quit(farms[i]);\n        }\n    }\n\n    function quit(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].remove(address(farm_)), \"ERC20F: already exited\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), msg.sender, address(0), balance, true, false);\n        _farmTotalSupply[farm_] -= balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function claimAll() public virtual returns(uint256[] memory amounts) {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        amounts = new uint256[](farms.length);\n        for (uint256 i = 0; i < farms.length; i++) {\n            amounts[i] = claim(farms[i]);\n        }\n    }\n\n    function claim(address farm_) public virtual returns(uint256) {\n        uint256 fpt = farmedPerToken(farm_);\n        uint256 balance = farmBalanceOf(farm_, msg.sender);\n        uint256 amount = _userInfo[farm_].farmed(msg.sender, balance, fpt);\n        if (amount > 0) {\n            _userInfo[farm_].eraseFarmed(msg.sender, balance, fpt);\n            IFarm(farm_).claimFor(msg.sender, amount);\n        }\n        return amount;\n    }\n\n    function updateCheckpoint() public virtual {\n        _userInfo[msg.sender].updateCheckpoint(farmedPerToken(msg.sender));\n    }\n\n    // ERC20 overrides\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override virtual {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (amount > 0 && from != to) {\n            address[] memory a = _userFarms[from].items.get();\n            address[] memory b = _userFarms[to].items.get();\n\n            for (uint256 i = 0; i < a.length; i++) {\n                address farm_ = a[i];\n\n                uint256 j;\n                for (j = 0; j < b.length; j++) {\n                    if (farm_ == b[j]) {\n                        // Both parties are farming the same token\n                        _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, true);\n                        b[j] = address(0);\n                        break;\n                    }\n                }\n\n                if (j == b.length) {\n                    // Sender is farming a token, but receiver is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, false);\n                    _farmTotalSupply[farm_] -= amount;\n                }\n            }\n\n            for (uint256 j = 0; j < b.length; j++) {\n                address farm_ = b[j];\n                if (farm_ != address(0)) {\n                    // Receiver is farming a token, but sender is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, false, true);\n                    _farmTotalSupply[farm_] += amount;\n                }\n            }\n        }\n    }\n\n    // UserAccounting bindings\n\n    function _lazyGetSupply(address farm_) internal view returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function _lazyGetFarmed(address farm_, uint256 checkpoint) internal view returns(uint256) {\n        try IFarm(farm_).farmedSinceCheckpointScaled{ gas: 200_000 }(checkpoint) returns(uint256 amount) {\n            if (amount <= FarmAccounting._MAX_REWARD_AMOUNT * 1e18) {\n                return amount;\n            }\n            else {\n                this.onError(\"farm.farmedSinceCheckpoint() result overflowed\");\n            }\n        }\n        catch {\n            this.onError(\"farm.farmedSinceCheckpoint() failed\");\n        }\n        return 0;\n    }\n}"
    }
  ]
}