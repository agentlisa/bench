{
  "Title": "[N-05] `override` function arguments that are unused should have the variable name removed or commented out to avoid compiler warnings",
  "Content": "\n*There is 1 instance of this issue:*\n\n```solidity\nFile: convex-platform/contracts/contracts/BaseRewardPool4626.sol   #1\n\n134:      function maxDeposit(address owner) public view virtual override returns (uint256) {\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/BaseRewardPool4626.sol#L134>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "convex-platform/contracts/contracts/BaseRewardPool4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport { BaseRewardPool, IDeposit } from \"./BaseRewardPool.sol\";\nimport { IERC4626 } from \"./interfaces/IERC4626.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.6/utils/ReentrancyGuard.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title   BaseRewardPool4626\n * @notice  Simply wraps the BaseRewardPool with the new IERC4626 Vault standard functions.\n * @dev     See https://github.com/fei-protocol/ERC4626/blob/main/src/interfaces/IERC4626.sol#L58\n *          This is not so much a vault as a Reward Pool, therefore asset:share ratio is always 1:1.\n *          To create most utility for this RewardPool, the \"asset\" has been made to be the crvLP token,\n *          as opposed to the cvxLP token. Therefore, users can easily deposit crvLP, and it will first\n *          go to the Booster and mint the cvxLP before performing the normal staking function.\n */\ncontract BaseRewardPool4626 is BaseRewardPool, ReentrancyGuard, IERC4626 {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice The address of the underlying ERC20 token used for\n     * the Vault for accounting, depositing, and withdrawing.\n     */\n    address public override asset;\n\n    /**\n     * @dev See BaseRewardPool.sol\n     */\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_,\n        address lptoken_\n    ) public BaseRewardPool(pid_, stakingToken_, rewardToken_, operator_, rewardManager_) {\n        asset = lptoken_;\n        IERC20(asset).safeApprove(operator_, type(uint256).max);\n    }\n\n    /**\n     * @notice Total amount of the underlying asset that is \"managed\" by Vault.\n     */\n    function totalAssets() external view virtual override returns(uint256){\n        return totalSupply();\n    }\n\n    /**\n     * @notice Mints `shares` Vault shares to `receiver`.\n     * @dev Because `asset` is not actually what is collected here, first wrap to required token in the booster.\n     */\n    function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {\n        // Transfer \"asset\" (crvLP) from sender\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        // Convert crvLP to cvxLP through normal booster deposit process, but don't stake\n        uint256 balBefore = stakingToken.balanceOf(address(this));\n        IDeposit(operator).deposit(pid, assets, false);\n        uint256 balAfter = stakingToken.balanceOf(address(this));\n\n        require(balAfter - balBefore >= assets, \"!deposit\");\n\n        // Perform stake manually, now that the funds have been received\n        _processStake(assets, receiver);\n\n        emit Deposit(msg.sender, receiver, assets, assets);\n        emit Staked(receiver, assets);\n        return assets;\n    }\n\n    /**\n     * @notice Mints exactly `shares` Vault shares to `receiver`\n     * by depositing `assets` of underlying tokens.\n     */\n    function mint(uint256 shares, address receiver) external virtual override returns (uint256) {\n        return deposit(shares, receiver);\n    }\n\n    /**\n     * @notice Redeems `shares` from `owner` and sends `assets`\n     * of underlying tokens to `receiver`.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override nonReentrant returns (uint256) {\n        require(owner == msg.sender, \"!owner\");\n        \n        _withdrawAndUnwrapTo(assets, receiver);\n\n        emit Withdraw(msg.sender, receiver, assets, assets);\n        return assets;\n    }\n\n    /**\n     * @notice Redeems `shares` from `owner` and sends `assets`\n     * of underlying tokens to `receiver`.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external virtual override returns (uint256) {\n        return withdraw(shares, receiver, owner);\n    }\n\n    /**\n     * @notice The amount of shares that the vault would\n     * exchange for the amount of assets provided, in an\n     * ideal scenario where all the conditions are met.\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice The amount of assets that the vault would\n     * exchange for the amount of shares provided, in an\n     * ideal scenario where all the conditions are met.\n     */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Total number of underlying assets that can\n     * be deposited by `owner` into the Vault, where `owner`\n     * corresponds to the input parameter `receiver` of a\n     * `deposit` call.\n     */\n    function maxDeposit(address owner) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     */    \n    function previewDeposit(uint256 assets) external view virtual override returns(uint256){\n        return convertToShares(assets);\n    }\n\n    /**\n     * @notice Total number of underlying shares that can be minted\n     * for `owner`, where `owner` corresponds to the input\n     * parameter `receiver` of a `mint` call.\n     */\n    function maxMint(address owner) external view virtual override returns (uint256) {\n        return maxDeposit(owner);\n    }\n\n    /**    \n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their mint at the current block, given\n     * current on-chain conditions.\n     */\n    function previewMint(uint256 shares) external view virtual override returns(uint256){\n        return convertToAssets(shares);\n    }\n\n    /**\n     * @notice Total number of underlying assets that can be\n     * withdrawn from the Vault by `owner`, where `owner`\n     * corresponds to the input parameter of a `withdraw` call.\n     */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /**    \n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns(uint256 shares){\n        return convertToShares(assets);\n    }\n\n    /**\n     * @notice Total number of underlying shares that can be\n     * redeemed from the Vault by `owner`, where `owner` corresponds\n     * to the input parameter of a `redeem` call.\n     */\n    function maxRedeem(address owner) external view virtual override returns (uint256) {\n        return maxWithdraw(owner);\n    }\n    /**    \n     * @notice Allows an on-chain or off-chain user to simulate\n     * the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     */\n    function previewRedeem(uint256 shares) external view virtual override returns(uint256){\n        return previewWithdraw(shares);\n    }\n}"
    }
  ]
}