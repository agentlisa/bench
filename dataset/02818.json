{
  "Title": "M-11: Users can loose their Illuminate tokens if amount to redeem is greater than holdings[u][m]",
  "Content": "# Issue M-11: Users can loose their Illuminate tokens if amount to redeem is greater than holdings[u][m] \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/81 \n\n## Found by \nneumo, Jeiwan\n\n## Summary\nWhen a user tries to redeem Illuminate tokens (using the Redeemer contract), the call will burn his/her illuminate tokens in exchange of zero underlying tokens if the amount to redeem exceeds the holdings value for that `[underlying, maturity]` pair.\n\n## Vulnerability Detail\nHoldings mapping for a `[underlying, maturity]` pair is only increased in  certain function calls.\n`redeem method for Swivel, Yield, Element, Pendle, APWine, Tempus and Notional protocols`\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L329\n`redeem method signature for Sense`\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L394\nBut it is decreased in a number of other places, for instance in this function:\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L403-L434\nWhich `burns Illuminate principal tokens and sends underlying to user`.\nAcording to the [documentation](https://docs.illuminate.finance/smart-contracts/deposit-lifecycle#mint), \n>As an alternative to directly lending through Illuminate, users can also purchase external principal tokens and then wrap them at a 1:1 ratio into Illuminate Principal Tokens.\nAs an example, let's say a user lends 100 USDC directly on Notional in the December 2022 market at a rate of 5% for one year. This leaves the user with 105 Notional PTs.\n\n>By then calling mint on Lender.sol, this user can then wrap their 105 Notional PTs into 105 Illuminate PTs (likely in order to perform arbitrage).\nLender: holds 105 Notional (External) PTs\nUser: holds 105 Illuminate PTs\n\nSo it could happen that a user minted Illuminate tokens, and after maturity try to redeem the underlying before any call has been made to the `redeem` functions above (the ones that increase the holdings). This means that `holdings[u][m]` would be zero and the call to `redeem(address u, uint256 m)` by the user would just burn their Illuminate principal in return for nothing.\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L422-L431\nNote that in line 422, the `redeemed` amount is zero because `holdings[u][m]` is zero. So in line 428, the Illuminate tokens are burnt and in line 431 zero (`redeemed`) underlying is transferred to the user.\nThis issue is present also in funtions `autoRedeem` and `authRedeem` because both calculate the amount of underlying to redeem as `uint256 redeemed = (amount * holdings[u][m]) / pt.totalSupply();`. For the sake of simplicity, I only present below a PoC of the case of the `redeem(address u, uint256 m)` function to prove the loss of funds.\n\n## Impact\nLoss of user funds in certin scenarios.\n## Code Snippet\nFor the case of the `redeem(address u, uint256 m)` function of the Redeemer contract, I wrote the following test that can be included in [Redeemer.t.sol](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/test/fork/Redeemer.t.sol).\n```solidity\nfunction testIssueIlluminateRedeem() public {\n\t// Deploy market\n\tdeployMarket(Contracts.USDC, 0);\n\n\taddress principalToken = mp.token(Contracts.USDC, maturity, uint256(MarketPlace.Principals.Yield));\n\taddress illuminateToken = mp.token(Contracts.USDC, maturity, uint256(MarketPlace.Principals.Illuminate));\n\n\t// Give msg.sender principal (Yield) tokens\n\tdeal(principalToken, msg.sender, startingBalance);\n\n\t// approve lender to transfer principal tokens\n\tvm.startPrank(address(msg.sender));\n\tIERC20(principalToken).approve(address(l), startingBalance);\n\n\t// In the starting state, the balance of Yield tokens for the user is equal to startingBalance\n\t// and the balance of Illuminate tokens is zero\n\t// Both the USDC balance of the user and the holdings mapping in the Redeemer for [u][m] is zero\n\tassertEq(IERC20(principalToken).balanceOf(msg.sender), startingBalance);\n\tassertEq(IERC20(illuminateToken).balanceOf(msg.sender), 0);\n\tassertEq(IERC20(Contracts.USDC).balanceOf(msg.sender), 0);\n\tassertEq(r.holdings(Contracts.USDC, maturity), 0);\n\n\t// User mints Illuminate tokens by wrapping his/her 1_000 Yield principal tokens\n\tl.mint(\n\t\tuint8(MarketPlace.Principals.Yield), // Yield\n\t\tContracts.USDC, \n\t\tmaturity, \n\t\t1_000\n\t);\n\tvm.stopPrank();\n\n\t// After minting, the balance of Yield tokens for the user is 1_000 less than the starting balance\n\t// and the balance of Illuminate tokens is 1_000\n\t// Both the USDC balance of the user and the holdings mapping in the Redeemer for [u][m] is zero\n\tassertEq(IERC20(principalToken).balanceOf(msg.sender), startingBalance - 1_000);\n\tassertEq(IERC20(illuminateToken).balanceOf(msg.sender), 1_000);\n\tassertEq(IERC20(Contracts.USDC).balanceOf(msg.sender), 0);\n\tassertEq(r.holdings(Contracts.USDC, maturity), 0);\n\n\tassertEq(r.holdings(Contracts.USDC, maturity), 0);\n\n\t// Try to redeem the underlying as msg.sender\n\tvm.prank(msg.sender);\n\tr.redeem(Contracts.USDC, maturity);\n\n\t// After redeeming, the balance of Yield tokens for the user is 1_000 less than the starting balance\n\t// and the balance of Illuminate tokens is zero, they have been burnt\n\t// The holdings mapping in the Redeemer for [u][m] is zero\n\t// But the USDC balance of the user is also zero, meaning the user has received nothing in return for \n\t// burning their Illuminate\n\tassertEq(IERC20(principalToken).balanceOf(msg.sender), startingBalance - 1_000);\n\tassertEq(IERC20(illuminateToken).balanceOf(msg.sender), 0);\n\tassertEq(IERC20(Contracts.USDC).balanceOf(msg.sender), 0);\n\tassertEq(r.holdings(Contracts.USDC, maturity), 0);\n}\n```\nYou can see how the user mints Illuminate from Yield tokens, then redeems through the Redeemer and ends up with the loss of the Yield tokens he/she used to mint Illuminate.\n\n## Tool used\n\nForge tests and manual Review\n\n## Recommendation\nUsing the `holdings` mapping to track the redeemable Illuminate tokens in the Redeemer contract can only be done if there is no way for an address to have a positive Illuminate tokens balance without the knowledge of the Redeemer contract. I think the team should rethink the way this contract works.\n\n\n\n## Discussion\n\n**sourabhmarathe**\n\nWe expect the user to confirm that the redemption process is fully complete prior to redeeming their Illuminate PTs. We believe this check is best done off-chain and as a result do not include it in Illuminate's `redeem` method.\n\n**neumoxx**\n\nEscalate for 100 USDC\nThe fact that a call to redeem can leave the user without his Illuminate tokens and without his principal, and relying on doing this offchain doesn't feel right. I point out in my report the case of `holdings[u][m]` being equal to zero and burning the full amount the user tries to redeem, but in fact it's more general of an issue.\nThis line (422 in Redeemer.sol)\n```solidity\nuint256 redeemed = (amount * holdings[u][m]) / token.totalSupply();\n```\nGets the amount to redeem. But this other line (428 in Redeemer.sol)\n```solidity\ntoken.authBurn(msg.sender, amount);\n```\nburns the amount passed in. So if a user has (to make it simple) `holdings[u][m] = 2` but has minted another token via `lender.mint` (see my report above), so `totalSupply = 3` and passes an amount of 3 to the function, the value of `redeemed` would be 2 but **the function would burn all three tokens**. Please, give it a second look because it's a big issue imo.\n\n**sherlock-admin**\n\n > Escalate for 100 USDC\n> The fact that a call to redeem can leave the user without his Illuminate tokens and without his principal, and relying on doing this offchain doesn't feel right. I point out in my report the case of `holdings[u][m]` being equal to zero and burning the full amount the user tries to redeem, but in fact it's more general of an issue.\n> This line (422 in Redeemer.sol)\n> ```solidity\n> uint256 redeemed = (amount * holdings[u][m]) / token.totalSupply();\n> ```\n> Gets the amount to redeem. But this other line (428 in Redeemer.sol)\n> ```solidity\n> token.authBurn(msg.sender, amount);\n> ```\n> burns the amount passed in. So if a user has (to make it simple) `holdings[u][m] = 2` but has minted another token via `lender.mint` (see my report above), so `totalSupply = 3` and passes an amount of 3 to the function, the value of `redeemed` would be 2 but **the function would burn all three tokens**. Please, give it a second look because it's a big issue imo.\n\nYou've created a valid escalation for 100 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted, enforcing a specific order of contract calls off-chain is not secure. Rewarding a medium severity.\n\n**sherlock-admin**\n\n> Escalation accepted, enforcing a specific order of contract calls off-chain is not secure. Rewarding a medium severity.\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "src/Redeemer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol';\n\nimport 'src/lib/Safe.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IAPWine.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/ISwivelToken.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleForge.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IConverter.sol';\n\nimport 'forge-std/Test.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    /// @notice address that is allowed to set fees and contracts, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n    /// @notice address that converts compounding tokens to their underlying\n    address public converter;\n\n    /// @notice third party contract needed to redeem Swivel PTs\n    address public immutable swivelAddr;\n    /// @notice third party contract needed to redeem Pendle PTs\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to redeem Tempus PTs\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on auto redemptions\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public MIN_FEENOMINATOR = 500;\n\n    /// @notice mapping that indicates how much underlying has been redeemed by a market\n    mapping(address => mapping(uint256 => uint256)) public holdings;\n    /// @notice mapping that determines if a market's iPT can be redeemed\n    mapping(address => mapping(uint256 => bool)) public paused;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount,\n        address sender\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon changing the converter\n    event SetConverter(address indexed converter);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    modifier unpaused(address u, uint256 m) {\n        if (paused[u][m]) {\n            revert Exception(17, m, 0, u, address(0));\n        }\n        _;\n    }\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 4000;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the converter address\n    /// @param c address of the new converter\n    /// @return bool true if successful\n    function setConverter(address c) external authorized(admin) returns (bool) {\n        converter = c;\n        emit SetConverter(c);\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exception(8, 0, 0, address(lender), address(0));\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (feeTime < block.timestamp) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice allows admin to stop redemptions of Illuminate PTs for a given market\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param b true to pause, false to unpause\n    function pauseRedemptions(\n        address u,\n        uint256 m,\n        bool b\n    ) external authorized(admin) {\n        paused[u][m] = b;\n    }\n\n    /// @notice approves the converter to spend the compounding asset\n    /// @param i an interest bearing token that must be approved for conversion\n    function approve(address i) external authorized(marketPlace) {\n        if (i != address(0)) {\n            Safe.approve(IERC20(i), address(converter), type(uint256).max);\n        }\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element, Pendle, APWine, Tempus and Notional protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) external returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Get the maturity for the given principal token\n        uint256 maturity;\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            maturity = ISwivelToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            maturity = IYieldToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            maturity = IElementToken(principal).unlockTimestamp();\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            maturity = IPendleToken(principal).expiry();\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            maturity = ITempusPool(ITempusToken(principal).pool())\n                .maturityTime();\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            // APWine's maturity is retrieved indirectly via the PT's\n            // futureVault and Controller\n            address futureVault = IAPWineToken(principal).futureVault();\n\n            address controller = IAPWineFutureVault(futureVault)\n                .getControllerAddress();\n\n            uint256 duration = IAPWineFutureVault(futureVault)\n                .PERIOD_DURATION();\n\n            maturity = IAPWineController(controller).getNextPeriodStart(\n                duration\n            );\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            maturity = INotional(principal).getMaturity();\n        } else {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Verify that the token has matured\n        if (maturity > block.timestamp) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Cache the lender to save gas on sload\n        address cachedLender = lender;\n\n        // Get the amount to be redeemed\n        uint256 amount = IERC20(principal).balanceOf(cachedLender);\n\n        // Receive the principal token from the lender contract\n        Safe.transferFrom(\n            IERC20(principal),\n            cachedLender,\n            address(this),\n            amount\n        );\n\n        // Get the starting balance of the underlying held by the redeemer\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems principal tokens from Swivel\n            if (!ISwivel(swivelAddr).redeemZcToken(u, maturity, amount)) {\n                revert Exception(15, 0, 0, address(0), address(0));\n            }\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems principal tokens from Yield\n            IYieldToken(principal).redeem(address(this), amount);\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            // Redeems principal tokens from Element\n            IElementToken(principal).withdrawPrincipal(amount, address(this));\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            // Get the forge contract for the principal token\n            address forge = IPendleToken(principal).forge();\n\n            // Get the forge ID of the principal token\n            bytes32 forgeId = IPendleForge(forge).forgeId();\n\n            // Redeem the tokens from the Pendle contract\n            IPendle(pendleAddr).redeemAfterExpiry(forgeId, u, maturity);\n\n            // Get the compounding asset for this market\n            address compounding = IPendleToken(principal)\n                .underlyingYieldToken();\n\n            // Redeem the compounding to token to the underlying\n            IConverter(converter).convert(\n                compounding,\n                u,\n                IERC20(compounding).balanceOf(address(this))\n            );\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            // Retrieve the pool for the principal token\n            address pool = ITempusToken(principal).pool();\n\n            // Redeems principal tokens from Tempus\n            ITempus(tempusAddr).redeemToBacking(pool, amount, 0, address(this));\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            apwineWithdraw(principal, u, amount);\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            // Redeems principal tokens from Notional\n            INotional(principal).redeem(\n                INotional(principal).maxRedeem(address(this)),\n                address(this),\n                address(this)\n            );\n        }\n\n        // Calculate how much underlying was redeemed\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n\n        // Update the holding for this market\n        holdings[u][m] = holdings[u][m] + redeemed;\n\n        emit Redeem(p, u, m, redeemed, msg.sender);\n        return true;\n    }\n\n    /// @notice redeem method signature for Sense\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param s Sense's maturity is needed to extract the pt address\n    /// @param a Sense's adapter for this market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 s,\n        address a\n    ) external returns (bool) {\n        // Check the principal is Sense\n        if (p != uint8(MarketPlace.Principals.Sense)) {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Get Sense's principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).token(u, m, p));\n\n        // Cache the lender to save on SLOAD operations\n        address cachedLender = lender;\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(cachedLender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, cachedLender, address(this), amount);\n\n        // Get the starting balance to verify the amount received afterwards\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        // Get the divider from the adapter\n        ISenseDivider divider = ISenseDivider(ISenseAdapter(a).divider());\n\n        // Redeem the tokens from the Sense contract\n        ISenseDivider(divider).redeem(a, s, amount);\n\n        // Get the compounding token that is redeemed by Sense\n        address compounding = ISenseAdapter(a).target();\n\n        // Redeem the compounding token back to the underlying\n        IConverter(converter).convert(\n            compounding,\n            u,\n            IERC20(compounding).balanceOf(address(this))\n        );\n\n        // Get the amount received\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n\n        // Verify that underlying are received 1:1 - cannot trust the adapter\n        if (redeemed < amount) {\n            revert Exception(13, 0, 0, address(0), address(0));\n        }\n\n        // Update the holdings for this market\n        holdings[u][m] = holdings[u][m] + redeemed;\n\n        emit Redeem(p, u, m, redeemed, msg.sender);\n        return true;\n    }\n\n    /// @notice burns Illuminate principal tokens and sends underlying to user\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    function redeem(address u, uint256 m) external unpaused(u, m) {\n        // Get Illuminate's principal token for this market\n        IERC5095 token = IERC5095(\n            IMarketPlace(marketPlace).token(\n                u,\n                m,\n                uint8(MarketPlace.Principals.Illuminate)\n            )\n        );\n\n        // Verify the token has matured\n        if (block.timestamp < token.maturity()) {\n            revert Exception(7, block.timestamp, m, address(0), address(0));\n        }\n\n        // Get the amount of tokens to be redeemed from the sender\n        uint256 amount = token.balanceOf(msg.sender);\n\n        // Calculate how many tokens the user should receive\n        uint256 redeemed = (amount * holdings[u][m]) / token.totalSupply();\n\n        // Update holdings of underlying\n        holdings[u][m] = holdings[u][m] - redeemed;\n\n        // Burn the user's principal tokens\n        token.authBurn(msg.sender, amount);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), msg.sender, redeemed);\n\n        emit Redeem(0, u, m, redeemed, msg.sender);\n    }\n\n    /// @notice implements the redeem method for the contract to fulfill the ERC-5095 interface\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param f address from where the underlying asset will be burned\n    /// @param t address to where the underlying asset will be transferred\n    /// @param a amount of the Illuminate PT to be burned and redeemed\n    /// @return uint256 amount of the underlying asset that was burned\n    function authRedeem(\n        address u,\n        uint256 m,\n        address f,\n        address t,\n        uint256 a\n    )\n        external\n        authorized(IMarketPlace(marketPlace).token(u, m, 0))\n        returns (uint256)\n    {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n\n        // Make sure the market has matured\n        uint256 maturity = pt.maturity();\n        if (block.timestamp < maturity) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Calculate the amount redeemed\n        uint256 redeemed = (a * holdings[u][m]) / pt.totalSupply();\n\n        // Update holdings of underlying\n        holdings[u][m] = holdings[u][m] - redeemed;\n\n        // Burn the user's principal tokens\n        pt.authBurn(f, a);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), t, redeemed);\n\n        emit Redeem(0, u, m, redeemed, msg.sender);\n        return a;\n    }\n\n    /// @notice implements a redeem method to enable third-party redemptions\n    /// @dev expects approvals from owners to redeemer\n    /// @param u address of the underlying asset\n    /// @param m maturity of the market\n    /// @param f address from where the principal token will be burned\n    /// @return uint256 amount of underlying yielded as a fee\n    function autoRedeem(\n        address u,\n        uint256 m,\n        address[] calldata f\n    ) external returns (uint256) {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n\n        // Make sure the market has matured\n        uint256 maturity = pt.maturity();\n        if (block.timestamp < maturity) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Retrieve the underlying\n        IERC20 uToken = IERC20(u);\n\n        // Sum up the fees received by the caller\n        uint256 incentiveFee;\n\n        // Get the number of owners to loop through\n        uint256 length = f.length;\n\n        // Loop through the provided arrays and mature each individual position\n        for (uint256 i; i != length; ) {\n            // Fetch the allowance set by the holder of the principal tokens\n            uint256 allowance = uToken.allowance(f[i], address(this));\n\n            // Get the amount of tokens held by the owner\n            uint256 amount = pt.balanceOf(f[i]);\n\n            // Calculate how many tokens the user should receive\n            uint256 redeemed = (amount * holdings[u][m]) / pt.totalSupply();\n\n            // Calculate the fees to be received (currently .025%)\n            uint256 fee = redeemed / feenominator;\n\n            // Verify allowance\n            if (allowance < amount) {\n                revert Exception(20, allowance, amount, address(0), address(0));\n            }\n\n            // Burn the tokens from the user\n            pt.authBurn(f[i], amount);\n\n            // Update the holdings for this market\n            holdings[u][m] = holdings[u][m] - redeemed;\n\n            // Transfer the underlying to the user\n            Safe.transfer(uToken, f[i], redeemed - fee);\n\n            unchecked {\n                // Track the fees gained by the caller\n                incentiveFee += fee;\n\n                ++i;\n            }\n        }\n\n        // Transfer the fee to the caller\n        Safe.transfer(uToken, msg.sender, incentiveFee);\n\n        return incentiveFee;\n    }\n\n    /// @notice Execute the business logic for conducting an APWine redemption\n    function apwineWithdraw(\n        address p,\n        address u,\n        uint256 a\n    ) internal {\n        // Retrieve the vault which executes the redemption in APWine\n        address futureVault = IAPWineToken(p).futureVault();\n\n        // Retrieve the controller that will execute the withdrawal\n        address controller = IAPWineFutureVault(futureVault)\n            .getControllerAddress();\n\n        // Retrieve the next period index\n        uint256 index = IAPWineFutureVault(futureVault).getCurrentPeriodIndex();\n\n        // Get the FYT address for the current period\n        address fyt = IAPWineFutureVault(futureVault).getFYTofPeriod(index);\n\n        // Trigger claim to FYTs by executing transfer\n        // Safe.transferFrom(IERC20(fyt), address(lender), address(this), a);\n        ILender(lender).transferFYTs(fyt, a);\n\n        // Redeem the underlying token from APWine to Illuminate\n        IAPWineController(controller).withdraw(futureVault, a);\n\n        // Retrieve the interest bearing token\n        address ibt = IAPWineFutureVault(futureVault).getIBTAddress();\n\n        // Convert the interest bearing token to underlying\n        IConverter(converter).convert(\n            IAPWineFutureVault(futureVault).getIBTAddress(),\n            u,\n            IERC20(ibt).balanceOf(address(this))\n        );\n    }\n}"
    },
    {
      "filename": "src/Redeemer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol';\n\nimport 'src/lib/Safe.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IAPWine.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/ISwivelToken.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleForge.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IConverter.sol';\n\nimport 'forge-std/Test.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    /// @notice address that is allowed to set fees and contracts, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n    /// @notice address that converts compounding tokens to their underlying\n    address public converter;\n\n    /// @notice third party contract needed to redeem Swivel PTs\n    address public immutable swivelAddr;\n    /// @notice third party contract needed to redeem Pendle PTs\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to redeem Tempus PTs\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on auto redemptions\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public MIN_FEENOMINATOR = 500;\n\n    /// @notice mapping that indicates how much underlying has been redeemed by a market\n    mapping(address => mapping(uint256 => uint256)) public holdings;\n    /// @notice mapping that determines if a market's iPT can be redeemed\n    mapping(address => mapping(uint256 => bool)) public paused;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount,\n        address sender\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon changing the converter\n    event SetConverter(address indexed converter);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    modifier unpaused(address u, uint256 m) {\n        if (paused[u][m]) {\n            revert Exception(17, m, 0, u, address(0));\n        }\n        _;\n    }\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 4000;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the converter address\n    /// @param c address of the new converter\n    /// @return bool true if successful\n    function setConverter(address c) external authorized(admin) returns (bool) {\n        converter = c;\n        emit SetConverter(c);\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exception(8, 0, 0, address(lender), address(0));\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (feeTime < block.timestamp) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice allows admin to stop redemptions of Illuminate PTs for a given market\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param b true to pause, false to unpause\n    function pauseRedemptions(\n        address u,\n        uint256 m,\n        bool b\n    ) external authorized(admin) {\n        paused[u][m] = b;\n    }\n\n    /// @notice approves the converter to spend the compounding asset\n    /// @param i an interest bearing token that must be approved for conversion\n    function approve(address i) external authorized(marketPlace) {\n        if (i != address(0)) {\n            Safe.approve(IERC20(i), address(converter), type(uint256).max);\n        }\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element, Pendle, APWine, Tempus and Notional protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) external returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Get the maturity for the given principal token\n        uint256 maturity;\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            maturity = ISwivelToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            maturity = IYieldToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            maturity = IElementToken(principal).unlockTimestamp();\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            maturity = IPendleToken(principal).expiry();\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            maturity = ITempusPool(ITempusToken(principal).pool())\n                .maturityTime();\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            // APWine's maturity is retrieved indirectly via the PT's\n            // futureVault and Controller\n            address futureVault = IAPWineToken(principal).futureVault();\n\n            address controller = IAPWineFutureVault(futureVault)\n                .getControllerAddress();\n\n            uint256 duration = IAPWineFutureVault(futureVault)\n                .PERIOD_DURATION();\n\n            maturity = IAPWineController(controller).getNextPeriodStart(\n                duration\n            );\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            maturity = INotional(principal).getMaturity();\n        } else {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Verify that the token has matured\n        if (maturity > block.timestamp) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Cache the lender to save gas on sload\n        address cachedLender = lender;\n\n        // Get the amount to be redeemed\n        uint256 amount = IERC20(principal).balanceOf(cachedLender);\n\n        // Receive the principal token from the lender contract\n        Safe.transferFrom(\n            IERC20(principal),\n            cachedLender,\n            address(this),\n            amount\n        );\n\n        // Get the starting balance of the underlying held by the redeemer\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems principal tokens from Swivel\n            if (!ISwivel(swivelAddr).redeemZcToken(u, maturity, amount)) {\n                revert Exception(15, 0, 0, address(0), address(0));\n            }\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems principal tokens from Yield\n            IYieldToken(principal).redeem(address(this), amount);\n        } e"
    }
  ]
}