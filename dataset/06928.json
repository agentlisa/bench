{
  "Title": "[2]",
  "Content": "Function SystemContext.setGasPrice() comments are wrong.\n```solidity\n    /// @notice Set the current tx origin.\n    /// @param _gasPrice The new tx gasPrice.\n    function setGasPrice(uint256 _gasPrice) external onlyBootloader {\n        gasPrice = _gasPrice;\n    }\n```\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/SystemContext.sol#L64-L68\n\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-zksync",
  "Code": [
    {
      "filename": "contracts/SystemContext.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ISystemContext} from \"./interfaces/ISystemContext.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @notice Contract that stores some of the context variables, that may be either\n * block-scoped, tx-scoped or system-wide.\n */\ncontract SystemContext is ISystemContext {\n    modifier onlyBootloader() {\n        require(msg.sender == BOOTLOADER_FORMAL_ADDRESS);\n        _;\n    }\n\n    /// @notice The chainId of the network. It is set at the genesis.\n    uint256 public chainId;\n\n    /// @notice The `tx.origin` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    address public origin;\n\n    /// @notice The `tx.gasPrice` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    uint256 public gasPrice;\n\n    /// @notice The current block's gasLimit (gasLimit in Ethereum terms).\n    /// @dev Currently set to some dummy value, it will be changed closer to mainnet.\n    uint256 public blockGasLimit = (1 << 30);\n\n    /// @notice The `block.coinbase` in the current transaction.\n    /// @dev For the support of coinbase, we will the bootloader formal address for now\n    address public coinbase = BOOTLOADER_FORMAL_ADDRESS;\n\n    /// @notice Formal `block.difficulty` parameter.\n    uint256 public difficulty = 2500000000000000;\n\n    /// @notice The `block.basefee`.\n    /// @dev It is currently a constant.\n    uint256 public baseFee;\n\n    /// @notice The coefficient with which the current block's number\n    /// is stored in the current block info\n    uint256 constant BLOCK_INFO_BLOCK_NUMBER_PART = 2 ** 128;\n\n    /// @notice block.number and block.timestamp stored packed.\n    /// @dev It is equal to 2^128 * block_number + block_timestamp.\n    uint256 public currentBlockInfo;\n\n    /// @notice The hashes of blocks.\n    /// @dev It stores block hashes for all previous blocks.\n    mapping(uint256 => bytes32) public blockHash;\n\n    /// @notice Set the current tx origin.\n    /// @param _newOrigin The new tx origin.\n    function setTxOrigin(address _newOrigin) external onlyBootloader {\n        origin = _newOrigin;\n    }\n\n    /// @notice Set the current tx origin.\n    /// @param _gasPrice The new tx gasPrice.\n    function setGasPrice(uint256 _gasPrice) external onlyBootloader {\n        gasPrice = _gasPrice;\n    }\n\n    /// @notice The method that emulates `blockhash` opcode in EVM.\n    /// @dev Just like the blockhash in the EVM, it returns bytes32(0), when\n    /// when queried about hashes that are older than 256 blocks ago.\n    function getBlockHashEVM(uint256 _block) external view returns (bytes32 hash) {\n        if (block.number < _block || block.number - _block > 256) {\n            hash = bytes32(0);\n        } else {\n            hash = blockHash[_block];\n        }\n    }\n\n    /// @notice Returns the current blocks' number and timestamp.\n    /// @return blockNumber and blockTimestamp tuple of the current block's number and the current block's timestamp\n    function getBlockNumberAndTimestamp() public view returns (uint256 blockNumber, uint256 blockTimestamp) {\n        uint256 blockInfo = currentBlockInfo;\n        blockNumber = blockInfo / BLOCK_INFO_BLOCK_NUMBER_PART;\n        blockTimestamp = blockInfo % BLOCK_INFO_BLOCK_NUMBER_PART;\n    }\n\n    /// @notice Returns the current block's number.\n    /// @return blockNumber The current block's number.\n    function getBlockNumber() public view returns (uint256 blockNumber) {\n        (blockNumber, ) = getBlockNumberAndTimestamp();\n    }\n\n    /// @notice Returns the current block's timestamp.\n    /// @return timestamp The current block's timestamp.\n    function getBlockTimestamp() public view returns (uint256 timestamp) {\n        (, timestamp) = getBlockNumberAndTimestamp();\n    }\n\n    /// @notice Increments the current block number and sets the new timestamp\n    /// @dev Called by the bootloader at the start of the block.\n    /// @param _prevBlockHash The hash of the previous block.\n    /// @param _newTimestamp The timestamp of the new block.\n    /// @param _expectedNewNumber The new block's number\n    /// @dev Whie _expectedNewNumber can be derived as prevBlockNumber + 1, we still\n    /// manually supply it here for consistency checks.\n    /// @dev The correctness of the _prevBlockHash and _newTimestamp should be enforced on L1.\n    function setNewBlock(\n        bytes32 _prevBlockHash,\n        uint256 _newTimestamp,\n        uint256 _expectedNewNumber,\n        uint256 _baseFee\n    ) external onlyBootloader {\n        (uint256 currentBlockNumber, uint256 currentBlockTimestamp) = getBlockNumberAndTimestamp();\n        require(_newTimestamp >= currentBlockTimestamp, \"Timestamps should be incremental\");\n        require(currentBlockNumber + 1 == _expectedNewNumber, \"The provided block number is not correct\");\n\n        blockHash[currentBlockNumber] = _prevBlockHash;\n\n        // Setting new block number and timestamp\n        currentBlockInfo = (currentBlockNumber + 1) * BLOCK_INFO_BLOCK_NUMBER_PART + _newTimestamp;\n\n        baseFee = _baseFee;\n\n        // The correctness of this block hash and the timestamp will be checked on L1:\n        SystemContractHelper.toL1(false, bytes32(_newTimestamp), _prevBlockHash);\n    }\n\n    /// @notice A testing method that manually sets the current blocks' number and timestamp.\n    /// @dev Should be used only for testing / ethCalls and should never be used in production.\n    function unsafeOverrideBlock(uint256 _newTimestamp, uint256 number, uint256 _baseFee) external onlyBootloader {\n        currentBlockInfo = (number) * BLOCK_INFO_BLOCK_NUMBER_PART + _newTimestamp;\n        baseFee = _baseFee;\n    }\n}"
    }
  ]
}