{
  "Title": "H-2: Anyone who approved quote tokens to a pool can be forced to take",
  "Content": "# Issue H-2: Anyone who approved quote tokens to a pool can be forced to take \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/145 \n\n## Found by \nJeiwan\n\n## Summary\nTaking may be executed on behalf of any address who approved spending of quote tokens to a pool: such address will pay quote tokens and will receive collateral.\n## Vulnerability Detail\n[ERC20Pool](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L403) and [ERC721Pool](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L405) implement the `take` functions, which buy collateral from auction in exchange for quote tokens. The address to pull quote tokens from is specified in the `callee_` argument, which allows anyone to call the functions and pass an address that has previously approved spending of the quote token to the pool. As a result, such an address will pay for the liquidation and will receive the collateral.\n## Impact\nAnyone can initiate a take on behalf of another user. Such user can be a lender who has previously approved spending of the quote token to the pool. Calling `take` with the user's address specified as the `callee_` argument will result in:\n1. the user [receiving collateral](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L450), which may have low value;\n1. the user [paying the quote token](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L460) to repay the debt being taken.\n## Code Snippet\n[ERC20Pool.sol#L460](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L460)\n[ERC721Pool.sol#L463](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L463)\n## Tool used\nManual Review\n## Recommendation\nIn the `ERC20Pool.take` and `ERC721Pool.take` functions, consider transferring collateral only from `msg.sender`. Alternatively, consider checking that `callee_` has approved spending quote tokens to `msg.sender`.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/ERC20Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }    from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { \n    IERC20Pool,\n    IERC20PoolBorrowerActions,\n    IERC20PoolImmutables,\n    IERC20PoolLenderActions\n}                              from './interfaces/pool/erc20/IERC20Pool.sol';\nimport { IERC20Taker }         from './interfaces/pool/erc20/IERC20Taker.sol';\n\nimport {\n    IPoolLenderActions,\n    IPoolLiquidationActions,\n    IERC20Token\n}                            from './interfaces/pool/IPool.sol';\nimport {\n    IERC3156FlashBorrower,\n    IERC3156FlashLender\n}                            from './interfaces/pool/IERC3156FlashLender.sol';\n\nimport {\n    DrawDebtResult,\n    BucketTakeResult,\n    RepayDebtResult,\n    SettleParams,\n    TakeResult\n}                    from './interfaces/pool/commons/IPoolInternals.sol';\nimport { PoolState } from './interfaces/pool/commons/IPoolState.sol';\n\nimport { FlashloanablePool } from './base/FlashloanablePool.sol';\n\nimport {\n    _getCollateralDustPricePrecisionAdjustment,\n    _roundToScale,\n    _roundUpToScale\n}                                               from './libraries/helpers/PoolHelper.sol';\nimport { _revertIfAuctionClearable }            from './libraries/helpers/RevertsHelper.sol';\n\nimport { Loans }    from './libraries/internal/Loans.sol';\nimport { Deposits } from './libraries/internal/Deposits.sol';\nimport { Maths }    from './libraries/internal/Maths.sol';\n\nimport { BorrowerActions } from './libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from './libraries/external/LenderActions.sol';\nimport { Auctions }        from './libraries/external/Auctions.sol';\n\n/**\n *  @title  ERC20 Pool contract\n *  @notice Entrypoint of ERC20 Pool actions for pool actors:\n *          - Lenders: add, remove and move quote tokens; transfer LPs\n *          - Borrowers: draw and repay debt\n *          - Traders: add, remove and move quote tokens; add and remove collateral\n *          - Kickers: kick undercollateralized loans; settle auctions; claim bond rewards\n *          - Bidders: take auctioned collateral\n *          - Reserve purchasers: start auctions; take reserves\n *          - Flash borrowers: initiate flash loans on quote tokens and collateral\n *  @dev    Contract is FlashloanablePool with flash loan logic.\n *  @dev    Contract is base Pool with logic to handle ERC20 collateral.\n *  @dev    Calls logic from external PoolCommons, LenderActions, BorrowerActions and Auctions libraries.\n */\ncontract ERC20Pool is FlashloanablePool, IERC20Pool {\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant COLLATERAL_SCALE = 93;\n\n    /****************************/\n    /*** Initialize Functions ***/\n    /****************************/\n\n    /// @inheritdoc IERC20Pool\n    function initialize(\n        uint256 rate_\n    ) external override {\n        if (isPoolInitialized) revert AlreadyInitialized();\n\n        inflatorState.inflator       = uint208(1e18);\n        inflatorState.inflatorUpdate = uint48(block.timestamp);\n\n        interestState.interestRate       = uint208(rate_);\n        interestState.interestRateUpdate = uint48(block.timestamp);\n\n        Loans.init(loans);\n\n        // increment initializations count to ensure these values can't be updated\n        isPoolInitialized = true;\n    }\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IERC20PoolImmutables\n    function collateralScale() external pure override returns (uint256) {\n        return _getArgUint256(COLLATERAL_SCALE);\n    }\n\n    /// @inheritdoc IERC20Pool\n    function bucketCollateralDust(uint256 bucketIndex) external pure override returns (uint256) {\n        return _bucketCollateralDust(bucketIndex);\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - increment poolBalances.pledgedCollateral accumulator\n     *          - increment poolBalances.t0Debt accumulator\n     *  @dev emit events:\n     *          - DrawDebt\n     */\n    function drawDebt(\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256 collateralToPledge_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure the borrower is not credited with a fractional amount of collateral smaller than the token scale\n        collateralToPledge_ = _roundToScale(collateralToPledge_, _bucketCollateralDust(0));\n\n        DrawDebtResult memory result = BorrowerActions.drawDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            amountToBorrow_,\n            limitIndex_,\n            collateralToPledge_\n        );\n\n        emit DrawDebt(borrowerAddress_, amountToBorrow_, collateralToPledge_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (collateralToPledge_ != 0) {\n            // update pool balances state\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n            poolBalances.pledgedCollateral += collateralToPledge_;\n\n            // move collateral from sender to pool\n            _transferCollateralFrom(msg.sender, collateralToPledge_);\n        }\n\n        if (amountToBorrow_ != 0) {\n            // update pool balances state\n            poolBalances.t0Debt += result.t0DebtChange;\n\n            // move borrowed amount from pool to sender\n            _transferQuoteToken(msg.sender, amountToBorrow_);\n        }\n    }\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     *  @dev emit events:\n     *          - RepayDebt\n     */\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure accounting is performed using the appropriate token scale\n        maxQuoteTokenAmountToRepay_ = _roundToScale(maxQuoteTokenAmountToRepay_, _getArgUint256(QUOTE_SCALE));\n        collateralAmountToPull_     = _roundToScale(collateralAmountToPull_,     _bucketCollateralDust(0));\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxQuoteTokenAmountToRepay_,\n            collateralAmountToPull_\n        );\n\n        emit RepayDebt(borrowerAddress_, result.quoteTokenToRepay, collateralAmountToPull_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.quoteTokenToRepay != 0) {\n            // update pool balances state\n            poolBalances.t0Debt -= result.t0RepaidDebt;\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n\n            // move amount to repay from sender to pool\n            _transferQuoteTokenFrom(msg.sender, result.quoteTokenToRepay);\n        }\n        if (collateralAmountToPull_ != 0) {\n            // update pool balances state\n            poolBalances.pledgedCollateral = result.poolCollateral;\n\n            // move collateral from pool to sender\n            _transferCollateral(msg.sender, collateralAmountToPull_);\n        }\n    }\n\n    /************************************/\n    /*** Flashloan External Functions ***/\n    /************************************/\n\n    /// @inheritdoc FlashloanablePool\n    function flashLoan(\n        IERC3156FlashBorrower receiver_,\n        address token_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external override(IERC3156FlashLender, FlashloanablePool) nonReentrant returns (bool) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS)) return _flashLoanQuoteToken(receiver_, token_, amount_, data_);\n\n        if (token_ == _getArgAddress(COLLATERAL_ADDRESS)) {\n            _transferCollateral(address(receiver_), amount_);\n\n            if (receiver_.onFlashLoan(msg.sender, token_, amount_, 0, data_) !=\n                keccak256(\"ERC3156FlashBorrower.onFlashLoan\")) revert FlashloanCallbackFailed();\n\n            _transferCollateralFrom(address(receiver_), amount_);\n            return true;\n        }\n\n        revert FlashloanUnavailableForToken();\n    }\n\n    /// @inheritdoc FlashloanablePool\n    function flashFee(\n        address token_,\n        uint256\n    ) external pure override(IERC3156FlashLender, FlashloanablePool) returns (uint256) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS) || token_ == _getArgAddress(COLLATERAL_ADDRESS)) return 0;\n        revert FlashloanUnavailableForToken();\n    }\n\n    /// @inheritdoc FlashloanablePool\n    function maxFlashLoan(\n        address token_\n    ) external view override(IERC3156FlashLender, FlashloanablePool) returns (uint256 maxLoan_) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS) || token_ == _getArgAddress(COLLATERAL_ADDRESS)) {\n            maxLoan_ = IERC20Token(token_).balanceOf(address(this));\n        }\n    }\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolLenderActions\n     *  @dev reverts on:\n     *          - DustAmountNotExceeded()\n     *  @dev emit events:\n     *          - AddCollateral\n     */\n    function addCollateral(\n        uint256 amountToAdd_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // revert if the dust amount was not exceeded, but round on the scale amount\n        if (amountToAdd_ != 0 && amountToAdd_ < _bucketCollateralDust(index_)) revert DustAmountNotExceeded();\n        amountToAdd_ = _roundToScale(amountToAdd_, _getArgUint256(COLLATERAL_SCALE));\n\n        bucketLPs_ = LenderActions.addCollateral(\n            buckets,\n            deposits,\n            amountToAdd_,\n            index_\n        );\n\n        emit AddCollateral(msg.sender, index_, amountToAdd_, bucketLPs_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        // move required collateral from sender to pool\n        _transferCollateralFrom(msg.sender, amountToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev emit events:\n     *          - RemoveCollateral\n     */\n    function removeCollateral(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 collateralAmount_, uint256 lpAmount_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round the collateral amount appropriately based on token precision\n        maxAmount_ = _roundToScale(maxAmount_, _getArgUint256(COLLATERAL_SCALE));\n\n        (collateralAmount_, lpAmount_) = LenderActions.removeMaxCollateral(\n            buckets,\n            deposits,\n            maxAmount_,\n            index_\n        );\n\n        emit RemoveCollateral(msg.sender, index_, collateralAmount_, lpAmount_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        // move collateral from pool to lender\n        _transferCollateral(msg.sender, collateralAmount_);\n    }\n\n    /*******************************/\n    /*** Pool Auctions Functions ***/\n    /*******************************/\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function settle(\n        address borrowerAddress_,\n        uint256 maxDepth_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();\n\n        uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;\n\n        (\n            ,\n            ,\n            uint256 collateralSettled,\n            uint256 t0DebtSettled\n        ) = Auctions.settlePoolDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            SettleParams({\n                borrower:    borrowerAddress_,\n                reserves:    (assets > liabilities) ? (assets - liabilities) : 0,\n                inflator:    poolState.inflator,\n                bucketDepth: maxDepth_,\n                poolType:    poolState.poolType\n            })\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt            -= t0DebtSettled;\n        poolBalances.t0DebtInAuction   -= t0DebtSettled;\n        poolBalances.pledgedCollateral -= collateralSettled;\n\n        // update pool interest rate state\n        poolState.debt       -= Maths.wmul(t0DebtSettled, poolState.inflator);\n        poolState.collateral -= collateralSettled;\n        _updateInterestState(poolState, _lup(poolState.debt));\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function take(\n        address        borrowerAddress_,\n        uint256        collateral_,\n        address        callee_,\n        bytes calldata data_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 collateralDust = _bucketCollateralDust(0);\n\n        // round requested collateral to an amount which can actually be transferred\n        collateral_ = _roundToScale(collateral_, collateralDust);\n\n        TakeResult memory result = Auctions.take(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            collateral_,\n            collateralDust\n        );\n        // round quote token up to cover the cost of purchasing the collateral\n        result.quoteTokenAmount = _roundUpToScale(result.quoteTokenAmount, _getArgUint256(QUOTE_SCALE));\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       =  result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n\n        _transferCollateral(callee_, result.collateralAmount);\n\n        if (data_.length != 0) {\n            IERC20Taker(callee_).atomicSwapCallback(\n                result.collateralAmount / _getArgUint256(COLLATERAL_SCALE), \n                result.quoteTokenAmount / _getArgUint256(QUOTE_SCALE), \n                data_\n            );\n        }\n\n        _transferQuoteTokenFrom(callee_, result.quoteTokenAmount);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function bucketTake(\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_\n    ) external override nonReentrant {\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        BucketTakeResult memory result = Auctions.bucketTake(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            depositTake_,\n            index_,\n            _bucketCollateralDust(0)\n        );\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    function _transferCollateralFrom(address from_, uint256 amount_) internal {\n        IERC20(_getArgAddress(COLLATERAL_ADDRESS)).safeTransferFrom(from_, address(this), amount_ / _getArgUint256(COLLATERAL_SCALE));\n    }\n\n    function _transferCollateral(address to_, uint256 amount_) internal {\n        IERC20(_getArgAddress(COLLATERAL_ADDRESS)).safeTransfer(to_, amount_ / _getArgUint256(COLLATERAL_SCALE));\n    }\n\n    function _bucketCollateralDust(uint256 bucketIndex) internal pure returns (uint256) {\n        // price precision adjustment will always be 0 for encumbered collateral\n        uint256 pricePrecisionAdjustment = _getCollateralDustPricePrecisionAdjustment(bucketIndex);\n        // difference between the normalized scale and the collateral token's scale\n        return Maths.max(_getArgUint256(COLLATERAL_SCALE), 10 ** pricePrecisionAdjustment);\n    } \n}"
    },
    {
      "filename": "contracts/src/ERC20Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }    from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { \n    IERC20Pool,\n    IERC20PoolBorrowerActions,\n    IERC20PoolImmutables,\n    IERC20PoolLenderActions\n}                              from './interfaces/pool/erc20/IERC20Pool.sol';\nimport { IERC20Taker }         from './interfaces/pool/erc20/IERC20Taker.sol';\n\nimport {\n    IPoolLenderActions,\n    IPoolLiquidationActions,\n    IERC20Token\n}                            from './interfaces/pool/IPool.sol';\nimport {\n    IERC3156FlashBorrower,\n    IERC3156FlashLender\n}                            from './interfaces/pool/IERC3156FlashLender.sol';\n\nimport {\n    DrawDebtResult,\n    BucketTakeResult,\n    RepayDebtResult,\n    SettleParams,\n    TakeResult\n}                    from './interfaces/pool/commons/IPoolInternals.sol';\nimport { PoolState } from './interfaces/pool/commons/IPoolState.sol';\n\nimport { FlashloanablePool } from './base/FlashloanablePool.sol';\n\nimport {\n    _getCollateralDustPricePrecisionAdjustment,\n    _roundToScale,\n    _roundUpToScale\n}                                               from './libraries/helpers/PoolHelper.sol';\nimport { _revertIfAuctionClearable }            from './libraries/helpers/RevertsHelper.sol';\n\nimport { Loans }    from './libraries/internal/Loans.sol';\nimport { Deposits } from './libraries/internal/Deposits.sol';\nimport { Maths }    from './libraries/internal/Maths.sol';\n\nimport { BorrowerActions } from './libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from './libraries/external/LenderActions.sol';\nimport { Auctions }        from './libraries/external/Auctions.sol';\n\n/**\n *  @title  ERC20 Pool contract\n *  @notice Entrypoint of ERC20 Pool actions for pool actors:\n *          - Lenders: add, remove and move quote tokens; transfer LPs\n *          - Borrowers: draw and repay debt\n *          - Traders: add, remove and move quote tokens; add and remove collateral\n *          - Kickers: kick undercollateralized loans; settle auctions; claim bond rewards\n *          - Bidders: take auctioned collateral\n *          - Reserve purchasers: start auctions; take reserves\n *          - Flash borrowers: initiate flash loans on quote tokens and collateral\n *  @dev    Contract is FlashloanablePool with flash loan logic.\n *  @dev    Contract is base Pool with logic to handle ERC20 collateral.\n *  @dev    Calls logic from external PoolCommons, LenderActions, BorrowerActions and Auctions libraries.\n */\ncontract ERC20Pool is FlashloanablePool, IERC20Pool {\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant COLLATERAL_SCALE = 93;\n\n    /****************************/\n    /*** Initialize Functions ***/\n    /****************************/\n\n    /// @inheritdoc IERC20Pool\n    function initialize(\n        uint256 rate_\n    ) external override {\n        if (isPoolInitialized) revert AlreadyInitialized();\n\n        inflatorState.inflator       = uint208(1e18);\n        inflatorState.inflatorUpdate = uint48(block.timestamp);\n\n        interestState.interestRate       = uint208(rate_);\n        interestState.interestRateUpdate = uint48(block.timestamp);\n\n        Loans.init(loans);\n\n        // increment initializations count to ensure these values can't be updated\n        isPoolInitialized = true;\n    }\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IERC20PoolImmutables\n    function collateralScale() external pure override returns (uint256) {\n        return _getArgUint256(COLLATERAL_SCALE);\n    }\n\n    /// @inheritdoc IERC20Pool\n    function bucketCollateralDust(uint256 bucketIndex) external pure override returns (uint256) {\n        return _bucketCollateralDust(bucketIndex);\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - increment poolBalances.pledgedCollateral accumulator\n     *          - increment poolBalances.t0Debt accumulator\n     *  @dev emit events:\n     *          - DrawDebt\n     */\n    function drawDebt(\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256 collateralToPledge_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure the borrower is not credited with a fractional amount of collateral smaller than the token scale\n        collateralToPledge_ = _roundToScale(collateralToPledge_, _bucketCollateralDust(0));\n\n        DrawDebtResult memory result = BorrowerActions.drawDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            amountToBorrow_,\n            limitIndex_,\n            collateralToPledge_\n        );\n\n        emit DrawDebt(borrowerAddress_, amountToBorrow_, collateralToPledge_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (collateralToPledge_ != 0) {\n            // update pool balances state\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n            poolBalances.pledgedCollateral += collateralToPledge_;\n\n            // move collateral from sender to pool\n            _transferCollateralFrom(msg.sender, collateralToPledge_);\n        }\n\n        if (amountToBorrow_ != 0) {\n            // update pool balances state\n            poolBalances.t0Debt += result.t0DebtChange;\n\n            // move borrowed amount from pool to sender\n            _transferQuoteToken(msg.sender, amountToBorrow_);\n        }\n    }\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     *  @dev emit events:\n     *          - RepayDebt\n     */\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure accounting is performed using the appropriate token scale\n        maxQuoteTokenAmountToRepay_ = _roundToScale(maxQuoteTokenAmountToRepay_, _getArgUint256(QUOTE_SCALE));\n        collateralAmountToPull_     = _roundToScale(collateralAmountToPull_,     _bucketCollateralDust(0));\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxQuoteTokenAmountToRepay_,\n            collateralAmountToPull_\n        );\n\n        emit RepayDebt(borrowerAddress_, result.quoteTokenToRepay, collateralAmountToPull_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.quoteTokenToRepay != 0) {\n            // update pool balances state\n            poolBalances.t0Debt -= result.t0RepaidDebt;\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n\n            // move amount to repay from sender to pool\n            _transferQuoteTokenFrom(msg.sender, result.quoteTokenToRepay);\n        }\n        if (collateralAmountToPull_ != 0) {\n            // update pool balances state\n            poolBalances.pledgedCollateral = result.poolCollateral;\n\n            // move collateral from pool to sender\n            _transferCollateral(msg.sender, collateralAmountToPull_);\n        }\n    }\n\n    /************************************/\n    /*** Flashloan External Functions ***/\n    /************************************/\n\n    /// @inheritdoc FlashloanablePool\n    function flashLoan(\n        IERC3156FlashBorrower receiver_,\n        address token_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external override(IERC3156FlashLender, FlashloanablePool) nonReentrant returns (bool) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS)) return _flashLoanQuoteToken(receiver_, token_, amount_, data_);\n\n        if (token_ == _getArgAddress(COLLATERAL_ADDRESS)) {\n            _transferCollateral(address(receiver_), amount_);\n\n            if (receiver_.onFlashLoan(msg.sender, token_, amount_, 0, data_) !=\n                keccak256(\"ERC3156FlashBorrower.onFlashLoan\")) revert FlashloanCallbackFailed();\n\n            _transferCollateralFrom(address(receiver_), amount_);\n            return true;\n        }\n\n        revert FlashloanUnavailableForToken();\n    }\n\n    /// @inheritdoc FlashloanablePool\n    function flashFee(\n        address token_,\n        uint256\n    ) external pure override(IERC3156FlashLender, FlashloanablePool) returns (uint256) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS) || token_ == _getArgAddress(COLLATERAL_ADDRESS)) return 0;\n        revert FlashloanUnavailableForToken();\n    }\n\n    /// @inheritdoc FlashloanablePool\n    function maxFlashLoan(\n        address token_\n    ) external view override(IERC3156FlashLender, FlashloanablePool) returns (uint256 maxLoan_) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS) || token_ == _getArgAddress(COLLATERAL_ADDRESS)) {\n            maxLoan_ = IERC20Token(token_).balanceOf(address(this));\n        }\n    }\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolLenderActions\n     *  @dev reverts on:\n     *          - DustAmountNotExceeded()\n     *  @dev emit events:\n     *          - AddCollateral\n     */\n    function addCollateral(\n        uint256 amountToAdd_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // revert if the dust amount was not exceeded, but round on the scale amount\n        if (amountToAdd_ != 0 && amountToAdd_ < _bucketCollateralDust(index_)) revert DustAmountNotExceeded();\n        amountToAdd_ = _roundToScale(amountToAdd_, _getArgUint256(COLLATERAL_SCALE));\n\n        bucketLPs_ = LenderActions.addCollateral(\n            buckets,\n            deposits,\n            amountToAdd_,\n            index_\n        );\n\n        emit AddCollateral(msg.sender, index_, amountToAdd_, bucketLPs_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        // move required collateral from sender to pool\n        _transferCollateralFrom(msg.sender, amountToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev emit events:\n     *          - RemoveCollateral\n     */\n    function removeCollateral(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 collateralAmount_, uint256 lpAmount_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round the collateral amount appropriately based on token precision\n        maxAmount_ = _roundToScale(maxAmount_, _getArgUint256(COLLATERAL_SCALE));\n\n        (collateralAmount_, lpAmount_) = LenderActions.removeMaxCollateral(\n            buckets,\n            deposits,\n            maxAmount_,\n            index_\n        );\n\n        emit RemoveCollateral(msg.sender, index_, collateralAmount_, lpAmount_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        // move collateral from pool to lender\n        _transferCollateral(msg.sender, collateralAmount_);\n    }\n\n    /*******************************/\n    /*** Pool Auctions Functions ***/\n    /*******************************/\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function settle(\n        address borrowerAddress_,\n        uint256 maxDepth_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();\n\n        uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;\n\n        (\n            ,\n            ,\n            uint256 collateralSettled,\n            uint256 t0DebtSettled\n        ) = Auctions.settlePoolDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            SettleParams({\n                borrower:    borrowerAddress_,"
    }
  ]
}