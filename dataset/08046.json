{
  "Title": "[M-01] A malicious user can send tokens to the TribeRedeemer contract to make the redeem function work, and other users may lose assets as a result",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/redeem/TribeRedeemer.sol#L44-L61\n\n\n# Vulnerability details\n\n## Impact\nIn the TribeRedeemer contract, the user provides redeemedToken to redeem the tokens in the list.\nThe transaction will revert when the balance of tokens in the list is 0. This prevents the user from losing their redeemedToken if they redeem when there are no tokens in the contract.\n```\n        for (uint256 i = 0; i < tokensReceived.length; i++) {\n            uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n            require(balance != 0, \"ZERO_BALANCE\");\n            // @dev, this assumes all of `tokensReceived` and `redeemedToken`\n            // have the same number of decimals\n            uint256 redeemedAmount = (amountIn * balance) / base;   // 10^6 * 10^18 / 10^8*10^6\n            amountsOut[i] = redeemedAmount;\n        }\n```\nHowever, a malicious user could send tokens in the list to the TribeRedeemer contract so that the token balance is not 0. This would allow the redeem function to work, and the user would suffer a loss when they redeem early by mistake.\n## Proof of Concept\nhttps://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/redeem/TribeRedeemer.sol#L44-L61\n## Tools Used\nNone\n## Recommended Mitigation Steps\nConsider making the TribeRedeemer contract inherit the Pausable contract and allow users to redeem when a sufficient number of tokens have been sent to the contract",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-fei-and-tribe-redemption-contest",
  "Code": [
    {
      "filename": "contracts/shutdown/redeem/TribeRedeemer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title contract used to redeem a list of tokens, by permanently\n/// taking another token out of circulation.\n/// @author Fei Protocol\ncontract TribeRedeemer is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice event to track redemptions\n    event Redeemed(address indexed owner, address indexed receiver, uint256 amount, uint256 base);\n\n    /// @notice token to redeem\n    address public immutable redeemedToken;\n\n    /// @notice tokens to receive when redeeming\n    address[] private tokensReceived;\n\n    /// @notice base used to compute the redemption amounts.\n    /// For instance, if the base is 100, and a user provides 100 `redeemedToken`,\n    /// they will receive all the balances of each `tokensReceived` held on this contract.\n    uint256 public redeemBase;\n\n    constructor(\n        address _redeemedToken,\n        address[] memory _tokensReceived,\n        uint256 _redeemBase\n    ) {\n        redeemedToken = _redeemedToken;\n        tokensReceived = _tokensReceived;\n        redeemBase = _redeemBase;\n    }\n\n    /// @notice Public function to get `tokensReceived`\n    function tokensReceivedOnRedeem() public view returns (address[] memory) {\n        return tokensReceived;\n    }\n\n    /// @notice Return the balances of `tokensReceived` that would be\n    /// transferred if redeeming `amountIn` of `redeemedToken`.\n    function previewRedeem(uint256 amountIn)\n        public\n        view\n        returns (address[] memory tokens, uint256[] memory amountsOut)\n    {\n        tokens = tokensReceivedOnRedeem();\n        amountsOut = new uint256[](tokens.length);\n\n        uint256 base = redeemBase;\n        for (uint256 i = 0; i < tokensReceived.length; i++) {\n            uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n            require(balance != 0, \"ZERO_BALANCE\");\n            // @dev, this assumes all of `tokensReceived` and `redeemedToken`\n            // have the same number of decimals\n            uint256 redeemedAmount = (amountIn * balance) / base;\n            amountsOut[i] = redeemedAmount;\n        }\n    }\n\n    /// @notice Redeem `redeemedToken` for a pro-rata basket of `tokensReceived`\n    function redeem(address to, uint256 amountIn) external nonReentrant {\n        IERC20(redeemedToken).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        (address[] memory tokens, uint256[] memory amountsOut) = previewRedeem(amountIn);\n\n        uint256 base = redeemBase;\n        redeemBase = base - amountIn; // decrement the base for future redemptions\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).safeTransfer(to, amountsOut[i]);\n        }\n\n        emit Redeemed(msg.sender, to, amountIn, base);\n    }\n}"
    }
  ]
}