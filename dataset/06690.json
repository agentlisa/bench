{
  "Title": "[N-01] Avoid infinite loops whenever possible",
  "Content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n\n> This r2 != 0 condition can be always true cause unbounded loop. This condition only fails if r2 is exactly equal to 0   \n\n51: while (r2 != 0) {\n                q = r1 / r2;\n                (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\n            }\n\n```\n[EllipticCurve.sol#L51-L54](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L51-L54)\n\n```solidity\nFILE: 2023-04-ens/contracts/dnssec-oracle/RRUtils.sol\n\nwhile (true) {\n            assert(idx < self.length);\n            uint256 labelLen = self.readUint8(idx);\n            idx += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n        }\n\n```\n[RRUtils.sol#L24-L31](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/RRUtils.sol#L24-L31)\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/dnssec-oracle/algorithms/EllipticCurve.sol",
      "content": "pragma solidity ^0.8.4;\n\n/**\n * @title   EllipticCurve\n *\n * @author  Tilman Drerup;\n *\n * @notice  Implements elliptic curve math; Parametrized for SECP256R1.\n *\n *          Includes components of code by Andreas Olofsson, Alexander Vlasov\n *          (https://github.com/BANKEX/CurveArithmetics), and Avi Asayag\n *          (https://github.com/orbs-network/elliptic-curve-solidity)\n *\n *          Source: https://github.com/tdrerup/elliptic-curve-solidity\n *\n * @dev     NOTE: To disambiguate public keys when verifying signatures, activate\n *          condition 'rs[1] > lowSmax' in validateSignature().\n */\ncontract EllipticCurve {\n    // Set parameters for curve.\n    uint256 constant a =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n    uint256 constant b =\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n    uint256 constant gx =\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n    uint256 constant gy =\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n    uint256 constant p =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 constant n =\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n\n    uint256 constant lowSmax =\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n\n    /**\n     * @dev Inverse of u in the field of modulo m.\n     */\n    function inverseMod(uint256 u, uint256 m) internal pure returns (uint256) {\n        unchecked {\n            if (u == 0 || u == m || m == 0) return 0;\n            if (u > m) u = u % m;\n\n            int256 t1;\n            int256 t2 = 1;\n            uint256 r1 = m;\n            uint256 r2 = u;\n            uint256 q;\n\n            while (r2 != 0) {\n                q = r1 / r2;\n                (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\n            }\n\n            if (t1 < 0) return (m - uint256(-t1));\n\n            return uint256(t1);\n        }\n    }\n\n    /**\n     * @dev Transform affine coordinates into projective coordinates.\n     */\n    function toProjectivePoint(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (uint256[3] memory P) {\n        P[2] = addmod(0, 1, p);\n        P[0] = mulmod(x0, P[2], p);\n        P[1] = mulmod(y0, P[2], p);\n    }\n\n    /**\n     * @dev Add two points in affine coordinates and return projective point.\n     */\n    function addAndReturnProjectivePoint(\n        uint256 x1,\n        uint256 y1,\n        uint256 x2,\n        uint256 y2\n    ) internal pure returns (uint256[3] memory P) {\n        uint256 x;\n        uint256 y;\n        (x, y) = add(x1, y1, x2, y2);\n        P = toProjectivePoint(x, y);\n    }\n\n    /**\n     * @dev Transform from projective to affine coordinates.\n     */\n    function toAffinePoint(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0\n    ) internal pure returns (uint256 x1, uint256 y1) {\n        uint256 z0Inv;\n        z0Inv = inverseMod(z0, p);\n        x1 = mulmod(x0, z0Inv, p);\n        y1 = mulmod(y0, z0Inv, p);\n    }\n\n    /**\n     * @dev Return the zero curve in projective coordinates.\n     */\n    function zeroProj()\n        internal\n        pure\n        returns (uint256 x, uint256 y, uint256 z)\n    {\n        return (0, 1, 0);\n    }\n\n    /**\n     * @dev Return the zero curve in affine coordinates.\n     */\n    function zeroAffine() internal pure returns (uint256 x, uint256 y) {\n        return (0, 0);\n    }\n\n    /**\n     * @dev Check if the curve is the zero curve.\n     */\n    function isZeroCurve(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (bool isZero) {\n        if (x0 == 0 && y0 == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @dev Check if a point in affine coordinates is on the curve.\n     */\n    function isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {\n        if (0 == x || x == p || 0 == y || y == p) {\n            return false;\n        }\n\n        uint256 LHS = mulmod(y, y, p); // y^2\n        uint256 RHS = mulmod(mulmod(x, x, p), x, p); // x^3\n\n        if (a != 0) {\n            RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x\n        }\n        if (b != 0) {\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\n        }\n\n        return LHS == RHS;\n    }\n\n    /**\n     * @dev Double an elliptic curve point in projective coordinates. See\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\n     */\n    function twiceProj(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0\n    ) internal pure returns (uint256 x1, uint256 y1, uint256 z1) {\n        uint256 t;\n        uint256 u;\n        uint256 v;\n        uint256 w;\n\n        if (isZeroCurve(x0, y0)) {\n            return zeroProj();\n        }\n\n        u = mulmod(y0, z0, p);\n        u = mulmod(u, 2, p);\n\n        v = mulmod(u, x0, p);\n        v = mulmod(v, y0, p);\n        v = mulmod(v, 2, p);\n\n        x0 = mulmod(x0, x0, p);\n        t = mulmod(x0, 3, p);\n\n        z0 = mulmod(z0, z0, p);\n        z0 = mulmod(z0, a, p);\n        t = addmod(t, z0, p);\n\n        w = mulmod(t, t, p);\n        x0 = mulmod(2, v, p);\n        w = addmod(w, p - x0, p);\n\n        x0 = addmod(v, p - w, p);\n        x0 = mulmod(t, x0, p);\n        y0 = mulmod(y0, u, p);\n        y0 = mulmod(y0, y0, p);\n        y0 = mulmod(2, y0, p);\n        y1 = addmod(x0, p - y0, p);\n\n        x1 = mulmod(u, w, p);\n\n        z1 = mulmod(u, u, p);\n        z1 = mulmod(z1, u, p);\n    }\n\n    /**\n     * @dev Add two elliptic curve points in projective coordinates. See\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\n     */\n    function addProj(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0,\n        uint256 x1,\n        uint256 y1,\n        uint256 z1\n    ) internal pure returns (uint256 x2, uint256 y2, uint256 z2) {\n        uint256 t0;\n        uint256 t1;\n        uint256 u0;\n        uint256 u1;\n\n        if (isZeroCurve(x0, y0)) {\n            return (x1, y1, z1);\n        } else if (isZeroCurve(x1, y1)) {\n            return (x0, y0, z0);\n        }\n\n        t0 = mulmod(y0, z1, p);\n        t1 = mulmod(y1, z0, p);\n\n        u0 = mulmod(x0, z1, p);\n        u1 = mulmod(x1, z0, p);\n\n        if (u0 == u1) {\n            if (t0 == t1) {\n                return twiceProj(x0, y0, z0);\n            } else {\n                return zeroProj();\n            }\n        }\n\n        (x2, y2, z2) = addProj2(mulmod(z0, z1, p), u0, u1, t1, t0);\n    }\n\n    /**\n     * @dev Helper function that splits addProj to avoid too many local variables.\n     */\n    function addProj2(\n        uint256 v,\n        uint256 u0,\n        uint256 u1,\n        uint256 t1,\n        uint256 t0\n    ) private pure returns (uint256 x2, uint256 y2, uint256 z2) {\n        uint256 u;\n        uint256 u2;\n        uint256 u3;\n        uint256 w;\n        uint256 t;\n\n        t = addmod(t0, p - t1, p);\n        u = addmod(u0, p - u1, p);\n        u2 = mulmod(u, u, p);\n\n        w = mulmod(t, t, p);\n        w = mulmod(w, v, p);\n        u1 = addmod(u1, u0, p);\n        u1 = mulmod(u1, u2, p);\n        w = addmod(w, p - u1, p);\n\n        x2 = mulmod(u, w, p);\n\n        u3 = mulmod(u2, u, p);\n        u0 = mulmod(u0, u2, p);\n        u0 = addmod(u0, p - w, p);\n        t = mulmod(t, u0, p);\n        t0 = mulmod(t0, u3, p);\n\n        y2 = addmod(t, p - t0, p);\n\n        z2 = mulmod(u3, v, p);\n    }\n\n    /**\n     * @dev Add two elliptic curve points in affine coordinates.\n     */\n    function add(\n        uint256 x0,\n        uint256 y0,\n        uint256 x1,\n        uint256 y1\n    ) internal pure returns (uint256, uint256) {\n        uint256 z0;\n\n        (x0, y0, z0) = addProj(x0, y0, 1, x1, y1, 1);\n\n        return toAffinePoint(x0, y0, z0);\n    }\n\n    /**\n     * @dev Double an elliptic curve point in affine coordinates.\n     */\n    function twice(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (uint256, uint256) {\n        uint256 z0;\n\n        (x0, y0, z0) = twiceProj(x0, y0, 1);\n\n        return toAffinePoint(x0, y0, z0);\n    }\n\n    /**\n     * @dev Multiply an elliptic curve point by a 2 power base (i.e., (2^exp)*P)).\n     */\n    function multiplyPowerBase2(\n        uint256 x0,\n        uint256 y0,\n        uint256 exp\n    ) internal pure returns (uint256, uint256) {\n        uint256 base2X = x0;\n        uint256 base2Y = y0;\n        uint256 base2Z = 1;\n\n        for (uint256 i = 0; i < exp; i++) {\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\n        }\n\n        return toAffinePoint(base2X, base2Y, base2Z);\n    }\n\n    /**\n     * @dev Multiply an elliptic curve point by a scalar.\n     */\n    function multiplyScalar(\n        uint256 x0,\n        uint256 y0,\n        uint256 scalar\n    ) internal pure returns (uint256 x1, uint256 y1) {\n        if (scalar == 0) {\n            return zeroAffine();\n        } else if (scalar == 1) {\n            return (x0, y0);\n        } else if (scalar == 2) {\n            return twice(x0, y0);\n        }\n\n        uint256 base2X = x0;\n        uint256 base2Y = y0;\n        uint256 base2Z = 1;\n        uint256 z1 = 1;\n        x1 = x0;\n        y1 = y0;\n\n        if (scalar % 2 == 0) {\n            x1 = y1 = 0;\n        }\n\n        scalar = scalar >> 1;\n\n        while (scalar > 0) {\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\n\n            if (scalar % 2 == 1) {\n                (x1, y1, z1) = addProj(base2X, base2Y, base2Z, x1, y1, z1);\n            }\n\n            scalar = scalar >> 1;\n        }\n\n        return toAffinePoint(x1, y1, z1);\n    }\n\n    /**\n     * @dev Multiply the curve's generator point by a scalar.\n     */\n    function multipleGeneratorByScalar(\n        uint256 scalar\n    ) internal pure returns (uint256, uint256) {\n        return multiplyScalar(gx, gy, scalar);\n    }\n\n    /**\n     * @dev Validate combination of message, signature, and public key.\n     */\n    function validateSignature(\n        bytes32 message,\n        uint256[2] memory rs,\n        uint256[2] memory Q\n    ) internal pure returns (bool) {\n        // To disambiguate between public key solutions, include comment below.\n        if (rs[0] == 0 || rs[0] >= n || rs[1] == 0) {\n            // || rs[1] > lowSmax)\n            return false;\n        }\n        if (!isOnCurve(Q[0], Q[1])) {\n            return false;\n        }\n\n        uint256 x1;\n        uint256 x2;\n        uint256 y1;\n        uint256 y2;\n\n        uint256 sInv = inverseMod(rs[1], n);\n        (x1, y1) = multiplyScalar(gx, gy, mulmod(uint256(message), sInv, n));\n        (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n));\n        uint256[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);\n\n        if (P[2] == 0) {\n            return false;\n        }\n\n        uint256 Px = inverseMod(P[2], p);\n        Px = mulmod(P[0], mulmod(Px, Px, p), p);\n\n        return Px % n == rs[0];\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/RRUtils.sol",
      "content": "pragma solidity ^0.8.4;\n\nimport \"./BytesUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/**\n * @dev RRUtils is a library that provides utilities for parsing DNS resource records.\n */\nlibrary RRUtils {\n    using BytesUtils for *;\n    using Buffer for *;\n\n    /**\n     * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return The length of the DNS name at 'offset', in bytes.\n     */\n    function nameLength(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (uint256) {\n        uint256 idx = offset;\n        while (true) {\n            assert(idx < self.length);\n            uint256 labelLen = self.readUint8(idx);\n            idx += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n        }\n        return idx - offset;\n    }\n\n    /**\n     * @dev Returns a DNS format name at the specified offset of self.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return ret The name.\n     */\n    function readName(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (bytes memory ret) {\n        uint256 len = nameLength(self, offset);\n        return self.substring(offset, len);\n    }\n\n    /**\n     * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return The number of labels in the DNS name at 'offset', in bytes.\n     */\n    function labelCount(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (uint256) {\n        uint256 count = 0;\n        while (true) {\n            assert(offset < self.length);\n            uint256 labelLen = self.readUint8(offset);\n            offset += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n            count += 1;\n        }\n        return count;\n    }\n\n    uint256 constant RRSIG_TYPE = 0;\n    uint256 constant RRSIG_ALGORITHM = 2;\n    uint256 constant RRSIG_LABELS = 3;\n    uint256 constant RRSIG_TTL = 4;\n    uint256 constant RRSIG_EXPIRATION = 8;\n    uint256 constant RRSIG_INCEPTION = 12;\n    uint256 constant RRSIG_KEY_TAG = 16;\n    uint256 constant RRSIG_SIGNER_NAME = 18;\n\n    struct SignedSet {\n        uint16 typeCovered;\n        uint8 algorithm;\n        uint8 labels;\n        uint32 ttl;\n        uint32 expiration;\n        uint32 inception;\n        uint16 keytag;\n        bytes signerName;\n        bytes data;\n        bytes name;\n    }\n\n    function readSignedSet(\n        bytes memory data\n    ) internal pure returns (SignedSet memory self) {\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\n        self.labels = data.readUint8(RRSIG_LABELS);\n        self.ttl = data.readUint32(RRSIG_TTL);\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\n        self.inception = data.readUint32(RRSIG_INCEPTION);\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\n        self.data = data.substring(\n            RRSIG_SIGNER_NAME + self.signerName.length,\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\n        );\n    }\n\n    function rrs(\n        SignedSet memory rrset\n    ) internal pure returns (RRIterator memory) {\n        return iterateRRs(rrset.data, 0);\n    }\n\n    /**\n     * @dev An iterator over resource records.\n     */\n    struct RRIterator {\n        bytes data;\n        uint256 offset;\n        uint16 dnstype;\n        uint16 class;\n        uint32 ttl;\n        uint256 rdataOffset;\n        uint256 nextOffset;\n    }\n\n    /**\n     * @dev Begins iterating over resource records.\n     * @param self The byte string to read from.\n     * @param offset The offset to start reading at.\n     * @return ret An iterator object.\n     */\n    function iterateRRs(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (RRIterator memory ret) {\n        ret.data = self;\n        ret.nextOffset = offset;\n        next(ret);\n    }\n\n    /**\n     * @dev Returns true iff there are more RRs to iterate.\n     * @param iter The iterator to check.\n     * @return True iff the iterator has finished.\n     */\n    function done(RRIterator memory iter) internal pure returns (bool) {\n        return iter.offset >= iter.data.length;\n    }\n\n    /**\n     * @dev Moves the iterator to the next resource record.\n     * @param iter The iterator to advance.\n     */\n    function next(RRIterator memory iter) internal pure {\n        iter.offset = iter.nextOffset;\n        if (iter.offset >= iter.data.length) {\n            return;\n        }\n\n        // Skip the name\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\n\n        // Read type, class, and ttl\n        iter.dnstype = iter.data.readUint16(off);\n        off += 2;\n        iter.class = iter.data.readUint16(off);\n        off += 2;\n        iter.ttl = iter.data.readUint32(off);\n        off += 4;\n\n        // Read the rdata\n        uint256 rdataLength = iter.data.readUint16(off);\n        off += 2;\n        iter.rdataOffset = off;\n        iter.nextOffset = off + rdataLength;\n    }\n\n    /**\n     * @dev Returns the name of the current record.\n     * @param iter The iterator.\n     * @return A new bytes object containing the owner name from the RR.\n     */\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\n        return\n            iter.data.substring(\n                iter.offset,\n                nameLength(iter.data, iter.offset)\n            );\n    }\n\n    /**\n     * @dev Returns the rdata portion of the current record.\n     * @param iter The iterator.\n     * @return A new bytes object containing the RR's RDATA.\n     */\n    function rdata(\n        RRIterator memory iter\n    ) internal pure returns (bytes memory) {\n        return\n            iter.data.substring(\n                iter.rdataOffset,\n                iter.nextOffset - iter.rdataOffset\n            );\n    }\n\n    uint256 constant DNSKEY_FLAGS = 0;\n    uint256 constant DNSKEY_PROTOCOL = 2;\n    uint256 constant DNSKEY_ALGORITHM = 3;\n    uint256 constant DNSKEY_PUBKEY = 4;\n\n    struct DNSKEY {\n        uint16 flags;\n        uint8 protocol;\n        uint8 algorithm;\n        bytes publicKey;\n    }\n\n    function readDNSKEY(\n        bytes memory data,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (DNSKEY memory self) {\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\n        self.publicKey = data.substring(\n            offset + DNSKEY_PUBKEY,\n            length - DNSKEY_PUBKEY\n        );\n    }\n\n    uint256 constant DS_KEY_TAG = 0;\n    uint256 constant DS_ALGORITHM = 2;\n    uint256 constant DS_DIGEST_TYPE = 3;\n    uint256 constant DS_DIGEST = 4;\n\n    struct DS {\n        uint16 keytag;\n        uint8 algorithm;\n        uint8 digestType;\n        bytes digest;\n    }\n\n    function readDS(\n        bytes memory data,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (DS memory self) {\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\n    }\n\n    function isSubdomainOf(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (bool) {\n        uint256 off = 0;\n        uint256 counts = labelCount(self, 0);\n        uint256 othercounts = labelCount(other, 0);\n\n        while (counts > othercounts) {\n            off = progress(self, off);\n            counts--;\n        }\n\n        return self.equals(off, other, 0);\n    }\n\n    function compareNames(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (int256) {\n        if (self.equals(other)) {\n            return 0;\n        }\n\n        uint256 off;\n        uint256 otheroff;\n        uint256 prevoff;\n        uint256 otherprevoff;\n        uint256 counts = labelCount(self, 0);\n        uint256 othercounts = labelCount(other, 0);\n\n        // Keep removing labels from the front of the name until both names are equal length\n        while (counts > othercounts) {\n            prevoff = off;\n            off = progress(self, off);\n            counts--;\n        }\n\n        while (othercounts > counts) {\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            othercounts--;\n        }\n\n        // Compare the last nonequal labels to each other\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\n            prevoff = off;\n            off = progress(self, off);\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            counts -= 1;\n        }\n\n        if (off == 0) {\n            return -1;\n        }\n        if (otheroff == 0) {\n            return 1;\n        }\n\n        return\n            self.compare(\n                prevoff + 1,\n                self.readUint8(prevoff),\n                other,\n                otherprevoff + 1,\n                other.readUint8(otherprevoff)\n            );\n    }\n\n    /**\n     * @dev Compares two serial numbers using RFC1982 serial number math.\n     */\n    function serialNumberGte(\n        uint32 i1,\n        uint32 i2\n    ) internal pure returns (bool) {\n        unchecked {\n            return int32(i1) - int32(i2) >= 0;\n        }\n    }\n\n    function progress(\n        bytes memory body,\n        uint256 off\n    ) internal pure returns (uint256) {\n        return off + 1 + body.readUint8(off);\n    }\n\n    /**\n     * @dev Computes the keytag for a chunk of data.\n     * @param data The data to compute a keytag for.\n     * @return The computed key tag.\n     */\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\n        /* This function probably deserves some explanation.\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\n         *\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\n         *         uint ac;\n         *         for (uint i = 0; i < data.length; i++) {\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\n         *         }\n         *         return uint16(ac + (ac >> 16));\n         *     }\n         *\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\n         * large words work in our favour.\n         *\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\n         * effectively summing 16 different numbers with each EVM ADD opcode.\n         *\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\n         * and the remaining sums can be done just on ac1.\n         */\n        unchecked {\n            require(data.length <= 8192, \"Long keys not permitted\");\n            uint256 ac1;\n            uint256 ac2;\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\n                uint256 word;\n                assembly {\n                    word := mload(add(add(data, 32), i))\n                }\n                if (i + 32 > data.length) {\n                    uint256 unused = 256 - (data.length - i) * 8;\n                    word = (word >> unused) << unused;\n                }\n                ac1 +=\n                    (word &\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\n                    8;\n                ac2 += (word &\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\n            }\n            ac1 =\n                (ac1 &\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n                ((ac1 &\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\n                    16);\n            ac2 =\n                (ac2 &\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n                ((ac2 &\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\n                    16);\n            ac1 = (ac1 << 8) + ac2;\n            ac1 =\n                (ac1 &\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\n                ((ac1 &\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\n                    32);\n            ac1 =\n                (ac1 &\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\n                ((ac1 &\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\n                    64);\n            ac1 =\n                (ac1 &\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\n                (ac1 >> 128);\n            ac1 += (ac1 >> 16) & 0xFFFF;\n            return uint16(ac1);\n        }\n    }\n}"
    }
  ]
}