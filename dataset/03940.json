{
  "Title": "[L05] Not checking for 0 addresses",
  "Content": "Some constructors do not check that an initialized `address` is not `0`. This could result in loss of control or locked funds. Examples include:\n\n\n* [`beneficiary` address](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/utils/LinearTokenTimelock.sol#L29) in the `LinearTokenTimelock` constructor\n* [`admin` address](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/dao/Timelock.sol#L32) in the `Timelock` constructor\n\n\nConsider validating that addresses are not `0` to ensure contracts operate as intended.\n\n\n**Update:** *Fixed in [PR#39](https://github.com/fei-protocol/fei-protocol-core/pull/39).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/utils/LinearTokenTimelock.sol",
      "content": "pragma solidity ^0.6.0;\n\n// Inspired by OpenZeppelin TokenTimelock contract\n// Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/TokenTimelock.sol\n\nimport \"./Timed.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract LinearTokenTimelock is Timed {\n\n    // ERC20 basic token contract being held\n    IERC20 public lockedToken;\n\n    // beneficiary of tokens after they are released\n    address public beneficiary;\n\n    address public pendingBeneficiary;\n\n    uint public initialBalance;\n\n    uint internal lastBalance;\n\n    event Release(address indexed _beneficiary, uint _amount);\n    event BeneficiaryUpdate(address indexed _beneficiary);\n    event PendingBeneficiaryUpdate(address indexed _pendingBeneficiary);\n\n    constructor (address _beneficiary, uint32 _duration) public Timed(_duration) {\n        require(_duration != 0, \"LinearTokenTimelock: duration is 0\");\n        beneficiary = _beneficiary;\n        _initTimed();\n    }\n\n    // Prevents incoming LP tokens from messing up calculations\n    modifier balanceCheck() {\n        if (totalToken() > lastBalance) {\n            uint delta = totalToken() - lastBalance;\n            initialBalance += delta;\n        }\n        _;\n        lastBalance = totalToken();\n    }\n\n    modifier onlyBeneficiary() {\n        require(msg.sender == beneficiary, \"LinearTokenTimelock: Caller is not a beneficiary\");\n        _;\n    }\n\n    function release() external onlyBeneficiary balanceCheck {\n        uint amount = availableForRelease();\n        require(amount != 0, \"LinearTokenTimelock: no tokens to release\");\n\n        lockedToken.transfer(beneficiary, amount);\n        emit Release(beneficiary, amount);\n    }\n\n    function totalToken() public view virtual returns(uint) {\n        return lockedToken.balanceOf(address(this));\n    }\n\n    function alreadyReleasedAmount() public view returns(uint) {\n        return initialBalance - totalToken();\n    }\n\n    function availableForRelease() public view returns(uint) {\n        uint elapsed = timestamp();\n        uint _duration = duration;\n\n        if (elapsed > _duration) {\n            elapsed = _duration;\n        }\n\n        uint totalAvailable = initialBalance * elapsed / _duration;\n        uint netAvailable = totalAvailable - alreadyReleasedAmount();\n        return netAvailable;\n    }\n\n    function setPendingBeneficiary(address _pendingBeneficiary) public onlyBeneficiary {\n        pendingBeneficiary = _pendingBeneficiary;\n        emit PendingBeneficiaryUpdate(_pendingBeneficiary);\n    }\n\n    function acceptBeneficiary() public virtual {\n        _setBeneficiary(msg.sender);\n    }\n\n    function _setBeneficiary(address newBeneficiary) internal {\n        require(newBeneficiary == pendingBeneficiary, \"LinearTokenTimelock: Caller is not pending beneficiary\");\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdate(newBeneficiary);\n        pendingBeneficiary = address(0);\n    }\n\n    function setLockedToken(address tokenAddress) internal {\n        lockedToken = IERC20(tokenAddress);\n    }\n}"
    },
    {
      "filename": "contracts/dao/Timelock.sol",
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// Forked from Compound\n// See https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol\ncontract Timelock {\n    using SafeMath for uint;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 1 hours;\n    uint public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) public {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    receive() external payable { }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: value}(callData); //solhint-disable avoid-call-value\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp;\n    }\n}"
    }
  ]
}