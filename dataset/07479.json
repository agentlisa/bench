{
  "Title": "[M-05] Failure in endpoint can cause minting more than one NFT with the same token id in different chains",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168\n\n\n# Vulnerability details\n\n## Impact\n\nIn the contract `GovNFT`, it is possible to bridge the governance NFT to other chains. It is also stated in the document that:\n>NFT holders only earn the profits generated by the platform on the chain that the NFT is on.\n\nIt is assumed that there is only one unique NFT per token id. But there is a scenario that can lead to have more than one NFT with the same token id on different chains.\n\n## Proof of Concept\n\n - Suppose Bob (honest user who owns an NFT with token id X on chain B) plans to bridge this NFT from chain B to chain A. So, Bob calls the function `crossChain` to bridge the NFT from chain B to chain A. Thus, his NFT will be burnt on chain B, and it is supposed to be minted on chain A.\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L124\n - The `endpoint` is responsible to complete the bridging task on chain A.\n - Suppose the `endpoint` calls the function `lzReceive` with low gas on chain A, so that the transaction will be not successful.\n```\nfunction lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        require(_msgSender() == address(endpoint), \"!Endpoint\");\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n```\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168\n - Since the transaction was not successful, the message will be added as a failed message.\n```\nfailedMessages[chainB][Bob's address][_nonce] = keccak256(_payload);\n```\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L178\n - Then, due to network lag (or any server issue, or any failure in `endpoint`), the `endpoint` assumes that the transaction is not sent, and it again calls this function with enough gas, so, the NFT with token id X will be minted to Bob's address on chain A. The flow is as follows:\n`lzReceive` ==> `nonblockingLzReceive` ==> `_nonblockingLzReceive` ==> `_bridgeMint`\n - Now Bob has the NFT on chain A. Moreover, he has a failed message on chain A.\n - Then Bob calls the function `crossChain` to bridge that NFT from chain A to chain B. So, this NFT will be burnt on chain A, and minted to Bob's address on chain B.\n - Now, Bob has the NFT with token id X on chain B. Moreover, he has a failed message on chain A.\n - He calls the function `retryMessage` to retry the failed message on chain A.\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L206\n - By doing so the NFT with token id X will be minted to Bob on chain A. The flow is as follows:\n`retryMessage` ==> `_nonblockingLzReceive` ==> `_bridgeMint`\n - Now Bob has the NFT with token id X on both chain A and chain B. This is the vulnerability. \n - Now he can for example sell the NFT on chain B while he is earning the profits generated by the platform on the chain A that the NFT is on.\n - Please note that Bob can not call the function `retryMessage` while he owns the NFT on chain A. Because during minting the NFT, it checks whether the token id exists or not. That is why Bob first bridges the NFT to another chain, and then retries the failed message.\n\n***The vulnerability is that when the message is failed, it is not considered as consumed, so in case of a failure in `endpoint` it is possible to both having failed message and being able to mint it at the same time.***\n\nPlease note that if this scenario happens again, more NFT with the same token id X will be minted to Bob on different chains.\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\nIt is recommended to track the consumed messages, and add a consumed flag whenever the function `lzReceive` is called, because it will either immediately mint the NFT or add it to he failed messages to be minted later.\n```\nmapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public consumedMessage;\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        \n        require(!consumedMessage[_srcChainId][_srcAddress][_nonce], \"already consumed\");\n        consumedMessage[_srcChainId][_srcAddress][_nonce] = true;\n\n        require(_msgSender() == address(endpoint), \"!Endpoint\");\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
  "Code": [
    {
      "filename": "contracts/GovNFT.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IGovNFT.sol\";\nimport \"./utils/ExcessivelySafeCall.sol\";\n\ncontract GovNFT is ERC721Enumerable, ILayerZeroReceiver, MetaContext, IGovNFT {\n    using ExcessivelySafeCall for address;\n    \n    uint256 private counter = 1;\n    uint256 private constant MAX = 10000;\n    uint256 public gas = 150000;\n    string public baseURI;\n    uint256 public maxBridge = 20;\n    ILayerZeroEndpoint public endpoint;\n\n    mapping(uint16 => mapping(address => bool)) public isTrustedAddress;\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n    event ReceiveNFT(\n        uint16 _srcChainId,\n        address _from,\n        uint256[] _tokenId\n    );\n\n    constructor(\n        address _endpoint,\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n        baseURI = _setBaseURI;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function _mint(address to, uint256 tokenId) internal override {\n        require(counter <= MAX, \"Exceeds supply\");\n        counter += 1;\n        for (uint i=0; i<assetsLength(); i++) {\n            userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n        }\n        super._mint(to, tokenId);\n    }\n\n    /**\n     * @dev should only be called by layer zero\n     * @param to the address to receive the bridged NFTs\n     * @param tokenId the NFT id\n     */\n    function _bridgeMint(address to, uint256 tokenId) public {\n        require(msg.sender == address(this) || _msgSender() == owner(), \"NotBridge\");\n        require(tokenId <= 10000, \"BadID\");\n        for (uint i=0; i<assetsLength(); i++) {\n            userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n        }\n        super._mint(to, tokenId);\n    }\n\n    /**\n    * @notice updates userDebt \n    */\n    function _burn(uint256 tokenId) internal override {\n        address owner = ownerOf(tokenId);\n        for (uint i=0; i<assetsLength(); i++) {\n            userDebt[owner][assets[i]] += accRewardsPerNFT[assets[i]];\n            userDebt[owner][assets[i]] -= userPaid[owner][assets[i]]/balanceOf(owner);\n            userPaid[owner][assets[i]] -= userPaid[owner][assets[i]]/balanceOf(owner);            \n        }\n        super._burn(tokenId);\n    }\n\n    /**\n    * @notice updates userDebt for both to and from\n    */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        require(ownerOf(tokenId) == from, \"!Owner\");\n        for (uint i=0; i<assetsLength(); i++) {\n            userDebt[from][assets[i]] += accRewardsPerNFT[assets[i]];\n            userDebt[from][assets[i]] -= userPaid[from][assets[i]]/balanceOf(from);\n            userPaid[from][assets[i]] -= userPaid[from][assets[i]]/balanceOf(from);\n            userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n        }\n        super._transfer(from, to, tokenId);\n    }\n\n    function mintMany(uint _amount) external onlyOwner {\n        for (uint i=0; i<_amount; i++) {\n            _mint(_msgSender(), counter);\n        }\n    }\n\n    function mint() external onlyOwner {\n        _mint(_msgSender(), counter);\n    }\n\n    function setTrustedAddress(uint16 _chainId, address _contract, bool _bool) external onlyOwner {\n        isTrustedAddress[_chainId][_contract] = _bool;\n    }\n\n    /**\n    * @notice used to bridge NFTs crosschain using layer zero\n    * @param _dstChainId the layer zero id of the dest chain\n    * @param _to receiving address on dest chain\n    * @param tokenId array of the ids of the NFTs to be bridged\n    */\n    function crossChain(\n        uint16 _dstChainId,\n        bytes memory _destination,\n        address _to,\n        uint256[] memory tokenId\n    ) public payable {\n        require(tokenId.length > 0, \"Not bridging\");\n        for (uint i=0; i<tokenId.length; i++) {\n            require(_msgSender() == ownerOf(tokenId[i]), \"Not the owner\");\n            // burn NFT\n            _burn(tokenId[i]);\n        }\n        address targetAddress;\n        assembly {\n            targetAddress := mload(add(_destination, 20))\n        }\n        require(isTrustedAddress[_dstChainId][targetAddress], \"!Trusted\");\n        bytes memory payload = abi.encode(_to, tokenId);\n        // encode adapterParams to specify more gas for the destination\n        uint16 version = 1;\n        uint256 _gas = 500_000 + gas*tokenId.length;\n        bytes memory adapterParams = abi.encodePacked(version, _gas);\n        (uint256 messageFee, ) = endpoint.estimateFees(\n            _dstChainId,\n            address(this),\n            payload,\n            false,\n            adapterParams\n        );\n        require(\n            msg.value >= messageFee,\n            \"Must send enough value to cover messageFee\"\n        );\n        endpoint.send{value: msg.value}(\n            _dstChainId,\n            _destination,\n            payload,\n            payable(_msgSender()),\n            address(0x0),\n            adapterParams\n        );\n    }\n\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        require(_msgSender() == address(endpoint), \"!Endpoint\");\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public {\n        // only internal transaction\n        require(msg.sender == address(this), \"NonblockingLzApp: caller must be app\");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64, bytes memory _payload) internal {\n        address fromAddress;\n        assembly {\n            fromAddress := mload(add(_srcAddress, 20))\n        }\n        require(isTrustedAddress[_srcChainId][fromAddress], \"!TrustedAddress\");\n        (address toAddress, uint256[] memory tokenId) = abi.decode(\n            _payload,\n            (address, uint256[])\n        );\n        // mint the tokens\n        for (uint i=0; i<tokenId.length; i++) {\n            _bridgeMint(toAddress, tokenId[i]);\n        }\n        emit ReceiveNFT(_srcChainId, toAddress, tokenId);\n    }\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n\n    // Endpoint.sol estimateFees() returns the fees for the message\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParams\n    ) external view returns (uint256 nativeFee, uint256 zroFee) {\n        return\n            endpoint.estimateFees(\n                _dstChainId,\n                _userApplication,\n                _payload,\n                _payInZRO,\n                _adapterParams\n            );\n    }\n\n    function setGas(uint _gas) external onlyOwner {\n        gas = _gas;\n    }\n\n    function setEndpoint(ILayerZeroEndpoint _endpoint) external onlyOwner {\n        require(address(_endpoint) != address(0), \"ZeroAddress\");\n        endpoint = _endpoint;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        for (uint i=0; i<_ids.length; i++) {\n            _transfer(_msgSender(), _to, _ids[i]);\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        for (uint i=0; i<_ids.length; i++) {\n            safeTransferFrom(_from, _to, _ids[i]);\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        for (uint i=0; i<_ids.length; i++) {\n            approve(_to, _ids[i]);\n        }\n    }\n\n    // Rewards\n    address[] public assets;\n    mapping(address => bool) private _allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(address => mapping(address => uint256)) private userPaid;\n    mapping(address => mapping(address => uint256)) private userDebt;\n    mapping(address => uint256) private accRewardsPerNFT;\n\n    /**\n    * @notice claimable by anyone to claim pending rewards tokens\n    * @param _tigAsset reward token address\n    */\n    function claim(address _tigAsset) external {\n        address _msgsender = _msgSender();\n        uint256 amount = pending(_msgsender, _tigAsset);\n        userPaid[_msgsender][_tigAsset] += amount;\n        IERC20(_tigAsset).transfer(_msgsender, amount);\n    }\n\n    /**\n    * @notice add rewards for NFT holders\n    * @param _tigAsset reward token address\n    * @param _amount amount to be distributed\n    */\n    function distribute(address _tigAsset, uint _amount) external {\n        if (assets.length == 0 || assets[assetsIndex[_tigAsset]] == address(0) || totalSupply() == 0 || !_allowedAsset[_tigAsset]) return;\n        try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n            accRewardsPerNFT[_tigAsset] += _amount/totalSupply();\n        } catch {\n            return;\n        }\n    }\n\n    function pending(address user, address _tigAsset) public view returns (uint256) {\n        return userDebt[user][_tigAsset] + balanceOf(user)*accRewardsPerNFT[_tigAsset] - userPaid[user][_tigAsset]; \n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        _allowedAsset[_asset] = true;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        _allowedAsset[_asset] = _bool;\n    }\n\n    function setMaxBridge(uint256 _max) external onlyOwner {\n        maxBridge = _max;\n    }\n\n    function assetsLength() public view returns (uint256) {\n        return assets.length;\n    }\n\n    function allowedAsset(address _asset) external view returns (bool) {\n        return _allowedAsset[_asset];\n    }\n\n    function balanceIds(address _user) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = tokenOfOwnerByIndex(_user, i);\n        }\n        return _ids;\n    }\n\n    // META-TX\n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {\n        return MetaContext._msgSender();\n    }\n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {\n        return MetaContext._msgData();\n    }\n}"
    }
  ]
}