{
  "Title": "[H-02] Draw organizer can rig the draw to favor certain participants such as their own account.",
  "Content": "\nIn RandomDraw, the host initiates a draw using `startDraw()` or `redraw()` if the redraw draw expiry has passed. Actual use of Chainlink oracle is done in `\\_requestRoll`:\n\n    request.currentChainlinkRequestId = coordinator.requestRandomWords({\n        keyHash: settings.keyHash,\n        subId: settings.subscriptionId,\n        minimumRequestConfirmations: minimumRequestConfirmations,\n        callbackGasLimit: callbackGasLimit,\n        numWords: wordsRequested\n    });\n\nUse of subscription API is explained well [here](https://docs.chain.link/vrf/v2/subscription). Chainlink VRFCoordinatorV2 is called with `requestRandomWords()` and emits a random request. After `minimumRequestConfirmations` blocks, an oracle VRF node replies to the coordinator with a provable random, which supplies the random to the requesting contract via `fulfillRandomWords()`  call. It is important to note the role of subscription ID. This ID maps to the subscription charged for the request, in LINK tokens. In our contract, the raffle host supplies their subscription ID as a parameter. Sufficient balance check of the request ID is not [checked](https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L370) at request-time, but rather checked in Chainlink [node](https://github.com/smartcontractkit/chainlink/blob/806ee17236ba70926a1f07d1141808b634db48b6/core/services/vrf/listener_v2.go#L346) code as well as on-chain by [VRFCoordinator](https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L594) when the request is satisfied. In the scenario where the subscriptionID lacks funds, there will be a period of 24 hours when user can top up the account and random response will be [sent](https://docs.chain.link/vrf/v2/subscription):\n\n\"Each subscription must maintain a minimum balance to fund requests from consuming contracts. If your balance is below that minimum, your requests remain pending for up to 24 hours before they expire. After you add sufficient LINK to a subscription, pending requests automatically process as long as they have not expired.\"\n\nThe reason this is extremely interesting is because as soon as redraws are possible, the random response can no longer be treated as fair. Indeed, Draw host can wait until redraw cooldown passed (e.g. 1 hour), and only then fund the subscriptionID. At this point, Chainlink node will send a TX with the random response. If host likes the response (i.e. the draw winner), they will not interfere. If they don't like the response, they can simply frontrun the Chainlink TX with a `redraw()` call. A redraw will create a new random request and discard the old requestId so the previous request will never be accepted.\n\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        // Validate request ID\n    \t  // <---------------- swap currentChainlinkRequestId --->\n        if (_requestId != request.currentChainlinkRequestId) {\n            revert REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n        }\n    \t...\n    }\n\n<!---->\n\n    //<------ redraw swaps currentChainlinkRequestId --->\n    request.currentChainlinkRequestId = coordinator.requestRandomWords({\n        keyHash: settings.keyHash,\n        subId: settings.subscriptionId,\n        minimumRequestConfirmations: minimumRequestConfirmations,\n        callbackGasLimit: callbackGasLimit,\n        numWords: wordsRequested\n    });\n\nChainlink docs [warn](https://docs.chain.link/vrf/v2/security) against this usage pattern of the VRF -\"Donâ€™t accept bids/bets/inputs after you have made a randomness request\". In this instance, a low subscription balance allows the host to invalidate the assumption that 1 hour redraw cooldown is enough to guarantee Chainlink answer has been received.\n\n### Impact\n\nDraw organizer can rig the draw to favor certain participants such as their own account.\n\n### Proof of Concept\n\nOwner offers a BAYC NFT for holders of their NFT collection X. Out of 10,000 tokenIDs, owner has 5,000 Xs. Rest belongs to retail users.\n\n1.  Owner subscriptionID is left with 0 LINK balance in coordinator\n2.  Redraw time is set to 2 hours\n3.  Owner calls `startDraw()` which will initiate a Chainlink request\n4.  Owner waits for 2 hours and then tops up their subscriptionID with sufficient LINK\n5.  Owner scans the mempool for `fulfillRandomWords()`\n6.  If the raffle winner is tokenID < 5000, it is owner's token\n    1.  Let fulfill execute and pick up the reward\n7.  If tokenID >= 5000\n    1.  Call `redraw()`\n    2.  fulfill will revert because of requestId mismatch\n8.  Owner has 75% of claiming the NFT instead of 50%\n\nNote that Forgeries draws are presumably intended as incentives for speculators to buy NFTs from specific collections. Without having a fair shot at receiving rewards from raffles, these NFTs user buys could be worthless. Another way to look at it is that the impact is theft of yield, as host can freely decrease the probability that a token will be chosen for rewards with this method.\n\nAlso, I did not categorize it as centralization risk as the counterparty is not Forgeries but rather some unknown third-party host which offers an NFT incentive program. It is a similar situation to the distinction made between 1st party and 3rd party projects [here](https://github.com/code-423n4/2022-10-juicebox-findings/issues/191).\n\n### Tools Used\n\n[Chainlink docs](https://docs.chain.link/vrf/v2/subscription)\n\n[Chainlink co-ordinator code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFCoordinatorV2.sol)\n\n### Recommended Mitigation Steps\n\nThe root cause is that Chainlink response can arrive up to 24 hours from the most request is dispatched, while redraw cooldown can be 1 hour+. The best fix would be to enforce minimum cooldown of 24 hours.\n\n**[iainnash (Forgeries) confirmed](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272)**\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1374550568):**\n > This issue weaponized [133](https://github.com/code-423n4/2022-12-forgeries-findings/issues/133) and [194](https://github.com/code-423n4/2022-12-forgeries-findings/issues/194) to violate the fairness requirement of the protocol. Downgrading this to Medium because the \n> 1. Difficulty of attack is high; you need to \n> a) front-run the fulfillRandomWords call and \n> b) own a meaningful % of the collection \n> \n> 2. Require to use an underfunded subscription\n> This will flag the raffle is fishy, since the owner might as well never fund the subscription.\n> \n> 3. 3rd party can mitigate this by funding the subscription.\n> \n> There is another case where the chainlink node waits almost 24 hours before fulfilling the request, but I don't think that is the normal behavior and is out of the attacker's control.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376205733):**\n > Would like to respectfully state my case and why this finding is clearly HIGH impact. \n> Manipulation of RNG is an extremely serious impact as it undermines assumption of fairness which is the main selling point of raffles, lotteries etc. As proof one can view [Chainlink's ](https://immunefi.com/bounty/chainlink/) BBP which lists \"Predictable or manipulable RNG that results in abuse of downstream services\" as a critical impact, payable up to $3M.\n> \n> I would like to relate to the conditions stated by the judge:\n> > 1. Difficulty of attack is high; you need to\n> >    a) front-run the fulfillRandomWords call and\n> >    b) own a meaningful % of the collection\n> \n> frontrunning is done in practically every block by MEV bots proving it's practical and easy to do on mainnet, where the protocol is deployed. Owning a meaningful % of the collection is not necessary, as:\n> 1. Even with 1 / 10,000 NFTs, owner is still multiplying their chances which is a breach of fair random.\n> 2. The exploit can be repeated in every single raffle, exponentially multiplying their edge across time. This also highlights that the frontrunning does not have to be work every time (even though it's high %) in order for the exploitation to work.\n> 3. The draw is chosen by ownership of **\\_settings.drawingToken**, which is a project-provided token which is already likely they have a large amount of. It is unrelated to the BAYC collection / high value NFT being given out.\n> 4. It is easy to see attacker can easily half the chances of any unwanted recipient to win the raffle - they would have to have the winning ticket in both rounds. Putting the subscriber's boosted win chances aside, it's a clear theft of user's potential high value prize.\n> \n> > * Require to use an underfunded subscription\n> >   This will flag the raffle is fishy, since the owner might as well never fund the subscription.\n> > * 3rd party can mitigate this by funding the subscription\n> \n> It is unrealistic to expect users of the protocol to be savvy on-chain detectives and also anticipate this specific attack vector. Even so, the topping-up of the subscription is done directly subscriber -> ChainlinkVRFCoordinator, so it's not visible by looking at the raffle contract. \n> \n> To summarize, the characteristics of this finding are much more aligned to those of High severity, than those of Medium severity.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376267492):**\n> The difficulty arises when only the raffle creator can perform the front running, not any interested MEV searcher. For sure, this is only 1 of the reason I think the risk of this issue is not High.\n\n> As the project seems to be fine with a raffle being created, but never actually started; I think when the attack require a chainlink subscription to be underfunded to begin with also kinda fall in to the \"creator decided not to start raffle\" category.\n\n> The argument of judging this apart from that is the raffle would looks like it completed but might not be fair, which I think is a very valid issue. However, I don't see this as High risk given the relative difficulty as said and we seems to agree that it is fine if the raffle creator decided not to start the raffle. The end state would basically be the same.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376282150):**\n > The end states are in my opinion very different. In order to understand the full impact of the vulnerability we need to understand the context in which those raffles take place. The drawing tokens are shilled to give users a chance to win a high valued item. Their worth is correlated to the fair chance users think they have in winning the raffle. The \"fake raffle\" on display allows the attacker to keep profiting from ticket sales while not giving away high value. I think this is why \n> @iainnash agreed this to be a high risk find. \n> \n> I've also listed several other justifications including theft of user's chances of winning which is high impact. I'd be happy to provide additional proof of why frontrunning is easily high enough % if that is the source of difficulty observed.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376307513):**\n > > The drawing tokens are shilled to give users a chance to win a high valued item. Their worth is correlated to the fair chance users think they have in winning the raffle. \n\n> That's my original thought, but you and the sponsor tried to convince me the raffle is permissioned by design considering startDraw. \n\n>If we think we need to guarantee the raffle token can get something fairly, we will also need to guarantee the raffle will, well, start. So I would say these are very similar since the ticket would be already sold anyway.\n\n>I think I might either keep everything as-is, or I am going to reinstate those other issues that I invalidated due to assuming the permissioned design, and upgrading this to High. Would love to hear more from the sponsor before making the final call.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1379859299):**\n> Regarding your smart observation @gzeon , I think the idea is clearly to make the draw methods decentralized in the future, but owner controlled as a first step. However they were not aware of this exploit, which from day 1 allows to put on a show and drive draw token prices up.\n\n**[gzeon (judge) increased severity to High and commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1383501062):**\n > [#359 (comment)](https://github.com/code-423n4/2022-12-forgeries-findings/discussions/359#discussioncomment-4693679)\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-12-forgeries-contest",
  "Code": [
    {
      "filename": "contracts/src/v0.8/VRFCoordinatorV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/BlockhashStoreInterface.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"./interfaces/TypeAndVersionInterface.sol\";\nimport \"./interfaces/ERC677ReceiverInterface.sol\";\nimport \"./VRF.sol\";\nimport \"./ConfirmedOwner.sol\";\nimport \"./VRFConsumerBaseV2.sol\";\n\ncontract VRFCoordinatorV2 is\n  VRF,\n  ConfirmedOwner,\n  TypeAndVersionInterface,\n  VRFCoordinatorV2Interface,\n  ERC677ReceiverInterface\n{\n  LinkTokenInterface public immutable LINK;\n  AggregatorV3Interface public immutable LINK_ETH_FEED;\n  BlockhashStoreInterface public immutable BLOCKHASH_STORE;\n\n  // We need to maintain a list of consuming addresses.\n  // This bound ensures we are able to loop over them as needed.\n  // Should a user require more consumers, they can use multiple subscriptions.\n  uint16 public constant MAX_CONSUMERS = 100;\n  error TooManyConsumers();\n  error InsufficientBalance();\n  error InvalidConsumer(uint64 subId, address consumer);\n  error InvalidSubscription();\n  error OnlyCallableFromLink();\n  error InvalidCalldata();\n  error MustBeSubOwner(address owner);\n  error PendingRequestExists();\n  error MustBeRequestedOwner(address proposedOwner);\n  error BalanceInvariantViolated(uint256 internalBalance, uint256 externalBalance); // Should never happen\n  event FundsRecovered(address to, uint256 amount);\n  // We use the subscription struct (1 word)\n  // at fulfillment time.\n  struct Subscription {\n    // There are only 1e9*1e18 = 1e27 juels in existence, so the balance can fit in uint96 (2^96 ~ 7e28)\n    uint96 balance; // Common link balance used for all consumer requests.\n    uint64 reqCount; // For fee tiers\n  }\n  // We use the config for the mgmt APIs\n  struct SubscriptionConfig {\n    address owner; // Owner can fund/withdraw/cancel the sub.\n    address requestedOwner; // For safely transferring sub ownership.\n    // Maintains the list of keys in s_consumers.\n    // We do this for 2 reasons:\n    // 1. To be able to clean up all keys from s_consumers when canceling a subscription.\n    // 2. To be able to return the list of all consumers in getSubscription.\n    // Note that we need the s_consumers map to be able to directly check if a\n    // consumer is valid without reading all the consumers from storage.\n    address[] consumers;\n  }\n  // Note a nonce of 0 indicates an the consumer is not assigned to that subscription.\n  mapping(address => mapping(uint64 => uint64)) /* consumer */ /* subId */ /* nonce */\n    private s_consumers;\n  mapping(uint64 => SubscriptionConfig) /* subId */ /* subscriptionConfig */\n    private s_subscriptionConfigs;\n  mapping(uint64 => Subscription) /* subId */ /* subscription */\n    private s_subscriptions;\n  // We make the sub count public so that its possible to\n  // get all the current subscriptions via getSubscription.\n  uint64 private s_currentSubId;\n  // s_totalBalance tracks the total link sent to/from\n  // this contract through onTokenTransfer, cancelSubscription and oracleWithdraw.\n  // A discrepancy with this contract's link balance indicates someone\n  // sent tokens using transfer and so we may need to use recoverFunds.\n  uint96 private s_totalBalance;\n  event SubscriptionCreated(uint64 indexed subId, address owner);\n  event SubscriptionFunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\n  event SubscriptionConsumerAdded(uint64 indexed subId, address consumer);\n  event SubscriptionConsumerRemoved(uint64 indexed subId, address consumer);\n  event SubscriptionCanceled(uint64 indexed subId, address to, uint256 amount);\n  event SubscriptionOwnerTransferRequested(uint64 indexed subId, address from, address to);\n  event SubscriptionOwnerTransferred(uint64 indexed subId, address from, address to);\n\n  // Set this maximum to 200 to give us a 56 block window to fulfill\n  // the request before requiring the block hash feeder.\n  uint16 public constant MAX_REQUEST_CONFIRMATIONS = 200;\n  uint32 public constant MAX_NUM_WORDS = 500;\n  // 5k is plenty for an EXTCODESIZE call (2600) + warm CALL (100)\n  // and some arithmetic operations.\n  uint256 private constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\n  error InvalidRequestConfirmations(uint16 have, uint16 min, uint16 max);\n  error GasLimitTooBig(uint32 have, uint32 want);\n  error NumWordsTooBig(uint32 have, uint32 want);\n  error ProvingKeyAlreadyRegistered(bytes32 keyHash);\n  error NoSuchProvingKey(bytes32 keyHash);\n  error InvalidLinkWeiPrice(int256 linkWei);\n  error InsufficientGasForConsumer(uint256 have, uint256 want);\n  error NoCorrespondingRequest();\n  error IncorrectCommitment();\n  error BlockhashNotInStore(uint256 blockNum);\n  error PaymentTooLarge();\n  error Reentrant();\n  struct RequestCommitment {\n    uint64 blockNum;\n    uint64 subId;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n    address sender;\n  }\n  mapping(bytes32 => address) /* keyHash */ /* oracle */\n    private s_provingKeys;\n  bytes32[] private s_provingKeyHashes;\n  mapping(address => uint96) /* oracle */ /* LINK balance */\n    private s_withdrawableTokens;\n  mapping(uint256 => bytes32) /* requestID */ /* commitment */\n    private s_requestCommitments;\n  event ProvingKeyRegistered(bytes32 keyHash, address indexed oracle);\n  event ProvingKeyDeregistered(bytes32 keyHash, address indexed oracle);\n  event RandomWordsRequested(\n    bytes32 indexed keyHash,\n    uint256 requestId,\n    uint256 preSeed,\n    uint64 indexed subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords,\n    address indexed sender\n  );\n  event RandomWordsFulfilled(uint256 indexed requestId, uint256 outputSeed, uint96 payment, bool success);\n\n  struct Config {\n    uint16 minimumRequestConfirmations;\n    uint32 maxGasLimit;\n    // Reentrancy protection.\n    bool reentrancyLock;\n    // stalenessSeconds is how long before we consider the feed price to be stale\n    // and fallback to fallbackWeiPerUnitLink.\n    uint32 stalenessSeconds;\n    // Gas to cover oracle payment after we calculate the payment.\n    // We make it configurable in case those operations are repriced.\n    uint32 gasAfterPaymentCalculation;\n  }\n  int256 private s_fallbackWeiPerUnitLink;\n  Config private s_config;\n  FeeConfig private s_feeConfig;\n  struct FeeConfig {\n    // Flat fee charged per fulfillment in millionths of link\n    // So fee range is [0, 2^32/10^6].\n    uint32 fulfillmentFlatFeeLinkPPMTier1;\n    uint32 fulfillmentFlatFeeLinkPPMTier2;\n    uint32 fulfillmentFlatFeeLinkPPMTier3;\n    uint32 fulfillmentFlatFeeLinkPPMTier4;\n    uint32 fulfillmentFlatFeeLinkPPMTier5;\n    uint24 reqsForTier2;\n    uint24 reqsForTier3;\n    uint24 reqsForTier4;\n    uint24 reqsForTier5;\n  }\n  event ConfigSet(\n    uint16 minimumRequestConfirmations,\n    uint32 maxGasLimit,\n    uint32 stalenessSeconds,\n    uint32 gasAfterPaymentCalculation,\n    int256 fallbackWeiPerUnitLink,\n    FeeConfig feeConfig\n  );\n\n  constructor(\n    address link,\n    address blockhashStore,\n    address linkEthFeed\n  ) ConfirmedOwner(msg.sender) {\n    LINK = LinkTokenInterface(link);\n    LINK_ETH_FEED = AggregatorV3Interface(linkEthFeed);\n    BLOCKHASH_STORE = BlockhashStoreInterface(blockhashStore);\n  }\n\n  /**\n   * @notice Registers a proving key to an oracle.\n   * @param oracle address of the oracle\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\n   */\n  function registerProvingKey(address oracle, uint256[2] calldata publicProvingKey) external onlyOwner {\n    bytes32 kh = hashOfKey(publicProvingKey);\n    if (s_provingKeys[kh] != address(0)) {\n      revert ProvingKeyAlreadyRegistered(kh);\n    }\n    s_provingKeys[kh] = oracle;\n    s_provingKeyHashes.push(kh);\n    emit ProvingKeyRegistered(kh, oracle);\n  }\n\n  /**\n   * @notice Deregisters a proving key to an oracle.\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\n   */\n  function deregisterProvingKey(uint256[2] calldata publicProvingKey) external onlyOwner {\n    bytes32 kh = hashOfKey(publicProvingKey);\n    address oracle = s_provingKeys[kh];\n    if (oracle == address(0)) {\n      revert NoSuchProvingKey(kh);\n    }\n    delete s_provingKeys[kh];\n    for (uint256 i = 0; i < s_provingKeyHashes.length; i++) {\n      if (s_provingKeyHashes[i] == kh) {\n        bytes32 last = s_provingKeyHashes[s_provingKeyHashes.length - 1];\n        // Copy last element and overwrite kh to be deleted with it\n        s_provingKeyHashes[i] = last;\n        s_provingKeyHashes.pop();\n      }\n    }\n    emit ProvingKeyDeregistered(kh, oracle);\n  }\n\n  /**\n   * @notice Returns the proving key hash key associated with this public key\n   * @param publicKey the key to return the hash of\n   */\n  function hashOfKey(uint256[2] memory publicKey) public pure returns (bytes32) {\n    return keccak256(abi.encode(publicKey));\n  }\n\n  /**\n   * @notice Sets the configuration of the vrfv2 coordinator\n   * @param minimumRequestConfirmations global min for request confirmations\n   * @param maxGasLimit global max for request gas limit\n   * @param stalenessSeconds if the eth/link feed is more stale then this, use the fallback price\n   * @param gasAfterPaymentCalculation gas used in doing accounting after completing the gas measurement\n   * @param fallbackWeiPerUnitLink fallback eth/link price in the case of a stale feed\n   * @param feeConfig fee tier configuration\n   */\n  function setConfig(\n    uint16 minimumRequestConfirmations,\n    uint32 maxGasLimit,\n    uint32 stalenessSeconds,\n    uint32 gasAfterPaymentCalculation,\n    int256 fallbackWeiPerUnitLink,\n    FeeConfig memory feeConfig\n  ) external onlyOwner {\n    if (minimumRequestConfirmations > MAX_REQUEST_CONFIRMATIONS) {\n      revert InvalidRequestConfirmations(\n        minimumRequestConfirmations,\n        minimumRequestConfirmations,\n        MAX_REQUEST_CONFIRMATIONS\n      );\n    }\n    if (fallbackWeiPerUnitLink <= 0) {\n      revert InvalidLinkWeiPrice(fallbackWeiPerUnitLink);\n    }\n    s_config = Config({\n      minimumRequestConfirmations: minimumRequestConfirmations,\n      maxGasLimit: maxGasLimit,\n      stalenessSeconds: stalenessSeconds,\n      gasAfterPaymentCalculation: gasAfterPaymentCalculation,\n      reentrancyLock: false\n    });\n    s_feeConfig = feeConfig;\n    s_fallbackWeiPerUnitLink = fallbackWeiPerUnitLink;\n    emit ConfigSet(\n      minimumRequestConfirmations,\n      maxGasLimit,\n      stalenessSeconds,\n      gasAfterPaymentCalculation,\n      fallbackWeiPerUnitLink,\n      s_feeConfig\n    );\n  }\n\n  function getConfig()\n    external\n    view\n    returns (\n      uint16 minimumRequestConfirmations,\n      uint32 maxGasLimit,\n      uint32 stalenessSeconds,\n      uint32 gasAfterPaymentCalculation\n    )\n  {\n    return (\n      s_config.minimumRequestConfirmations,\n      s_config.maxGasLimit,\n      s_config.stalenessSeconds,\n      s_config.gasAfterPaymentCalculation\n    );\n  }\n\n  function getFeeConfig()\n    external\n    view\n    returns (\n      uint32 fulfillmentFlatFeeLinkPPMTier1,\n      uint32 fulfillmentFlatFeeLinkPPMTier2,\n      uint32 fulfillmentFlatFeeLinkPPMTier3,\n      uint32 fulfillmentFlatFeeLinkPPMTier4,\n      uint32 fulfillmentFlatFeeLinkPPMTier5,\n      uint24 reqsForTier2,\n      uint24 reqsForTier3,\n      uint24 reqsForTier4,\n      uint24 reqsForTier5\n    )\n  {\n    return (\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier1,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier2,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier3,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier4,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier5,\n      s_feeConfig.reqsForTier2,\n      s_feeConfig.reqsForTier3,\n      s_feeConfig.reqsForTier4,\n      s_feeConfig.reqsForTier5\n    );\n  }\n\n  function getTotalBalance() external view returns (uint256) {\n    return s_totalBalance;\n  }\n\n  function getFallbackWeiPerUnitLink() external view returns (int256) {\n    return s_fallbackWeiPerUnitLink;\n  }\n\n  /**\n   * @notice Owner cancel subscription, sends remaining link directly to the subscription owner.\n   * @param subId subscription id\n   * @dev notably can be called even if there are pending requests, outstanding ones may fail onchain\n   */\n  function ownerCancelSubscription(uint64 subId) external onlyOwner {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    cancelSubscriptionHelper(subId, s_subscriptionConfigs[subId].owner);\n  }\n\n  /**\n   * @notice Recover link sent with transfer instead of transferAndCall.\n   * @param to address to send link to\n   */\n  function recoverFunds(address to) external onlyOwner {\n    uint256 externalBalance = LINK.balanceOf(address(this));\n    uint256 internalBalance = uint256(s_totalBalance);\n    if (internalBalance > externalBalance) {\n      revert BalanceInvariantViolated(internalBalance, externalBalance);\n    }\n    if (internalBalance < externalBalance) {\n      uint256 amount = externalBalance - internalBalance;\n      LINK.transfer(to, amount);\n      emit FundsRecovered(to, amount);\n    }\n    // If the balances are equal, nothing to be done.\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function getRequestConfig()\n    external\n    view\n    override\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    )\n  {\n    return (s_config.minimumRequestConfirmations, s_config.maxGasLimit, s_provingKeyHashes);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 requestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external override nonReentrant returns (uint256) {\n    // Input validation using the subscription storage.\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    // Its important to ensure that the consumer is in fact who they say they\n    // are, otherwise they could use someone else's subscription balance.\n    // A nonce of 0 indicates consumer is not allocated to the sub.\n    uint64 currentNonce = s_consumers[msg.sender][subId];\n    if (currentNonce == 0) {\n      revert InvalidConsumer(subId, msg.sender);\n    }\n    // Input validation using the config storage word.\n    if (\n      requestConfirmations < s_config.minimumRequestConfirmations || requestConfirmations > MAX_REQUEST_CONFIRMATIONS\n    ) {\n      revert InvalidRequestConfirmations(\n        requestConfirmations,\n        s_config.minimumRequestConfirmations,\n        MAX_REQUEST_CONFIRMATIONS\n      );\n    }\n    // No lower bound on the requested gas limit. A user could request 0\n    // and they would simply be billed for the proof verification and wouldn't be\n    // able to do anything with the random value.\n    if (callbackGasLimit > s_config.maxGasLimit) {\n      revert GasLimitTooBig(callbackGasLimit, s_config.maxGasLimit);\n    }\n    if (numWords > MAX_NUM_WORDS) {\n      revert NumWordsTooBig(numWords, MAX_NUM_WORDS);\n    }\n    // Note we do not check whether the keyHash is valid to save gas.\n    // The consequence for users is that they can send requests\n    // for invalid keyHashes which will simply not be fulfilled.\n    uint64 nonce = currentNonce + 1;\n    (uint256 requestId, uint256 preSeed) = computeRequestId(keyHash, msg.sender, subId, nonce);\n\n    s_requestCommitments[requestId] = keccak256(\n      abi.encode(requestId, block.number, subId, callbackGasLimit, numWords, msg.sender)\n    );\n    emit RandomWordsRequested(\n      keyHash,\n      requestId,\n      preSeed,\n      subId,\n      requestConfirmations,\n      callbackGasLimit,\n      numWords,\n      msg.sender\n    );\n    s_consumers[msg.sender][subId] = nonce;\n\n    return requestId;\n  }\n\n  /**\n   * @notice Get request commitment\n   * @param requestId id of request\n   * @dev used to determine if a request is fulfilled or not\n   */\n  function getCommitment(uint256 requestId) external view returns (bytes32) {\n    return s_requestCommitments[requestId];\n  }\n\n  function computeRequestId(\n    bytes32 keyHash,\n    address sender,\n    uint64 subId,\n    uint64 nonce\n  ) private pure returns (uint256, uint256) {\n    uint256 preSeed = uint256(keccak256(abi.encode(keyHash, sender, subId, nonce)));\n    return (uint256(keccak256(abi.encode(keyHash, preSeed))), preSeed);\n  }\n\n  /**\n   * @dev calls target address with exactly gasAmount gas and data as calldata\n   * or reverts if at least gasAmount gas is not available.\n   */\n  function callWithExactGas(\n    uint256 gasAmount,\n    address target,\n    bytes memory data\n  ) private returns (bool success) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let g := gas()\n      // Compute g -= GAS_FOR_CALL_EXACT_CHECK and check for underflow\n      // The gas actually passed to the callee is min(gasAmount, 63//64*gas available).\n      // We want to ensure that we revert if gasAmount >  63//64*gas available\n      // as we do not want to provide them with less, however that check itself costs\n      // gas.  GAS_FOR_CALL_EXACT_CHECK ensures we have at least enough gas to be able\n      // to revert if gasAmount >  63//64*gas available.\n      if lt(g, GAS_FOR_CALL_EXACT_CHECK) {\n        revert(0, 0)\n      }\n      g := sub(g, GAS_FOR_CALL_EXACT_CHECK)\n      // if g - g//64 <= gasAmount, revert\n      // (we subtract g//64 because of EIP-150)\n      if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\n        revert(0, 0)\n      }\n      // solidity calls check that a contract actually exists at the destination, so we do the same\n      if iszero(extcodesize(target)) {\n        revert(0, 0)\n      }\n      // call and return whether we succeeded. ignore return data\n      // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\n      success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\n    }\n    return success;\n  }\n\n  function getRandomnessFromProof(Proof memory proof, RequestCommitment memory rc)\n    private\n    view\n    returns (\n      bytes32 keyHash,\n      uint256 requestId,\n      uint256 randomness\n    )\n  {\n    keyHash = hashOfKey(proof.pk);\n    // Only registered proving keys are permitted.\n    address oracle = s_provingKeys[keyHash];\n    if (oracle == address(0)) {\n      revert NoSuchProvingKey(keyHash);\n    }\n    requestId = uint256(keccak256(abi.encode(keyHash, proof.seed)));\n    bytes32 commitment = s_requestCommitments[requestId];\n    if (commitment == 0) {\n      revert NoCorrespondingRequest();\n    }\n    if (\n      commitment != keccak256(abi.encode(requestId, rc.blockNum, rc.subId, rc.callbackGasLimit, rc.numWords, rc.sender))\n    ) {\n      revert IncorrectCommitment();\n    }\n\n    bytes32 blockHash = blockhash(rc.blockNum);\n    if (blockHash == bytes32(0)) {\n      blockHash = BLOCKHASH_STORE.getBlockhash(rc.blockNum);\n      if (blockHash == bytes32(0)) {\n        revert BlockhashNotInStore(rc.blockNum);\n      }\n    }\n\n    // The seed actually used by the VRF machinery, mixing in the blockhash\n    uint256 actualSeed = uint256(keccak256(abi.encodePacked(proof.seed, blockHash)));\n    randomness = VRF.randomValueFromVRFProof(proof, actualSeed); // Reverts on failure\n  }\n\n  /*\n   * @notice Compute fee based on the request count\n   * @param reqCount number of requests\n   * @return feePPM fee in LINK PPM\n   */\n  function getFeeTier(uint64 reqCount) public view returns (uint32) {\n    FeeConfig memory fc = s_feeConfig;\n    if (0 <= reqCount && reqCount <= fc.reqsForTier2) {\n      return fc.fulfillmentFlatFeeLinkPPMTier1;\n    }\n    if (fc.reqsForTier2 < reqCount && reqCount <= fc.reqsForTier3) {\n      return fc.fulfillmentFlatFeeLinkPPMTier2;\n    }\n    if (fc.reqsForTier3 < reqCount && reqCount <= fc.reqsForTier4) {\n      return fc.fulfillmentFlatFeeLinkPPMTier3;\n    }\n    if (fc.reqsForTier4 < reqCount && reqCount <= fc.reqsForTier5) {\n      return fc.fulfillmentFlatFeeLinkPPMTier4;\n    }\n    return fc.fulfillmentFlatFeeLinkPPMTier5;\n  }\n\n  /*\n   * @notice Fulfill a randomness request\n   * @param proof contains the proof and randomness\n   * @param rc request commitment pre-image, committed to at request time\n   * @return payment amount billed to the subscription\n   * @dev simulated offchain to determine if sufficient balance is present to fulfill the request\n   */\n  function fulfillRandomWords(Proof memory proof, RequestCommitment memory rc) external nonReentrant returns (uint96) {\n    uint256 startGas = gasleft();\n    (bytes32 keyHash, uint256 requestId, uint256 randomness) = getRandomnessFromProof(proof, rc);\n\n    uint256[] memory randomWords = new uint256[](rc.numWords);\n    for (uint256 i = 0; i < rc.numWords; i++) {\n      randomWords[i] = uint256(keccak256(abi.encode(randomness, i)));\n    }\n\n    delete s_requestCommitments[requestId];\n    VRFConsumerBaseV2 v;\n    bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, requestId, randomWords);\n    // Call with explicitly the amount of callback gas requested\n    // Important to not let them exhaust the gas budget and avoid oracle payment.\n    // Do not allow any non-view/non-pure coordinator functions to be called\n    // during the consumers callback code via reentrancyLock.\n    // Note that callWithExactGas will revert if we do not have sufficient gas\n    // to give the callee their requested amount.\n    s_config.reentrancyLock = true;\n    bool success = callWithExactGas(rc.callbackGasLimit, rc.sender, resp);\n    s_config.reentrancyLock = false;\n\n    // Increment the req count for fee tier selection.\n    uint64 reqCount = s_subscriptions[rc.subId].reqCount;\n    s_subscriptions[rc.subId].reqCount += 1;\n\n    // We want to charge users exactly for how much gas they use in their callback.\n    // The gasAfterPaymentCalculation is meant to cover these additional operations where we\n    // decrement the subscription balance and increment the oracles withdrawable balance.\n    // We also add the flat link fee to the payment amount.\n    // Its specified in millionths of link, if s_config.fulfillmentFlatFeeLinkPPM = 1\n    // 1 link / 1e6 = 1e18 juels / 1e6 = 1e12 juels.\n    uint96 payment = calculatePaymentAmount(\n      startGas,\n      s_config.gasAfterPaymentCalculation,\n      getFeeTier(reqCount),\n      tx.gasprice\n    );\n    if (s_subscriptions[rc.subId].balance < payment) {\n      revert InsufficientBalance();\n    }\n    s_subscriptions[rc.subId].balance -= payment;\n    s_withdrawableTokens[s_provingKeys[keyHash]] += payment;\n    // Include payment in the event for tracking costs.\n    emit RandomWordsFulfilled(requestId, randomness, payment, success);\n    return payment;\n  }\n\n  // Get the amount of gas used for fulfillment\n  function calculatePaymentAmount(\n    uint256 startGas,\n    uint256 gasAfterPaymentCalculation,\n    uint32 fulfillmentFlatFeeLinkPPM,\n    uint256 weiPerUnitGas\n  ) internal view returns (uint96) {\n    int256 weiPerUnitLink;\n    weiPerUnitLink = getFeedData();\n    if (weiPerUnitLink <= 0) {\n      revert InvalidLinkWeiPrice(weiPerUnitLink);\n    }\n    // (1e18 juels/link) (wei/gas * gas) / (wei/link) = juels\n    uint256 paymentNoFee = (1e18 * weiPerUnitGas * (gasAfterPaymentCalculation + startGas - gasleft())) /\n      uint256(weiPerUnitLink);\n    uint256 fee = 1e12 * uint256(fulfillmentFlatFeeLinkPPM);\n    if (paymentNoFee > (1e27 - fee)) {\n      revert PaymentTooLarge(); // Payment + fee cannot be more than all of the link in existence.\n    }\n    return uint96(paymentNoFee + fee);\n  }\n\n  function getFeedData() private view returns (int256) {\n    uint32 stalenessSeconds = s_config.stalenessSeconds;\n    bool staleFallback = stalenessSeconds > 0;\n    uint256 timestamp;\n    int256 weiPerUnitLink;\n    (, weiPerUnitLink, , timestamp, ) = LINK_ETH_FEED.latestRoundData();\n    // solhint-disable-next-line not-rely-on-time\n    if (staleFallback && stalenessSeconds < block.timestamp - timestamp) {\n      weiPerUnitLink = s_fallbackWeiPerUnitLink;\n    }\n    return weiPerUnitLink;\n  }\n\n  /*\n   * @notice Oracle withdraw LINK earned through fulfilling requests\n   * @param recipient where to send the funds\n   * @param amount amount to withdraw\n   */\n  function oracleWithdraw(address recipient, uint96 amount) external nonReentrant {\n    if (s_withdrawableTokens[msg.sender] < amount) {\n      revert InsufficientBalance();\n    }\n    s_withdrawableTokens[msg.sender] -= amount;\n    s_totalBalance -= amount;\n    if (!LINK.transfer(recipient, amount)) {\n      revert InsufficientBalance();\n    }\n  }\n\n  function onTokenTransfer(\n    address, /* sender */\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant {\n    if (msg.sender != address(LINK)) {\n      revert OnlyCallableFromLink();\n    }\n    if (data.length != 32) {\n      revert InvalidCalldata();\n    }\n    uint64 subId = abi.decode(data, (uint64));\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    // We do not check that the msg.sender is the subscription owner,\n    // anyone can fund a subscription.\n    uint256 oldBalance = s_subscriptions[subId].balance;\n    s_subscriptions[subId].balance += uint96(amount);\n    s_totalBalance += uint96(amount);\n    emit SubscriptionFunded(subId, oldBalance, oldBalance + amount);\n  }\n\n  function getCurrentSubId() external view returns (uint64) {\n    return s_currentSubId;\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    override\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    )\n  {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    return (\n      s_subscriptions[subId].balance,\n      s_subscriptions[subId].reqCount,\n      s_subscriptionConfigs[subId].owner,\n      s_subscriptionConfigs[subId].consumers\n    );\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function createSubscription() external override nonReentrant returns (uint64) {\n    s_currentSubId++;\n    uint64 currentSubId = s_currentSubId;\n    address[] memory consumers = new address[](0);\n    s_subscriptions[currentSubId] = Subscription({balance: 0, reqCount: 0});\n    s_subscriptionConfigs[currentSubId] = SubscriptionConfig({\n      owner: msg.sender,\n      requestedOwner: address(0),\n      consumers: consumers\n    });\n\n    emit SubscriptionCreated(currentSubId, msg.sender);\n    return currentSubId;\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)\n    external\n    override\n    onlySubOwner(subId)\n    nonReentrant\n  {\n    // Proposing to address(0) would never be claimable so don't need to check.\n    if (s_subscriptionConfigs[subId].requestedOwner != newOwner) {\n      s_subscriptionConfigs[subId].requestedOwner = newOwner;\n      emit SubscriptionOwnerTransferRequested(subId, msg.sender, newOwner);\n    }\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external override nonReentrant {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    if (s_subscriptionConfigs[subId].requestedOwner != msg.sender) {\n      revert MustBeRequestedOwner(s_subscriptionConfigs[subId].requestedOwner);\n    }\n    address oldOwner = s_subscriptionConfigs[subId].owner;\n    s_subscriptionConfigs[subId].owner = msg.sender;\n    s_subscriptionConfigs[subId].requestedOwner = address(0);\n    emit SubscriptionOwnerTransferred(subId, oldOwner, msg.sender);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function removeConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\n    if (s_consumers[consumer][subId] == 0) {\n      revert InvalidConsumer(subId, consumer);\n    }\n    // Note bounded by MAX_CONSUMERS\n    address[] memory consumers = s_subscriptionConfigs[subId].consumers;\n    uint256 lastConsumerIndex = consumers.length - 1;\n    for (uint256 i = 0; i < consumers.length; i++) {\n      if (consumers[i] == consumer) {\n        address last = consumers[lastConsumerIndex];\n        // Storage write to preserve last element\n        s_subscriptionConfigs[subId].consumers[i] = last;\n        // Storage remove last element\n        s_subscriptionConfigs[subId].consumers.pop();\n        break;\n      }\n    }\n    delete s_consumers[consumer][subId];\n    emit SubscriptionConsumerRemoved(subId, consumer);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function addConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\n    // Already maxed, cannot add any more consumers.\n    if (s_subscriptionConfigs[subId].consumers.length == MAX_CONSUMERS) {\n      revert TooManyConsumers();\n    }\n    if (s_consumers[consumer][subId] != 0) {\n      // Idempotence - do nothing if already added.\n      // Ensures uniqueness in s_subscriptions[subId].consumers.\n      return;\n    }\n    // Initialize the nonce to 1, indicating the consumer is allocated.\n    s_consumers[consumer][subId] = 1;\n    s_subscriptionConfigs[subId].consumers.push(consumer);\n\n    emit SubscriptionConsumerAdded(subId, consumer);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function cancelSubscription(uint64 subId, address to) external override onlySubOwner(subId) nonReentrant {\n    if (pendingRequestExists(subId)) {\n      revert PendingRequestExists();\n    }\n    cancelSubscriptionHelper(subId, to);\n  }\n\n  function cancelSubscriptionHelper(uint64 subId, address to) private nonReentrant {\n    SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\n    Subscription memory sub = s_subscriptions[subId];\n    uint96 balance = sub.balance;\n    // Note bounded by MAX_CONSUMERS;\n    // If no consumers, does nothing.\n    for (uint256 i = 0; i < subConfig.consumers.length; i++) {\n      delete s_consumers[subConfig.consumers[i]][subId];\n    }\n    delete s_subscriptionConfigs[subId];\n    delete s_subscriptions[subId];\n    s_totalBalance -= balance;\n    if (!LINK.transfer(to, uint256(balance))) {\n      revert InsufficientBalance();\n    }\n    emit SubscriptionCanceled(subId, to, balance);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   * @dev Looping is bounded to MAX_CONSUMERS*(number of keyhashes).\n   * @dev Used to disable subscription canceling while outstanding request are present.\n   */\n  function pendingRequestExists(uint64 subId) public view override returns (bool) {\n    SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\n    for (uint256 i = 0; i < subConfig.consumers.length; i++) {\n      for (uint256 j = 0; j < s_provingKeyHashes.length; j++) {\n        (uint256 reqId, ) = computeRequestId(\n          s_provingKeyHashes[j],\n          subConfig.consumers[i],\n          subId,\n          s_consumers[subConfig.consumers[i]][subId]\n        );\n        if (s_requestCommitments[reqId] != 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  modifier onlySubOwner(uint64 subId) {\n    address owner = s_subscriptionConfigs[subId].owner;\n    if (owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    if (msg.sender != owner) {\n      revert MustBeSubOwner(owner);\n    }\n    _;\n  }\n\n  modifier nonReentrant() {\n    if (s_config.reentrancyLock) {\n      revert Reentrant();\n    }\n    _;\n  }\n\n  /**\n   * @notice The type and version of this contract\n   * @return Type and version string\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"VRFCoordinatorV2 1.0.0\";\n  }\n}"
    }
  ]
}