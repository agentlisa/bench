{
  "Title": "[M-08] Incentive Pool can be drained without rebalancing the pool",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityPool.sol#L149-L173\nhttps://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityPool.sol#L263-L277\n\n\n# Vulnerability details\n\n## Impact\n`depositErc20` allows an attacker to specify the destination chain to be the same as the source chain and the receiver account to be the same as the caller account. This enables an attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state. \n\n\n## Proof of Concept\nThis requires the attacker to have some collateral, to begin with. The profit also depends on how much the attacker has. Assume the attacker has enough assets.\n\nIn each chain, when the pool is very deficit (e.g. `currentLiquidity` is much less than `providedLiquidity`), which often mean there's a good amount in the Incentive pool after some high valued transfers, then do the following.  \n\n- step 1 :  borrow the liquidityDifference amount such that one can get the whole incentivePool.\n```\n            uint256 liquidityDifference = providedLiquidity - currentLiquidity;\n            if (amount >= liquidityDifference) {\n                rewardAmount = incentivePool[tokenAddress];\n```\n- step 2 : call `depositErc20()` with `toChainId` being the same chain and `receiver` being `msg.sender`.\n\nThe executor will call `sendFundsToUser` to msg.sender. Then a rewardAmount, equivalent to the entire incentive pool (up to 10% of the total pool value), will be added to `msg.sender` minus equilibrium fee (~0.01%) and gas fee. \n\n\nIn the end, the pool is back to the deficit state as before, the incentive pool is drained and the exploiter pockets the difference of rewardAmount minus fees. \n\nThis attack can be repeated on each deployed chain multiple times whenever the incentive pool is profitable (particularly right after a big transfer).\n\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\n- Disallow `toChainId` to be the source chain by validating it in `depositErc20` or in `sendFundsToUser` validate that `fromChainId` is not the same as current chain.\n\n- require `receiver` is not `msg.sender` in `depositErc20`. \n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-biconomy-hyphen-20-contest",
  "Code": [
    {
      "filename": "contracts/hyphen/LiquidityPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/IExecutorManager.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./interfaces/ITokenManager.sol\";\n\ncontract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {\n    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy\n\n    uint256 public baseGas;\n\n    IExecutorManager private executorManager;\n    ITokenManager public tokenManager;\n    ILiquidityProviders public liquidityProviders;\n\n    struct PermitRequest {\n        uint256 nonce;\n        uint256 expiry;\n        bool allowed;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    mapping(bytes32 => bool) public processedHash;\n    mapping(address => uint256) public gasFeeAccumulatedByToken;\n\n    // Gas fee accumulated by token address => executor address\n    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;\n\n    // Incentive Pool amount per token address\n    mapping(address => uint256) public incentivePool;\n\n    event AssetSent(\n        address indexed asset,\n        uint256 indexed amount,\n        uint256 indexed transferredAmount,\n        address target,\n        bytes depositHash,\n        uint256 fromChainId\n    );\n    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);\n    event Received(address indexed from, uint256 indexed amount);\n    event Deposit(\n        address indexed from,\n        address indexed tokenAddress,\n        address indexed receiver,\n        uint256 toChainId,\n        uint256 amount,\n        uint256 reward,\n        string tag\n    );\n    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);\n    event TrustedForwarderChanged(address indexed forwarderAddress);\n    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);\n    event EthReceived(address, uint256);\n\n    // MODIFIERS\n    modifier onlyExecutor() {\n        require(executorManager.getExecutorStatus(_msgSender()), \"Only executor is allowed\");\n        _;\n    }\n\n    modifier onlyLiquidityProviders() {\n        require(_msgSender() == address(liquidityProviders), \"Only liquidityProviders is allowed\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, \"Token not supported\");\n        _;\n    }\n\n    function initialize(\n        address _executorManagerAddress,\n        address _pauser,\n        address _trustedForwarder,\n        address _tokenManager,\n        address _liquidityProviders\n    ) public initializer {\n        require(_executorManagerAddress != address(0), \"ExecutorManager cannot be 0x0\");\n        require(_trustedForwarder != address(0), \"TrustedForwarder cannot be 0x0\");\n        require(_liquidityProviders != address(0), \"LiquidityProviders cannot be 0x0\");\n        __ERC2771Context_init(_trustedForwarder);\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        executorManager = IExecutorManager(_executorManagerAddress);\n        tokenManager = ITokenManager(_tokenManager);\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        baseGas = 21000;\n    }\n\n    function setTrustedForwarder(address trustedForwarder) public onlyOwner {\n        require(trustedForwarder != address(0), \"TrustedForwarder can't be 0\");\n        _trustedForwarder = trustedForwarder;\n        emit TrustedForwarderChanged(trustedForwarder);\n    }\n\n    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {\n        require(_liquidityProviders != address(0), \"LiquidityProviders can't be 0\");\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        emit LiquidityProvidersChanged(_liquidityProviders);\n    }\n\n    function setBaseGas(uint128 gas) external onlyOwner {\n        baseGas = gas;\n    }\n\n    function getExecutorManager() public view returns (address) {\n        return address(executorManager);\n    }\n\n    function setExecutorManager(address _executorManagerAddress) external onlyOwner {\n        require(_executorManagerAddress != address(0), \"Executor Manager cannot be 0\");\n        executorManager = IExecutorManager(_executorManagerAddress);\n    }\n\n    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {\n        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);\n        \n        currentLiquidity =\n            liquidityPoolBalance -\n            liquidityProviders.totalLPFees(tokenAddress) -\n            gasFeeAccumulatedByToken[tokenAddress] -\n            incentivePool[tokenAddress];\n    }\n\n    /**\n     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.\n     * @param toChainId Chain id where funds needs to be transfered\n     * @param tokenAddress ERC20 Token address that needs to be transfered\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param amount Amount of token being transfered\n     */\n    function depositErc20(\n        uint256 toChainId,\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        string memory tag\n    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&\n                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(amount != 0, \"Amount cannot be 0\");\n        address sender = _msgSender();\n\n        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);\n        if (rewardAmount != 0) {\n            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);\n        // Emit (amount + reward amount) in event\n        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);\n    }\n\n    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);\n        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);\n        if (currentLiquidity < providedLiquidity) {\n            uint256 liquidityDifference = providedLiquidity - currentLiquidity;\n            if (amount >= liquidityDifference) {\n                rewardAmount = incentivePool[tokenAddress];\n            } else {\n                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference\n                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;\n                rewardAmount = rewardAmount / 10000000000;\n            }\n        }\n    }\n\n    /**\n     * DAI permit and Deposit.\n     */\n    function permitAndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            permitOptions.nonce,\n            permitOptions.expiry,\n            permitOptions.allowed,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * EIP2612 and Deposit.\n     */\n    function permitEIP2612AndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            amount,\n            permitOptions.expiry,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param toChainId Chain id where funds needs to be transfered\n     */\n    function depositNative(\n        address receiver,\n        uint256 toChainId,\n        string memory tag\n    ) external payable whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&\n                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(msg.value != 0, \"Amount cannot be 0\");\n\n        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);\n        if (rewardAmount != 0) {\n            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);\n        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);\n    }\n\n    function sendFundsToUser(\n        address tokenAddress,\n        uint256 amount,\n        address payable receiver,\n        bytes memory depositHash,\n        uint256 tokenGasPrice,\n        uint256 fromChainId\n    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n        uint256 initialGas = gasleft();\n        require(\n            tokenManager.getTransferConfig(tokenAddress).min <= amount &&\n                tokenManager.getTransferConfig(tokenAddress).max >= amount,\n            \"Withdraw amnt not in Cap limits\"\n        );\n        require(receiver != address(0), \"Bad receiver address\");\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n        require(!status, \"Already Processed\");\n        processedHash[hashSendTransaction] = true;\n\n        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);\n        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);\n\n        if (tokenAddress == NATIVE) {\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n            (bool success, ) = receiver.call{value: amountToTransfer}(\"\");\n            require(success, \"Native Transfer Failed\");\n        } else {\n            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);\n        }\n\n        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);\n    }\n\n    /**\n     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.\n     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.\n     * @param initialGas Gas provided initially before any calculations began\n     * @param tokenAddress Token address for which calculation needs to be done\n     * @param amount Amount of token to be transfered before deducting the fee\n     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee\n     * @return amountToTransfer Total amount to be transfered after deducting all fees.\n     */\n    function getAmountToTransfer(\n        uint256 initialGas,\n        address tokenAddress,\n        uint256 amount,\n        uint256 tokenGasPrice\n    ) internal returns (uint256 amountToTransfer) {\n        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);\n        uint256 lpFee;\n        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {\n            // Here add some fee to incentive pool also\n            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;\n            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;\n        } else {\n            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n        }\n        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n\n        liquidityProviders.addLPFee(tokenAddress, lpFee);\n\n        uint256 totalGasUsed = initialGas - gasleft();\n        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;\n        totalGasUsed = totalGasUsed + baseGas;\n\n        uint256 gasFee = totalGasUsed * tokenGasPrice;\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;\n        amountToTransfer = amount - (transferFeeAmount + gasFee);\n\n        emit FeeDetails(lpFee, transferFeeAmount, gasFee);\n    }\n\n    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);\n        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);\n\n        uint256 resultingLiquidity = currentLiquidity - amount;\n\n        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;\n        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;\n        // Fee is represented in basis points * 10 for better accuracy\n        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)\n        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)\n\n        if (denominator == 0) {\n            fee = 0;\n        } else {\n            fee = numerator / denominator;\n        }\n    }\n\n    function checkHashStatus(\n        address tokenAddress,\n        uint256 amount,\n        address payable receiver,\n        bytes memory depositHash\n    ) public view returns (bytes32 hashSendTransaction, bool status) {\n        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));\n\n        status = processedHash[hashSendTransaction];\n    }\n\n    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {\n        require(tokenAddress != NATIVE, \"Can't withdraw native token fee\");\n        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];\n        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];\n        require(_gasFeeAccumulated != 0, \"Gas Fee earned is 0\");\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);\n        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);\n    }\n\n    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {\n        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];\n        require(_gasFeeAccumulated != 0, \"Gas Fee earned is 0\");\n        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;\n        gasFeeAccumulated[NATIVE][_msgSender()] = 0;\n        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}(\"\");\n        require(success, \"Native Transfer Failed\");\n\n        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);\n    }\n\n    function transfer(\n        address _tokenAddress,\n        address receiver,\n        uint256 _tokenAmount\n    ) external whenNotPaused onlyLiquidityProviders nonReentrant {\n        require(receiver != address(0), \"Invalid receiver\");\n        if (_tokenAddress == NATIVE) {\n            require(address(this).balance >= _tokenAmount, \"ERR__INSUFFICIENT_BALANCE\");\n            (bool success, ) = receiver.call{value: _tokenAmount}(\"\");\n            require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        } else {\n            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);\n            require(baseToken.balanceOf(address(this)) >= _tokenAmount, \"ERR__INSUFFICIENT_BALANCE\");\n            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);\n        }\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit EthReceived(_msgSender(), msg.value);\n    }\n}"
    },
    {
      "filename": "contracts/hyphen/LiquidityPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/IExecutorManager.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./interfaces/ITokenManager.sol\";\n\ncontract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {\n    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy\n\n    uint256 public baseGas;\n\n    IExecutorManager private executorManager;\n    ITokenManager public tokenManager;\n    ILiquidityProviders public liquidityProviders;\n\n    struct PermitRequest {\n        uint256 nonce;\n        uint256 expiry;\n        bool allowed;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    mapping(bytes32 => bool) public processedHash;\n    mapping(address => uint256) public gasFeeAccumulatedByToken;\n\n    // Gas fee accumulated by token address => executor address\n    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;\n\n    // Incentive Pool amount per token address\n    mapping(address => uint256) public incentivePool;\n\n    event AssetSent(\n        address indexed asset,\n        uint256 indexed amount,\n        uint256 indexed transferredAmount,\n        address target,\n        bytes depositHash,\n        uint256 fromChainId\n    );\n    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);\n    event Received(address indexed from, uint256 indexed amount);\n    event Deposit(\n        address indexed from,\n        address indexed tokenAddress,\n        address indexed receiver,\n        uint256 toChainId,\n        uint256 amount,\n        uint256 reward,\n        string tag\n    );\n    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);\n    event TrustedForwarderChanged(address indexed forwarderAddress);\n    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);\n    event EthReceived(address, uint256);\n\n    // MODIFIERS\n    modifier onlyExecutor() {\n        require(executorManager.getExecutorStatus(_msgSender()), \"Only executor is allowed\");\n        _;\n    }\n\n    modifier onlyLiquidityProviders() {\n        require(_msgSender() == address(liquidityProviders), \"Only liquidityProviders is allowed\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, \"Token not supported\");\n        _;\n    }\n\n    function initialize(\n        address _executorManagerAddress,\n        address _pauser,\n        address _trustedForwarder,\n        address _tokenManager,\n        address _liquidityProviders\n    ) public initializer {\n        require(_executorManagerAddress != address(0), \"ExecutorManager cannot be 0x0\");\n        require(_trustedForwarder != address(0), \"TrustedForwarder cannot be 0x0\");\n        require(_liquidityProviders != address(0), \"LiquidityProviders cannot be 0x0\");\n        __ERC2771Context_init(_trustedForwarder);\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        executorManager = IExecutorManager(_executorManagerAddress);\n        tokenManager = ITokenManager(_tokenManager);\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        baseGas = 21000;\n    }\n\n    function setTrustedForwarder(address trustedForwarder) public onlyOwner {\n        require(trustedForwarder != address(0), \"TrustedForwarder can't be 0\");\n        _trustedForwarder = trustedForwarder;\n        emit TrustedForwarderChanged(trustedForwarder);\n    }\n\n    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {\n        require(_liquidityProviders != address(0), \"LiquidityProviders can't be 0\");\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        emit LiquidityProvidersChanged(_liquidityProviders);\n    }\n\n    function setBaseGas(uint128 gas) external onlyOwner {\n        baseGas = gas;\n    }\n\n    function getExecutorManager() public view returns (address) {\n        return address(executorManager);\n    }\n\n    function setExecutorManager(address _executorManagerAddress) external onlyOwner {\n        require(_executorManagerAddress != address(0), \"Executor Manager cannot be 0\");\n        executorManager = IExecutorManager(_executorManagerAddress);\n    }\n\n    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {\n        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);\n        \n        currentLiquidity =\n            liquidityPoolBalance -\n            liquidityProviders.totalLPFees(tokenAddress) -\n            gasFeeAccumulatedByToken[tokenAddress] -\n            incentivePool[tokenAddress];\n    }\n\n    /**\n     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.\n     * @param toChainId Chain id where funds needs to be transfered\n     * @param tokenAddress ERC20 Token address that needs to be transfered\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param amount Amount of token being transfered\n     */\n    function depositErc20(\n        uint256 toChainId,\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        string memory tag\n    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&\n                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(amount != 0, \"Amount cannot be 0\");\n        address sender = _msgSender();\n\n        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);\n        if (rewardAmount != 0) {\n            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);\n        // Emit (amount + reward amount) in event\n        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);\n    }\n\n    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);\n        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);\n        if (currentLiquidity < providedLiquidity) {\n            uint256 liquidityDifference = providedLiquidity - currentLiquidity;\n            if (amount >= liquidityDifference) {\n                rewardAmount = incentivePool[tokenAddress];\n            } else {\n                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference\n                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;\n                rewardAmount = rewardAmount / 10000000000;\n            }\n        }\n    }\n\n    /**\n     * DAI permit and Deposit.\n     */\n    function permitAndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            permitOptions.nonce,\n            permitOptions.expiry,\n            permitOptions.allowed,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * EIP2612 and Deposit.\n     */\n    function permitEIP2612AndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            amount,\n            permitOptions.expiry,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param toChainId Chain id where funds needs to be transfered\n     */\n    function depositNative(\n        address receiver,\n        uint256 toChainId,\n        string memory tag\n    ) external payable whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&\n                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(msg.value != 0, \"Amount cannot be 0\");\n\n        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);\n        if (rewardAmount != 0) {\n            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);\n        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);\n    }\n\n    function sendFundsToUser(\n        address tokenAddress,\n        uint256 amount,\n        address payable receiver,\n        bytes memory depositHash,\n        uint256 tokenGasPrice,\n        uint256 fromChainId\n    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n        uint256 initialGas = gasleft();\n        require(\n            tokenManager.getTransferConfig(tokenAddress).min <= amount &&\n                tokenManager.getTransferConfig(tokenAddress).max >= amount,\n            \"Withdraw amnt not in Cap limits\"\n        );\n        require(receiver != address(0), \"Bad receiver address\");\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n        require(!status, \"Already Processed\");\n        processedHash[hashSendTransaction] = true;\n\n        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);\n        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);\n\n        if (tokenAddress == NATIVE) {\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n            (bool success, ) = receiver.call{value: amountToTransfer}(\"\");\n            require(success, \"Native Transfer Failed\");\n        } else {\n            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);\n        }\n\n        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);\n    }\n\n    /**\n     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.\n     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.\n     * @param initialGas Gas provided initially before any calculations began\n     * @param tokenAddress Token address for which calculation needs to be done\n     * @param amount Amount of token to be transfered before deducting the fee\n     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee\n     * @return amountToTransfer Total amount to be transfered after deducting all fees.\n     */\n    function getAmountToTransfer(\n        uint256 initialGas,\n        address tokenAddress,\n        uint256 amount,\n        uint256 tokenGasPrice\n    ) internal returns (uint256 amountToTransfer) {\n        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);\n        uint256 lpFee;\n        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {\n            // Here add some fee to incentive pool also\n            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;\n            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;\n        } else {\n            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n        }\n        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n\n        liquidityProviders.addLPFee(tokenAddress, lpFee);\n\n        uint256 totalGasUsed = initialGas - gasleft();\n        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;\n        totalGasUsed = totalGasUsed + baseGas;\n\n        uint256 gasFee = totalGasUsed * tokenGasPrice;\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;\n        amountToTransfer = amount - (transferFeeAmount + gasFee);\n\n        emit FeeDetails(lpFee, transferFeeAmount, gasFee);\n    }\n\n    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddres"
    }
  ]
}