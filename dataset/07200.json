{
  "Title": "[G-03] Massive 15k per tx gas savings - use 1 and 2 for Reentrancy guard",
  "Content": "Using `true` and `false` will trigger gas-refunds, which after London are 1/5 of what they used to be, meaning using `1` and `2` (keeping the slot non-zero), will cost 5k per change (5k + 5k) vs 20k + 5k, saving you 15k gas per function which uses the modifier.\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L1434-L1439\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n  modifier nonReentrant() {\n    require(_notEntered, \"re-entered\");\n    _notEntered = false;\n    _;\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenModified.sol#L1437-L1442\n```solidity\nFile: /contracts/lending/tokens/cToken/CTokenModified.sol\n  modifier nonReentrant() {\n    require(_notEntered, \"re-entered\");\n    _notEntered = false;\n    _;\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n```\n\n[See solmate implementation](https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n\nWe could debate about the above finding being on the c4udit as **using bools** but due to the huge impact it would have, I've highlighted it here. Feel free to not include it when doing gas savings calculations. \n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-ondo-finance-contest",
  "Code": [
    {
      "filename": "contracts/lending/tokens/cCash/CTokenCash.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"../cErc20Delegate/ComptrollerInterface.sol\";\nimport \"../cErc20Delegate/ErrorReporter.sol\";\nimport \"../cErc20Delegate/EIP20Interface.sol\";\nimport \"../cErc20Delegate/InterestRateModel.sol\";\nimport \"../cErc20Delegate/ExponentialNoError.sol\";\nimport \"./CTokenInterfacesModifiedCash.sol\";\n\n/**\n * @title Ondo's CToken Contract for CASH\n * @notice Abstract base for CTokens w/underlying as CASH tokens\n * @dev Does KYC checks on key functions\n * @author Compound + Ondo\n */\nabstract contract CTokenCash is\n  CTokenInterface,\n  ExponentialNoError,\n  TokenErrorReporter\n{\n  /**\n   * @notice Initialize the money market\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ EIP-20 name of this token\n   * @param symbol_ EIP-20 symbol of this token\n   * @param decimals_ EIP-20 decimal precision of this token\n   * @param kycRegistry_ KYC Registry contract address\n   * @param kycRequirementGroup_ KYC Requirement group to check KYC status\n   *                             against\n   */\n  function initialize(\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address kycRegistry_,\n    uint256 kycRequirementGroup_\n  ) public {\n    require(msg.sender == admin, \"only admin may initialize the market\");\n    require(\n      accrualBlockNumber == 0 && borrowIndex == 0,\n      \"market may only be initialized once\"\n    );\n\n    // Set initial exchange rate\n    initialExchangeRateMantissa = initialExchangeRateMantissa_;\n    require(\n      initialExchangeRateMantissa > 0,\n      \"initial exchange rate must be greater than zero.\"\n    );\n\n    // Set the comptroller\n    uint err = _setComptroller(comptroller_);\n    require(err == NO_ERROR, \"setting comptroller failed\");\n\n    // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n    accrualBlockNumber = getBlockNumber();\n    borrowIndex = mantissaOne;\n\n    // Set the interest rate model (depends on block number / borrow index)\n    err = _setInterestRateModelFresh(interestRateModel_);\n    require(err == NO_ERROR, \"setting interest rate model failed\");\n\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n\n    // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n    _notEntered = true;\n\n    // Initialize KYCRegistryClient\n    _setKYCRegistry(kycRegistry_);\n    _setKYCRequirementGroup(kycRequirementGroup_);\n  }\n\n  /**\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n   * @dev Called by both `transfer` and `transferFrom` internally\n   * @param spender The address of the account performing the transfer\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param tokens The number of tokens to transfer\n   * @return 0 if the transfer succeeded, else revert\n   */\n  function transferTokens(\n    address spender,\n    address src,\n    address dst,\n    uint tokens\n  ) internal returns (uint) {\n    /* Revert if KYC not valid */\n    require(_getKYCStatus(spender), \"Spender not KYC'd\");\n    require(_getKYCStatus(src), \"Source not KYC'd\");\n    require(_getKYCStatus(dst), \"Destination not KYC'd\");\n\n    /* Fail if transfer not allowed */\n    uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n    if (allowed != 0) {\n      revert TransferComptrollerRejection(allowed);\n    }\n\n    /* Do not allow self-transfers */\n    if (src == dst) {\n      revert TransferNotAllowed();\n    }\n\n    /* Get the allowance, infinite for the account owner */\n    uint startingAllowance = 0;\n    if (spender == src) {\n      startingAllowance = type(uint).max;\n    } else {\n      startingAllowance = transferAllowances[src][spender];\n    }\n\n    /* Do the calculations, checking for {under,over}flow */\n    uint allowanceNew = startingAllowance - tokens;\n    uint srcTokensNew = accountTokens[src] - tokens;\n    uint dstTokensNew = accountTokens[dst] + tokens;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    accountTokens[src] = srcTokensNew;\n    accountTokens[dst] = dstTokensNew;\n\n    /* Eat some of the allowance (if necessary) */\n    if (startingAllowance != type(uint).max) {\n      transferAllowances[src][spender] = allowanceNew;\n    }\n\n    /* We emit a Transfer event */\n    emit Transfer(src, dst, tokens);\n\n    // unused function\n    // comptroller.transferVerify(address(this), src, dst, tokens);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(\n    address dst,\n    uint256 amount\n  ) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (uint256.max means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(\n    address spender,\n    uint256 amount\n  ) external override returns (bool) {\n    address src = msg.sender;\n    transferAllowances[src][spender] = amount;\n    emit Approval(src, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(\n    address owner,\n    address spender\n  ) external view override returns (uint256) {\n    return transferAllowances[owner][spender];\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The number of tokens owned by `owner`\n   */\n  function balanceOf(address owner) external view override returns (uint256) {\n    return accountTokens[owner];\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n   * @dev This also accrues interest in a transaction\n   * @param owner The address of the account to query\n   * @return The amount of underlying owned by `owner`\n   */\n  function balanceOfUnderlying(address owner) external override returns (uint) {\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n    return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\n   * @param account Address of the account to snapshot\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n   */\n  function getAccountSnapshot(\n    address account\n  ) external view override returns (uint, uint, uint, uint) {\n    return (\n      NO_ERROR,\n      accountTokens[account],\n      borrowBalanceStoredInternal(account),\n      exchangeRateStoredInternal()\n    );\n  }\n\n  /**\n   * @dev Function to simply retrieve block number\n   *  This exists mainly for inheriting test contracts to stub this result.\n   */\n  function getBlockNumber() internal view virtual returns (uint) {\n    return block.number;\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n   * @return The borrow interest rate per block, scaled by 1e18\n   */\n  function borrowRatePerBlock() external view override returns (uint) {\n    return\n      interestRateModel.getBorrowRate(\n        getCashPrior(),\n        totalBorrows,\n        totalReserves\n      );\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n   * @return The supply interest rate per block, scaled by 1e18\n   */\n  function supplyRatePerBlock() external view override returns (uint) {\n    return\n      interestRateModel.getSupplyRate(\n        getCashPrior(),\n        totalBorrows,\n        totalReserves,\n        reserveFactorMantissa\n      );\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n   * @return The total borrows with interest\n   */\n  function totalBorrowsCurrent() external override nonReentrant returns (uint) {\n    accrueInterest();\n    return totalBorrows;\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n   * @param account The address whose balance should be calculated after updating borrowIndex\n   * @return The calculated balance\n   */\n  function borrowBalanceCurrent(\n    address account\n  ) external override nonReentrant returns (uint) {\n    accrueInterest();\n    return borrowBalanceStored(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return The calculated balance\n   */\n  function borrowBalanceStored(\n    address account\n  ) public view override returns (uint) {\n    return borrowBalanceStoredInternal(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return (error code, the calculated balance or 0 if error code is non-zero)\n   */\n  function borrowBalanceStoredInternal(\n    address account\n  ) internal view returns (uint) {\n    /* Get borrowBalance and borrowIndex */\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n     */\n    if (borrowSnapshot.principal == 0) {\n      return 0;\n    }\n\n    /* Calculate new borrow balance using the interest index:\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n     */\n    uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n    return principalTimesIndex / borrowSnapshot.interestIndex;\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateCurrent() public override nonReentrant returns (uint) {\n    accrueInterest();\n    return exchangeRateStored();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the cToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStored() public view override returns (uint) {\n    return exchangeRateStoredInternal();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the cToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStoredInternal() internal view virtual returns (uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n      /*\n       * If there are no tokens minted:\n       *  exchangeRate = initialExchangeRate\n       */\n      return initialExchangeRateMantissa;\n    } else {\n      /*\n       * Otherwise:\n       *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n       */\n      uint totalCash = getCashPrior();\n      uint cashPlusBorrowsMinusReserves = totalCash +\n        totalBorrows -\n        totalReserves;\n      uint exchangeRate = (cashPlusBorrowsMinusReserves * expScale) /\n        _totalSupply;\n\n      return exchangeRate;\n    }\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n   * @return The quantity of underlying asset owned by this contract\n   */\n  function getCash() external view override returns (uint) {\n    return getCashPrior();\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves\n   * @dev This calculates interest accrued from the last checkpointed block\n   *   up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public virtual override returns (uint) {\n    /* Remember the initial block number */\n    uint currentBlockNumber = getBlockNumber();\n    uint accrualBlockNumberPrior = accrualBlockNumber;\n\n    /* Short-circuit accumulating 0 interest */\n    if (accrualBlockNumberPrior == currentBlockNumber) {\n      return NO_ERROR;\n    }\n\n    /* Read the previous values out of storage */\n    uint cashPrior = getCashPrior();\n    uint borrowsPrior = totalBorrows;\n    uint reservesPrior = totalReserves;\n    uint borrowIndexPrior = borrowIndex;\n\n    /* Calculate the current borrow interest rate */\n    uint borrowRateMantissa = interestRateModel.getBorrowRate(\n      cashPrior,\n      borrowsPrior,\n      reservesPrior\n    );\n    require(\n      borrowRateMantissa <= borrowRateMaxMantissa,\n      \"borrow rate is absurdly high\"\n    );\n\n    /* Calculate the number of blocks elapsed since the last accrual */\n    uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n    /*\n     * Calculate the interest accumulated into borrows and reserves and the new index:\n     *  simpleInterestFactor = borrowRate * blockDelta\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n     */\n\n    Exp memory simpleInterestFactor = mul_(\n      Exp({mantissa: borrowRateMantissa}),\n      blockDelta\n    );\n    uint interestAccumulated = mul_ScalarTruncate(\n      simpleInterestFactor,\n      borrowsPrior\n    );\n    uint totalBorrowsNew = interestAccumulated + borrowsPrior;\n    uint totalReservesNew = mul_ScalarTruncateAddUInt(\n      Exp({mantissa: reserveFactorMantissa}),\n      interestAccumulated,\n      reservesPrior\n    );\n    uint borrowIndexNew = mul_ScalarTruncateAddUInt(\n      simpleInterestFactor,\n      borrowIndexPrior,\n      borrowIndexPrior\n    );\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accrualBlockNumber = currentBlockNumber;\n    borrowIndex = borrowIndexNew;\n    totalBorrows = totalBorrowsNew;\n    totalReserves = totalReservesNew;\n\n    /* We emit an AccrueInterest event */\n    emit AccrueInterest(\n      cashPrior,\n      interestAccumulated,\n      borrowIndexNew,\n      totalBorrowsNew\n    );\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   */\n  function mintInternal(uint mintAmount) internal nonReentrant {\n    accrueInterest();\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n    mintFresh(msg.sender, mintAmount);\n  }\n\n  /**\n   * @notice User supplies assets into the market and receives cTokens in exchange\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param minter The address of the account which is supplying the assets\n   * @param mintAmount The amount of the underlying asset to supply\n   */\n  function mintFresh(address minter, uint mintAmount) internal {\n    /* Revert if minter not KYC'd */\n    require(_getKYCStatus(minter), \"Minter not KYC'd\");\n\n    /* Fail if mint not allowed */\n    uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n    if (allowed != 0) {\n      revert MintComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert MintFreshnessCheck();\n    }\n\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     *  We call `doTransferIn` for the minter and the mintAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n     *  side-effects occurred. The function returns the amount actually transferred,\n     *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n     *  of cash.\n     */\n    uint actualMintAmount = doTransferIn(minter, mintAmount);\n\n    /*\n     * We get the current exchange rate and calculate the number of cTokens to be minted:\n     *  mintTokens = actualMintAmount / exchangeRate\n     */\n\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n    /*\n     * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n     *  totalSupplyNew = totalSupply + mintTokens\n     *  accountTokensNew = accountTokens[minter] + mintTokens\n     * And write them into storage\n     */\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, actualMintAmount, mintTokens);\n    emit Transfer(address(this), minter, mintTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   */\n  function redeemInternal(uint redeemTokens) internal nonReentrant {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    redeemFresh(payable(msg.sender), redeemTokens, 0);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n   */\n  function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    redeemFresh(payable(msg.sender), 0, redeemAmount);\n  }\n\n  /**\n   * @notice User redeems cTokens in exchange for the underlying asset\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param redeemer The address of the account which is redeeming the tokens\n   * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   */\n  function redeemFresh(\n    address payable redeemer,\n    uint redeemTokensIn,\n    uint redeemAmountIn\n  ) internal {\n    /* Revert if redeemer not KYC'd */\n    require(_getKYCStatus(redeemer), \"Redeemer not KYC'd\");\n\n    require(\n      redeemTokensIn == 0 || redeemAmountIn == 0,\n      \"one of redeemTokensIn or redeemAmountIn must be zero\"\n    );\n\n    /* exchangeRate = invoke Exchange Rate Stored() */\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    uint redeemTokens;\n    uint redeemAmount;\n    /* If redeemTokensIn > 0: */\n    if (redeemTokensIn > 0) {\n      /*\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\n       *  redeemTokens = redeemTokensIn\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n       */\n      redeemTokens = redeemTokensIn;\n      redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n    } else {\n      /*\n       * We get the current exchange rate and calculate the amount to be redeemed:\n       *  redeemTokens = redeemAmountIn / exchangeRate\n       *  redeemAmount = redeemAmountIn\n       */\n      redeemTokens = div_(redeemAmountIn, exchangeRate);\n      redeemAmount = redeemAmountIn;\n    }\n\n    /* Fail if redeem not allowed */\n    uint allowed = comptroller.redeemAllowed(\n      address(this),\n      redeemer,\n      redeemTokens\n    );\n    if (allowed != 0) {\n      revert RedeemComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert RedeemFreshnessCheck();\n    }\n\n    /* Fail gracefully if protocol has insufficient cash */\n    if (getCashPrior() < redeemAmount) {\n      revert RedeemTransferOutNotPossible();\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We write the previously calculated values into storage.\n     *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\n     */\n    totalSupply = totalSupply - redeemTokens;\n    accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\n\n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(redeemer, redeemAmount);\n\n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), redeemTokens);\n    emit Redeem(redeemer, redeemAmount, redeemTokens);\n\n    /* We call the defense hook */\n    comptroller.redeemVerify(\n      address(this),\n      redeemer,\n      redeemAmount,\n      redeemTokens\n    );\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   */\n  function borrowInternal(uint borrowAmount) internal nonReentrant {\n    accrueInterest();\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\n    borrowFresh(payable(msg.sender), borrowAmount);\n  }\n\n  /**\n   * @notice Users borrow assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   */\n  function borrowFresh(address payable borrower, uint borrowAmount) internal {\n    /* Revert if borrower not KYC'd */\n    require(_getKYCStatus(borrower), \"Borrower not KYC'd\");\n\n    /* Fail if borrow not allowed */\n    uint allowed = comptroller.borrowAllowed(\n      address(this),\n      borrower,\n      borrowAmount\n    );\n    if (allowed != 0) {\n      revert BorrowComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert BorrowFreshnessCheck();\n    }\n\n    /* Fail gracefully if protocol has insufficient underlying cash */\n    if (getCashPrior() < borrowAmount) {\n      revert BorrowCashNotAvailable();\n    }\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on overflow:\n     *  accountBorrowNew = accountBorrow + borrowAmount\n     *  totalBorrowsNew = totalBorrows + borrowAmount\n     */\n    uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n    uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;\n    uint totalBorrowsNew = totalBorrows + borrowAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\n        `*/\n    accountBorrows[borrower].principal = accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = totalBorrowsNew;\n\n    /*\n     * We invoke doTransferOut for the borrower and the borrowAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken borrowAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(borrower, borrowAmount);\n\n    /* We emit a Borrow event */\n    emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   */\n  function repayBorrowInternal(uint repayAmount) internal nonReentrant {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   */\n  function repayBorrowBehalfInternal(\n    address borrower,\n    uint repayAmount\n  ) internal nonReentrant {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    repayBorrowFresh(msg.sender, borrower, repayAmount);\n  }\n\n  /**\n   * @notice Borrows are repaid by another user (possibly the borrower).\n   * @param payer the account paying off the borrow\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\n   * @return (uint) the actual repayment amount.\n   */\n  function repayBorrowFresh(\n    address payer,\n    address borrower,\n    uint repayAmount\n  ) internal returns (uint) {\n    /* Revert if not KYC'd */\n    require(_getKYCStatus(payer), \"Payer not KYC'd\");\n    require(_getKYCStatus(borrower), \"Borrower not KYC'd\");\n\n    /* Fail if repayBorrow not allowed */\n    uint allowed = comptroller.repayBorrowAllowed(\n      address(this),\n      payer,\n      borrower,\n      repayAmount\n    );\n    if (allowed != 0) {\n      revert RepayBorrowComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert RepayBorrowFreshnessCheck();\n    }\n\n    /* We fetch the amount the borrower owes, with accumulated interest */\n    uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n\n    /* If repayAmount == -1, repayAmount = accountBorrows */\n    uint repayAmountFinal = repayAmount == type(uint).max\n      ? accountBorrowsPrev\n      : repayAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the payer and the repayAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional repayAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *   it returns the amount actually transferred, in case of a fee.\n     */\n    uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on underflow:\n     *  accountBorrowsNew = accountBorrows - actualRepayAmount\n     *  totalBorrowsNew = totalBorrows - actualRepayAmount\n     */\n    uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\n    uint totalBorrowsNew = totalBorrows - actualRepayAmount;\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = totalBorrowsNew;\n\n    /* We emit a RepayBorrow event */\n    emit RepayBorrow(\n      payer,\n      borrower,\n      actualRepayAmount,\n      accountBorrowsNew,\n      totalBorrowsNew\n    );\n\n    return actualRepayAmount;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   */\n  function liquidateBorrowInternal(\n    address borrower,\n    uint repayAmount,\n    CTokenInterface cTokenCollateral\n  ) internal nonReentrant {\n    accrueInterest();\n\n    uint error = cTokenCollateral.accrueInterest();\n    if (error != NO_ERROR) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n      revert LiquidateAccrueCollateralInterestFailed(error);\n    }\n\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n    liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n  }\n\n  /**\n   * @notice The liquidator liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param liquidator The address repaying the borrow and seizing collateral\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   */\n  function liquidateBorrowFresh(\n    address liquidator,\n    address borrower,\n    uint repayAmount,\n    CTokenInterface cTokenCollateral\n  ) internal {\n    /* Fail if liquidate not allowed */\n    uint allowed = comptroller.liquidateBorrowAllowed(\n      address(this),\n      address(cTokenCollateral),\n      liquidator,\n      borrower,\n      repayAmount\n    );\n    if (allowed != 0) {\n      revert LiquidateComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert LiquidateFreshnessCheck();\n    }\n\n    /* Verify cTokenCollateral market's block number equals current block number */\n    if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n      revert LiquidateCollateralFreshnessCheck();\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      revert LiquidateLiquidatorIsBorrower();\n    }\n\n    /* Fail if repayAmount = 0 */\n    if (repayAmount == 0) {\n      revert LiquidateCloseAmountIsZero();\n    }\n\n    /* Fail if repayAmount = -1 */\n    if (repayAmount == type(uint).max) {\n      revert LiquidateCloseAmountIsUintMax();\n    }\n\n    /* Fail if repayBorrow fails */\n    uint actualRepayAmount = repayBorrowFresh(\n      liquidator,\n      borrower,\n      repayAmount\n    );\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We calculate the number of collateral tokens that will be seized */\n    (uint amountSeizeError, uint seizeTokens) = comptroller\n      .liquidateCalculateSeizeTokens(\n        address(this),\n        address(cTokenCollateral),\n        actualRepayAmount\n      );\n    require(\n      amountSeizeError == NO_ERROR,\n      \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\"\n    );\n\n    /* Revert if borrower collateral token balance < seizeTokens */\n    require(\n      cTokenCollateral.balanceOf(borrower) >= seizeTokens,\n      \"LIQUIDATE_SEIZE_TOO_MUCH\"\n    );\n\n    // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n    if (address(cTokenCollateral) ="
    }
  ]
}