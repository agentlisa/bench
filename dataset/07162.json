{
  "Title": "[06] Word/typing typos",
  "Content": "`ot` can be changed to `to` in the following comment.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/StrikeConversion.sol#L22\n\n```solidity\n    /// @param amount The amount ot be converted. Token0 amount when zeroToOne. Token1 amount when oneToZero.\n```\n\n`overidden` can be changed to `overridden` in the following comment.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L69\n\n```solidity\n    // Can be overidden for testing purposes.\n```\n\n`positionss` can be changed to `positions` in the following comment.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/interfaces/callbacks/ITimeswapV2PoolMintCallback.sol#L10\n\n```solidity\n    /// @dev The liquidity positionss will already be minted to the receipient.\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-library/src/StrikeConversion.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {FullMath} from \"./FullMath.sol\";\n\n/// @dev library for converting strike prices.\n/// @dev When strike is greater than uint128, the base token is denominated as token0 (which is the smaller address token).\n/// @dev When strike is uint128, the base token is denominated as token1 (which is the larger address).\nlibrary StrikeConversion {\n    /// @dev When zeroToOne, converts a number in multiple of strike.\n    /// @dev When oneToZero, converts a number in multiple of 1 / strike.\n    /// @param amount The amount to be converted.\n    /// @param strike The strike multiple conversion.\n    /// @param zeroToOne ZeroToOne if it is true. OneToZero if it is false.\n    /// @param roundUp Round up the result when true. Round down if false.\n    function convert(uint256 amount, uint256 strike, bool zeroToOne, bool roundUp) internal pure returns (uint256) {\n        return zeroToOne ? FullMath.mulDiv(amount, strike, uint256(1) << 128, roundUp) : FullMath.mulDiv(amount, uint256(1) << 128, strike, roundUp);\n    }\n\n    /// @dev When toOne, converts a base denomination to token1 denomination.\n    /// @dev When toZero, converts a base denomination to token0 denomination.\n    /// @param amount The amount ot be converted. Token0 amount when zeroToOne. Token1 amount when oneToZero.\n    /// @param strike The strike multiple conversion.\n    /// @param toOne ToOne if it is true, ToZero if it is false.\n    /// @param roundUp Round up the result when true. Round down if false.\n    function turn(uint256 amount, uint256 strike, bool toOne, bool roundUp) internal pure returns (uint256) {\n        return strike > type(uint128).max ? (toOne ? convert(amount, strike, true, roundUp) : amount) : (toOne ? amount : convert(amount, strike, false, roundUp));\n    }\n\n    /// @dev Combine and add token0Amount and token1Amount into base token amount.\n    /// @param amount0 The token0 amount to be combined.\n    /// @param amount1 The token1 amount to be combined.\n    /// @param strike The strike multiple conversion.\n    /// @param roundUp Round up the result when true. Round down if false.\n    function combine(uint256 amount0, uint256 amount1, uint256 strike, bool roundUp) internal pure returns (uint256) {\n        return strike > type(uint128).max ? amount0 + convert(amount1, strike, false, roundUp) : amount1 + convert(amount0, strike, true, roundUp);\n    }\n\n    /// @dev When zeroToOne, given a larger base amount, and token0 amount, get the difference token1 amount.\n    /// @dev When oneToZero, given a larger base amount, and toekn1 amount, get the difference token0 amount.\n    /// @param base The larger base amount.\n    /// @param amount The token0 amount when zeroToOne, the token1 amount when oneToZero.\n    /// @param strike The strike multiple conversion.\n    /// @param zeroToOne ZeroToOne if it is true. OneToZero if it is false.\n    /// @param roundUp Round up the result when true. Round down if false.\n    function dif(uint256 base, uint256 amount, uint256 strike, bool zeroToOne, bool roundUp) internal pure returns (uint256) {\n        return\n            strike > type(uint128).max\n                ? (zeroToOne ? convert(base - amount, strike, true, roundUp) : base - convert(amount, strike, false, !roundUp))\n                : (zeroToOne ? base - convert(amount, strike, true, !roundUp) : convert(base - amount, strike, false, roundUp));\n    }\n}"
    },
    {
      "filename": "packages/v2-option/src/TimeswapV2Option.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Option} from \"./interfaces/ITimeswapV2Option.sol\";\nimport {ITimeswapV2OptionDeployer} from \"./interfaces/ITimeswapV2OptionDeployer.sol\";\nimport {ITimeswapV2OptionMintCallback} from \"./interfaces/callbacks/ITimeswapV2OptionMintCallback.sol\";\nimport {ITimeswapV2OptionBurnCallback} from \"./interfaces/callbacks/ITimeswapV2OptionBurnCallback.sol\";\nimport {ITimeswapV2OptionSwapCallback} from \"./interfaces/callbacks/ITimeswapV2OptionSwapCallback.sol\";\nimport {ITimeswapV2OptionCollectCallback} from \"./interfaces/callbacks/ITimeswapV2OptionCollectCallback.sol\";\n\nimport {Option, OptionLibrary} from \"./structs/Option.sol\";\nimport {Process, ProcessLibrary} from \"./structs/Process.sol\";\nimport {StrikeAndMaturity} from \"./structs/StrikeAndMaturity.sol\";\n\nimport {TimeswapV2OptionPosition, PositionLibrary} from \"./enums/Position.sol\";\nimport {TimeswapV2OptionMint, TimeswapV2OptionBurn, TimeswapV2OptionSwap, TimeswapV2OptionCollect, TransactionLibrary} from \"./enums/Transaction.sol\";\n\nimport {TimeswapV2OptionMintParam, TimeswapV2OptionBurnParam, TimeswapV2OptionSwapParam, TimeswapV2OptionCollectParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2OptionMintCallbackParam, TimeswapV2OptionBurnCallbackParam, TimeswapV2OptionSwapCallbackParam, TimeswapV2OptionCollectCallbackParam} from \"./structs/CallbackParam.sol\";\n\n/// @title Timeswap V2 Options for a given pair\n/// @author Timeswap Labs\n/// @notice Holds the option of all strikes and maturies.\ncontract TimeswapV2Option is ITimeswapV2Option, NoDelegateCall {\n    using OptionLibrary for Option;\n    using ProcessLibrary for Process[];\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override optionFactory;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token0;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token1;\n\n    /// @dev mapping of all option state for all strikes and maturies.\n    mapping(uint256 => mapping(uint256 => Option)) private options;\n    /// @dev Always start and end as an empty array for every transaction.\n    /// Process the token requirement for every option interaction call.\n    Process[] private processing;\n\n    mapping(uint256 => mapping(uint256 => bool)) private hasInteracted;\n    StrikeAndMaturity[] private listOfOptions;\n\n    function addOptionEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (!hasInteracted[strike][maturity]) {\n            hasInteracted[strike][maturity] = true;\n            listOfOptions.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (optionFactory, token0, token1) = ITimeswapV2OptionDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp() internal view virtual returns (uint96) {\n        return uint96(block.timestamp); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfOptions[id];\n    }\n\n    function numberOfOptions() external view override returns (uint256) {\n        return listOfOptions.length;\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function totalPosition(uint256 strike, uint256 maturity, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].totalPosition(strike, position);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function positionOf(uint256 strike, uint256 maturity, address owner, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].positionOf(owner, position);\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    function transferPosition(uint256 strike, uint256 maturity, address to, TimeswapV2OptionPosition position, uint256 amount) external override {\n        if (!hasInteracted[strike][maturity]) Error.inactiveOptionChoice(strike, maturity);\n        if (to == address(0)) Error.zeroAddress();\n        if (amount == 0) Error.zeroInput();\n        PositionLibrary.check(position);\n\n        options[strike][maturity].transferPosition(to, position, amount);\n\n        emit TransferPosition(strike, maturity, msg.sender, to, position, amount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function mint(\n        TimeswapV2OptionMintParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        ParamLibrary.check(param, blockTimestamp());\n        addOptionEnumerationIfNecessary(param.strike, param.maturity);\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main mint logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.mint(param.strike, param.long0To, param.long1To, param.shortTo, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, true, true);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount\n        ));\n\n        // ask the msg.sender to transfer token0 and/or token1 to this contract.\n        data = ITimeswapV2OptionMintCallback(msg.sender).timeswapV2OptionMintCallback(\n            TimeswapV2OptionMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                shortAmount: shortAmount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 balance target is achieved.\n        if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n\n        // check if the token1 balance target is achieved.\n        if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n\n        // finish the process.\n        processing.pop();\n\n        emit Mint(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function burn(\n        TimeswapV2OptionBurnParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main burn logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.burn(param.strike, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0AndLong0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0AndLong0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1AndLong1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1AndLong1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionBurnCallback(msg.sender).timeswapV2OptionBurnCallback(\n                TimeswapV2OptionBurnCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0AndLong0Amount: token0AndLong0Amount,\n                    token1AndLong1Amount: token1AndLong1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.long0[msg.sender] -= token0AndLong0Amount;\n        option.long1[msg.sender] -= token1AndLong1Amount;\n        option.short[msg.sender] -= shortAmount;\n\n        emit Burn(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function swap(TimeswapV2OptionSwapParam calldata param) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main swap logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount) = option.swap(param.strike, param.longTo, param.isLong0ToLong1, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, !param.isLong0ToLong1, param.isLong0ToLong1);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            param.isLong0ToLong1 ? IERC20(token0).balanceOf(address(this)) - token0AndLong0Amount : IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            param.isLong0ToLong1 ? IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount : IERC20(token1).balanceOf(address(this)) - token1AndLong1Amount\n        ));\n\n        // transfer token to recipient.\n        IERC20(param.isLong0ToLong1 ? token0 : token1).safeTransfer(param.tokenTo, param.isLong0ToLong1 ? token0AndLong0Amount : token1AndLong1Amount);\n\n        // ask the msg.sender to transfer token0 or token1 to this contract.\n        data = ITimeswapV2OptionSwapCallback(msg.sender).timeswapV2OptionSwapCallback(\n            TimeswapV2OptionSwapCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                isLong0ToLong1: param.isLong0ToLong1,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 or token1 balance target is achieved.\n        Error.checkEnough(IERC20(param.isLong0ToLong1 ? token1 : token0).balanceOf(address(this)), param.isLong0ToLong1 ? currentProcess.balance1Target : currentProcess.balance0Target);\n\n        if (param.isLong0ToLong1) option.long0[msg.sender] -= token0AndLong0Amount;\n        else option.long1[msg.sender] -= token1AndLong1Amount;\n\n        // finish the process.\n        processing.pop();\n\n        emit Swap(param.strike, param.maturity, msg.sender, param.tokenTo, param.longTo, param.isLong0ToLong1, token0AndLong0Amount, token1AndLong1Amount);\n    }\n\n    function collect(TimeswapV2OptionCollectParam calldata param) external override noDelegateCall returns (uint256 token0Amount, uint256 token1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main collect logic calculation\n        (token0Amount, token1Amount, shortAmount) = option.collect(param.strike, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0Amount, token1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionCollectCallback(msg.sender).timeswapV2OptionCollectCallback(\n                TimeswapV2OptionCollectCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0Amount: token0Amount,\n                    token1Amount: token1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.short[msg.sender] -= shortAmount;\n\n        emit Collect(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0Amount, token1Amount, shortAmount);\n    }\n}"
    },
    {
      "filename": "packages/v2-pool/src/interfaces/callbacks/ITimeswapV2PoolMintCallback.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolMintCallbackParam} from \"../../structs/CallbackParam.sol\";\n\n/// @dev The interface that needs to be implemented by a contract calling the mint function.\ninterface ITimeswapV2PoolMintCallback {\n    /// @dev Returns the amount of long0 position and long1 positions chosen to be deposited to the pool.\n    /// @notice The StrikeConversion.combine of long0 position and long1 position must be greater than or equal to long amount.\n    /// @dev The liquidity positionss will already be minted to the receipient.\n    /// @return long0Amount Amount of long0 position to be deposited.\n    /// @return long1Amount Amount of long1 position to be deposited.\n    /// @param data The bytes of data to be sent to msg.sender.\n    function timeswapV2PoolMintChoiceCallback(TimeswapV2PoolMintChoiceCallbackParam calldata param) external returns (uint256 long0Amount, uint256 long1Amount, bytes memory data);\n\n    /// @dev Require the transfer of long0 position, long1 position, and short position into the pool.\n    /// @param data The bytes of data to be sent to msg.sender.\n    function timeswapV2PoolMintCallback(TimeswapV2PoolMintCallbackParam calldata param) external returns (bytes memory data);\n}"
    }
  ]
}