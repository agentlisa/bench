{
  "Title": "Empty trades",
  "Content": "##### Description\nThe trade function allows you to specify a price limit, upon reaching which the cycle will be exited without performing any movement of tokens at line\nhttps://github.com/DivergenceProtocol/diver-contracts/blob/29a0ccb5fc7ac838bd44c75c0afc398b84be267a/src/core/Battle.sol#L286, \nbut with a change of the current price at line \nhttps://github.com/DivergenceProtocol/diver-contracts/blob/29a0ccb5fc7ac838bd44c75c0afc398b84be267a/src/core/Battle.sol#L359.\n \nAn attacker creates a contract that calls the trade function of the Battle contract with a price limit. To get passed the balance check, the attacker sends one token to the contract inside tradeCallback.\n\nThis ability to perform empty exchanges in empty areas of liquidity creates the possibility of price manipulation. This capability can be used by an attacker to attack liquidity providers in order to block the addition of liquidity. \n\nhttps://github.com/DivergenceProtocol/diver-contracts/blob/29a0ccb5fc7ac838bd44c75c0afc398b84be267a/src/periphery/base/LiquidityManagement.sol#L43\n\nTo resolve this, it is necessary to resort to non-standard actions, for example, adding liquidity over the entire tick interval.\n\nThis error is marked as HIGH as the contract is blocked by the attacker.\n\n##### Recommendation\nWe recommend following one of the next ways:\n\n1) Revert empty trades\n2) Add function initAddLIquidity that moves price to the right place and then call the addLiquidity function\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/Battle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport { SafeERC20 } from \"@oz/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@oz/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@oz/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\nimport { FullMath } from \"@uniswap/v3-core/contracts/libraries/FullMath.sol\";\nimport { TickBitmap } from \"@uniswap/v3-core/contracts/libraries/TickBitmap.sol\";\nimport { SqrtPriceMath } from \"@uniswap/v3-core/contracts/libraries/SqrtPriceMath.sol\";\nimport { FixedPoint128 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport { Errors } from \"core/errors/Errors.sol\";\nimport { IBattle } from \"core/interfaces/battle/IBattle.sol\";\nimport { IOracle } from \"core/interfaces/IOracle.sol\";\nimport { IBattleBase } from \"core/interfaces/battle/IBattleActions.sol\";\nimport { IBattleState } from \"core/interfaces/battle/IBattleState.sol\";\nimport { IBattleInit } from \"core/interfaces/battle/IBattleInit.sol\";\nimport { IMintCallback } from \"core/interfaces/callback/IMintCallback.sol\";\nimport { IBattleMintBurn } from \"core/interfaces/battle/IBattleActions.sol\";\nimport { ISToken } from \"core/interfaces/ISToken.sol\";\nimport { IOwner } from \"core/interfaces/IOwner.sol\";\nimport { ITradeCallback } from \"core/interfaces/callback/ITradeCallback.sol\";\nimport { IArenaState } from \"core/interfaces/IArena.sol\";\nimport { TickMath } from \"core/libs/TickMath.sol\";\nimport { Tick } from \"core/libs/Tick.sol\";\nimport { Position } from \"core/libs/Position.sol\";\nimport { DiverSqrtPriceMath } from \"core/libs/DiverSqrtPriceMath.sol\";\nimport { TradeMath } from \"core/libs/TradeMath.sol\";\nimport { TradeCache, TradeState, StepComputations } from \"./types/TradeTypes.sol\";\nimport { LiquidityType, BattleKey, Outcome, GrowthX128, TickInfo, PositionInfo, Fee, TradeType } from \"./types/common.sol\";\nimport {\n    ModifyPositionParams,\n    BattleMintParams,\n    BattleBurnParams,\n    BattleTradeParams,\n    ComputeTradeStepParams,\n    DeploymentParams,\n    UpdatePositionParams\n} from \"core/params/coreParams.sol\";\n\n/// @title Battle\ncontract Battle is IBattle {\n    using Tick for mapping(int24 => TickInfo);\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => PositionInfo);\n    using Position for PositionInfo;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    struct Slot0 {\n        uint160 sqrtPriceX96;\n        int24 tick;\n        bool unlocked;\n    }\n\n    address public override manager;\n    address public arena;\n    address public oracle;\n    address public override spear;\n    address public override shield;\n    address public cOracle;\n\n    uint256 public unit;\n    uint256 public startTS;\n    uint128 public liquidity;\n    uint128 public maxLiquidityPerTick;\n    uint128 public protocolFeeAmount;\n\n    Fee public override fee;\n\n    BattleKey private _bk;\n    GrowthX128 public global;\n    Slot0 public override slot0;\n    Outcome public override battleOutcome;\n\n    mapping(int24 => TickInfo) public ticks;\n    mapping(int16 => uint256) public tickBitmap;\n    mapping(bytes32 => PositionInfo) private _positions;\n\n    modifier lock() {\n        if (!slot0.unlocked) {\n            revert Errors.Locked();\n        }\n        slot0.unlocked = false;\n        _;\n        slot0.unlocked = true;\n    }\n\n    modifier onlyManager() {\n        if (msg.sender != manager) {\n            revert Errors.OnlyManager();\n        }\n        _;\n    }\n\n    /// @notice init storage state variable, only be caled once\n    function init(DeploymentParams memory params) external override {\n        if (_bk.expiries != 0) {\n            revert Errors.InitTwice();\n        }\n        if (slot0.sqrtPriceX96 != 0) {\n            revert Errors.InitTwice();\n        }\n        _bk = params.battleKey;\n        unit = 10 ** IERC20Metadata(_bk.collateral).decimals();\n        oracle = params.oracleAddr;\n        cOracle = params.cOracleAddr;\n        startTS = block.timestamp;\n        fee = params.fee;\n        spear = params.spear;\n        shield = params.shield;\n        manager = params.manager;\n        arena = address(msg.sender);\n        slot0 = Slot0({ sqrtPriceX96: params.sqrtPriceX96, tick: TickMath.getTickAtSqrtRatio(params.sqrtPriceX96), unlocked: true });\n        maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(30);\n    }\n\n    function _updatePosition(UpdatePositionParams memory params) internal returns (PositionInfo storage position) {\n        position = _positions.get(msg.sender, params.mpParams.tickLower, params.mpParams.tickUpper);\n        GrowthX128 memory _global = global;\n\n        bool flippedLower;\n        bool flippedUpper;\n        if (params.mpParams.liquidityDelta != 0) {\n            flippedLower = ticks.update(params.mpParams.tickLower, params.tick, params.mpParams.liquidityDelta, _global, maxLiquidityPerTick, false);\n\n            flippedUpper = ticks.update(params.mpParams.tickUpper, params.tick, params.mpParams.liquidityDelta, _global, maxLiquidityPerTick, true);\n\n            if (flippedLower) {\n                tickBitmap.flipTick(params.mpParams.tickLower, 30);\n            }\n            if (flippedUpper) {\n                tickBitmap.flipTick(params.mpParams.tickUpper, 30);\n            }\n        }\n        GrowthX128 memory insideLast = ticks.getGrowthInside(params.mpParams.tickLower, params.mpParams.tickUpper, params.tick, _global);\n        position.update(params.mpParams.liquidityDelta, insideLast);\n        if (params.mpParams.liquidityDelta < 0) {\n            if (flippedLower) {\n                ticks.clear(params.mpParams.tickLower);\n            }\n            if (flippedUpper) {\n                ticks.clear(params.mpParams.tickUpper);\n            }\n        }\n    }\n\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n        if (tickLower >= tickUpper) revert Errors.TickInvalid();\n        if (tickLower < TickMath.MIN_TICK) revert Errors.TickInvalid();\n        if (tickUpper > TickMath.MAX_TICK) revert Errors.TickInvalid();\n    }\n\n    function _modifyPosition(ModifyPositionParams memory params) internal returns (PositionInfo storage position) {\n        checkTicks(params.tickLower, params.tickUpper);\n        position = _updatePosition(UpdatePositionParams(params, slot0.tick));\n        if (params.liquidityDelta > 0) {\n            if (slot0.tick >= params.tickLower && slot0.tick < params.tickUpper) {\n                liquidity += uint128(params.liquidityDelta);\n            }\n        } else if (params.liquidityDelta < 0) {\n            if (slot0.tick >= params.tickLower && slot0.tick < params.tickUpper) {\n                liquidity -= uint128(-params.liquidityDelta);\n            }\n        }\n    }\n\n    /// @inheritdoc IBattleMintBurn\n    function mint(BattleMintParams memory params) external override lock onlyManager {\n        if (block.timestamp >= _bk.expiries) {\n            revert Errors.BattleEnd();\n        }\n\n        if (params.liquidityType == LiquidityType.SPEAR && !(slot0.tick > params.tickUpper)) {\n            revert Errors.TickInvalid();\n        }\n\n        if (params.liquidityType == LiquidityType.SHIELD && !(slot0.tick < params.tickLower)) {\n            revert Errors.TickInvalid();\n        }\n        if (params.amount == 0) {\n            revert Errors.ZeroValue();\n        }\n\n        PositionInfo storage positionInfo;\n        positionInfo = _modifyPosition(\n            ModifyPositionParams({\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                liquidityType: params.liquidityType,\n                liquidityDelta: int128(params.amount)\n            })\n        );\n\n        if (params.liquidityType == LiquidityType.COLLATERAL) {\n            uint256 balanceBefore = IERC20(_bk.collateral).balanceOf(address(this));\n            IMintCallback(msg.sender).mintCallback(params.seed, params.data);\n            if (IERC20(_bk.collateral).balanceOf(address(this)) < balanceBefore + params.seed) {\n                revert Errors.InsufficientCollateral();\n            }\n        } else if (params.liquidityType == LiquidityType.SPEAR) {\n            uint256 balanceBefore = IERC20(spear).balanceOf(address(this));\n            IMintCallback(msg.sender).mintCallback(params.seed, params.data);\n            if (IERC20(spear).balanceOf(address(this)) < balanceBefore + params.seed) {\n                revert Errors.InsufficientSpear();\n            }\n            ISToken(spear).burn(address(this), params.seed);\n        } else {\n            uint256 balanceBefore = IERC20(shield).balanceOf(address(this));\n            IMintCallback(msg.sender).mintCallback(params.seed, params.data);\n            if (IERC20(shield).balanceOf(address(this)) < balanceBefore + params.seed) {\n                revert Errors.InsufficientShield();\n            }\n            ISToken(shield).burn(address(this), params.seed);\n        }\n\n        emit Minted(msg.sender, params.liquidityType, params.tickLower, params.tickUpper, params.amount, params.seed);\n    }\n\n    /// @inheritdoc IBattleMintBurn\n    function burn(BattleBurnParams memory params) external override lock onlyManager {\n        if (params.tickLower >= params.tickUpper) {\n            revert Errors.TickOrderInvalid();\n        }\n        _modifyPosition(\n            ModifyPositionParams({\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                liquidityType: params.liquidityType,\n                liquidityDelta: -int128(params.liquidityAmount)\n            })\n        );\n        emit Burned(params.tickLower, params.tickUpper, params.liquidityType, params.liquidityAmount);\n    }\n\n    /// comments see IBattleTrade\n    function collect(address recipient, uint256 cAmount, uint256 spAmount, uint256 shAmount) external override onlyManager {\n        if (cAmount > 0) {\n            IERC20(_bk.collateral).safeTransfer(recipient, cAmount);\n        }\n        if (spAmount > 0) {\n            ISToken(spear).mint(recipient, spAmount);\n        }\n        if (shAmount > 0) {\n            ISToken(shield).mint(recipient, shAmount);\n        }\n    }\n\n    function trade(BattleTradeParams memory params) external returns (uint256 cAmount, uint256 sAmount, uint256 fAmount) {\n        if (block.timestamp >= _bk.expiries) {\n            revert Errors.BattleEnd();\n        }\n        if (params.amountSpecified == 0) {\n            revert Errors.ZeroValue();\n        }\n\n        Slot0 memory slot0Start = slot0;\n\n        if (!slot0Start.unlocked) {\n            revert Errors.Locked();\n        }\n\n        bool isPriceDown = params.tradeType == TradeType.BUY_SPEAR;\n        bool exactIn = params.amountSpecified > 0;\n        require(\n            isPriceDown\n                ? params.sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && params.sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO\n                : params.sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && params.sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,\n            \"PriceInvalid\"\n        );\n        slot0.unlocked = false;\n\n        TradeCache memory cache = TradeCache({ feeProtocol: fee.protocolFee });\n        TradeState memory state = TradeState({\n            amountSpecifiedRemaining: params.amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\n            tick: slot0Start.tick,\n            global: global,\n            protocolFee: 0,\n            liquidity: liquidity,\n            transactionFee: 0\n        });\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != params.sqrtPriceLimitX96) {\n            StepComputations memory step;\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(state.tick, 30, isPriceDown);\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            }\n            if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n            (state.sqrtPriceX96, step.amountIn, step.amountOut) = TradeMath.computeTradeStep(\n                ComputeTradeStepParams({\n                    tradeType: params.tradeType,\n                    sqrtRatioCurrentX96: state.sqrtPriceX96,\n                    sqrtRatioTargetX96: (\n                        isPriceDown ? step.sqrtPriceNextX96 < params.sqrtPriceLimitX96 : step.sqrtPriceNextX96 > params.sqrtPriceLimitX96\n                        ) ? params.sqrtPriceLimitX96 : step.sqrtPriceNextX96,\n                    liquidity: state.liquidity,\n                    amountRemaining: state.amountSpecifiedRemaining,\n                    unit: unit\n                })\n            );\n            if (exactIn) {\n                state.amountSpecifiedRemaining -= (step.amountIn).toInt256();\n                state.amountCalculated += (step.amountOut).toInt256();\n            } else {\n                state.amountSpecifiedRemaining += (step.amountOut).toInt256();\n                state.amountCalculated += (step.amountIn).toInt256();\n            }\n\n            step.feeAmount = FullMath.mulDiv(step.amountOut, fee.transactionFee, 1e6);\n            if (cache.feeProtocol > 0) {\n                uint256 delta = FullMath.mulDiv(step.feeAmount, cache.feeProtocol, 1e6);\n                step.feeAmount -= delta;\n                state.protocolFee += uint128(delta);\n            }\n\n            if (state.liquidity > 0) {\n                unchecked {\n                    state.global.fee += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);\n                    state.transactionFee += step.feeAmount;\n                    state.global.collateralIn += FullMath.mulDiv(step.amountIn, FixedPoint128.Q128, state.liquidity);\n\n                    if (params.tradeType == TradeType.BUY_SPEAR) {\n                        // buy spear => spearBought and shieldBankOut need be\n                        // considered\n                        // spear bought\n                        state.global.spearOut += FullMath.mulDiv(step.amountOut, FixedPoint128.Q128, state.liquidity);\n                    } else {\n                        // buy shield => shieldBought and spearBankOut need be\n                        // considered\n                        state.global.shieldOut += FullMath.mulDiv(step.amountOut, FixedPoint128.Q128, state.liquidity);\n                    }\n                }\n            }\n\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                if (step.initialized) {\n                    int128 liquidityNet = ticks.cross(step.tickNext, state.global);\n                    if (isPriceDown) {\n                        liquidityNet = -liquidityNet;\n                    }\n                    state.liquidity = liquidityNet < 0 ? state.liquidity - uint128(-liquidityNet) : state.liquidity + uint128(liquidityNet);\n                }\n                state.tick = isPriceDown ? step.tickNext - 1 : step.tickNext;\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n        }\n\n        if (state.tick != slot0Start.tick) {\n            (slot0.sqrtPriceX96, slot0.tick) = (state.sqrtPriceX96, state.tick);\n        } else {\n            slot0.sqrtPriceX96 = state.sqrtPriceX96;\n        }\n        liquidity = state.liquidity;\n        global = state.global;\n        if (exactIn) {\n            cAmount = uint256(params.amountSpecified) - uint256(state.amountSpecifiedRemaining) + state.transactionFee + state.protocolFee;\n            sAmount = uint256(state.amountCalculated);\n        } else {\n            cAmount = uint256(state.amountCalculated) + state.transactionFee + state.protocolFee;\n            sAmount = uint256(-(params.amountSpecified - state.amountSpecifiedRemaining));\n        }\n        if (state.protocolFee > 0) {\n            protocolFeeAmount += state.protocolFee;\n        }\n        fAmount = state.transactionFee + state.protocolFee;\n\n        uint256 colBalanceBefore = collateralBalance();\n        ITradeCallback(msg.sender).tradeCallback(cAmount, sAmount, params.data);\n        if (colBalanceBefore + cAmount > collateralBalance()) {\n            revert Errors.InsufficientCollateral();\n        }\n\n        if (params.tradeType == TradeType.BUY_SPEAR) {\n            // mint spear to user\n            ISToken(spear).mint(params.recipient, sAmount);\n        } else {\n            // mint shield to user\n            ISToken(shield).mint(params.recipient, sAmount);\n        }\n        emit Traded(params.recipient, state.liquidity, cAmount, sAmount, params.tradeType, state.sqrtPriceX96, state.tick);\n        slot0.unlocked = true;\n    }\n\n    /// @inheritdoc IBattleBase\n    function settle() external override {\n        if (block.timestamp < _bk.expiries) {\n            revert Errors.BattleNotEnd();\n        }\n        if (battleOutcome != Outcome.ONGOING) {\n            revert Errors.BattleSettled();\n        }\n        (uint256 price,) = IOracle(oracle).getPriceByExternal(cOracle, _bk.expiries);\n        if (price == 0) {\n            revert Errors.OraclePriceError();\n        }\n        if (price >= _bk.strikeValue) {\n            battleOutcome = Outcome.SPEAR_WIN;\n        } else {\n            battleOutcome = Outcome.SHIELD_WIN;\n        }\n        emit Settled(msg.sender, battleOutcome);\n    }\n\n    /// @inheritdoc IBattleBase\n    function exercise() external override lock {\n        if (battleOutcome == Outcome.ONGOING) {\n            revert Errors.BattleNotEnd();\n        }\n        uint256 amount;\n        bool wasSpearWon = battleOutcome == Outcome.SPEAR_WIN;\n        if (wasSpearWon) {\n            amount = IERC20(spear).balanceOf(msg.sender);\n        } else {\n            amount = IERC20(shield).balanceOf(msg.sender);\n        }\n        if (amount > 0) {\n            if (wasSpearWon) {\n                ISToken(spear).burn(msg.sender, amount);\n            } else {\n                ISToken(shield).burn(msg.sender, amount);\n            }\n            uint256 exerciseFeeAmount = FullMath.mulDiv(amount, fee.exerciseFee, 1e6);\n            if (exerciseFeeAmount > 0) {\n                amount -= exerciseFeeAmount;\n                protocolFeeAmount += uint128(exerciseFeeAmount);\n            }\n            IERC20(_bk.collateral).safeTransfer(msg.sender, amount);\n            emit Exercised(msg.sender, wasSpearWon, amount);\n        }\n    }\n\n    /// @inheritdoc IBattleBase\n    function withdrawObligation(address recipient, uint256 amount) external override onlyManager lock {\n        IERC20(_bk.collateral).safeTransfer(recipient, amount);\n        emit ObligationWithdrawed(recipient, amount);\n    }\n\n    /// comments see IBattleTrade\n    function collectProtocolFee(address recipient) external override lock {\n        if (IOwner(arena).owner() != msg.sender) {\n            revert Errors.OnlyOwner();\n        }\n        uint256 _fee = protocolFeeAmount;\n        protocolFeeAmount = 0;\n        IERC20(_bk.collateral).safeTransfer(recipient, _fee);\n        emit ProtocolFeeCollected(recipient, _fee);\n    }\n\n    function collateralBalance() private view returns (uint256) {\n        return IERC20(_bk.collateral).balanceOf(address(this));\n    }\n\n    function positions(bytes32 positionKeyB32) external view override returns (PositionInfo memory info) {\n        info = _positions[positionKeyB32];\n    }\n\n    function battleKey() external view override returns (BattleKey memory) {\n        return _bk;\n    }\n\n    function startAndEndTS() external view override returns (uint256, uint256) {\n        return (startTS, _bk.expiries);\n    }\n\n    function spearBalanceOf(address account) external view override returns (uint256 amount) {\n        amount = IERC20(spear).balanceOf(account);\n    }\n\n    function shieldBalanceOf(address account) external view override returns (uint256 amount) {\n        amount = IERC20(shield).balanceOf(account);\n    }\n\n    function spearAndShield() external view override returns (address, address) {\n        return (spear, shield);\n    }\n\n    function getInsideLast(int24 tickLower, int24 tickUpper) external view override returns (GrowthX128 memory) {\n        return ticks.getGrowthInside(tickLower, tickUpper, slot0.tick, global);\n    }\n}"
    },
    {
      "filename": "src/core/Battle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport { SafeERC20 } from \"@oz/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@oz/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@oz/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\nimport { FullMath } from \"@uniswap/v3-core/contracts/libraries/FullMath.sol\";\nimport { TickBitmap } from \"@uniswap/v3-core/contracts/libraries/TickBitmap.sol\";\nimport { SqrtPriceMath } from \"@uniswap/v3-core/contracts/libraries/SqrtPriceMath.sol\";\nimport { FixedPoint128 } from \"@uniswap/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport { Errors } from \"core/errors/Errors.sol\";\nimport { IBattle } from \"core/interfaces/battle/IBattle.sol\";\nimport { IOracle } from \"core/interfaces/IOracle.sol\";\nimport { IBattleBase } from \"core/interfaces/battle/IBattleActions.sol\";\nimport { IBattleState } from \"core/interfaces/battle/IBattleState.sol\";\nimport { IBattleInit } from \"core/interfaces/battle/IBattleInit.sol\";\nimport { IMintCallback } from \"core/interfaces/callback/IMintCallback.sol\";\nimport { IBattleMintBurn } from \"core/interfaces/battle/IBattleActions.sol\";\nimport { ISToken } from \"core/interfaces/ISToken.sol\";\nimport { IOwner } from \"core/interfaces/IOwner.sol\";\nimport { ITradeCallback } from \"core/interfaces/callback/ITradeCallback.sol\";\nimport { IArenaState } from \"core/interfaces/IArena.sol\";\nimport { TickMath } from \"core/libs/TickMath.sol\";\nimport { Tick } from \"core/libs/Tick.sol\";\nimport { Position } from \"core/libs/Position.sol\";\nimport { DiverSqrtPriceMath } from \"core/libs/DiverSqrtPriceMath.sol\";\nimport { TradeMath } from \"core/libs/TradeMath.sol\";\nimport { TradeCache, TradeState, StepComputations } from \"./types/TradeTypes.sol\";\nimport { LiquidityType, BattleKey, Outcome, GrowthX128, TickInfo, PositionInfo, Fee, TradeType } from \"./types/common.sol\";\nimport {\n    ModifyPositionParams,\n    BattleMintParams,\n    BattleBurnParams,\n    BattleTradeParams,\n    ComputeTradeStepParams,\n    DeploymentParams,\n    UpdatePositionParams\n} from \"core/params/coreParams.sol\";\n\n/// @title Battle\ncontract Battle is IBattle {\n    using Tick for mapping(int24 => TickInfo);\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => PositionInfo);\n    using Position for PositionInfo;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    struct Slot0 {\n        uint160 sqrtPriceX96;\n        int24 tick;\n        bool unlocked;\n    }\n\n    address public override manager;\n    address public arena;\n    address public oracle;\n    address public override spear;\n    address public override shield;\n    address public cOracle;\n\n    uint256 public unit;\n    uint256 public startTS;\n    uint128 public liquidity;\n    uint128 public maxLiquidityPerTick;\n    uint128 public protocolFeeAmount;\n\n    Fee public override fee;\n\n    BattleKey private _bk;\n    GrowthX128 public global;\n    Slot0 public override slot0;\n    Outcome public override battleOutcome;\n\n    mapping(int24 => TickInfo) public ticks;\n    mapping(int16 => uint256) public tickBitmap;\n    mapping(bytes32 => PositionInfo) private _positions;\n\n    modifier lock() {\n        if (!slot0.unlocked) {\n            revert Errors.Locked();\n        }\n        slot0.unlocked = false;\n        _;\n        slot0.unlocked = true;\n    }\n\n    modifier onlyManager() {\n        if (msg.sender != manager) {\n            revert Errors.OnlyManager();\n        }\n        _;\n    }\n\n    /// @notice init storage state variable, only be caled once\n    function init(DeploymentParams memory params) external override {\n        if (_bk.expiries != 0) {\n            revert Errors.InitTwice();\n        }\n        if (slot0.sqrtPriceX96 != 0) {\n            revert Errors.InitTwice();\n        }\n        _bk = params.battleKey;\n        unit = 10 ** IERC20Metadata(_bk.collateral).decimals();\n        oracle = params.oracleAddr;\n        cOracle = params.cOracleAddr;\n        startTS = block.timestamp;\n        fee = params.fee;\n        spear = params.spear;\n        shield = params.shield;\n        manager = params.manager;\n        arena = address(msg.sender);\n        slot0 = Slot0({ sqrtPriceX96: params.sqrtPriceX96, tick: TickMath.getTickAtSqrtRatio(params.sqrtPriceX96), unlocked: true });\n        maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(30);\n    }\n\n    function _updatePosition(UpdatePositionParams memory params) internal returns (PositionInfo storage position) {\n        position = _positions.get(msg.sender, params.mpParams.tickLower, params.mpParams.tickUpper);\n        GrowthX128 memory _global = global;\n\n        bool flippedLower;\n        bool flippedUpper;\n        if (params.mpParams.liquidityDelta != 0) {\n            flippedLower = ticks.update(params.mpParams.tickLower, params.tick, params.mpParams.liquidityDelta, _global, maxLiquidityPerTick, false);\n\n            flippedUpper = ticks.update(params.mpParams.tickUpper, params.tick, params.mpParams.liquidityDelta, _global, maxLiquidityPerTick, true);\n\n            if (flippedLower) {\n                tickBitmap.flipTick(params.mpParams.tickLower, 30);\n            }\n            if (flippedUpper) {\n                tickBitmap.flipTick(params.mpParams.tickUpper, 30);\n            }\n        }\n        GrowthX128 memory insideLast = ticks.getGrowthInside(params.mpParams.tickLower, params.mpParams.tickUpper, params.tick, _global);\n        position.update(params.mpParams.liquidityDelta, insideLast);\n        if (params.mpParams.liquidityDelta < 0) {\n            if (flippedLower) {\n                ticks.clear(params.mpParams.tickLower);\n            }\n            if (flippedUpper) {\n                ticks.clear(params.mpParams.tickUpper);\n            }\n        }\n    }\n\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n        if (tickLower >= tickUpper) revert Errors.TickInvalid();\n        if (tickLower < TickMath.MIN_TICK) revert Errors.TickInvalid();\n        if (tickUpper > TickMath.MAX_TICK) revert Errors.TickInvalid();\n    }\n\n    function _modifyPosition(ModifyPositionParams memory params) internal returns (PositionInfo storage position) {\n        checkTicks(params.tickLower, params.tickUpper);\n        position = _updatePosition(UpdatePositionParams(params, slot0.tick));\n        if (params.liquidityDelta > 0) {\n            if (slot0.tick >= params.tickLower && slot0.tick < params.tickUpper) {\n                liquidity += uint128(params.liquidityDelta);\n            }\n        } else if (params.liquidityDelta < 0) {\n            if (slot0.tick >= params.tickLower && slot0.tick < params.tickUpper) {\n                liquidity -= uint128(-params.liquidityDelta);\n            }\n        }\n    }\n\n    /// @inheritdoc IBattleMintBurn\n    function mint(BattleMintParams memory params) external override lock onlyManager {\n        if (block.timestamp >= _bk.expiries) {\n            revert Errors.BattleEnd();\n        }\n\n        if (params.liquidityType == LiquidityType.SPEAR && !(slot0.tick > params.tickUpper)) {\n            revert Errors.TickInvalid();\n        }\n\n        if (params.liquidityType == LiquidityType.SHIELD && !(slot0.tick < params.tickLower)) {\n            revert Errors.TickInvalid();\n        }\n        if (params.amount == 0) {\n            revert Errors.ZeroValue();\n        }\n\n        PositionInfo storage positionInfo;\n        positionInfo = _modifyPosition(\n            ModifyPositionParams({\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                liquidityType: params.liquidityType,\n                liquidityDelta: int128(params.amount)\n            })\n        );\n\n        if (params.liquidityType == LiquidityType.COLLATERAL) {\n            uint256 balanceBefore = IERC20(_bk.collateral).balanceOf(address(this));\n            IMintCallback(msg.sender).mintCallback(params.seed, params.data);\n            if (IERC20(_bk.collateral).balanceOf(address(this)) < balanceBefore + params.seed) {\n                revert Errors.InsufficientCollateral();\n            }\n        } else if (params.liquidityType == LiquidityType.SPEAR) {\n            uint256 balanceBefore = IERC20(spear).balanceOf(address(this));\n            IMintCallback(msg.sender).mintCallback(params.seed, params.data);\n            if (IERC20(spear).balanceOf(address(this)) < balanceBefore + params.seed) {\n                revert Errors.InsufficientSpear();\n            }\n            ISToken(spear).burn(address(this), params.seed);\n        } else {\n            uint256 balanceBefore = IERC20(shield).balanceOf(address(this));\n            IMintCallback(msg.sender).mintCallback(params.seed, params.data);\n            if (IERC20(shield).balanceOf(address(this)) < balanceBefore + params.seed) {\n                revert Errors.InsufficientShield();\n            }\n            ISToken(shield).burn(address(this), params.seed);\n        }\n\n        emit Minted(msg.sender, params.liquidityType, params.tickLower, params.tickUpper, params.amount, params.seed);\n    }\n\n    /// @inheritdoc IBattleMintBurn\n    function burn(BattleBurnParams memory params) external override lock onlyManager {\n        if (params.tickLower >= params.tickUpper) {\n            revert Errors.TickOrderInvalid();\n        }\n        _modifyPosition(\n            ModifyPositionParams({\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                liquidityType: params.liquidityType,\n                liquidityDelta: -int128(params.liquidityAmount)\n            })\n        );\n        emit Burned(params.tickLower, params.tickUpper, params.liquidityType, params.liquidityAmount);\n    }\n\n    /// comments see IBattleTrade\n    function collect(address recipient, uint256 cAmount, uint256 spAmount, uint256 shAmount) external override onlyManager {\n        if (cAmount > 0) {\n            IERC20(_bk.collateral).safeTransfer(recipient, cAmount);\n        }\n        if (spAmount > 0) {\n            ISToken(spear).mint(recipient, spAmount);\n        }\n        if (shAmount > 0) {\n            ISToken(shield).mint(recipient, shAmount);\n        }\n    }\n\n    function trade(BattleTradeParams memory params) external returns (uint256 cAmount, uint256 sAmount, uint256 fAmount) {\n        if (block.timestamp >= _bk.expiries) {\n            revert Errors.BattleEnd();\n        }\n        if (params.amountSpecified == 0) {\n            revert Errors.ZeroValue();\n        }\n\n        Slot0 memory slot0Start = slot0;\n\n        if (!slot0Start.unlocked) {\n            revert Errors.Locked();\n        }\n\n        bool isPriceDown = params.tradeType == TradeType.BUY_SPEAR;\n        bool exactIn = params.amountSpecified > 0;\n        require(\n            isPriceDown\n                ? params.sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && params.sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO\n                : params.sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && params.sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,\n            \"PriceInvalid\"\n        );\n        slot0.unlocked = false;\n\n        TradeCache memory cache = TradeCache({ feeProtocol: fee.protocolFee });\n        TradeState memory state = TradeState({\n            amountSpecifiedRemaining: params.amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\n            tick: slot0Start.tick,\n            global: global,\n            protocolFee: 0,\n            liquidity: liquidity,\n            transactionFee: 0\n        });\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != params.sqrtPriceLimitX96) {\n            StepComputations memory step;\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(state.tick, 30, isPriceDown);\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            }\n            if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n            (state.sqrtPriceX96, step.amountIn, step.amountOut) = TradeMath.computeTradeStep(\n                ComputeTradeStepParams({\n                    tradeType: params.tradeType,\n                    sqrtRatioCurrentX96"
    }
  ]
}