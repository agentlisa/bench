{
  "Title": "[N-04] `safeApprove()` is deprecated",
  "Content": "\n[Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`\n\n1.  File: contracts/PaladinRewardReserve.sol (line [31](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L31))\n\n```solidity\n        IERC20(token).safeApprove(spender, amount);\n```\n\n2.  File: contracts/PaladinRewardReserve.sol (line [38](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L38))\n\n```solidity\n        IERC20(token).safeApprove(spender, 0);\n```\n\n3.  File: contracts/PaladinRewardReserve.sol (line [39](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L39))\n\n```solidity\n        IERC20(token).safeApprove(spender, amount);\n```\n\n4.  File: contracts/PaladinRewardReserve.sol (line [47](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L47))\n\n```solidity\n        IERC20(token).safeApprove(spender, 0);\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-paladin",
  "Code": [
    {
      "filename": "contracts/token/ERC20/utils/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    },
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    },
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    },
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    },
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    }
  ]
}