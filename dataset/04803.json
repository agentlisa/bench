{
  "Title": "[21] Remove unnecessary code irrelevant to final production",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondInit.sol#L51\n\n```solidity\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n```\n\nThis check is used to ensure that the length of the L2Log encoding is not equal to the length of other L2Logs' tree nodes preimages, but according to the code comment, we know that the check is only in place for testing purposes, also from [here](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/common/Config.sol#L8-L12) we can see that this is a constant value set as `88`.\n\n### Impact\n\nBad code structure, unnecessary code irrelevant to the production is being left in protocol.\n\n### Recommended Mitigation Steps\n\nRemove this assertion from final released code.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondInit.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Diamond} from \"../libraries/Diamond.sol\";\nimport {ZkSyncStateTransitionBase} from \"./facets/ZkSyncStateTransitionBase.sol\";\nimport {FeeParams} from \"./ZkSyncStateTransitionStorage.sol\";\nimport {L2_TO_L1_LOG_SERIALIZE_SIZE, MAX_GAS_PER_TRANSACTION} from \"../../common/Config.sol\";\nimport {InitializeData, IDiamondInit} from \"../chain-interfaces/IDiamondInit.sol\";\nimport {VerifierParams} from \"../chain-interfaces/IVerifier.sol\";\n\nimport \"../l2-deps/ISystemContext.sol\";\n\n/// @author Matter Labs\n/// @dev The contract is used only once to initialize the diamond proxy.\n/// @dev The deployment process takes care of this contract's initialization.\ncontract DiamondInit is ZkSyncStateTransitionBase, IDiamondInit {\n    /// @dev Initialize the implementation to prevent any possibility of a Parity hack.\n    constructor() reentrancyGuardInitializer {}\n\n    /// @notice hyperchain diamond contract initialization\n    /// @return Magic 32 bytes, which indicates that the contract logic is expected to be used as a diamond proxy\n    /// initializer\n    function initialize(InitializeData calldata _initializeData) external reentrancyGuardInitializer returns (bytes32) {\n        require(address(_initializeData.verifier) != address(0), \"vt\");\n        require(_initializeData.admin != address(0), \"vy\");\n        require(_initializeData.validatorTimelock != address(0), \"hc\");\n        require(_initializeData.priorityTxMaxGasLimit <= MAX_GAS_PER_TRANSACTION, \"vu\");\n\n        s.chainId = _initializeData.chainId;\n        s.bridgehub = _initializeData.bridgehub;\n        s.stateTransitionManager = _initializeData.stateTransitionManager;\n        s.baseToken = _initializeData.baseToken;\n        s.baseTokenBridge = _initializeData.baseTokenBridge;\n        s.protocolVersion = _initializeData.protocolVersion;\n\n        s.verifier = _initializeData.verifier;\n        s.admin = _initializeData.admin;\n        s.validators[_initializeData.validatorTimelock] = true;\n\n        s.storedBatchHashes[0] = _initializeData.storedBatchZero;\n        s.verifierParams = _initializeData.verifierParams;\n        s.l2BootloaderBytecodeHash = _initializeData.l2BootloaderBytecodeHash;\n        s.l2DefaultAccountBytecodeHash = _initializeData.l2DefaultAccountBytecodeHash;\n        s.priorityTxMaxGasLimit = _initializeData.priorityTxMaxGasLimit;\n        s.feeParams = _initializeData.feeParams;\n        s.blobVersionedHashRetriever = _initializeData.blobVersionedHashRetriever;\n\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/common/Config.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\n/// @dev `keccak256(\"\")`\nbytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n/// @dev Bytes in raw L2 log\n/// @dev Equal to the bytes size of the tuple - (uint8 ShardId, bool isService, uint16 txNumberInBatch, address sender,\n/// bytes32 key, bytes32 value)\nuint256 constant L2_TO_L1_LOG_SERIALIZE_SIZE = 88;\n\n/// @dev The maximum length of the bytes array with L2 -> L1 logs\nuint256 constant MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES = 4 + L2_TO_L1_LOG_SERIALIZE_SIZE * 512;\n\n/// @dev The value of default leaf hash for L2 -> L1 logs Merkle tree\n/// @dev An incomplete fixed-size tree is filled with this value to be a full binary tree\n/// @dev Actually equal to the `keccak256(new bytes(L2_TO_L1_LOG_SERIALIZE_SIZE))`\nbytes32 constant L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH = 0x72abee45b59e344af8a6e520241c4744aff26ed411f4c4b00f8af09adada43ba;\n\n// TODO: change constant to the real root hash of empty Merkle tree (SMA-184)\nbytes32 constant DEFAULT_L2_LOGS_TREE_ROOT_HASH = bytes32(0);\n\n/// @dev Denotes the type of the zkSync transaction that came from L1.\nuint256 constant PRIORITY_OPERATION_L2_TX_TYPE = 255;\n\n/// @dev Denotes the type of the zkSync transaction that is used for system upgrades.\nuint256 constant SYSTEM_UPGRADE_L2_TX_TYPE = 254;\n\n/// @dev The maximal allowed difference between protocol versions in an upgrade. The 100 gap is needed\n/// in case a protocol version has been tested on testnet, but then not launched on mainnet, e.g.\n/// due to a bug found.\nuint256 constant MAX_ALLOWED_PROTOCOL_VERSION_DELTA = 100;\n\n/// @dev The amount of time in seconds the validator has to process the priority transaction\n/// NOTE: The constant is set to zero for the Alpha release period\nuint256 constant PRIORITY_EXPIRATION = 0 days;\n\n/// @dev Timestamp - seconds since unix epoch.\nuint256 constant COMMIT_TIMESTAMP_NOT_OLDER = 3 days;\n\n/// @dev Maximum available error between real commit batch timestamp and analog used in the verifier (in seconds)\n/// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 12 seconds)\nuint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 1 hours;\n\n/// @dev Shift to apply to verify public input before verifying.\nuint256 constant PUBLIC_INPUT_SHIFT = 32;\n\n/// @dev The maximum number of L2 gas that a user can request for an L2 transaction\nuint256 constant MAX_GAS_PER_TRANSACTION = $(MAX_GAS_PER_TRANSACTION);\n\n/// @dev Even though the price for 1 byte of pubdata is 16 L1 gas, we have a slightly increased\n/// value.\nuint256 constant L1_GAS_PER_PUBDATA_BYTE = $(L1_GAS_PER_PUBDATA_BYTE);\n\n/// @dev The intrinsic cost of the L1->l2 transaction in computational L2 gas\nuint256 constant L1_TX_INTRINSIC_L2_GAS = $(L1_TX_INTRINSIC_L2_GAS);\n\n/// @dev The intrinsic cost of the L1->l2 transaction in pubdata\nuint256 constant L1_TX_INTRINSIC_PUBDATA = $(L1_TX_INTRINSIC_PUBDATA);\n\n/// @dev The minimal base price for L1 transaction\nuint256 constant L1_TX_MIN_L2_GAS_BASE = $(L1_TX_MIN_L2_GAS_BASE);\n\n/// @dev The number of L2 gas the transaction starts costing more with each 544 bytes of encoding\nuint256 constant L1_TX_DELTA_544_ENCODING_BYTES = $(L1_TX_DELTA_544_ENCODING_BYTES);\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_L2_GAS = $(L1_TX_DELTA_FACTORY_DEPS_L2_GAS);\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_PUBDATA = $(L1_TX_DELTA_FACTORY_DEPS_PUBDATA);\n\n/// @dev The number of pubdata an L1->L2 transaction requires with each new factory dependency\nuint256 constant MAX_NEW_FACTORY_DEPS = $(MAX_NEW_FACTORY_DEPS);\n\n/// @dev The L2 gasPricePerPubdata required to be used in bridges.\nuint256 constant REQUIRED_L2_GAS_PRICE_PER_PUBDATA = $(REQUIRED_L2_GAS_PRICE_PER_PUBDATA);\n\n/// @dev The mask which should be applied to the packed batch and L2 block timestamp in order\n/// to obtain the L2 block timestamp. Applying this mask is equivalent to calculating modulo 2**128\nuint256 constant PACKED_L2_BLOCK_TIMESTAMP_MASK = 0xffffffffffffffffffffffffffffffff;\n\n/// @dev Address of the point evaluation precompile used for EIP-4844 blob verification.\naddress constant POINT_EVALUATION_PRECOMPILE_ADDR = address(0x0A);\n\n/// @dev The overhead for a transaction slot in L2 gas.\n/// It is roughly equal to 80kk/MAX_TRANSACTIONS_IN_BATCH, i.e. how many gas would an L1->L2 transaction\n/// need to pay to compensate for the batch being closed.\n/// @dev It is expected that the L1 contracts will enforce that the L2 gas price will be high enough to compensate\n/// the operator in case the batch is closed because of tx slots filling up.\nuint256 constant TX_SLOT_OVERHEAD_L2_GAS = 10000;\n\n/// @dev The overhead for each byte of the bootloader memory that the encoding of the transaction.\n/// It is roughly equal to 80kk/BOOTLOADER_MEMORY_FOR_TXS, i.e. how many gas would an L1->L2 transaction\n/// need to pay to compensate for the batch being closed.\n/// @dev It is expected that the L1 contracts will enforce that the L2 gas price will be high enough to compensate\n/// the operator in case the batch is closed because of the memory for transactions being filled up.\nuint256 constant MEMORY_OVERHEAD_GAS = 10;\n\naddress constant ETH_TOKEN_ADDRESS = address(1);\n\n/// @dev Era's chainID\nuint256 constant ERA_CHAIN_ID = $(ERA_CHAIN_ID);\n\n/// @dev The address of legacy L1 ERC20 bridge.\naddress constant ERA_ERC20_BRIDGE_ADDRESS = $(ERA_ERC20_BRIDGE_ADDRESS);\n\n/// @dev The address of zkSync Era diamond proxy contract.\naddress constant ERA_DIAMOND_PROXY = $(ERA_DIAMOND_PROXY);\n\nbytes32 constant TWO_BRIDGES_MAGIC_VALUE = bytes32(uint256(keccak256(\"TWO_BRIDGES_MAGIC_VALUE\")) - 1);\n\n/// @dev https://eips.ethereum.org/EIPS/eip-1352\naddress constant BRIDGEHUB_MIN_SECOND_BRIDGE_ADDRESS = address(uint160(type(uint16).max));"
    }
  ]
}