{
  "Title": "[M-15] `sync` function in `RdpxV2Core.sol` should be called in multiple scenarios to account for the balance changes that occurs",
  "Content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L160-L178> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV3LiquidityAmo.sol#L118-L133>\n\nThe function `sync` is used in `RdpxV2Core.sol` to synchronize the balances of the reserve assets stored in the contract, but it is not called in all of the situations where swaps/providing/removing liquidity is made.\n\n### Proof of Concept\n\nAs you can see `sync` is called in `UniV3LiquidityAmo.sol` after `_sendTokensToRdpxV2Core` is called to occur for all of the balances change after modifying the liquidity in UniswapV3 <br><https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV3LiquidityAmo.sol#L361><br>\nBut it is not called functions like `collectFees` where funds are directly transferred to `RdpxV2Core.sol` <br><https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV3LiquidityAmo.sol#L118-L133><br>\nOr in `_sendTokensToRdpxV2Core` in the `UniV2LiquidityAmo.sol` which transfers tokens to `RdpxV2Core` <br><https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L157-L178><br>\nBecause of that wrong assumptions can be taken in cases of `lowerDepeg` or `upperDepeg`, or any other functions that uses the balances of assets stored, if `sync` was not called before.\n\n### Recommended Mitigation Steps\n\nSince you already call `sync` in `_sendTokensToRdpxV2Core` from `UniV3LiquidityAmo.sol`, call it in `collectFees` and `_sendTokensToRdpxV2Core` from `UniV2LiquidityAmo.sol` also to accounts for any balance changes, which will protect the protocol against errors.\n\n**[bytes032 (Lookout) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/269#issuecomment-1712408116):**\n > * [This is related to Uni V2, in the implementation for V3 it is called.](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV3LiquidityAmo.sol#L361)\n> * This will cause less than expected backing reserves, which can lead to underflow when performing various other actions such as when providing funding for APP options (provideFunding()), settling options (settle()).\n> * The [function getReserveTokenInfo](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1135) is no longer a reliable source for external integration to retrieve the token balance state.\n> \n> Potentially impacts the following functions:\n> - [_purchaseOptions](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L486)\n> - [_stake](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L570)\n> - [settle](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L780)\n> - [provideFunding](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L803)\n> - [lowerDepeg](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1106)\n> \n> Edit: It’s actually not called in [collectFee’s](https://github.com/code-423n4/2023-08-dopex-findings/issues/934) as well. I’m duplicating all of these under a single primary issue, because #269 mentions both.\n\n**[witherblock (Dopex) confirmed](https://github.com/code-423n4/2023-08-dopex-findings/issues/269#issuecomment-1734174462)**\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/269#issuecomment-1759127851):**\n > Seems like an opportunity for a higher exploit was missed by stopping at the broken sync.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/amo/UniV2LiquidityAmo.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IUniswapV2Router } from \"../uniswap_V2/IUniswapV2Router.sol\";\nimport { IUniswapV2Pair } from \"../uniswap_V2/IUniswapV2Pair.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IRdpxV2Core } from \"../core/IRdpxV2Core.sol\";\n\n// Libraries\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title UniswapV2LiquidityAmo contract\n/// @author Dopex\n/// @notice The uniswap v2 liquidity amo contract\ncontract UniV2LiquidityAMO is AccessControl {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeMath for uint256;\n\n  // ================================ STATE VARIABLES ================================ //\n  struct Addresses {\n    // token A address\n    address tokenA; // rdpx\n    // token B address\n    address tokenB; // weth\n    // pair address\n    address pair;\n    // rdpxV2Core address\n    address rdpxV2Core;\n    // rdpx price oracle\n    address rdpxOracle;\n    // AMM Factory\n    address ammFactory;\n    // AMM Router\n    address ammRouter;\n  }\n\n  /// @notice  addresses of the contracts\n  Addresses public addresses;\n\n  /// @notice Precision used for prices, percentages and other calculations\n  uint256 public constant DEFAULT_PRECISION = 1e8;\n\n  /// @notice The slippage tolernce in swaps in 1e8 precision\n  uint256 public slippageTolerance = 5e5; // 0.5%\n\n  /// @notice LP token Balance\n  uint256 public lpTokenBalance;\n\n  // ================================ CONSTRUCTOR ================================ //\n  constructor() {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Set the addresses of the contracts\n   * @dev    Can only be called by admin\n   * @param  _tokenA the token A address\n   * @param  _tokenB the token B address\n   * @param _pair the pair address\n   * @param _rdpxV2Core the rdpxV2Core address\n   * @param _rdpxOracle the rdpx price oracle\n   * @param _ammFactory the AMM Factory\n   * @param _ammRouter the AMM Router\n   **/\n  function setAddresses(\n    address _tokenA,\n    address _tokenB,\n    address _pair,\n    address _rdpxV2Core,\n    address _rdpxOracle,\n    address _ammFactory,\n    address _ammRouter\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _tokenA != address(0) &&\n        _tokenB != address(0) &&\n        _pair != address(0) &&\n        _rdpxV2Core != address(0) &&\n        _rdpxOracle != address(0) &&\n        _ammFactory != address(0) &&\n        _ammRouter != address(0),\n      \"reLPContract: address cannot be 0\"\n    );\n    addresses = Addresses({\n      tokenA: _tokenA,\n      tokenB: _tokenB,\n      pair: _pair,\n      rdpxV2Core: _rdpxV2Core,\n      rdpxOracle: _rdpxOracle,\n      ammFactory: _ammFactory,\n      ammRouter: _ammRouter\n    });\n  }\n\n  /**\n   * @notice sets the slippage tolerance\n   * @dev    Can only be called by admin\n   * @param  _slippageTolerance the slippage tolerance\n   */\n  function setSlippageTolerance(\n    uint256 _slippageTolerance\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _slippageTolerance > 0,\n      \"reLPContract: slippage tolerance must be greater than 0\"\n    );\n    slippageTolerance = _slippageTolerance;\n  }\n\n  /**\n   * @notice Approve a contract to spend a certain amount of tokens\n   * @dev    Can only be called by admin\n   * @param  _token the address of the token to approve\n   * @param  _spender the address of the contract to approve\n   * @param  _amount the amount to approve\n   */\n  function approveContractToSpend(\n    address _token,\n    address _spender,\n    uint256 _amount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_token != address(0), \"reLPContract: token cannot be 0\");\n    require(_spender != address(0), \"reLPContract: spender cannot be 0\");\n    require(_amount > 0, \"reLPContract: amount must be greater than 0\");\n    IERC20WithBurn(_token).approve(_spender, _amount);\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit LogEmergencyWithdraw(msg.sender, tokens);\n  }\n\n  // ================================ INTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @dev sends token A and B to the rdpxV2Core\n   */\n  function _sendTokensToRdpxV2Core() internal {\n    uint256 tokenABalance = IERC20WithBurn(addresses.tokenA).balanceOf(\n      address(this)\n    );\n    uint256 tokenBBalance = IERC20WithBurn(addresses.tokenB).balanceOf(\n      address(this)\n    );\n    // transfer token A and B from this contract to the rdpxV2Core\n    IERC20WithBurn(addresses.tokenA).safeTransfer(\n      addresses.rdpxV2Core,\n      tokenABalance\n    );\n    IERC20WithBurn(addresses.tokenB).safeTransfer(\n      addresses.rdpxV2Core,\n      tokenBBalance\n    );\n\n    emit LogAssetsTransfered(msg.sender, tokenABalance, tokenBBalance);\n  }\n\n  // ================================ AMO FUNCTIONS ================================ //\n\n  /**\n   * @dev adds liquidity to the uni v2 pool\n   * @param tokenAAmount the amount of token A to add\n   * @param tokenBAmount the amount of token B to add\n   * @param tokenAAmountMin the minimum amount of token A to add\n   * @param tokenBAmountMin the minimum amount of token B to add\n   */\n  function addLiquidity(\n    uint256 tokenAAmount,\n    uint256 tokenBAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin\n  )\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 tokenAUsed, uint256 tokenBUsed, uint256 lpReceived)\n  {\n    // approve the AMM Router\n    IERC20WithBurn(addresses.tokenA).safeApprove(\n      addresses.ammRouter,\n      tokenAAmount\n    );\n    IERC20WithBurn(addresses.tokenB).safeApprove(\n      addresses.ammRouter,\n      tokenBAmount\n    );\n\n    // transfer token A and B from the rdpxV2Core to this contract\n    IERC20WithBurn(addresses.tokenA).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      tokenAAmount\n    );\n    IERC20WithBurn(addresses.tokenB).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      tokenBAmount\n    );\n\n    // add Liquidity\n    (tokenAUsed, tokenBUsed, lpReceived) = IUniswapV2Router(addresses.ammRouter)\n      .addLiquidity(\n        addresses.tokenA,\n        addresses.tokenB,\n        tokenAAmount,\n        tokenBAmount,\n        tokenAAmountMin,\n        tokenBAmountMin,\n        address(this),\n        block.timestamp + 1\n      );\n\n    // update LP token Balance\n    lpTokenBalance += lpReceived;\n\n    // send unused token A and token B back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogAddLiquidity(\n      msg.sender,\n      tokenAAmount,\n      tokenBAmount,\n      tokenAAmountMin,\n      tokenBAmountMin,\n      tokenAUsed,\n      tokenBUsed,\n      lpReceived\n    );\n  }\n\n  /**\n   * @dev removes liquidity from the uni v2 pool\n   * @param lpAmount the amount of LP tokens to remove\n   * @param tokenAAmountMin the minimum amount of token A to receive\n   * @param tokenBAmountMin the minimum amount of token B to receive\n   */\n  function removeLiquidity(\n    uint256 lpAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin\n  )\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 tokenAReceived, uint256 tokenBReceived)\n  {\n    // approve the AMM Router\n    IERC20WithBurn(addresses.pair).safeApprove(addresses.ammRouter, lpAmount);\n\n    // remove liquidity\n    (tokenAReceived, tokenBReceived) = IUniswapV2Router(addresses.ammRouter)\n      .removeLiquidity(\n        addresses.tokenA,\n        addresses.tokenB,\n        lpAmount,\n        tokenAAmountMin,\n        tokenBAmountMin,\n        address(this),\n        block.timestamp + 1\n      );\n\n    // update LP token Balance\n    lpTokenBalance -= lpAmount;\n\n    // send unused token A and token B back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogRemoveLiquidity(\n      msg.sender,\n      lpAmount,\n      tokenAAmountMin,\n      tokenBAmountMin,\n      tokenAReceived,\n      tokenBReceived\n    );\n  }\n\n  /**\n   * @dev swaps token 1 for token 2\n   * @param token1Amount the amount of token A to swap\n   * @param token2AmountOutMin the minimum amount of token B to receive\n   * @param swapTokenAForTokenB whether to swap token A for token B\n   */\n  function swap(\n    uint256 token1Amount,\n    uint256 token2AmountOutMin,\n    bool swapTokenAForTokenB\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256 token2Amount) {\n    address token1;\n    address token2;\n\n    // check to see if we are swapping token A for token B\n    if (swapTokenAForTokenB) {\n      token1 = addresses.tokenA;\n      token2 = addresses.tokenB;\n    } else {\n      token1 = addresses.tokenB;\n      token2 = addresses.tokenA;\n    }\n    // transfer token A from the rdpxV2Core to this contract\n    IERC20WithBurn(token1).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      token1Amount\n    );\n\n    // approve the AMM Router\n    IERC20WithBurn(token1).safeApprove(addresses.ammRouter, token1Amount);\n\n    address[] memory path;\n    path = new address[](2);\n    path[0] = token1;\n    path[1] = token2;\n\n    // swap token A for token B\n    token2Amount = IUniswapV2Router(addresses.ammRouter)\n      .swapExactTokensForTokens(\n        token1Amount,\n        token2AmountOutMin,\n        path,\n        address(this),\n        block.timestamp + 1\n      )[path.length - 1];\n\n    // send tokens back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogSwap(\n      msg.sender,\n      token1Amount,\n      token2AmountOutMin,\n      swapTokenAForTokenB,\n      token2Amount\n    );\n  }\n\n  // ================================ EXTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @notice Syncs asset reserves with contract balances\n   **/\n  function sync() external {\n    lpTokenBalance = IERC20WithBurn(addresses.pair).balanceOf(address(this));\n  }\n\n  // ================================ VIEW FUNCTIONS ================================ //\n  /**\n   * @notice Returns the LP token balance in weth\n   * @dev returns LP token balance\n   * @return lpTokenBalanceInWeth the LP token balance in weth\n   */\n  function getLpTokenBalanceInWeth() external view returns (uint256) {\n    return (lpTokenBalance * getLpPrice()) / 1e8;\n  }\n\n  /**\n   * @notice Returns the price of a rDPX/ETH Lp token against the alpha token\n   * @dev    Price is in 1e8 Precision\n   * @return uint256 LP price\n   **/\n  function getLpPrice() public view returns (uint256) {\n    return IRdpxEthOracle(addresses.rdpxOracle).getLpPriceInEth();\n  }\n\n  // ================================ Events FUNCTIONS ================================ //\n\n  event LogAddLiquidity(\n    address indexed sender,\n    uint256 tokenAAmount,\n    uint256 tokenBAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin,\n    uint256 tokenAUsed,\n    uint256 tokenBUsed,\n    uint256 lpReceived\n  );\n\n  event LogRemoveLiquidity(\n    address indexed sender,\n    uint256 lpAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin,\n    uint256 tokenAReceived,\n    uint256 tokenBReceived\n  );\n\n  event LogSwap(\n    address indexed sender,\n    uint256 token1Amount,\n    uint256 token2AmountOutMin,\n    bool swapTokenAForTokenB,\n    uint256 token2Amount\n  );\n\n  event LogAssetsTransfered(\n    address indexed sender,\n    uint256 tokenAAmount,\n    uint256 tokenBAmount\n  );\n\n  event LogEmergencyWithdraw(address sender, address[] tokens);\n}"
    },
    {
      "filename": "contracts/amo/UniV3LiquidityAmo.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { TransferHelper } from \"../libraries/TransferHelper.sol\";\nimport { IRdpxV2Core } from \"../core/IRdpxV2Core.sol\";\n\n// Uniswamp V3\nimport \"../uniswap_V3/IUniswapV3Factory.sol\";\nimport \"../uniswap_V3/libraries/TickMath.sol\";\nimport \"../uniswap_V3/libraries/LiquidityAmounts.sol\";\nimport \"../uniswap_V3/periphery/interfaces/INonfungiblePositionManager.sol\";\nimport \"../uniswap_V3/IUniswapV3Pool.sol\";\nimport \"../uniswap_V3/ISwapRouter.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\nabstract contract OracleLike {\n  function read() external view virtual returns (uint);\n\n  function uniswapPool() external view virtual returns (address);\n}\n\ncontract UniV3LiquidityAMO is AccessControl, ERC721Holder {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20WithBurn;\n\n  /* ========== STATE VARIABLES ========== */\n\n  // Uniswap v3\n  IUniswapV3Factory public univ3_factory;\n  INonfungiblePositionManager public univ3_positions;\n  ISwapRouter public univ3_router;\n\n  // Details about the AMO's uniswap positions\n  struct Position {\n    uint256 token_id;\n    address collateral_address;\n    uint128 liquidity; // the liquidity of the position\n    int24 tickLower; // the tick range of the position\n    int24 tickUpper;\n    uint24 fee_tier;\n  }\n\n  // Add liquidity param\n  struct AddLiquidityParams {\n    address _tokenA;\n    address _tokenB;\n    int24 _tickLower;\n    int24 _tickUpper;\n    uint24 _fee;\n    uint256 _amount0Desired;\n    uint256 _amount1Desired;\n    uint256 _amount0Min;\n    uint256 _amount1Min;\n  }\n\n  // Array of all Uni v3 NFT positions held by the AMO\n  Position[] public positions_array;\n\n  // Map token_id to Position\n  mapping(uint256 => Position) public positions_mapping;\n\n  // Rdpx address\n  address public rdpx;\n\n  // RdpxV2Core address\n  address public rdpxV2Core;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(address _rdpx, address _rdpxV2Core) {\n    rdpx = _rdpx;\n    rdpxV2Core = _rdpxV2Core;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    univ3_factory = IUniswapV3Factory(\n      0x1F98431c8aD98523631AE4a59f267346ea31F984\n    );\n    univ3_positions = INonfungiblePositionManager(\n      0xC36442b4a4522E871399CD717aBDD847Ab11FE88\n    );\n    univ3_router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n  }\n\n  /* ========== VIEWS ========== */\n\n  // Returns this contract's liquidity in a specific [Rdpx]-[collateral] uni v3 pool\n  function liquidityInPool(\n    address _collateral_address,\n    int24 _tickLower,\n    int24 _tickUpper,\n    uint24 _fee\n  ) public view returns (uint128) {\n    IUniswapV3Pool get_pool = IUniswapV3Pool(\n      univ3_factory.getPool(address(rdpx), _collateral_address, _fee)\n    );\n\n    // goes into the pool's positions mapping, and grabs this address's liquidity\n    (uint128 liquidity, , , , ) = get_pool.positions(\n      keccak256(abi.encodePacked(address(this), _tickLower, _tickUpper))\n    );\n    return liquidity;\n  }\n\n  // Only counts non-withdrawn positions\n  function numPositions() public view returns (uint256) {\n    return positions_array.length;\n  }\n\n  /* ========== RESTRICTED FUNCTIONS, BUT CUSTODIAN CAN CALL ========== */\n\n  // Iterate through all positions and collect fees accumulated\n  function collectFees() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint i = 0; i < positions_array.length; i++) {\n      Position memory current_position = positions_array[i];\n      INonfungiblePositionManager.CollectParams\n        memory collect_params = INonfungiblePositionManager.CollectParams(\n          current_position.token_id,\n          rdpxV2Core,\n          type(uint128).max,\n          type(uint128).max\n        );\n\n      // Send to custodian address\n      univ3_positions.collect(collect_params);\n    }\n  }\n\n  /* ---------------------------------------------------- */\n  /* ---------------------- Uni v3 ---------------------- */\n  /* ---------------------------------------------------- */\n\n  function approveTarget(\n    address _target,\n    address _token,\n    uint256 _amount,\n    bool use_safe_approve\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (use_safe_approve) {\n      // safeApprove needed for USDT and others for the first approval\n      // You need to approve 0 every time beforehand for USDT: it resets\n      TransferHelper.safeApprove(_token, _target, _amount);\n    } else {\n      IERC20WithBurn(_token).approve(_target, _amount);\n    }\n  }\n\n  // IUniswapV3Pool public current_uni_pool; // only used for mint callback; is set and accessed during execution of addLiquidity()\n  function addLiquidity(\n    AddLiquidityParams memory params\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    IERC20WithBurn(params._tokenA).transferFrom(\n      rdpxV2Core,\n      address(this),\n      params._amount0Desired\n    );\n    IERC20WithBurn(params._tokenB).transferFrom(\n      rdpxV2Core,\n      address(this),\n      params._amount1Desired\n    );\n\n    IERC20WithBurn(params._tokenA).approve(\n      address(univ3_positions),\n      params._amount0Desired\n    );\n    IERC20WithBurn(params._tokenB).approve(\n      address(univ3_positions),\n      params._amount1Desired\n    );\n\n    INonfungiblePositionManager.MintParams\n      memory mintParams = INonfungiblePositionManager.MintParams(\n        params._tokenA,\n        params._tokenB,\n        params._fee,\n        params._tickLower,\n        params._tickUpper,\n        params._amount0Desired,\n        params._amount1Desired,\n        params._amount0Min,\n        params._amount1Min,\n        address(this),\n        type(uint256).max\n      );\n\n    (uint256 tokenId, uint128 amountLiquidity, , ) = univ3_positions.mint(\n      mintParams\n    );\n\n    Position memory pos = Position(\n      tokenId,\n      params._tokenA == address(rdpx) ? params._tokenB : params._tokenA,\n      amountLiquidity,\n      params._tickLower,\n      params._tickUpper,\n      params._fee\n    );\n\n    positions_array.push(pos);\n    positions_mapping[tokenId] = pos;\n\n    // send tokens to rdpxV2Core\n    _sendTokensToRdpxV2Core(params._tokenA, params._tokenB);\n  }\n\n  function removeLiquidity(\n    uint256 positionIndex,\n    uint256 minAmount0,\n    uint256 minAmount1\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    Position memory pos = positions_array[positionIndex];\n    INonfungiblePositionManager.CollectParams\n      memory collect_params = INonfungiblePositionManager.CollectParams(\n        pos.token_id,\n        rdpxV2Core,\n        type(uint128).max,\n        type(uint128).max\n      );\n\n    (\n      ,\n      ,\n      address tokenA,\n      address tokenB,\n      ,\n      ,\n      ,\n      uint128 liquidity,\n      ,\n      ,\n      ,\n\n    ) = univ3_positions.positions(pos.token_id);\n\n    // remove liquidity\n    INonfungiblePositionManager.DecreaseLiquidityParams\n      memory decreaseLiquidityParams = INonfungiblePositionManager\n        .DecreaseLiquidityParams(\n          pos.token_id,\n          liquidity,\n          minAmount0,\n          minAmount1,\n          block.timestamp\n        );\n\n    univ3_positions.decreaseLiquidity(decreaseLiquidityParams);\n\n    univ3_positions.collect(collect_params);\n\n    univ3_positions.burn(pos.token_id);\n\n    positions_array[positionIndex] = positions_array[\n      positions_array.length - 1\n    ];\n    positions_array.pop();\n    delete positions_mapping[pos.token_id];\n\n    // send tokens to rdpxV2Core\n    _sendTokensToRdpxV2Core(tokenA, tokenB);\n\n    emit log(positions_array.length);\n    emit log(positions_mapping[pos.token_id].token_id);\n  }\n\n  // Swap tokenA into tokenB using univ3_router.ExactInputSingle()\n  // Uni V3 only\n  function swap(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee_tier,\n    uint256 _amountAtoB,\n    uint256 _amountOutMinimum,\n    uint160 _sqrtPriceLimitX96\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256) {\n    // transfer token from rdpx v2 core\n    IERC20WithBurn(_tokenA).transferFrom(\n      rdpxV2Core,\n      address(this),\n      _amountAtoB\n    );\n\n    ISwapRouter.ExactInputSingleParams memory swap_params = ISwapRouter\n      .ExactInputSingleParams(\n        _tokenA,\n        _tokenB,\n        _fee_tier,\n        address(this),\n        2105300114, // Expiration: a long time from now\n        _amountAtoB,\n        _amountOutMinimum,\n        _sqrtPriceLimitX96\n      );\n\n    // Approval\n    TransferHelper.safeApprove(_tokenA, address(univ3_router), _amountAtoB);\n\n    uint256 amountOut = univ3_router.exactInputSingle(swap_params);\n\n    _sendTokensToRdpxV2Core(_tokenA, _tokenB);\n    return amountOut;\n  }\n\n  /* ========== OWNER / GOVERNANCE FUNCTIONS ONLY ========== */\n  // Only owner or timelock can call, to limit risk\n\n  function recoverERC20(\n    address tokenAddress,\n    uint256 tokenAmount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Can only be triggered by owner or governance, not custodian\n    // Tokens are sent to the custodian, as a sort of safeguard\n    TransferHelper.safeTransfer(tokenAddress, rdpxV2Core, tokenAmount);\n\n    emit RecoveredERC20(tokenAddress, tokenAmount);\n  }\n\n  function recoverERC721(\n    address tokenAddress,\n    uint256 token_id\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Only the owner address can ever receive the recovery withdrawal\n    // INonfungiblePositionManager inherits IERC721 so the latter does not need to be imported\n    INonfungiblePositionManager(tokenAddress).safeTransferFrom(\n      address(this),\n      rdpxV2Core,\n      token_id\n    );\n    emit RecoveredERC721(tokenAddress, token_id);\n  }\n\n  // Generic proxy\n  function execute(\n    address _to,\n    uint256 _value,\n    bytes calldata _data\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (bool, bytes memory) {\n    (bool success, bytes memory result) = _to.call{ value: _value }(_data);\n    return (success, result);\n  }\n\n  /* ========== INTERNAL ========== */\n\n  /**\n   * @dev sends token A and B to the rdpxV2Core\n   */\n  function _sendTokensToRdpxV2Core(address tokenA, address tokenB) internal {\n    uint256 tokenABalance = IERC20WithBurn(tokenA).balanceOf(address(this));\n    uint256 tokenBBalance = IERC20WithBurn(tokenB).balanceOf(address(this));\n    // transfer token A and B from this contract to the rdpxV2Core\n    IERC20WithBurn(tokenA).safeTransfer(rdpxV2Core, tokenABalance);\n    IERC20WithBurn(tokenB).safeTransfer(rdpxV2Core, tokenBBalance);\n\n    // sync token balances\n    IRdpxV2Core(rdpxV2Core).sync();\n\n    emit LogAssetsTransfered(tokenABalance, tokenBBalance, tokenA, tokenB);\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RecoveredERC20(address token, uint256 amount);\n  event RecoveredERC721(address token, uint256 id);\n  event LogAssetsTransfered(\n    uint256 tokenAAmount,\n    uint256 tokenBAmount,\n    address tokenAAddress,\n    address tokenBAddress\n  );\n  /*\n   **  burn tokenAmount from the recipient and send tokens to the receipient\n   */\n  event log(uint);\n}"
    },
    {
      "filename": "contracts/amo/UniV3LiquidityAmo.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { TransferHelper } from \"../libraries/TransferHelper.sol\";\nimport { IRdpxV2Core } from \"../core/IRdpxV2Core.sol\";\n\n// Uniswamp V3\nimport \"../uniswap_V3/IUniswapV3Factory.sol\";\nimport \"../uniswap_V3/libraries/TickMath.sol\";\nimport \"../uniswap_V3/libraries/LiquidityAmounts.sol\";\nimport \"../uniswap_V3/periphery/interfaces/INonfungiblePositionManager.sol\";\nimport \"../uniswap_V3/IUniswapV3Pool.sol\";\nimport \"../uniswap_V3/ISwapRouter.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\nabstract contract OracleLike {\n  function read() external view virtual returns (uint);\n\n  function uniswapPool() external view virtual returns (address);\n}\n\ncontract UniV3LiquidityAMO is AccessControl, ERC721Holder {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20WithBurn;\n\n  /* ========== STATE VARIABLES ========== */\n\n  // Uniswap v3\n  IUniswapV3Factory public univ3_factory;\n  INonfungiblePositionManager public univ3_positions;\n  ISwapRouter public univ3_router;\n\n  // Details about the AMO's uniswap positions\n  struct Position {\n    uint256 token_id;\n    address collateral_address;\n    uint128 liquidity; // the liquidity of the position\n    int24 tickLower; // the tick range of the position\n    int24 tickUpper;\n    uint24 fee_tier;\n  }\n\n  // Add liquidity param\n  struct AddLiquidityParams {\n    address _tokenA;\n    address _tokenB;\n    int24 _tickLower;\n    int24 _tickUpper;\n    uint24 _fee;\n    uint256 _amount0Desired;\n    uint256 _amount1Desired;\n    uint256 _amount0Min;\n    uint256 _amount1Min;\n  }\n\n  // Array of all Uni v3 NFT positions held by the AMO\n  Position[] public positions_array;\n\n  // Map token_id to Position\n  mapping(uint256 => Position) public positions_mapping;\n\n  // Rdpx address\n  address public rdpx;\n\n  // RdpxV2Core address\n  address public rdpxV2Core;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(address _rdpx, address _rdpxV2Core) {\n    rdpx = _rdpx;\n    rdpxV2Core = _rdpxV2Core;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    univ3_factory = IUniswapV3Factory(\n      0x1F98431c8aD98523631AE4a59f267346ea31F984\n    );\n    univ3_positions = INonfungiblePositionManager(\n      0xC36442b4a4522E871399CD717aBDD847Ab11FE88\n    );\n    univ3_router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n  }\n\n  /* ========== VIEWS ========== */\n\n  // Returns this contract's liquidity in a specific [Rdpx]-[collateral] uni v3 pool\n  function liquidityInPool(\n    address _collateral_address,\n    int24 _tickLower,\n    int24 _tickUpper,\n    uint24 _fee\n  ) public view returns (uint128) {\n    IUniswapV3Pool get_pool = IUniswapV3Pool(\n      univ3_factory.getPool(address(rdpx), _collateral_address, _fee)\n    );\n\n    // goes into the pool's positions mapping, and grabs this address's liquidity\n    (uint128 liquidity, , , , ) = get_pool.positions(\n      keccak256(abi.encodePacked(address(this), _tickLower, _tickUpper))\n    );\n    return liquidity;\n  }\n\n  // Only counts non-withdrawn positions\n  function numPositions() public view returns (uint256) {\n    return positions_array.length;\n  }\n\n  /* ========== RESTRICTED FUNCTIONS, BUT CUSTODIAN CAN CALL ========== */\n\n  // Iterate through all positions and collect fees accumulated\n  function collectFees() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint i = 0; i < positions_array.length; i++) {\n      Position memory current_position = positions_array[i];\n      INonfungiblePositionManager.CollectParams\n        memory collect_params = INonfungiblePositionManager.CollectParams(\n          current_position.token_id,\n          rdpxV2Core,\n          type(uint128).max,\n          type(uint128).max\n        );\n\n      // Send to custodian address\n      univ3_positions.collect(collect_params);\n    }\n  }\n\n  /* ---------------------------------------------------- */\n  /* ---------------------- Uni v3 ---------------------- */\n  /* ---------------------------------------------------- */\n\n  function approveTarget(\n    address _target,\n    address _token,\n    uint256 _amount,\n    bool use_safe_approve\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (use_safe_approve) {\n      // safeApprove needed for USDT and others for the first approval\n      // You need to approve 0 every time beforehand for USDT: it resets\n      TransferHelper.safeApprove(_token, _target, _amount);\n    } else {\n      IERC20WithBurn(_token).approve(_target, _amount);\n    }\n  }\n\n  // IUniswapV3Pool public current_uni_pool; // only used for mint callback; is set and accessed during execution of addLiquidity()\n  function addLiquidity(\n    AddLiquidityParams memory params\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    IERC20WithBurn(params._tokenA).transferFrom(\n      rdpxV2Core,\n      address(this),\n      params._amount0Desired\n    );\n    IERC20WithBurn(params._tokenB).transferFrom(\n      rdpxV2Core,\n      address(this),\n      params._amount1Desired\n    );\n\n    IERC20WithBurn(params._tokenA).approve(\n      address(univ3_positions),\n      params._amount0Desired\n    );\n    IERC20WithBurn(params._tokenB).approve(\n      address(univ3_positions),\n      params._amount1Desired\n    );\n\n    INonfungiblePositionManager.MintParams\n      memory mintParams = INonfungiblePositionManager.MintParams(\n        params._tokenA,\n        params._tokenB,\n        params._fee,\n        params._tickLower,\n        params._tickUpper,\n        params._amount0Desired,\n        params._amount1Desired,\n        params._amount0Min,\n        params._amount1Min,\n        address(this),\n        type(uint256).max\n      );\n\n    (uint256 tokenId, uint128 amountLiquidity, , ) = univ3_positions.mint(\n      mintParams\n    );\n\n    Position memory pos = Position(\n      tokenId,\n      params._tokenA == address(rdpx) ? params._tokenB : params._tokenA,\n      amountLiquidity,\n      params._tickLower,\n      params._tickUpper,\n      params._fee\n    );\n\n    positions_array.push(pos);\n    positions_mapping[tokenId] = pos;\n\n    // send tokens to rdpxV2Core\n    _sendTokensToRdpxV2Core(params._tokenA, params._tokenB);\n  }\n\n  function removeLiquidity(\n    uint256 positionIndex,\n    uint256 minAmount0,\n    uint256 minAmount1\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    Position memory pos = positions_array[positionIndex];\n    INonfungiblePositionManager.CollectParams\n      memory collect_params = INonfungiblePositionManager.CollectParams(\n        pos.token_id,\n        rdpxV2Core,\n        type(uint128).max,\n        type(uint128).max\n      );\n\n    (\n      ,\n      ,\n      address tokenA,\n      address tokenB,\n      ,\n      ,\n      ,\n      uint128 liquidity,\n      ,\n      ,\n      ,\n\n    ) = univ3_positions.positions(pos.token_id);\n\n    // remove liquidity\n    INonfungiblePositionManager.DecreaseLiquidityParams\n      memory decreaseLiquidityParams = INonfungiblePositionManager\n        .DecreaseLiquidityParams(\n          pos.token_id,\n          liquidity,\n          minAmount0,\n          minAmount1,\n          block.timestamp\n        );\n\n    univ3_positions.decreaseLiquidity(decreaseLiquidityParams);\n\n    univ3_positions.collect(collect_params);\n\n    univ3_positions.burn(pos.token_id);\n\n    positions_array[positionIndex] = positions_array[\n      positions_array.length - 1\n    ];\n    positions_array.pop();\n    delete positions_mapping[pos.token_id];\n\n    // send tokens to rdpxV2Core\n    _sendTokensToRdpxV2Core(tokenA, tokenB);\n\n    emit log(positions_array.length);\n    emit log(positions_mapping[pos.token_id].token_id);\n  }\n\n  // Swap tokenA into tokenB using univ3_router.ExactInputSingle()\n  // Uni V3 only\n  function swap(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee_tier,\n    uint256 _amountAtoB,\n    uint256 _amountOutMinimum,\n    uint160 _sqrtPriceLimitX96\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256) {\n    // transfer token from rdpx v2 core\n    IERC20WithBurn(_tokenA).transferFrom(\n      rdpxV2Core,\n      address(this),\n      _amountAtoB\n    );\n\n    ISwapRouter.ExactInputSingleParams memory swap_params = ISwapRouter\n      .ExactInputSingleParams(\n        _tokenA,\n        _tokenB,\n        _fee_tier,\n        address(this),\n        2105300114, // Expiration: a long time from now\n        _amountAtoB,\n        _amountOutMinimum,\n        _sqrtPriceLimitX96\n      );\n\n    // Approval\n    TransferHelper.safeApprove(_tokenA, address(univ3_router), _amountAtoB);\n\n    uint256 amountOut = univ3_router.exactInputSingle(swap_params);\n\n    _sendTokensToRdpxV2Core(_tokenA, _tokenB);\n    return amountOut;\n  }\n\n  /* ========== OWNER / GOVERNANCE FUNCTIONS ONLY ========== */\n  // Only owner or timelock can call, to limit risk\n\n  function recoverERC20(\n    address tokenAddress,\n    uint256 tokenAmount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Can only be triggered by owner or governance, not custodian\n    // Tokens are sent to the custodian, as a sort of safeguard\n    TransferHelper.safeTransfer(tokenAddress, rdpxV2Core, tokenAmount);\n\n    emit RecoveredERC20(tokenAddress, tokenAmount);\n  }\n\n  function recoverERC721(\n    address"
    }
  ]
}