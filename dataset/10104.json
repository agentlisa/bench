{
  "Title": "[M-06] debtWriteOff updates `totalFrozen` immaturely, thereby losing staker rewards",
  "Content": "_Submitted by kenzo, also found by itsmeSTYJ_\n\n`debtWriteOff` updates `totalFrozen` before withdrawing `unionToken` rewards.\nAs the borrower is overdue, this means the staker calling debtWriteOff will lose his rewards if for example `totalStaked` == `totalFrozen`.\n(Note: If the borrower would to first call `withdrawRewards`/stake/unstake before calling debtWriteOff, he would get the rewards.)\n\n#### Impact\nStaker loses rewards.\n(Or at the very least, inconsistency at rewards calculation between debtWriteOff and stake/unstake/`withdrawRewards`.)\n\n#### Proof of Concept\n`debtWriteOff` first calls `updateTotalFrozen`, and then `comptroller.withdrawRewards`: [`L710:` L712](https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L710:#L712)\n\n`updateTotalFrozen` can update `totalFrozen` to be same as `totalStaked`.\n`comptroller.withdrawRewards` calls `calculateRewardsByBlocks`: [`Comptroller.sol` L98](https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L98)\n\n`calculateRewardsByBlocks` is calculating `userManagerContract.totalStaked() - userManagerData.totalFrozen`, which can be 0 in certain cases,\n[`Comptroller.sol` L140](https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140)\n\nand passing it as the third parameter to `calculateRewards`: [`Comptroller.sol` L167](https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L167)\n\nIn `calculateRewards`, if the third parameter is 0, the user won't get any rewards.\n\n[`Comptroller.sol` L253](https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L253)\n\nSo in this scenario the user won't get any rewards after calling `debtWriteOff`.\n\nIf we were to call `updateTotalFrozen` *after* the withdrawing of the rewards, or if the staker would call `withdrawRewards` before calling `debtWriteOff`, the `totalFrozen` would not have been updated, and the user would get his rewards by calling `debtWriteOff`.\nAs I mentioned earlier, if there's a reason I'm not seeing as to why `updateTotalFrozen` is updated in `debtWriteOff` before `withdrawRewards` is called, then it is not consistent with stake/unstake/`withdrawRewards` functions.\n\nI have a created an (admittedly hacky) script to show the bug.\nIt will run two scenarios which are almost the same (based on integration/`testUserManager`.js).\nIn the first the staker will call `debtWriteOff` at some point,\nand at the second the staker will call `withdrawRewards` at the same point,\nand the test will print the difference in unionToken balance after each call.\nFile password: \"union\".\n<https://pastebin.com/xkS0PXtq>\n\n#### Tools Used\nManual analysis, hardhat.\n\n#### Recommended Mitigation Steps\nIf I am not missing anything, in `debtWriteOff` I would move the `withdrawRewards` to before `updateTotalFrozen`.\n\n[`UserManager.sol` L710:L712](https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L710:#L712)\n\n**[kingjacob (Union) acknowledged](https://github.com/code-423n4/2021-10-union-findings/issues/28)**\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/28#issuecomment-966598345):**\n > As described by the warden, the `debtWriteOff` function causes users to loose rewards, since this is a loss of yield will maintain a Med Risk severity\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-10-union",
  "Code": [
    {
      "filename": "contracts/user/UserManager.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../Controller.sol\";\nimport \"../interfaces/IAssetManager.sol\";\nimport \"../interfaces/ICreditLimitModel.sol\";\nimport \"../interfaces/IUserManager.sol\";\nimport \"../interfaces/IComptroller.sol\";\nimport \"../interfaces/IUnionToken.sol\";\nimport \"../interfaces/IDai.sol\";\nimport \"../interfaces/IUToken.sol\";\n\n/**\n * @title UserManager Contract\n * @dev Manages the Union members credit lines, and their vouchees and borrowers info.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Member {\n        bool isMember;\n        CreditLine creditLine;\n    }\n\n    //address: member address, uint256: trustAmount\n    struct CreditLine {\n        mapping(address => uint256) borrowers;\n        address[] borrowerAddresses;\n        mapping(address => uint256) stakers;\n        address[] stakerAddresses;\n        mapping(address => uint256) lockedAmount;\n    }\n\n    struct TrustInfo {\n        address[] stakerAddresses;\n        address[] borrowerAddresses;\n        uint256 effectiveCount;\n        address staker;\n        uint256 vouchingAmount;\n        uint256 stakingAmount;\n        uint256 availableStakingAmount;\n        uint256 lockedStake;\n        uint256 totalLockedStake;\n    }\n\n    uint256 public constant MAX_TRUST_LIMIT = 100;\n    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;\n    address public stakingToken;\n    address public unionToken;\n    address public assetManager;\n    IUToken public uToken;\n    ICreditLimitModel public creditLimitModel;\n    IComptroller public comptroller;\n    uint256 public newMemberFee; // New member application fee\n\n    // slither-disable-next-line constable-states\n    uint256 public override totalStaked;\n    // slither-disable-next-line constable-states\n    uint256 public override totalFrozen;\n    mapping(address => Member) private members;\n    // slither-disable-next-line uninitialized-state\n    mapping(address => uint256) public stakers; //1 user address 2 amount\n    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount\n\n    modifier onlyMember(address account) {\n        require(checkIsMember(account), \"UserManager: caller does not have the Member role\");\n        _;\n    }\n\n    modifier onlyMarketOrAdmin() {\n        require(\n            address(uToken) == msg.sender || isAdmin(msg.sender),\n            \"UserManager: caller does not the market or admin\"\n        );\n        _;\n    }\n\n    /**\n     *  @dev Update new credit limit model event\n     *  @param newCreditLimitModel New credit limit model address\n     */\n    event LogNewCreditLimitModel(address newCreditLimitModel);\n\n    /**\n     *  @dev Add new member event\n     *  @param member New member address\n     */\n    event LogAddMember(address member);\n\n    /**\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /**\n     *  @dev New member application event\n     *  @param account New member's voucher address\n     *  @param borrower New member address\n     */\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Cancel vouching for other member event\n     *  @param account New member's voucher address\n     *  @param borrower The address gets vouched for\n     */\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Stake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev Unstake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to unstake\n     */\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev DebtWriteOff event\n     *  @param staker The staker's address\n     *  @param borrower The borrower's address\n     *  @param amount The amount of write off\n     */\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address creditLimitModel_,\n        address comptroller_,\n        address admin_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        _setCreditLimitModel(creditLimitModel_);\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 10**18; // Set the default membership fee\n    }\n\n    function setUToken(address uToken_) public onlyAdmin {\n        uToken = IUToken(uToken_);\n    }\n\n    function setNewMemberFee(uint256 amount) public onlyAdmin {\n        newMemberFee = amount;\n    }\n\n    /**\n     *  @dev Change the credit limit model\n     *  Accept claims only from the admin\n     *  @param newCreditLimitModel New credit limit model address\n     */\n    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {\n        _setCreditLimitModel(newCreditLimitModel);\n    }\n\n    function _setCreditLimitModel(address newCreditLimitModel) private {\n        require(\n            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),\n            \"MemberMnager: new model is not a creditLimitModel\"\n        );\n        creditLimitModel = ICreditLimitModel(newCreditLimitModel);\n\n        emit LogNewCreditLimitModel(newCreditLimitModel);\n    }\n\n    /**\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     */\n    function checkIsMember(address account) public view override returns (bool) {\n        return members[account].isMember;\n    }\n\n    /**\n     *  @dev Get member borrowerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getBorrowerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.borrowerAddresses;\n    }\n\n    /**\n     *  @dev Get member stakerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getStakerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.stakerAddresses;\n    }\n\n    /**\n     *  @dev Get member backer asset\n     *  @param account Member address\n     *  @param borrower Borrower address\n     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount\n     */\n    function getBorrowerAsset(address account, address borrower)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.borrowers[borrower];\n        lockedStake = getLockedStake(account, borrower);\n        vouchingAmount = getVouchingAmount(account, borrower);\n    }\n\n    /**\n     *  @dev Get member stakers asset\n     *  @param account Member address\n     *  @param staker Staker address\n     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake\n     */\n    function getStakerAsset(address account, address staker)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.stakers[staker];\n        lockedStake = getLockedStake(staker, account);\n        vouchingAmount = getVouchingAmount(staker, account);\n    }\n\n    /**\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     */\n    function getLockedStake(address staker, address borrower) public view returns (uint256) {\n        return members[staker].creditLine.lockedAmount[borrower];\n    }\n\n    /**\n     *  @dev Get the user's locked stake from all his backed loans\n     *  @param staker Staker address\n     *  @return LockedStake\n     */\n    function getTotalLockedStake(address staker) public view override returns (uint256) {\n        uint256 totalLockedStake = 0;\n        uint256 stakingAmount = stakers[staker];\n        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        address borrower;\n        for (uint256 i = 0; i < borrowerAddresses.length; i++) {\n            borrower = borrowerAddresses[i];\n            totalLockedStake += getLockedStake(staker, borrower);\n        }\n\n        if (stakingAmount >= totalLockedStake) {\n            return totalLockedStake;\n        } else {\n            return stakingAmount;\n        }\n    }\n\n    /**\n     *  @dev Get staker's defaulted / frozen staked token amount\n     *  @param staker Staker address\n     *  @return Frozen token amount\n     */\n    function getTotalFrozenAmount(address staker) public view override returns (uint256) {\n        TrustInfo memory trustInfo;\n        uint256 totalFrozenAmount = 0;\n        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        trustInfo.stakingAmount = stakers[staker];\n\n        address borrower;\n        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {\n            borrower = trustInfo.borrowerAddresses[i];\n            if (uToken.checkIsOverdue(borrower)) {\n                totalFrozenAmount += getLockedStake(staker, borrower);\n            }\n        }\n\n        if (trustInfo.stakingAmount >= totalFrozenAmount) {\n            return totalFrozenAmount;\n        } else {\n            return trustInfo.stakingAmount;\n        }\n    }\n\n    /**\n     *  @dev Get the member's available credit line\n     *  @param borrower Member address\n     *  @return Credit line amount\n     */\n    function getCreditLimit(address borrower) public view override returns (int256) {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        // Get the number of effective vouchee, first\n        trustInfo.effectiveCount = 0;\n        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);\n\n        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit\n            if (trustInfo.vouchingAmount > 0) {\n                //availableStakingAmount is staker‘s free stake amount\n                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);\n\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount;\n                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);\n                if (trustInfo.stakingAmount <= totalLockedStake) {\n                    trustInfo.availableStakingAmount = 0;\n                } else {\n                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;\n                }\n\n                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n\n                require(\n                    trustInfo.vouchingAmount >= trustInfo.lockedStake,\n                    \"UserManager: vouchingAmount or lockedStake data error\"\n                );\n\n                //The actual effective guarantee amount cannot exceed availableStakingAmount,\n                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {\n                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;\n                } else {\n                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {\n                        limits[trustInfo.effectiveCount] = 0;\n                    } else {\n                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;\n                    }\n                }\n                trustInfo.effectiveCount += 1;\n            }\n        }\n\n        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);\n        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {\n            creditlimits[j] = limits[j];\n        }\n\n        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));\n    }\n\n    /**\n     *  @dev Get vouching amount\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     */\n    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {\n        uint256 totalStake = stakers[staker];\n        uint256 trustAmount = members[borrower].creditLine.stakers[staker];\n        if (trustAmount > totalStake) {\n            return totalStake;\n        } else {\n            return trustAmount;\n        }\n    }\n\n    /**\n     *  @dev Get the user's deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) public view override returns (uint256) {\n        return stakers[account];\n    }\n\n    /**\n     *  @dev Add member\n     *  Accept claims only from the admin\n     *  @param account Member address\n     */\n    function addMember(address account) public override onlyAdmin {\n        require(!checkIsMember(account), \"UserManager: address is already member\");\n        members[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /**\n     *  @dev Update the trust amount for exisitng members.\n     *  @param borrower_ Account address\n     *  @param trustAmount Trust amount\n     */\n    function updateTrust(address borrower_, uint256 trustAmount)\n        external\n        override\n        onlyMember(msg.sender)\n        whenNotPaused\n    {\n        require(borrower_ != address(0), \"borrower cannot be zero\");\n        address borrower = borrower_;\n\n        TrustInfo memory trustInfo;\n        trustInfo.staker = msg.sender;\n        require(trustInfo.staker != borrower, \"UserManager: Can't vouch for self\");\n        require(\n            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&\n                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,\n            \"UserManager: trust reach limit\"\n        );\n        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n        require(\n            trustAmount >= trustInfo.lockedStake,\n            \"UserManager: trust amount cannot be less than the locked amount \"\n        );\n        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        for (uint256 i = 0; i < borrowerCount; i++) {\n            if (trustInfo.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n            }\n        }\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        for (uint256 i = 0; i < stakerCount; i++) {\n            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {\n                stakerExist = true;\n            }\n        }\n\n        if (!borrowerExist) {\n            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);\n        }\n\n        if (!stakerExist) {\n            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);\n        }\n\n        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;\n        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;\n        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);\n    }\n\n    /**\n     *  @dev Stop vouch for other member.\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {\n        require(\n            msg.sender == staker || msg.sender == borrower,\n            \"UserManager: Accept claims only from the staker or borrower\"\n        );\n\n        require(getLockedStake(staker, borrower) == 0, \"UserManager: LockedStake is not zero\");\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        uint256 stakerIndex = 0;\n        for (uint256 i = 0; i < stakerCount; i++) {\n            if (members[borrower].creditLine.stakerAddresses[i] == staker) {\n                stakerExist = true;\n                stakerIndex = i;\n            }\n        }\n\n        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        uint256 borrowerIndex = 0;\n        for (uint256 i = 0; i < borrowerCount; i++) {\n            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n                borrowerIndex = i;\n            }\n        }\n\n        //delete address\n        if (borrowerExist) {\n            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[\n                borrowerCount - 1\n            ];\n            members[staker].creditLine.borrowerAddresses.pop();\n        }\n\n        if (stakerExist) {\n            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[\n                stakerCount - 1\n            ];\n            members[borrower].creditLine.stakerAddresses.pop();\n        }\n\n        delete members[staker].creditLine.borrowers[borrower];\n        delete members[borrower].creditLine.stakers[staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /**\n     *  @dev Apply for membership, and burn UnionToken as application fees\n     *  @param newMember New member address\n     */\n    function registerMember(address newMember) public override whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        require(!checkIsMember(newMember), \"UserManager: address is already member\");\n        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, \"UserManager: balance not enough\");\n\n        uint256 effectiveStakerNumber = 0;\n        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {\n            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];\n            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)\n                effectiveStakerNumber += 1;\n        }\n\n        require(\n            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),\n            \"UserManager: not enough effective stakers\"\n        );\n\n        members[newMember].isMember = true;\n\n        unionTokenContract.burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    function updateLockedData(\n        address borrower,\n        uint256 amount,\n        bool isBorrow\n    ) external override onlyMarketOrAdmin {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n\n        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](\n            trustInfo.stakerAddresses.length\n        );\n\n        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {\n            ICreditLimitModel.LockedInfo memory lockedInfo;\n\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);\n            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {\n                trustInfo.availableStakingAmount = 0;\n            } else {\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;\n            }\n\n            lockedInfo.staker = trustInfo.staker;\n            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;\n            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);\n            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;\n\n            lockedInfoList[i] = lockedInfo;\n        }\n\n        for (uint256 i = 0; i < lockedInfoList.length; i++) {\n            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(\n                lockedInfoList,\n                lockedInfoList[i].staker,\n                amount,\n                isBorrow\n            );\n        }\n    }\n\n    /**\n     *  @dev Stake\n     *  @param amount Amount\n     */\n    function stake(uint256 amount) public override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 balance = stakers[msg.sender];\n\n        require(balance + amount <= MAX_STAKE_AMOUNT, \"UserManager: Stake limit hit\");\n\n        stakers[msg.sender] = balance + amount;\n        totalStaked += amount;\n\n        require(\n            erc20Token.allowance(msg.sender, address(this)) >= amount,\n            \"UserManager: not enough allowance to stake\"\n        );\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        require(IAssetManager(assetManager).deposit(stakingToken, amount), \"UserManager: Deposit failed\");\n\n        emit LogStake(msg.sender, amount);\n    }\n\n    /**\n     *  @dev stakeWithPermit\n     *  @param amount Amount\n     */\n    function stakeWithPermit(\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IDai erc20Token = IDai(stakingToken);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        stake(amount);\n    }\n\n    /**\n     *  @dev Unstake\n     *  @param amount Amount\n     */\n    function unstake(uint256 amount) external override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n        uint256 stakingAmount = stakers[msg.sender];\n        require(\n            stakingAmount - getTotalLockedStake(msg.sender) >= amount,\n            \"UserManager: unstake balance is insufficient\"\n        );\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        stakers[msg.sender] = stakingAmount - amount;\n        totalStaked -= amount;\n\n        require(\n            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),\n            \"UserManager: withdraw failed\"\n        );\n\n        erc20Token.safeTransfer(msg.sender, amount);\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);\n        require(rewards > 0, \"UserManager: not enough rewards\");\n    }\n\n    /**\n     *  @dev Repay user's loan overdue, called only from the lending market\n     *  @param account User address\n     *  @param token The asset token repaying to\n     *  @param lastRepay Last repay block number\n     */\n    function repayLoanOverdue(\n        address account,\n        address token,\n        uint256 lastRepay\n    ) external override whenNotPaused onlyMarketOrAdmin {\n        address[] memory stakerAddresses = getStakerAddresses(account);\n        for (uint256 i = 0; i < stakerAddresses.length; i++) {\n            address staker = stakerAddresses[i];\n            (, , uint256 lockedStake) = getStakerAsset(account, staker);\n\n            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);\n        }\n    }\n\n    //Only supports sumOfTrust\n    function debtWriteOff(address borrower, uint256 amount) public {\n        require(amount > 0, \"UserManager: amount can not be zero\");\n        require(totalStaked >= amount, \"UserManager: amount exceeds the totalStaked\");\n        require(uToken.checkIsOverdue(borrower), \"UserManager: only call when borrower is overdue\");\n        uint256 lockedAmount = getLockedStake(msg.sender, borrower);\n        require(lockedAmount >= amount, \"UserManager: amount exceeds the locked amount\");\n\n        _updateTotalFrozen(borrower, true);\n        require(totalFrozen >= amount, \"UserManager: amount exceeds the totalFrozen\");\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge\n\n        stakers[msg.sender] -= amount;\n        totalStaked -= amount;\n        totalFrozen -= amount;\n        if (memberFrozen[borrower] >= amount) {\n            memberFrozen[borrower] -= amount;\n        } else {\n            memberFrozen[borrower] = 0;\n        }\n        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;\n        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];\n        uint256 newTrustAmount = trustAmount - amount;\n        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;\n        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;\n        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);\n        uToken.debtWriteOff(borrower, amount);\n        emit LogDebtWriteOff(msg.sender, borrower, amount);\n    }\n\n    /**\n     *  @dev Update total frozen\n     *  @param account borrower address\n     *  @param isOverdue account is overdue\n     */\n    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {\n        require(totalStaked >= totalFrozen, \"UserManager: total stake amount error\");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        _updateTotalFrozen(account, isOverdue);\n    }\n\n    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)\n        external\n        override\n        onlyMarketOrAdmin\n        whenNotPaused\n    {\n        require(accounts.length == isOverdues.length, \"UserManager: params length error\");\n        require(totalStaked >= totalFrozen, \"UserManager: total stake amount error\");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        for (uint256 i = 0; i < accounts.length; i++) {\n            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);\n        }\n    }\n\n    function _updateTotalFrozen(address account, bool isOverdue) private {\n        if (isOverdue) {\n            //isOverdue = true, user overdue needs to increase totalFrozen\n\n            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated\n            uint256 amount;\n            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {\n                address staker = members[account].creditLine.stakerAddresses[i];\n                uint256 lockedStake = getLockedStake(staker, account);\n                amount += lockedStake;\n            }\n\n            if (memberFrozen[account] == 0) {\n                //I haven’t updated the frozen amount about this borrower before, just increase the amount directly\n                totalFrozen += amount;\n            } else {\n                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.\n                totalFrozen = totalFrozen + amount - memberFrozen[account];\n            }\n            //Record the increased value of this borrower this time\n            memberFrozen[account] = amount;\n        } else {\n            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal\n            if (totalFrozen > memberFrozen[account]) {\n                //Minus the frozen amount added last time\n                totalFrozen -= memberFrozen[account];\n            } else {\n                totalFrozen = 0;\n            }\n            memberFrozen[account] = 0;\n        }\n    }\n\n    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i < borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks >= blocks) {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);\n                } else {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n\n    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i < borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks >= blocks) {\n                    totalFrozenCoinAge += lockedStake * blocks;\n                } else {\n                    totalFrozenCoinAge += lockedStake * pastBlocks;\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n}"
    },
    {
      "filename": "contracts/token/Comptroller.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../Controller.sol\";\nimport \"../WadRayMath.sol\";\nimport \"../interfaces/IComptroller.sol\";\nimport \"../interfaces/IMarketRegistry.sol\";\nimport \"../interfaces/IUserManager.sol\";\n\n//For the time being, only the reward calculation of a single token is supported, and the contract needs to be revised after determining the reward calculation scheme of multiple tokens\ncontract Comptroller is Controller, IComptroller {\n    using WadRayMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Info {\n        uint256 frozenCoinAge;\n        uint256 updatedBlock; //last withdraw rewards block\n        uint256 inflationIndex; //last withdraw rewards inflationIndex\n        uint256 accrued; //the unionToken accrued but not yet transferred to each user\n    }\n\n    struct UserManagerData {\n        uint256 userStaked;\n        uint256 totalFrozen;\n        uint256 totalStaked;\n        uint256 userFrozen;\n        uint256 frozenCoinAge;\n        uint256 totalLocked;\n        bool isMe"
    }
  ]
}