{
  "Title": "[H01] fastTrackAuction accounts for debt incorrectly",
  "Content": "Currently, when the [system is shutdown](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L254), if there are any collateral auctions still occurring they can be ended by calling [`fastTrackAuction`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L281). This function is designed to [end the auction](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L296) and [return unsold collateral and unsettled debt](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L301) from the auction to the original SAFE owner. Notice that in english type auctions, the [unsold collateral is the initial amount](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L321), since english auctions can be terminated prematurely only in the first phase, where no collateral is sold. On the contrary, fixed-discount type of auctions [sell part of the initial collateral](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L826) whenever a user calls the `buyCollateral()` function. For this reason, unsold collateral in this case can be lower than the initial amount.\n\n\nA SAFE owner will [receive back](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L301) only the amount of collateral that [was not sold, `collateralToSell`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L289). However, the debt they receive back, which is [originally taken from the SAFE when liquidation starts](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L360-L361), will end up being the [same amount as was initially taken](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L298). This means that when a SAFEâ€™s collateral auction is fast-tracked, they lose collateral but retain the same amount of debt.\n\n\nThis has the wider effect that SAFEs become even more under-collateralized than they were before. When [`processSAFE`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L304) is called, these SAFEs will artificially [increase `collateralShortfall`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L311-L314) more than they should. In the same way, the [`collateralTotalDebt`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L299) is incorrectly increased. This will have effects also in [the calculation of `redemptionAdjustedDebt`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L357) which is accounted together with `collateralShortfall` to calculate the final [`collateralCashPrice`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L359-L360). This will result in an skewed value of `collateralCashPrice`, potentially lowering the value of all coins [upon redemption](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L372-L378).\n\n\nConsider changing [line 298](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L298) to use the difference between the values of `bids[id].amountToRaise` and `bids[id].raisedAmount` in place of `amountToRaise`. These values may need to be fetched with the [other auction parameters](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L288-L291), since auction data will be [deleted](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L313) within [the call to `terminateAuctionPrematurely`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L296). This will correct the issue of `debt_` being too high on [line 301](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L301), which currently causes the liquidated SAFE to receive [the same `.generatedDebt` as when it started](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L490), even when an auction has sold some collateral. Note that this problem also results in erroneous accounting for the [`debtBalance` of `AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L499-L501) and [`globalUnbackedDebt`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L503-L505).\n\n\n***Update**: Fixed in [pull request #74.](https://github.com/reflexer-labs/geb/pull/74/files)*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/GlobalSettlement.sol",
      "content": "/// GlobalSettlement.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n// Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract SAFEEngineLike {\n    function coinBalance(address) virtual public view returns (uint256);\n    function collateralTypes(bytes32) virtual public view returns (\n        uint256 debtAmount,        // [wad]\n        uint256 accumulatedRate,   // [ray]\n        uint256 safetyPrice,       // [ray]\n        uint256 debtCeiling,       // [rad]\n        uint256 debtFloor,         // [rad]\n        uint256 liquidationPrice   // [ray]\n    );\n    function safes(bytes32,address) virtual public view returns (\n        uint256 lockedCollateral, // [wad]\n        uint256 generatedDebt     // [wad]\n    );\n    function globalDebt() virtual public returns (uint256);\n    function transferInternalCoins(address src, address dst, uint256 rad) virtual external;\n    function approveSAFEModification(address) virtual external;\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) virtual external;\n    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address safe, address collateralSource, address debtDestination, int256 deltaCollateral, int256 deltaDebt) virtual external;\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint256 rad) virtual external;\n    function disableContract() virtual external;\n}\nabstract contract LiquidationEngineLike {\n    function collateralTypes(bytes32) virtual public view returns (\n        address collateralAuctionHouse,\n        uint256 liquidationPenalty,     // [wad]\n        uint256 liquidationQuantity     // [rad]\n    );\n    function disableContract() virtual external;\n}\nabstract contract StabilityFeeTreasuryLike {\n    function disableContract() virtual external;\n}\nabstract contract AccountingEngineLike {\n    function disableContract() virtual external;\n}\nabstract contract CoinSavingsAccountLike {\n    function disableContract() virtual external;\n}\nabstract contract CollateralAuctionHouseLike {\n    function bidAmount(uint id) virtual public view returns (uint256);\n    function remainingAmountToSell(uint id) virtual public view returns (uint256);\n    function forgoneCollateralReceiver(uint id) virtual public view returns (address);\n    function amountToRaise(uint id) virtual public view returns (uint256);\n    function terminateAuctionPrematurely(uint auctionId) virtual external;\n}\nabstract contract OracleLike {\n    function read() virtual public view returns (uint256);\n}\nabstract contract OracleRelayerLike {\n    function redemptionPrice() virtual public returns (uint256);\n    function collateralTypes(bytes32) virtual public view returns (\n        OracleLike orcl,\n        uint256 safetyCRatio,\n        uint256 liquidationCRatio\n    );\n    function disableContract() virtual external;\n}\n\n/*\n    This is the Global Settlement module. It is an\n    involved, stateful process that takes place over nine steps.\n    First we freeze the system and lock the prices for each collateral type.\n    1. `shutdownSystem()`:\n        - freezes user entrypoints\n        - cancels collateral/surplus auctions\n        - starts cooldown period\n    2. `freezeCollateralType(collateralType)`:\n       - set the final price for each collateralType, reading off the price feed\n    We must process some system state before it is possible to calculate\n    the final coin / collateral price. In particular, we need to determine:\n      a. `collateralShortfall` (considers under-collateralised SAFEs)\n      b. `outstandingCoinSupply` (after including system surplus / deficit)\n    We determine (a) by processing all under-collateralised SAFEs with\n    `processSAFE`\n    3. `processSAFE(collateralType, safe)`:\n       - cancels SAFE debt\n       - any excess collateral remains\n       - backing collateral taken\n    We determine (b) by processing ongoing coin generating processes,\n    i.e. auctions. We need to ensure that auctions will not generate any\n    further coin income. In the two-way auction model this occurs when\n    all auctions are in the reverse (`decreaseSoldAmount`) phase. There are two ways\n    of ensuring this:\n    4.  i) `shutdownCooldown`: set the cooldown period to be at least as long as the\n           longest auction duration, which needs to be determined by the\n           shutdown administrator.\n           This takes a fairly predictable time to occur but with altered\n           auction dynamics due to the now varying price of the system coin.\n       ii) `fastTrackAuction`: cancel all ongoing auctions and seize the collateral.\n           This allows for faster processing at the expense of more\n           processing calls. This option allows coin holders to retrieve\n           their collateral faster.\n           `fastTrackAuction(collateralType, auctionId)`:\n            - cancel individual collateral auctions in the `increaseBidSize` (forward) phase\n            - retrieves collateral and returns coins to bidder\n            - `decreaseSoldAmount` (reverse) phase auctions can continue normally\n    Option (i), `shutdownCooldown`, is sufficient for processing the system\n    settlement but option (ii), `fastTrackAuction`, will speed it up. Both options\n    are available in this implementation, with `fastTrackAuction` being enabled on a\n    per-auction basis.\n    When a SAFE has been processed and has no debt remaining, the\n    remaining collateral can be removed.\n    5. `freeCollateral(collateralType)`:\n        - remove collateral from the caller's SAFE\n        - owner can call as needed\n    After the processing period has elapsed, we enable calculation of\n    the final price for each collateral type.\n    6. `setOutstandingCoinSupply()`:\n       - only callable after processing time period elapsed\n       - assumption that all under-collateralised SAFEs are processed\n       - fixes the total outstanding supply of coin\n       - may also require extra SAFE processing to cover system surplus\n    7. `calculateCashPrice(collateralType)`:\n        - calculate `collateralCashPrice`\n        - adjusts `collateralCashPrice` in the case of deficit / surplus\n    At this point we have computed the final price for each collateral\n    type and coin holders can now turn their coin into collateral. Each\n    unit coin can claim a fixed basket of collateral.\n    Coin holders must first `prepareCoinsForRedeeming` into a `coinBag`. Once prepared,\n    coins cannot be transferred out of the bag. More coin can be added to a bag later.\n    8. `prepareCoinsForRedeeming(coinAmount)`:\n        - put some coins into a bag in order to 'redeemCollateral'. The bigger the bag, the more collateral the user can claim.\n    9. `redeemCollateral(collateralType, collateralAmount)`:\n        - exchange some coin from your bag for tokens from a specific collateral type\n        - the amount of collateral available to redeem is limited by how big your bag is\n*/\n\ncontract GlobalSettlement {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"GlobalSettlement/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    SAFEEngineLike            public safeEngine;\n    LiquidationEngineLike    public liquidationEngine;\n    AccountingEngineLike     public accountingEngine;\n    OracleRelayerLike        public oracleRelayer;\n    CoinSavingsAccountLike   public coinSavingsAccount;\n    StabilityFeeTreasuryLike public stabilityFeeTreasury;\n\n    uint256  public contractEnabled;\n    uint256  public shutdownTime;\n    uint256  public shutdownCooldown;\n    uint256  public outstandingCoinSupply;                                      // [rad]\n\n    mapping (bytes32 => uint256) public finalCoinPerCollateralPrice;            // [ray]\n    mapping (bytes32 => uint256) public collateralShortfall;                    // [wad]\n    mapping (bytes32 => uint256) public collateralTotalDebt;                    // [wad]\n    mapping (bytes32 => uint256) public collateralCashPrice;                    // [ray]\n\n    mapping (address => uint256)                      public coinBag;           // [wad]\n    mapping (bytes32 => mapping (address => uint256)) public coinsUsedToRedeem; // [wad]\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event ShutdownSystem();\n    event FreezeCollateralType(bytes32 collateralType, uint finalCoinPerCollateralPrice);\n    event FastTrackAuction(bytes32 collateralType, uint256 auctionId, uint256 collateralTotalDebt);\n    event ProcessSAFE(bytes32 collateralType, address safe, uint256 collateralShortfall);\n    event FreeCollateral(bytes32 collateralType, address sender, int collateralAmount);\n    event SetOutstandingCoinSupply(uint256 outstandingCoinSupply);\n    event CalculateCashPrice(bytes32 collateralType, uint collateralCashPrice);\n    event PrepareCoinsForRedeeming(address sender, uint coinBag);\n    event RedeemCollateral(bytes32 collateralType, address sender, uint coinsAmount, uint collateralAmount);\n\n    // --- Init ---\n    constructor() public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function minimum(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n    function rmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function rdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function wdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, WAD) / y;\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        if (parameter == \"safeEngine\") safeEngine = SAFEEngineLike(data);\n        else if (parameter == \"liquidationEngine\") liquidationEngine = LiquidationEngineLike(data);\n        else if (parameter == \"accountingEngine\") accountingEngine = AccountingEngineLike(data);\n        else if (parameter == \"oracleRelayer\") oracleRelayer = OracleRelayerLike(data);\n        else if (parameter == \"coinSavingsAccount\") coinSavingsAccount = CoinSavingsAccountLike(data);\n        else if (parameter == \"stabilityFeeTreasury\") stabilityFeeTreasury = StabilityFeeTreasuryLike(data);\n        else revert(\"GlobalSettlement/modify-unrecognized-parameter\");\n        emit ModifyParameters(parameter, data);\n    }\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        if (parameter == \"shutdownCooldown\") shutdownCooldown = data;\n        else revert(\"GlobalSettlement/modify-unrecognized-parameter\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Settlement ---\n    function shutdownSystem() external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        contractEnabled = 0;\n        shutdownTime = now;\n        safeEngine.disableContract();\n        liquidationEngine.disableContract();\n        // treasury must be disabled before AccountingEngine so that all surplus is gathered in one place\n        if (address(stabilityFeeTreasury) != address(0)) {\n          stabilityFeeTreasury.disableContract();\n        }\n        accountingEngine.disableContract();\n        oracleRelayer.disableContract();\n        if (address(coinSavingsAccount) != address(0)) {\n          coinSavingsAccount.disableContract();\n        }\n        emit ShutdownSystem();\n    }\n\n    function freezeCollateralType(bytes32 collateralType) external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        require(finalCoinPerCollateralPrice[collateralType] == 0, \"GlobalSettlement/final-collateral-price-already-defined\");\n        (collateralTotalDebt[collateralType],,,,,) = safeEngine.collateralTypes(collateralType);\n        (OracleLike orcl,,) = oracleRelayer.collateralTypes(collateralType);\n        // redemptionPrice is a ray, orcl returns a wad\n        finalCoinPerCollateralPrice[collateralType] = wdivide(oracleRelayer.redemptionPrice(), uint(orcl.read()));\n        emit FreezeCollateralType(collateralType, finalCoinPerCollateralPrice[collateralType]);\n    }\n    function fastTrackAuction(bytes32 collateralType, uint256 auctionId) external {\n        require(finalCoinPerCollateralPrice[collateralType] != 0, \"GlobalSettlement/final-collateral-price-not-defined\");\n\n        (address auctionHouse_,,)    = liquidationEngine.collateralTypes(collateralType);\n        CollateralAuctionHouseLike collateralAuctionHouse = CollateralAuctionHouseLike(auctionHouse_);\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n\n        uint bidAmount                    = collateralAuctionHouse.bidAmount(auctionId);\n        uint collateralToSell             = collateralAuctionHouse.remainingAmountToSell(auctionId);\n        address forgoneCollateralReceiver = collateralAuctionHouse.forgoneCollateralReceiver(auctionId);\n        uint amountToRaise                = collateralAuctionHouse.amountToRaise(auctionId);\n\n        safeEngine.createUnbackedDebt(address(accountingEngine), address(accountingEngine), amountToRaise);\n        safeEngine.createUnbackedDebt(address(accountingEngine), address(this), bidAmount);\n        safeEngine.approveSAFEModification(address(collateralAuctionHouse));\n        collateralAuctionHouse.terminateAuctionPrematurely(auctionId);\n\n        uint debt_ = amountToRaise / accumulatedRate;\n        collateralTotalDebt[collateralType] = addition(collateralTotalDebt[collateralType], debt_);\n        require(int(collateralToSell) >= 0 && int(debt_) >= 0, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(collateralType, forgoneCollateralReceiver, address(this), address(accountingEngine), int(collateralToSell), int(debt_));\n        emit FastTrackAuction(collateralType, auctionId, collateralTotalDebt[collateralType]);\n    }\n    function processSAFE(bytes32 collateralType, address safe) external {\n        require(finalCoinPerCollateralPrice[collateralType] != 0, \"GlobalSettlement/final-collateral-price-not-defined\");\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n        (uint safeCollateral, uint safeDebt) = safeEngine.safes(collateralType, safe);\n\n        uint amountOwed = rmultiply(rmultiply(safeDebt, accumulatedRate), finalCoinPerCollateralPrice[collateralType]);\n        uint minCollateral = minimum(safeCollateral, amountOwed);\n        collateralShortfall[collateralType] = addition(\n            collateralShortfall[collateralType],\n            subtract(amountOwed, minCollateral)\n        );\n\n        require(minCollateral <= 2**255 && safeDebt <= 2**255, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(\n            collateralType,\n            safe,\n            address(this),\n            address(accountingEngine),\n            -int(minCollateral),\n            -int(safeDebt)\n        );\n\n        emit ProcessSAFE(collateralType, safe, collateralShortfall[collateralType]);\n    }\n    function freeCollateral(bytes32 collateralType) external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        (uint safeCollateral, uint safeDebt) = safeEngine.safes(collateralType, msg.sender);\n        require(safeDebt == 0, \"GlobalSettlement/art-not-zero\");\n        require(safeCollateral <= 2**255, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(\n          collateralType,\n          msg.sender,\n          msg.sender,\n          address(accountingEngine),\n          -int(safeCollateral),\n          0\n        );\n        emit FreeCollateral(collateralType, msg.sender, -int(safeCollateral));\n    }\n    function setOutstandingCoinSupply() external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        require(outstandingCoinSupply == 0, \"GlobalSettlement/outstanding-coin-supply-not-zero\");\n        require(safeEngine.coinBalance(address(accountingEngine)) == 0, \"GlobalSettlement/surplus-not-zero\");\n        require(now >= addition(shutdownTime, shutdownCooldown), \"GlobalSettlement/shutdown-cooldown-not-finished\");\n        outstandingCoinSupply = safeEngine.globalDebt();\n        emit SetOutstandingCoinSupply(outstandingCoinSupply);\n    }\n    function calculateCashPrice(bytes32 collateralType) external {\n        require(outstandingCoinSupply != 0, \"GlobalSettlement/outstanding-coin-supply-zero\");\n        require(collateralCashPrice[collateralType] == 0, \"GlobalSettlement/collateral-cash-price-already-defined\");\n\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n        uint256 redemptionAdjustedDebt = rmultiply(\n          rmultiply(collateralTotalDebt[collateralType], accumulatedRate), finalCoinPerCollateralPrice[collateralType]\n        );\n        collateralCashPrice[collateralType] = rdivide(\n          multiply(subtract(redemptionAdjustedDebt, collateralShortfall[collateralType]), RAY), outstandingCoinSupply\n        );\n        emit CalculateCashPrice(collateralType, collateralCashPrice[collateralType]);\n    }\n    function prepareCoinsForRedeeming(uint256 coinAmount) external {\n        require(outstandingCoinSupply != 0, \"GlobalSettlement/outstanding-coin-supply-zero\");\n        safeEngine.transferInternalCoins(msg.sender, address(accountingEngine), multiply(coinAmount, RAY));\n        coinBag[msg.sender] = addition(coinBag[msg.sender], coinAmount);\n        emit PrepareCoinsForRedeeming(msg.sender, coinBag[msg.sender]);\n    }\n    function redeemCollateral(bytes32 collateralType, uint coinsAmount) external {\n        require(collateralCashPrice[collateralType] != 0, \"GlobalSettlement/collateral-cash-price-not-defined\");\n        uint collateralAmount = rmultiply(coinsAmount, collateralCashPrice[collateralType]);\n        safeEngine.transferCollateral(\n          collateralType,\n          address(this),\n          msg.sender,\n          collateralAmount\n        );\n        coinsUsedToRedeem[collateralType][msg.sender] = addition(coinsUsedToRedeem[collateralType][msg.sender], coinsAmount);\n        require(coinsUsedToRedeem[collateralType][msg.sender] <= coinBag[msg.sender], \"GlobalSettlement/insufficient-bag-balance\");\n        emit RedeemCollateral(collateralType, msg.sender, coinsAmount, collateralAmount);\n    }\n}"
    },
    {
      "filename": "src/GlobalSettlement.sol",
      "content": "/// GlobalSettlement.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n// Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract SAFEEngineLike {\n    function coinBalance(address) virtual public view returns (uint256);\n    function collateralTypes(bytes32) virtual public view returns (\n        uint256 debtAmount,        // [wad]\n        uint256 accumulatedRate,   // [ray]\n        uint256 safetyPrice,       // [ray]\n        uint256 debtCeiling,       // [rad]\n        uint256 debtFloor,         // [rad]\n        uint256 liquidationPrice   // [ray]\n    );\n    function safes(bytes32,address) virtual public view returns (\n        uint256 lockedCollateral, // [wad]\n        uint256 generatedDebt     // [wad]\n    );\n    function globalDebt() virtual public returns (uint256);\n    function transferInternalCoins(address src, address dst, uint256 rad) virtual external;\n    function approveSAFEModification(address) virtual external;\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) virtual external;\n    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address safe, address collateralSource, address debtDestination, int256 deltaCollateral, int256 deltaDebt) virtual external;\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint256 rad) virtual external;\n    function disableContract() virtual external;\n}\nabstract contract LiquidationEngineLike {\n    function collateralTypes(bytes32) virtual public view returns (\n        address collateralAuctionHouse,\n        uint256 liquidationPenalty,     // [wad]\n        uint256 liquidationQuantity     // [rad]\n    );\n    function disableContract() virtual external;\n}\nabstract contract StabilityFeeTreasuryLike {\n    function disableContract() virtual external;\n}\nabstract contract AccountingEngineLike {\n    function disableContract() virtual external;\n}\nabstract contract CoinSavingsAccountLike {\n    function disableContract() virtual external;\n}\nabstract contract CollateralAuctionHouseLike {\n    function bidAmount(uint id) virtual public view returns (uint256);\n    function remainingAmountToSell(uint id) virtual public view returns (uint256);\n    function forgoneCollateralReceiver(uint id) virtual public view returns (address);\n    function amountToRaise(uint id) virtual public view returns (uint256);\n    function terminateAuctionPrematurely(uint auctionId) virtual external;\n}\nabstract contract OracleLike {\n    function read() virtual public view returns (uint256);\n}\nabstract contract OracleRelayerLike {\n    function redemptionPrice() virtual public returns (uint256);\n    function collateralTypes(bytes32) virtual public view returns (\n        OracleLike orcl,\n        uint256 safetyCRatio,\n        uint256 liquidationCRatio\n    );\n    function disableContract() virtual external;\n}\n\n/*\n    This is the Global Settlement module. It is an\n    involved, stateful process that takes place over nine steps.\n    First we freeze the system and lock the prices for each collateral type.\n    1. `shutdownSystem()`:\n        - freezes user entrypoints\n        - cancels collateral/surplus auctions\n        - starts cooldown period\n    2. `freezeCollateralType(collateralType)`:\n       - set the final price for each collateralType, reading off the price feed\n    We must process some system state before it is possible to calculate\n    the final coin / collateral price. In particular, we need to determine:\n      a. `collateralShortfall` (considers under-collateralised SAFEs)\n      b. `outstandingCoinSupply` (after including system surplus / deficit)\n    We determine (a) by processing all under-collateralised SAFEs with\n    `processSAFE`\n    3. `processSAFE(collateralType, safe)`:\n       - cancels SAFE debt\n       - any excess collateral remains\n       - backing collateral taken\n    We determine (b) by processing ongoing coin generating processes,\n    i.e. auctions. We need to ensure that auctions will not generate any\n    further coin income. In the two-way auction model this occurs when\n    all auctions are in the reverse (`decreaseSoldAmount`) phase. There are two ways\n    of ensuring this:\n    4.  i) `shutdownCooldown`: set the cooldown period to be at least as long as the\n           longest auction duration, which needs to be determined by the\n           shutdown administrator.\n           This takes a fairly predictable time to occur but with altered\n           auction dynamics due to the now varying price of the system coin.\n       ii) `fastTrackAuction`: cancel all ongoing auctions and seize the collateral.\n           This allows for faster processing at the expense of more\n           processing calls. This option allows coin holders to retrieve\n           their collateral faster.\n           `fastTrackAuction(collateralType, auctionId)`:\n            - cancel individual collateral auctions in the `increaseBidSize` (forward) phase\n            - retrieves collateral and returns coins to bidder\n            - `decreaseSoldAmount` (reverse) phase auctions can continue normally\n    Option (i), `shutdownCooldown`, is sufficient for processing the system\n    settlement but option (ii), `fastTrackAuction`, will speed it up. Both options\n    are available in this implementation, with `fastTrackAuction` being enabled on a\n    per-auction basis.\n    When a SAFE has been processed and has no debt remaining, the\n    remaining collateral can be removed.\n    5. `freeCollateral(collateralType)`:\n        - remove collateral from the caller's SAFE\n        - owner can call as needed\n    After the processing period has elapsed, we enable calculation of\n    the final price for each collateral type.\n    6. `setOutstandingCoinSupply()`:\n       - only callable after processing time period elapsed\n       - assumption that all under-collateralised SAFEs are processed\n       - fixes the total outstanding supply of coin\n       - may also require extra SAFE processing to cover system surplus\n    7. `calculateCashPrice(collateralType)`:\n        - calculate `collateralCashPrice`\n        - adjusts `collateralCashPrice` in the case of deficit / surplus\n    At this point we have computed the final price for each collateral\n    type and coin holders can now turn their coin into collateral. Each\n    unit coin can claim a fixed basket of collateral.\n    Coin holders must first `prepareCoinsForRedeeming` into a `coinBag`. Once prepared,\n    coins cannot be transferred out of the bag. More coin can be added to a bag later.\n    8. `prepareCoinsForRedeeming(coinAmount)`:\n        - put some coins into a bag in order to 'redeemCollateral'. The bigger the bag, the more collateral the user can claim.\n    9. `redeemCollateral(collateralType, collateralAmount)`:\n        - exchange some coin from your bag for tokens from a specific collateral type\n        - the amount of collateral available to redeem is limited by how big your bag is\n*/\n\ncontract GlobalSettlement {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"GlobalSettlement/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    SAFEEngineLike            public safeEngine;\n    LiquidationEngineLike    public liquidationEngine;\n    AccountingEngineLike     public accountingEngine;\n    OracleRelayerLike        public oracleRelayer;\n    CoinSavingsAccountLike   public coinSavingsAccount;\n    StabilityFeeTreasuryLike public stabilityFeeTreasury;\n\n    uint256  public contractEnabled;\n    uint256  public shutdownTime;\n    uint256  public shutdownCooldown;\n    uint256  public outstandingCoinSupply;                                      // [rad]\n\n    mapping (bytes32 => uint256) public finalCoinPerCollateralPrice;            // [ray]\n    mapping (bytes32 => uint256) public collateralShortfall;                    // [wad]\n    mapping (bytes32 => uint256) public collateralTotalDebt;                    // [wad]\n    mapping (bytes32 => uint256) public collateralCashPrice;                    // [ray]\n\n    mapping (address => uint256)                      public coinBag;           // [wad]\n    mapping (bytes32 => mapping (address => uint256)) public coinsUsedToRedeem; // [wad]\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event ShutdownSystem();\n    event FreezeCollateralType(bytes32 collateralType, uint finalCoinPerCollateralPrice);\n    event FastTrackAuction(bytes32 collateralType, uint256 auctionId, uint256 collateralTotalDebt);\n    event ProcessSAFE(bytes32 collateralType, address safe, uint256 collateralShortfall);\n    event FreeCollateral(bytes32 collateralType, address sender, int collateralAmount);\n    event SetOutstandingCoinSupply(uint256 outstandingCoinSupply);\n    event CalculateCashPrice(bytes32 collateralType, uint collateralCashPrice);\n    event PrepareCoinsForRedeeming(address sender, uint coinBag);\n    event RedeemCollateral(bytes32 collateralType, address sender, uint coinsAmount, uint collateralAmount);\n\n    // --- Init ---\n    constructor() public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function minimum(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n    function rmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function rdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function wdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, WAD) / y;\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        if (parameter == \"safeEngine\") safeEngine = SAFEEngineLike(data);\n        else if (parameter == \"liquidationEngine\") liquidationEngine = LiquidationEngineLike(data);\n        else if (parameter == \"accountingEngine\") accountingEngine = AccountingEngineLike(data);\n        else if (parameter == \"oracleRelayer\") oracleRelayer = OracleRelayerLike(data);\n        else if (parameter == \"coinSavingsAccount\") coinSavingsAccount = CoinSavingsAccountLike(data);\n        else if (parameter == \"stabilityFeeTreasury\") stabilityFeeTreasury = StabilityFeeTreasuryLike(data);\n        else revert(\"GlobalSettlement/modify-unrecognized-parameter\");\n        emit ModifyParameters(parameter, data);\n    }\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        if (parameter == \"shutdownCooldown\") shutdownCooldown = data;\n        else revert(\"GlobalSettlement/modify-unrecognized-parameter\");"
    }
  ]
}