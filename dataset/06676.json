{
  "Title": "[M-01] `HexUtils.hexStringToBytes32()` and `HexUtils.hexToAddress()` may return incorrect results",
  "Content": "\n<https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L11><br>\n<https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L68>\n\nThe `HexUtils.hexStringToBytes32()` and `HexUtils.hexToAddress()` may return incorrect results if the input data provided is not in a standard format.\n\nThis could cause the contract to behave abnormally in some scenarios or be exploited for malicious purposes.\n\n### Proof of Concept\n\nThe function `HexUtils.hexStringToBytes32(bytes memory str, uint256 idx, uint256 lastIdx)` is used to convert a hexadecimal string `str[idx...lastIndx]` to a `bytes32`.\n\nHowever, the function lacks some critical checks on the input data, resulting in the following situations:\n\n1.  If the length `lastIdx - idx` is odd, it will not revert, but will read an additional out-of-range byte `str[lastIdx]` and return it.\n2.  If the length `lstIdx - idx > 32`, it will not revert, but will discard the excess data at the beginning and return the last 32 bytes.\n3.  If the length `lstIdx - idx < 32`, it will not revert, but will pad the data with zeros at the beginning.\n\nThe following test code verifies these situations:\n\n    diff --git a/test/utils/HexUtils.js b/test/utils/HexUtils.js\n    index 296eadf..e12e11c 100644\n    --- a/test/utils/HexUtils.js\n    +++ b/test/utils/HexUtils.js\n    @@ -16,6 +16,44 @@ describe('HexUtils', () => {\n         HexUtils = await HexUtilsFactory.deploy()\n       })\n\n    +  describe.only('Special cases for hexStringToBytes32()', () => {\n    +    const hex32Bytes = '5cee339e13375638553bdf5a6e36ba80fb9f6a4f0783680884d92b558aa471da'\n    +    it('odd length 1', async () => {\n    +      let [bytes32, valid] = await HexUtils.hexStringToBytes32(\n    +        toUtf8Bytes(hex32Bytes), 0, 63,\n    +      )\n    +      expect(valid).to.equal(true)\n    +      // the last 4 bits (half byte) of hex32Bytes is out of range but read\n    +      expect(bytes32).to.equal('0x' + hex32Bytes)\n    +    })\n    +    it('odd length 2', async () => {\n    +      let [bytes32, valid] = await HexUtils.hexStringToBytes32(\n    +        toUtf8Bytes(hex32Bytes + '00'), 1, 64,\n    +      )\n    +      expect(valid).to.equal(true)\n    +      // the first half byte of '00' is out of range but read\n    +      expect(bytes32).to.equal('0x' + hex32Bytes.substring(1) + '0')\n    +    })\n    +    it('not enough length', async () => {\n    +      let [bytes32, valid] = await HexUtils.hexStringToBytes32(\n    +        toUtf8Bytes(hex32Bytes), 0, 2,\n    +      )\n    +      expect(valid).to.equal(true)\n    +      // only one byte is read, but it is expanded to 32 bytes\n    +      expect(bytes32).to.equal(\n    +        '0x000000000000000000000000000000000000000000000000000000000000005c',\n    +      )\n    +    })\n    +    it('exceed length', async () => {\n    +      let [bytes32, valid] = await HexUtils.hexStringToBytes32(\n    +        toUtf8Bytes(hex32Bytes + \"1234\"), 0, 64 + 4,\n    +      )\n    +      expect(valid).to.equal(true)\n    +      // 34 bytes is read, and returns the last 32 bytes\n    +      expect(bytes32).to.equal('0x' + hex32Bytes.substring(4) + '1234')\n    +    })\n    +  })\n    +\n       describe('hexStringToBytes32()', () => {\n         it('Converts a hex string to bytes32', async () => {\n           let [bytes32, valid] = await HexUtils.hexStringToBytes32(\n\nTest code outputs:\n\n```\n  HexUtils\n    Special cases for hexStringToBytes32()\n      ✓ odd length 1\n      ✓ odd length 2\n      ✓ not enough length\n      ✓ exceed length\n\n```\n\nSince [HexUtils.hexToAddress()](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L68) is implemented by directly calling `HexUtils.hexStringToBytes32()`, it also has similar issues.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nShould revert the function if the input length `lastIdx - idx` is odd.\n\nFor cases where the length is greater than or less than 32 (or 20)\n\n*   if the current implementation meets the requirements, the design should be detailed in a comment\n*   otherwise the function should revert if the length is not 32 (or 20)\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2023-04-ens-findings/issues/281#issuecomment-1536208794)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/utils/HexUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary HexUtils {\n    /**\n     * @dev Attempts to parse bytes32 from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexStringToBytes32(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (bytes32 r, bool valid) {\n        valid = true;\n        assembly {\n            // check that the index to read to is not past the end of the string\n            if gt(lastIdx, mload(str)) {\n                revert(0, 0)\n            }\n\n            function getHex(c) -> ascii {\n                // chars 48-57: 0-9\n                if and(gt(c, 47), lt(c, 58)) {\n                    ascii := sub(c, 48)\n                    leave\n                }\n                // chars 65-70: A-F\n                if and(gt(c, 64), lt(c, 71)) {\n                    ascii := add(sub(c, 65), 10)\n                    leave\n                }\n                // chars 97-102: a-f\n                if and(gt(c, 96), lt(c, 103)) {\n                    ascii := add(sub(c, 97), 10)\n                    leave\n                }\n                // invalid char\n                ascii := 0xff\n            }\n\n            let ptr := add(str, 32)\n            for {\n                let i := idx\n            } lt(i, lastIdx) {\n                i := add(i, 2)\n            } {\n                let byte1 := getHex(byte(0, mload(add(ptr, i))))\n                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n                // if either byte is invalid, set invalid and break loop\n                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\n                    valid := false\n                    break\n                }\n                let combined := or(shl(4, byte1), byte2)\n                r := or(shl(8, r), combined)\n            }\n        }\n    }\n\n    /**\n     * @dev Attempts to parse an address from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexToAddress(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (address, bool) {\n        if (lastIdx - idx < 40) return (address(0x0), false);\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\n        return (address(uint160(uint256(r))), valid);\n    }\n}"
    },
    {
      "filename": "contracts/utils/HexUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary HexUtils {\n    /**\n     * @dev Attempts to parse bytes32 from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexStringToBytes32(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (bytes32 r, bool valid) {\n        valid = true;\n        assembly {\n            // check that the index to read to is not past the end of the string\n            if gt(lastIdx, mload(str)) {\n                revert(0, 0)\n            }\n\n            function getHex(c) -> ascii {\n                // chars 48-57: 0-9\n                if and(gt(c, 47), lt(c, 58)) {\n                    ascii := sub(c, 48)\n                    leave\n                }\n                // chars 65-70: A-F\n                if and(gt(c, 64), lt(c, 71)) {\n                    ascii := add(sub(c, 65), 10)\n                    leave\n                }\n                // chars 97-102: a-f\n                if and(gt(c, 96), lt(c, 103)) {\n                    ascii := add(sub(c, 97), 10)\n                    leave\n                }\n                // invalid char\n                ascii := 0xff\n            }\n\n            let ptr := add(str, 32)\n            for {\n                let i := idx\n            } lt(i, lastIdx) {\n                i := add(i, 2)\n            } {\n                let byte1 := getHex(byte(0, mload(add(ptr, i))))\n                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n                // if either byte is invalid, set invalid and break loop\n                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\n                    valid := false\n                    break\n                }\n                let combined := or(shl(4, byte1), byte2)\n                r := or(shl(8, r), combined)\n            }\n        }\n    }\n\n    /**\n     * @dev Attempts to parse an address from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexToAddress(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (address, bool) {\n        if (lastIdx - idx < 40) return (address(0x0), false);\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\n        return (address(uint160(uint256(r))), valid);\n    }\n}"
    },
    {
      "filename": "contracts/utils/HexUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary HexUtils {\n    /**\n     * @dev Attempts to parse bytes32 from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexStringToBytes32(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (bytes32 r, bool valid) {\n        valid = true;\n        assembly {\n            // check that the index to read to is not past the end of the string\n            if gt(lastIdx, mload(str)) {\n                revert(0, 0)\n            }\n\n            function getHex(c) -> ascii {\n                // chars 48-57: 0-9\n                if and(gt(c, 47), lt(c, 58)) {\n                    ascii := sub(c, 48)\n                    leave\n                }\n                // chars 65-70: A-F\n                if and(gt(c, 64), lt(c, 71)) {\n                    ascii := add(sub(c, 65), 10)\n                    leave\n                }\n                // chars 97-102: a-f\n                if and(gt(c, 96), lt(c, 103)) {\n                    ascii := add(sub(c, 97), 10)\n                    leave\n                }\n                // invalid char\n                ascii := 0xff\n            }\n\n            let ptr := add(str, 32)\n            for {\n                let i := idx\n            } lt(i, lastIdx) {\n                i := add(i, 2)\n            } {\n                let byte1 := getHex(byte(0, mload(add(ptr, i))))\n                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n                // if either byte is invalid, set invalid and break loop\n                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\n                    valid := false\n                    break\n                }\n                let combined := or(shl(4, byte1), byte2)\n                r := or(shl(8, r), combined)\n            }\n        }\n    }\n\n    /**\n     * @dev Attempts to parse an address from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexToAddress(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (address, bool) {\n        if (lastIdx - idx < 40) return (address(0x0), false);\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\n        return (address(uint160(uint256(r))), valid);\n    }\n}"
    }
  ]
}