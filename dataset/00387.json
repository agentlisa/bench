{
  "Title": "H-2: Calling `requestRedeem` with `_msgSender() != owner`  will lead to user's shares being locked in the vault forever",
  "Content": "# Issue H-2: Calling `requestRedeem` with `_msgSender() != owner`  will lead to user's shares being locked in the vault forever \n\nSource: https://github.com/sherlock-audit/2024-03-amphor-judging/issues/85 \n\n## Found by \nAfriaudit, DMoore, Varun\\_05, den\\_sosnovskyi, fugazzi, sammy, zzykxx\n## Summary\nThe [`requestRedeem`](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L477) function in `AsyncSynthVault.sol` can be invoked by a user on behalf of another user, referred to as 'owner', provided that the user has been granted sufficient allowance by the 'owner'. However, this action results in a complete loss of balance.\n\n\n## Vulnerability Detail\nThe [`_createRedeemRequest`](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L721) function contains a discrepancy; it fails to update the `lastRedeemRequestId` for the user eligible to claim the shares upon maturity. Instead, it updates this identifier for the 'owner' who delegated their shares to the user. As a result, the shares become permanently locked in the vault, rendering them unclaimable by either the 'owner' or the user.\n\nThis issue unfolds as follows:\n\n1. The 'owner' deposits tokens into the vault, receiving vault shares in return.\n2. The 'owner' then delegates the allowance of all their vault shares to another user.\n3. When `epochId == 1`, this user executes The [`requestRedeem`](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L477) , specifying the 'owner''s address as `owner`, the user's address as `receiver`, and the 'owner''s share balance as `shares`.\n4. The internal function `_createRedeemRequest` is invoked, incrementing `epochs[epochId].redeemRequestBalance[receiver]` by the amount of `shares`, and setting `lastRedeemRequestId[owner] = epochId`.\n5. At `epochId == 2`, the user calls [`claimRedeem`](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L521), which in turn calls the internal function [`_claimRedeem`](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L758), with `owner` set to `_msgSender()` (i.e., the user's address) and `receiver` also set to the user's address.\n6. In this scenario, `lastRequestId` remains zero because `lastRedeemRequestId[owner] == 0` (here, `owner` refers to the user's address). Consequently, `epochs[lastRequestId].redeemRequestBalance[owner]` is also zero. Therefore, no shares are minted to the user.\n\n\nProof of Code : \n\nThe following test demonstrates the claim made above : \n\n```solidity\nfunction test_poc() external {\n        // set token balances\n        deal(vaultTested.asset(), user1.addr, 20); // owner\n\n        vm.startPrank(user1.addr);\n        IERC20Metadata(vaultTested.asset()).approve(address(vaultTested), 20);\n        // owner deposits tokens when vault is open and receives vault shares\n        vaultTested.deposit(20, user1.addr);\n        // owner delegates shares balance to user\n        IERC20Metadata(address(vaultTested)).approve(\n            user2.addr,\n            vaultTested.balanceOf(user1.addr)\n        );\n        vm.stopPrank();\n\n        // vault is closed\n        vm.prank(vaultTested.owner());\n        vaultTested.close();\n\n        // epoch = 1\n        vm.startPrank(user2.addr);\n        // user requests a redeem on behlaf of owner\n        vaultTested.requestRedeem(\n            vaultTested.balanceOf(user1.addr),\n            user2.addr,\n            user1.addr,\n            \"\"\n        );\n        // user checks the pending redeem request amount\n        assertEq(vaultTested.pendingRedeemRequest(user2.addr), 20);\n        vm.stopPrank();\n\n        vm.startPrank(vaultTested.owner());\n        IERC20Metadata(vaultTested.asset()).approve(\n            address(vaultTested),\n            type(uint256).max\n        );\n        vaultTested.settle(23); // an epoch goes by\n        vm.stopPrank();\n\n        // epoch = 2\n\n        vm.startPrank(user2.addr);\n        // user tries to claim the redeem\n        vaultTested.claimRedeem(user2.addr);\n        assertEq(IERC20Metadata(vaultTested.asset()).balanceOf(user2.addr), 0);\n        // however, token balance of user is still empty\n        vm.stopPrank();\n\n        vm.startPrank(user1.addr);\n        // owner also tries to claim the redeem\n        vaultTested.claimRedeem(user1.addr);\n        assertEq(IERC20Metadata(vaultTested.asset()).balanceOf(user1.addr), 0);\n        // however, token balance of owner is still empty\n        vm.stopPrank();\n\n        // all the balances of owner and user are zero, indicating loss of funds\n        assertEq(vaultTested.balanceOf(user1.addr), 0);\n        assertEq(IERC20Metadata(vaultTested.asset()).balanceOf(user1.addr), 0);\n        assertEq(vaultTested.balanceOf(user2.addr), 0);\n        assertEq(IERC20Metadata(vaultTested.asset()).balanceOf(user2.addr), 0);\n    }\n```\nTo run the test : \n1. Copy the above code and paste it into `TestClaimDeposit.t.sol`\n2. Run `forge test --match-test test_poc --ffi`\n\n## Impact\nThe shares are locked in the vault forever with no method for recovery by the user or the 'owner'. \n\n## Code Snippet\n\n## Tool used\n\nManual Review\nFoundry\n\n## Recommendation\nModify [`_createRedeemRequest`](https://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L721) as follows : \n```diff\n-        lastRedeemRequestId[owner] = epochId;\n+       lastRedeemRequestid[receiver] = epochId;\n\n```\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/AmphorProtocol/asynchronous-vault/pull/103.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/244",
  "Code": [
    {
      "filename": "asynchronous-vault/src/AsyncSynthVault.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {\n    IERC7540,\n    IERC165,\n    IERC7540Redeem,\n    IERC7540Deposit\n} from \"./interfaces/IERC7540.sol\";\nimport { ERC7540Receiver } from \"./interfaces/ERC7540Receiver.sol\";\nimport { IERC20, SafeERC20, Math, PermitParams } from \"./SyncSynthVault.sol\";\n\nimport { SyncSynthVault } from \"./SyncSynthVault.sol\";\n\n/**\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%=::::::=%@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*=#=--=*=*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:*=    =#:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*-.    .-*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*        *@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@.         .@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*  Amphor  *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*==========#@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@+==========*@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@*   ASync   *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@%  Vault  %@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@=        +@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%       %@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@=      =@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@%     .@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@=    =@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@%----%@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%+:::::+%@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@########@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *\n *            d8888                        888\n *           d88888                        888\n *          d88P888                        888\n *         d88P 888 88888b.d88b.  88888b.  88888b.   .d88b.  888d888\n *        d88P  888 888 \"888 \"88b 888 \"88b 888 \"88b d88\"\"88b 888P\"\n *       d88P   888 888  888  888 888  888 888  888 888  888 888\n *      d8888888888 888  888  888 888 d88P 888  888 Y88..88P 888\n *     d88P     888 888  888  888 88888P\"  888  888  \"Y88P\"  888.io\n *                                888\n *                                888\n *                                888\n */\n\n/*\n * ########\n * # LIBS #\n * ########\n*/\nusing Math for uint256; // only used for `mulDiv` operations.\nusing SafeERC20 for IERC20; // `safeTransfer` and `safeTransferFrom`\n\n/*\n    This structure contains all the informations needed to let user claim their\n    request after we processed those. To avoid rounding errors we store the\ntotalSupply and totalAssets at the time of the deposit/redeem for the deposit\nand\n    the redeem. We also store the amount of assets and shares given by the user.*/\nstruct EpochData {\n    uint256 totalSupplySnapshotForRedeem;\n    uint256 totalAssetsSnapshotForRedeem;\n    uint256 totalSupplySnapshotForDeposit;\n    uint256 totalAssetsSnapshotForDeposit;\n    mapping(address => uint256) depositRequestBalance;\n    mapping(address => uint256) redeemRequestBalance;\n}\n\nstruct SettleValues {\n    uint256 lastSavedBalance;\n    uint256 fees;\n    uint256 pendingRedeem;\n    uint256 sharesToMint;\n    uint256 pendingDeposit;\n    uint256 assetsToWithdraw;\n    uint256 totalAssetsSnapshotForDeposit;\n    uint256 totalSupplySnapshotForDeposit;\n    uint256 totalAssetsSnapshotForRedeem;\n    uint256 totalSupplySnapshotForRedeem;\n}\n\nuint256 constant BPS_DIVIDER = 10_000;\nuint16 constant MAX_FEES = 3000; // 30%\n\ncontract Silo {\n    constructor(IERC20 underlying) {\n        underlying.forceApprove(msg.sender, type(uint256).max);\n    }\n}\n\ncontract AsyncSynthVault is IERC7540, SyncSynthVault {\n    /*\n     * ####################################\n     * # AMPHOR SYNTHETIC RELATED STORAGE #\n     * ####################################\n    */\n\n    // @return Amount of the perf fees applied on the positive yield.\n    uint256 public epochId;\n    Silo public pendingSilo; // to manage the pending deposits and redeems we\n        // store them in a contract whose function is to hold the assets/shares.\n    Silo public claimableSilo; // to manage the claimable deposits and redeems\n        // we\n        // store them in a contract whose function is to hold the assets/shares.\n    mapping(uint256 epochId => EpochData epoch) public epochs;\n    mapping(address user => uint256 epochId) public lastDepositRequestId;\n    mapping(address user => uint256 epochId) public lastRedeemRequestId;\n\n    /*\n     * ##########\n     * # EVENTS #\n     * ##########\n    */\n\n    event DecreaseDepositRequest(\n        uint256 indexed requestId,\n        address indexed owner,\n        uint256 indexed previousRequestedAssets,\n        uint256 newRequestedAssets\n    );\n\n    event DecreaseRedeemRequest(\n        uint256 indexed requestId,\n        address indexed owner,\n        uint256 indexed previousRequestedShares,\n        uint256 newRequestedShares\n    );\n\n    event ClaimDeposit(\n        uint256 indexed requestId,\n        address indexed owner,\n        address indexed receiver,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event ClaimRedeem(\n        uint256 indexed requestId,\n        address indexed owner,\n        address indexed receiver,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*\n     * ##########\n     * # ERRORS #\n     * ##########\n     */\n    error ExceededMaxRedeemRequest(\n        address receiver, uint256 shares, uint256 maxShares\n    );\n    error ExceededMaxDepositRequest(\n        address receiver, uint256 assets, uint256 maxDeposit\n    );\n    error MustClaimFirst(address owner);\n\n    error ReceiverFailed();\n    error NotOwner();\n    error NullRequest();\n    error ERC7540CantRequestDepositOnBehalfOf();\n    /*\n     * ##############################\n     * # AMPHOR SYNTHETIC FUNCTIONS #\n     * ##############################\n     */\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() SyncSynthVault() {\n        //_disableInitializers();\n    }\n\n    function initialize(\n        uint16 fees,\n        address owner,\n        IERC20 underlying,\n        string memory name,\n        string memory symbol\n    )\n        public\n        virtual\n        override\n        initializer\n    {\n        super.initialize(fees, owner, underlying, name, symbol);\n        epochId = 1;\n        pendingSilo = new Silo(underlying);\n        claimableSilo = new Silo(underlying);\n    }\n\n    /*\n    Since we only allow one claimable request at a time, users must claim\n        their request before making a new one. This function let users claim\n        and request a deposit in one transaction.\n    */\n    function claimAndRequestDeposit(\n        uint256 assets,\n        address receiver,\n        bytes memory data\n    )\n        external\n    {\n        _claimDeposit(receiver, receiver);\n        requestDeposit(assets, receiver, _msgSender(), data);\n    }\n\n    /*\n        Same logic as `claimAndRequestDeposit` but for redeem requests.\n    */\n    function claimAndRequestRedeem(\n        uint256 shares,\n        bytes memory data\n    )\n        external\n    {\n        address owner = _msgSender();\n        _claimRedeem(owner, owner);\n        requestRedeem(shares, owner, owner, data);\n    }\n\n    /*\n    This function is used to decrease the amount of assets requested to deposit\n    by the\n        user. It can only be called by the user who made the request.\n    */\n    function decreaseDepositRequest(uint256 assets)\n        external\n        whenClosed\n        whenNotPaused\n    {\n        address owner = _msgSender();\n        uint256 oldBalance = epochs[epochId].depositRequestBalance[owner];\n        epochs[epochId].depositRequestBalance[owner] -= assets;\n        _asset.safeTransferFrom(address(pendingSilo), owner, assets);\n\n        emit DecreaseDepositRequest(\n            epochId,\n            owner,\n            oldBalance,\n            epochs[epochId].depositRequestBalance[owner]\n        );\n    }\n\n    /*\n    This function is used to decrease the amount of shares requested to redeem\n    by the\n        user. It can only be called by the user who made the request.\n    */\n    function decreaseRedeemRequest(uint256 shares)\n        external\n        whenClosed\n        whenNotPaused\n    {\n        address owner = _msgSender();\n        uint256 oldBalance = epochs[epochId].redeemRequestBalance[owner];\n        epochs[epochId].redeemRequestBalance[owner] -= shares;\n        _update(address(pendingSilo), owner, shares);\n\n        emit DecreaseRedeemRequest(\n            epochId,\n            owner,\n            oldBalance,\n            epochs[epochId].redeemRequestBalance[owner]\n        );\n    }\n\n    /*\n     * ######################################\n     * # AMPHOR SYNTHETIC RELATED FUNCTIONS #\n     * ######################################\n    */\n\n    /**\n     * @dev The `close` function is used to close the vault.\n     * It can only be called by the owner of the contract (`onlyOwner`\n     * modifier).\n     */\n    function close() external override onlyOwner {\n        if (!vaultIsOpen) revert VaultIsClosed();\n\n        if (totalAssets() == 0) revert VaultIsEmpty();\n\n        lastSavedBalance = totalAssets();\n        vaultIsOpen = false;\n        _asset.safeTransfer(owner(), lastSavedBalance);\n        emit EpochStart(block.timestamp, lastSavedBalance, totalSupply());\n    }\n\n    /**\n     * @dev The `open` function is used to open the vault.\n     * @notice The `open` function is used to end the lock period of the vault.\n     * It can only be called by the owner of the contract (`onlyOwner` modifier)\n     * and only when the vault is locked.\n     * If there are profits, the performance fees are taken and sent to the\n     * owner of the contract.\n     * @param assetReturned The underlying assets amount to be deposited into\n     * the vault.\n     */\n    function open(uint256 assetReturned)\n        external\n        override\n        onlyOwner\n        whenNotPaused\n        whenClosed\n    {\n        (uint256 newBalance,) = _settle(assetReturned);\n        vaultIsOpen = true;\n        _asset.safeTransferFrom(owner(), address(this), newBalance);\n    }\n\n    /*\n     * #################################\n     * #   Permit RELATED FUNCTIONS    #\n     * #################################\n    */\n\n    /* This function is used to claim the pending deposit and request a new one\n    in one transaction using permit signatures */\n    function claimAndRequestDepositWithPermit(\n        uint256 assets,\n        bytes memory data,\n        PermitParams calldata permitParams\n    )\n        external\n    {\n        address msgSender = _msgSender();\n        _claimDeposit(msgSender, msgSender);\n        requestDepositWithPermit(assets, msgSender, data, permitParams);\n    }\n\n    /*\n    Since amphor strategies can be time sensitive, we must be able to switch\n    epoch without needing\n    to put all the funds back. Using _settle we can virtually put back the\n    funds, check how much we owe\n    to users that want to redeem and maybe take the extra funds from the deposit\n    requests.\n    \n    */\n    function settle(uint256 newSavedBalance) external {\n        (uint256 lastSavedBalance, uint256 totalSupply) =\n            _settle(newSavedBalance);\n        lastSavedBalance = 0;\n        emit EpochStart(block.timestamp, lastSavedBalance, totalSupply);\n    }\n\n    /**\n     * @dev How many shares a users currently has waiting to be redeem.\n     *\n     */\n    function pendingRedeemRequest(address owner)\n        external\n        view\n        returns (uint256)\n    {\n        return epochs[epochId].redeemRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many shares are  virtually waiting for the user to be redeemed\n     * via\n     * the `claimRedeem` function.\n     */\n    function claimableRedeemRequest(address owner)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        return isCurrentEpoch(lastRequestId)\n            ? 0\n            : epochs[lastRequestId].redeemRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are currently waiting to be deposited for the user.\n     */\n    function pendingDepositRequest(address owner)\n        external\n        view\n        returns (uint256 assets)\n    {\n        return epochs[epochId].depositRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are virtually waiting for the user to be deposit\n     * via the `claimDeposit` function.\n     */\n    function claimableDepositRequest(address owner)\n        external\n        view\n        returns (uint256 assets)\n    {\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        return isCurrentEpoch(lastRequestId)\n            ? 0\n            : epochs[lastRequestId].depositRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are currently waiting to be deposited for all users.\n     */\n    function totalPendingDeposits() external view returns (uint256) {\n        return vaultIsOpen ? 0 : _asset.balanceOf(address(pendingSilo));\n    }\n\n    /**\n     * @dev How many shares are  waiting to be redeemed for all users.\n     */\n    function totalPendingRedeems() external view returns (uint256) {\n        return vaultIsOpen ? 0 : balanceOf(address(pendingSilo));\n    }\n\n    function totalClaimableShares() external view returns (uint256) {\n        return balanceOf(address(claimableSilo));\n    }\n\n    function totalClaimableAssets() external view returns (uint256) {\n        return _asset.balanceOf(address(claimableSilo));\n    }\n\n    /**\n     * @dev when the vault is closed, users can only request to deposit.\n     * By doing this funds will be sent and wait in the pendingSilo.\n     * When the owner will call the `open` or `settle` function, the funds will\n     * be\n     * deposited and the minted shares will be sent to the claimableSilo. Waiting\n     * for the users to claim them.\n     */\n    function requestDeposit(\n        uint256 assets,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        public\n        whenNotPaused\n        whenClosed\n    {\n        // vault\n        if (_msgSender() != owner) {\n            revert ERC7540CantRequestDepositOnBehalfOf();\n        }\n        if (previewClaimDeposit(receiver) > 0) {\n            revert MustClaimFirst(receiver);\n        }\n\n        if (assets > maxDepositRequest(owner)) {\n            revert ExceededMaxDepositRequest(\n                receiver, assets, maxDepositRequest(owner)\n            );\n        }\n\n        _asset.safeTransferFrom(owner, address(pendingSilo), assets);\n\n        _createDepositRequest(assets, receiver, owner, data);\n    }\n\n    /**\n     * @dev when the vault is closed, users can only request to redeem.\n     * By doing this shares will be sent and wait in the pendingSilo.\n     * When the owner will call the `open` or `settle` function, the shares will\n     * be\n     * redeemed and the assets will be sent to the claimableSilo. Waiting for\n     * the\n     * users to claim them.\n     */\n    function requestRedeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        public\n        whenNotPaused\n        whenClosed\n    {\n        if (_msgSender() != owner) {\n            _spendAllowance(owner, _msgSender(), shares);\n        }\n        if (previewClaimRedeem(receiver) > 0) {\n            revert MustClaimFirst(receiver);\n        }\n        if (shares > maxRedeemRequest(owner)) {\n            revert ExceededMaxRedeemRequest(\n                receiver, shares, maxRedeemRequest(owner)\n            );\n        }\n\n        _update(owner, address(pendingSilo), shares);\n        // Create a new request\n        _createRedeemRequest(shares, receiver, owner, data);\n    }\n\n    /**\n     * @dev This function let users claim the shares we owe them after we\n     * processed their deposit request, in the _settle function.\n     */\n    function claimDeposit(address receiver)\n        public\n        whenNotPaused\n        returns (uint256 shares)\n    {\n        return _claimDeposit(_msgSender(), receiver);\n    }\n\n    /**\n     *\n     * @dev This function let users claim the assets we owe them after we\n     * processed their redeem request, in the _settle function.\n     */\n    function claimRedeem(address receiver)\n        public\n        whenNotPaused\n        returns (uint256 assets)\n    {\n        return _claimRedeem(_msgSender(), receiver);\n    }\n\n    /**\n     * @dev This funciton let user request a deposit using permit signatures.\n     */\n    function requestDepositWithPermit(\n        uint256 assets,\n        address receiver,\n        bytes memory data,\n        PermitParams calldata permitParams\n    )\n        public\n    {\n        address msgSender = _msgSender();\n        if (_asset.allowance(msgSender, address(this)) < assets) {\n            execPermit(msgSender, address(this), permitParams);\n        }\n        return requestDeposit(assets, receiver, msgSender, data);\n    }\n\n    /**\n     * @dev users can request deposit only when the vault is closed and not\n     * paused.\n     */\n    function maxDepositRequest(address) public view returns (uint256) {\n        return vaultIsOpen || paused() ? 0 : type(uint256).max;\n    }\n\n    /**\n     * @dev users can request redeem only when the vault is closed and not\n     * paused.\n     */\n    function maxRedeemRequest(address owner) public view returns (uint256) {\n        return vaultIsOpen || paused() ? 0 : balanceOf(owner);\n    }\n\n    /**\n     * @dev This function let users preview how many shares they will get if\n     * they claim their deposit request.\n     */\n    function previewClaimDeposit(address owner) public view returns (uint256) {\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n        return _convertToShares(assets, lastRequestId, Math.Rounding.Floor);\n    }\n\n    /**\n     * @dev This function let users preview how many assets they will get if\n     * they claim their redeem request.\n     */\n    function previewClaimRedeem(address owner) public view returns (uint256) {\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n        return _convertToAssets(shares, lastRequestId, Math.Rounding.Floor);\n    }\n\n    /**\n     */\n    function convertToShares(\n        uint256 assets,\n        uint256 _epochId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _convertToShares(assets, _epochId, Math.Rounding.Floor);\n    }\n\n    function convertToAssets(\n        uint256 shares,\n        uint256 _epochId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _convertToAssets(shares, _epochId, Math.Rounding.Floor);\n    }\n\n    /**\n     *\n     * Utils function to convert the shares claimable into assets. It can\n     * be used in the front end to save an rpc call.\n     */\n    function claimableDepositBalanceInAsset(address owner)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 shares = previewClaimDeposit(owner);\n        return convertToAssets(shares);\n    }\n\n    /**\n     * Using this the owner can know if he will have to send money to the\n     * claimableSilo (for users who want to leave the vault) or if he will\n     * receive money from it.\n     */\n    function previewSettle(uint256 newSavedBalance)\n        public\n        view\n        returns (\n            uint256 assetsToOwner,\n            uint256 assetsToVault,\n            SettleValues memory settleValues\n        )\n    {\n        uint256 _lastSavedBalance = lastSavedBalance;\n        _checkMaxDrawdown(_lastSavedBalance, newSavedBalance);\n\n        // calculate the fees between lastSavedBalance and newSavedBalance\n        uint256 fees = _computeFees(_lastSavedBalance, newSavedBalance);\n        uint256 totalSupply = totalSupply();\n\n        // taking fees if positive yield\n        _lastSavedBalance = newSavedBalance - fees;\n\n        address pendingSiloAddr = address(pendingSilo);\n        uint256 pendingRedeem = balanceOf(pendingSiloAddr);\n        uint256 pendingDeposit = _asset.balanceOf(pendingSiloAddr);\n\n        uint256 sharesToMint = pendingDeposit.mulDiv(\n            totalSupply + 1, _lastSavedBalance + 1, Math.Rounding.Floor\n        );\n\n        uint256 totalAssetsSnapshotForDeposit = _lastSavedBalance + 1;\n        uint256 totalSupplySnapshotForDeposit = totalSupply + 1;\n\n        uint256 assetsToWithdraw = pendingRedeem.mulDiv(\n            _lastSavedBalance + pendingDeposit + 1,\n            totalSupply + sharesToMint + 1,\n            Math.Rounding.Floor\n        );\n\n        uint256 totalAssetsSnapshotForRedeem =\n            _lastSavedBalance + pendingDeposit + 1;\n        uint256 totalSupplySnapshotForRedeem = totalSupply + sharesToMint + 1;\n\n        settleValues = SettleValues({\n            lastSavedBalance: _lastSavedBalance + fees,\n            fees: fees,\n            pendingRedeem: pendingRedeem,\n            sharesToMint: sharesToMint,\n            pendingDeposit: pendingDeposit,\n            assetsToWithdraw: assetsToWithdraw,\n            totalAssetsSnapshotForDeposit: totalAssetsSnapshotForDeposit,\n            totalSupplySnapshotForDeposit: totalSupplySnapshotForDeposit,\n            totalAssetsSnapshotForRedeem: totalAssetsSnapshotForRedeem,\n            totalSupplySnapshotForRedeem: totalSupplySnapshotForRedeem\n        });\n\n        if (pendingDeposit > assetsToWithdraw) {\n            assetsToOwner = pendingDeposit - assetsToWithdraw;\n        } else if (pendingDeposit < assetsToWithdraw) {\n            assetsToVault = assetsToWithdraw - pendingDeposit;\n        }\n    }\n\n    /**\n     * @dev see EIP\n     * @param interfaceId The interface id to check for.\n     * @return True if the contract implements the interface.\n     */\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        return interfaceId == type(IERC165).interfaceId\n            || interfaceId == type(IERC7540Redeem).interfaceId\n            || interfaceId == type(IERC7540Deposit).interfaceId;\n    }\n\n    // transfer must happen before this function is called\n    function _createDepositRequest(\n        uint256 assets,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        internal\n    {\n        epochs[epochId].depositRequestBalance[receiver] += assets;\n        if (lastDepositRequestId[receiver] != epochId) {\n            lastDepositRequestId[receiver] = epochId;\n        }\n\n        if (\n            data.length > 0\n                && ERC7540Receiver(receiver).onERC7540DepositReceived(\n                    _msgSender(), owner, epochId, data\n                ) != ERC7540Receiver.onERC7540DepositReceived.selector\n        ) revert ReceiverFailed();\n\n        emit DepositRequest(receiver, owner, epochId, _msgSender(), assets);\n    }\n\n    function _createRedeemRequest(\n        uint256 shares,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        internal\n    {\n        epochs[epochId].redeemRequestBalance[receiver] += shares;\n        lastRedeemRequestId[owner] = epochId;\n\n        if (\n            data.length > 0\n                && ERC7540Receiver(receiver).onERC7540RedeemReceived(\n                    _msgSender(), owner, epochId, data\n                ) != ERC7540Receiver.onERC7540RedeemReceived.selector\n        ) revert ReceiverFailed();\n\n        emit RedeemRequest(receiver, owner, epochId, _msgSender(), shares);\n    }\n\n    function _claimDeposit(\n        address owner,\n        address receiver\n    )\n        internal\n        returns (uint256 shares)\n    {\n        shares = previewClaimDeposit(owner);\n\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n        epochs[lastRequestId].depositRequestBalance[owner] = 0;\n        _update(address(claimableSilo), receiver, shares);\n        emit ClaimDeposit(lastRequestId, owner, receiver, assets, shares);\n    }\n\n    function _claimRedeem(\n        address owner,\n        address receiver\n    )\n        internal\n        whenNotPaused\n        returns (uint256 assets)\n    {\n        assets = previewClaimRedeem(owner);\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n        epochs[lastRequestId].redeemRequestBalance[owner] = 0;\n        _asset.safeTransferFrom(address(claimableSilo), address(this), assets);\n        _asset.transfer(receiver, assets);\n        emit ClaimRedeem(lastRequestId, owner, receiver, assets, shares);\n    }\n\n    function _settle(uint256 newSavedBalance)\n        internal\n        onlyOwner\n        whenNotPaused\n        whenClosed\n        returns (uint256, uint256)\n    {\n        (\n            uint256 assetsToOwner,\n            uint256 assetsToVault,\n            SettleValues memory settleValues\n        ) = previewSettle(newSavedBalance);\n\n        emit EpochEnd(\n            block.timestamp,\n            lastSavedBalance,\n            newSavedBalance,\n            settleValues.fees,\n            totalSupply()\n        );\n\n        // Settle the shares balance\n        _burn(address(pendingSilo), settleValues.pendingRedeem);\n        _mint(address(claimableSilo), settleValues.sharesToMint);\n\n        ///////////////////////////\n        // Settle assets balance //\n        ///////////////////////////\n        // either there are more deposits than withdrawals\n        if (settleValues.pendingDeposit > settleValues.assetsToWithdraw) {\n            _asset.safeTransferFrom(\n                address(pendingSilo), owner(), assetsToOwner\n            );\n            if (settleValues.assetsToWithdraw > 0) {\n                _asset.safeTransferFrom(\n                    address(pendingSilo),\n                    address(claimableSilo),\n                    settleValues.assetsToWithdraw\n                );\n            }\n        } else if (settleValues.pendingDeposit < settleValues.assetsToWithdraw)\n        {\n            _asset.safeTransferFrom(\n                owner(), address(claimableSilo), assetsToVault\n            );\n            if (settleValues.pendingDeposit > 0) {\n                _asset.safeTransferFrom(\n                    address(pendingSilo),\n                    address(claimableSilo),\n                    settleValues.pendingDeposit\n                );\n            }\n        } else if (settleValues.pendingDeposit > 0) {\n            // if _pendingDeposit == assetsToWithdraw AND _pendingDeposit > 0\n            // (and assetsToWithdraw > 0)\n            _asset.safeTransferFrom(\n                address(pendingSilo),\n                address(claimableSilo),\n                settleValues.assetsToWithdraw\n            );\n        }\n\n        emit Deposit(\n            address(pendingSilo),\n            address(claimableSilo),\n            settleValues.pendingDeposit,\n            settleValues.sharesToMint\n        );\n\n        emit Withdraw(\n            address(pendingSilo),\n            address(claimableSilo),\n            address(pendingSilo),\n            settleValues.assetsToWithdraw,\n            settleValues.pendingRedeem\n        );\n\n        settleValues.lastSavedBalance = settleValues.lastSavedBalance\n            - settleValues.fees + settleValues.pendingDeposit\n            - settleValues.assetsToWithdraw;\n        lastSavedBalance = settleValues.lastSavedBalance;\n\n        epochs[epochId].totalSupplySnapshotForDeposit =\n            settleValues.totalSupplySnapshotForDeposit;\n        epochs[epochId].totalAssetsSnapshotForDeposit =\n            settleValues.totalAssetsSnapshotForDeposit;\n        epochs[epochId].totalSupplySnapshotForRedeem =\n            settleValues.totalSupplySnapshotForRedeem;\n        epochs[epochId].totalAssetsSnapshotForRedeem =\n            settleValues.totalAssetsSnapshotForRedeem;\n\n        epochId++;\n\n        return (settleValues.lastSavedBalance, totalSupply());\n    }\n\n    function isCurrentEpoch(uint256 requestId) internal view returns (bool) {\n        return requestId == epochId;\n    }\n\n    function _convertToShares(\n        uint256 assets,\n        uint256 requestId,\n        Math.Rounding rounding\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        if (isCurrentEpoch(requestId)) {\n            return 0;\n        }\n        uint256 totalAssets =\n            epochs[requestId].totalAssetsSnapshotForDeposit + 1;\n        uint256 totalSupply =\n            epochs[requestId].totalSupplySnapshotForDeposit + 1;\n\n        return assets.mulDiv(totalSupply, totalAssets, rounding);\n    }\n\n    function _convertToAssets(\n        uint256 shares,\n        uint256 requestId,\n        Math.Rounding rounding\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        if (isCurrentEpoch(requestId)) {\n            return 0;\n        }\n        uint256 totalAssets = epochs[requestId].totalAssetsSnapshotForRedeem + 1;\n        uint256 totalSupply = epochs[requestId].totalSupplySnapshotForRedeem + 1;\n\n        return shares.mulDiv(totalAssets, totalSupply, rounding);\n    }\n\n    function _checkMaxDrawdown(\n        uint256 _lastSavedBalance,\n        uint256 newSavedBalance\n    )\n        internal\n        view\n    {\n        if (\n            newSavedBalance\n                < _lastSavedBalance.mulDiv(\n                    BPS_DIVIDER - _maxDrawdown, BPS_DIVIDER, Math.Rounding.Ceil\n                )\n        ) revert MaxDrawdownReached();\n    }\n\n    function _computeFees(\n        uint256 _lastSavedBalance,\n        uint256 newSavedBalance\n    )\n        internal\n        view\n        returns (uint256 fees)\n    {\n        if (newSavedBalance > _lastSavedBalance && feesInBps > 0) {\n            uint256 profits;\n            unchecked {\n                profits = newSavedBalance - _lastSavedBalance;\n            }\n            fees = (profits).mulDiv(feesInBps, BPS_DIVIDER, Math.Rounding.Floor);\n        }\n    }\n}"
    },
    {
      "filename": "asynchronous-vault/src/AsyncSynthVault.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {\n    IERC7540,\n    IERC165,\n    IERC7540Redeem,\n    IERC7540Deposit\n} from \"./interfaces/IERC7540.sol\";\nimport { ERC7540Receiver } from \"./interfaces/ERC7540Receiver.sol\";\nimport { IERC20, SafeERC20, Math, PermitParams } from \"./SyncSynthVault.sol\";\n\nimport { SyncSynthVault } from \"./SyncSynthVault.sol\";\n\n/**\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%=::::::=%@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*=#=--=*=*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:*=    =#:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*-.    .-*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*        *@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@.         .@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*  Amphor  *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*==========#@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@+==========*@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@*   ASync   *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@%  Vault  %@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@=        +@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%       %@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@=      =@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@%     .@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@=    =@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@%----%@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%+:::::+%@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@########@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *\n *            d8888                        888\n *           d88888                        888\n *          d88P888                        888\n *         d88P 888 88888b.d88b.  88888b.  88888b.   .d88b.  888d888\n *        d88P  888 888 \"888 \"88b 888 \"88b 888 \"88b d88\"\"88b 888P\"\n *       d88P   888 888  888  888 888  888 888  888 888  888 888\n *      d8888888888 888  888  888 888 d88P 888  888 Y88..88P 888\n *     d88P     888 888  888  888 88888P\"  888  888  \"Y88P\"  888.io\n *                                888\n *                                888\n *                                888\n */\n\n/*\n * ########\n * # LIBS #\n * ########\n*/\nusing Math for uint256; // only used for `mulDiv` operations.\nusing SafeERC20 for IERC20; // `safeTransfer` and `safeTransferFrom`\n\n/*\n    This structur"
    }
  ]
}