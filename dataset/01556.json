{
  "Title": "M-3: Blocklisted address can be used to lock the option token minter's fund",
  "Content": "# Issue M-3: Blocklisted address can be used to lock the option token minter's fund \n\nSource: https://github.com/sherlock-audit/2023-06-bond-judging/issues/81 \n\n## Found by \nVagner, berndartmueller, bin2chen, caventa, ctf\\_sec\n## Summary\n\nBlocklisted address can be used to lock the option token minter's fund\n\n## Vulnerability Detail\n\nWhen deploy a token via the teller contract, the contract validate that [receiver address is not address(0)](https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L139)\n\nHowever, a malicious option token creator can save a seemingly favorable strike price and pick a blocklisted address and set the blocklisted address as receiver\n\nhttps://github.com/d-xo/weird-erc20#tokens-with-blocklists\n\n> Some tokens (e.g. USDC, USDT) have a contract level admin controlled address blocklist. If an address is blocked, then transfers to and from that address are forbidden.\n\n> Malicious or compromised token owners can trap funds in a contract by adding the contract address to the blocklist. This could potentially be the result of regulatory action against the contract itself, against a single user of the contract (e.g. a Uniswap LP), or could also be a part of an extortion attempt against users of the blocked contract.\n\nthen user would see the favorable strike price and mint the option token using payout token for call option or use quote token for put option\n\nHowever, they can never exercise their option because the transaction would revert when [transferring asset to the recevier](https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L361) for call option and [transferring asset to the receiver](https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L378) for put option when exercise the option.\n\n```solidity\n\n```\n\nthe usre's fund that used to mint the option are locked\n\n## Impact\n\nBlocklisted receiver address can be used to lock the option token minter's fund\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L139\n\nhttps://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L361\n\n(https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L378\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nValid that receiver is not blacklisted when create and deploy the option token or add an expiry check, if after the expiry the receiver does not reclaim the fund, allows the option minter to burn their token in exchange for their fund\n\n\n\n## Discussion\n\n**Oighty**\n\nAgree with this issue. Checking blocklists seems challenging to handle since they could be implemented differently. The fix mentioned in  #29 , #52 , and #70 of using a pull mechanism to claim proceeds could work, but isn't a great UX from the receiver's perspective. That may be the best option though.\n\n**juntzhan**\n\nEscalate\n\nDisagree with severity, this is not a valid high:\n\n1. Users should be wary of tokens they interact with;\n2. Users are able to see if receiver is blocklisted before interacting with;\n3. It's not up to option token creator to get receiver blocklisted, even if receiver did bad things, for example, only 174 address are blacklisted by USDC till now.\n\n\n**sherlock-admin**\n\n > Escalate\n> \n> Disagree with severity, this is not a valid high:\n> \n> 1. Users should be wary of tokens they interact with;\n> 2. Users are able to see if receiver is blocklisted before interacting with;\n> 3. It's not up to option token creator to get receiver blocklisted, even if receiver did bad things, for example, only 174 address are blacklisted by USDC till now.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**sherlock-admin**\n\n> Escalate\n> \n> This should be a valid high issue\n> \n> Agree that it is possible for users are able to see if receiver is blocklisted / blacklisted before interacting with.\n> \n> But an address can be not blacklisted in the first interaction (Deploy or create), and then blacklisted in the second onwards interaction (Exercise or reclaim)\n> \n> which leads to transfer failure and leads to fund stuck in the contract\n> \n> Yes, it is not up to FixedStrikeOptionTeller to get receiver blocklisted / blacklisted. But what we need to do is how to handle if the receiver get blocklisted / blacklisted and to prevent fund stuck in the contract\n\n    You've deleted an escalation for this issue.\n\n**ctf-sec**\n\n> Users are able to see if receiver is blocklisted before interacting with;\n\nThis would be difficult for user give the current audit scope.\nOption creating process has nothing to do with receiver address.\n\nplus blocklisted receiver can lock user's fund infinitely long time.\n\n**jingyi2811**\n\nAgree that it is possible for users are able to see if receiver is blocklisted / blacklisted before interacting with.\n\nBut an address can be not blacklisted in the first interaction (Deploy or create), and then blacklisted in the second onwards interaction (Exercise or reclaim)\n\nwhich leads to transfer failure and leads to fund stuck in the contract\n\nYes, it is not up to FixedStrikeOptionTeller to get receiver blocklisted / blacklisted. But what we need to do is how to handle if the receiver get blocklisted / blacklisted and to prevent fund stuck in the contract\n\n**Oot2k**\n\nI think this is on the verge of medium and high. The worst scenario is, as mentioned above, that the receiver gets backlisted between option start and expiry. I think this is is fairly unlikely, and have not tested how easy it is to get a address blacklisted, but if this is still the case the damage is really high compared to the attack cost.\nI still think this is a valid high. (small attack cost, large damage)\n\n**juntzhan**\n\nThere is no large damage, user's funds won't be locked because the the transaction will revert, the only problem is that user won't be able to exercise option token, but there is only 50% chance that user will try to exercise.\n\nSo I think it's fair to think this is not a valid high:\n\n1. Low possibility that receiver gets backlisted between option start and expiry\n2. Small damage to user if option token won't be exercised.\n\n\n**Oighty**\n\nWe don't plan to implement a fix for this. We don't believe the increased security is worth the UX degradation. For OTLM, the user is not paying for the option token, therefore, the loss is minimal (other than opportunity cost). A bad receiver can be swapped out by the OTLM owner, or users will withdraw when they figure out that the receiver is blacklisted. If tokens are sold, a check can be made on the front-end if the receiver is blacklisted or not for specific tokens. Overall, this is an edge case as stated above. cc @0xTex \n\n**ctf-sec**\n\n> We don't plan to implement a fix for this. We don't believe the increased security is worth the UX degradation. For OTLM, the user is not paying for the option token, therefore, the loss is minimal (other than opportunity cost). A bad receiver can be swapped out by the OTLM owner, or users will withdraw when they figure out that the receiver is blacklisted. If tokens are sold, a check can be made on the front-end if the receiver is blacklisted or not for specific tokens. Overall, this is an edge case as stated above. cc @0xTex\n\nThat make sense!\n\n**ctf-sec**\n\nRecommend checking #70 before resolving the escalation :)\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this a valid medium, based on the above discussion and given the impact. \nThis does not break core functionality, not causing irreversible damage for all users. \nAgree with the Sponsor comment below. \nAdditional Sponsor comment:\n> If options are sold or reward to uses for some risk-taking activity and then the receiver prevents execution, then there would be some loss of value for the user in the aggregate. I personally don't think this is a high issue because it is possible to verify if this is the case before interacting with the token.\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [juntzhan](https://github.com/sherlock-audit/2023-06-bond-judging/issues/81/#issuecomment-1633416572): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/99",
  "Code": [
    {
      "filename": "options/src/fixed-strike/FixedStrikeOptionTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ClonesWithImmutableArgs} from \"src/lib/clones/ClonesWithImmutableArgs.sol\";\n\nimport {IFixedStrikeOptionTeller, IOptionTeller} from \"src/interfaces/IFixedStrikeOptionTeller.sol\";\nimport {FixedStrikeOptionToken} from \"src/fixed-strike/FixedStrikeOptionToken.sol\";\n\nimport {TransferHelper} from \"src/lib/TransferHelper.sol\";\nimport {FullMath} from \"src/lib/FullMath.sol\";\n\n/// @title Fixed Strike Option Teller\n/// @notice Fixed Strike Option Teller Contract\n/// @dev Option Teller contracts handle the deployment, creation, and exercise of option tokens.\n///      Option Tokens are ERC20 tokens that represent the right to buy (call) or sell (put) a fixed\n///      amount of an asset (payout token) for an amount of another asset (quote token) between two\n///      timestamps (eligible and expiry). Option Tokens are denominated in units of the payout token\n///      and are created at a 1:1 ratio for the amount of payout tokens to buy or sell.\n///      The amount of quote tokens required to exercise (call) or collateralize (put) an option token\n///      is called the strike price. Strike prices are denominated in units of the quote token.\n///      The Fixed Strike Option Teller implementation creates option tokens that have a fixed strike\n///      price that is set at the time of creation.\n///\n///      In order to create option tokens, an issuer must deploy the specific token configuration on\n///      the teller, and then provide collateral to the teller to mint option tokens. The collateral is\n///      required to guarantee that the option tokens can be exercised. The collateral required depends on\n///      the option type. For call options, the collateral required is an amount of payout tokens equivalent\n///      to the amount of option tokens being minted. For put options, the collateral required is an amount\n///      of quote tokens equivalent to the amount of option tokens being minted multipled by the strike price.\n///      As the name \"option\" suggests, the holder of an option token has the right, but not the obligation,\n///      to exercise the option token within the eligible time window. If the option token is not exercised,\n///      the designated \"receiver\" of the option token exercise proceeds can reclaim the collateral after\n///      the expiry timestamp. If an option token is exercised, the holder receives the collateral and the\n///      receiver receives the exercise proceeds.\n///\n/// @author Bond Protocol\ncontract FixedStrikeOptionTeller is IFixedStrikeOptionTeller, Auth, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n    using ClonesWithImmutableArgs for address;\n\n    /* ========== ERRORS ========== */\n\n    error Teller_NotAuthorized();\n    error Teller_TokenDoesNotExist(bytes32 optionHash);\n    error Teller_UnsupportedToken(address token);\n    error Teller_InvalidParams(uint256 index, bytes value);\n    error Teller_OptionExpired(uint48 expiry);\n    error Teller_NotEligible(uint48 eligible);\n    error Teller_NotExpired(uint48 expiry);\n    error Teller_PriceOutOfBounds();\n\n    /* ========== EVENTS ========== */\n    event WroteOption(uint256 indexed id, address indexed referrer, uint256 amount, uint256 payout);\n    event OptionTokenCreated(\n        FixedStrikeOptionToken optionToken,\n        ERC20 indexed payoutToken,\n        ERC20 quoteToken,\n        uint48 eligible,\n        uint48 indexed expiry,\n        address indexed receiver,\n        bool call,\n        uint256 strikePrice\n    );\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Fee paid to protocol when options are exercised in basis points (3 decimal places).\n    uint48 public protocolFee;\n\n    /// @notice Base value used to scale fees. 1e5 = 100%\n    uint48 public constant FEE_DECIMALS = 1e5; // one percent equals 1000.\n\n    /// @notice FixedStrikeOptionToken reference implementation (deployed on creation to clone from)\n    FixedStrikeOptionToken public immutable optionTokenImplementation;\n\n    /// @notice Minimum duration an option must be eligible to exercise (in seconds)\n    uint48 public minOptionDuration;\n\n    /// @notice Fees earned by protocol, by token\n    mapping(ERC20 => uint256) public fees;\n\n    /// @notice Fixed strike option tokens (hash of parameters to address)\n    mapping(bytes32 => FixedStrikeOptionToken) public optionTokens;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /// @param guardian_    Address of the guardian for Auth\n    /// @param authority_   Address of the authority for Auth\n    constructor(address guardian_, Authority authority_) Auth(guardian_, authority_) {\n        // Explicitly setting protocol fee to zero initially\n        protocolFee = 0;\n\n        // Set minimum option duration initially to 1 day (the absolute minimum given timestamp rounding)\n        minOptionDuration = uint48(1 days);\n\n        // Deploy option token implementation that clones proxy to\n        optionTokenImplementation = new FixedStrikeOptionToken();\n    }\n\n    /* ========== CREATE OPTION TOKENS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function deploy(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) external override nonReentrant returns (FixedStrikeOptionToken) {\n        // If eligible is zero, use current timestamp\n        if (eligible_ == 0) eligible_ = uint48(block.timestamp);\n\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        eligible_ = uint48(eligible_ / 1 days) * 1 days;\n        expiry_ = uint48(expiry_ / 1 days) * 1 days;\n\n        // Revert if eligible is in the past, we do this to avoid duplicates tokens with the same parameters otherwise\n        // Truncate block.timestamp to the nearest day for comparison\n        if (eligible_ < uint48(block.timestamp / 1 days) * 1 days)\n            revert Teller_InvalidParams(2, abi.encodePacked(eligible_));\n\n        // Revert if the difference between eligible and expiry is less than min duration or eligible is after expiry\n        // Don't need to check expiry against current timestamp since eligible is already checked\n        if (eligible_ > expiry_ || expiry_ - eligible_ < minOptionDuration)\n            revert Teller_InvalidParams(3, abi.encodePacked(expiry_));\n\n        // Revert if any addresses are zero or the tokens are not contracts\n        if (address(payoutToken_) == address(0) || address(payoutToken_).code.length == 0)\n            revert Teller_InvalidParams(0, abi.encodePacked(payoutToken_));\n        if (address(quoteToken_) == address(0) || address(quoteToken_).code.length == 0)\n            revert Teller_InvalidParams(1, abi.encodePacked(quoteToken_));\n        if (receiver_ == address(0)) revert Teller_InvalidParams(4, abi.encodePacked(receiver_));\n\n        // Revert if strike price is zero or out of bounds\n        int8 priceDecimals = _getPriceDecimals(strikePrice_, quoteToken_.decimals()); // @audit determine if this external call to provided quote token is an issue\n        if (strikePrice_ == 0 || priceDecimals > int8(9) || priceDecimals < int8(-9))\n            revert Teller_InvalidParams(6, abi.encodePacked(strikePrice_));\n\n        // Create option token if one doesn't already exist\n        // Timestamps are truncated above to give canonical version of hash\n        bytes32 optionHash = _getOptionTokenHash(\n            payoutToken_,\n            quoteToken_,\n            eligible_,\n            expiry_,\n            receiver_,\n            call_,\n            strikePrice_\n        );\n\n        FixedStrikeOptionToken optionToken = optionTokens[optionHash];\n\n        // If option token doesn't exist, deploy it\n        if (address(optionToken) == address(0)) {\n            optionToken = _deploy(\n                payoutToken_,\n                quoteToken_,\n                eligible_,\n                expiry_,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n\n            // Set the domain separator for the option token on creation to save gas on permit approvals\n            optionToken.updateDomainSeparator();\n\n            // Store option token against computed hash\n            optionTokens[optionHash] = optionToken;\n\n            // Emit event\n            emit OptionTokenCreated(\n                optionToken,\n                payoutToken_,\n                quoteToken_,\n                eligible_,\n                expiry_,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n        }\n        return optionToken;\n    }\n\n    function _deploy(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal returns (FixedStrikeOptionToken) {\n        // All data has been validated prior to entering this function\n        // Option token does not exist yet\n\n        // Get name and symbol for option token\n        (bytes32 name, bytes32 symbol) = _getNameAndSymbol(\n            payoutToken_,\n            quoteToken_,\n            expiry_,\n            call_,\n            strikePrice_\n        );\n\n        // Deploy option token\n        return\n            FixedStrikeOptionToken(\n                address(optionTokenImplementation).clone(\n                    abi.encodePacked(\n                        name,\n                        symbol,\n                        uint8(payoutToken_.decimals()),\n                        payoutToken_,\n                        quoteToken_,\n                        eligible_,\n                        expiry_,\n                        receiver_,\n                        call_,\n                        address(this),\n                        strikePrice_\n                    )\n                )\n            );\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function create(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if provided token address does not match stored token address\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Revert if expiry is in the past\n        if (uint256(expiry) < block.timestamp) revert Teller_OptionExpired(expiry);\n\n        // Transfer in collateral\n        // If call option, transfer in payout tokens equivalent to the amount of option tokens being issued\n        // If put option, transfer in quote tokens equivalent to the amount of option tokens being issued * strike price\n        if (call) {\n            // Transfer payout tokens from user\n            // Check that amount received is not less than amount expected\n            // Handles edge cases like fee-on-transfer tokens (which are not supported)\n            uint256 startBalance = payoutToken.balanceOf(address(this));\n            payoutToken.safeTransferFrom(msg.sender, address(this), amount_);\n            uint256 endBalance = payoutToken.balanceOf(address(this));\n            if (endBalance < startBalance + amount_)\n                revert Teller_UnsupportedToken(address(payoutToken));\n        } else {\n            // Calculate amount of quote tokens required to mint\n            uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\n            // Transfer quote tokens from user\n            // Check that amount received is not less than amount expected\n            // Handles edge cases like fee-on-transfer tokens (which are not supported)\n            uint256 startBalance = quoteToken.balanceOf(address(this));\n            quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n            uint256 endBalance = quoteToken.balanceOf(address(this));\n            if (endBalance < startBalance + quoteAmount)\n                revert Teller_UnsupportedToken(address(quoteToken));\n        }\n\n        // Mint new option tokens to sender\n        optionToken.mint(msg.sender, amount_);\n    }\n\n    /* ========== EXERCISE OPTION TOKENS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function exercise(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Validate that option token is eligible to be exercised\n        if (uint48(block.timestamp) < eligible) revert Teller_NotEligible(eligible);\n\n        // Validate that option token is not expired\n        if (uint48(block.timestamp) >= expiry) revert Teller_OptionExpired(expiry);\n\n        // Calculate amount of quote tokens equivalent to amount at strike price\n        uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\n        // If not receiver, require payment\n        if (msg.sender != receiver) {\n            // If call, transfer in quote tokens equivalent to the amount of option tokens being exercised * strike price\n            // If put, transfer in payout tokens equivalent to the amount of option tokens being exercised\n            if (call) {\n                // Calculate protocol fee\n                uint256 fee = (quoteAmount * protocolFee) / FEE_DECIMALS;\n                fees[quoteToken] += fee;\n\n                // Transfer proceeds from user\n                // Check balances before and after transfer to ensure that the correct amount was transferred\n                // @audit this does enable potential malicious option tokens that can't be exercised\n                // However, we view it as a \"buyer beware\" situation that can handled on the front-end\n                uint256 startBalance = quoteToken.balanceOf(address(this));\n                quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n                uint256 endBalance = quoteToken.balanceOf(address(this));\n                if (endBalance < startBalance + quoteAmount)\n                    revert Teller_UnsupportedToken(address(quoteToken));\n\n                // Transfer proceeds minus fee to receiver\n                quoteToken.safeTransfer(receiver, quoteAmount - fee);\n            } else {\n                // Calculate protocol fee (in payout tokens)\n                uint256 fee = (amount_ * protocolFee) / FEE_DECIMALS;\n                fees[payoutToken] += fee;\n\n                // Transfer proceeds from user\n                // Check balances before and after transfer to ensure that the correct amount was transferred\n                // @audit this does enable potential malicious option tokens that can't be exercised\n                // However, we view it as a \"buyer beware\" situation that can handled on the front-end\n                uint256 startBalance = payoutToken.balanceOf(address(this));\n                payoutToken.safeTransferFrom(msg.sender, address(this), amount_);\n                uint256 endBalance = payoutToken.balanceOf(address(this));\n                if (endBalance < startBalance + amount_)\n                    revert Teller_UnsupportedToken(address(payoutToken));\n\n                // Transfer proceeds minus fee to receiver\n                payoutToken.safeTransfer(receiver, amount_ - fee);\n            }\n        }\n\n        // Burn option tokens\n        optionToken.burn(msg.sender, amount_);\n\n        if (call) {\n            // Transfer payout tokens to user\n            payoutToken.safeTransfer(msg.sender, amount_);\n        } else {\n            // Transfer quote tokens to user\n            quoteToken.safeTransfer(msg.sender, quoteAmount);\n        }\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function reclaim(FixedStrikeOptionToken optionToken_) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Revert if not expired\n        if (uint48(block.timestamp) < expiry) revert Teller_NotExpired(expiry);\n\n        // Revert if caller is not receiver\n        if (msg.sender != receiver) revert Teller_NotAuthorized();\n\n        // Transfer remaining collateral to receiver\n        uint256 amount = optionToken.totalSupply();\n        if (call) {\n            payoutToken.safeTransfer(receiver, amount);\n        } else {\n            // Calculate amount of quote tokens equivalent to amount at strike price\n            uint256 quoteAmount = amount.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n            quoteToken.safeTransfer(receiver, quoteAmount);\n        }\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function exerciseCost(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external view returns (ERC20, uint256) {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // If option is a call, calculate quote tokens required to exercise\n        // If option is a put, exercise cost is the same as the option token amount in payout tokens\n        if (call) {\n            return (quoteToken, amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals()));\n        } else {\n            return (payoutToken, amount_);\n        }\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function getOptionToken(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) public view returns (FixedStrikeOptionToken) {\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        uint48 eligible = uint48(eligible_ / 1 days) * 1 days;\n        uint48 expiry = uint48(expiry_ / 1 days) * 1 days;\n\n        // Calculate a hash from the normalized inputs\n        bytes32 optionHash = _getOptionTokenHash(\n            payoutToken_,\n            quoteToken_,\n            eligible,\n            expiry,\n            receiver_,\n            call_,\n            strikePrice_\n        );\n\n        FixedStrikeOptionToken optionToken = optionTokens[optionHash];\n\n        // Revert if token does not exist\n        if (address(optionToken) == address(0)) revert Teller_TokenDoesNotExist(optionHash);\n\n        return optionToken;\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function getOptionTokenHash(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) external pure returns (bytes32) {\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        uint48 eligible = uint48(eligible_ / 1 days) * 1 days;\n        uint48 expiry = uint48(expiry_ / 1 days) * 1 days;\n\n        return\n            _getOptionTokenHash(\n                payoutToken_,\n                quoteToken_,\n                eligible,\n                expiry,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _getOptionTokenHash(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    payoutToken_,\n                    quoteToken_,\n                    eligible_,\n                    expiry_,\n                    receiver_,\n                    call_,\n                    strikePrice_\n                )\n            );\n    }\n\n    /// @notice Derive name and symbol of option token\n    function _getNameAndSymbol(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint256 expiry_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal view returns (bytes32, bytes32) {\n        // Examples\n        // WETH call option expiring on 2100-01-01 with strike price of 10_010.50 DAI would be formatted as:\n        // Name: \"WETH/DAI C 1.001e4 2100-01-01\"\n        // Symbol: \"WETH/DAI-C-21000101\"\n        //\n        // WETH put option expiring on 2100-01-01 with strike price of 10.546 DAI would be formatted as:\n        // Name: \"WETH/DAI P 1.054e1 2100-01-01\"\n        // Symbol: \"WETH/DAI-P-21000101\"\n\n        // Get the date format from the expiry timestamp.\n        // Convert a number of days into a human-readable date, courtesy of BokkyPooBah.\n        // Source: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\n        string memory yearStr;\n        string memory monthStr;\n        string memory dayStr;\n        {\n            int256 __days = int256(expiry_ / 1 days);\n\n            int256 num1 = __days + 68569 + 2440588; // 2440588 = OFFSET19700101\n            int256 num2 = (4 * num1) / 146097;\n            num1 = num1 - (146097 * num2 + 3) / 4;\n            int256 _year = (4000 * (num1 + 1)) / 1461001;\n            num1 = num1 - (1461 * _year) / 4 + 31;\n            int256 _month = (80 * num1) / 2447;\n            int256 _day = num1 - (2447 * _month) / 80;\n            num1 = _month / 11;\n            _month = _month + 2 - 12 * num1;\n            _year = 100 * (num2 - 49) + _year + num1;\n\n            yearStr = _uint2str(uint256(_year) % 10000);\n            monthStr = uint256(_month) < 10\n                ? string(abi.encodePacked(\"0\", _uint2str(uint256(_month))))\n                : _uint2str(uint256(_month));\n            dayStr = uint256(_day) < 10\n                ? string(abi.encodePacked(\"0\", _uint2str(uint256(_day))))\n                : _uint2str(uint256(_day));\n        }\n\n        // Format token symbols\n        // Symbols longer than 5 characters are truncated, min length would be 1 if tokens have no symbols, max length is 11\n        bytes memory tokenSymbols;\n        {\n            bytes memory payoutSymbol = bytes(payoutToken_.symbol());\n            if (payoutSymbol.length > 5) payoutSymbol = abi.encodePacked(bytes5(payoutSymbol));\n            bytes memory quoteSymbol = bytes(quoteToken_.symbol());\n            if (quoteSymbol.length > 5) quoteSymbol = abi.encodePacked(bytes5(quoteSymbol));\n\n            tokenSymbols = abi.encodePacked(payoutSymbol, \"/\", quoteSymbol);\n        }\n\n        // Format option type\n        bytes1 callPut = call_ ? bytes1(\"C\") : bytes1(\"P\");\n\n        // Format strike price\n        // Strike price is formatted as scientific notation to 3 significant figures\n        // Will either be 7 or 8 bytes, e.g. 1.056e1 (7) or 9.745e-2 (8)\n        bytes memory strike = _getScientificNotation(strikePrice_, quoteToken_.decimals());\n\n        // Construct name/symbol strings.\n\n        // Name is formatted as \"payoutSymbol/quoteSymbol callPut strikePrice expiry\" with the following constraints: // Name and symbol can each be at most 32 bytes since it is stored as a bytes32\n        // quoteSymbol - 5 bytes\n        // \" \" - 1 byte\n        // callPut - 1 byte\n        // \" \" - 1 byte\n        // strikePrice - 7 or 8 bytes, scientific notation to 3 significant figures, e.g. 1.056e1 (7) or 9.745e-2 (8)\n        // \" \" - 1 byte\n        // expiry - 8 bytes, YYYYMMDD\n        // Total is 30 or 31 bytes\n\n        // Symbol is formatted as \"payoutSymbol/quoteSymbol-callPut-expiry\" with the following constraints:\n        // payoutSymbol - 5 bytes\n        // \"/\" - 1 byte\n        // quoteSymbol - 5 bytes\n        // \"-\" - 1 byte\n        // callPut - 1 byte\n        // \"-\" - 1 byte\n        // expiry - 8 bytes, YYYYMMDD\n        // Total is 22 bytes\n\n        bytes32 name = bytes32(\n            abi.encodePacked(\n                tokenSymbols,\n                \" \",\n                callPut,\n                \" \",\n                strike,\n                \" \",\n                yearStr,\n                monthStr,\n                dayStr\n            )\n        );\n        bytes32 symbol = bytes32(\n            abi.encodePacked(tokenSymbols, \"-\", callPut, \"-\", yearStr, monthStr, dayStr)\n        );\n\n        return (name, symbol);\n    }\n\n    /// @notice Helper function to calculate number of price decimals in the provided price\n    /// @param price_   The price to calculate the number of decimals for\n    /// @return         The number of decimals\n    function _getPriceDecimals(uint256 price_, uint8 tokenDecimals_) internal pure returns (int8) {\n        int8 decimals;\n        while (price_ >= 10) {\n            price_ = price_ / 10;\n            decimals++;\n        }\n\n        // Subtract the stated decimals from the calculated decimals to get the relative price decimals.\n        // Required to do it this way vs. normalizing at the beginning since price decimals can be negative.\n        return decimals - int8(tokenDecimals_);\n    }\n\n    /// @notice Helper function to format a uint256 into scientific notation to 3 significant figures\n    /// @param price_           The price to format\n    /// @param tokenDecimals_   The number of decimals in the token\n    function _getScientificNotation(\n        uint256 price_,\n        uint8 tokenDecimals_\n    ) internal pure returns (bytes memory) {\n        // Get a bytes representation of the price in scientific notation to 3 significant figures.\n        // 1. Get the number of price decimals\n        int8 priceDecimals = _getPriceDecimals(price_, tokenDecimals_);\n\n        // If priceDecimals are >= 10 or <= -10, then it will be too large to fit in the byte limit\n        // However, this is already checked when an option token is deployed\n\n        // 2. Get a string of the price decimals and exponent figure\n        uint256 decimals = priceDecimals < 0\n            ? uint256(uint8(-priceDecimals))\n            : uint256(uint8(priceDecimals));\n        bytes memory decStr = bytes.concat(\"e\", bytes(_uint2str(decimals)));\n\n        // 3. Get a string of the leading digits with decimal point\n        uint8 priceMagnitude = uint8(int8(tokenDecimals_) + priceDecimals);\n        uint256 digits = price_ / (10 ** (priceMagnitude < 3 ? 0 : priceMagnitude - 3));\n        bytes memory digitStr = bytes(_uint2str(digits));\n        uint256 len = bytes(digitStr).length;\n        bytes memory leadingStr = bytes.concat(digitStr[0], \".\");\n        for (uint256 i = 1; i < len; ++i) {\n            leadingStr = bytes.concat(leadingStr, digitStr[i]);\n        }\n\n        // 4. Combine and return\n        // The bytes string should be at most 8 bytes (e.g. 1.056e-1)\n        return bytes.concat(leadingStr, decStr);\n    }\n\n    // Some fancy math to convert a uint into a string, courtesy of Provable Things.\n    // Updated to work with solc 0.8.0.\n    // https://github.com/provable-things/ethereum-api/blob/master/provableAPI_0.6.sol\n    function _uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /* ========== ADMIN & FEES ========== */\n\n    /// @inheritdoc IOptionTeller\n    function setMinOptionDuration(uint48 duration_) external override requiresAuth {\n        // Must be a minimum of 1 day due to timestamp rounding\n        if (duration_ < uint48(1 days)) revert Teller_InvalidParams(0, abi.encodePacked(duration_));\n        minOptionDuration = duration_;\n    }\n\n    /// @inheritdoc IOptionTeller\n    function setProtocolFee(uint48 fee_) external override requiresAuth {\n        if (fee_ > 5e3) revert Teller_InvalidParams(0, abi.encodePacked(fee_)); // 5% max\n        protocolFee = fee_;\n    }\n\n    /// @inheritdoc IOptionTeller\n    function claimFees(\n        ERC20[] memory tokens_,\n        address to_\n    ) external override nonReentrant requiresAuth {\n        uint256 len = tokens_.length;\n        for (uint256 i; i < len; ++i) {\n            ERC20 token = tokens_[i];\n            uint256 send = fees[token];\n\n            if (send != 0) {\n                fees[token] = 0;\n                token.safeTransfer(to_, send);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "options/src/fixed-strike/FixedStrikeOptionTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ClonesWithImmutableArgs} from \"src/lib/clones/ClonesWithImmutableArgs.sol\";\n\nimport {IFixedStrikeOptionTeller, IOptionTeller} from \"src/interfaces/IFixedStrikeOptionTeller.sol\";\nimport {FixedStrikeOptionToken} from \"src/fixed-strike/FixedStrikeOptionToken.sol\";\n\nimport {TransferHelper} from \"src/lib/TransferHelper.sol\";\nimport {FullMath} from \"src/lib/FullMath.sol\";\n\n/// @title Fixed Strike Option Teller\n/// @notice Fixed Strike Option Teller Contract\n/// @dev Option Teller contracts handle the deployment, creation, and exercise of option tokens.\n///      Option Tokens are ERC20 tokens that represent the right to buy (call) or sell (put) a fixed\n///      amount of an asset (payout token) for an amount of another asset (quote token) between two\n///      timestamps (eli"
    }
  ]
}