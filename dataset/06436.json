{
  "Title": "[H-04] `MIN_FALLBACK_RESERVE` (in `BranchBridgeAgent`) doesn't consider the actual gas consumption in ``AnyCall`` contracts, which lets the user underpay the actual cost when replenishing the execution budget",
  "Content": "\n`anyFallback` method is called by the `Anycall Executor` on the source chain in case of a failure of the function `anyExecute` on the root chain. The user has to pay for the execution gas cost for this, which is done at the end of the call. However, if there is not enough `depositedGas`, the  `anyFallback` method will be reverted, due to a revert caused by the `Anycall Executor`. This shouldn't happen since the depositor deposited at least the `MIN_FALLBACK_RESERVE` (`185_000`) in the first place.\n\nHere is the calculation for the gas used when `anyFallback` is called:\n\n```solidity\n\t//Save gas\n\tuint256 gasLeft = gasleft();\n\n\t//Get Branch Environment Execution Cost\n\tuint256 minExecCost = tx.gasprice * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft);\n\n\t//Check if sufficient balance\n\tif (minExecCost > getDeposit[_depositNonce].depositedGas) {\n\t\t_forceRevert();\n\t\treturn;\n\t}\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1063-L1072>\n\n`_forceRevert` will withdraw all of the execution budget:\n\n    \t// Withdraw all execution gas budget from anycall for tx to revert with \"no enough budget\"\n    \tif (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {}\n\nSo `Anycall Executor` will revert if there is not enough budget. This is done at:\n\n```solidity\n\tuint256 budget = executionBudget[_from];\n\trequire(budget > totalCost, \"no enough budget\");\n\texecutionBudget[_from] = budget - totalCost;\n```\n<https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L206C42-L206C58>\n\n### (1) Gas Calculation in our `anyFallback` and in ``AnyCall`` contracts:\n\nTo calculate how much the user has to pay, the following formula is used:\n\n```solidity\n\t//Get Branch Environment Execution Cost\n\tuint256 minExecCost = tx.gasprice * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft);\n```\n\nGas units are calculated as follows:\n\n - Store `gasleft()` at `initialGas` at the beginning of `anyFallback` method:\n\n```solidity\n\t//Get Initial Gas Checkpoint\n\tuint256 initialGas = gasleft();\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1233-L1234>\n\n- Nearly at the end of the method, deduct `gasleft()` from `initialGas`. This covers everything between the initial gas checkpoint and the ending gas checkpoint.\n\n```solidity\n        //Save gas\n        uint256 gasLeft = gasleft();\n\n        //Get Branch Environment Execution Cost\n        uint256 minExecCost = tx.gasprice * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft);\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1063-L1066>\n\n- Add `MIN_FALLBACK_RESERVE` which is **`185_000`**.\n\nThis overhead is supposed to cover:\n\n- **`100_000` for `anycall`**. This is extra cost required by `Anycall`.\n\n```solidity\nLine:38\t\nuint256 constant EXECUTION_OVERHEAD = 100000;\n\t.\n\t.\nLine:203\t\nuint256 gasUsed = _prevGasLeft + EXECUTION_OVERHEAD - gasleft();\n```\n\n<https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203>\n\n- **`85_000` for our fallback execution**. For example, this is used to cover the modifier `requiresExecutor` and to cover everything after the end gas checkpoint.\n\nIf we check how much this would actually cost, **we can find it nearly `70_000`**. So, `85_000` is safe enough. A PoC is also provided to prove this. However, there is an overhead of gas usage in the `Anycall` contracts that's not considered, which is different than the `100_000` extra that's required by ``AnyCall`` anyway (see above).\n\nThis means, the user is paying less than the actual cost. According to the sponsor, Bridge Agent deployer deposits the first time into `anycallConfig`, where the goal is to replenish the execution budget after use every time.\n\nThe issue leads to:\n\n1. **execution budget is decreasing over time (slow draining)** in case it has funds already.\n\n2. **anyExecute call will fail** since the calculation of the gas used in the `Anycall` contracts is bigger than the minimum reserve. In `Anycall`, this is done by the modifier `chargeDestFee`.\n\n- Modifier `chargeDestFee`:\n\n    ```solidity\n    \tmodifier chargeDestFee(address _from, uint256 _flags) {\n    \tif (_isSet(_flags, AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {\n    \t\tuint256 _prevGasLeft = gasleft();\n    \t\t_;\n    \t\tIAnycallConfig(config).chargeFeeOnDestChain(_from, _prevGasLeft);\n    \t} else {\n    \t\t_;\n    \t}\n    }\n    ```\n\n    <https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L163-L171>\n\n-  Function `chargeFeeOnDestChain`:\n\n    ```solidity\n    \tfunction chargeFeeOnDestChain(address _from, uint256 _prevGasLeft)\n    \t\texternal\n    \t\tonlyAnycallContract\n    \t{\n    \t\tif (!_isSet(mode, FREE_MODE)) {\n    \t\t\tuint256 gasUsed = _prevGasLeft + EXECUTION_OVERHEAD - gasleft();\n    \t\t\tuint256 totalCost = gasUsed * (tx.gasprice + _feeData.premium);\n    \t\t\tuint256 budget = executionBudget[_from];\n    \t\t\trequire(budget > totalCost, \"no enough budget\");\n    \t\t\texecutionBudget[_from] = budget - totalCost;\n    \t\t\t_feeData.accruedFees += uint128(totalCost);\n    \t\t}\n    \t}\n    ```\n\n    <https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203>\n\nThe gas consumption of `anyExec` method called by the MPC (in ``AnyCall``) here:\n\n```solidity\n    function anyExec(\n        address _to,\n        bytes calldata _data,\n        string calldata _appID,\n        RequestContext calldata _ctx,\n        bytes calldata _extdata\n    )\n        external\n        virtual\n        lock\n        whenNotPaused\n        chargeDestFee(_to, _ctx.flags) // <= starting from here\n        onlyMPC\n    {\n\t\t.\n\t\t.\n\t\t.\n\t\tbool success = _execute(_to, _data, _ctx, _extdata);\n\t\t.\n\t\t.\n   }\n```\n\n<https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L276>\n\n**The gas is nearly `110_000`** and is not taken into account; as proven in the PoCs.\n\n### (2) Base Fee & Input Data Fee:\n\nFrom [Ethereum yellow paper](https://ethereum.github.io/yellowpaper/paper.pdf):\n\n> `Gtransaction` - 21000 Paid for every transaction.<br>\n> `Gtxdatazero` - 4 Paid for every zero byte of data or code for a transaction.<br>\n> `Gtxdatanonzero` - 16 Paid for every non-zero byte of data or code for a transaction.\n\nSo:\n\n1. We have `21_000` as the base fee. This should be taken into account; however, it is paid by ``AnyCall`` since the TX is sent by MPC. So, we are fine here. This probably explains the overhead (`100_000`) added by `anycall`.\n\n2. Because the `anyFallback` method has bytes data to be passed, we have extra gas consumption which is not taken into account.\n\nFor every zero byte `=>` 4\n\nFor every non-zero byte `=>` 16\n\nSo generally speaking, the bigger the data is, the bigger the gas becomes. You can simply prove this by adding arbitrary data to the `anyFallback` method in the PoC #1 test below. You will also see the gas spent increases.\n\n### Summary\n\n1. `MIN_FALLBACK_RESERVE` is safe enough, without considering the `anyExec` method (check next point).\n2. The gas consumed by the `anyExec` method called by the MPC is not considered.\n3. The input data fee isn't taken into account.\n\nThere are two PoCs proving the first two points above. The third point can be proven by simply adding arbitrary data to the `anyFallback` method in the PoC #1 test.\n\n*Note: this is also applicable for `RootBridgeAgent`, which I avoided writing a separate issue for it since the code for `_payFallbackGas` is almost the same. However, those 3 statements don't exist in `RootBridgeAgent._payFallbackGas`.*\n\n```solidity\n\t//Withdraw Gas\n\tIPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), minExecCost);\n\n\t//Unwrap Gas\n\twrappedNativeToken.withdraw(minExecCost);\n\n\t//Replenish Gas\n\t_replenishGas(minExecCost);\n```\n\nSo, the gas spent is even less and `55_000` (from `155_000` in `MIN_FALLBACK_RESERVE` of `RootBridgeAgent`) is safe enough. But, the second two points are still not taken into account in `RootBridgeAgent` (see above).\n\n### Proof of Concept #1 \n\n`MIN_FALLBACK_RESERVE` is safe enough.\n\n*Note: estimation doesn't consider `anyExec` method's actual cost.*\n\n### Overview\n\nThis PoC is independent from the codebase (but uses the same code). There are two contracts simulating `BranchBridgeAgent.anyFallback`:\n\n1. **BranchBridgeAgent**, which has the code of the pre-first gas checkpoint and the post-last gas checkpoint.\n2. **BranchBridgeAgentEmpty**, which has the code of the pre-first gas checkpoint and the post-last gas checkpoint **commented out**.\n\nWe'll run the same test for both, but the difference in gas is what's at least nearly the minimum required to cover the pre-first gas checkpoint and the post-last gas checkpoint.\nIn this case here, it is `70_090` which is smaller than `85_000`. So, we are fine.\n\nHere is the output of the test:\n\n```sh\n[PASS] test_calcgas() (gas: 143835)\nLogs:\n  branchBridgeAgent.anyFallback Gas Spent => 71993\n\n[PASS] test_calcgasEmpty() (gas: 73734)\nLogs:\n  branchBridgeAgentEmpty.anyFallback Gas Spent => 1903\n\nTest result: ok. 2 passed; 0 failed; finished in 2.08ms\n```\n\n`71_993 - 1903` = `70_090`\n\n### Explanation\n\n`BranchBridgeAgent.anyFallback` method depends on the following external calls:\n\n1. `AnycallExecutor.context()`\n2. `AnycallProxy.config()`\n3. `AnycallConfig.executionBudget()`\n4. `AnycallConfig.withdraw()`\n5. `AnycallConfig.deposit()`\n6. `WETH9.withdraw()`\n7. `BranchPort.withdraw()`\n\nFor this reason, I've copied the same code from [multichain-smart-contracts](https://github.com/anyswap/multichain-smart-contracts). For `WETH9`, I've used the contract from the codebase which has minimal code. For `BranchPort`, I copied from the codebase. \n\n*Note: For libraries, unused methods were removed. This is because I couldn't submit the report, as it gave the error \"too long body\". However, it doesn't affect the gas spent*\n\nPlease note that:\n\n- **tx.gasprice** is replaced with a fixed value in the `_payFallbackGas` method, as it is not available in Foundry.\n\n- In `_replenishGas`, reading the config via `IAnycallProxy(local`AnyCall`Address).config()` is replaced with an `immediate` call for simplicity. In other words, avoiding proxy to make the PoC simpler and shorter. However, if done with proxy, the gas used would increase. So in both ways, it is in favor of the PoC.\n\n### The coded PoC\n\n- `Foundry.toml`\n\n```sh\n\t[profile.default]\n\tsolc = '0.8.17'\n\tsrc = 'solidity'\n\ttest = 'solidity/test'\n\tout = 'out'\n\tlibs = ['lib']\n\tfuzz_runs = 1000\n\toptimizer_runs = 10_000\n```\n\n- `.gitmodules`\n\n```sh\n\t[submodule \"lib/ds-test\"]\n\t\tpath = lib/ds-test\n\t\turl = https://github.com/dapphub/ds-test\n\t\tbranch = master\n\t[submodule \"lib/forge-std\"]\n\t\tpath = lib/forge-std\n\t\turl = https://github.com/brockelmore/forge-std\n\t\tbranch = master\n```\n\n- `remappings.txt`\n\n```sh\n\tds-test/=lib/ds-test/src\n\tforge-std/=lib/forge-std/src\n```\n\n- Test File:\n\n<details>\n\n```solidity\n// PoC => Maia OmniChain: gasCalculation for anyFallback in BranchBridgeAgent\npragma solidity >=0.8.4 <0.9.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\nimport {DSTest} from \"ds-test/test.sol\";\n\n// copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\n// only decimals is used\nabstract contract ERC20 {\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n\n}\n\n// copied from Solady \n// removed unused methods, because I couldn't submit the report with too long code\nlibrary SafeTransferLib {\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev Suggested gas stipend for contract receiving ETH\n    /// that disallows any storage writes.\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    /// Multiply by a small constant (e.g. 2), if needed.\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\n\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    /// Reverts upon failure.\n    ///\n    /// Note: This implementation does NOT protect against gas griefing.\n    /// Please use `forceSafeTransferETH` for gas griefing protection.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    \n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            // Store the function selector of `transferFrom(address,address,uint256)`.\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\n\n            if iszero(\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n  \n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Store the function selector of `transfer(address,uint256)`.\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\n\n            if iszero(\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n\n}\n\n/// copied from (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)\nlibrary SafeCastLib {\n\n    error Overflow();\n\n\n    function toUint128(uint256 x) internal pure returns (uint128) {\n        if (x >= 1 << 128) _revertOverflow();\n        return uint128(x);\n    }\n\n\n    function toInt8(int256 x) internal pure returns (int8) {\n        int8 y = int8(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    \n\n    function toInt128(int256 x) internal pure returns (int128) {\n        int128 y = int128(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n\n    function toInt256(uint256 x) internal pure returns (int256) {\n        if (x >= 1 << 255) _revertOverflow();\n        return int256(x);\n    }\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /-                    PRIVATE HELPERS                       */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    function _revertOverflow() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `Overflow()`.\n            mstore(0x00, 0x35278d12)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }\n}\n\ninterface IAnycallExecutor {\n    function context()\n        external\n        view\n        returns (address from, uint256 fromChainID, uint256 nonce);\n\n    function execute(\n        address _to,\n        bytes calldata _data,\n        address _from,\n        uint256 _fromChainID,\n        uint256 _nonce,\n        uint256 _flags,\n        bytes calldata _extdata\n    ) external returns (bool success, bytes memory result);\n}\n\ninterface IAnycallConfig {\n    function calcSrcFees(\n        address _app,\n        uint256 _toChainID,\n        uint256 _dataLength\n    ) external view returns (uint256);\n\n    function executionBudget(address _app) external view returns (uint256);\n\n    function deposit(address _account) external payable;\n\n    function withdraw(uint256 _amount) external;\n}\n\ninterface IAnycallProxy {\n    function executor() external view returns (address);\n\n    function config() external view returns (address);\n\n    function anyCall(\n        address _to,\n        bytes calldata _data,\n        uint256 _toChainID,\n        uint256 _flags,\n        bytes calldata _extdata\n    ) external payable;\n\n    function anyCall(\n        string calldata _to,\n        bytes calldata _data,\n        uint256 _toChainID,\n        uint256 _flags,\n        bytes calldata _extdata\n    ) external payable;\n}\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    // function receive() external payable {\n    //   deposit();\n    // }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != 255) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n\ncontract AnycallExecutor {\n    struct Context {\n        address from;\n        uint256 fromChainID;\n        uint256 nonce;\n    }\n    // Context public override context;\n    Context public context;\n\n    constructor() {\n        context.fromChainID = 1;\n        context.from = address(2);\n        context.nonce = 1;\n    }\n}\n\ncontract AnycallV7Config {\n    event Deposit(address indexed account, uint256 amount);\n\n    mapping(address => uint256) public executionBudget;\n\n    /// @notice Deposit native currency crediting `_account` for execution costs on this chain\n    /// @param _account The account to deposit and credit for\n    function deposit(address _account) external payable {\n        executionBudget[_account] += msg.value;\n        emit Deposit(_account, msg.value);\n    }\n}\n\n// IBranchPort interface\ninterface IPort {\n    /*///////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Returns true if the address is a Bridge Agent.\n     - @param _bridgeAgent Bridge Agent address.\n     - @return bool.\n     */\n    function isBridgeAgent(address _bridgeAgent) external view returns (bool);\n\n    /**\n     * @notice Returns true if the address is a Strategy Token.\n     - @param _token token address.\n     - @return bool.\n     */\n    function isStrategyToken(address _token) external view returns (bool);\n\n    /**\n     * @notice Returns true if the address is a Port Strategy.\n     - @param _strategy strategy address.\n     - @param _token token address.\n     - @return bool.\n     */\n    function isPortStrategy(\n        address _strategy,\n        address _token\n    ) external view returns (bool);\n\n    /**\n     * @notice Returns true if the address is a Bridge Agent Factory.\n     - @param _bridgeAgentFactory Bridge Agent Factory address.\n     - @return bool.\n     */\n    function isBridgeAgentFactory(\n        address _bridgeAgentFactory\n    ) external view returns (bool);\n\n    /*///////////////////////////////////////////////////////////////\n                          PORT STRATEGY MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Allows active Port Strategy addresses to withdraw assets.\n     -   @param _token token address.\n     -   @param _amount amount of tokens.\n     */\n    function manage(address _token, uint256 _amount) external;\n\n    /**\n     * @notice allow approved address to repay borrowed reserves with reserves\n     -   @param _amount uint\n     -   @param _token address\n     */\n    function replenishReserves(\n        address _strategy,\n        address _token,\n        uint256 _amount\n    ) external;\n\n    /*///////////////////////////////////////////////////////////////\n                          hTOKEN MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to withdraw underlying / native token amount into Port in exchange for Local hToken.\n     - @param _recipient hToken receiver.\n     - @param _underlyingAddress underlying / native token address.\n     - @param _amount amount of tokens.\n     *\n     */\n    function withdraw(\n        address _recipient,\n        address _underlyingAddress,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @notice Setter function to increase local hToken supply.\n     - @param _recipient hToken receiver.\n     - @param _localAddress token address.\n     - @param _amount amount of tokens.\n     *\n     */\n    function bridgeIn(\n        address _recipient,\n        address _localAddress,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @notice Setter function to increase local hToken supply.\n     - @param _recipient hToken receiver.\n     - @param _localAddresses token addresses.\n     - @param _amounts amount of tokens.\n     *\n     */\n    function bridgeInMultiple(\n        address _recipient,\n        address[] memory _localAddresses,\n        uint256[] memory _amounts\n    ) external;\n\n    /**\n     * @notice Setter function to decrease local hToken supply.\n     - @param _localAddress token address.\n     - @param _amount amount of tokens.\n     *\n     */\n    function bridgeOut(\n        address _depositor,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit\n    ) external;\n\n    /**\n     * @notice Setter function to decrease local hToken supply.\n     - @param _depositor user to deduct balance from.\n     - @param _localAddresses local token addresses.\n     - @param _underlyingAddresses local token address.\n     - @param _amounts amount of local tokens.\n     - @param _deposits amount of underlying tokens.\n     *\n     */\n    function bridgeOutMultiple(\n        address _depositor,\n        address[] memory _localAddresses,\n        address[] memory _underlyingAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits\n    ) external;\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Adds a new bridge agent address to the branch port.\n     - @param _bridgeAgent address of the bridge agent to add to the Port\n     */\n    function addBridgeAgent(address _bridgeAgent) external;\n\n    /**\n     * @notice Sets the core router address for the branch port.\n     - @param _newCoreRouter address of the new core router\n     */\n    function setCoreRouter(address _newCoreRouter) external;\n\n    /**\n     * @notice Adds a new bridge agent factory address to the branch port.\n     - @param _bridgeAgentFactory address of the bridge agent factory to add to the Port\n     */\n    function addBridgeAgentFactory(address _bridgeAgentFactory) external;\n\n    /**\n     * @notice Reverts the toggle on the given bridge agent factory. If it's active, it will de-activate it and vice-versa.\n     - @param _newBridgeAgentFactory address of the bridge agent factory to add to the Port\n     */\n    function toggleBridgeAgentFactory(address _newBridgeAgentFactory) external;\n\n    /**\n     * @notice Reverts thfe toggle on the given bridge agent  If it's active, it will de-activate it and vice-versa.\n     - @param _bridgeAgent address of the bridge agent to add to the Port\n     */\n    function toggleBridgeAgent(address _bridgeAgent) external;\n\n    /**\n     * @notice Adds a new strategy token.\n     * @param _token address of the token to add to the Strategy Tokens\n     */\n    function addStrategyToken(\n        address _token,\n        uint256 _minimumReservesRatio\n    ) external;\n\n    /**\n     * @notice Reverts the toggle on the given strategy token. If it's active, it will de-activate it and vice-versa.\n     * @param _token address of the token to add to the Strategy Tokens\n     */\n    function toggleStrategyToken(address _token) external;\n\n    /**\n     * @notice Adds a new Port strategy to the given port\n     * @param _portStrategy address of the bridge agent factory to add to the Port\n     */\n    function addPortStrategy(\n        address _portStrategy,\n        address _token,\n        uint256 _dailyManagementLimit\n    ) external;\n\n    /**\n     * @notice Reverts the toggle on the given port strategy. If it's active, it will de-activate it and vice-versa.\n     * @param _portStrategy address of the bridge agent factory to add to the Port\n     */\n    function togglePortStrategy(address _portStrategy, address _token) external;\n\n    /**\n     * @notice Updates the daily management limit for the given port strategy.\n     * @param _portStrategy address of the bridge agent factory to add to the Port\n     * @param _token address of the token to update the limit for\n     * @param _dailyManagementLimit new daily management limit\n     */\n    function updatePortStrategy(\n        address _portStrategy,\n        address _token,\n        uint256 _dailyManagementLimit\n    ) external;\n\n    /*///////////////////////////////////////////////////////////////\n                            EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event DebtCreated(\n        address indexed _strategy,\n        address indexed _token,\n        uint256 _amount\n    );\n    event DebtRepaid(\n        address indexed _strategy,\n        address indexed _token,\n        uint256 _amount\n    );\n\n    event StrategyTokenAdded(\n        address indexed _token,\n        uint256 _minimumReservesRatio\n    );\n    event StrategyTokenToggled(address indexed _token);\n\n    event PortStrategyAdded(\n        address indexed _portStrategy,\n        address indexed _token,\n        uint256 _dailyManagementLimit\n    );\n    event PortStrategyToggled(\n        address indexed _portStrategy,\n        address indexed _token\n    );\n    event PortStrategyUpdated(\n        address indexed _portStrategy,\n        address indexed _token,\n        uint256 _dailyManagementLimit\n    );\n\n    event BridgeAgentFactoryAdded(address indexed _bridgeAgentFactory);\n    event BridgeAgentFactoryToggled(address indexed _bridgeAgentFactory);\n\n    event BridgeAgentToggled(address indexed _bridgeAgent);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error InvalidMinimumReservesRatio();\n    error InsufficientReserves();\n    error UnrecognizedCore();\n    error UnrecognizedBridgeAgent();\n    error UnrecognizedBridgeAgentFactory();\n    error UnrecognizedPortStrategy();\n    error UnrecognizedStrategyToken();\n}\n\ncontract BranchPort {\n    using SafeTransferLib for address;\n\n    error UnrecognizedBridgeAgent();\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address => bool) public isBridgeAgent;\n\n    constructor(address bridgeAgent) {\n        isBridgeAgent[bridgeAgent] = true;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent.\n    modifier requiresBridgeAgent() {\n        if (!isBridgeAgent[msg.sender]) revert UnrecognizedBridgeAgent();\n        _;\n    }\n\n    function withdraw(\n        address _recipient,\n        address _underlyingAddress,\n        uint256 _deposit\n    ) external virtual requiresBridgeAgent {\n        _underlyingAddress.safeTransfer(\n            _recipient,\n            _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n        );\n    }\n\n    function _denormalizeDecimals(\n        uint256 _amount,\n        uint8 _decimals\n    ) internal pure returns (uint256) {\n        return\n            _decimals == 18 ? _amount : (_amount * 1 ether) / (10 ** _decimals);\n    }\n}\n\ncontract BranchBridgeAgent {\n    using SafeCastLib for uint256;\n\n    enum DepositStatus {\n        Success,\n        Failed\n    }\n\n    struct Deposit {\n        uint128 depositedGas;\n        address owner;\n        DepositStatus status;\n        address[] hTokens;\n        address[] tokens;\n        uint256[] amounts;\n        uint256[] deposits;\n    }\n\n    error AnycallUnauthorizedCaller();\n    error GasErrorOrRepeatedTx();\n\n    uint256 public remoteCallDepositedGas;\n\n    uint256 internal constant MIN_FALLBACK_RESERVE = 185_000; // 100_000 for anycall + 85_000 fallback execution overhead\n    // uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executions\n    uint256 internal constant TRANSFER_OVERHEAD = 24_000;\n\n    WETH9 public immutable wrappedNativeToken;\n\n    AnycallV7Config public anycallV7Config;\n\n    uint256 public accumulatedFees;\n\n    /// @notice Local Chain Id\n    uint24 public immutable localChainId;\n\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.\n    address public immutable rootBridgeAgentAddress;\n    /// @notice Local Anyexec Address\n    address public immutable local`AnyCall`ExecutorAddress;\n\n    /// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.\n    address public immutable local`AnyCall`Address;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept, managed an",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/BranchBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\nimport {IApp, IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IBranchRouter as IRouter} from \"./interfaces/IBranchRouter.sol\";\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch as ERC20hToken} from \"./token/ERC20hTokenBranch.sol\";\nimport {BranchBridgeAgentExecutor, DeployBranchBridgeAgentExecutor} from \"./BranchBridgeAgentExecutor.sol\";\nimport {\n    Deposit,\n    DepositStatus,\n    DepositInput,\n    DepositMultipleInput,\n    DepositParams,\n    DepositMultipleParams,\n    SettlementParams,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\n\n/// @title Library for Branch Bridge Agent Deployment\nlibrary DeployBranchBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) external returns (BranchBridgeAgent) {\n        return new BranchBridgeAgent(\n            _wrappedNativeToken,\n            _rootChainId,\n            _localChainId,\n            _rootBridgeAgentAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localRouterAddress,\n            _localPortAddress\n        );\n    }\n}\n\n/// @title Branch Bridge Agent Contract\ncontract BranchBridgeAgent is IBranchBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Decode Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ENTRY_SIZE = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// ClearTokens Decode Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain Id for Root Chain where liqudity is virtualized(e.g. 4).\n    uint256 public immutable rootChainId;\n\n    /// @notice Chain Id for Local Chain.\n    uint256 public immutable localChainId;\n\n    /// @notice Address for Local Wrapped Native Token.\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.\n    address public immutable rootBridgeAgentAddress;\n\n    /// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.\n    address public immutable localAnyCallAddress;\n\n    /// @notice Address for Local Anyexec Address where cross-chain requests from the Root Chain Router are received locally.\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Address for Local Router used for custom actions for different hApps.\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\n    address public immutable localPortAddress;\n\n    address public bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSITS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public depositNonce;\n\n    /// @notice Mapping from Pending deposits hash to Deposit Struct.\n    mapping(uint32 => Deposit) public getDeposit;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint32 => bool) public executionHistory;\n\n    /*///////////////////////////////////////////////////////////////\n                        GAS MANAGEMENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public remoteCallDepositedGas;\n\n    uint256 internal constant MIN_FALLBACK_RESERVE = 185_000; // 100_000 for anycall + 85_000 fallback execution overhead\n    uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executions\n    uint256 internal constant TRANSFER_OVERHEAD = 24_000;\n\n    constructor(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) {\n        require(_rootBridgeAgentAddress != address(0), \"Root Bridge Agent Address cannot be the zero address.\");\n        require(_localAnyCallAddress != address(0), \"AnyCall Address cannot be the zero address.\");\n        require(_localAnyCallExecutorAddress != address(0), \"AnyCall Executor Address cannot be the zero address.\");\n        require(_localRouterAddress != address(0), \"Local Router Address cannot be the zero address.\");\n        require(_localPortAddress != address(0), \"Local Port Address cannot be the zero address.\");\n\n        wrappedNativeToken = _wrappedNativeToken;\n        localChainId = _localChainId;\n        rootChainId = _rootChainId;\n        rootBridgeAgentAddress = _rootBridgeAgentAddress;\n        localAnyCallAddress = _localAnyCallAddress;\n        localAnyCallExecutorAddress = _localAnyCallExecutorAddress;\n        localRouterAddress = _localRouterAddress;\n        localPortAddress = _localPortAddress;\n        bridgeAgentExecutorAddress = DeployBranchBridgeAgentExecutor.deploy();\n        depositNonce = 1;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getDepositEntry(uint32 _depositNonce) external view returns (Deposit memory) {\n        return getDeposit[_depositNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOut(bytes calldata _params, uint128 _remoteExecutionGas) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call without deposit\n        _callOut(msg.sender, _params, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with deposit\n        _callOutAndBridge(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with multiple deposits\n        _callOutAndBridgeMultiple(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSigned(bytes calldata _params, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x04), msg.sender, depositNonce, _params, msg.value.toUint128(), _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Signed Call without deposit\n        _noDepositCall(msg.sender, packedData, msg.value.toUint128());\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x05),\n            msg.sender,\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            msg.sender,\n            packedData,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _dParams.deposit,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Normalize Deposits\n        uint256[] memory _deposits = new uint256[](_dParams.hTokens.length);\n\n        for (uint256 i = 0; i < _dParams.hTokens.length; i++) {\n            _deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x06),\n            msg.sender,\n            uint8(_dParams.hTokens.length),\n            depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _deposits,\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCallMultiple(\n            msg.sender,\n            packedData,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retryDeposit(\n        bool _isSigned,\n        uint32 _depositNonce,\n        bytes calldata _params,\n        uint128 _remoteExecutionGas,\n        uint24 _toChain\n    ) external payable lock requiresFallbackGas {\n        //Check if deposit belongs to message sender\n        if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData;\n\n        if (uint8(getDeposit[_depositNonce].hTokens.length) == 1) {\n            if (_isSigned) {\n                packedData = abi.encodePacked(\n                    bytes1(0x05),\n                    msg.sender,\n                    _depositNonce,\n                    getDeposit[_depositNonce].hTokens[0],\n                    getDeposit[_depositNonce].tokens[0],\n                    getDeposit[_depositNonce].amounts[0],\n                    _normalizeDecimals(\n                        getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n                    ),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            } else {\n                packedData = abi.encodePacked(\n                    bytes1(0x02),\n                    _depositNonce,\n                    getDeposit[_depositNonce].hTokens[0],\n                    getDeposit[_depositNonce].tokens[0],\n                    getDeposit[_depositNonce].amounts[0],\n                    _normalizeDecimals(\n                        getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n                    ),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            }\n        } else if (uint8(getDeposit[_depositNonce].hTokens.length) > 1) {\n            //Nonce\n            uint32 nonce = _depositNonce;\n\n            if (_isSigned) {\n                packedData = abi.encodePacked(\n                    bytes1(0x06),\n                    msg.sender,\n                    uint8(getDeposit[_depositNonce].hTokens.length),\n                    nonce,\n                    getDeposit[nonce].hTokens,\n                    getDeposit[nonce].tokens,\n                    getDeposit[nonce].amounts,\n                    _normalizeDecimalsMultiple(getDeposit[nonce].deposits, getDeposit[nonce].tokens),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            } else {\n                packedData = abi.encodePacked(\n                    bytes1(0x03),\n                    uint8(getDeposit[nonce].hTokens.length),\n                    _depositNonce,\n                    getDeposit[nonce].hTokens,\n                    getDeposit[nonce].tokens,\n                    getDeposit[nonce].amounts,\n                    _normalizeDecimalsMultiple(getDeposit[nonce].deposits, getDeposit[nonce].tokens),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            }\n        }\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Deposit Gas to Port\n        _depositGas(msg.value.toUint128());\n\n        //Ensure success Status\n        getDeposit[_depositNonce].status = DepositStatus.Success;\n\n        //Update Deposited Gas\n        getDeposit[_depositNonce].depositedGas = msg.value.toUint128();\n\n        //Perform Call\n        _performCall(packedData);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrySettlement(uint32 _settlementNonce, uint128 _gasToBoostSettlement)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x07), depositNonce++, _settlementNonce, msg.value.toUint128(), _gasToBoostSettlement\n        );\n        //Update State and Perform Call\n        _sendRetrieveOrRetry(packedData);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrieveDeposit(uint32 _depositNonce) external payable lock requiresFallbackGas {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(bytes1(0x08), _depositNonce, msg.value.toUint128(), uint128(0));\n\n        //Update State and Perform Call\n        _sendRetrieveOrRetry(packedData);\n    }\n\n    function _sendRetrieveOrRetry(bytes memory _data) internal {\n        //Deposit Gas for call.\n        _createGasDeposit(msg.sender, msg.value.toUint128());\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function redeemDeposit(uint32 _depositNonce) external lock {\n        //Update Deposit\n        if (getDeposit[_depositNonce].status != DepositStatus.Failed) {\n            revert DepositRedeemUnavailable();\n        }\n        _redeemDeposit(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRANCH ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performSystemCallOut(\n        address _depositor,\n        bytes calldata _params,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData =\n            abi.encodePacked(bytes1(0x00), depositNonce, _params, gasToBridgeOut, _remoteExecutionGas);\n\n        //Perform Call\n        _noDepositCall(_depositor, packedData, gasToBridgeOut);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOut(\n        address _depositor,\n        bytes calldata _params,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOut(_depositor, _params, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOutAndBridge(\n        address _depositor,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOutAndBridge(_depositor, _params, _dParams, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOutAndBridgeMultiple(\n        address _depositor,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOutAndBridgeMultiple(_depositor, _params, _dParams, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearToken(address _recipient, address _hToken, address _token, uint256 _amount, uint256 _deposit)\n        external\n        requiresAgentExecutor\n    {\n        _clearToken(_recipient, _hToken, _token, _amount, _deposit);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearTokens(bytes calldata _sParams, address _recipient)\n        external\n        requiresAgentExecutor\n        returns (SettlementMultipleParams memory)\n    {\n        //Parse Params\n        uint8 numOfAssets = uint8(bytes1(_sParams[0]));\n        uint32 nonce = uint32(bytes4(_sParams[PARAMS_START:PARAMS_TKN_START]));\n\n        address[] memory _hTokens = new address[](numOfAssets);\n        address[] memory _tokens = new address[](numOfAssets);\n        uint256[] memory _amounts = new uint256[](numOfAssets);\n        uint256[] memory _deposits = new uint256[](numOfAssets);\n\n        //Transfer token to recipient\n        for (uint256 i = 0; i < numOfAssets;) {\n            //Parse Params\n            _hTokens[i] = address(\n                uint160(\n                    bytes20(\n                        bytes32(\n                            _sParams[\n                                PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * i) + 12:\n                                    PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * (PARAMS_START + i))\n                            ]\n                        )\n                    )\n                )\n            );\n            _tokens[i] = address(\n                uint160(\n                    bytes20(\n                        _sParams[\n                            PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(i + numOfAssets) + 12:\n                                PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i + numOfAssets)\n                        ]\n                    )\n                )\n            );\n            _amounts[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):\n                            PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets)\n                                + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)\n                    ]\n                )\n            );\n            _deposits[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):\n                            PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets)\n                                + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)\n                    ]\n                )\n            );\n            //Clear Tokens to destination\n            if (_amounts[i] - _deposits[i] > 0) {\n                IPort(localPortAddress).bridgeIn(_recipient, _hTokens[i], _amounts[i] - _deposits[i]);\n            }\n\n            if (_deposits[i] > 0) {\n                IPort(localPortAddress).withdraw(_recipient, _tokens[i], _deposits[i]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return SettlementMultipleParams(numOfAssets, _recipient, nonce, _hTokens, _tokens, _amounts, _deposits);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                LOCAL USER DEPOSIT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router without token deposit.\n     *   @param _depositor address of the user that will deposit the funds.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 1 (Call without deposit)\n     *\n     */\n    function _callOut(address _depositor, bytes calldata _params, uint128 _gasToBridgeOut, uint128 _remoteExecutionGas)\n        internal\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData =\n            abi.encodePacked(bytes1(0x01), depositNonce, _params, _gasToBridgeOut, _remoteExecutionGas);\n\n        //Perform Call\n        _noDepositCall(_depositor, packedData, _gasToBridgeOut);\n    }\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router while depositing a single asset.\n     *   @param _depositor address of the user that will deposit the funds.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _dParams additional token deposit parameters.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 2 (Call with single deposit)\n     *\n     */\n    function _callOutAndBridge(\n        address _depositor,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) internal {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x02),\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            _gasToBridgeOut,\n            _remoteExecutionGas\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            _depositor, packedData, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit, _gasToBridgeOut\n        );\n    }\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router while depositing two or more assets.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _dParams additional token deposit parameters.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 3 (Call with multiple deposit)\n     *\n     */\n    function _callOutAndBridgeMultiple(\n        address _depositor,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) internal {\n        //Normalize Deposits\n        uint256[] memory deposits = new uint256[](_dParams.hTokens.length);\n\n        for (uint256 i = 0; i < _dParams.hTokens.length; i++) {\n            deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x03),\n            uint8(_dParams.hTokens.length),\n            depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            deposits,\n            _dParams.toChain,\n            _params,\n            _gasToBridgeOut,\n            _remoteExecutionGas\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCallMultiple(\n            _depositor,\n            packedData,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            _gasToBridgeOut\n        );\n    }\n\n    /**\n     * @notice Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _noDepositCall(address _depositor, bytes memory _data, uint128 _gasToBridgeOut) internal {\n        //Deposit Gas for call.\n        _createGasDeposit(_depositor, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @notice Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _hToken Local Input hToken Address.\n     *   @param _token Native / Underlying Token Address.\n     *   @param _amount Amount of Local hTokens deposited for trade.\n     *   @param _deposit Amount of native tokens deposited for trade.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _depositAndCall(\n        address _depositor,\n        bytes memory _data,\n        address _hToken,\n        address _token,\n        uint256 _amount,\n        uint256 _deposit,\n        uint128 _gasToBridgeOut\n    ) internal {\n        //Deposit and Store Info\n        _createDepositSingle(_depositor, _hToken, _token, _amount, _deposit, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @dev Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _hTokens Local Input hToken Address.\n     *   @param _tokens Native / Underlying Token Address.\n     *   @param _amounts Amount of Local hTokens deposited for trade.\n     *   @param _deposits  Amount of native tokens deposited for trade.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _depositAndCallMultiple(\n        address _depositor,\n        bytes memory _data,\n        address[] memory _hTokens,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        uint128 _gasToBridgeOut\n    ) internal {\n        //Validate Input\n        if (\n            _hTokens.length != _tokens.length || _tokens.length != _amounts.length\n                || _amounts.length != _deposits.length\n        ) revert InvalidInput();\n\n        //Deposit and Store Info\n        _createDepositMultiple(_depositor, _hTokens, _tokens, _amounts, _deposits, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @dev Function to create a pending deposit.\n     *    @param _user user address.\n     *    @param _gasToBridgeOut gas allocated for omnichain execution.\n     *\n     */\n    function _createGasDeposit(address _user, uint128 _gasToBridgeOut) internal {\n        //Deposit Gas to Port\n        _depositGas(_gasToBridgeOut);\n\n        // Update State\n        getDeposit[_getAndIncrementDepositNonce()] = Deposit({\n            owner: _user,\n            hTokens: new address[](0),\n            tokens: new address[](0),\n            amounts: new uint256[](0),\n            deposits: new uint256[](0),\n            status: DepositStatus.Success,\n            depositedGas: _gasToBridgeOut\n        });\n    }\n\n    /**\n     * @dev Function to create a pending deposit.\n     *    @param _user user address.\n     *    @param _hToken deposited local hToken addresses.\n     *    @param _token deposited native / underlying Token addresses.\n     *    @param _amount amounts of hTokens input.\n     *    @param _deposit amount of deposited underlying / native tokens.\n     *    @param _gasToBridgeOut gas allocated for omnichain execution.\n     *\n     */\n    function _createDepositSingle(\n        address _user,\n        address _hToken,"
    }
  ]
}