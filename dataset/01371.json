{
  "Title": "M-1: Wrong calculation of solvency in `fillCloseRequest` prevents the position from being closed even if the user is solvent after position closure",
  "Content": "# Issue M-1: Wrong calculation of solvency in `fillCloseRequest` prevents the position from being closed even if the user is solvent after position closure \n\nSource: https://github.com/sherlock-audit/2023-08-symmetrical-judging/issues/9 \n\n## Found by \npanprog, xiaoming90\n\nThis is an [issue 184](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/184) from previous contest, developers fixed it only partially (request to close), but fill close request remains the same.\nIf partyA has requested to close position, and partyB has called `fillCloseRequest`, the transaction will revert even though partyA is solvent after closure in the following scenario:\n- partyA is not solvent if the position is closed at the current market price\n- `closePrice` provided by the partyB is better than market price\n- partyA is solvent if the position is closed at the `closePrice` provided by partyB\n\nThis is unfair for partyA and can lead to liquidation and loss of funds for partyA, even though it could have had the position closed correctly to make it solvent.\n\n## Vulnerability Detail\n\n`isSolventAfterClosePosition` verifies that both partyA and partyB are solvent at the market price, then verifies that both partyA and partyB are solvent at the `closePrice`. However, if both parties are solvent at `closePrice` - this should be sufficient, as it's the most fair way for both parties - let the position close if both parties are solvent after it. But the requirement to be solvent both at market and close price prevents the transaction from being completed successfully.\n\n## Impact\n\nPartyA can be liquidated and lose funds instead of correct closure of the position due to failed position closure transaction.\n\n## Code Snippet\n\n`isSolventAfterClosePosition` requires enough balance both at the market and close price:\nhttps://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/libraries/LibSolvency.sol#L101-L133\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRequire both parties to only be solvent at `closePrice` when the position is closed, there is no point in reverting if the position closure can make both parties solvent, even though one of it is not solvent before that.\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nFixed Code PR: https://github.com/SYMM-IO/symmio-core/pull/32\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/108",
  "Code": [
    {
      "filename": "symmio-core/contracts/libraries/LibSolvency.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../storages/MuonStorage.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"./LibAccount.sol\";\nimport \"./LibQuote.sol\";\n\nlibrary LibSolvency {\n    using LockedValuesOps for LockedValues;\n\n    function isSolventAfterOpenPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal view returns (bool) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        int256 partyBAvailableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnlPartyB,\n            quote.partyB,\n            quote.partyA\n        );\n        int256 partyAAvailableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnlPartyA,\n            quote.partyA\n        );\n\n        if (quote.positionType == PositionType.LONG) {\n            if (quote.openedPrice >= upnlSig.price) {\n                uint256 diff = (filledAmount * (quote.openedPrice - upnlSig.price)) / 1e18;\n                require(\n                    partyAAvailableBalance - int256(diff) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n                require(\n                    partyBAvailableBalance + int256(diff) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            } else {\n                uint256 diff = (filledAmount * (upnlSig.price - quote.openedPrice)) / 1e18;\n                require(\n                    partyBAvailableBalance - int256(diff) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n                require(\n                    partyAAvailableBalance + int256(diff) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            }\n        } else if (quote.positionType == PositionType.SHORT) {\n            if (quote.openedPrice >= upnlSig.price) {\n                uint256 diff = (filledAmount * (quote.openedPrice - upnlSig.price)) / 1e18;\n                require(\n                    partyBAvailableBalance - int256(diff) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n                require(\n                    partyAAvailableBalance + int256(diff) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            } else {\n                uint256 diff = (filledAmount * (upnlSig.price - quote.openedPrice)) / 1e18;\n                require(\n                    partyAAvailableBalance - int256(diff) >= 0,\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n                require(\n                    partyBAvailableBalance + int256(diff) >= 0,\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            }\n        }\n\n        return true;\n    }\n\n    function isSolventAfterClosePosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal view returns (bool) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        uint256 unlockedAmount = (filledAmount * (quote.lockedValues.cva + quote.lockedValues.lf)) /\n            LibQuote.quoteOpenAmount(quote);\n\n        int256 partyBAvailableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnlPartyB,\n            quote.partyB,\n            quote.partyA\n        ) + int256(unlockedAmount);\n\n        int256 partyAAvailableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnlPartyA,\n            quote.partyA\n        ) + int256(unlockedAmount);\n\n        require(\n            partyBAvailableBalance >= 0 && partyAAvailableBalance >= 0,\n            \"LibSolvency: Available balance is lower than zero\"\n        );\n        if (quote.positionType == PositionType.LONG) {\n            if (closedPrice >= upnlSig.price) {\n                require(\n                    uint256(partyBAvailableBalance) >=\n                        ((filledAmount * (closedPrice - upnlSig.price)) / 1e18),\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            } else {\n                require(\n                    uint256(partyAAvailableBalance) >=\n                        ((filledAmount * (upnlSig.price - closedPrice)) / 1e18),\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            }\n        } else if (quote.positionType == PositionType.SHORT) {\n            if (closedPrice <= upnlSig.price) {\n                require(\n                    uint256(partyBAvailableBalance) >=\n                        ((filledAmount * (upnlSig.price - closedPrice)) / 1e18),\n                    \"LibSolvency: PartyB will be liquidatable\"\n                );\n            } else {\n                require(\n                    uint256(partyAAvailableBalance) >=\n                        ((filledAmount * (closedPrice - upnlSig.price)) / 1e18),\n                    \"LibSolvency: PartyA will be liquidatable\"\n                );\n            }\n        }\n        return true;\n    }\n\n    function isSolventAfterRequestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal view returns (bool) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        uint256 unlockedAmount = (quantityToClose *\n            (quote.lockedValues.cva + quote.lockedValues.lf)) / LibQuote.quoteOpenAmount(quote);\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            msg.sender\n        ) + int256(unlockedAmount);\n\n        require(availableBalance >= 0, \"LibSolvency: Available balance is lower than zero\");\n        if (quote.positionType == PositionType.LONG && closePrice <= upnlSig.price) {\n            require(\n                uint256(availableBalance) >=\n                    ((quantityToClose * (upnlSig.price - closePrice)) / 1e18),\n                \"LibSolvency: partyA will be liquidatable\"\n            );\n        } else if (quote.positionType == PositionType.SHORT && closePrice >= upnlSig.price) {\n            require(\n                uint256(availableBalance) >=\n                    ((quantityToClose * (closePrice - upnlSig.price)) / 1e18),\n                \"LibSolvency: partyA will be liquidatable\"\n            );\n        }\n        return true;\n    }\n}"
    }
  ]
}