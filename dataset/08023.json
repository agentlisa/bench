{
  "Title": "[G-02] Cache the results of an external function instead of calling it again (5 instances)",
  "Content": "\n- Deployment. Gas Saved: **102 794**\n\n- Minumal Method Call. Gas Saved: **-53**\n\n- Average Method Call. Gas Saved: **7 512**\n\n- Maximum Method Call. Gas Saved: **7 514**\n\n#### - src/Controller.sol:[199-200](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L199-L200), [202-203](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L202-L203), [206-209](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L206-L209)\n\n```diff\ndiff --git a/src/Controller.sol b/src/Controller.sol\nindex e15b0fa..54503d7 100644\n--- a/src/Controller.sol\n+++ b/src/Controller.sol\n@@ -76,39 +76,6 @@ contract Controller {\n   76,  76:         _;\n   77,  77:     }\n   78,  78:\n-  79     :-    /** @notice Modifier to ensure market exists, current market epoch time and price are valid\n-  80     :-      * @param marketIndex Target market index\n-  81     :-      * @param epochEnd End of epoch set for market\n-  82     :-      */\n-  83     :-    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {\n-  84     :-        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n-  85     :-        if(\n-  86     :-            vaultsAddress.length != VAULTS_LENGTH\n-  87     :-            )\n-  88     :-            revert MarketDoesNotExist(marketIndex);\n-  89     :-\n-  90     :-        address vaultAddress = vaultsAddress[0];\n-  91     :-        Vault vault = Vault(vaultAddress);\n-  92     :-\n-  93     :-        if(vault.idExists(epochEnd) == false)\n-  94     :-            revert EpochNotExist();\n-  95     :-\n-  96     :-        if(\n-  97     :-            vault.strikePrice() < getLatestPrice(vault.tokenInsured())\n-  98     :-            )\n-  99     :-            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));\n- 100     :-\n- 101     :-        if(\n- 102     :-            vault.idEpochBegin(epochEnd) > block.timestamp)\n- 103     :-            revert EpochNotStarted();\n- 104     :-\n- 105     :-        if(\n- 106     :-            block.timestamp > epochEnd\n- 107     :-            )\n- 108     :-            revert EpochExpired();\n- 109     :-        _;\n- 110     :-    }\n- 111     :-\n  112,  79:     /*//////////////////////////////////////////////////////////////\n  113,  80:                                 CONSTRUCTOR\n  114,  81:     //////////////////////////////////////////////////////////////*/\n@@ -147,12 +114,27 @@ contract Controller {\n  147, 114:       */\n  148, 115:     function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n  149, 116:         public\n- 150     :-        isDisaster(marketIndex, epochEnd)\n  151, 117:     {\n  152, 118:         address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n+      119:+        if(vaultsAddress.length != VAULTS_LENGTH)\n+      120:+            revert MarketDoesNotExist(marketIndex);\n+      121:+\n  153, 122:         Vault insrVault = Vault(vaultsAddress[0]);\n  154, 123:         Vault riskVault = Vault(vaultsAddress[1]);\n  155, 124:\n+      125:+        if(insrVault.idExists(epochEnd) == false)\n+      126:+            revert EpochNotExist();\n+      127:+\n+      128:+        int256 nowPrice;\n+      129:+        if(insrVault.strikePrice() < (nowPrice = getLatestPrice(insrVault.tokenInsured())))\n+      130:+            revert PriceNotAtStrikePrice(nowPrice);\n+      131:+\n+      132:+        if(insrVault.idEpochBegin(epochEnd) > block.timestamp)\n+      133:+            revert EpochNotStarted();\n+      134:+\n+      135:+        if(block.timestamp > epochEnd)\n+      136:+            revert EpochExpired();\n+      137:+\n  156, 138:         //require this function cannot be called twice in the same epoch for the same vault\n  157, 139:         if(insrVault.idFinalTVL(epochEnd) != 0)\n  158, 140:             revert NotZeroTVL();\n@@ -196,17 +178,14 @@ contract Controller {\n  196, 178:       * @param epochEnd End of epoch set for market\n  197, 179:       */\n  198, 180:     function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n- 199     :-        if(\n- 200     :-            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)\n+      181:+        address[] memory vaults = vaultFactory.getVaults(marketIndex);\n+      182:+        if(vaults.length != VAULTS_LENGTH)\n  201, 183:                 revert MarketDoesNotExist(marketIndex);\n- 202     :-        if(\n- 203     :-            block.timestamp < epochEnd)\n+      184:+        if(block.timestamp < epochEnd)\n  204, 185:             revert EpochNotExpired();\n  205, 186:\n- 206     :-        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n- 207     :-\n- 208     :-        Vault insrVault = Vault(vaultsAddress[0]);\n- 209     :-        Vault riskVault = Vault(vaultsAddress[1]);\n+      187:+        Vault insrVault = Vault(vaults[0]);\n+      188:+        Vault riskVault = Vault(vaults[1]);\n  210, 189:\n  211, 190:         if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)\n  212, 191:             revert EpochNotExist();\n```\n\n#### - src/oracles/PegOracle.sol:[29](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/oracles/PegOracle.sol#L29)\n\n```diff\ndiff --git a/src/oracles/PegOracle.sol b/src/oracles/PegOracle.sol\nindex 1c65268..8387ed9 100644\n--- a/src/oracles/PegOracle.sol\n+++ b/src/oracles/PegOracle.sol\n@@ -25,15 +25,16 @@ contract PegOracle {\n   25,  25:         require(_oracle1 != _oracle2, \"Cannot be same Oracle\");\n   26,  26:         priceFeed1 = AggregatorV3Interface(_oracle1);\n   27,  27:         priceFeed2 = AggregatorV3Interface(_oracle2);\n+       28:+        uint8 _decimals;\n   28,  29:         require(\n-  29     :-            (priceFeed1.decimals() == priceFeed2.decimals()),\n+       30:+            ((_decimals = priceFeed1.decimals()) == priceFeed2.decimals()),\n   30,  31:             \"Decimals must be the same\"\n   31,  32:         );\n   32,  33:\n   33,  34:         oracle1 = _oracle1;\n   34,  35:         oracle2 = _oracle2;\n   35,  36:\n-  36     :-        decimals = priceFeed1.decimals();\n+       37:+        decimals = _decimals;\n   37,  38:     }\n   38,  39:\n   39,  40:     /** @notice Returns oracle-fed data from the latest round\n```\n\n#### - src/rewards/RewardsFactory.sol:[90-91](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/rewards/RewardsFactory.sol#L90-L91)\n\n```diff\ndiff --git a/src/rewards/RewardsFactory.sol b/src/rewards/RewardsFactory.sol\nindex 8bee8bd..a679348 100644\n--- a/src/rewards/RewardsFactory.sol\n+++ b/src/rewards/RewardsFactory.sol\n@@ -87,8 +87,9 @@ contract RewardsFactory {\n   87,  87:     {\n   88,  88:         VaultFactory vaultFactory = VaultFactory(factory);\n   89,  89:\n-  90     :-        address _insrToken = vaultFactory.getVaults(_marketIndex)[0];\n-  91     :-        address _riskToken = vaultFactory.getVaults(_marketIndex)[1];\n+       90:+        address[] memory vaults = vaultFactory.getVaults(_marketIndex);\n+       91:+        address _insrToken = vaults[0];\n+       92:+        address _riskToken = vaults[1];\n   92,  93:\n   93,  94:         if(_insrToken == address(0) || _riskToken == address(0))\n   94,  95:             revert MarketDoesNotExist(_marketIndex);\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-09-y2k-finance-contest",
  "Code": [
    {
      "filename": "src/Controller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Vault.sol\";\nimport \"./VaultFactory.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract Controller {\n    address public immutable admin;\n    VaultFactory public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n    uint256 public constant VAULTS_LENGTH = 2;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error NotZeroTVL();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error TimestampZero();\n    error AddressNotAdmin();\n    error EpochNotExist();\n    error EpochNotExpired();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Depegs insurance vault when event is emitted\n      * @param epochMarketID Current market epoch ID\n      * @param tvl Current TVL\n      * @param isDisaster Flag if event isDisaster\n      * @param epoch Current epoch \n      * @param time Current time\n      * @param depegPrice Price that triggered depeg\n      */\n    event DepegInsurance(\n        bytes32 epochMarketID,\n        VaultTVL tvl,\n        bool isDisaster,\n        uint256 epoch,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /* solhint-disable  var-name-mixedcase */\n    struct VaultTVL {\n        uint256 RISK_claimTVL;\n        uint256 RISK_finalTVL;\n        uint256 INSR_claimTVL;\n        uint256 INSR_finalTVL;\n    }\n    /* solhint-enable  var-name-mixedcase */\n\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != admin)\n            revert AddressNotAdmin();\n        _;\n    }\n\n    /** @notice Modifier to ensure market exists, current market epoch time and price are valid \n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        if(\n            vaultsAddress.length != VAULTS_LENGTH\n            )\n            revert MarketDoesNotExist(marketIndex);\n\n        address vaultAddress = vaultsAddress[0];\n        Vault vault = Vault(vaultAddress);\n\n        if(vault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        if(\n            vault.strikePrice() < getLatestPrice(vault.tokenInsured())\n            )\n            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));\n\n        if(\n            vault.idEpochBegin(epochEnd) > block.timestamp)\n            revert EpochNotStarted();\n\n        if(\n            block.timestamp > epochEnd\n            )\n            revert EpochExpired();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _factory VaultFactory address\n      * @param _admin Admin address\n      * @param _l2Sequencer Arbitrum sequencer address\n      */ \n    constructor(\n        address _factory,\n        address _admin,\n        address _l2Sequencer\n    ) {\n        if(_admin == address(0))\n            revert ZeroAddress();\n\n        if(_factory == address(0)) \n            revert ZeroAddress();\n\n        if(_l2Sequencer == address(0))\n            revert ZeroAddress();\n        \n        admin = _admin;\n        vaultFactory = VaultFactory(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n        if(\n            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)\n                revert MarketDoesNotExist(marketIndex);\n        if(\n            block.timestamp < epochEnd)\n            revert EpochNotExpired();\n\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, false);\n        riskVault.endEpoch(epochEnd, false);\n\n        insrVault.setClaimTVL(epochEnd, 0);\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n        insrVault.sendTokens(epochEnd, address(riskVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            false,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN SETTINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n      * @param _token Target token address\n      * @return nowPrice Current token price\n      */\n    function getLatestPrice(address _token)\n        public\n        view\n        returns (int256 nowPrice)\n    {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        uint256 decimals = 10**(18-(priceFeed.decimals()));\n        price = price * int256(decimals);\n\n        if(price <= 0)\n            revert OraclePriceZero();\n\n        if(answeredInRound < roundID)\n            revert RoundIDOutdated();\n\n        if(timeStamp == 0)\n            revert TimestampZero();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n      * @dev need to find way to express typecasts in NatSpec\n      */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n}"
    },
    {
      "filename": "src/oracles/PegOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\n\ncontract PegOracle {\n    /***\n    @dev  for example: oracle1 would be stETH / USD, while oracle2 would be ETH / USD oracle\n    ***/\n    address public oracle1;\n    address public oracle2;\n\n    uint8 public decimals;\n\n    AggregatorV3Interface internal priceFeed1;\n    AggregatorV3Interface internal priceFeed2;\n\n    /** @notice Contract constructor\n      * @param _oracle1 First oracle address\n      * @param _oracle2 Second oracle address\n      */\n    constructor(address _oracle1, address _oracle2) {\n        require(_oracle1 != address(0), \"oracle1 cannot be the zero address\");\n        require(_oracle2 != address(0), \"oracle2 cannot be the zero address\");\n        require(_oracle1 != _oracle2, \"Cannot be same Oracle\");\n        priceFeed1 = AggregatorV3Interface(_oracle1);\n        priceFeed2 = AggregatorV3Interface(_oracle2);\n        require(\n            (priceFeed1.decimals() == priceFeed2.decimals()),\n            \"Decimals must be the same\"\n        );\n\n        oracle1 = _oracle1;\n        oracle2 = _oracle2;\n\n        decimals = priceFeed1.decimals();\n    }\n\n    /** @notice Returns oracle-fed data from the latest round\n      * @return roundID Current round id \n      * @return nowPrice Current price\n      * @return startedAt Starting timestamp\n      * @return timeStamp Current timestamp\n      * @return answeredInRound Round id for which answer was computed \n      */ \n    function latestRoundData()\n        public\n        view\n        returns (\n            uint80 roundID,\n            int256 nowPrice,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        )\n    {\n        (\n            uint80 roundID1,\n            int256 price1,\n            uint256 startedAt1,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        int256 price2 = getOracle2_Price();\n\n        if (price1 > price2) {\n            nowPrice = (price2 * 10000) / price1;\n        } else {\n            nowPrice = (price1 * 10000) / price2;\n        }\n\n        int256 decimals10 = int256(10**(18 - priceFeed1.decimals()));\n        nowPrice = nowPrice * decimals10;\n\n        return (\n            roundID1,\n            nowPrice / 1000000,\n            startedAt1,\n            timeStamp1,\n            answeredInRound1\n        );\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup first oracle price\n      * @return price Current first oracle price\n      */ \n    function getOracle1_Price() public view returns (int256 price) {\n        (\n            uint80 roundID1,\n            int256 price1,\n            ,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        require(price1 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound1 >= roundID1,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp1 != 0, \"Timestamp == 0 !\");\n\n        return price1;\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup second oracle price\n      * @return price Current second oracle price\n      */ \n    function getOracle2_Price() public view returns (int256 price) {\n        (\n            uint80 roundID2,\n            int256 price2,\n            ,\n            uint256 timeStamp2,\n            uint80 answeredInRound2\n        ) = priceFeed2.latestRoundData();\n\n        require(price2 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound2 >= roundID2,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp2 != 0, \"Timestamp == 0 !\");\n\n        return price2;\n    }\n}"
    },
    {
      "filename": "src/rewards/RewardsFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {StakingRewards} from \"./StakingRewards.sol\";\nimport {VaultFactory} from \"../VaultFactory.sol\";\nimport {Vault} from \"../Vault.sol\";\n\ncontract RewardsFactory {\n    address public admin;\n    address public govToken;\n    address public factory;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint marketId);\n    error AddressNotAdmin();\n    error EpochDoesNotExist();\n\n    /*//////////////////////////////////////////////////////////////\n                                 MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    //mapping(uint => mapping(uint => address[])) public marketIndex_epoch_StakingRewards; //Market Index, Epoch, Staking Rewards [0] = insrance, [1] = risk\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(bytes32 => address[]) public hashedIndex_StakingRewards; //Hashed Index, Staking Rewards [0] = insrance, [1] = risk\n\n    /*//////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Creates staking rewards when event is emitted\n      * @param marketEpochId Current market epoch ID\n      * @param mIndex Current market index\n      * @param hedgeFarm Hedge farm address\n      * @param riskFarm Risk farm address\n      */ \n    event CreatedStakingReward(\n        bytes32 indexed marketEpochId,\n        uint256 indexed mIndex,\n        address hedgeFarm,\n        address riskFarm\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                  MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions with this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != admin)\n            revert AddressNotAdmin();\n        _;\n    }\n\n    /** @notice Contract constructor\n      * @param _govToken Governance token address\n      * @param _factory VaultFactory address\n      * @param _admin Admin address\n      */\n    constructor(\n        address _govToken,\n        address _factory,\n        address _admin\n    ) {\n        admin = _admin;\n        govToken = _govToken;\n        factory = _factory;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                  METHODS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Trigger staking rewards event\n      * @param _marketIndex Target market index\n      * @param _epochEnd End of epoch set for market\n      * @return insr Insurance rewards address, first tuple address entry \n      * @return risk Risk rewards address, second tuple address entry \n      */\n    function createStakingRewards(uint256 _marketIndex, uint256 _epochEnd, uint256 _rewardDuration, uint256 _rewardRate)\n        external\n        onlyAdmin\n        returns (address insr, address risk)\n    {\n        VaultFactory vaultFactory = VaultFactory(factory);\n\n        address _insrToken = vaultFactory.getVaults(_marketIndex)[0];\n        address _riskToken = vaultFactory.getVaults(_marketIndex)[1];\n\n        if(_insrToken == address(0) || _riskToken == address(0))\n            revert MarketDoesNotExist(_marketIndex);\n\n        if(Vault(_insrToken).idExists(_epochEnd) == false || Vault(_riskToken).idExists(_epochEnd) == false)\n            revert EpochDoesNotExist();\n\n        StakingRewards insrStake = new StakingRewards(\n            admin,\n            admin,\n            govToken,\n            _insrToken,\n            _epochEnd,\n            _rewardDuration,\n            _rewardRate\n        );\n        StakingRewards riskStake = new StakingRewards(\n            admin,\n            admin,\n            govToken,\n            _riskToken,\n            _epochEnd,\n            _rewardDuration,\n            _rewardRate\n        );\n\n        bytes32 hashedIndex = keccak256(abi.encode(_marketIndex, _epochEnd));\n        hashedIndex_StakingRewards[hashedIndex] = [\n            address(insrStake),\n            address(riskStake)\n        ];\n\n        emit CreatedStakingReward(\n            keccak256(\n                abi.encodePacked(\n                    _marketIndex,\n                    Vault(_insrToken).idEpochBegin(_epochEnd),\n                    _epochEnd\n                )\n            ),\n            _marketIndex,\n            address(insrStake),\n            address(riskStake)\n        );\n\n        return (address(insrStake), address(riskStake));\n    }\n\n    /** @notice Lookup hashed indexes\n      * @param _index Target index\n      * @param _epoch Target epoch\n      * @return hashedIndex hashed index\n      */\n    function getHashedIndex(uint256 _index, uint256 _epoch)\n        public\n        pure\n        returns (bytes32 hashedIndex)\n    {\n        return keccak256(abi.encode(_index, _epoch));\n    }\n}"
    }
  ]
}