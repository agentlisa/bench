{
  "Title": "[N-01] More accurate to use `<=` for validity of oracle timestamp",
  "Content": "\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/ReservoirOracleUnderwriter.sol#L106\n\nCurrently, the check for oracle timestamp to not exceed `block.timestamp` is done with a strict comparison. Using `<=` can be better here as `VALID_FOR` implies that the oracle timestamp would be valid for the entire duration.\n\n> `oracleInfo.message.timestamp + VALID_FOR < block.timestamp`\n\n### Recommendation\nChange to `oracleInfo.message.timestamp + VALID_FOR <= block.timestamp`\n\n**[wilsoncusack (Backed) commented](https://github.com/code-423n4/2022-12-backed-findings/issues/147#issuecomment-1410918068):**\n>\n> I disagree with `L-02 - latestAuctionStartTime can be wrongly set to 0 even if an NFT is still selling in auction.`\n>\n>The intent of latestAuctionStartTime is to ensure min spacing between any two auctions. If two auctions are running, that means that minSpacing time has passed. If minSpacing time has passed, then it is OK to reset latestAuctionStartTime after purchasing the latest auction to allow a 3rd auction to start.\n>\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-12-backed",
  "Code": [
    {
      "filename": "src/ReservoirOracleUnderwriter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {ReservoirOracle} from \"@reservoir/ReservoirOracle.sol\";\n\ncontract ReservoirOracleUnderwriter {\n    /// @notice The kind of floor price to use from the oracle\n    /// @dev SPOT is the floor price at the time of the oracle message\n    /// @dev TWAP is the average weighted floor price over the last TWAP_SECONDS\n    /// @dev LOWER is the minimum of SPOT and TWAP\n    /// @dev UPPER is the maximum of SPOT and TWAP\n    /// @dev see https://docs.reservoir.tools/reference/getoraclecollectionsflooraskv4 for more details\n    enum PriceKind {\n        SPOT,\n        TWAP,\n        LOWER,\n        UPPER\n    }\n\n    /// @notice The signature of a message from our oracle signer\n    struct Sig {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice The message and signature from our oracle signer\n    struct OracleInfo {\n        ReservoirOracle.Message message;\n        Sig sig;\n    }\n\n    /// @notice the amount of time to use for the TWAP\n    uint256 constant TWAP_SECONDS = 30 days;\n\n    /// @notice the maximum time a given signed oracle message is valid for\n    uint256 constant VALID_FOR = 20 minutes;\n\n    /// @notice the signing address the contract expects from the oracle message\n    address public immutable oracleSigner;\n\n    /// @notice address of the currency we are receiving oracle prices in\n    address public immutable quoteCurrency;\n\n    error IncorrectOracleSigner();\n    error WrongIdentifierFromOracleMessage();\n    error WrongCurrencyFromOracleMessage();\n    error OracleMessageTooOld();\n\n    constructor(address _oracleSigner, address _quoteCurrency) {\n        oracleSigner = _oracleSigner;\n        quoteCurrency = _quoteCurrency;\n    }\n\n    /// @notice returns the price of an asset from a signed oracle message\n    /// @param asset the address of the ERC721 asset to underwrite the price for\n    /// @param priceKind the kind of price the function expects the oracle message to contain\n    /// @param oracleInfo the message and signature from our oracle signer\n    /// @return oraclePrice the price of the asset, expressed in quoteCurrency units\n    /// @dev reverts if the signer of the oracle message is incorrect\n    /// @dev reverts if the oracle message was signed longer than VALID_FOR ago\n    /// @dev reverts if the oracle message is for the wrong ERC721 asset, wrong price kind, or wrong quote currency\n    function underwritePriceForCollateral(ERC721 asset, PriceKind priceKind, OracleInfo memory oracleInfo)\n        public\n        returns (uint256)\n    {\n        address signerAddress = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    // EIP-712 structured-data hash\n                    keccak256(\n                        abi.encode(\n                            keccak256(\"Message(bytes32 id,bytes payload,uint256 timestamp)\"),\n                            oracleInfo.message.id,\n                            keccak256(oracleInfo.message.payload),\n                            oracleInfo.message.timestamp\n                        )\n                    )\n                )\n            ),\n            oracleInfo.sig.v,\n            oracleInfo.sig.r,\n            oracleInfo.sig.s\n        );\n\n        if (signerAddress != oracleSigner) {\n            revert IncorrectOracleSigner();\n        }\n\n        bytes32 expectedId = keccak256(\n            abi.encode(\n                keccak256(\"ContractWideCollectionPrice(uint8 kind,uint256 twapSeconds,address contract)\"),\n                priceKind,\n                TWAP_SECONDS,\n                asset\n            )\n        );\n\n        if (oracleInfo.message.id != expectedId) {\n            revert WrongIdentifierFromOracleMessage();\n        }\n\n        if (\n            oracleInfo.message.timestamp > block.timestamp || oracleInfo.message.timestamp + VALID_FOR < block.timestamp\n        ) {\n            revert OracleMessageTooOld();\n        }\n\n        (address oracleQuoteCurrency, uint256 oraclePrice) = abi.decode(oracleInfo.message.payload, (address, uint256));\n        if (oracleQuoteCurrency != quoteCurrency) {\n            revert WrongCurrencyFromOracleMessage();\n        }\n\n        return oraclePrice;\n    }\n}"
    }
  ]
}