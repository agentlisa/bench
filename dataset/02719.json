{
  "Title": "M-11: Auctioneer Cannot Be Removed From The Protocol",
  "Content": "# Issue M-11: Auctioneer Cannot Be Removed From The Protocol \n\nSource: https://github.com/sherlock-audit/2022-11-bond-judging/issues/13 \n\n## Found by \nxiaoming90\n\n## Summary\n\nIf a vulnerable Auctioneer is being exploited by an attacker, there is no way to remove the vulnerable Auctioneer from the protocol.\n\n## Vulnerability Detail\n\nThe protocol is missing the feature to remove an auctioneer. Once an auctioneer has been added to the whitelist, it is not possible to remove the auctioneer from the whitelist.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L62\n\n```solidity\nFile: BondAggregator.sol\n62:     function registerAuctioneer(IBondAuctioneer auctioneer_) external requiresAuth {\n63:         // Restricted to authorized addresses\n64: \n65:         // Check that the auctioneer is not already registered\n66:         if (_whitelist[address(auctioneer_)])\n67:             revert Aggregator_AlreadyRegistered(address(auctioneer_));\n68: \n69:         // Add the auctioneer to the whitelist\n70:         auctioneers.push(auctioneer_);\n71:         _whitelist[address(auctioneer_)] = true;\n72:     }\n```\n\n## Impact\n\nIn the event that a whitelisted Auctioneer is found to be vulnerable and has been actively exploited by an attacker in the wild, the protocol needs to mitigate the issue swiftly by removing the vulnerable Auctioneer from the protocol. However, the mitigation effort will be hindered by the fact there is no way to remove an Auctioneer within the protocol once it has been whitelisted. Thus, it might not be possible to stop the attacker from exploiting the vulnerable Auctioneer. The protocol team would need to find a workaround to block the attack, which will introduce an unnecessary delay to the recovery process where every second counts.\n\nAdditionally, if the admin accidentally whitelisted the wrong Auctioneer, there is no way to remove it.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L62\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider implementing an additional function to allow the removal of an Auctioneer from the whitelist, so that vulnerable Auctioneer can be removed swiftly if needed.\n\n```solidity\nfunction deregisterAuctioneer(IBondAuctioneer auctioneer_) external requiresAuth {\n    // Remove the auctioneer from the whitelist\n    _whitelist[address(auctioneer_)] = false;\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nWe acknowledge that a whitelisted Auctioneer cannot be removed from the Aggregator. Auctioneers can be sunset by disallowing new markets to be created. Adding a function to remove a whitelisted auctioneer would effectively give the protocol the ability to shutdown live, user-created markets, which goes against the goal of a permissionless system. Users have the ability to close their own markets if needed.\n\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/20",
  "Code": [
    {
      "filename": "src/BondAggregator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\n\nimport {IBondAggregator} from \"./interfaces/IBondAggregator.sol\";\nimport {IBondTeller} from \"./interfaces/IBondTeller.sol\";\nimport {IBondAuctioneer} from \"./interfaces/IBondAuctioneer.sol\";\n\nimport {FullMath} from \"./lib/FullMath.sol\";\n\n/// @title Bond Aggregator\n/// @notice Bond Aggregator Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Aggregator contract keeps a unique set of market IDs across multiple\n///      Tellers and Auctioneers. Additionally, it aggregates market data from\n///      multiple Auctioneers in convenient view functions for front-end interfaces.\n///      The Aggregator contract should be deployed first since Tellers, Auctioneers, and\n///      Callbacks all require it in their constructors.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondAggregator is IBondAggregator, Auth {\n    using FullMath for uint256;\n\n    /* ========== ERRORS ========== */\n    error Aggregator_OnlyAuctioneer();\n    error Aggregator_AlreadyRegistered(address auctioneer_);\n    error Aggregator_InvalidParams();\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Counter for bond markets on approved auctioneers\n    uint256 public marketCounter;\n\n    /// @notice Approved auctioneers\n    IBondAuctioneer[] public auctioneers;\n    mapping(address => bool) internal _whitelist;\n\n    /// @notice Auctioneer for Market ID\n    mapping(uint256 => IBondAuctioneer) public marketsToAuctioneers;\n\n    /// @notice Market IDs for payout token\n    mapping(address => uint256[]) public marketsForPayout;\n\n    /// @notice Market IDs for quote token\n    mapping(address => uint256[]) public marketsForQuote;\n\n    // A 'vesting' param longer than 50 years is considered a timestamp for fixed expiry.\n    uint48 private constant MAX_FIXED_TERM = 52 weeks * 50;\n\n    constructor(address guardian_, Authority authority_) Auth(guardian_, authority_) {}\n\n    /// @inheritdoc IBondAggregator\n    function registerAuctioneer(IBondAuctioneer auctioneer_) external requiresAuth {\n        // Restricted to authorized addresses\n\n        // Check that the auctioneer is not already registered\n        if (_whitelist[address(auctioneer_)])\n            revert Aggregator_AlreadyRegistered(address(auctioneer_));\n\n        // Add the auctioneer to the whitelist\n        auctioneers.push(auctioneer_);\n        _whitelist[address(auctioneer_)] = true;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function registerMarket(ERC20 payoutToken_, ERC20 quoteToken_)\n        external\n        override\n        returns (uint256 marketId)\n    {\n        if (!_whitelist[msg.sender]) revert Aggregator_OnlyAuctioneer();\n        if (address(payoutToken_) == address(0) || address(quoteToken_) == address(0))\n            revert Aggregator_InvalidParams();\n        marketId = marketCounter;\n        marketsToAuctioneers[marketId] = IBondAuctioneer(msg.sender);\n        marketsForPayout[address(payoutToken_)].push(marketId);\n        marketsForQuote[address(quoteToken_)].push(marketId);\n        ++marketCounter;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /// @inheritdoc IBondAggregator\n    function getAuctioneer(uint256 id_) external view returns (IBondAuctioneer) {\n        return marketsToAuctioneers[id_];\n    }\n\n    /// @inheritdoc IBondAggregator\n    function marketPrice(uint256 id_) public view override returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.marketPrice(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function marketScale(uint256 id_) external view override returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.marketScale(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function payoutFor(\n        uint256 amount_,\n        uint256 id_,\n        address referrer_\n    ) public view override returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.payoutFor(amount_, id_, referrer_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.maxAmountAccepted(id_, referrer_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function isInstantSwap(uint256 id_) external view returns (bool) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.isInstantSwap(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function isLive(uint256 id_) public view override returns (bool) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.isLive(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function liveMarketsBetween(uint256 firstIndex_, uint256 lastIndex_)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256 count;\n        for (uint256 i = firstIndex_; i < lastIndex_; ++i) {\n            if (isLive(i)) ++count;\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n        for (uint256 i = firstIndex_; i < lastIndex_; ++i) {\n            if (isLive(i)) {\n                ids[count] = i;\n                ++count;\n            }\n        }\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function liveMarketsFor(address token_, bool isPayout_)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256[] memory mkts;\n\n        mkts = isPayout_ ? marketsForPayout[token_] : marketsForQuote[token_];\n\n        uint256 count;\n        uint256 len = mkts.length;\n\n        for (uint256 i; i < len; ++i) {\n            if (isLive(mkts[i])) ++count;\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n\n        for (uint256 i; i < len; ++i) {\n            if (isLive(mkts[i])) {\n                ids[count] = mkts[i];\n                ++count;\n            }\n        }\n\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function marketsFor(address payout_, address quote_) public view returns (uint256[] memory) {\n        uint256[] memory forPayout = liveMarketsFor(payout_, true);\n        uint256 count;\n\n        ERC20 quoteToken;\n        IBondAuctioneer auctioneer;\n        uint256 len = forPayout.length;\n        for (uint256 i; i < len; ++i) {\n            auctioneer = marketsToAuctioneers[forPayout[i]];\n            (, , , quoteToken, , ) = auctioneer.getMarketInfoForPurchase(forPayout[i]);\n            if (isLive(forPayout[i]) && address(quoteToken) == quote_) ++count;\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n\n        for (uint256 i; i < len; ++i) {\n            auctioneer = marketsToAuctioneers[forPayout[i]];\n            (, , , quoteToken, , ) = auctioneer.getMarketInfoForPurchase(forPayout[i]);\n            if (isLive(forPayout[i]) && address(quoteToken) == quote_) {\n                ids[count] = forPayout[i];\n                ++count;\n            }\n        }\n\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function findMarketFor(\n        address payout_,\n        address quote_,\n        uint256 amountIn_,\n        uint256 minAmountOut_,\n        uint256 maxExpiry_\n    ) external view returns (uint256) {\n        uint256[] memory ids = marketsFor(payout_, quote_);\n        uint256 len = ids.length;\n        uint256[] memory payouts = new uint256[](len);\n\n        uint256 highestOut;\n        uint256 id = type(uint256).max; // set to max so an empty set doesn't return 0, the first index\n        uint48 vesting;\n        uint256 maxPayout;\n        IBondAuctioneer auctioneer;\n        for (uint256 i; i < len; ++i) {\n            auctioneer = marketsToAuctioneers[ids[i]];\n            (, , , , vesting, maxPayout) = auctioneer.getMarketInfoForPurchase(ids[i]);\n\n            uint256 expiry = (vesting <= MAX_FIXED_TERM) ? block.timestamp + vesting : vesting;\n\n            if (expiry <= maxExpiry_) {\n                payouts[i] = minAmountOut_ <= maxPayout\n                    ? payoutFor(amountIn_, ids[i], address(0))\n                    : 0;\n\n                if (payouts[i] > highestOut) {\n                    highestOut = payouts[i];\n                    id = ids[i];\n                }\n            }\n        }\n\n        return id;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function liveMarketsBy(address owner_) external view returns (uint256[] memory) {\n        uint256 count;\n        IBondAuctioneer auctioneer;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ++count;\n            }\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ids[count] = i;\n                ++count;\n            }\n        }\n\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function getTeller(uint256 id_) external view returns (IBondTeller) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.getTeller();\n    }\n\n    /// @inheritdoc IBondAggregator\n    function currentCapacity(uint256 id_) external view returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.currentCapacity(id_);\n    }\n}"
    },
    {
      "filename": "src/BondAggregator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\n\nimport {IBondAggregator} from \"./interfaces/IBondAggregator.sol\";\nimport {IBondTeller} from \"./interfaces/IBondTeller.sol\";\nimport {IBondAuctioneer} from \"./interfaces/IBondAuctioneer.sol\";\n\nimport {FullMath} from \"./lib/FullMath.sol\";\n\n/// @title Bond Aggregator\n/// @notice Bond Aggregator Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Aggregator contract keeps a unique set of market IDs across multiple\n///      Tellers and Auctioneers. Additionally, it aggregates market data from\n///      multiple Auctioneers in convenient view functions for front-end interfaces.\n///      The Aggregator contract should be deployed first since Tellers, Auctioneers, and\n///      Callbacks all require it in their constructors.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondAggregator is IBondAggregator, Auth {\n    using FullMath for uint256;\n\n    /* ========== ERRORS ========== */\n    error Aggregator_OnlyAuctioneer();\n    error Aggregator_AlreadyRegistered(address auctioneer_);\n    error Aggregator_InvalidParams();\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Counter for bond markets on approved auctioneers\n    uint256 public marketCounter;\n\n    /// @notice Approved auctioneers\n    IBondAuctioneer[] public auctioneers;\n    mapping(address => bool) internal _whitelist;\n\n    /// @notice Auctioneer for Market ID\n    mapping(uint256 => IBondAuctioneer) public marketsToAuctioneers;\n\n    /// @notice Market IDs for payout token\n    mapping(address => uint256[]) public marketsForPayout;\n\n    /// @notice Market IDs for quote token\n    mapping(address => uint256[]) public marketsForQuote;\n\n    // A 'vesting' param longer than 50 years is considered a timestamp for fixed expiry.\n    uint48 private constant MAX_FIXED_TERM = 52 weeks * 50;\n\n    constructor(address guardian_, Authority authority_) Auth(guardian_, authority_) {}\n\n    /// @inheritdoc IBondAggregator\n    function registerAuctioneer(IBondAuctioneer auctioneer_) external requiresAuth {\n        // Restricted to authorized addresses\n\n        // Check that the auctioneer is not already registered\n        if (_whitelist[address(auctioneer_)])\n            revert Aggregator_AlreadyRegistered(address(auctioneer_));\n\n        // Add the auctioneer to the whitelist\n        auctioneers.push(auctioneer_);\n        _whitelist[address(auctioneer_)] = true;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function registerMarket(ERC20 payoutToken_, ERC20 quoteToken_)\n        external\n        override\n        returns (uint256 marketId)\n    {\n        if (!_whitelist[msg.sender]) revert Aggregator_OnlyAuctioneer();\n        if (address(payoutToken_) == address(0) || address(quoteToken_) == address(0))\n            revert Aggregator_InvalidParams();\n        marketId = marketCounter;\n        marketsToAuctioneers[marketId] = IBondAuctioneer(msg.sender);\n        marketsForPayout[address(payoutToken_)].push(marketId);\n        marketsForQuote[address(quoteToken_)].push(marketId);\n        ++marketCounter;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /// @inheritdoc IBondAggregator\n    function getAuctioneer(uint256 id_) external view returns (IBondAuctioneer) {\n        return marketsToAuctioneers[id_];\n    }\n\n    /// @inheritdoc IBondAggregator\n    function marketPrice(uint256 id_) public view override returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.marketPrice(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function marketScale(uint256 id_) external view override returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.marketScale(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function payoutFor(\n        uint256 amount_,\n        uint256 id_,\n        address referrer_\n    ) public view override returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.payoutFor(amount_, id_, referrer_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.maxAmountAccepted(id_, referrer_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function isInstantSwap(uint256 id_) external view returns (bool) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.isInstantSwap(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function isLive(uint256 id_) public view override returns (bool) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.isLive(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function liveMarketsBetween(uint256 firstIndex_, uint256 lastIndex_)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256 count;\n        for (uint256 i = firstIndex_; i < lastIndex_; ++i) {\n            if (isLive(i)) ++count;\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n        for (uint256 i = firstIndex_; i < lastIndex_; ++i) {\n            if (isLive(i)) {\n                ids[count] = i;\n                ++count;\n            }\n        }\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function liveMarketsFor(address token_, bool isPayout_)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256[] memory mkts;\n\n        mkts = isPayout_ ? marketsForPayout[token_] : marketsForQuote[token_];\n\n        uint256 count;\n        uint256 len = mkts.length;\n\n        for (uint256 i; i < len; ++i) {\n            if (isLive(mkts[i])) ++count;\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n\n        for (uint256 i; i < len; ++i) {\n            if (isLive(mkts[i])) {\n                ids[count] = mkts[i];\n                ++count;\n            }\n        }\n\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function marketsFor(address payout_, address quote_) public view returns (uint256[] memory) {\n        uint256[] memory forPayout = liveMarketsFor(payout_, true);\n        uint256 count;\n\n        ERC20 quoteToken;\n        IBondAuctioneer auctioneer;\n        uint256 len = forPayout.length;\n        for (uint256 i; i < len; ++i) {\n            auctioneer = marketsToAuctioneers[forPayout[i]];\n            (, , , quoteToken, , ) = auctioneer.getMarketInfoForPurchase(forPayout[i]);\n            if (isLive(forPayout[i]) && address(quoteToken) == quote_) ++count;\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n\n        for (uint256 i; i < len; ++i) {\n            auctioneer = marketsToAuctioneers[forPayout[i]];\n            (, , , quoteToken, , ) = auctioneer.getMarketInfoForPurchase(forPayout[i]);\n            if (isLive(forPayout[i]) && address(quoteToken) == quote_) {\n                ids[count] = forPayout[i];\n                ++count;\n            }\n        }\n\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function findMarketFor(\n        address payout_,\n        address quote_,\n        uint256 amountIn_,\n        uint256 minAmountOut_,\n        uint256 maxExpiry_\n    ) external view returns (uint256) {\n        uint256[] memory ids = marketsFor(payout_, quote_);\n        uint256 len = ids.length;\n        uint256[] memory payouts = new uint256[](len);\n\n        uint256 highestOut;\n        uint256 id = type(uint256).max; // set to max so an empty set doesn't return 0, the first index\n        uint48 vesting;\n        uint256 maxPayout;\n        IBondAuctioneer auctioneer;\n        for (uint256 i; i < len; ++i) {\n            auctioneer = marketsToAuctioneers[ids[i]];\n            (, , , , vesting, maxPayout) = auctioneer.getMarketInfoForPurchase(ids[i]);\n\n            uint256 expiry = (vesting <= MAX_FIXED_TERM) ? block.timestamp + vesting : vesting;\n\n            if (expiry <= maxExpiry_) {\n                payouts[i] = minAmountOut_ <= maxPayout\n                    ? payoutFor(amountIn_, ids[i], address(0))\n                    : 0;\n\n                if (payouts[i] > highestOut) {\n                    highestOut = payouts[i];\n                    id = ids[i];\n                }\n            }\n        }\n\n        return id;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function liveMarketsBy(address owner_) external view returns (uint256[] memory) {\n        uint256 count;\n        IBondAuctioneer auctioneer;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ++count;\n            }\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ids[count] = i;\n                ++count;\n            }\n        }\n\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function getTeller(uint256 id_) external view returns (IBondTeller) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.getTeller();\n    }\n\n    /// @inheritdoc IBondAggregator\n    function currentCapacity(uint256 id_) external view returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.currentCapacity(id_);\n    }\n}"
    }
  ]
}