{
  "Title": "[M-03] First depositor inflation attack in `PendlePowerFarmToken`",
  "Content": "\nIn certain scenarios, shares of a subsequent depositor can be heavily reduced, losing a large amount of his deposited funds, the attacker can increase the right side of the `previewMintShares` by adding rewards for compounding.\n\nThat way victim can lose `6e17` of his assets for a deposit of `1e18`.\n\n### Proof of Concept\n\nLet’s see how a first user, can grief a subsequent deposit and reduce his shares from the desired `1:1` ratio to `1:0000000000000005`.\n\nFirst, he needs to choose `PowerFarmToken` with no previous deposits.\n\n1. He calls `depositExactAmount` with 2 wei which will also call `syncSupply` `→` `_updateRewards` which is a key moment of the attack. This will make it possible `PowerFarmController::exchangeRewardsForCompoundingWithIncentive` to be called when performing the donation.\n2. With 2 wei user will mint 2 shares, so `totalSupply = 3` and `underlyingLpAssetsCurrent = 3`.\n3. Then, the victim comes and tries to deposit `1e18` of assets, but is front ran by the first user calling `PowerFarmController::exchangeRewardsForCompoundingWithIncentive` `→` `addCompoundRewards` with `999999999999999996` that will increase the `totalLpAssetsToDistribute`, which is added to `underlyingLpAssetsCurrent` in the `_syncSupply` function, called from the modifier before the main functions.\n\nThe attacker does not lose his deposit of `1e18` because it is converted to `rewardTokens` and sent to him, basically making the inflation free.\n\n[PendlePowerFarmController.sol#L53-L111](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L53-L111)\n\n```solidity\nfunction exchangeRewardsForCompoundingWithIncentive(\n      address _pendleMarket,\n      address _rewardToken,\n      uint256 _rewardAmount\n  ) external syncSupply(_pendleMarket) returns (uint256) {\n      CompoundStruct memory childInfo = pendleChildCompoundInfo[_pendleMarket];\n\n      uint256 index = _findIndex(childInfo.rewardTokens, _rewardToken);\n\n      if (childInfo.reservedForCompound[index] < _rewardAmount) {\n          revert NotEnoughCompound();\n      }\n\n      uint256 sendingAmount = _getAmountToSend(_pendleMarket, _getTokensInETH(_rewardToken, _rewardAmount));\n\n      childInfo.reservedForCompound[index] -= _rewardAmount;\n      pendleChildCompoundInfo[_pendleMarket] = childInfo;\n\n      _safeTransferFrom(_pendleMarket, msg.sender, address(this), sendingAmount);\n\n      IPendlePowerFarmToken(pendleChildAddress[_pendleMarket]).addCompoundRewards(sendingAmount);//@audit inflate\n\n      _safeTransfer(childInfo.rewardTokens[index], msg.sender, _rewardAmount);//@audit receive back + incentive\n\n      emit ExchangeRewardsForCompounding(_pendleMarket, _rewardToken, _rewardAmount, sendingAmount);\n\n      return sendingAmount;\n  }\n```\n\nAfter that, `totalSupply = 3`, `underlyingLpAssetsCurrent = 1e18 - 1`. The victim transaction is then executed:\n\n[PendlePowerFarmToken.sol#L452-L463](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L452-L463)\n\n```solidity\nfunction previewMintShares(uint256 _underlyingAssetAmount, uint256 _underlyingLpAssetsCurrent)\n        public\n        view\n        returns (uint256)\n    {\n        return _underlyingAssetAmount * totalSupply() / _underlyingLpAssetsCurrent;\n        // 1e18 * 3 / 1e18 - 1 = 2 \n    }\n```\n\nBoth attacker and victim have 1 share, because of the fee that is taken in the deposit function.\n\nAfter victim deposit: `totalSupply: 5`, `underlyingLpAssetsCurrent = 2e18 - 1`. Then, the victim tries to withdraw all his shares `- 1` (1 was taken as a fee on deposit).\n\n[PendlePowerFarmToken.sol#L465-L476](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L465-L476)\n\n```solidity\nfunction previewAmountWithdrawShares(uint256 _shares, uint256 _underlyingLpAssetsCurrent)\n        public\n        view\n        returns (uint256)\n    {\n        return _shares * _underlyingLpAssetsCurrent / totalSupply();\n\t        //1 * (2e18 - 1) / 5 = 399999999999999999 (0.3e18)\n    }\n```\n\nUser has lost `1e18 - 0.3e18 = 0.6e18` tokens.\n\n### Recommended Mitigation Steps\n\nSince there will be many `PowerFarmTokens` deployed, there is no way for team to perform the first deposit for all of them. Possible mitigation will be to have minimum deposit amount for the first depositor in the `PendlePowerToken`, which will increase the cost of the attack exponentially. There will not be enough reward tokens making the `exchangeRewardsForCompoundingWithIncentive` revert, due to insufficient amount. Or, could mint proper amount of tokens in the `initialize` function.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/271#issuecomment-2032169778):**\n > > Since there will be many `PowerFarmTokens` deployed, there is no way for team to perform the first deposit for all of them.\n> \n> I think this assumption is wrong here, team deploys each token and farm by admin - one by one, and each time a new token/farm is created, team can perform first deposit or necessary step. It is not a public function to create these that team cannot handle something like that or to say \"there is no way to perform the first deposit for all of them\". That's just blown off and far fetched.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/271#issuecomment-2090382531):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n>\n> Additional notes: before any farm is publicly available, admin creating farms can ensure no further supplier to the farm would experience any loss due to described far-fetched scenario in this \"finding\". \n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./PendlePowerFarmTokenFactory.sol\";\nimport \"./PendlePowerFarmControllerHelper.sol\";\n\ncontract PendlePowerFarmController is PendlePowerFarmControllerHelper {\n\n    PendlePowerFarmTokenFactory public immutable PENDLE_POWER_FARM_TOKEN_FACTORY;\n\n    constructor(\n        address _vePendle,\n        address _pendleToken,\n        address _voterContract,\n        address _voterRewardsClaimerAddress,\n        address _wiseOracleHub\n    )\n        PendlePowerFarmControllerBase(\n            _vePendle,\n            _pendleToken,\n            _voterContract,\n            _voterRewardsClaimerAddress,\n            _wiseOracleHub\n        )\n    {\n        PENDLE_POWER_FARM_TOKEN_FACTORY = new PendlePowerFarmTokenFactory(\n            address(this)\n        );\n    }\n\n    function withdrawLp(\n        address _pendleMarket,\n        address _to,\n        uint256 _amount\n    )\n        external\n        onlyChildContract(_pendleMarket)\n    {\n        _safeTransfer(\n            _pendleMarket,\n            _to,\n            _amount\n        );\n\n        emit WithdrawLp(\n            _pendleMarket,\n            _to,\n            _amount\n        );\n    }\n\n    function exchangeRewardsForCompoundingWithIncentive(\n        address _pendleMarket,\n        address _rewardToken,\n        uint256 _rewardAmount\n    )\n        external\n        syncSupply(_pendleMarket)\n        returns (uint256)\n    {\n        CompoundStruct memory childInfo = pendleChildCompoundInfo[\n            _pendleMarket\n        ];\n\n        uint256 index = _findIndex(\n            childInfo.rewardTokens,\n            _rewardToken\n        );\n\n        if (childInfo.reservedForCompound[index] < _rewardAmount) {\n            revert NotEnoughCompound();\n        }\n\n        uint256 sendingAmount = _getAmountToSend(\n            _pendleMarket,\n            _getTokensInETH(\n                _rewardToken,\n                _rewardAmount\n            )\n        );\n\n        childInfo.reservedForCompound[index] -= _rewardAmount;\n        pendleChildCompoundInfo[_pendleMarket] = childInfo;\n\n        _safeTransferFrom(\n            _pendleMarket,\n            msg.sender,\n            address(this),\n            sendingAmount\n        );\n\n        IPendlePowerFarmToken(pendleChildAddress[_pendleMarket]).addCompoundRewards(\n            sendingAmount\n        );\n\n        _safeTransfer(\n            childInfo.rewardTokens[index],\n            msg.sender,\n            _rewardAmount\n        );\n\n        emit ExchangeRewardsForCompounding(\n            _pendleMarket,\n            _rewardToken,\n            _rewardAmount,\n            sendingAmount\n        );\n\n        return sendingAmount;\n    }\n\n    function exchangeLpFeesForPendleWithIncentive(\n        address _pendleMarket,\n        uint256 _pendleChildShares\n    )\n        external\n        syncSupply(_pendleMarket)\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        if (_pendleChildShares == 0) {\n            revert ZeroShares();\n        }\n\n        address pendleChild = pendleChildAddress[\n            _pendleMarket\n        ];\n\n        uint256 tokenAmountSend = _getAmountToSend(\n            PENDLE_TOKEN_ADDRESS,\n            _getTokensInETH(\n                pendleChild,\n                _pendleChildShares\n            )\n        );\n\n        reservedPendleForLocking += tokenAmountSend;\n\n        _safeTransferFrom(\n            PENDLE_TOKEN_ADDRESS,\n            msg.sender,\n            address(this),\n            tokenAmountSend\n        );\n\n        uint256 withdrawnAmount = IPendlePowerFarmToken(pendleChild).withdrawExactShares(\n            _pendleChildShares\n        );\n\n        _safeTransfer(\n            _pendleMarket,\n            msg.sender,\n            withdrawnAmount\n        );\n\n        emit ExchangeLpFeesForPendle(\n            _pendleMarket,\n            _pendleChildShares,\n            tokenAmountSend,\n            withdrawnAmount\n        );\n\n        return(\n            tokenAmountSend,\n            withdrawnAmount\n        );\n    }\n\n    function skim(\n        address _pendleMarket\n    )\n        external\n        returns (uint256)\n    {\n        address childMarket = pendleChildAddress[\n            _pendleMarket\n        ];\n\n        if (childMarket == ZERO_ADDRESS) {\n            revert WrongAddress();\n        }\n\n        uint256 balance = IPendleMarket(_pendleMarket).balanceOf(\n            address(this)\n        );\n\n        uint256 totalAssets = IPendlePowerFarmToken(\n            childMarket\n        ).totalLpAssets();\n\n        if (balance < totalAssets + 1) {\n            revert NothingToSkim();\n        }\n\n        uint256 difference = balance\n            - totalAssets\n            + 1;\n\n        _safeTransfer(\n            _pendleMarket,\n            master,\n            difference\n        );\n\n        return difference;\n    }\n\n    function addPendleMarket(\n        address _pendleMarket,\n        string memory _tokenName,\n        string memory _symbolName,\n        uint16 _maxCardinality\n    )\n        external\n        onlyMaster\n    {\n        if (pendleChildAddress[_pendleMarket] > ZERO_ADDRESS) {\n            revert AlreadySet();\n        }\n\n        address pendleChild = PENDLE_POWER_FARM_TOKEN_FACTORY.deploy(\n            _pendleMarket,\n            _tokenName,\n            _symbolName,\n            _maxCardinality\n        );\n\n        pendleChildAddress[_pendleMarket] = pendleChild;\n\n        _setRewardTokens(\n            _pendleMarket,\n            _getRewardTokens(\n                _pendleMarket\n            )\n        );\n\n        CompoundStruct storage childInfo = pendleChildCompoundInfo[\n            _pendleMarket\n        ];\n\n        uint256 rewardTokensLength = childInfo\n            .rewardTokens\n            .length;\n\n        childInfo.lastIndex = new uint128[](\n            rewardTokensLength\n        );\n\n        childInfo.reservedForCompound = new uint256[](\n            rewardTokensLength\n        );\n\n        uint256 i;\n\n        while (i < rewardTokensLength) {\n\n            address token = childInfo.rewardTokens[i];\n\n            childInfo.lastIndex[i] = _getUserRewardIndex(\n                _pendleMarket,\n                token,\n                address(this)\n            );\n\n            childInfo.reservedForCompound[i] = 0;\n\n            _checkFeed(\n                token\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _checkFeed(\n            _pendleMarket\n        );\n\n        activePendleMarkets.push(\n            _pendleMarket\n        );\n\n        emit AddPendleMarket(\n            _pendleMarket,\n            pendleChild\n        );\n    }\n\n    function updateRewardTokens(\n        address _pendleMarket\n    )\n        external\n        onlyChildContract(_pendleMarket)\n        returns (bool)\n    {\n        address[] memory rewardTokens = _getRewardTokens(\n            _pendleMarket\n        );\n\n        if (_compareHashes(_pendleMarket, rewardTokens) == true) {\n            return false;\n        }\n\n        _setRewardTokens(\n            _pendleMarket,\n            rewardTokens\n        );\n\n        emit UpdateRewardTokens(\n            _pendleMarket,\n            rewardTokens\n        );\n\n        return true;\n    }\n\n    function changeExchangeIncentive(\n        uint256 _newExchangeIncentive\n    )\n        external\n        onlyMaster\n    {\n        exchangeIncentive = _newExchangeIncentive;\n\n        emit ChangeExchangeIncentive(\n            _newExchangeIncentive\n        );\n    }\n\n    function changeMintFee(\n        address _pendleMarket,\n        uint256 _newFee\n    )\n        external\n        onlyMaster\n    {\n        address child = pendleChildAddress[\n            _pendleMarket\n        ];\n\n        if (child == ZERO_ADDRESS) {\n            revert WrongAddress();\n        }\n\n        IPendlePowerFarmToken(\n            child\n        ).changeMintFee(\n            _newFee\n        );\n\n        emit ChangeMintFee(\n            _pendleMarket,\n            _newFee\n        );\n    }\n\n    /**\n     * @dev Can also be used to extend existing lock.\n     */\n    function lockPendle(\n        uint256 _amount,\n        uint128 _weeks,\n        bool _fromInside,\n        bool _sameExpiry\n    )\n        external\n        onlyMaster\n        returns (uint256 newVeBalance)\n    {\n        syncAllSupply();\n\n        uint256 currentExpiry = _getExpiry();\n\n        uint128 expiry = _sameExpiry\n            ? uint128(currentExpiry)\n            : _calcExpiry(\n                _weeks\n            );\n\n        if (uint256(expiry) < currentExpiry) {\n            revert LockTimeTooShort();\n        }\n\n        if (_amount > 0) {\n\n            _safeApprove(\n                PENDLE_TOKEN_ADDRESS,\n                VE_PENDLE_CONTRACT_ADDRESS,\n                _amount\n            );\n\n            if (_fromInside == false) {\n                _safeTransferFrom(\n                    PENDLE_TOKEN_ADDRESS,\n                    msg.sender,\n                    address(this),\n                    _amount\n                );\n            }\n        }\n\n        newVeBalance = PENDLE_LOCK.increaseLockPosition(\n            uint128(_amount),\n            expiry\n        );\n\n        syncAllSupply();\n\n        if (_fromInside == false) {\n            return newVeBalance;\n        }\n\n        if (_amount > 0) {\n            reservedPendleForLocking -= _amount;\n        }\n\n        emit LockPendle(\n            _amount,\n            expiry,\n            newVeBalance,\n            _fromInside,\n            _sameExpiry,\n            block.timestamp\n        );\n    }\n\n    function claimArb(\n        uint256 _accrued,\n        bytes32[] calldata _proof\n    )\n        external\n        onlyArbitrum\n    {\n        ARB_REWARDS.claim(\n            master,\n            _accrued,\n            _proof\n        );\n\n        emit ClaimArb(\n            _accrued,\n            _proof,\n            block.timestamp\n        );\n    }\n\n    function withdrawLock()\n        external\n        onlyMaster\n        returns (uint256 amount)\n    {\n        if (IS_ETH_MAIN == false) {\n\n            amount = reservedPendleForLocking;\n            reservedPendleForLocking = 0;\n\n            _safeTransfer(\n                PENDLE_TOKEN_ADDRESS,\n                master,\n                amount\n            );\n\n            emit WithdrawLock(\n                amount,\n                block.timestamp\n            );\n\n            return amount;\n        }\n\n        if (_getExpiry() > block.timestamp) {\n            revert NotExpired();\n        }\n\n        syncAllSupply();\n\n        amount = PENDLE_LOCK.withdraw();\n\n        _safeTransfer(\n            PENDLE_TOKEN_ADDRESS,\n            master,\n            amount\n        );\n\n        syncAllSupply();\n\n        emit WithdrawLock(\n            amount,\n            block.timestamp\n        );\n    }\n\n    function increaseReservedForCompound(\n        address _pendleMarket,\n        uint256[] calldata _amounts\n    )\n        external\n        onlyChildContract(_pendleMarket)\n    {\n        CompoundStruct memory childInfo = pendleChildCompoundInfo[\n            _pendleMarket\n        ];\n\n        uint256 i;\n        uint256 length = childInfo.rewardTokens.length;\n\n        while (i < length) {\n            childInfo.reservedForCompound[i] += _amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        pendleChildCompoundInfo[_pendleMarket] = childInfo;\n\n        emit IncreaseReservedForCompound(\n            _pendleMarket,\n            _amounts\n        );\n    }\n\n    function overWriteIndex(\n        address _pendleMarket,\n        uint256 _tokenIndex\n    )\n        public\n        onlyChildContract(_pendleMarket)\n    {\n        CompoundStruct storage childInfo = pendleChildCompoundInfo[\n            _pendleMarket\n        ];\n\n        childInfo.lastIndex[_tokenIndex] = _getUserRewardIndex(\n            _pendleMarket,\n            childInfo.rewardTokens[_tokenIndex],\n            address(this)\n        );\n    }\n\n    function overWriteIndexAll(\n        address _pendleMarket\n    )\n        external\n        onlyChildContract(_pendleMarket)\n    {\n        uint256 i;\n        uint256 length = pendleChildCompoundInfo[\n            _pendleMarket\n        ].rewardTokens.length;\n\n        while (i < length) {\n            overWriteIndex(\n                _pendleMarket,\n                i\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function overWriteAmounts(\n        address _pendleMarket\n    )\n        external\n        onlyChildContract(_pendleMarket)\n    {\n        CompoundStruct storage childInfo = pendleChildCompoundInfo[\n            _pendleMarket\n        ];\n\n        childInfo.reservedForCompound = new uint256[](\n            childInfo.rewardTokens.length\n        );\n    }\n\n    function claimVoteRewards(\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    )\n        external\n    {\n        PENDLE_VOTE_REWARDS.claimRetail(\n            address(this),\n            _amount,\n            _merkleProof\n        );\n\n        emit ClaimVoteRewards(\n            _amount,\n            _merkleProof,\n            block.timestamp\n        );\n    }\n\n    function forwardETH(\n        address _to,\n        uint256 _amount\n    )\n        external\n        onlyMaster\n    {\n        payable(_to).transfer(\n            _amount\n        );\n    }\n\n    function vote(\n        address[] calldata _pools,\n        uint64[] calldata _weights\n    )\n        external\n        onlyMaster\n    {\n        if (_weights.length != _pools.length) {\n            revert InvalidLength();\n        }\n\n        uint256 i;\n        uint256 len = _weights.length;\n\n        uint256 weightSum;\n\n        while (i < len) {\n            unchecked {\n                weightSum += _weights[i];\n                ++i;\n            }\n        }\n\n        if (weightSum > PRECISION_FACTOR_E18) {\n            revert InvalidWeightSum();\n        }\n\n        PENDLE_VOTER.vote(\n            _pools,\n            _weights\n        );\n    }\n}"
    },
    {
      "filename": "contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./SimpleERC20Clone.sol\";\n\nimport \"../../InterfaceHub/IPendle.sol\";\nimport \"../../InterfaceHub/IPendleController.sol\";\n\nimport \"../../TransferHub/TransferHelper.sol\";\n\nerror MarketExpired();\nerror NotController();\nerror ZeroFee();\nerror TooMuchFee();\nerror NotEnoughLpAssetsTransferred();\nerror InsufficientShares();\nerror ZeroAmount();\nerror FeeTooHigh();\nerror NotEnoughShares();\nerror InvalidSharePriceGrowth();\nerror InvalidSharePrice();\nerror AlreadyInitialized();\n\ncontract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n\n    // Pendle - LP token address\n    address public UNDERLYING_PENDLE_MARKET;\n    address public PENDLE_POWER_FARM_CONTROLLER;\n\n    // Total balance of LPs backing at current compound distribution\n    uint256 public underlyingLpAssetsCurrent;\n\n    // Lp assets from compound left to distribute\n    uint256 public totalLpAssetsToDistribute;\n\n    // Interface Object for underlying Market\n    IPendleMarket public PENDLE_MARKET;\n\n    // InterfaceObject for pendle Sy\n    IPendleSy public PENDLE_SY;\n\n    // Interface for Pendle Controller\n    IPendleController public PENDLE_CONTROLLER;\n\n    // Max cardinality of Pendle Market\n    uint16 public MAX_CARDINALITY;\n\n    uint256 public mintFee;\n    uint256 public lastInteraction;\n\n    uint256 private constant ONE_WEEK = 7 days;\n    uint256 internal constant ONE_YEAR = 365 days;\n    uint256 private constant MAX_MINT_FEE = 10000;\n\n    uint256 private constant PRECISION_FACTOR_E6 = 1E6;\n    uint256 private constant PRECISION_FACTOR_E18 = 1E18;\n    uint256 internal constant PRECISION_FACTOR_E36 = PRECISION_FACTOR_E18 * PRECISION_FACTOR_E18;\n    uint256 internal constant PRECISION_FACTOR_YEAR = PRECISION_FACTOR_E18 * ONE_YEAR;\n\n    uint256 private INITIAL_TIME_STAMP;\n\n    uint256 internal constant RESTRICTION_FACTOR = 10\n        * PRECISION_FACTOR_E36\n        / PRECISION_FACTOR_YEAR;\n\n    modifier onlyController() {\n        _onlyController();\n        _;\n    }\n\n    function _onlyController()\n        private\n        view\n    {\n        if (msg.sender != PENDLE_POWER_FARM_CONTROLLER) {\n            revert NotController();\n        }\n    }\n\n    modifier syncSupply()\n    {\n        _triggerIndexUpdate();\n        _overWriteCheck();\n        _syncSupply();\n        _updateRewards();\n        _setLastInteraction();\n        _increaseCardinalityNext();\n        uint256 sharePriceBefore = _getSharePrice();\n        _;\n        _validateSharePriceGrowth(\n            _validateSharePrice(\n                sharePriceBefore\n            )\n        );\n    }\n\n    function _validateSharePrice(\n        uint256 _sharePriceBefore\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 sharePricenNow = _getSharePrice();\n\n        if (sharePricenNow < _sharePriceBefore) {\n            revert InvalidSharePrice();\n        }\n\n        return sharePricenNow;\n    }\n\n    function _validateSharePriceGrowth(\n        uint256 _sharePriceNow\n    )\n        private\n        view\n    {\n        uint256 timeDifference = block.timestamp\n            - INITIAL_TIME_STAMP;\n\n        uint256 maximum = timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n\n        if (_sharePriceNow > maximum) {\n            revert InvalidSharePriceGrowth();\n        }\n    }\n\n    function _overWriteCheck()\n        internal\n    {\n        _wrapOverWrites(\n            _updateRewardTokens()\n        );\n    }\n\n    function _triggerIndexUpdate()\n        internal\n    {\n        _withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            0\n        );\n    }\n\n    function _wrapOverWrites(\n        bool _overWritten\n    )\n        internal\n    {\n        if (_overWritten == true) {\n            _overWriteIndexAll();\n            _overWriteAmounts();\n        }\n    }\n\n    function _updateRewardTokens()\n        private\n        returns (bool)\n    {\n        return PENDLE_CONTROLLER.updateRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndexAll()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndexAll(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndex(\n        uint256 _index\n    )\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndex(\n            UNDERLYING_PENDLE_MARKET,\n            _index\n        );\n    }\n\n    function _overWriteAmounts()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteAmounts(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _updateRewards()\n        private\n    {\n        uint256[] memory rewardsOutsideArray = _calculateRewardsClaimedOutside();\n\n        uint256 i;\n        uint256 l = rewardsOutsideArray.length;\n\n        while (i < l) {\n            if (rewardsOutsideArray[i] > 0) {\n                PENDLE_CONTROLLER.increaseReservedForCompound(\n                    UNDERLYING_PENDLE_MARKET,\n                    rewardsOutsideArray\n                );\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _calculateRewardsClaimedOutside()\n        internal\n        returns (uint256[] memory)\n    {\n        address[] memory rewardTokens = PENDLE_CONTROLLER.pendleChildCompoundInfoRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint128[] memory lastIndex = PENDLE_CONTROLLER.pendleChildCompoundInfoLastIndex(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint256 l = rewardTokens.length;\n        uint256[] memory rewardsOutsideArray = new uint256[](l);\n\n        uint256 i;\n        uint128 index;\n\n        while (i < l) {\n            UserReward memory userReward = _getUserReward(\n                rewardTokens[i],\n                PENDLE_POWER_FARM_CONTROLLER\n            );\n\n            if (userReward.accrued > 0) {\n                PENDLE_MARKET.redeemRewards(\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n\n                userReward = _getUserReward(\n                    rewardTokens[i],\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n            }\n\n            index = userReward.index;\n\n            if (lastIndex[i] == 0 && index > 0) {\n                rewardsOutsideArray[i] = 0;\n                _overWriteIndex(\n                    i\n                );\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            if (index == lastIndex[i]) {\n                rewardsOutsideArray[i] = 0;\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            uint256 indexDiff = index\n                - lastIndex[i];\n\n            uint256 activeBalance = _getActiveBalance();\n            uint256 totalLpAssetsCurrent = totalLpAssets();\n            uint256 lpBalanceController = _getBalanceLpBalanceController();\n\n            bool scaleNecessary = totalLpAssetsCurrent < lpBalanceController;\n\n            rewardsOutsideArray[i] = scaleNecessary\n                ? indexDiff\n                    * activeBalance\n                    * totalLpAssetsCurrent\n                    / lpBalanceController\n                    / PRECISION_FACTOR_E18\n                : indexDiff\n                    * activeBalance\n                    / PRECISION_FACTOR_E18;\n\n            _overWriteIndex(\n                i\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewardsOutsideArray;\n    }\n\n    function _getBalanceLpBalanceController()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.balanceOf(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getActiveBalance()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.activeBalance(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getSharePrice()\n        private\n        view\n        returns (uint256)\n    {\n        return previewUnderlyingLpAssets() * PRECISION_FACTOR_E18\n            / totalSupply();\n    }\n\n    function _syncSupply()\n        private\n    {\n        uint256 additonalAssets = previewDistribution();\n\n        if (additonalAssets == 0) {\n            return;\n        }\n\n        underlyingLpAssetsCurrent += additonalAssets;\n        totalLpAssetsToDistribute -= additonalAssets;\n    }\n\n    function _increaseCardinalityNext()\n        internal\n    {\n        MarketStorage memory storageMarket = PENDLE_MARKET._storage();\n\n        if (storageMarket.observationCardinalityNext < MAX_CARDINALITY) {\n            PENDLE_MARKET.increaseObservationsCardinalityNext(\n                storageMarket.observationCardinalityNext + 1\n            );\n        }\n    }\n\n    function _withdrawLp(\n        address _to,\n        uint256 _amount\n    )\n        internal\n    {\n        PENDLE_CONTROLLER.withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            _to,\n            _amount\n        );\n    }\n\n    function _getUserReward(\n        address _rewardToken,\n        address _user\n    )\n        internal\n        view\n        returns (UserReward memory)\n    {\n        return PENDLE_MARKET.userReward(\n            _rewardToken,\n            _user\n        );\n    }\n\n    function previewDistribution()\n        public\n        view\n        returns (uint256)\n    {\n        if (totalLpAssetsToDistribute == 0) {\n            return 0;\n        }\n\n        if (block.timestamp == lastInteraction) {\n            return 0;\n        }\n\n        if (totalLpAssetsToDistribute < ONE_WEEK) {\n            return totalLpAssetsToDistribute;\n        }\n\n        uint256 currentRate = totalLpAssetsToDistribute\n            / ONE_WEEK;\n\n        uint256 additonalAssets = currentRate\n            * (block.timestamp - lastInteraction);\n\n        if (additonalAssets > totalLpAssetsToDistribute) {\n            return totalLpAssetsToDistribute;\n        }\n\n        return additonalAssets;\n    }\n\n    function _setLastInteraction()\n        private\n    {\n        lastInteraction = block.timestamp;\n    }\n\n    function _applyMintFee(\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _amount\n            * (PRECISION_FACTOR_E6 - mintFee)\n            / PRECISION_FACTOR_E6;\n    }\n\n    function totalLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return underlyingLpAssetsCurrent\n            + totalLpAssetsToDistribute;\n    }\n\n    function previewUnderlyingLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return previewDistribution()\n            + underlyingLpAssetsCurrent;\n    }\n\n    function previewMintShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _underlyingAssetAmount\n            * totalSupply()\n            / _underlyingLpAssetsCurrent;\n    }\n\n    function previewAmountWithdrawShares(\n        uint256 _shares,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _shares\n            * _underlyingLpAssetsCurrent\n            / totalSupply();\n    }\n\n    function previewBurnShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 product = _underlyingAssetAmount\n            * totalSupply();\n\n        return product % _underlyingLpAssetsCurrent == 0\n            ? product / _underlyingLpAssetsCurrent\n            : product / _underlyingLpAssetsCurrent + 1;\n    }\n\n    function manualSync()\n        external\n        syncSupply\n        returns (bool)\n    {\n        return true;\n    }\n\n    function addCompoundRewards(\n        uint256 _amount\n    )\n        external\n        syncSupply\n    {\n        if (_amount == 0) {\n            revert ZeroAmount();\n        }\n\n        totalLpAssetsToDistribute += _amount;\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return;\n        }\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _amount\n        );\n    }\n\n    /**\n     * @dev External wrapper for mint function.\n     */\n    function depositExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewMintShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares == 0) {\n            revert NotEnoughLpAssetsTransferred();\n        }\n\n        uint256 reducedShares = _applyMintFee(\n            shares\n        );\n\n        uint256 feeShares = shares\n            - reducedShares;\n\n        if (feeShares == 0) {\n            revert ZeroFee();\n        }\n\n        if (reducedShares == feeShares) {\n            revert TooMuchFee();\n        }\n\n        _mint(\n            msg.sender,\n            reducedShares\n        );\n\n        _mint(\n            PENDLE_POWER_FARM_CONTROLLER,\n            feeShares\n        );\n\n        underlyingLpAssetsCurrent += _underlyingLpAssetAmount;\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _underlyingLpAssetAmount\n        );\n\n        return (\n            reducedShares,\n            feeShares\n        );\n    }\n\n    function changeMintFee(\n        uint256 _newFee\n    )\n        external\n        onlyController\n    {\n        if (_newFee > MAX_MINT_FEE) {\n            revert FeeTooHigh();\n        }\n\n        mintFee = _newFee;\n    }\n\n    /**\n     * @dev External wrapper for burn function.\n     */\n    function withdrawExactShares(\n        uint256 _shares\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_shares == 0) {\n            revert ZeroAmount();\n        }\n\n        if (_shares > balanceOf(msg.sender)) {\n            revert InsufficientShares();\n        }\n\n        uint256 tokenAmount = previewAmountWithdrawShares(\n            _shares,\n            underlyingLpAssetsCurrent\n        );\n\n        underlyingLpAssetsCurrent -= tokenAmount;\n\n        _burn(\n            msg.sender,\n            _shares\n        );\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return tokenAmount;\n        }\n\n        _withdrawLp(\n            msg.sender,\n            tokenAmount\n        );\n\n        return tokenAmount;\n    }\n\n    function withdrawExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewBurnShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares > balanceOf(msg.sender)) {\n            revert NotEnoughShares();\n        }\n\n        _burn(\n            msg.sender,\n            shares\n        );\n\n        underlyingLpAssetsCurrent -= _underlyingLpAssetAmount;\n\n        _withdrawLp(\n            msg.sender,\n            _underlyingLpAssetAmount\n        );\n\n        return shares;\n    }\n\n    function initialize(\n        address _underlyingPendleMarket,\n        address _pendleController,\n        string memory _tokenName,\n        string memory _symbolName,\n        uint16 _maxCardinality\n    )\n        external\n    {\n        if (address(PENDLE_MARKET) != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        PENDLE_MARKET = IPendleMarket(\n            _underlyingPendleMarket\n        );\n\n        if (PENDLE_MARKET.isExpired() == true) {\n            revert MarketExpired();\n        }\n\n        PENDLE_CONTROLLER = IPendleController(\n            _pendleController\n        );\n\n        MAX_CARDINALITY = _maxCardinality;\n\n        _name = _tokenName;\n        _symbol = _symbolName;\n\n        PENDLE_POWER_FARM_CONTROLLER = _pendleController;\n        UNDERLYING_PENDLE_MARKET = _underlyingPendleMarket;\n\n        (\n            address pendleSyAddress,\n            ,\n        ) = PENDLE_MARKET.readTokens();\n\n        PENDLE_SY = IPendleSy(\n            pendleSyAddress\n        );\n\n        _decimals = PENDLE_SY.decimals();\n\n        lastInteraction = block.timestamp;\n\n        _totalSupply = 1;\n        underlyingLpAssetsCurrent = 1;\n        mintFee = 3000;\n        INITIAL_TIME_STAMP = block.timestamp;\n    }\n}"
    },
    {
      "filename": "contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./SimpleERC20Clone.sol\";\n\nimport \"../../InterfaceHub/IPendle.sol\";\nimport \"../../InterfaceHub/IPendleController.sol\";\n\nimport \"../../TransferHub/TransferHelper.sol\";\n\nerror MarketExpired();\nerror NotController();\nerror ZeroFee();\nerror TooMuchFee();\nerror NotEnoughLpAssetsTransferred();\nerror InsufficientShares();\nerror ZeroAmount();\nerror FeeTooHigh();\nerror NotEnoughShares();\nerror InvalidSharePriceGrowth();\nerror InvalidSharePrice();\nerror AlreadyInitialized();\n\ncontract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n\n    // Pendle - LP token address\n    address public UNDERLYING_PENDLE_MARKET;\n    address public PENDLE_POWER_FARM_CONTROLLER;\n\n    // Total balance of LPs backing at current compound distribution\n    uint256 public underlyingLpAssetsCurrent;\n\n    // Lp assets from compound left to distribute\n    uint256 public totalLpAssetsToDistribute;\n\n    // Interface Object for underlying Market\n    IPendleMarket public PENDLE_MARKET;\n\n    // InterfaceObject for pendle Sy\n    IPendleSy public PENDLE_SY;\n\n    // Interface for Pendle Controller\n    IPendleController public PENDLE_CONTROLLER;\n\n    // Max cardinality of Pendle Market\n    uint16 public MAX_CARDINALITY;\n\n    uint256 public mintFee;\n    uint256 public lastInteraction;\n\n    uint256 private constant ONE_WEEK = 7 days;\n    uint256 internal constant ONE_YEAR = 365 days;\n    uint256 private constant MAX_MINT_FEE = 10000;\n\n    uint256 private constant PRECISION_FACTOR_E6 = 1E6;\n    uint256 private constant PRECISION_FACTOR_E18 = 1E18;\n    uint256 internal constant PRECISION_FACTOR_E36 = PRECISION_FACTOR_E18 * PRECISION_FACTOR_E18;\n    uint256 internal constant PRECISION_FACTOR_YEAR = PRECISION_FACTOR_E18 * ONE_YEAR;\n\n    uint256 private INITIAL_TIME_STAMP;\n\n    uint256 internal constant RESTRICTION_FACTOR = 10\n        * PRECISION_FACTOR_E36\n        / PRECISION_FACTOR_YEAR;\n\n    modifier onlyController() {\n        _onlyController();\n        _;\n    }\n\n    function _onlyController()\n        private\n        view"
    }
  ]
}