{
  "Title": "[L21] Unvetted function call",
  "Content": "The [`withdrawErc20` function](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/common/implementation/Withdrawable.sol#L27) in the `Withdrawable` contract and the [`payOracleFeesErc20` function](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Store.sol#L67) in the `Store` contract both call an unvetted function ([`transfer`](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/common/implementation/Withdrawable.sol#L29) and [`transferFrom`](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Store.sol#L71) respectively) on a user-specified address. If the address is chosen maliciously, this could result in arbitrary code being executed within another contract on behalf of the the UMA contract. This does not directly affect the UMA system but it does introduce an unexpected behavior. To improve predictability, consider whitelisting or vetting the contracts that can be passed to the `withdrawErc20` and `payOracleFeesErc20` functions.\n\n\n**Update:** *This issue is acknowledged because, according to UMA, the suggested mitigation would introduce too much complexity for minimal gain.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "core/contracts/common/implementation/Withdrawable.sol",
      "content": "/**\n * Withdrawable contract.\n */\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./MultiRole.sol\";\n\n\n/**\n * @title Base contract that allows a specific role to withdraw any ETH and/or ERC20 tokens that the contract holds.\n */\ncontract Withdrawable is MultiRole {\n    uint private _roleId;\n\n    /**\n     * @notice Withdraws ETH from the contract.\n     */\n    function withdraw(uint amount) external onlyRoleHolder(_roleId) {\n        msg.sender.transfer(amount);\n    }\n\n    /**\n     * @notice Withdraws ERC20 tokens from the contract.\n     */\n    function withdrawErc20(address erc20Address, uint amount) external onlyRoleHolder(_roleId) {\n        IERC20 erc20 = IERC20(erc20Address);\n        require(erc20.transfer(msg.sender, amount));\n    }\n\n    /**\n     * @notice Internal method that allows derived contracts to create a role for withdrawal.\n     * @dev Either this method or `setWithdrawRole` must be called by the derived class for this contract to function\n     * properly.\n     */\n    function createWithdrawRole(uint roleId, uint managingRoleId, address owner) internal {\n        _roleId = roleId;\n        _createExclusiveRole(roleId, managingRoleId, owner);\n    }\n\n    /**\n     * @notice Internal method that allows derived contracts to choose the role for withdrawal.\n     * @dev The role `roleId` must exist. Either this method or `createWithdrawRole` must be called by the derived class\n     * for this contract to function properly.\n     */\n    function setWithdrawRole(uint roleId) internal {\n        _roleId = roleId;\n    }\n}"
    }
  ]
}