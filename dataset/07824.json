{
  "Title": "[H-03]  LayerZeroModule miscalculates gas, risking loss of assets",
  "Content": "\n[LayerZeroModule.sol#L431-L445](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/module/LayerZeroModule.sol#L431-L445)<br>\n\nHolograph gets its cross chain messaging primitives through Layer Zero. To get pricing estimate, it uses the DstConfig price struct exposed in LZ's [RelayerV2](https://github.com/LayerZero-Labs/LayerZero/blob/main/contracts/RelayerV2.sol#L133).\n\nThe issue is that the important baseGas and gasPerByte configuration parameters, which are used to calculate a custom amount of gas for the destination LZ message, use the values that come from the *source* chain. This is in contrast to LZ which handles DstConfigs in a mapping keyed by chainID.  The encoded gas amount is described [here](https://layerzero.gitbook.io/docs/guides/advanced/relayer-adapter-parameters).\n\n### Impact\n\nThe impact is that when those fields are different between chains, one of two things may happen:\n\n1.  Less severe - we waste excess gas, which is refunded to the lzReceive() caller (Layer Zero)\n2.  More severe - we underprice the delivery cost, causing lzReceive() to revert and the NFT stuck in limbo forever.\n\nThe code does not handle a failed lzReceive (differently to a failed executeJob). Therefore, no failure event is emitted and the NFT is screwed.\n\n### Recommended Mitigation Steps\n\nFirstly, make sure to use the target gas costs.<br>\nSecondly, re-engineer lzReceive to be fault-proof, i.e. save some gas to emit result event.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#issuecomment-1297075073):**\n > Might also cause the LZ channel to stuck [`#244`](https://github.com/code-423n4/2022-10-holograph-findings/issues/244).\n\n**[ACC01ADE (Holograph) disputed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#issuecomment-1308865449):**\n > I respectfully disagree that this is even a valid issue.<br>\n> @Trust - please re-review the affected code. You'll notice that we are in fact extracting destination chain gas data. And if you review the 100s of cross-chain testnet transactions that we have already made with that version of code, you will notice that the math is exact.\n>\n > Maybe I am misunderstanding something, so some clarification would be great if you think I'm wrong on this.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#issuecomment-1308879405):**\n > Please take a look at `LayerZeroModule.sol`'s send function:\n> ```\n> function send(\n>   uint256, /* gasLimit*/\n>   uint256, /* gasPrice*/\n>   uint32 toChain,\n>   address msgSender,\n>   uint256 msgValue,\n>   bytes calldata crossChainPayload\n> ) external payable {\n>   require(msg.sender == address(_operator()), \"HOLOGRAPH: operator only call\");\n>   LayerZeroOverrides lZEndpoint;\n>   assembly {\n>     lZEndpoint := sload(_lZEndpointSlot)\n>   }\n>   // need to recalculate the gas amounts for LZ to deliver message\n>   lZEndpoint.send{value: msgValue}(\n>     uint16(_interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)),\n>     abi.encodePacked(address(this), address(this)),\n>     crossChainPayload,\n>     payable(msgSender),\n>     address(this),\n>     abi.encodePacked(uint16(1), uint256(_baseGas() + (crossChainPayload.length * _gasPerByte())))\n>   );\n> }\n> ```\n> \n> The function uses `_baseGas()` and `_gasPerByte()` as the relayer adapter parameters as described in the submission description's link. These two getters are global for all chains.\n> \n> I agree that the `getMessage()` function takes into account the correct fees for the destination chain.\n\n**[ACC01ADE (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#issuecomment-1308924550):**\n > @Trust - Ya but these refer to destination gas limits. BaseGas and GasPerByte is the amount of gas that is used by the `crossChainMessage` function that LayerZero triggers on cross-chain call [HolographOperator.sol#L484](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L484)\n\n**[ACC01ADE (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#issuecomment-1308953994):**\n > Discussed this in more detail with @Trust, definitely a critical issue.<br>\n> Need to add destination chain-specific `_baseGas` and `_gasPerByte` to mitigate EVM differences in opcode costs.\n\n**[alexanderattar (Holograph) resolved](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#event-7816582320):**\n > [Feature/HOLO-604: implementing critical issue fixes](https://github.com/holographxyz/holograph-protocol/pull/84)\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-10-holograph-contest",
  "Code": [
    {
      "filename": "contracts/module/LayerZeroModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../enum/ChainIdType.sol\";\n\nimport \"../interface/CrossChainMessageInterface.sol\";\nimport \"../interface/HolographOperatorInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/LayerZeroModuleInterface.sol\";\nimport \"../interface/LayerZeroOverrides.sol\";\n\n/**\n * @title Holograph LayerZero Module\n * @author https://github.com/holographxyz\n * @notice Holograph module for enabling LayerZero cross-chain messaging\n * @dev This contract abstracts all of the LayerZero specific logic into an isolated module\n */\ncontract LayerZeroModule is Admin, Initializable, CrossChainMessageInterface, LayerZeroModuleInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.interfaces')) - 1)\n   */\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.lZEndpoint')) - 1)\n   */\n  bytes32 constant _lZEndpointSlot = 0x56825e447adf54cdde5f04815fcf9b1dd26ef9d5c053625147c18b7c13091686;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _baseGasSlot = 0x1eaa99919d5563fbfdd75d9d906ff8de8cf52beab1ed73875294c8a0c9e9d83a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _gasPerByteSlot = 0x99d8b07d37c89d4c4f4fa0fd9b7396caeb5d1d4e58b41c61c71e3cf7d424a625;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address bridge, address interfaces, address operator, uint256 baseGas, uint256 gasPerByte) = abi.decode(\n      initPayload,\n      (address, address, address, uint256, uint256)\n    );\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_bridgeSlot, bridge)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_operatorSlot, operator)\n      sstore(_baseGasSlot, baseGas)\n      sstore(_gasPerByteSlot, gasPerByte)\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Receive cross-chain message from LayerZero\n   * @dev This function only allows calls from the configured LayerZero endpoint address\n   */\n  function lzReceive(\n    uint16, /* _srcChainId*/\n    bytes calldata _srcAddress,\n    uint64, /* _nonce*/\n    bytes calldata _payload\n  ) external payable {\n    assembly {\n      /**\n       * @dev check if msg.sender is LayerZero Endpoint\n       */\n      switch eq(sload(_lZEndpointSlot), caller())\n      case 0 {\n        /**\n         * @dev this is the assembly version of -> revert(\"HOLOGRAPH: LZ only endpoint\");\n         */\n        mstore(0x80, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        mstore(0xa0, 0x0000002000000000000000000000000000000000000000000000000000000000)\n        mstore(0xc0, 0x0000001b484f4c4f47524150483a204c5a206f6e6c7920656e64706f696e7400)\n        mstore(0xe0, 0x0000000000000000000000000000000000000000000000000000000000000000)\n        revert(0x80, 0xc4)\n      }\n      let ptr := mload(0x40)\n      calldatacopy(add(ptr, 0x0c), _srcAddress.offset, _srcAddress.length)\n      /**\n       * @dev check if LZ from address is same as address(this)\n       */\n      switch eq(mload(ptr), address())\n      case 0 {\n        /**\n         * @dev this is the assembly version of -> revert(\"HOLOGRAPH: unauthorized sender\");\n         */\n        mstore(0x80, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        mstore(0xa0, 0x0000002000000000000000000000000000000000000000000000000000000000)\n        mstore(0xc0, 0x0000001e484f4c4f47524150483a20756e617574686f72697a65642073656e64)\n        mstore(0xe0, 0x6572000000000000000000000000000000000000000000000000000000000000)\n        revert(0x80, 0xc4)\n      }\n    }\n    /**\n     * @dev if validation has passed, submit payload to Holograph Operator for converting into an operator job\n     */\n    _operator().crossChainMessage(_payload);\n  }\n\n  /**\n   * @dev Need to add an extra function to get LZ gas amount needed for their internal cross-chain message verification\n   */\n  function send(\n    uint256, /* gasLimit*/\n    uint256, /* gasPrice*/\n    uint32 toChain,\n    address msgSender,\n    uint256 msgValue,\n    bytes calldata crossChainPayload\n  ) external payable {\n    require(msg.sender == address(_operator()), \"HOLOGRAPH: operator only call\");\n    LayerZeroOverrides lZEndpoint;\n    assembly {\n      lZEndpoint := sload(_lZEndpointSlot)\n    }\n    // need to recalculate the gas amounts for LZ to deliver message\n    lZEndpoint.send{value: msgValue}(\n      uint16(_interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)),\n      abi.encodePacked(address(this), address(this)),\n      crossChainPayload,\n      payable(msgSender),\n      address(this),\n      abi.encodePacked(uint16(1), uint256(_baseGas() + (crossChainPayload.length * _gasPerByte())))\n    );\n  }\n\n  function getMessageFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee, uint256 msgFee) {\n    uint16 lzDestChain = uint16(\n      _interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)\n    );\n    LayerZeroOverrides lz;\n    assembly {\n      lz := sload(_lZEndpointSlot)\n    }\n    // convert holograph chain id to lz chain id\n    (uint128 dstPriceRatio, uint128 dstGasPriceInWei) = _getPricing(lz, lzDestChain);\n    if (gasPrice == 0) {\n      gasPrice = dstGasPriceInWei;\n    }\n    bytes memory adapterParams = abi.encodePacked(\n      uint16(1),\n      uint256(_baseGas() + (crossChainPayload.length * _gasPerByte()))\n    );\n    (uint256 nativeFee, ) = lz.estimateFees(lzDestChain, address(this), crossChainPayload, false, adapterParams);\n    return (((gasPrice * (gasLimit + (gasLimit / 10))) * dstPriceRatio) / (10**10), nativeFee);\n  }\n\n  function getHlgFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice\n  ) external view returns (uint256 hlgFee) {\n    LayerZeroOverrides lz;\n    assembly {\n      lz := sload(_lZEndpointSlot)\n    }\n    uint16 lzDestChain = uint16(\n      _interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)\n    );\n    (uint128 dstPriceRatio, uint128 dstGasPriceInWei) = _getPricing(lz, lzDestChain);\n    if (gasPrice == 0) {\n      gasPrice = dstGasPriceInWei;\n    }\n    return ((gasPrice * (gasLimit + (gasLimit / 10))) * dstPriceRatio) / (10**10);\n  }\n\n  function _getPricing(LayerZeroOverrides lz, uint16 lzDestChain)\n    private\n    view\n    returns (uint128 dstPriceRatio, uint128 dstGasPriceInWei)\n  {\n    return\n      LayerZeroOverrides(LayerZeroOverrides(lz.defaultSendLibrary()).getAppConfig(lzDestChain, address(this)).relayer)\n        .dstPriceLookup(lzDestChain);\n  }\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  /**\n   * @notice Get the address of the approved LayerZero Endpoint\n   * @dev All lzReceive function calls allow only requests from this address\n   */\n  function getLZEndpoint() external view returns (address lZEndpoint) {\n    assembly {\n      lZEndpoint := sload(_lZEndpointSlot)\n    }\n  }\n\n  /**\n   * @notice Update the approved LayerZero Endpoint address\n   * @param lZEndpoint address of the LayerZero Endpoint to use\n   */\n  function setLZEndpoint(address lZEndpoint) external onlyAdmin {\n    assembly {\n      sstore(_lZEndpointSlot, lZEndpoint)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Bridge Interface\n   */\n  function _bridge() private view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interfaces Interface\n   */\n  function _interfaces() private view returns (HolographInterfacesInterface interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Operator Interface\n   */\n  function _operator() private view returns (HolographOperatorInterface operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent having any type of ether transfered into the contract\n   */\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n\n  /**\n   * @notice Get the baseGas value\n   * @dev Cross-chain messages require at least this much gas\n   */\n  function getBaseGas() external view returns (uint256 baseGas) {\n    assembly {\n      baseGas := sload(_baseGasSlot)\n    }\n  }\n\n  /**\n   * @notice Update the baseGas value\n   * @param baseGas minimum gas amount that a message requires\n   */\n  function setBaseGas(uint256 baseGas) external onlyAdmin {\n    assembly {\n      sstore(_baseGasSlot, baseGas)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the baseGas value\n   */\n  function _baseGas() private view returns (uint256 baseGas) {\n    assembly {\n      baseGas := sload(_baseGasSlot)\n    }\n  }\n\n  /**\n   * @notice Get the gasPerByte value\n   * @dev Cross-chain messages require at least this much gas (per payload byte)\n   */\n  function getGasPerByte() external view returns (uint256 gasPerByte) {\n    assembly {\n      gasPerByte := sload(_gasPerByteSlot)\n    }\n  }\n\n  /**\n   * @notice Update the gasPerByte value\n   * @param gasPerByte minimum gas amount (per payload byte) that a message requires\n   */\n  function setGasPerByte(uint256 gasPerByte) external onlyAdmin {\n    assembly {\n      sstore(_gasPerByteSlot, gasPerByte)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the gasPerByte value\n   */\n  function _gasPerByte() private view returns (uint256 gasPerByte) {\n    assembly {\n      gasPerByte := sload(_gasPerByteSlot)\n    }\n  }\n}"
    },
    {
      "filename": "contracts/RelayerV2.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat-deploy/solc_0.7/proxy/Proxied.sol\";\n\nimport \"./interfaces/ILayerZeroRelayerV2.sol\";\nimport \"./interfaces/ILayerZeroUltraLightNodeV2.sol\";\n\ncontract RelayerV2 is ReentrancyGuard, OwnableUpgradeable, Proxied, ILayerZeroRelayerV2 {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    using SafeMath for uint128;\n    using SafeMath for uint64;\n\n    ILayerZeroUltraLightNodeV2 public uln;\n    address public stargateBridgeAddress;\n\n    struct DstPrice {\n        uint128 dstPriceRatio; // 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint128 dstNativeAmtCap;\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    // [_chainId] => DstPriceData. change often\n    mapping(uint16 => DstPrice) public dstPriceLookup;\n    // [_chainId][_outboundProofType] => DstConfig. change much less often\n    mapping(uint16 => mapping(uint16 => DstConfig)) public dstConfigLookup;\n    mapping(address => bool) public approvedAddresses;\n\n    event Withdraw(address to, uint amount);\n    event ApproveAddress(address addr, bool approved);\n    event AssignJob(uint totalFee);\n    event ValueTransferFailed(address indexed to, uint indexed quantity);\n    event SetDstPrice(uint16 chainId, uint128 dstPriceRatio, uint128 dstGasPriceInWei);\n    event SetDstConfig(uint16 chainId, uint16 outboundProofType, uint128 dstNativeAmtCap, uint64 baseGas, uint64 gasPerByte);\n\n    // new pauseable relayer\n    bool public paused;\n\n    // owner is always approved\n    modifier onlyApproved() {\n        if (owner() != msg.sender) {\n            require(isApproved(msg.sender), \"Relayer: not approved\");\n        }\n        _;\n    }\n\n    function initialize(address _uln) public proxied initializer {\n        __Ownable_init();\n        uln = ILayerZeroUltraLightNodeV2(_uln);\n        setApprovedAddress(address(this), true);\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyApproved\n\n    function setDstPrice(uint16 _chainId, uint128 _dstPriceRatio, uint128 _dstGasPriceInWei) external onlyApproved {\n        dstPriceLookup[_chainId] = DstPrice(_dstPriceRatio, _dstGasPriceInWei);\n        emit SetDstPrice(_chainId, _dstPriceRatio, _dstGasPriceInWei);\n    }\n\n    function setDstConfig(uint16 _chainId, uint16 _outboundProofType, uint128 _dstNativeAmtCap, uint64 _baseGas, uint64 _gasPerByte) external onlyApproved {\n        dstConfigLookup[_chainId][_outboundProofType] = DstConfig(_dstNativeAmtCap, _baseGas, _gasPerByte);\n        emit SetDstConfig(_chainId, _outboundProofType, _dstNativeAmtCap, _baseGas, _gasPerByte);\n    }\n\n    function setStargateAddress(address _stargateAddress) external onlyApproved {\n        stargateBridgeAddress = _stargateAddress;\n    }\n\n    //----------------------------------------------------------------------------------\n    // onlyOwner\n\n    function setApprovedAddress(address _relayerAddress, bool _approve) public onlyOwner {\n        approvedAddresses[_relayerAddress] = _approve;\n        emit ApproveAddress(_relayerAddress, _approve);\n    }\n\n    function setPause(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    // txType 1\n    // bytes  [2       32      ]\n    // fields [txType  extraGas]\n    // txType 2\n    // bytes  [2       32        32            bytes[]         ]\n    // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n    // User App Address is not used in this version\n    function _getPrices(uint16 _dstChainId, uint16 _outboundProofType, address, bytes memory _adapterParameters) internal view returns (uint basePrice, uint pricePerByte) {\n        require(!paused, \"Admin: paused\");\n        // decoding the _adapterParameters - reverts if type 2 and there is no dstNativeAddress\n        require(_adapterParameters.length == 34 || _adapterParameters.length > 66, \"Relayer: wrong _adapterParameters size\");\n        uint16 txType;\n        uint extraGas;\n        assembly {\n            txType := mload(add(_adapterParameters, 2))\n            extraGas := mload(add(_adapterParameters, 34))\n        }\n        require(extraGas > 0, \"Relayer: gas too low\");\n        require(txType == 1 || txType == 2, \"Relayer: unsupported txType\");\n\n        DstPrice storage dstPrice = dstPriceLookup[_dstChainId];\n        DstConfig storage dstConfig = dstConfigLookup[_dstChainId][_outboundProofType];\n\n        uint totalRemoteToken; // = baseGas + extraGas + requiredNativeAmount\n        if (txType == 2) {\n            uint dstNativeAmt;\n            assembly {\n                dstNativeAmt := mload(add(_adapterParameters, 66))\n            }\n            require(dstConfig.dstNativeAmtCap >= dstNativeAmt, \"Relayer: dstNativeAmt too large\");\n            totalRemoteToken = totalRemoteToken.add(dstNativeAmt);\n        }\n        // remoteGasTotal = dstGasPriceInWei * (baseGas + extraGas)\n        uint remoteGasTotal = dstPrice.dstGasPriceInWei.mul(dstConfig.baseGas.add(extraGas));\n\n        totalRemoteToken = totalRemoteToken.add(remoteGasTotal);\n\n        // tokenConversionRate = dstPrice / localPrice\n        // basePrice = totalRemoteToken * tokenConversionRate\n        basePrice = totalRemoteToken.mul(dstPrice.dstPriceRatio).div(10**10);\n\n        // pricePerByte = (dstGasPriceInWei * gasPerBytes) * tokenConversionRate\n        pricePerByte = dstPrice.dstGasPriceInWei.mul(dstConfig.gasPerByte).mul(dstPrice.dstPriceRatio).div(10**10);\n    }\n\n    function getFee(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external view override returns (uint) {\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        (uint basePrice, uint pricePerByte) = _getPrices(_dstChainId, _outboundProofType, _userApplication, _adapterParams);\n        return basePrice.add(_payloadSize.mul(pricePerByte));\n    }\n\n    function isApproved(address _relayerAddress) public view returns (bool) {\n        return approvedAddresses[_relayerAddress];\n    }\n\n    function assignJob(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external override returns (uint) {\n        require(msg.sender == address(uln), \"Relayer: invalid uln\");\n        require(_payloadSize <= 10000, \"Relayer: _payloadSize tooooo big\");\n        (uint basePrice, uint pricePerByte) = _getPrices(_dstChainId, _outboundProofType, _userApplication, _adapterParams);\n        uint totalFee = basePrice.add(_payloadSize.mul(pricePerByte));\n        emit AssignJob(totalFee);\n        return totalFee;\n    }\n\n    function withdrawFee(address payable _to, uint _amount) external override onlyApproved {\n        uint totalFee = uln.accruedNativeFee(address(this));\n        require(_amount <= totalFee, \"Relayer: not enough fee for withdrawal\");\n        uln.withdrawNative(_to, _amount);\n    }\n\n    function validateTransactionProofV2(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _blockHash, bytes32 _data, bytes calldata _transactionProof, address payable _to) external payable onlyApproved nonReentrant {\n        (bool sent, ) = _to.call{value: msg.value}(\"\");\n        //require(sent, \"Relayer: failed to send ether\");\n        if (!sent) {\n            emit ValueTransferFailed(_to, msg.value);\n        }\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n\n    function validateTransactionProofV1(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _blockHash, bytes32 _data, bytes calldata _transactionProof) external onlyApproved nonReentrant {\n        uln.validateTransactionProof(_srcChainId, _dstAddress, _gasLimit, _blockHash, _data, _transactionProof);\n    }\n}"
    },
    {
      "filename": "contracts/HolographOperator.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/CrossChainMessageInterface.sol\";\nimport \"./interface/HolographBridgeInterface.sol\";\nimport \"./interface/HolographERC20Interface.sol\";\nimport \"./interface/HolographInterface.sol\";\nimport \"./interface/HolographOperatorInterface.sol\";\nimport \"./interface/HolographRegistryInterface.sol\";\nimport \"./interface/InitializableInterface.sol\";\nimport \"./interface/HolographInterfacesInterface.sol\";\nimport \"./interface/Ownable.sol\";\n\nimport \"./struct/OperatorJob.sol\";\n\n/**\n * @title Holograph Operator\n * @author https://github.com/holographxyz\n * @notice Participate in the Holograph Protocol by becoming an Operator\n * @dev This contract allows operators to bond utility tokens and help execute operator jobs\n */\ncontract HolographOperator is Admin, Initializable, HolographOperatorInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.interfaces')) - 1)\n   */\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.jobNonce')) - 1)\n   */\n  bytes32 constant _jobNonceSlot = 0x1cda64803f3b43503042e00863791e8d996666552d5855a78d53ee1dd4b3286d;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.messagingModule')) - 1)\n   */\n  bytes32 constant _messagingModuleSlot = 0x54176250282e65985d205704ffce44a59efe61f7afd99e29fda50f55b48c061a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.utilityToken')) - 1)\n   */\n  bytes32 constant _utilityTokenSlot = 0xbf76518d46db472b71aa7677a0908b8016f3dee568415ffa24055f9a670f9c37;\n\n  /**\n   * @dev Internal number (in seconds), used for defining a window for operator to execute the job\n   */\n  uint256 private _blockTime;\n\n  /**\n   * @dev Minimum amount of tokens needed for bonding\n   */\n  uint256 private _baseBondAmount;\n\n  /**\n   * @dev The multiplier used for calculating bonding amount for pods\n   */\n  uint256 private _podMultiplier;\n\n  /**\n   * @dev The threshold used for limiting number of operators in a pod\n   */\n  uint256 private _operatorThreshold;\n\n  /**\n   * @dev The threshold step used for increasing bond amount once threshold is reached\n   */\n  uint256 private _operatorThresholdStep;\n\n  /**\n   * @dev The threshold divisor used for inc"
    }
  ]
}