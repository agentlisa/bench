{
  "Title": "[M-11] Attacker can disable basket during un-registration, which can cause an unnecessary trade in some cases",
  "Content": "\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/AssetRegistry.sol#L89-L93> <br><https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/AssetRegistry.sol#L106-L110>\n\nAt the mitigation audit there was an issue regarding the `basketHandler.quantity()` call at the unregistration process taking up all gas.\nAs a mitigation to that issue the devs set aside some gas and use the remaining to do that call.\nThis opens up to a new kind of attack, where a attacker can cause the call to revert by not supplying enough gas to it.\n\n### Impact\n\nThis can cause the basket to get disabled, which would require a basket refresh.\n\nAfter a basket refresh is done, an additional warmup period has to pass for some functionality to be available again (issuance, rebalancing and forwarding revenue).\n\nIn some cases this might trigger a basket switch that would require the protocol to rebalance via trading, trading can have some slippage which can cause a loss for the protocol.\n\n### Proof of Concept\n\nThe `quantity()` function is being called with the amount of gas that `_reserveGas()` returns\n\nIf an attacker causes the gas to be just right above `GAS_TO_RESERVE` the function would be called with 1 unit of gas, causing it to revert:\n\n```solidity\n    function _reserveGas() private view returns (uint256) {\n        uint256 gas = gasleft();\n        require(gas > GAS_TO_RESERVE, \"not enough gas to unregister safely\");\n        return gas - GAS_TO_RESERVE;\n    }\n```\n\nRegarding the unnecessary trade, consider the following scenario:\n\n*   The basket has USDC as the main asset and DAI as a backup token\n*   A proposal to replace the backup token with USDT was raised\n*   A proposal to unregister BUSD (which isn't part of the basket) was raised too\n*   USDC defaults and DAI kicks in as the backup token\n*   Both proposals are now ready to execute and the attacker executes the backup proposal first, then the unregister while disabling the basket using the bug in question\n*   Now, when the basket is refreshed DAI will be replaced with USDT, making the protocol to trade DAI for USDT\n\nThe refresh was unnecessary and therefore the trade too.\n\n### Recommended Mitigation Steps\n\nReserve gas for the call as well:\n\n```diff\n    function _reserveGas() private view returns (uint256) {\n        uint256 gas = gasleft();\n-        require(gas > GAS_TO_RESERVE, \"not enough gas to unregister safely\");\n+        require(gas >= GAS_TO_RESERVE + MIN_GAS_FOR_EXECUTION, \"not enough gas to unregister safely\");\n        return gas - GAS_TO_RESERVE;\n    }\n```\n\nDisclosure: this issue was [mentioned in the comments](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/73#issuecomment-1435483929) to the issue in the mitigation audit; however, since this wasn't noticed by the devs and isn't part of the submission, I don't think this should be considered a known issue.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/7#issuecomment-1586332703):**\n > Applaud @0xA5DF for highlighting this on their own issue.\n> \n> > *Disclosure: this issue was [mentioned in the comments](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/73#issuecomment-1435483929) to the issue in the mitigation audit, however since this wasn't noticed by the devs and isn't part of the submission I don't think this should be considered a known issue*\n> \n> Look forward to discussion with sponsor. \n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/7#issuecomment-1589904155):**\n > We've discussed and agree with with the warden that this should not be considered a known issue. \n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Change gas reservation policy in `AssetRegistry`.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/857\n\n**Status:** Mitigation confirmed. Full details in reports from [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/27), [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/39), and [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/18) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-reserve",
  "Code": [
    {
      "filename": "contracts/p1/AssetRegistry.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../interfaces/IAssetRegistry.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"./mixins/Component.sol\";\n\n/// The AssetRegistry provides the mapping from ERC20 to Asset, allowing the rest of Main\n/// to think in terms of ERC20 tokens and target/ref units.\ncontract AssetRegistryP1 is ComponentP1, IAssetRegistry {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant GAS_TO_RESERVE = 900000; // just enough to disable basket on n=128\n\n    // Peer-component addresses\n    IBasketHandler private basketHandler;\n    IBackingManager private backingManager;\n\n    // Registered ERC20s\n    EnumerableSet.AddressSet private _erc20s;\n\n    // Registered Assets\n    mapping(IERC20 => IAsset) private assets;\n\n    // === 3.0.0 ===\n\n    uint48 public lastRefresh; // {s}\n\n    /* ==== Contract Invariants ====\n       The contract state is just the mapping assets; _erc20s is ignored in properties.\n\n       invariant: _erc20s == keys(assets)\n       invariant: addr == assets[addr].erc20()\n           where: addr in assets\n     */\n\n    /// Initialize the AssetRegistry with assets\n    // effects: assets' = {a.erc20(): a for a in assets_}\n    function init(IMain main_, IAsset[] calldata assets_) external initializer {\n        __Component_init(main_);\n        basketHandler = main_.basketHandler();\n        backingManager = main_.backingManager();\n        uint256 length = assets_.length;\n        for (uint256 i = 0; i < length; ++i) {\n            _register(assets_[i]);\n        }\n    }\n\n    /// Update the state of all assets\n    /// @custom:refresher\n    // actions:\n    //   calls refresh(c) for c in keys(assets) when c.isCollateral()\n    //   tracks basket status on basketHandler\n    function refresh() public {\n        // It's a waste of gas to require notPausedOrFrozen because assets can be updated directly\n        uint256 length = _erc20s.length();\n        for (uint256 i = 0; i < length; ++i) {\n            assets[IERC20(_erc20s.at(i))].refresh();\n        }\n\n        basketHandler.trackStatus();\n        lastRefresh = uint48(block.timestamp); // safer to do this at end than start, actually\n    }\n\n    /// Register `asset`\n    /// If either the erc20 address or the asset was already registered, fail\n    /// @return true if the erc20 address was not already registered.\n    /// @custom:governance\n    // checks: asset.erc20() not in keys(assets) or assets[asset.erc20] == asset\n    // effects: assets' = assets.set(asset.erc20(), asset)\n    // returns: (asset.erc20 not in keys(assets))\n    function register(IAsset asset) external governance returns (bool) {\n        return _register(asset);\n    }\n\n    /// Register `asset` if and only if its erc20 address is already registered.\n    /// If the erc20 address was not registered, revert.\n    /// @return swapped If the asset was swapped for a previously-registered asset\n    /// @custom:governance\n    // contract\n    // checks: asset.erc20() in assets\n    // effects: assets' = assets + {asset.erc20(): asset}\n    // actions: if asset.erc20() is in basketHandler's basket then basketHandler.disableBasket()\n    function swapRegistered(IAsset asset) external governance returns (bool swapped) {\n        require(_erc20s.contains(address(asset.erc20())), \"no ERC20 collision\");\n\n        try basketHandler.quantity{ gas: _reserveGas() }(asset.erc20()) returns (uint192 quantity) {\n            if (quantity > 0) basketHandler.disableBasket(); // not an interaction\n        } catch {\n            basketHandler.disableBasket();\n        }\n\n        swapped = _registerIgnoringCollisions(asset);\n    }\n\n    /// Unregister an asset, requiring that it is already registered\n    /// @custom:governance\n    // checks: assets[asset.erc20()] == asset\n    // effects: assets' = assets - {asset.erc20():_} + {asset.erc20(), asset}\n    function unregister(IAsset asset) external governance {\n        require(_erc20s.contains(address(asset.erc20())), \"no asset to unregister\");\n        require(assets[asset.erc20()] == asset, \"asset not found\");\n\n        try basketHandler.quantity{ gas: _reserveGas() }(asset.erc20()) returns (uint192 quantity) {\n            if (quantity > 0) basketHandler.disableBasket(); // not an interaction\n        } catch {\n            basketHandler.disableBasket();\n        }\n\n        _erc20s.remove(address(asset.erc20()));\n        assets[asset.erc20()] = IAsset(address(0));\n        emit AssetUnregistered(asset.erc20(), asset);\n    }\n\n    /// Return the Asset registered for erc20; revert if erc20 is not registered.\n    // checks: erc20 in assets\n    // returns: assets[erc20]\n    function toAsset(IERC20 erc20) external view returns (IAsset) {\n        require(_erc20s.contains(address(erc20)), \"erc20 unregistered\");\n        return assets[erc20];\n    }\n\n    /// Return the Collateral registered for erc20; revert if erc20 is not registered as Collateral\n    // checks: erc20 in assets, assets[erc20].isCollateral()\n    // returns: assets[erc20]\n    function toColl(IERC20 erc20) external view returns (ICollateral) {\n        require(_erc20s.contains(address(erc20)), \"erc20 unregistered\");\n        require(assets[erc20].isCollateral(), \"erc20 is not collateral\");\n        return ICollateral(address(assets[erc20]));\n    }\n\n    /// Returns true if erc20 is registered.\n    // returns: (erc20 in assets)\n    function isRegistered(IERC20 erc20) external view returns (bool) {\n        return _erc20s.contains(address(erc20));\n    }\n\n    /// Returns keys(assets) as a (duplicate-free) list.\n    // returns: [keys(assets)] without duplicates.\n    function erc20s() external view returns (IERC20[] memory erc20s_) {\n        uint256 length = _erc20s.length();\n        erc20s_ = new IERC20[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            erc20s_[i] = IERC20(_erc20s.at(i));\n        }\n    }\n\n    /// Returns keys(assets), values(assets) as (duplicate-free) lists.\n    // returns: [keys(assets)], [values(assets)] without duplicates.\n    /// @return reg The list of registered ERC20s and Assets, in the same order\n    function getRegistry() external view returns (Registry memory reg) {\n        uint256 length = _erc20s.length();\n        reg.erc20s = new IERC20[](length);\n        reg.assets = new IAsset[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            reg.erc20s[i] = IERC20(_erc20s.at(i));\n            reg.assets[i] = assets[IERC20(_erc20s.at(i))];\n        }\n    }\n\n    /// @return The number of registered ERC20s\n    function size() external view returns (uint256) {\n        return _erc20s.length();\n    }\n\n    /// Register an asset\n    /// Forbids registering a different asset for an ERC20 that is already registered\n    /// @return registered If the asset was moved from unregistered to registered\n    // checks: (asset.erc20() not in assets) or (assets[asset.erc20()] == asset)\n    // effects: assets' = assets.set(asset.erc20(), asset)\n    // returns: assets.erc20() not in assets\n    function _register(IAsset asset) internal returns (bool registered) {\n        require(\n            !_erc20s.contains(address(asset.erc20())) || assets[asset.erc20()] == asset,\n            \"duplicate ERC20 detected\"\n        );\n\n        registered = _registerIgnoringCollisions(asset);\n    }\n\n    /// Register an asset, unregistering any previous asset with the same ERC20.\n    // effects: assets' = assets.set(asset.erc20(), asset)\n    // returns: assets[asset.erc20()] != asset\n    function _registerIgnoringCollisions(IAsset asset) private returns (bool swapped) {\n        IERC20Metadata erc20 = asset.erc20();\n        if (_erc20s.contains(address(erc20))) {\n            if (assets[erc20] == asset) return false;\n            else emit AssetUnregistered(erc20, assets[erc20]);\n        } else {\n            _erc20s.add(address(erc20));\n        }\n\n        assets[erc20] = asset;\n        emit AssetRegistered(erc20, asset);\n\n        // Refresh to ensure it does not revert, and to save a recent lastPrice\n        asset.refresh();\n\n        if (!main.frozen()) {\n            backingManager.grantRTokenAllowance(erc20);\n        }\n\n        return true;\n    }\n\n    function _reserveGas() private view returns (uint256) {\n        uint256 gas = gasleft();\n        require(gas > GAS_TO_RESERVE, \"not enough gas to unregister safely\");\n        return gas - GAS_TO_RESERVE;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}"
    }
  ]
}