{
  "Title": "[03] `is_running_in_command` function is missing or misnamed in the code",
  "Content": "\nhttps://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/runtime/src/runtime/extension.rs#L439\n\nThe function `is_running_in_command` (from the documentation) is missing or misnamed in the code to be `is_it_in_transaction`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-phala-network",
  "Code": [
    {
      "filename": "phala-blockchain/crates/pink/runtime/src/runtime/extension.rs",
      "content": "use std::borrow::Cow;\n\nuse frame_support::traits::Currency;\nuse log::error;\nuse pallet_contracts::chain_extension::{\n    ChainExtension, Environment, Ext, InitState, Result as ExtResult, RetVal,\n};\nuse phala_crypto::sr25519::{Persistence, KDF};\nuse phala_types::contract::ConvertTo;\nuse pink::{\n    chain_extension::{\n        self as ext, HttpRequest, HttpResponse, JsCode, JsValue, PinkExtBackend, SigType,\n        StorageQuotaExceeded,\n    },\n    dispatch_ext_call,\n    types::sgx::SgxQuote,\n    CacheOp, EcdhPublicKey, EcdsaPublicKey, EcdsaSignature, Hash, PinkEvent,\n};\nuse pink_chain_extension::{DefaultPinkExtension, PinkRuntimeEnv};\nuse scale::{Decode, Encode};\nuse sp_runtime::{AccountId32, DispatchError};\n\nuse crate::{capi::OCallImpl, types::AccountId};\n\nuse pink_capi::{types::ExecSideEffects, v1::ocall::OCallsRo};\n\nuse super::{pallet_pink, PinkRuntime, SystemEvents};\nuse crate::runtime::Pink as PalletPink;\ntype Error = pallet_pink::Error<PinkRuntime>;\n\nfn deposit_pink_event(contract: AccountId, event: PinkEvent) {\n    let topics = [pink::PinkEvent::event_topic().into()];\n    let event = super::RuntimeEvent::Contracts(pallet_contracts::Event::ContractEmitted {\n        contract,\n        data: event.encode(),\n    });\n    super::System::deposit_event_indexed(&topics[..], event);\n}\n\npub fn get_side_effects() -> (SystemEvents, ExecSideEffects) {\n    let mut pink_events = Vec::default();\n    let mut ink_events = Vec::default();\n    let mut instantiated = Vec::default();\n    let mut system_events = vec![];\n    for event in super::System::events() {\n        let mut is_private_event = false;\n        if let super::RuntimeEvent::Contracts(ink_event) = &event.event {\n            use pallet_contracts::Event as ContractEvent;\n            match ink_event {\n                ContractEvent::Instantiated {\n                    deployer,\n                    contract: address,\n                } => instantiated.push((deployer.clone(), address.clone())),\n                ContractEvent::ContractEmitted {\n                    contract: address,\n                    data,\n                } => {\n                    if event.topics.len() == 1\n                        && event.topics[0].0 == pink::PinkEvent::event_topic()\n                    {\n                        match pink::PinkEvent::decode(&mut &data[..]) {\n                            Ok(event) => {\n                                pink_events.push((address.clone(), event.clone()));\n                                is_private_event = event.is_private();\n                            }\n                            Err(_) => {\n                                error!(\"Contract emitted an invalid pink event\");\n                            }\n                        }\n                    } else {\n                        ink_events.push((address.clone(), event.topics.clone(), data.clone()));\n                    }\n                }\n                _ => (),\n            }\n        }\n        if !is_private_event {\n            system_events.push(event);\n        }\n    }\n    (\n        system_events,\n        ExecSideEffects::V1 {\n            pink_events,\n            ink_events,\n            instantiated,\n        },\n    )\n}\n\n/// Contract extension for `pink contracts`\n#[derive(Default)]\npub struct PinkExtension;\n\nimpl ChainExtension<PinkRuntime> for PinkExtension {\n    fn call<E: Ext<T = PinkRuntime>>(\n        &mut self,\n        env: Environment<E, InitState>,\n    ) -> ExtResult<RetVal> {\n        let mut env = env.buf_in_buf_out();\n        if env.ext_id() != 0 {\n            error!(target: \"pink\", \"Unknown extension id: {:}\", env.ext_id());\n            return Err(Error::UnknownChainExtensionId.into());\n        }\n\n        let address = env.ext().address().clone();\n        let call_in_query = CallInQuery { address };\n        let mode = OCallImpl.exec_context().mode;\n        let (ret, output) = if mode.is_query() {\n            dispatch_ext_call!(env.func_id(), call_in_query, env)\n        } else {\n            let call = CallInCommand {\n                as_in_query: call_in_query,\n            };\n            dispatch_ext_call!(env.func_id(), call, env)\n        }\n        .ok_or(Error::UnknownChainExtensionFunction)\n        .map_err(|err| {\n            error!(target: \"pink\", \"Called an unregistered `func_id`: {:}\", env.func_id());\n            err\n        })?;\n        env.write(&output, false, None)\n            .or(Err(Error::ContractIoBufferOverflow))?;\n        Ok(RetVal::Converging(ret))\n    }\n\n    fn enabled() -> bool {\n        true\n    }\n}\n\nstruct CallInQuery {\n    address: AccountId,\n}\n\nimpl PinkRuntimeEnv for CallInQuery {\n    type AccountId = AccountId;\n\n    fn address(&self) -> &Self::AccountId {\n        &self.address\n    }\n}\n\nimpl CallInQuery {\n    fn ensure_system(&self) -> Result<(), DispatchError> {\n        let contract: AccountId32 = self.address.convert_to();\n        if Some(contract) != PalletPink::system_contract() {\n            return Err(DispatchError::BadOrigin);\n        }\n        Ok(())\n    }\n    fn address_bytes(&self) -> Vec<u8> {\n        let slice: &[u8] = self.address.as_ref();\n        slice.to_vec()\n    }\n}\n\nimpl PinkExtBackend for CallInQuery {\n    type Error = DispatchError;\n    fn http_request(&self, request: HttpRequest) -> Result<HttpResponse, Self::Error> {\n        OCallImpl\n            .http_request(self.address.clone(), request)\n            .map_err(|err| DispatchError::Other(err.display()))\n    }\n\n    fn batch_http_request(\n        &self,\n        requests: Vec<ext::HttpRequest>,\n        timeout_ms: u64,\n    ) -> Result<ext::BatchHttpResult, Self::Error> {\n        Ok(OCallImpl.batch_http_request(self.address.clone(), requests, timeout_ms))\n    }\n\n    fn sign(\n        &self,\n        sigtype: SigType,\n        key: Cow<[u8]>,\n        message: Cow<[u8]>,\n    ) -> Result<Vec<u8>, Self::Error> {\n        DefaultPinkExtension::new(self).sign(sigtype, key, message)\n    }\n\n    fn verify(\n        &self,\n        sigtype: SigType,\n        pubkey: Cow<[u8]>,\n        message: Cow<[u8]>,\n        signature: Cow<[u8]>,\n    ) -> Result<bool, Self::Error> {\n        DefaultPinkExtension::new(self).verify(sigtype, pubkey, message, signature)\n    }\n\n    fn derive_sr25519_key(&self, salt: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        let privkey = PalletPink::key().ok_or(Error::KeySeedMissing)?;\n        let privkey = sp_core::sr25519::Pair::restore_from_secret_key(&privkey);\n        let contract_address: &[u8] = self.address.as_ref();\n        let derived_pair = privkey\n            .derive_sr25519_pair(&[contract_address, &salt, b\"keygen\"])\n            .or(Err(Error::DeriveKeyFailed))?;\n        let priviate_key = derived_pair.dump_secret_key();\n        let priviate_key: &[u8] = priviate_key.as_ref();\n        Ok(priviate_key.to_vec())\n    }\n\n    fn get_public_key(&self, sigtype: SigType, key: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        DefaultPinkExtension::new(self).get_public_key(sigtype, key)\n    }\n\n    fn cache_set(\n        &self,\n        key: Cow<[u8]>,\n        value: Cow<[u8]>,\n    ) -> Result<Result<(), StorageQuotaExceeded>, Self::Error> {\n        Ok(OCallImpl.cache_set(self.address_bytes(), key.into_owned(), value.into_owned()))\n    }\n\n    fn cache_set_expiration(&self, key: Cow<[u8]>, expire: u64) -> Result<(), Self::Error> {\n        OCallImpl.cache_set_expiration(self.address_bytes(), key.into_owned(), expire);\n        Ok(())\n    }\n\n    fn cache_get(&self, key: Cow<'_, [u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        Ok(OCallImpl.cache_get(self.address_bytes(), key.into_owned()))\n    }\n\n    fn cache_remove(&self, key: Cow<'_, [u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        Ok(OCallImpl.cache_remove(self.address_bytes(), key.into_owned()))\n    }\n\n    fn log(&self, level: u8, message: Cow<str>) -> Result<(), Self::Error> {\n        OCallImpl.log_to_server(self.address.clone(), level, message.as_ref().into());\n        DefaultPinkExtension::new(self).log(level, message)\n    }\n\n    fn getrandom(&self, length: u8) -> Result<Vec<u8>, Self::Error> {\n        DefaultPinkExtension::new(self).getrandom(length)\n    }\n\n    fn is_in_transaction(&self) -> Result<bool, Self::Error> {\n        Ok(false)\n    }\n\n    fn ecdsa_sign_prehashed(\n        &self,\n        key: Cow<[u8]>,\n        message_hash: Hash,\n    ) -> Result<EcdsaSignature, Self::Error> {\n        DefaultPinkExtension::new(self).ecdsa_sign_prehashed(key, message_hash)\n    }\n\n    fn ecdsa_verify_prehashed(\n        &self,\n        signature: EcdsaSignature,\n        message_hash: Hash,\n        pubkey: EcdsaPublicKey,\n    ) -> Result<bool, Self::Error> {\n        DefaultPinkExtension::new(self).ecdsa_verify_prehashed(signature, message_hash, pubkey)\n    }\n\n    fn system_contract_id(&self) -> Result<ext::AccountId, Self::Error> {\n        PalletPink::system_contract()\n            .map(|address| address.convert_to())\n            .ok_or(Error::SystemContractMissing.into())\n    }\n\n    fn balance_of(\n        &self,\n        account: ext::AccountId,\n    ) -> Result<(pink::Balance, pink::Balance), Self::Error> {\n        self.ensure_system()?;\n        let account: AccountId32 = account.convert_to();\n        let total = crate::runtime::Balances::total_balance(&account);\n        let free = crate::runtime::Balances::free_balance(&account);\n        Ok((total, free))\n    }\n\n    fn untrusted_millis_since_unix_epoch(&self) -> Result<u64, Self::Error> {\n        DefaultPinkExtension::new(self).untrusted_millis_since_unix_epoch()\n    }\n\n    fn worker_pubkey(&self) -> Result<EcdhPublicKey, Self::Error> {\n        Ok(OCallImpl.worker_pubkey())\n    }\n\n    fn code_exists(&self, code_hash: Hash, sidevm: bool) -> Result<bool, Self::Error> {\n        if sidevm {\n            Ok(PalletPink::sidevm_code_exists(&code_hash.into()))\n        } else {\n            Ok(crate::storage::external_backend::code_exists(\n                &code_hash.into(),\n            ))\n        }\n    }\n\n    fn import_latest_system_code(\n        &self,\n        payer: ext::AccountId,\n    ) -> Result<Option<Hash>, Self::Error> {\n        self.ensure_system()?;\n        let system_code = OCallImpl.latest_system_code();\n        if system_code.is_empty() {\n            return Ok(None);\n        }\n        let code_hash = sp_core::blake2_256(&system_code);\n        if !self.code_exists(code_hash, false)? {\n            crate::runtime::Contracts::bare_upload_code(\n                payer.convert_to(),\n                system_code,\n                None,\n                pallet_contracts::Determinism::Enforced,\n            )?;\n        };\n        Ok(Some(code_hash))\n    }\n\n    fn runtime_version(&self) -> Result<(u32, u32), Self::Error> {\n        Ok(crate::version())\n    }\n\n    fn current_event_chain_head(&self) -> Result<(u64, Hash), Self::Error> {\n        Ok((\n            PalletPink::next_event_block_number(),\n            PalletPink::last_event_block_hash().into(),\n        ))\n    }\n\n    fn js_eval(&self, codes: Vec<JsCode>, args: Vec<String>) -> Result<JsValue, Self::Error> {\n        Ok(OCallImpl.js_eval(self.address.clone(), codes, args))\n    }\n\n    fn worker_sgx_quote(&self) -> Result<Option<SgxQuote>, Self::Error> {\n        Ok(OCallImpl.worker_sgx_quote())\n    }\n}\n\nstruct CallInCommand {\n    as_in_query: CallInQuery,\n}\n\n/// This implementation is used when calling the extension in a command.\n/// # NOTE FOR IMPLEMENTORS\n/// Make sure the return values are deterministic.\nimpl PinkExtBackend for CallInCommand {\n    type Error = DispatchError;\n\n    fn http_request(&self, _request: HttpRequest) -> Result<HttpResponse, Self::Error> {\n        Ok(HttpResponse {\n            status_code: 523,\n            reason_phrase: \"API Unavailable\".into(),\n            headers: vec![],\n            body: b\"HTTP request is not supported in transaction\".to_vec(),\n        })\n    }\n    fn batch_http_request(\n        &self,\n        _requests: Vec<ext::HttpRequest>,\n        _timeout_ms: u64,\n    ) -> Result<ext::BatchHttpResult, Self::Error> {\n        Ok(Err(ext::HttpRequestError::NotAllowed))\n    }\n    fn sign(\n        &self,\n        sigtype: SigType,\n        key: Cow<[u8]>,\n        message: Cow<[u8]>,\n    ) -> Result<Vec<u8>, Self::Error> {\n        if matches!(sigtype, SigType::Sr25519) {\n            return Ok(vec![]);\n        }\n        self.as_in_query.sign(sigtype, key, message)\n    }\n\n    fn verify(\n        &self,\n        sigtype: SigType,\n        pubkey: Cow<[u8]>,\n        message: Cow<[u8]>,\n        signature: Cow<[u8]>,\n    ) -> Result<bool, Self::Error> {\n        self.as_in_query.verify(sigtype, pubkey, message, signature)\n    }\n\n    fn derive_sr25519_key(&self, salt: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        self.as_in_query.derive_sr25519_key(salt)\n    }\n\n    fn get_public_key(&self, sigtype: SigType, key: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        self.as_in_query.get_public_key(sigtype, key)\n    }\n\n    fn cache_set(\n        &self,\n        key: Cow<[u8]>,\n        value: Cow<[u8]>,\n    ) -> Result<Result<(), StorageQuotaExceeded>, Self::Error> {\n        deposit_pink_event(\n            self.as_in_query.address.clone(),\n            PinkEvent::CacheOp(CacheOp::Set {\n                key: key.into_owned(),\n                value: value.into_owned(),\n            }),\n        );\n        Ok(Ok(()))\n    }\n\n    fn cache_set_expiration(&self, key: Cow<[u8]>, expiration: u64) -> Result<(), Self::Error> {\n        deposit_pink_event(\n            self.as_in_query.address.clone(),\n            PinkEvent::CacheOp(CacheOp::SetExpiration {\n                key: key.into_owned(),\n                expiration,\n            }),\n        );\n        Ok(())\n    }\n\n    fn cache_get(&self, _key: Cow<[u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        Ok(None)\n    }\n\n    fn cache_remove(&self, key: Cow<[u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        deposit_pink_event(\n            self.as_in_query.address.clone(),\n            PinkEvent::CacheOp(CacheOp::Remove {\n                key: key.into_owned(),\n            }),\n        );\n        Ok(None)\n    }\n\n    fn log(&self, level: u8, message: Cow<str>) -> Result<(), Self::Error> {\n        self.as_in_query.log(level, message)\n    }\n\n    fn getrandom(&self, _length: u8) -> Result<Vec<u8>, Self::Error> {\n        Ok(vec![])\n    }\n\n    fn is_in_transaction(&self) -> Result<bool, Self::Error> {\n        Ok(true)\n    }\n\n    fn ecdsa_sign_prehashed(\n        &self,\n        key: Cow<[u8]>,\n        message_hash: Hash,\n    ) -> Result<EcdsaSignature, Self::Error> {\n        self.as_in_query.ecdsa_sign_prehashed(key, message_hash)\n    }\n\n    fn ecdsa_verify_prehashed(\n        &self,\n        signature: EcdsaSignature,\n        message_hash: Hash,\n        pubkey: EcdsaPublicKey,\n    ) -> Result<bool, Self::Error> {\n        self.as_in_query\n            .ecdsa_verify_prehashed(signature, message_hash, pubkey)\n    }\n\n    fn system_contract_id(&self) -> Result<ext::AccountId, Self::Error> {\n        self.as_in_query.system_contract_id()\n    }\n\n    fn balance_of(\n        &self,\n        account: ext::AccountId,\n    ) -> Result<(pink::Balance, pink::Balance), Self::Error> {\n        self.as_in_query.balance_of(account)\n    }\n\n    fn untrusted_millis_since_unix_epoch(&self) -> Result<u64, Self::Error> {\n        Ok(0)\n    }\n\n    fn worker_pubkey(&self) -> Result<EcdhPublicKey, Self::Error> {\n        Ok(Default::default())\n    }\n\n    fn code_exists(&self, code_hash: Hash, sidevm: bool) -> Result<bool, Self::Error> {\n        self.as_in_query.code_exists(code_hash, sidevm)\n    }\n\n    fn import_latest_system_code(\n        &self,\n        payer: ext::AccountId,\n    ) -> Result<Option<Hash>, Self::Error> {\n        self.as_in_query.import_latest_system_code(payer)\n    }\n\n    fn runtime_version(&self) -> Result<(u32, u32), Self::Error> {\n        self.as_in_query.runtime_version()\n    }\n\n    fn current_event_chain_head(&self) -> Result<(u64, Hash), Self::Error> {\n        self.as_in_query.current_event_chain_head()\n    }\n\n    fn js_eval(&self, _code: Vec<JsCode>, _args: Vec<String>) -> Result<JsValue, Self::Error> {\n        Ok(JsValue::Exception(\n            \"Js evaluation is not supported in transaction\".into(),\n        ))\n    }\n\n    fn worker_sgx_quote(&self) -> Result<Option<SgxQuote>, Self::Error> {\n        Ok(None)\n    }\n}"
    }
  ]
}