{
  "Title": "M-6: If oracle is set for ERC777 token, re-entrancy is possible to steal all LToken funds",
  "Content": "# Issue M-6: If oracle is set for ERC777 token, re-entrancy is possible to steal all LToken funds \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/076-M \n## Found by \npanprog, xiaoming90, Tutturu, devtooligan, Bahurum, Czar102\n\n## Summary\n\nIf oracle is set for any `ERC777` or similar token (tokens which call receiver's hook after receiving it), re-entrancy in `Account.sweepTo` allows to borrow funds, which are immediately withdrawn along with all account assets without any health checks, leaving account with 0 assets and big debt, making it possible to drain all LToken funds.\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/core/Account.sol#L163-L174\n\n## Vulnerability Detail\n\nIf oracle is set for `ERC777` token, it's possible to add these tokens to assets (even if collateral or controller allowed token for them is not set, using the bug in uniswap v2 controller for `removeLiquidity`, which doesn't check if tokenIn is allowed).\n\nOnce `ERC777` token is added to assets, malicious user can close his account, which calls `Account.sweepTo`, which has multiple re-entrancy scenarios. As `ERC777` token will call user's hook after receiving these tokens, the following actions are possible in the hook to steal funds:\n\n- User can borrow funds, exit reentrancy, and all borrowed tokens along with all account assets will be immediately transfered to user without any health checks.\n- For tokens which were in `assets` list before the `ERC777` token, `hasAsset[]` is set to false even though the token is still in the assets list. Depositing these tokens again will add them to assets again, counting them twice in account balance calculations, which allows to borrow even more funds.\n- Ether is transferred back to user after all the `ERC20` tokens, so ether can also be used to borrow funds against, and it will also be transerred back to user along with all the `ERC20` tokens.\n\nList of bugs used in the attack:\n\n1. Uniswap v2 controller in `removeLiquidity` doesn't check if tokens received are allowed. It seems to assume that account can only have allowed uni v2 lp tokens (as it's checked in `addLiquidity`), however any lp tokens can easily be transferred to account directly (not via `exec`). This makes it possible to call `exec` to `removeLiquidity` and add ANY tokens to account's assets list (and if oracle is set for the token, `accountManager.exec` will succeed as it doesn't check for asset tokens to be allowed as collateral)\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/controller/src/uniswap/UniV2Controller.sol#L182-L189\n\n2. `Account.sweepTo` is very vulnerable to re-entrancy. While it assumes that asset tokens are ERC20, if ERC20-compatible tokens with callback hooks are allowed (such as `ERC777` tokens), these tokens can re-enter to steal funds.\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/core/Account.sol#L163-L174\n\nSteps to steal funds from LToken:\n\n1. OpenAccount\n2. If `ERC777` token is allowed as collateral, deposit `ERC777` token (such as `imBTC`, which is pegged 1:1 to BTC and is ERC777). If `ERC777` is not allowed as collateral, but the oracle for this token is set up, then use bug 1:\n  2.1. Deploy uniswap v2 pool `USDC-imBTC`, add liquidity with minimum `USDC` and `imBTC`\n  2.2. Send uniswap v2 LP token to account's address\n  2.3. Call `AccountManager.exec` to `removeLiquidity` from uniswap v2 LP token, abusing bug 1 and receiving small amounts of `USDC+imBTC` (`tokensIn` are set and both `USDC` and `imBTC` are added to account's `assets`)\n3. Deposit `0 DAI` to add `DAI` to account `assets` (this is to include `DAI` in `sweepTo` at the last index, which will make it possible to borrow `DAI` in re-entrancy and immediately receive all of it without health checks)\n4. Close account\n5. Close account will performs `account.sweepTo` as the last step, where `USDC` is transferred to user, then `imBTC` is transferred to user, which calls `tokensReceived` on user's contract allowing re-entrancy. In `tokensReceived`:\n  5.1. Call `AccountManager.openAccount` to re-gain access to account (since it's closed) - this restores account access\n  5.2. Deposit `1 ether` to account\n  5.3. Borrow `4000 DAI`\n  5.4. Exit re-entrancy\n6. `sweepTo` continues and sends `4000 DAI` to user, then deletes `assets` and sends `1 ether` to user.\n7. At this point user has received back its `1 ether` and `4000 DAI`, leaving account with `0` assets and `4000 DAI` debt.\n\nThis scenario can be made even more capital efficient to steal more money if user deposits `1000 USDC` instead of `1 ether`, which will add `USDC` to assets, making his balance `2000` instead of `1000`, allowing to borrow `8000 DAI` for the same deposited amount. If this is repeated a few times, it's possible to steal millions with only a small initial capital.\n\n## Impact\n\nIf any `ERC777` (or similar) token oracle is added, it's very easy to steal all funds from all LTokens which you can borrow from.\n\n## Code Snippet\n\nCreate folder `./protocol/src/test/integrations/attacks` and put these 2 test files there:\n\nhttps://gist.github.com/panprog/2f16348325303869f7d84653cf99fba1\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n1. Add ReEntrancy guard from openzeppelin to main entry functions, mostly all functions in `AccountManager`.\n2. Add correct token checks to uniswap v2 controller.\n\n## Sentiment Team\nWe found an additional issue reported by a community member which was not a real exploit but exploited a vulnerability in the logic. Would request the auditors to take a look. PR [here](https://github.com/sentimentxyz/protocol/pull/237).\n\n## Lead Senior Watson\nFixed. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "protocol/src/core/Account.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Helpers} from \"../utils/Helpers.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\n\n/**\n    @title Sentiment Account\n    @notice Contract that acts as a dynamic and distributed asset reserve\n        which holds a user’s collateral and loaned assets\n*/\ncontract Account is IAccount {\n    using Helpers for address;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              STATE VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Block number for when the account is activated\n    uint public activationBlock;\n\n    /**\n        @notice Address of account manager\n        @dev If the value is 0x0 the contract is not initialized\n    */\n    address public accountManager;\n\n\n    /// @notice A list of ERC-20 assets (Collaterals + Borrows) present in the account\n    address[] public assets;\n\n    /// @notice A list of borrowed ERC-20 assets present in the account\n    address[] public borrows;\n\n    /// @notice A mapping of ERC-20 assets present in the account\n    mapping(address => bool) public hasAsset;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Initializes the account by setting the address of the account\n            manager\n        @dev Can only be called as long as the address of the accountManager is\n            0x0\n        @param _accountManager address of the account manager\n    */\n    function init(address _accountManager) external {\n        if (accountManager != address(0))\n            revert Errors.ContractAlreadyInitialized();\n        accountManager = _accountManager;\n    }\n\n    /**\n        @notice Activates an account by setting the activationBlock to the\n            current block number\n    */\n    function activate() external accountManagerOnly {\n        activationBlock = block.number;\n    }\n\n    /**\n        @notice Deactivates an account by setting the activationBlock to 0\n    */\n    function deactivate() external accountManagerOnly {\n        activationBlock = 0;\n    }\n\n    /**\n        @notice Returns a list of ERC-20 assets deposited and borrowed by the owner\n        @return assets List of addresses\n    */\n    function getAssets() external view returns (address[] memory) {\n        return assets;\n    }\n\n    /**\n        @notice Returns a list of ERC-20 assets borrowed by the owner\n        @return borrows List of addresses\n    */\n    function getBorrows() external view returns (address[] memory) {\n        return borrows;\n    }\n\n    /**\n        @notice Adds a given ERC-20 token to the assets list\n        @param token Address of the ERC-20 token to add\n    */\n    function addAsset(address token) external accountManagerOnly {\n        assets.push(token);\n        hasAsset[token] = true;\n    }\n\n    /**\n        @notice Adds a given ERC-20 token to the borrows list\n        @param token Address of the ERC-20 token to add\n    */\n    function addBorrow(address token) external accountManagerOnly {\n        borrows.push(token);\n    }\n\n    /**\n        @notice Removes a given ERC-20 token from the assets list\n        @param token Address of the ERC-20 token to remove\n    */\n    function removeAsset(address token) external accountManagerOnly {\n        _remove(assets, token);\n        hasAsset[token] = false;\n    }\n\n    /**\n        @notice Removes a given ERC-20 token from the borrows list\n        @param token Address of the ERC-20 token to remove\n    */\n    function removeBorrow(address token) external accountManagerOnly {\n        _remove(borrows, token);\n    }\n\n    /**\n        @notice Returns whether the account has debt or not by checking the length\n            of the borrows list\n        @return hasNoDebt bool\n    */\n    function hasNoDebt() external view returns (bool) {\n        return borrows.length == 0;\n    }\n\n    /**\n        @notice Generalized utility function to transact with a given contract\n        @param target Address of contract to transact with\n        @param amt Amount of Eth to send to the target contract\n        @param data Encoded sig + params of the function to transact with in the\n            target contract\n        @return success True if transaction was successful, false otherwise\n        @return retData Data returned by given target contract after\n            the transaction\n    */\n    function exec(address target, uint amt, bytes calldata data)\n        external\n        accountManagerOnly\n        returns (bool, bytes memory)\n    {\n        (bool success, bytes memory retData) = target.call{value: amt}(data);\n        return (success, retData);\n    }\n\n    /**\n        @notice Utility function to transfer all assets to a specified account\n            and delete all assets\n        @param toAddress address of the account to send the assets to\n    */\n    function sweepTo(address toAddress) external accountManagerOnly {\n        uint assetsLen = assets.length;\n        for(uint i; i < assetsLen; ++i) {\n            assets[i].safeTransfer(\n                toAddress,\n                assets[i].balanceOf(address(this))\n            );\n            hasAsset[assets[i]] = false;\n        }\n        delete assets;\n        toAddress.safeTransferEth(address(this).balance);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Utility function to remove a given address from a list of addresses\n        @param arr A list of addresses\n        @param token Address to remove\n    */\n    function _remove(address[] storage arr, address token) internal {\n        uint len = arr.length;\n        for(uint i; i < len; ++i) {\n            if (arr[i] == token) {\n                arr[i] = arr[arr.length - 1];\n                arr.pop();\n                break;\n            }\n        }\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "controller/src/uniswap/UniV2Controller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IController} from \"../core/IController.sol\";\nimport {IControllerFacade} from \"../core/IControllerFacade.sol\";\nimport {IUniV2Factory} from \"./IUniV2Factory.sol\";\n\n/**\n    @title Uniswap V2 Controller\n    @notice Controller for uniswap v2 interaction\n    eth:0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n*/\ncontract UniV2Controller is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\tfunction signature\n    bytes4 constant SWAP_EXACT_TOKENS_FOR_TOKENS = 0x38ed1739;\n\n    /// @notice swapTokensForExactTokens(uint256,uint256,address[],address,uint256)\tfunction signature\n    bytes4 constant SWAP_TOKENS_FOR_EXACT_TOKENS = 0x8803dbee;\n\n    /// @notice swapExactETHForTokens(uint256,address[],address,uint256) function signature\n    bytes4 constant SWAP_EXACT_ETH_FOR_TOKENS = 0x7ff36ab5;\n\n    /// @notice swapTokensForExactETH(uint256,uint256,address[],address,uint256) function signature\n    bytes4 constant SWAP_TOKENS_FOR_EXACT_ETH = 0x4a25d94a;\n\n    /// @notice swapExactTokensForETH(uint256,uint256,address[],address,uint256) function signature\n    bytes4 constant SWAP_EXACT_TOKENS_FOR_ETH = 0x18cbafe5;\n\n    /// @notice swapETHForExactTokens(uint256,address[],address,uint256) function signature\n    bytes4 constant SWAP_ETH_FOR_EXACT_TOKENS = 0xfb3bdb41;\n\n    /// @notice addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256) function signature\n    bytes4 constant ADD_LIQUIDITY = 0xe8e33700;\n\n    /// @notice removeLiquidity(address,address,uint256,uint256,uint256,address,uint256) function signature\n    bytes4 constant REMOVE_LIQUIDITY = 0xbaa2abde;\n\n    /// @notice addLiquidityETH(address,uint256,uint256,uint256,address,uint256) function signature\n    bytes4 constant ADD_LIQUIDITY_ETH = 0xf305d719;\n\n    /// @notice removeLiquidityETH(address,uint256,uint256,uint256,address,uint256) function signature\n    bytes4 constant REMOVE_LIQUIDITY_ETH = 0x02751cec;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice WETH address\n    address public immutable WETH;\n\n    /// @notice Uniswap v2 factory\n    IUniV2Factory public immutable UNIV2_FACTORY;\n\n    /// @notice IControllerFacade\n    IControllerFacade public immutable controller;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract constructor\n        @param _WETH WETH address\n        @param _uniV2Factory Uniswap V2 Factory address\n        @param _controller Controller Facade\n    */\n    constructor(\n        address _WETH,\n        IUniV2Factory _uniV2Factory,\n        IControllerFacade _controller\n    ) {\n        WETH = _WETH;\n        UNIV2_FACTORY = _uniV2Factory;\n        controller = _controller;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        // Swap Functions\n        if (sig == SWAP_EXACT_TOKENS_FOR_TOKENS || sig == SWAP_TOKENS_FOR_EXACT_TOKENS)\n            return swapErc20ForErc20(data[4:]); // ERC20 -> ERC20\n        if (sig == SWAP_EXACT_ETH_FOR_TOKENS || sig == SWAP_ETH_FOR_EXACT_TOKENS)\n            return swapEthForErc20(data[4:]); // ETH -> ERC20\n        if (sig == SWAP_TOKENS_FOR_EXACT_ETH || sig == SWAP_EXACT_TOKENS_FOR_ETH)\n            return swapErc20ForEth(data[4:]); // ERC20 -> ETH\n\n        // LP Functions\n        if (sig == ADD_LIQUIDITY) return addLiquidity(data[4:]);\n        if (sig == REMOVE_LIQUIDITY) return removeLiquidity(data[4:]);\n        if (sig == ADD_LIQUIDITY_ETH) return addLiquidityEth(data[4:]);\n        if (sig == REMOVE_LIQUIDITY_ETH) return removeLiquidityEth(data[4:]);\n\n        return(false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Evaluates whether liquidity can be added\n        @param data calldata for adding liquidity\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function addLiquidity(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address tokenA, address tokenB) = abi.decode(data, (address, address));\n\n        address[] memory tokensOut = new address[](2);\n        tokensOut[0] = tokenA;\n        tokensOut[1] = tokenB;\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = UNIV2_FACTORY.getPair(tokenA, tokenB);\n\n        return(controller.isTokenAllowed(tokensIn[0]), tokensIn, tokensOut);\n    }\n\n    /**\n        @notice Evaluates whether liquidity can be added\n        @param data calldata for adding liquidity\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function addLiquidityEth(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address token = abi.decode(data, (address));\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = token;\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = UNIV2_FACTORY.getPair(token, WETH);\n\n        return(controller.isTokenAllowed(tokensIn[0]), tokensIn, tokensOut);\n    }\n\n    /**\n        @notice Evaluates whether liquidity can be removed\n        @param data calldata for removing liquidity\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function removeLiquidity(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address tokenA, address tokenB) = abi.decode(data, (address, address));\n\n        address[] memory tokensIn = new address[](2);\n        tokensIn[0] = tokenA;\n        tokensIn[1] = tokenB;\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = UNIV2_FACTORY.getPair(tokenA, tokenB);\n\n        return(true, tokensIn, tokensOut);\n    }\n\n    /**\n        @notice Evaluates whether liquidity can be removed\n        @param data calldata for removing liquidity\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function removeLiquidityEth(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address token) = abi.decode(data, (address));\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = token;\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = UNIV2_FACTORY.getPair(token, WETH);\n\n        return(true, tokensIn, tokensOut);\n    }\n\n    /**\n        @notice Evaluates whether swap can be performed\n        @param data calldata for swapping tokens\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function swapErc20ForErc20(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (,, address[] memory path,,)\n                = abi.decode(data, (uint, uint, address[], address, uint));\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = path[0];\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = path[path.length - 1];\n\n        return(\n            controller.isTokenAllowed(tokensIn[0]),\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    /**\n        @notice Evaluates whether swap can be performed\n        @param data calldata for swapping tokens\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function swapEthForErc20(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (, address[] memory path,,)\n                = abi.decode(data, (uint, address[], address, uint));\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = path[path.length - 1];\n\n        return (\n            controller.isTokenAllowed(tokensIn[0]),\n            tokensIn,\n            new address[](0)\n        );\n    }\n\n    /**\n        @notice Evaluates whether swap can be performed\n        @param data calldata for swapping tokens\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function swapErc20ForEth(bytes calldata data)\n        internal\n        pure\n        returns (bool, address[] memory, address[] memory)\n    {\n        (,, address[] memory path)\n                = abi.decode(data, (uint, uint, address[]));\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = path[0];\n\n        return (true, new address[](0), tokensOut);\n    }\n}"
    },
    {
      "filename": "protocol/src/core/Account.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Helpers} from \"../utils/Helpers.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\n\n/**\n    @title Sentiment Account\n    @notice Contract that acts as a dynamic and distributed asset reserve\n        which holds a user’s collateral and loaned assets\n*/\ncontract Account is IAccount {\n    using Helpers for address;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              STATE VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Block number for when the account is activated\n    uint public activationBlock;\n\n    /**\n        @notice Address of account manager\n        @dev If the value is 0x0 the contract is not initialized\n    */\n    address public accountManager;\n\n\n    /// @notice A list of ERC-20 assets (Collaterals + Borrows) present in the account\n    address[] public assets;\n\n    /// @notice A list of borrowed ERC-20 assets present in the account\n    address[] public borrows;\n\n    /// @notice A mapping of ERC-20 assets present in the account\n    mapping(address => bool) public hasAsset;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Initializes the account by setting the address of the account\n            manager\n        @dev Can only be called as long as the address of the accountManager is\n            0x0\n        @param _accountManager address of the account manager\n    */\n    function init(address _accountManager) external {\n        if (accountManager != address(0))\n            revert Errors.ContractAlreadyInitialized();\n        accountManager = _accountManager;\n    }\n\n    /**\n        @notice Activates an account by setting the activationBlock to the\n            current block number\n    */\n    function activate() external accountManagerOnly {\n        activationBlock = block.number;\n    }\n\n    /**\n        @notice Deactivates an account by setting the activationBlock to 0\n    */\n    function deactivate() external accountManagerOnly {\n        activationBlock = 0;\n    }\n\n    /**\n        @notice Returns a list of ERC-20 assets deposited and borrowed by the owner\n        @return assets List of addresses\n    */\n    function getAssets() external view returns (address[] memory) {\n        return assets;\n    }\n\n    /**\n        @notice Returns a list of ERC-20 assets borrowed by the owner\n        @return borrows List of addresses\n    */\n    function getBorrows() external view returns (address[] memory) {\n        return borrows;\n    }\n\n    /**\n        @notice Adds a given ERC-20 token to the assets list\n        @param token Address of the ERC-20 token to add\n    */\n    function addAsset(address token) external accountManagerOnly {\n        assets.push(token);\n        hasAsset[token] = true;\n    }\n\n    /**\n        @notice Adds a given ERC-20 token to the borrows list\n        @param token Address of the ERC-20 token to add\n    */\n    function addBorrow(address token) external accountManagerOnly {\n        borrows.push(token);\n    }\n\n    /**\n        @notice Removes a given ERC-20 token from the assets list\n        @param token Address of the ERC-20 token to remove\n    */\n    function removeAsset(address token) external accountManagerOnly {\n        _remove(assets, token);\n        hasAsset[token] = false;\n    }\n\n    /**\n        @notice Removes a given ERC-20 token from the borrows list\n        @param token Address of the ERC-20 token to remove\n    */\n    function removeBorrow(address token) external accountManagerOnly {\n        _remove(borrows, token);\n    }\n\n    /**\n        @notice Returns whether the account has debt or not by checking the length\n            of the borrows list\n        @return hasNoDebt bool\n    */\n    function hasNoDebt() external view returns (bool) {\n        return borrows.length == 0;\n    }\n\n    /**\n        @notice Generalized utility function to transact with a given contract\n        @param target Address of contract to transact with\n        @param amt Amount of Eth to send to the target contract\n        @param data Encoded sig + params of the function to transact with in the\n            target contract\n        @return success True if transaction was successful, false otherwise\n        @return retData Data returned by given target contract after\n            the transaction\n    */\n    function exec(address target, uint amt, bytes calldata data)\n        external\n        accountManagerOnly\n        returns (bool, bytes memory)\n    {\n        (bool success, bytes memory retData) = target.call{value: amt}(data);\n        return (success, retData);\n    }\n\n    /**\n        @notice Utility function to transfer all assets to a specified account\n            and delete all assets\n        @param toAddress address of the account to send the assets to\n    */\n    function sweepTo(address toAddress) external accountManagerOnly {\n        uint assetsLen = assets.length;\n        for(uint i; i < assetsLen; ++i) {\n            assets[i].safeTransfer(\n                toAddress,\n                assets[i].balanceOf(address(this))\n            );\n            hasAsset[assets[i]] = false;\n        }\n        delete assets;\n        toAddress.safeTransferEth(address(this).balance);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Utility function to remove a given address from a list of addresses\n        @param arr A list of addresses\n        @param token Address to remove\n    */\n    function _remove(address[] storage arr, address token) internal {\n        uint len = arr.length;\n        for(uint i; i < len; ++i) {\n            if (arr[i] == token) {\n                arr[i] = arr[arr.length - 1];\n                arr.pop();\n                break;\n            }\n        }\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}