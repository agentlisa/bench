{
  "Title": "[M-42] `UlyssesPool.sol` does not match `EIP4626` because of the preview functions",
  "Content": "\nAccording to EIP4626, `previewDeposit()`, `previewRedeem()` and `previewMint()` must include a fee in the returned value:\n1. `previewDeposit` \"MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\"\n2. `previewRedeem` \"MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\"\n3. `previewMint` \"MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\"\n\n### Proof of Concept\n\n`UlyssesPool.sol` inherits `UlyssesERC4626.sol` with default implementation:\n\nhttps://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/UlyssesERC4626.sol#L96-L106>\n\n```solidity\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return assets;\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n```\n\nHowever, `deposit`, `redeem` and `mint` in `UlyssesPool.sol` take fees:\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesPool.sol#L1200-L1221>\n\n```solidity\n    function beforeDeposit(uint256 assets) internal override returns (uint256 shares) {\n        // Update deposit/mint\n        shares = ulyssesAddLP(assets, true);\n    }\n\n    /**\n     * @notice Performs the necessary steps to make after depositing.\n     * @param assets to be deposited\n     */\n    function beforeMint(uint256 shares) internal override returns (uint256 assets) {\n        // Update deposit/mint\n        assets = ulyssesAddLP(shares, false);\n    }\n\n    /**\n     * @notice Performs the necessary steps to take before withdrawing assets\n     * @param shares to be burned\n     */\n    function afterRedeem(uint256 shares) internal override returns (uint256 assets) {\n        // Update withdraw/redeem\n        assets = ulyssesRemoveLP(shares);\n    }\n```\n\nFurthermore, you can check that the functions `ulyssesAddLP()` and `ulyssesRemoveLP()` take fees. I consider it overabundant in this submission.\n\n### Recommended Mitigation Steps\n\nOverride the preview functions in `UlyssesPool.sol` to include fees.\n\n### Assessed type\n\nERC4626\n\n**[0xLightt (Maia) confirmed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/98#issuecomment-1655654891):**\n > We recognize the audit's findings on Ulysses AMM. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-4626/UlyssesERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IUlyssesERC4626} from \"./interfaces/IUlyssesERC4626.sol\";\n\n/// @title Minimal ERC4626 tokenized 1:1 Vault implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract UlyssesERC4626 is ERC20, ReentrancyGuard, IUlyssesERC4626 {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable asset;\n\n    constructor(address _asset, string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        asset = _asset;\n\n        if (ERC20(_asset).decimals() != 18) revert InvalidAssetDecimals();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual nonReentrant returns (uint256 shares) {\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        shares = beforeDeposit(assets);\n\n        require(shares != 0, \"ZERO_SHARES\");\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual nonReentrant returns (uint256 assets) {\n        assets = beforeMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        require(assets != 0, \"ZERO_ASSETS\");\n\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 assets)\n    {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        assets = afterRedeem(shares);\n\n        require(assets != 0, \"ZERO_ASSETS\");\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return assets;\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return assets;\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function beforeDeposit(uint256 assets) internal virtual returns (uint256 shares);\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function beforeMint(uint256 shares) internal virtual returns (uint256 assets);\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function afterRedeem(uint256 shares) internal virtual returns (uint256 assets);\n}"
    },
    {
      "filename": "src/ulysses-amm/UlyssesPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {UlyssesERC4626} from \"@ERC4626/UlyssesERC4626.sol\";\n\nimport {UlyssesFactory} from \"./factories/UlyssesFactory.sol\";\n\nimport {IUlyssesPool} from \"./interfaces/IUlyssesPool.sol\";\n\n/// @title Ulysses Pool - Single Sided Stableswap LP\n/// @author Maia DAO (https://github.com/Maia-DAO)\ncontract UlyssesPool is UlyssesERC4626, Ownable, IUlyssesPool {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n    using SafeCastLib for uint256;\n\n    /// @notice ulysses factory associated with the Ulysses LP\n    UlyssesFactory public immutable factory;\n\n    /// @notice ID of this Ulysses LP\n    uint256 public immutable id;\n\n    /// @notice List of all added LPs\n    BandwidthState[] public bandwidthStateList;\n\n    /// @notice destinations[destinationId] => bandwidthStateList index\n    mapping(uint256 => uint256) public destinations;\n\n    /// @notice destinationIds[address] => destinationId\n    mapping(address => uint256) public destinationIds;\n\n    /// @notice Sum of all weights\n    uint256 public totalWeights;\n\n    /// @notice The minimum amount that can be swapped\n    uint256 private constant MIN_SWAP_AMOUNT = 1e4;\n\n    /// @notice The maximum sum of all weights\n    uint256 private constant MAX_TOTAL_WEIGHT = 256;\n\n    /// @notice The maximum destinations that can be added\n    uint256 private constant MAX_DESTINATIONS = 15;\n\n    /// @notice The maximum protocol fee that can be set (1%)\n    uint256 private constant MAX_PROTOCOL_FEE = 1e16;\n\n    /// @notice The maximum lambda1 that can be set (10%)\n    uint256 private constant MAX_LAMBDA1 = 1e17;\n\n    /// @notice The minimum sigma2 that can be set (1%)\n    uint256 private constant MIN_SIGMA2 = 1e16;\n\n    /*//////////////////////////////////////////////////////////////\n                            FEE PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The divisioner for fee calculations\n    uint256 private constant DIVISIONER = 1 ether;\n\n    uint256 public protocolFee = 1e14;\n\n    /// @notice The current rebalancing fees\n    Fees public fees = Fees({lambda1: 20e14, lambda2: 4980e14, sigma1: 6000e14, sigma2: 500e14});\n\n    /**\n     * @param _id the Ulysses LP ID\n     * @param _asset the underlying asset\n     * @param _name the name of the LP\n     * @param _symbol the symbol of the LP\n     * @param _owner the owner of this contract\n     * @param _factory the Ulysses factory\n     */\n    constructor(\n        uint256 _id,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _owner,\n        address _factory\n    ) UlyssesERC4626(_asset, _name, _symbol) {\n        require(_owner != address(0));\n        factory = UlyssesFactory(_factory);\n        _initializeOwner(_owner);\n        require(_id != 0);\n        id = _id;\n\n        bandwidthStateList.push(BandwidthState({bandwidth: 0, destination: UlyssesPool(address(0)), weight: 0}));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    // @inheritdoc UlyssesERC4626\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this)) - getProtocolFees();\n    }\n\n    // @inheritdoc UlyssesERC4626\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf[owner].min(asset.balanceOf(address(this)));\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function getBandwidth(uint256 destinationId) external view returns (uint256) {\n        /**\n         * @dev bandwidthStateList first element has always 0 bandwidth\n         *      so this line will never fail and return 0 instead\n         */\n        return bandwidthStateList[destinations[destinationId]].bandwidth;\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function getBandwidthStateList() external view returns (BandwidthState[] memory) {\n        return bandwidthStateList;\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function getProtocolFees() public view returns (uint256) {\n        uint256 balance = asset.balanceOf(address(this));\n        uint256 assets;\n\n        for (uint256 i = 1; i < bandwidthStateList.length; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            assets += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n\n            assets += bandwidthStateList[i].bandwidth;\n        }\n\n        if (balance > assets) {\n            return balance - assets;\n        } else {\n            return 0;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUlyssesPool\n    function claimProtocolFees() external nonReentrant returns (uint256 claimed) {\n        claimed = getProtocolFees();\n\n        if (claimed > 0) {\n            asset.safeTransfer(factory.owner(), claimed);\n        }\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function addNewBandwidth(uint256 poolId, uint8 weight) external nonReentrant onlyOwner returns (uint256 index) {\n        if (weight == 0) revert InvalidWeight();\n\n        UlyssesPool destination = factory.pools(poolId);\n        uint256 destinationId = destination.id();\n\n        if (destinationIds[address(destination)] != 0 || destinationId == id) revert InvalidPool();\n\n        if (destinationId == 0) revert NotUlyssesLP();\n\n        index = bandwidthStateList.length;\n\n        if (index > MAX_DESTINATIONS) revert TooManyDestinations();\n\n        uint256 oldRebalancingFee;\n\n        for (uint256 i = 1; i < index; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            oldRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        uint256 oldTotalWeights = totalWeights;\n        uint256 newTotalWeights = oldTotalWeights + weight;\n        totalWeights = newTotalWeights;\n\n        if (newTotalWeights > MAX_TOTAL_WEIGHT) revert InvalidWeight();\n\n        uint256 newBandwidth;\n\n        for (uint256 i = 1; i < index;) {\n            uint256 oldBandwidth = bandwidthStateList[i].bandwidth;\n            if (oldBandwidth > 0) {\n                bandwidthStateList[i].bandwidth = oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();\n\n                newBandwidth += oldBandwidth - bandwidthStateList[i].bandwidth;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        bandwidthStateList.push(\n            BandwidthState({bandwidth: newBandwidth.toUint248(), destination: destination, weight: weight})\n        );\n\n        destinations[destinationId] = index;\n        destinationIds[address(destination)] = index;\n\n        uint256 newRebalancingFee;\n\n        for (uint256 i = 1; i <= index; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            newRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        if (oldRebalancingFee < newRebalancingFee) {\n            asset.safeTransferFrom(msg.sender, address(this), newRebalancingFee - oldRebalancingFee);\n        }\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function setWeight(uint256 poolId, uint8 weight) external nonReentrant onlyOwner {\n        if (weight == 0) revert InvalidWeight();\n\n        uint256 poolIndex = destinations[poolId];\n\n        if (poolIndex == 0) revert NotUlyssesLP();\n\n        uint256 oldRebalancingFee;\n\n        for (uint256 i = 1; i < bandwidthStateList.length; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            oldRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        uint256 oldTotalWeights = totalWeights;\n        uint256 weightsWithoutPool = oldTotalWeights - bandwidthStateList[poolIndex].weight;\n        uint256 newTotalWeights = weightsWithoutPool + weight;\n        totalWeights = newTotalWeights;\n\n        if (totalWeights > MAX_TOTAL_WEIGHT || oldTotalWeights == newTotalWeights) {\n            revert InvalidWeight();\n        }\n\n        uint256 leftOverBandwidth;\n\n        BandwidthState storage poolState = bandwidthStateList[poolIndex];\n        poolState.weight = weight;\n\n        if (oldTotalWeights > newTotalWeights) {\n            for (uint256 i = 1; i < bandwidthStateList.length;) {\n                if (i != poolIndex) {\n                    uint256 oldBandwidth = bandwidthStateList[i].bandwidth;\n                    if (oldBandwidth > 0) {\n                        bandwidthStateList[i].bandwidth =\n                            oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();\n\n                        leftOverBandwidth += oldBandwidth - bandwidthStateList[i].bandwidth;\n                    }\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            poolState.bandwidth += leftOverBandwidth.toUint248();\n        } else {\n            uint256 oldBandwidth = poolState.bandwidth;\n            if (oldBandwidth > 0) {\n                poolState.bandwidth = oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();\n\n                leftOverBandwidth += oldBandwidth - poolState.bandwidth;\n            }\n\n            for (uint256 i = 1; i < bandwidthStateList.length;) {\n                if (i != poolIndex) {\n                    if (i == bandwidthStateList.length - 1) {\n                        bandwidthStateList[i].bandwidth += leftOverBandwidth.toUint248();\n                    } else if (leftOverBandwidth > 0) {\n                        bandwidthStateList[i].bandwidth +=\n                            leftOverBandwidth.mulDiv(bandwidthStateList[i].weight, weightsWithoutPool).toUint248();\n                    }\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint256 newRebalancingFee;\n\n        for (uint256 i = 1; i < bandwidthStateList.length; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            newRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        if (oldRebalancingFee < newRebalancingFee) {\n            asset.safeTransferFrom(msg.sender, address(this), newRebalancingFee - oldRebalancingFee);\n        }\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function setFees(Fees calldata _fees) external nonReentrant onlyOwner {\n        // Lower fee must be lower than 1%\n        if (_fees.lambda1 > MAX_LAMBDA1) revert InvalidFee();\n        // Sum of both fees must be 50%\n        if (_fees.lambda1 + _fees.lambda2 != DIVISIONER / 2) revert InvalidFee();\n\n        // Upper bound must be lower than 100%\n        if (_fees.sigma1 > DIVISIONER) revert InvalidFee();\n        // Lower bound must be lower than Upper bound and higher than 1%\n        if (_fees.sigma1 <= _fees.sigma2 || _fees.sigma2 < MIN_SIGMA2) revert InvalidFee();\n\n        fees = _fees;\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function setProtocolFee(uint256 _protocolFee) external nonReentrant {\n        if (msg.sender != factory.owner()) revert Unauthorized();\n\n        // Revert if the protocol fee is larger than 1%\n        if (_protocolFee > MAX_PROTOCOL_FEE) revert InvalidFee();\n\n        protocolFee = _protocolFee;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ULYSSES LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Calculates the bandwidth increase/decrease amount.\n     * Is called when a user is doing a swap or adding/removing liquidity.\n     * @param roundUp Whether to round up or down\n     * @param positiveTransfer Whether the transfer is positive or negative\n     * @param amount The amount to transfer\n     * @param _totalWeights The total weights\n     * @param _totalSupply The total supply\n     */\n    function getBandwidthUpdateAmounts(\n        bool roundUp,\n        bool positiveTransfer,\n        uint256 amount,\n        uint256 _totalWeights,\n        uint256 _totalSupply\n    ) private view returns (uint256[] memory bandwidthUpdateAmounts, uint256 length) {\n        // Get the bandwidth state list length\n        length = bandwidthStateList.length;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the list is empty\n            if eq(length, 1) {\n                // Store the function selector of `NotInitialized()`.\n                mstore(0x00, 0x87138d5c)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Revert if the amount is too small\n            if lt(amount, MIN_SWAP_AMOUNT) {\n                // Store the function selector of `AmountTooSmall()`.\n                mstore(0x00, 0xc2f5625a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Initialize bandwidth update amounts\n        bandwidthUpdateAmounts = new uint256[](length);\n        // Initialize bandwidth differences from target bandwidth\n        uint256[] memory diffs = new uint256[](length);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store bandwidth state slot in memory\n            mstore(0x00, bandwidthStateList.slot)\n            // Hash the bandwidth state slot to get the bandwidth state list start\n            let bandwidthStateListStart := keccak256(0x00, 0x20)\n\n            // Total difference from target bandwidth of all bandwidth states\n            let totalDiff\n            // Total difference from target bandwidth of all bandwidth states\n            let transfered\n            // Total amount to be distributed according to each bandwidth weights\n            let transferedChange\n\n            for { let i := 1 } lt(i, length) { i := add(i, 1) } {\n                // Load bandwidth and weight from storage\n                // Each bandwidth state occupies two storage slots\n                let slot := sload(add(bandwidthStateListStart, mul(i, 2)))\n                // Bandwidth is the first 248 bits of the slot\n                let bandwidth := and(slot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                // Weight is the last 8 bits of the slot\n                let weight := shr(248, slot)\n\n                // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n                if mul(weight, gt(_totalSupply, div(not(0), weight))) {\n                    // Store the function selector of `MulDivFailed()`.\n                    mstore(0x00, 0xad251c27)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n\n                // Calculate the target bandwidth\n                let targetBandwidth := div(mul(_totalSupply, weight), _totalWeights)\n\n                // Calculate the difference from the target bandwidth\n                switch positiveTransfer\n                // If the transfer is positive, calculate deficit from target bandwidth\n                case true {\n                    // If there is a deficit, store the difference\n                    if gt(targetBandwidth, bandwidth) {\n                        // Calculate the difference\n                        let diff := sub(targetBandwidth, bandwidth)\n                        // Add the difference to the total difference\n                        totalDiff := add(totalDiff, diff)\n                        // Store the difference in the diffs array\n                        mstore(add(diffs, add(mul(i, 0x20), 0x20)), diff)\n                    }\n                }\n                // If the transfer is negative, calculate surplus from target bandwidth\n                default {\n                    // If there is a surplus, store the difference\n                    if gt(bandwidth, targetBandwidth) {\n                        // Calculate the difference\n                        let diff := sub(bandwidth, targetBandwidth)\n                        // Add the difference to the total difference\n                        totalDiff := add(totalDiff, diff)\n                        // Store the difference in the diffs array\n                        mstore(add(diffs, add(mul(i, 0x20), 0x20)), diff)\n                    }\n                }\n            }\n\n            // Calculate the amount to be distributed according deficit/surplus\n            // and/or the amount to be distributed according to each bandwidth weights\n            switch gt(amount, totalDiff)\n            // If the amount is greater than the total deficit/surplus\n            case true {\n                // Total deficit/surplus is distributed\n                transfered := totalDiff\n                // Set rest to be distributed according to each bandwidth weights\n                transferedChange := sub(amount, totalDiff)\n            }\n            // If the amount is less than the total deficit/surplus\n            default {\n                // Amount will be distributed according to deficit/surplus\n                transfered := amount\n            }\n\n            for { let i := 1 } lt(i, length) { i := add(i, 1) } {\n                // Increase/decrease amount of bandwidth for each bandwidth state\n                let bandwidthUpdate\n\n                // If there is a deficit/surplus, calculate the amount to be distributed\n                if gt(transfered, 0) {\n                    // Load the difference from the diffs array\n                    let diff := mload(add(diffs, add(mul(i, 0x20), 0x20)))\n\n                    // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n                    if mul(diff, gt(transfered, div(not(0), diff))) {\n                        // Store the function selector of `MulDivFailed()`.\n                        mstore(0x00, 0xad251c27)\n                        // Revert with (offset, size).\n                        revert(0x1c, 0x04)\n                    }\n\n                    // Calculate the amount to be distributed according to deficit/surplus\n                    switch roundUp\n                    // If round up then do mulDivUp(transfered, diff, totalDiff)\n                    case true {\n                        bandwidthUpdate :=\n                            add(\n                                iszero(iszero(mod(mul(transfered, diff), totalDiff))), div(mul(transfered, diff), totalDiff)\n                            )\n                    }\n                    // If round down then do mulDiv(transfered, diff, totalDiff)\n                    default { bandwidthUpdate := div(mul(transfered, diff), totalDiff) }\n                }\n\n                // If there is a rest, calculate the amount to be distributed according to each bandwidth weights\n                if gt(transferedChange, 0) {\n                    // Load weight from storage\n                    let weight := shr(248, sload(add(bandwidthStateListStart, mul(i, 2))))\n\n                    // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n                    if mul(weight, gt(transferedChange, div(not(0), weight))) {\n                        // Store the function selector of `MulDivFailed()`.\n                        mstore(0x00, 0xad251c27)\n                        // Revert with (offset, size).\n                        revert(0x1c, 0x04)\n                    }\n\n                    // Calculate the amount to be distributed according to each bandwidth weights\n                    switch roundUp\n                    // If round up then do mulDivUp(transferedChange, weight, _totalWeights)\n                    case true {\n                        bandwidthUpdate :=\n                            add(\n                                bandwidthUpdate,\n                                add(\n                                    iszero(iszero(mod(mul(transferedChange, weight), _totalWeights))),\n                                    div(mul(transferedChange, weight), _totalWeights)\n                                )\n                            )\n                    }\n                    // If round down then do mulDiv(transferedChange, weight, _totalWeights)\n                    default {\n                        bandwidthUpdate := add(bandwidthUpdate, div(mul(transferedChange, weight), _totalWeights))\n                    }\n                }\n\n                // If there is an update in bandwidth\n                if gt(bandwidthUpdate, 0) {\n                    // Store the amount to be updated in the bandwidthUpdateAmounts array\n                    mstore(add(bandwidthUpdateAmounts, add(mul(i, 0x20), 0x20)), bandwidthUpdate)\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the bandwidth of the destination Ulysses LP\n     * @param depositFees Whether to deposit fees or not\n     * @param positiveTransfer Whether the transfer is positive or negative\n     * @param destinationState The state of the destination Ulysses LP\n     * @param difference The difference between the old and new total supply\n     * @param _totalWeights The total weights of all Ulysses LPs\n     * @param _totalSupply The total supply of the Ulysses LP\n     * @param _newTotalSupply  The new total supply of the Ulysses LP\n     * @return positivefee The positive fee\n     */\n    function updateBandwidth(\n        bool depositFees,\n        bool positiveTransfer,\n        BandwidthState storage destinationState,\n        uint256 difference,\n        uint256 _totalWeights,\n        uint256 _totalSupply,\n        uint256 _newTotalSupply\n    ) private returns (uint256 positivefee, uint256 negativeFee) {\n        uint256 bandwidth;\n        uint256 targetBandwidth;\n        uint256 weight;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Load bandwidth and weight from storage\n            let slot := sload(destinationState.slot)\n            // Bandwidth is the first 248 bits of the slot\n            bandwidth := and(slot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            // Weight is the last 8 bits of the slot\n            weight := shr(248, slot)\n\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(weight, gt(_totalSupply, div(not(0), weight))) {\n                // Store the function selector of `MulDivFailed()`.\n                mstore(0x00, 0xad251c27)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Get the target bandwidth\n            targetBandwidth := div(mul(_totalSupply, weight), _totalWeights)\n        }\n\n        // get the rebalancing fee prior to updating the bandwidth\n        uint256 oldRebalancingFee = _calculateRebalancingFee(\n            bandwidth,\n            targetBandwidth,\n            positiveTransfer // Rounds down if positive, up if negative\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch positiveTransfer\n            // If the transfer is positive\n            case true {\n                // Add the difference to the bandwidth\n                bandwidth := add(bandwidth, difference)\n\n                // Revert if bandwidth overflows\n                if lt(bandwidth, difference) {\n                    // Store the function selector of `Overflow()`.\n                    mstore(0x00, 0x35278d12)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n            }\n            // If the transfer is negative\n            default {\n                // Revert if bandwidth underflows\n                if gt(difference, bandwidth) {\n                    // Store the function selector of `Underflow()`.\n                    mstore(0x00, 0xcaccb6d9)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n\n                // Subtract the difference from the bandwidth\n                bandwidth := sub(bandwidth, difference)\n            }\n\n            // True on deposit, mint and redeem\n            if gt(_newTotalSupply, 0) {\n                // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n                if mul(weight, gt(_newTotalSupply, div(not(0), weight))) {\n                    // Store the function selector of `MulDivFailed()`.\n                    mstore(0x00, 0xad251c27)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n\n                // Get the new target bandwidth after total supply change\n                targetBandwidth := div(mul(_newTotalSupply, weight), _totalWeights)\n            }\n        }\n\n        // get the rebalancing fee after updating the bandwidth\n        uint256 newRebalancingFee = _calculateRebalancingFee(\n            bandwidth,\n            targetBandwidth,\n            positiveTransfer // Rounds down if positive, up if negative\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch lt(newRebalancingFee, oldRebalancingFee)\n            // If new fee is lower than old fee\n            case true {\n                // Calculate the positive fee\n                positivefee := sub(oldRebalancingFee, newRebalancingFee)\n\n                // If depositFees is true, add the positive fee to the bandwidth\n                if depositFees {\n                    bandwidth := add(bandwidth, positivefee)\n\n                    // Revert if bandwidth overflows\n                    if lt(bandwidth, positivefee) {\n                        // Store the function selector of `Overflow()`.\n                        mstore(0x00, 0x35278d12)\n                        // Revert with (offset, size).\n                        revert(0x1c, 0x04)\n                    }\n                }\n            }\n            default {\n                // If new fee is higher than old fee\n                if gt(newRebalancingFee, oldRebalancingFee) {\n                    // Calculate the negative fee\n                    negativeFee := sub(newRebalancingFee, oldRebalancingFee)\n                }\n            }\n\n            if gt(bandwidth, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                // Store the function selector of `Overflow()`.\n                mstore(0x00, 0x35278d12)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Update storage with the new bandwidth\n            sstore(destinationState.slot, or(bandwidth, shl(248, weight)))\n        }\n    }\n\n    /**\n     * @notice Calculates the positive or negative rebalancing fee for a bandwidth change\n     * @param bandwidth The new bandwidth, after decreasing or increasing the current bandwidth\n     * @param targetBandwidth The ideal bandwidth according to weight and totalSupply\n     * @param roundDown Whether to round down or up\n     * @return fee The rebalancing fee for this action\n     */\n    function _calculateRebalancingFee(uint256 bandwidth, uint256 targetBandwidth, bool roundDown)\n        internal\n        view\n        returns (uint256 fee)\n    {\n        // If the bandwidth is larger or equal to the target bandwidth, return 0\n        if (bandwidth >= targetBandwidth) return 0;\n\n        // Upper bound of the first fee interval\n        uint256 upperBound1;"
    }
  ]
}