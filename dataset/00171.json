{
  "Title": "M-1: Incorrect encoding of bytes for EIP712 digest in `TitleGraph` causes signatures generated by common EIP712 tools to be unusable",
  "Content": "# Issue M-1: Incorrect encoding of bytes for EIP712 digest in `TitleGraph` causes signatures generated by common EIP712 tools to be unusable \n\nSource: https://github.com/sherlock-audit/2024-04-titles-judging/issues/74 \n\n## Found by \n0x73696d616f, T1MOH, ZanyBonzy, ast3ros, fugazzi, mt030d\n## Summary\n\nThe signature in `﻿TitleGraph.acknowledgeEdge()` and ﻿`TitleGraph.unacknowledgeEdge()` is generated based on a digest computed from ﻿`edgeId` and ﻿`data`. However, the ﻿`data` bytes argument is not correctly encoded according to the EIP712 specification. Consequently, a signature generated using common EIP712 tools would not pass validation in ﻿`TitleGraph.checkSignature()`.\n\n## Vulnerability Detail\nAccording to [EIP712](https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata):\n> The dynamic values bytes and string are encoded as a keccak256 hash of their contents.\n\n```solidity\n    modifier checkSignature(bytes32 edgeId, bytes calldata data, bytes calldata signature) {\n        bytes32 digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n        ...\n    }\n```\nHowever, the `checkSignature()` modifier in the `TitlesGraph` contract reconstructs the digest by encoding the ﻿data bytes argument without first applying keccak256 hashing.\nAs a result, a signature generated using common EIP712 tools (e.g. using the `signTypedData` function from `ethers.js`) would not pass validation in ﻿`TitleGraph.checkSignature()`.\n\n### POC\n1. EIP712 signature computed by using ethers.js\n```js\n// main.js\nconst { ethers } = require(\"ethers\");\n\nasync function main() {\n    const pk = \"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\";\n    const signer = new ethers.Wallet(pk);\n    const domain = {\n      name: \"TitlesGraph\",\n      version: '1',\n      chainId: 31337,\n      verifyingContract: \"0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\" // should match the address in foundry test\n    };\n    const types = {\n      Ack: [\n        { name: \"edgeId\", type: \"bytes32\" },\n        { name: \"data\", type: \"bytes\" },\n      ],\n    };\n    const value = {\n        edgeId: ethers.id(\"test edgeId\"),\n        data: \"0xabcd\"\n    };\n    const signature = await signer.signTypedData(domain, types, value);\n    console.log(signature);\n    \n}\n\nmain();\n```\nhere we run \n```bash\nnpm install ethers\nnode main.js\n```\nThe output is `0xab4623a7bacf25ed3d6779684f195ed63a5ed1ed46c278c107390086e74b739b35f1db213c6075dedc041d68ced3d11798d49afaf3c47743d4696c49f03037b51b`\n\n2. EIP712 signature computed using foundry\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Test, console} from \"forge-std/Test.sol\";\nimport {EIP712} from \"lib/solady/src/utils/EIP712.sol\";\n\ncontract EIP712Test is Test, EIP712 {\n    bytes32 public constant ACK_TYPEHASH = keccak256(\"Ack(bytes32 edgeId,bytes data)\");\n\n    // test data\n    bytes32 testEdgeId = keccak256(\"test edgeId\");\n    bytes testData = hex\"abcd\";\n\n\n    function test_sig() public {\n        uint256 pk = 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80;\n        bytes32 digest = _computeDigest(testEdgeId, testData);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, digest);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        console.logBytes(signature);\n    }\n\n    function test_sigShouldBe() public {\n        uint256 pk = 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80;\n        bytes32 digest = _computeDigestShouldBe(testEdgeId, testData);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, digest);\n        bytes memory signature = abi.encodePacked(r, s, v);\n        console.logBytes(signature);\n    }\n\n    function _computeDigest(bytes32 edgeId, bytes memory data) internal returns (bytes32 digest) {\n        digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n    }\n\n    function _computeDigestShouldBe(bytes32 edgeId, bytes memory data) internal returns (bytes32 digest) {\n        digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, keccak256(data))));\n    }\n\n    function _domainNameAndVersion()\n        internal\n        pure\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"TitlesGraph\";\n        version = \"1\";\n    }\n}\n```\nhere we run\n```bash\nforge test --mc EIP712Test -vv\n```\nThe output is\n```txt\n[PASS] test_sig() (gas: 12176)\nLogs:\n  0x7bd09aece710ef3845f26c4a695d357b1b170f75d0702f18ec09409f571260237a38e0fed802f8a9d598d9aed0d7898562c51e09bfa7cf254e5a8a5bc74106561c\n\n[PASS] test_sigShouldBe() (gas: 11958)\nLogs:\n  0xab4623a7bacf25ed3d6779684f195ed63a5ed1ed46c278c107390086e74b739b35f1db213c6075dedc041d68ced3d11798d49afaf3c47743d4696c49f03037b51b\n```\n\n`test_sig()` simulates the way the digest is reconstructed in `TitleGraph.checkSignature()`, while `test_sigShouldBe()` shows how  the digest should be reconstructed.\nFrom the above output, we can see the signature generated by ethers.js matches the signature generated in `test_sigShouldBe()`  and does not match the signature generated in `test_sig()`.\nThis PoC shows the way `TitleGraph.checkSignature()` reconstruct the digest is not compatible with the way data is encoded in EIP712.\n\n## Impact\nA signature generated by the signer using common EIP712 tools (e.g. signTypedData in `ethers.js`) would not pass validation in ﻿`TitleGraph.checkSignature()`.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L41\n\n## Tool used\n\nManual Review, ethers.js, foundry\n\n## Recommendation\nEncoding the `data` bytes as a keccak256 hash of its contents before computing the digest from it:\n```diff\n- digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n+ digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, keccak256(data))));\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/326",
  "Code": [
    {
      "filename": "wallflower-contract-v2/src/graph/TitlesGraph.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {EIP712} from \"lib/solady/src/utils/EIP712.sol\";\nimport {SignatureCheckerLib} from \"lib/solady/src/utils/SignatureCheckerLib.sol\";\nimport {UUPSUpgradeable} from \"lib/solady/src/utils/UUPSUpgradeable.sol\";\n\nimport {IOpenGraph} from \"src/interfaces/IOpenGraph.sol\";\nimport {IEdgeManager} from \"src/interfaces/IEdgeManager.sol\";\nimport {ADMIN_ROLE, Edge, Node, Unauthorized} from \"src/shared/Common.sol\";\n\n/// @title TitlesGraph\n/// @notice Titles.xyz implementation of the OpenGraph standard\n/// @dev The TitlesGraph contract implements the OpenGraph standard and is responsible for managing the creation and acknowledgment of {Node}s and {Edge}s in the graph.\ncontract TitlesGraph is IOpenGraph, IEdgeManager, OwnableRoles, EIP712, UUPSUpgradeable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using SignatureCheckerLib for address;\n\n    error Exists();\n    error NotFound();\n\n    /// @notice The set of edge IDs in the graph. Enumerable to enable on-chain graph traversal in the future.\n    EnumerableSet.Bytes32Set private _edgeIds;\n\n    /// @notice Edges are relationships between two nodes in the graph.\n    mapping(bytes32 id => Edge edge) public edges;\n\n    /// @notice An internal mapping to prevent signature reuse.\n    mapping(bytes32 signature => bool used) private _isUsed;\n\n    // @notice The hash of the acknowledgement struct. Used for EIP-712.\n    bytes32 public constant ACK_TYPEHASH = keccak256(\"Ack(bytes32 edgeId,bytes data)\");\n\n    // @notice The EIP-712 domain type hash. (Exposed here for convenience.)\n    bytes32 public constant DOMAIN_TYPEHASH = _DOMAIN_TYPEHASH;\n\n    /// @notice Modified to check the signature for a proxied acknowledgment.\n    modifier checkSignature(bytes32 edgeId, bytes calldata data, bytes calldata signature) {\n        bytes32 digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n        if (\n            !edges[edgeId].to.creator.target.isValidSignatureNowCalldata(digest, signature)\n                || _isUsed[keccak256(signature)]\n        ) {\n            revert Unauthorized();\n        }\n        _;\n        _isUsed[keccak256(signature)] = true;\n    }\n\n    constructor(address owner_, address admin_) {\n        _initializeOwner(owner_);\n        _grantRoles(admin_, ADMIN_ROLE);\n    }\n\n    /// @inheritdoc IOpenGraph\n    /// @notice Create a new {Edge} between two {Node}s in the graph.\n    /// @param from_ The {Node} from which the edge originates.\n    /// @param to_ The {Node} to which the edge points.\n    /// @param data_ Metadata associated with the edge.\n    /// @return edge The created edge.\n    /// @dev This function is used to create a new edge between two nodes in the graph and will revert if not unique or if called by any address other than the contract referenced as the `from` node. A {NodeTouched} event is emitted for each node and an {EdgeCreated} event is emitted for the edge itself.\n    function createEdge(Node calldata from_, Node calldata to_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isEntity(from_, msg.sender)) revert Unauthorized();\n        return _createEdge(from_, to_, data_);\n    }\n\n    /// @notice Create multiple edges within the graph.\n    /// @param edges_ The edges to create.\n    /// @dev This function is used to create multiple edges within the graph and will revert if any of the edges are not unique. It emits a {NodeTouched} event for each node and an {EdgeCreated} event for each edge.\n    function createEdges(Edge[] calldata edges_) external onlyRolesOrOwner(ADMIN_ROLE) {\n        for (uint256 i = 0; i < edges_.length; i++) {\n            _createEdge(edges_[i].from, edges_[i].to, edges_[i].data);\n        }\n    }\n\n    function _createEdge(Node memory from_, Node memory to_, bytes memory data_)\n        internal\n        returns (Edge memory edge)\n    {\n        bytes32 edgeId = keccak256(abi.encode(from_, to_));\n        if (!_edgeIds.add(edgeId)) revert Exists();\n\n        edge = Edge({from: from_, to: to_, acknowledged: false, data: data_});\n        edges[edgeId] = edge;\n\n        emit NodeTouched(from_, data_);\n        emit NodeTouched(to_, data_);\n        emit EdgeCreated(edge, data_);\n    }\n\n    /// @inheritdoc IEdgeManager\n    /// @notice Acknowledge an edge.\n    /// @param edgeId_ The ID of the edge to acknowledge.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @return edge The acknowledged edge.\n    /// @dev This function is used to acknowledge an edge that was previously created and will revert if the edge does not exist. It emits an {EdgeAcknowledged} event for the edge.\n    function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isCreatorOrEntity(edges[edgeId_].to, msg.sender)) revert Unauthorized();\n        return _setAcknowledged(edgeId_, data_, true);\n    }\n\n    /// @notice Acknowledge an edge using an ECDSA signature.\n    /// @param edgeId_ The ID of the edge to acknowledge.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @param signature_ The ECDSA signature to verify.\n    /// @dev The request is valid if the given signature was produced using the edge ID as the message and the creator of the `to` node as the signer.\n    /// @dev This function is used to acknowledge an edge that was previously created and will revert if the edge does not exist or if the signature is invalid. It emits an {EdgeAcknowledged} event for the edge.\n    function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n        external\n        checkSignature(edgeId_, data_, signature_)\n        returns (Edge memory edge)\n    {\n        return _setAcknowledged(edgeId_, data_, true);\n    }\n\n    /// @inheritdoc IEdgeManager\n    /// @notice Unacknowledge an edge.\n    /// @param edgeId_ The ID of the edge to unacknowledge.\n    /// @param data_ Additional data to include with the unacknowledgment.\n    /// @dev This function is used to unacknowledge an edge that was previously acknowledged.\n    function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isCreatorOrEntity(edges[edgeId_].to, msg.sender)) revert Unauthorized();\n        return _setAcknowledged(edgeId_, data_, false);\n    }\n\n    /// @notice Unacknowledge an edge using an ECDSA signature.\n    /// @param edgeId_ The ID of the edge to unacknowledge.\n    /// @param data_ Additional data to include with the unacknowledgment.\n    /// @param signature_ The ECDSA signature to verify.\n    /// @dev The request is valid if the given signature was produced using the edge ID as the message and the creator of the `to` node as the signer.\n    /// @dev This function is used to unacknowledge an edge that was previously acknowledged and will revert if the edge does not exist or if the signature is invalid. It emits an {EdgeUnacknowledged} event for the edge.\n    function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n        external\n        checkSignature(edgeId_, data_, signature_)\n        returns (Edge memory edge)\n    {\n        return _setAcknowledged(edgeId_, data_, false);\n    }\n\n    /// @notice Override the {OwnableRoles} implementation to extend access to the `ADMIN_ROLE`.\n    /// @param guy The address to grant the roles.\n    /// @param roles The roles to grant.\n    /// @dev This function is used to grant roles to an address and will revert if the caller is not the owner and does not have the `ADMIN_ROLE`.\n    function grantRoles(address guy, uint256 roles)\n        public\n        payable\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        _grantRoles(guy, roles);\n    }\n\n    /// @notice Override the {OwnableRoles} implementation to extend access to the `ADMIN_ROLE`.\n    /// @param guy The address from which to revoke the roles.\n    /// @param roles The roles to revoke.\n    /// @dev This function is used to revoke roles from an address and will revert if the caller is not the owner and does not have the `ADMIN_ROLE`.\n    function revokeRoles(address guy, uint256 roles)\n        public\n        payable\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        _removeRoles(guy, roles);\n    }\n\n    /// @notice Get the ID of an edge given the source and target nodes.\n    /// @param from_ The source node of the edge.\n    /// @param to_ The target node of the edge.\n    /// @return edgeId The ID of the edge (i.e. the keccak256 hash of the `from` and `to` nodes).\n    function getEdgeId(Node memory from_, Node memory to_) public pure returns (bytes32) {\n        return keccak256(abi.encode(from_, to_));\n    }\n\n    /// @notice Get the ID of an edge.\n    /// @param edge_ The edge for which to get the ID.\n    /// @return edgeId The ID of the edge (i.e. the keccak256 hash of the `from` and `to` nodes).\n    function getEdgeId(Edge memory edge_) public pure returns (bytes32) {\n        return getEdgeId(edge_.from, edge_.to);\n    }\n\n    /// @notice Set the acknowledged status of an edge.\n    /// @param edgeId_ The ID of the edge to set the acknowledged status for.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @param acknowledged_ The new acknowledged status of the edge.\n    /// @return edge The edge with the updated acknowledged status.\n    function _setAcknowledged(bytes32 edgeId_, bytes calldata data_, bool acknowledged_)\n        internal\n        returns (Edge memory edge)\n    {\n        if (!_edgeIds.contains(edgeId_)) revert NotFound();\n        edge = edges[edgeId_];\n        edge.acknowledged = acknowledged_;\n\n        if (acknowledged_) {\n            emit EdgeAcknowledged(edge, msg.sender, data_);\n        } else {\n            emit EdgeUnacknowledged(edge, msg.sender, data_);\n        }\n    }\n\n    /// @notice Allows the admin to upgrade the contract.\n    /// @dev This function overrides the {UUPSUpgradeable} implementation to restrict upgrade rights to the graph owner.\n    function _authorizeUpgrade(address) internal view override onlyOwnerOrRoles(ADMIN_ROLE) {\n        // The modifier handles the authorization.\n    }\n\n    /// @notice Returns the domain name and version for EIP-712.\n    function _domainNameAndVersion()\n        internal\n        pure\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"TitlesGraph\";\n        version = \"1\";\n    }\n\n    /// @notice Checks if the given address is the creator of a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the creator of the node, false otherwise.\n    function _isCreator(Node memory node, address guy) internal pure returns (bool) {\n        return node.creator.target == guy;\n    }\n\n    /// @notice Checks if the given address is the on-chain entity represented by a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the entity of the node, false otherwise.\n    function _isEntity(Node memory node, address guy) internal pure returns (bool) {\n        return node.entity.target == guy;\n    }\n\n    /// @notice Checks if the given address is either the creator or on-chain entity represented by a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the creator or entity of the node, false otherwise.\n    function _isCreatorOrEntity(Node memory node, address guy) internal pure returns (bool) {\n        return _isCreator(node, guy) || _isEntity(node, guy);\n    }\n}"
    }
  ]
}