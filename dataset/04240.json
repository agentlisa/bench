{
  "Title": "[M04] Lack of input validation",
  "Content": "The [`upgradeContract` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/registry/Registry.sol#L80) in the `Registry` contract does not check if the `_newAddress` is the zero address. If passed the zero address, the function will perform the same functionality as the [`removeContract` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/registry/Registry.sol#L61) but emit a `ContractUpgraded` event.\n\n\nThe [`setServiceVersion` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L180) in the `ServiceTypeManager` contract does not check if the inputted `_serviceType` type exists, allowing callers to add versions to a nonexistent service type.\n\n\nThe [`updateServiceType` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L123) in the `ServiceTypeManager` contract does not check if the new `_serviceTypeMax` is zero or not (which would make the `serviceTypeIsValid` function always return `false`, even for valid service types), or if `_serviceTypeMax < _serviceTypeMin` (which would break endpoint registration and deregistration).\n\n\nThe [`setGovernanceAddress` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L57) in the `ServiceTypeManager` contract does not check if the new `_governanceAddress` corresponds to a real governance address (for example, by calling an `isGovernanceAddress` function on the `_governanceAddress` contract). If the `_governanceAddress` is set to an incorrect address, control over the contracts may be permanently lost.\n\n\nThe [`addServiceType` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L71) in the `ServiceTypeManager` contract does not enforce that `_serviceTypeMax > 0`. This means it is possible to add the same service type to the `validServiceTypes` array multiple times.\n\n\nThe [`setVotingPeriod` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/Governance.sol#L457) in the `Governance` contract does not check if the `_votingPeriod` is zero. If it is, then it would not be possible to vote on any future proposal.\n\n\nConsider adding input checks to each of these functions to reduce possible errors.\n\n\n***Update:** Fixed in [pull request #569](https://github.com/AudiusProject/audius-protocol/pull/569). Checks were added for each of the reported occurrences. For the one found in the `addServiceType` function, the `ServiceTypeManager` contract does not explicitly enforce that `_serviceTypeMax` has to be bigger than zero, nevertheless, it needs to be bigger than the `_serviceTypeMin` variable, which cannot be inferior than zero.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "eth-contracts/contracts/registry/Registry.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\n\nimport \"../InitializableV2.sol\";\n\n\n/**\n* @title Central hub for Audius protocol. It stores all contract addresses to facilitate\n*   external access and enable version management.\n*/\ncontract Registry is InitializableV2, Ownable {\n    using SafeMath for uint;\n\n    /**\n     * @dev addressStorage mapping allows efficient lookup of current contract version\n     *      addressStorageHistory maintains record of all contract versions\n     */\n    mapping(bytes32 => address) private addressStorage;\n    mapping(bytes32 => address[]) private addressStorageHistory;\n\n    event ContractAdded(bytes32 _name, address _address);\n    event ContractRemoved(bytes32 _name, address _address);\n    event ContractUpgraded(bytes32 _name, address _oldAddress, address _newAddress);\n\n    function initialize() public initializer {\n        /// @notice Ownable.initialize(address _sender) sets contract owner to _sender.\n        Ownable.initialize(msg.sender);\n        InitializableV2.initialize();\n    }\n\n    // ========================================= Setters =========================================\n\n    /**\n     * @notice addContract registers contract name to address mapping under given registry key\n     * @param _name - registry key that will be used for lookups\n     * @param _address - address of contract\n     */\n    function addContract(bytes32 _name, address _address) external onlyOwner {\n        _requireIsInitialized();\n\n        require(\n            addressStorage[_name] == address(0x00),\n            \"Registry::addContract: Contract already registered with given name.\"\n        );\n        require(\n            _address != address(0x00),\n            \"Registry::addContract: Cannot register zero address.\"\n        );\n\n        setAddress(_name, _address);\n\n        emit ContractAdded(_name, _address);\n    }\n\n    /**\n     * @notice removes contract address registered under given registry key\n     * @param _name - registry key for lookup\n     */\n    function removeContract(bytes32 _name) external onlyOwner {\n        _requireIsInitialized();\n\n        address contractAddress = addressStorage[_name];\n        require(\n            contractAddress != address(0x00),\n            \"Registry::removeContract: Cannot remove - no contract registered with given _name.\"\n        );\n\n        setAddress(_name, address(0x00));\n\n        emit ContractRemoved(_name, contractAddress);\n    }\n\n    /**\n     * @notice replaces contract address registered under given key with provided address\n     * @param _name - registry key for lookup\n     * @param _newAddress - new contract address to register under given key\n     */\n    function upgradeContract(bytes32 _name, address _newAddress) external onlyOwner {\n        _requireIsInitialized();\n\n        address oldAddress = addressStorage[_name];\n        require(\n            oldAddress != address(0x00),\n            \"Registry::upgradeContract: Cannot upgrade - no contract registered with given _name.\"\n        );\n\n        setAddress(_name, _newAddress);\n\n        emit ContractUpgraded(_name, oldAddress, _newAddress);\n    }\n\n    // ========================================= Getters =========================================\n\n    /**\n     * @notice returns contract address registered under given registry key\n     * @param _name - registry key for lookup\n     * @return contractAddr - address of contract registered under given registry key\n     */\n    function getContract(bytes32 _name) external view returns (address contractAddr) {\n        return addressStorage[_name];\n    }\n\n    /// @notice overloaded getContract to return explicit version of contract\n    function getContract(bytes32 _name, uint _version) external view\n    returns (address contractAddr)\n    {\n        // array length for key implies version number\n        require(\n            _version <= addressStorageHistory[_name].length,\n            \"Registry::getContract: Index out of range _version.\"\n        );\n        return addressStorageHistory[_name][_version.sub(1)];\n    }\n\n    /**\n     * @notice Returns the number of versions for a contract key\n     * @param _name - registry key for lookup\n     * @return number of contract versions\n     */\n    function getContractVersionCount(bytes32 _name) external view returns (uint) {\n        return addressStorageHistory[_name].length;\n    }\n\n    // ========================================= Private functions =========================================\n\n    /**\n     * @param _key the key for the contract address\n     * @param _value the contract address\n     */\n    function setAddress(bytes32 _key, address _value) private {\n        // main map for cheap lookup\n        addressStorage[_key] = _value;\n        // keep track of contract address history\n        addressStorageHistory[_key].push(_value);\n    }\n\n}"
    },
    {
      "filename": "eth-contracts/contracts/ServiceTypeManager.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./InitializableV2.sol\";\n\n\ncontract ServiceTypeManager is InitializableV2 {\n    address governanceAddress;\n\n    /**\n     * @dev - mapping of serviceType - serviceTypeVersion\n     * Example - \"discovery-provider\" - [\"0.0.1\", \"0.0.2\", ..., \"currentVersion\"]\n     */\n    mapping(bytes32 => bytes32[]) public serviceTypeVersions;\n\n    /**\n     * @dev - mapping of serviceType - < serviceTypeVersion, isValid >\n     * Example - \"discovery-provider\" - <\"0.0.1\", true>\n     */\n    mapping(bytes32 => mapping(bytes32 => bool)) public serviceTypeVersionInfo;\n\n    /// @dev List of valid service types\n    bytes32[] private validServiceTypes;\n\n    /// @dev Struct representing service type stake requirements\n    struct ServiceTypeStakeRequirements {\n        uint minStake;\n        uint maxStake;\n    }\n\n    /// @dev mapping of service type to registered requirements\n    mapping(bytes32 => ServiceTypeStakeRequirements) serviceTypeStakeRequirements;\n\n    event SetServiceVersion(bytes32 _serviceType, bytes32 _serviceVersion);\n    event Test(string msg, bool value);\n    event TestAddr(string msg, address addr);\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _governanceAddress - Governance proxy address\n     */\n    function initialize(address _governanceAddress) public initializer\n    {\n        governanceAddress = _governanceAddress;\n        InitializableV2.initialize();\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only governance\");\n        governanceAddress = _governanceAddress;\n    }\n\n    // ========================================= Service Type Logic =========================================\n\n    /// @notice Add a new service type\n    /**\n     * @notice Add a new service type\n     * @param _serviceType - type of service to add\n     * @param _serviceTypeMin - minimum stake for service type\n     * @param _serviceTypeMax - maximum stake for service type\n     */\n    function addServiceType(\n        bytes32 _serviceType,\n        uint _serviceTypeMin,\n        uint _serviceTypeMax\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        require(!this.serviceTypeIsValid(_serviceType), \"Already known service type\");\n\n        validServiceTypes.push(_serviceType);\n        serviceTypeStakeRequirements[_serviceType] = ServiceTypeStakeRequirements({\n            minStake: _serviceTypeMin,\n            maxStake: _serviceTypeMax\n        });\n    }\n\n    /**\n     * @notice Remove an existing service type\n     * @param _serviceType - name of service type to remove\n     */\n    function removeServiceType(bytes32 _serviceType) external {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n\n        uint serviceIndex = 0;\n        bool foundService = false;\n        for (uint i = 0; i < validServiceTypes.length; i ++) {\n            if (validServiceTypes[i] == _serviceType) {\n                serviceIndex = i;\n                foundService = true;\n                break;\n            }\n        }\n        require(foundService == true, \"Invalid service type, not found\");\n        // Overwrite service index\n        uint lastIndex = validServiceTypes.length - 1;\n        validServiceTypes[serviceIndex] = validServiceTypes[lastIndex];\n        validServiceTypes.length--;\n        // Overwrite values\n        serviceTypeStakeRequirements[_serviceType].minStake = 0;\n        serviceTypeStakeRequirements[_serviceType].maxStake = 0;\n    }\n\n    /**\n     * @notice Update a service type\n     * @param _serviceType - type of service\n     * @param _serviceTypeMin - minimum stake for service type\n     * @param _serviceTypeMax - maximum stake for service type\n     */\n    function updateServiceType(\n        bytes32 _serviceType,\n        uint _serviceTypeMin,\n        uint _serviceTypeMax\n    ) external\n    {\n        _requireIsInitialized();\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n\n        require(this.serviceTypeIsValid(_serviceType), \"Invalid service type\");\n\n        serviceTypeStakeRequirements[_serviceType].minStake = _serviceTypeMin;\n        serviceTypeStakeRequirements[_serviceType].maxStake = _serviceTypeMax;\n    }\n\n    /**\n     * @notice Get min and max stake for a given service type\n     * @param _serviceType - type of service\n     * @return min and max stake for type\n     */\n    function getServiceTypeStakeInfo(bytes32 _serviceType)\n    external view returns (uint min, uint max)\n    {\n        return (\n            serviceTypeStakeRequirements[_serviceType].minStake,\n            serviceTypeStakeRequirements[_serviceType].maxStake\n        );\n    }\n\n    /**\n     * @notice Get list of valid service types\n     */\n    function getValidServiceTypes()\n    external view returns (bytes32[] memory types)\n    {\n        return validServiceTypes;\n    }\n\n    /**\n     * @notice Return indicating whether this is a valid service type\n     */\n    function serviceTypeIsValid(bytes32 _serviceType)\n    external view returns (bool isValid)\n    {\n        return serviceTypeStakeRequirements[_serviceType].maxStake > 0;\n    }\n\n    // ========================================= Service Version Logic =========================================\n\n    /**\n     * @notice Add new version for a serviceType\n     * @param _serviceType - type of service\n     * @param _serviceVersion - new version of service to add\n     */\n    function setServiceVersion(\n        bytes32 _serviceType,\n        bytes32 _serviceVersion\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n\n        require(\n            serviceTypeVersionInfo[_serviceType][_serviceVersion] == false,\n            \"Already registered\"\n        );\n\n         // Update array of known types\n        serviceTypeVersions[_serviceType].push(_serviceVersion);\n\n        // Update status for this specific service version\n        serviceTypeVersionInfo[_serviceType][_serviceVersion] = true;\n\n        emit SetServiceVersion(_serviceType, _serviceVersion);\n    }\n\n    /**\n     * @notice Get a version for a service type given it's index\n     * @param _serviceType - type of service\n     * @param _versionIndex - index in list of service versions\n     */\n    function getVersion(bytes32 _serviceType, uint _versionIndex)\n    external view returns (bytes32 version)\n    {\n        require(\n            serviceTypeVersions[_serviceType].length > _versionIndex,\n            \"No registered version of serviceType\"\n        );\n        return (serviceTypeVersions[_serviceType][_versionIndex]);\n    }\n\n    /**\n     * @notice Get curent version for a service type\n     * @param _serviceType - type of service\n     * @return Returns current version of service\n     */\n    function getCurrentVersion(bytes32 _serviceType)\n    external view returns (bytes32 currentVersion)\n    {\n        require(\n            serviceTypeVersions[_serviceType].length >= 1,\n            \"No registered version of serviceType\"\n        );\n        uint latestVersionIndex = serviceTypeVersions[_serviceType].length - 1;\n        return (serviceTypeVersions[_serviceType][latestVersionIndex]);\n    }\n\n    /**\n     * @notice Get total number of versions for a service type\n     * @param _serviceType - type of service\n     */\n    function getNumberOfVersions(bytes32 _serviceType)\n    external view returns (uint)\n    {\n        return serviceTypeVersions[_serviceType].length;\n    }\n\n    /**\n     * @notice Return boolean indicating whether given version is valid for given type\n     * @param _serviceType - type of service\n     * @param _serviceVersion - version of service to check\n     */\n    function serviceVersionIsValid(bytes32 _serviceType, bytes32 _serviceVersion)\n    external view returns (bool isValidServiceVersion)\n    {\n        return serviceTypeVersionInfo[_serviceType][_serviceVersion];\n    }\n}"
    },
    {
      "filename": "eth-contracts/contracts/ServiceTypeManager.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./InitializableV2.sol\";\n\n\ncontract ServiceTypeManager is InitializableV2 {\n    address governanceAddress;\n\n    /**\n     * @dev - mapping of serviceType - serviceTypeVersion\n     * Example - \"discovery-provider\" - [\"0.0.1\", \"0.0.2\", ..., \"currentVersion\"]\n     */\n    mapping(bytes32 => bytes32[]) public serviceTypeVersions;\n\n    /**\n     * @dev - mapping of serviceType - < serviceTypeVersion, isValid >\n     * Example - \"discovery-provider\" - <\"0.0.1\", true>\n     */\n    mapping(bytes32 => mapping(bytes32 => bool)) public serviceTypeVersionInfo;\n\n    /// @dev List of valid service types\n    bytes32[] private validServiceTypes;\n\n    /// @dev Struct representing service type stake requirements\n    struct ServiceTypeStakeRequirements {\n        uint minStake;\n        uint maxStake;\n    }\n\n    /// @dev mapping of service type to registered requirements\n    mapping(bytes32 => ServiceTypeStakeRequirements) serviceTypeStakeRequirements;\n\n    event SetServiceVersion(bytes32 _serviceType, bytes32 _serviceVersion);\n    event Test(string msg, bool value);\n    event TestAddr(string msg, address addr);\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _governanceAddress - Governance proxy address\n     */\n    function initialize(address _governanceAddress) public initializer\n    {\n        governanceAddress = _governanceAddress;\n        InitializableV2.initialize();\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only governance\");\n        governanceAddress = _governanceAddress;\n    }\n\n    // ========================================= Service Type Logic =========================================\n\n    /// @notice Add a new service type\n    /**\n     * @notice Add a new service type\n     * @param _serviceType - type of service to add\n     * @param _serviceTypeMin - minimum stake for service type\n     * @param _serviceTypeMax - maximum stake for service type\n     */\n    function addServiceType(\n        bytes32 _serviceType,\n        uint _serviceTypeMin,\n        uint _serviceTypeMax\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        require(!this.serviceTypeIsValid(_serviceType), \"Already known service type\");\n\n        validServiceTypes.push(_serviceType);\n        serviceTypeStakeRequirements[_serviceType] = ServiceTypeStakeRequirements({\n            minStake: _serviceTypeMin,\n            maxStake: _serviceTypeMax\n        });\n    }\n\n    /**\n     * @notice Remove an existing service type\n     * @param _serviceType - name of service type to remove\n     */\n    function removeServiceType(bytes32 _serviceType) external {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n\n        uint serviceIndex = 0;\n        bool foundService = false;\n        for (uint i = 0; i < validServiceTypes.length; i ++) {\n            if (validServiceTypes[i] == _serviceType) {\n                serviceIndex = i;\n                foundService = true;\n                break;\n            }\n        }\n        require(foundService == true, \"Invalid service type, not found\");\n        // Overwrite service index\n        uint lastIndex = validServiceTypes.length - 1;\n        validServiceTypes[serviceIndex] = validServiceTypes[lastIndex];\n        validServiceTypes.length--;\n        // Overwrite values\n        serviceTypeStakeRequirements[_serviceType].minStake = 0;\n        serviceTypeStakeRequirements[_serviceType].maxStake = 0;\n    }\n\n    /**\n     * @notice Update a service type\n     * @param _serviceType - type of service\n     * @param _serviceTypeMin - minimum stake for service type\n     * @param _serviceTypeMax - maximum stake for service type\n     */\n    function updateServiceType(\n        bytes32 _serviceType,\n        uint _serviceTypeMin,\n        uint _serviceTypeMax\n    ) external\n    {\n        _requireIsInitialized();\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n\n        require(this.serviceTypeIsValid(_serviceType), \"Invalid service type\");\n\n        serviceTypeStakeRequirements[_serviceType].minStake = _serviceTypeMin;\n        serviceTypeStakeRequirements[_serviceType].maxStake = _serviceTypeMax;\n    }\n\n    /**\n     * @notice Get min and max stake for a given service type\n     * @param _serviceType - type of service\n     * @return min and max stake for type\n     */\n    function getServiceTypeStakeInfo(bytes32 _serviceType)\n    external view returns (uint min, uint max)\n    {\n        return (\n            serviceTypeStakeRequirements[_serviceType].minStake,\n            serviceTypeStakeRequirements[_serviceType].maxStake\n        );\n    }\n\n    /**\n     * @notice Get list of valid service types\n     */\n    function getValidServiceTypes()\n    external view returns (bytes32[] memory types)\n    {\n        return validServiceTypes;\n    }\n\n    /**\n     * @notice Return indicating whether this is a valid service type\n     */\n    function serviceTypeIsValid(bytes32 _serviceType)\n    external view returns (bool isValid)\n    {\n        return serviceTypeStakeRequirements[_serviceType].maxStake > 0;\n    }\n\n    // ========================================= Service Version Logic =========================================\n\n    /**\n     * @notice Add new version for a serviceType\n     * @param _serviceType - type of service\n     * @param _serviceVersion - new version of service to add\n     */\n    function setServiceVersion(\n        bytes32 _serviceType,\n        bytes32 _serviceVersion\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n\n        require(\n            serviceTypeVersionInfo[_serviceType][_serviceVersion] == false,\n            \"Already registered\"\n        );\n\n         // Update array of known types\n        serviceTypeVersions[_serviceType].push(_serviceVersion);\n\n        // Update status for this specific service version\n        serviceTypeVersionInfo[_serviceType][_serviceVersion] = true;\n\n        emit SetServiceVersion(_serviceType, _serviceVersion);\n    }\n\n    /**\n     * @notice Get a version for a service type given it's index\n     * @param _serviceType - type of service\n     * @param _versionIndex - index in list of service versions\n     */\n    function getVersion(bytes32 _serviceType, uint _versionIndex)\n    external view returns (bytes32 version)\n    {\n        require(\n            serviceTypeVersions[_serviceType].length > _versionIndex,\n            \"No registered version of serviceType\"\n        );\n        return (serviceTypeVersions[_serviceType][_versionIndex]);\n    }\n\n    /**\n     * @notice Get curent version for a service type\n     * @param _serviceType - type of service\n     * @return Returns current version of service\n     */\n    function getCurrentVersion(bytes32 _serviceType)\n    external view returns (bytes32 currentVersion)\n    {\n        require(\n            serviceTypeVersions[_serviceType].length >= 1,\n            \"No registered version of serviceType\"\n        );\n        uint latestVersionIndex = serviceTypeVersions[_serviceType].length - 1;\n        return (serviceTypeVersions[_serviceType][latestVersionIndex]);\n    }\n\n    /**\n     * @notice Get total number of versions for a service type\n     * @param _serviceType - type of service\n     */\n    function getNumberOfVersions(bytes32 _serviceType)\n    external view returns (uint)\n    {\n        return serviceTypeVersions[_serviceType].length;\n    }\n\n    /**\n     * @notice Return boolean indicating whether given version is valid for given type\n     * @param _serviceType - type of service\n     * @param _serviceVersion - version of service to check\n     */\n    function serviceVersionIsValid(bytes32 _serviceType, bytes32 _serviceVersion)\n    external view returns (bool isValidServiceVersion)\n    {\n        return serviceTypeVersionInfo[_serviceType][_serviceVersion];\n    }\n}"
    },
    {
      "filename": "eth-contracts/contracts/ServiceTypeManager.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./InitializableV2.sol\";\n\n\ncontract ServiceTypeManager is InitializableV2 {\n    address governanceAddress;\n\n    /**\n     * @dev - mapping of serviceType - serviceTypeVersion\n     * Example - \"discovery-provider\" - [\"0.0.1\", \"0.0.2\", ..., \"currentVersion\"]\n     */\n    mapping(bytes32 => bytes32[]) public serviceTypeVersions;\n\n    /**\n     * @dev - mapping of serviceType - < serviceTypeVersion, isValid >\n     * Example - \"discovery-provider\" - <\"0.0.1\", true>\n     */\n    mapping(bytes32 => mapping(bytes32 => bool)) public serviceTypeVersionInfo;\n\n    /// @dev List of valid service types\n    bytes32[] private validServiceTypes;\n\n    /// @dev Struct representing service type stake requirements\n    struct ServiceTypeStakeRequirements {\n        uint minStake;\n        uint maxStake;\n    }\n\n    /// @dev mapping of service type to registered requirements\n    mapping(bytes32 => ServiceTypeStakeRequirements) serviceTypeStakeRequirements;\n\n    event SetServiceVersion(bytes32 _serviceType, bytes32 _serviceVersion);\n    event Test(string msg, bool value);\n    event TestAddr(string msg, address addr);\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _governanceAddress - Governance proxy address\n     */\n    function initialize(address _governanceAddress) public initializer\n    {\n        governanceAddress = _governanceAddress;\n        InitializableV2.initialize();\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only governance\");\n        governanceAddress = _governanceAddress;\n    }\n\n    // ========================================= Service Type Logic =========================================\n\n    /// @notice Add a new service type\n    /**\n     * @notice Add a new service type\n     * @param _serviceType - type of service to add\n     * @param _serviceTypeMin - minimum stake for service type\n     * @param _serviceTypeMax - maximum stake for service type\n     */\n    function addServiceType(\n        bytes32 _serviceType,\n        uint _serviceTypeMin,\n        uint _serviceTypeMax\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        require(!this.serviceTypeIsValid(_serviceType), \"Already known service type\");\n\n        validServiceTypes.push(_serviceType);\n        serviceTypeStakeRequirements[_serviceType] = ServiceTypeStakeRequirements({\n            minStake: _serviceTypeMin,\n            maxStake: _serviceTypeMax\n        });\n    }\n\n    /**\n     * @notice Remove an existing service type\n     * @param _serviceType - name of service type to remove\n     */\n    function removeServiceType(bytes32 _serviceType) external {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n\n        uint serviceIndex = 0;\n        bool foundService = false;\n        for (uint i = 0; i < validServiceTypes.length; i ++) {\n            if (validServiceTypes[i] == _serviceType) {\n                serviceIndex = i;\n                foundService = true;\n                break;\n            }\n        }\n        require(foundService == true, \"Invalid service type, not found\");\n        // Overwrite service index\n        uint lastIndex = validServiceTypes.length - 1;\n        validServiceTypes[serviceIndex] = validServiceTypes[lastIndex];\n        validServiceTypes.length--;\n        // Overwrite values\n        serviceTypeStakeRequirements[_serviceType].minStake = 0;\n        serviceTypeStakeRequirements[_serviceType].maxStake = 0;\n    }\n\n    /**\n     * @notice Update a service type\n     * @param _serviceType - type of service\n     * @param _serviceTypeMin - minimum stake for service type\n     * @param _serviceTypeMax - maximum stake for service type\n     */\n    function updateServiceType(\n        bytes32 _serviceType,\n        uint _serviceTypeMin,\n        uint _serviceTypeMax\n    ) external\n    {\n        _requireIsInitialized();\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n\n        require(this.serviceTypeIsValid(_serviceType), \"Invalid service type\");\n\n        serviceTypeStakeRequirements[_serviceType].minStake = _serviceTypeMin;\n        serviceTypeStakeRequirements[_serviceType].maxStake = _serviceTypeMax;\n    }\n\n    /**\n     * @notice Get min and max stake for a given service type\n     * @param _serviceType - type of service\n     * @return min and max stake for type\n     */\n    function getServiceTypeStakeInfo(bytes32 _serviceType)\n    external view returns (uint min, uint max)\n    {\n        return (\n            serviceTypeStakeRequirements[_serviceType].minStake,\n            serviceTypeStakeRequirements[_serviceType].maxStake\n        );\n    }\n\n    /**\n     * @notice Get list of valid service types\n     */\n    function getValidServiceTypes()\n    external view returns (bytes32[] memory types)\n    {\n        return validServiceTypes;\n    }\n\n    /**\n     * @notice Return indicating whether this is a valid service type\n     */\n    function serviceTypeIsValid(bytes32 _serviceType)\n    external view returns (bool isValid)\n    {\n        return serviceTypeStakeRequirements[_serviceType].maxStake > 0;\n    }\n\n    // ========================================= Service Version Logic =========================================\n\n    /**\n     * @notice Add new version for a serviceType\n     * @param _serviceType - type of service\n     * @param _serviceVersion - new version of service to add\n     */\n    function setServiceVersion(\n        bytes32 _serviceType,\n        bytes32 _serviceVersion\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n\n        require(\n            serviceTypeVersionInfo[_serviceType][_serviceVersion] == false,\n            \"Already registered\"\n        );\n\n         // Update array of known types\n        serviceTypeVersions[_serviceType].push(_serviceVersion);\n\n        // Update status for this specific service version\n        serviceTypeVersionInfo[_serviceType][_serviceVersion] = true;\n\n        emit SetServiceVersion(_serviceType, _serviceVersion);\n    }\n\n    /**\n     * @notice Get a version for a service type given it's index\n     * @param _serviceType - type of service\n     * @param _versionIndex - index in list of service versions\n     */\n    function getVersion(bytes32 _serviceType, uint _versionIndex)\n    external view returns (bytes32 version)\n    {\n        require(\n            serviceTypeVersions[_serviceType].length > _versionIndex,\n            \"No registered version of serviceType\"\n        );\n        return (serviceTypeVersions[_serviceType][_versionIndex]);\n    }\n\n    /**\n     * @notice Get curent version for a service type\n     * @param _serviceType - type of service\n     * @return Returns current version of service\n     */\n    function getCurrentVersion(bytes32 _serviceType)\n    external view returns (bytes32 currentVersion)\n    {\n        require(\n            serviceTypeVersions[_serviceType].length >= 1,\n            \"No registered version of serviceType\"\n        );\n        uint latestVersionIndex = serviceTypeVersions[_serviceType].length - 1;\n        return (serviceTypeVersions[_serviceType][latestVersionIndex]);\n    }\n\n    /**\n     * @notice Get total number of versions for a service type\n     * @param _serviceType - type of service\n     */\n    function getNumberOfVersions(bytes32 _serviceType)\n    external view returns (uint)\n    {\n        return serviceTypeVersions[_serviceType].length;\n    }\n\n    /**\n     * @notice Return boolean indicating whether given version is valid for given type\n     * @param _serviceType - type of service\n     * @param _serviceVersion - version of service to check\n     */\n    function serviceVersionIsValid(bytes32 _serviceType, bytes32 _serviceVersion)\n    external view returns (bool isValidServiceVersion)\n    {\n        return serviceTypeVersionInfo[_serviceType][_serviceVersion];\n    }\n}"
    },
    {
      "filename": "eth-contracts/contracts/ServiceTypeManager.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./InitializableV2.sol\";\n\n\ncontract ServiceTypeManager is InitializableV2 {\n    address governanceAddress;\n\n    /**\n     * @dev - mapping of serviceType - serviceTypeVersion\n     * Example - \"discovery-provider\" - [\"0.0.1\", \"0.0.2\", ..., \"currentVersion\"]\n     */\n    mapping(bytes32 => bytes32[]) public serviceTypeVersions;\n\n    /**\n     * @dev - mapping of serviceType - < serviceTypeVersion, isValid >\n     * Example - \"discovery-provider\" - <\"0.0.1\", true>\n     */\n    mapping(bytes32 => mapping(bytes32 => bool)) public serviceTypeVersionInfo;\n\n    /// @dev List of valid service types\n    bytes32[] private validServiceTypes;\n\n    /// @dev Struct representing service type stake requirements\n    struct ServiceTypeStakeRequirements {\n        uint minStake;\n        uint maxStake;\n    }\n\n    /// @dev mapping of service type to registered requirements\n    mapping(bytes32 => ServiceTypeStakeRequirements) serviceTypeStakeRequirements;\n\n    event SetServiceVersion(bytes32 _serviceType, bytes32 _serviceVersion);\n    event Test(string msg, bool value);\n    event TestAddr(string msg, address addr);\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _governanceAddress - Governance proxy address\n     */\n    function initialize(address _governanceAddress) public initializer\n    {\n        governanceAddress = _governanceAddress;\n        InitializableV2.initialize();\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only governance\");\n        governanceAddress = _governanceAddress;\n    }\n\n    // ========================================= Service Type Logic =========================================\n\n    /// @notice Add a new service type\n    /**\n     * @notice Add a new service type\n     * @param _serviceType - type of service to add\n     * @param _serviceTypeMi"
    }
  ]
}