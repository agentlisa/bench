{
  "Title": "No explicit checks for `mint` and `swap` calls on uninitialized Pool",
  "Content": "##### Description\nhttps://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraPool.sol#L66  https://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraPool.sol#L210 https://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraPool.sol#L253 The `swap` and `mint` functions can be invoked on an uninitialized pool, leading to a potential `revert` midway through execution due to invariant checks. This might introduce vulnerabilities if there are modifications to the implementation in subsequent updates.\n##### Recommendation\nWe recommend adding an explicit precondition to preempt the following errors: `require(globalState.price != 0)`, to the`swap`, `swapWithPaymentInAdvance`, and `mint` functions.\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/contracts/AlgebraPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\npragma abicoder v1;\n\nimport './base/AlgebraPoolBase.sol';\nimport './base/ReentrancyGuard.sol';\nimport './base/Positions.sol';\nimport './base/SwapCalculation.sol';\nimport './base/ReservesManager.sol';\nimport './base/TickStructure.sol';\n\nimport './libraries/FullMath.sol';\nimport './libraries/Constants.sol';\nimport './libraries/SafeCast.sol';\nimport './libraries/TickMath.sol';\nimport './libraries/LiquidityMath.sol';\nimport './libraries/Plugins.sol';\n\nimport './interfaces/IAlgebraFactory.sol';\n\n/// @title Algebra concentrated liquidity pool\n/// @notice This contract is responsible for liquidity positions, swaps and flashloans\n/// @dev Version: Algebra Integral\ncontract AlgebraPool is AlgebraPoolBase, TickStructure, ReentrancyGuard, Positions, SwapCalculation, ReservesManager {\n  using SafeCast for uint256;\n  using SafeCast for uint128;\n  using Plugins for uint8;\n  using Plugins for bytes4;\n\n  /// @inheritdoc IAlgebraPoolActions\n  function initialize(uint160 initialPrice) external override {\n    int24 tick = TickMath.getTickAtSqrtRatio(initialPrice); // getTickAtSqrtRatio checks validity of initialPrice inside\n    if (globalState.price != 0) revert alreadyInitialized(); // after initialization, the price can never become zero\n    globalState.price = initialPrice;\n\n    if (plugin != address(0)) {\n      IAlgebraPlugin(plugin).beforeInitialize(msg.sender, initialPrice).shouldReturn(IAlgebraPlugin.beforeInitialize.selector);\n    }\n\n    (uint16 _communityFee, int24 _tickSpacing, uint16 _fee) = _getDefaultConfiguration();\n    tickSpacing = _tickSpacing;\n\n    uint8 pluginConfig = globalState.pluginConfig;\n    globalState.tick = tick;\n    globalState.fee = _fee;\n    globalState.communityFee = _communityFee;\n\n    emit Initialize(initialPrice, tick);\n    emit TickSpacing(_tickSpacing);\n    emit CommunityFee(_communityFee);\n\n    if (pluginConfig.hasFlag(Plugins.AFTER_INIT_FLAG)) {\n      IAlgebraPlugin(plugin).afterInitialize(msg.sender, initialPrice, tick).shouldReturn(IAlgebraPlugin.afterInitialize.selector);\n    }\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function mint(\n    address leftoversRecipient,\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 liquidityDesired,\n    bytes calldata data\n  ) external override onlyValidTicks(bottomTick, topTick) returns (uint256 amount0, uint256 amount1, uint128 liquidityActual) {\n    if (liquidityDesired == 0) revert zeroLiquidityDesired();\n\n    _beforeModifyPos(recipient, bottomTick, topTick, liquidityDesired.toInt128(), data);\n    _lock();\n\n    unchecked {\n      int24 _tickSpacing = tickSpacing;\n      if (bottomTick % _tickSpacing | topTick % _tickSpacing != 0) revert tickIsNotSpaced();\n    }\n\n    (amount0, amount1, ) = LiquidityMath.getAmountsForLiquidity(\n      bottomTick,\n      topTick,\n      liquidityDesired.toInt128(),\n      globalState.tick,\n      globalState.price\n    );\n\n    (uint256 receivedAmount0, uint256 receivedAmount1) = _updateReserves();\n    _mintCallback(amount0, amount1, data); // IAlgebraMintCallback.algebraMintCallback to msg.sender\n\n    receivedAmount0 = amount0 == 0 ? 0 : _balanceToken0() - receivedAmount0;\n    receivedAmount1 = amount1 == 0 ? 0 : _balanceToken1() - receivedAmount1;\n\n    if (receivedAmount0 < amount0) {\n      liquidityActual = uint128(FullMath.mulDiv(uint256(liquidityDesired), receivedAmount0, amount0));\n    } else {\n      liquidityActual = liquidityDesired;\n    }\n    if (receivedAmount1 < amount1) {\n      uint128 liquidityForRA1 = uint128(FullMath.mulDiv(uint256(liquidityDesired), receivedAmount1, amount1));\n      if (liquidityForRA1 < liquidityActual) liquidityActual = liquidityForRA1;\n    }\n    if (liquidityActual == 0) revert zeroLiquidityActual();\n\n    // scope to prevent \"stack too deep\"\n    {\n      Position storage _position = getOrCreatePosition(recipient, bottomTick, topTick);\n      (amount0, amount1) = _updatePositionTicksAndFees(_position, bottomTick, topTick, liquidityActual.toInt128());\n    }\n\n    unchecked {\n      // return leftovers\n      if (amount0 > 0) {\n        if (receivedAmount0 > amount0) _transfer(token0, leftoversRecipient, receivedAmount0 - amount0);\n        else assert(receivedAmount0 == amount0); // must always be true\n      }\n      if (amount1 > 0) {\n        if (receivedAmount1 > amount1) _transfer(token1, leftoversRecipient, receivedAmount1 - amount1);\n        else assert(receivedAmount1 == amount1); // must always be true\n      }\n    }\n\n    _changeReserves(int256(amount0), int256(amount1), 0, 0);\n    emit Mint(msg.sender, recipient, bottomTick, topTick, liquidityActual, amount0, amount1);\n\n    _unlock();\n    _afterModifyPos(recipient, bottomTick, topTick, liquidityActual.toInt128(), amount0, amount1, data);\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function burn(\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount,\n    bytes calldata data\n  ) external override onlyValidTicks(bottomTick, topTick) returns (uint256 amount0, uint256 amount1) {\n    if (amount > uint128(type(int128).max)) revert arithmeticError();\n\n    int128 liquidityDelta = -int128(amount);\n\n    _beforeModifyPos(msg.sender, bottomTick, topTick, liquidityDelta, data);\n    _lock();\n\n    _updateReserves();\n    Position storage position = getOrCreatePosition(msg.sender, bottomTick, topTick);\n\n    (amount0, amount1) = _updatePositionTicksAndFees(position, bottomTick, topTick, liquidityDelta);\n\n    if (amount0 | amount1 != 0) {\n      (position.fees0, position.fees1) = (position.fees0 + uint128(amount0), position.fees1 + uint128(amount1));\n    }\n\n    if (amount | amount0 | amount1 != 0) emit Burn(msg.sender, bottomTick, topTick, amount, amount0, amount1);\n\n    _unlock();\n    _afterModifyPos(msg.sender, bottomTick, topTick, liquidityDelta, amount0, amount1, data);\n  }\n\n  function _beforeModifyPos(address owner, int24 bottomTick, int24 topTick, int128 liquidityDelta, bytes calldata data) internal {\n    if (globalState.pluginConfig.hasFlag(Plugins.BEFORE_POSITION_MODIFY_FLAG)) {\n      IAlgebraPlugin(plugin).beforeModifyPosition(msg.sender, owner, bottomTick, topTick, liquidityDelta, data).shouldReturn(\n        IAlgebraPlugin.beforeModifyPosition.selector\n      );\n    }\n  }\n\n  function _afterModifyPos(address owner, int24 bTick, int24 tTick, int128 deltaL, uint256 amount0, uint256 amount1, bytes calldata data) internal {\n    if (globalState.pluginConfig.hasFlag(Plugins.AFTER_POSITION_MODIFY_FLAG)) {\n      IAlgebraPlugin(plugin).afterModifyPosition(msg.sender, owner, bTick, tTick, deltaL, amount0, amount1, data).shouldReturn(\n        IAlgebraPlugin.afterModifyPosition.selector\n      );\n    }\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function collect(\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external override nonReentrant returns (uint128 amount0, uint128 amount1) {\n    // we don't check tick range validity, because if ticks are incorrect, the position will be empty\n    Position storage position = getOrCreatePosition(msg.sender, bottomTick, topTick);\n    (uint128 positionFees0, uint128 positionFees1) = (position.fees0, position.fees1);\n\n    if (amount0Requested > positionFees0) amount0Requested = positionFees0;\n    if (amount1Requested > positionFees1) amount1Requested = positionFees1;\n\n    if (amount0Requested | amount1Requested != 0) {\n      // use one if since fees0 and fees1 are tightly packed\n      (amount0, amount1) = (amount0Requested, amount1Requested);\n\n      unchecked {\n        // single SSTORE\n        (position.fees0, position.fees1) = (positionFees0 - amount0, positionFees1 - amount1);\n\n        if (amount0 > 0) _transfer(token0, recipient, amount0);\n        if (amount1 > 0) _transfer(token1, recipient, amount1);\n        _changeReserves(-int256(uint256(amount0)), -int256(uint256(amount1)), 0, 0);\n      }\n      emit Collect(msg.sender, recipient, bottomTick, topTick, amount0, amount1);\n    }\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function swap(\n    address recipient,\n    bool zeroToOne,\n    int256 amountRequired,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external override returns (int256 amount0, int256 amount1) {\n    _beforeSwap(recipient, zeroToOne, amountRequired, limitSqrtPrice, false, data);\n    _lock();\n\n    {\n      // scope to prevent \"stack too deep\"\n      uint160 currentPrice;\n      int24 currentTick;\n      uint128 currentLiquidity;\n      uint256 communityFee;\n      (amount0, amount1, currentPrice, currentTick, currentLiquidity, communityFee) = _calculateSwap(zeroToOne, amountRequired, limitSqrtPrice);\n      (uint256 balance0Before, uint256 balance1Before) = _updateReserves();\n      if (zeroToOne) {\n        unchecked {\n          if (amount1 < 0) _transfer(token1, recipient, uint256(-amount1)); // amount1 cannot be > 0\n        }\n        _swapCallback(amount0, amount1, data); // callback to get tokens from the msg.sender\n        if (balance0Before + uint256(amount0) > _balanceToken0()) revert insufficientInputAmount();\n        _changeReserves(amount0, amount1, communityFee, 0); // reflect reserve change and pay communityFee\n      } else {\n        unchecked {\n          if (amount0 < 0) _transfer(token0, recipient, uint256(-amount0)); // amount0 cannot be > 0\n        }\n        _swapCallback(amount0, amount1, data); // callback to get tokens from the msg.sender\n        if (balance1Before + uint256(amount1) > _balanceToken1()) revert insufficientInputAmount();\n        _changeReserves(amount0, amount1, 0, communityFee); // reflect reserve change and pay communityFee\n      }\n\n      emit Swap(msg.sender, recipient, amount0, amount1, currentPrice, currentLiquidity, currentTick);\n    }\n\n    _unlock();\n    _afterSwap(recipient, zeroToOne, amountRequired, limitSqrtPrice, amount0, amount1, data);\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function swapWithPaymentInAdvance(\n    address leftoversRecipient,\n    address recipient,\n    bool zeroToOne,\n    int256 amountToSell,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external override returns (int256 amount0, int256 amount1) {\n    if (amountToSell < 0) revert invalidAmountRequired(); // we support only exactInput here\n\n    _lock();\n    // firstly we are getting tokens from the original caller of the transaction\n    // since the pool can get less/more tokens then expected, _amountToSell_ can be changed\n    {\n      // scope to prevent \"stack too deep\"\n      int256 amountReceived;\n      if (zeroToOne) {\n        uint256 balanceBefore = _balanceToken0();\n        _swapCallback(amountToSell, 0, data); // callback to get tokens from the msg.sender\n        uint256 balanceAfter = _balanceToken0();\n        amountReceived = (balanceAfter - balanceBefore).toInt256();\n        _changeReserves(amountReceived, 0, 0, 0);\n      } else {\n        uint256 balanceBefore = _balanceToken1();\n        _swapCallback(0, amountToSell, data); // callback to get tokens from the msg.sender\n        uint256 balanceAfter = _balanceToken1();\n        amountReceived = (balanceAfter - balanceBefore).toInt256();\n        _changeReserves(0, amountReceived, 0, 0);\n      }\n      if (amountReceived != amountToSell) amountToSell = amountReceived;\n    }\n    if (amountToSell == 0) revert insufficientInputAmount();\n\n    _unlock();\n    _beforeSwap(recipient, zeroToOne, amountToSell, limitSqrtPrice, true, data);\n    _lock();\n\n    _updateReserves();\n\n    uint160 currentPrice;\n    int24 currentTick;\n    uint128 currentLiquidity;\n    uint256 communityFee;\n    (amount0, amount1, currentPrice, currentTick, currentLiquidity, communityFee) = _calculateSwap(zeroToOne, amountToSell, limitSqrtPrice);\n\n    unchecked {\n      // transfer to the recipient\n      if (zeroToOne) {\n        if (amount1 < 0) _transfer(token1, recipient, uint256(-amount1)); // amount1 cannot be > 0\n        uint256 leftover = uint256(amountToSell - amount0); // return the leftovers\n        if (leftover != 0) _transfer(token0, leftoversRecipient, leftover);\n        _changeReserves(-leftover.toInt256(), amount1, communityFee, 0); // reflect reserve change and pay communityFee\n      } else {\n        if (amount0 < 0) _transfer(token0, recipient, uint256(-amount0)); // amount0 cannot be > 0\n        uint256 leftover = uint256(amountToSell - amount1); // return the leftovers\n        if (leftover != 0) _transfer(token1, leftoversRecipient, leftover);\n        _changeReserves(amount0, -leftover.toInt256(), 0, communityFee); // reflect reserve change and pay communityFee\n      }\n    }\n\n    emit Swap(msg.sender, recipient, amount0, amount1, currentPrice, currentLiquidity, currentTick);\n\n    _unlock();\n    _afterSwap(recipient, zeroToOne, amountToSell, limitSqrtPrice, amount0, amount1, data);\n  }\n\n  function _beforeSwap(address recipient, bool zto, int256 amount, uint160 limitPrice, bool payInAdvance, bytes calldata data) internal {\n    if (globalState.pluginConfig.hasFlag(Plugins.BEFORE_SWAP_FLAG)) {\n      IAlgebraPlugin(plugin).beforeSwap(msg.sender, recipient, zto, amount, limitPrice, payInAdvance, data).shouldReturn(\n        IAlgebraPlugin.beforeSwap.selector\n      );\n    }\n  }\n\n  function _afterSwap(address recipient, bool zto, int256 amount, uint160 limitPrice, int256 amount0, int256 amount1, bytes calldata data) internal {\n    if (globalState.pluginConfig.hasFlag(Plugins.AFTER_SWAP_FLAG)) {\n      IAlgebraPlugin(plugin).afterSwap(msg.sender, recipient, zto, amount, limitPrice, amount0, amount1, data).shouldReturn(\n        IAlgebraPlugin.afterSwap.selector\n      );\n    }\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external override {\n    if (globalState.pluginConfig.hasFlag(Plugins.BEFORE_FLASH_FLAG)) {\n      IAlgebraPlugin(plugin).beforeFlash(msg.sender, recipient, amount0, amount1, data).shouldReturn(IAlgebraPlugin.beforeFlash.selector);\n    }\n    _lock();\n\n    uint256 paid0;\n    uint256 paid1;\n    {\n      (uint256 balance0Before, uint256 balance1Before) = _updateReserves();\n      uint256 fee0;\n      if (amount0 > 0) {\n        fee0 = FullMath.mulDivRoundingUp(amount0, Constants.FLASH_FEE, Constants.FEE_DENOMINATOR);\n        _transfer(token0, recipient, amount0);\n      }\n      uint256 fee1;\n      if (amount1 > 0) {\n        fee1 = FullMath.mulDivRoundingUp(amount1, Constants.FLASH_FEE, Constants.FEE_DENOMINATOR);\n        _transfer(token1, recipient, amount1);\n      }\n\n      _flashCallback(fee0, fee1, data); // IAlgebraFlashCallback.algebraFlashCallback to msg.sender\n\n      paid0 = _balanceToken0();\n      if (balance0Before + fee0 > paid0) revert flashInsufficientPaid0();\n      paid1 = _balanceToken1();\n      if (balance1Before + fee1 > paid1) revert flashInsufficientPaid1();\n\n      unchecked {\n        paid0 -= balance0Before;\n        paid1 -= balance1Before;\n      }\n\n      uint256 _communityFee = globalState.communityFee;\n      if (_communityFee > 0) {\n        uint256 communityFee0;\n        if (paid0 > 0) communityFee0 = FullMath.mulDiv(paid0, _communityFee, Constants.COMMUNITY_FEE_DENOMINATOR);\n        uint256 communityFee1;\n        if (paid1 > 0) communityFee1 = FullMath.mulDiv(paid1, _communityFee, Constants.COMMUNITY_FEE_DENOMINATOR);\n\n        _changeReserves(int256(communityFee0), int256(communityFee1), communityFee0, communityFee1);\n      }\n      emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n    }\n\n    _unlock();\n    if (globalState.pluginConfig.hasFlag(Plugins.AFTER_FLASH_FLAG)) {\n      IAlgebraPlugin(plugin).afterFlash(msg.sender, recipient, amount0, amount1, paid0, paid1, data).shouldReturn(IAlgebraPlugin.afterFlash.selector);\n    }\n  }\n\n  /// @dev using function to save bytecode\n  function _checkIfAdministrator() private view {\n    if (!IAlgebraFactory(factory).hasRoleOrOwner(Constants.POOLS_ADMINISTRATOR_ROLE, msg.sender)) revert notAllowed();\n  }\n\n  /// @inheritdoc IAlgebraPoolPermissionedActions\n  function setCommunityFee(uint16 newCommunityFee) external override nonReentrant {\n    _checkIfAdministrator();\n    if (newCommunityFee > Constants.MAX_COMMUNITY_FEE || newCommunityFee == globalState.communityFee) revert invalidNewCommunityFee();\n    globalState.communityFee = newCommunityFee;\n    emit CommunityFee(newCommunityFee);\n  }\n\n  /// @inheritdoc IAlgebraPoolPermissionedActions\n  function setTickSpacing(int24 newTickSpacing) external override nonReentrant {\n    _checkIfAdministrator();\n    if (newTickSpacing <= 0 || newTickSpacing > Constants.MAX_TICK_SPACING || tickSpacing == newTickSpacing) revert invalidNewTickSpacing();\n    tickSpacing = newTickSpacing;\n    emit TickSpacing(newTickSpacing);\n  }\n\n  /// @inheritdoc IAlgebraPoolPermissionedActions\n  function setPlugin(address newPluginAddress) external override nonReentrant {\n    _checkIfAdministrator();\n    plugin = newPluginAddress;\n    emit Plugin(newPluginAddress);\n  }\n\n  /// @inheritdoc IAlgebraPoolPermissionedActions\n  function setPluginConfig(uint8 newConfig) external override nonReentrant {\n    if (msg.sender != plugin) _checkIfAdministrator();\n    globalState.pluginConfig = newConfig;\n    emit PluginConfig(newConfig);\n  }\n\n  /// @inheritdoc IAlgebraPoolPermissionedActions\n  function setFee(uint16 newFee) external override {\n    bool isDynamicFeeEnabled = globalState.pluginConfig.hasFlag(Plugins.DYNAMIC_FEE);\n    if (!globalState.unlocked) revert IAlgebraPoolErrors.locked(); // cheaper to check lock here\n\n    if (msg.sender == plugin) {\n      if (!isDynamicFeeEnabled) revert dynamicFeeDisabled();\n    } else {\n      if (isDynamicFeeEnabled) revert dynamicFeeActive();\n      _checkIfAdministrator();\n    }\n    globalState.fee = newFee;\n    emit Fee(newFee);\n  }\n}"
    }
  ]
}