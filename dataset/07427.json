{
  "Title": "[M-16] maxWithdraw() and maxRedeem() doesnâ€™t return correct value which can make other contracts fail while working with protocol",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L215-L223\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L205-L213\n\n\n# Vulnerability details\n\n## Impact\nFunctions `maxWithdraw()` and `maxRedeem()` returns max amount of assets or shares owner would be able to withdraw taking into account liquidity in the TokenggAVAX contract, but logics don't consider that when user withdraws the withdrawal amounts subtracted from `totalReleasedAssets` (in `beforeWithdraw()` function) so the maximum amounts that can user withdraws should always be lower than `totalReleasedAssets` (which shows all the deposits and withdraws) but because functions `maxWithdraw()` and `maxRedeem()` uses `totalAssets()` to calculate available AVAX which includes deposits and current cycle rewards so those functions would return wrong value (whenever the return value is bigger than `totalReleaseAssets` then it would be wrong)\n\n## Proof of Concept\nThis is `beforeWithdraw()` code:\n```\n\tfunction beforeWithdraw(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets -= amount;\n\t}\n```\nThis is `beforeWithdraw()` code which is called whenever users withdraws their funds and as you can see the amount of withdrawal assets subtracted from `totalReleaseAssets` so withdrawal amounts can never be bigger than `totalReleaseAssets`. This is `maxWithdraw()` code:\n```\n\tfunction maxWithdraw(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 assets = convertToAssets(balanceOf[_owner]);\n\t\tuint256 avail = totalAssets() - stakingTotalAssets;\n\t\treturn assets > avail ? avail : assets;\n\t}\n```\nAs you can see to calculate available AVAX in the contract address code uses `totalAssets() - stakingTotalAssets` and `totalAssets()` shows deposits + current cycle rewards so `totalAssets()` is bigger than `totalReleaseAssets` and the value of the `totalAssets() - stakingTotalAssets` can be bigger than `totalReleaseAssets` and if code returns `avail` as answer then the return value would be wrong.\nimagine this scenario:\n1. `totalReleaseAssets` is `10000` AVAX.\n2. `stakingTotalAssets` is `1000` AVAX.\n3. current cycle rewards is `4000` AVAX and `block.timestamp` is currently in the middle of the cycle so current rewards is `2000` AVAX.\n4. `totalAssets()` is `totalReleaseAssets + current rewards = 10000 + 2000 = 12000`. \n5. contract balance is `10000 + 4000 - 1000 = 13000` AVAX.\n6. user1 has 90% contract shares and calls `maxWithdraw()` and code would calculate user assets as `10800` AVAX and available AVAX in contract as `totalAssets() - stakingTotalAssets = 12000 - 1000 = 11000` and code would return `10800` as answer.\n7. now if user1 withdraws `10800` AVAX code would revert in the function `beforeWithdraw()` because code would try to execute `totalReleaseAssets = totalReleaseAssets - amount = 10000 - 10800` and it would revert because of the underflow. so in reality user1 couldn't withdraw `10800` AVAX which was the return value of the `maxWithdraw()` for user1.\n\nthe root cause of the bug is that the withdrawal amount is subtracted from `totalReleaseAssets` and so max withdrawal can never be `totalReleaseAssets` and function `maxWithdraw()` should never return value bigger than `totalReleaseAssets`. (the bug in function `maxRedeem()` is similar)\n\nThis bug would cause other contract or front end calls to fail, for example if the logic is something like this:\n```\n   amount = maxWithdraw(user);\n   TokenggAVAX.withdrawAVAX(amount);\n```\naccording the function definitions this code should work bug because of the the issue there are situations that this would revert and other contracts and UI can't work properly with the protocol.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nconsider `totalReleaseAssets` in max withdrawal amount too.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/tokens/TokenggAVAX.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// Copied from https://github.com/fei-protocol/ERC4626/blob/main/src/xERC4626.sol\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\npragma solidity 0.8.17;\n\nimport \"../BaseUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"./upgradeable/ERC20Upgradeable.sol\";\nimport {ERC4626Upgradeable} from \"./upgradeable/ERC4626Upgradeable.sol\";\nimport {ProtocolDAO} from \"../ProtocolDAO.sol\";\nimport {Storage} from \"../Storage.sol\";\n\nimport {IWithdrawer} from \"../../interface/IWithdrawer.sol\";\nimport {IWAVAX} from \"../../interface/IWAVAX.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/// @dev Local variables and parent contracts must remain in order between contract upgrades\ncontract TokenggAVAX is Initializable, ERC4626Upgradeable, UUPSUpgradeable, BaseUpgradeable {\n\tusing SafeTransferLib for ERC20;\n\tusing SafeTransferLib for address;\n\tusing SafeCastLib for *;\n\tusing FixedPointMathLib for uint256;\n\n\terror SyncError();\n\terror ZeroShares();\n\terror ZeroAssets();\n\terror InvalidStakingDeposit();\n\terror WithdrawAmountTooLarge();\n\n\tevent NewRewardsCycle(uint256 indexed cycleEnd, uint256 rewardsAmt);\n\tevent WithdrawnForStaking(address indexed caller, uint256 assets);\n\tevent DepositedFromStaking(address indexed caller, uint256 baseAmt, uint256 rewardsAmt);\n\n\t/// @notice the effective start of the current cycle\n\tuint32 public lastSync;\n\n\t/// @notice the maximum length of a rewards cycle\n\tuint32 public rewardsCycleLength;\n\n\t/// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n\tuint32 public rewardsCycleEnd;\n\n\t/// @notice the amount of rewards distributed in a the most recent cycle.\n\tuint192 public lastRewardsAmt;\n\n\t/// @notice the total amount of avax (including avax sent out for staking and all incoming rewards)\n\tuint256 public totalReleasedAssets;\n\n\t/// @notice total amount of avax currently out for staking (not including any rewards)\n\tuint256 public stakingTotalAssets;\n\n\tmodifier whenTokenNotPaused(uint256 amt) {\n\t\tif (amt > 0 && getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\trevert ContractPaused();\n\t\t}\n\t\t_;\n\t}\n\n\t/// @custom:oz-upgrades-unsafe-allow constructor\n\tconstructor() {\n\t\t// The constructor is exectued only when creating implementation contract\n\t\t// so prevent it's reinitialization\n\t\t_disableInitializers();\n\t}\n\n\tfunction initialize(Storage storageAddress, ERC20 asset) public initializer {\n\t\t__ERC4626Upgradeable_init(asset, \"GoGoPool Liquid Staking Token\", \"ggAVAX\");\n\t\t__BaseUpgradeable_init(storageAddress);\n\n\t\trewardsCycleLength = 14 days;\n\t\t// Ensure it will be evenly divisible by `rewardsCycleLength`.\n\t\trewardsCycleEnd = (block.timestamp.safeCastTo32() / rewardsCycleLength) * rewardsCycleLength;\n\t}\n\n\t/// @notice only accept AVAX via fallback from the WAVAX contract\n\treceive() external payable {\n\t\tassert(msg.sender == address(asset));\n\t}\n\n\t/// @notice Distributes rewards to TokenggAVAX holders. Public, anyone can call.\n\t/// \t\t\t\tAll surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n\tfunction syncRewards() public {\n\t\tuint32 timestamp = block.timestamp.safeCastTo32();\n\n\t\tif (timestamp < rewardsCycleEnd) {\n\t\t\trevert SyncError();\n\t\t}\n\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint256 stakingTotalAssets_ = stakingTotalAssets;\n\n\t\tuint256 nextRewardsAmt = (asset.balanceOf(address(this)) + stakingTotalAssets_) - totalReleasedAssets_ - lastRewardsAmt_;\n\n\t\t// Ensure nextRewardsCycleEnd will be evenly divisible by `rewardsCycleLength`.\n\t\tuint32 nextRewardsCycleEnd = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n\t\tlastRewardsAmt = nextRewardsAmt.safeCastTo192();\n\t\tlastSync = timestamp;\n\t\trewardsCycleEnd = nextRewardsCycleEnd;\n\t\ttotalReleasedAssets = totalReleasedAssets_ + lastRewardsAmt_;\n\t\temit NewRewardsCycle(nextRewardsCycleEnd, nextRewardsAmt);\n\t}\n\n\t/// @notice Compute the amount of tokens available to share holders.\n\t///         Increases linearly during a reward distribution period from the sync call, not the cycle start.\n\tfunction totalAssets() public view override returns (uint256) {\n\t\t// cache global vars\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint32 rewardsCycleEnd_ = rewardsCycleEnd;\n\t\tuint32 lastSync_ = lastSync;\n\n\t\tif (block.timestamp >= rewardsCycleEnd_) {\n\t\t\t// no rewards or rewards are fully unlocked\n\t\t\t// entire reward amount is available\n\t\t\treturn totalReleasedAssets_ + lastRewardsAmt_;\n\t\t}\n\n\t\t// rewards are not fully unlocked\n\t\t// return unlocked rewards and stored total\n\t\tuint256 unlockedRewards = (lastRewardsAmt_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);\n\t\treturn totalReleasedAssets_ + unlockedRewards;\n\t}\n\n\tfunction amountAvailableForStaking() public view returns (uint256) {\n\t\tProtocolDAO protocolDAO = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 targetCollateralRate = protocolDAO.getTargetGGAVAXReserveRate();\n\n\t\tuint256 totalAssets_ = totalAssets();\n\n\t\tuint256 reservedAssets = totalAssets_.mulDivDown(targetCollateralRate, 1 ether);\n\t\treturn totalAssets_ - reservedAssets - stakingTotalAssets;\n\t}\n\n\tfunction depositFromStaking(uint256 baseAmt, uint256 rewardAmt) public payable onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tuint256 totalAmt = msg.value;\n\t\tif (totalAmt != (baseAmt + rewardAmt) || baseAmt > stakingTotalAssets) {\n\t\t\trevert InvalidStakingDeposit();\n\t\t}\n\n\t\temit DepositedFromStaking(msg.sender, baseAmt, rewardAmt);\n\t\tstakingTotalAssets -= baseAmt;\n\t\tIWAVAX(address(asset)).deposit{value: totalAmt}();\n\t}\n\n\tfunction withdrawForStaking(uint256 assets) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tif (assets > amountAvailableForStaking()) {\n\t\t\trevert WithdrawAmountTooLarge();\n\t\t}\n\n\t\temit WithdrawnForStaking(msg.sender, assets);\n\n\t\tstakingTotalAssets += assets;\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tIWithdrawer withdrawer = IWithdrawer(msg.sender);\n\t\twithdrawer.receiveWithdrawalAVAX{value: assets}();\n\t}\n\n\tfunction depositAVAX() public payable returns (uint256 shares) {\n\t\tuint256 assets = msg.value;\n\t\t// Check for rounding error since we round down in previewDeposit.\n\t\tif ((shares = previewDeposit(assets)) == 0) {\n\t\t\trevert ZeroShares();\n\t\t}\n\n\t\temit Deposit(msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).deposit{value: assets}();\n\t\t_mint(msg.sender, shares);\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction withdrawAVAX(uint256 assets) public returns (uint256 shares) {\n\t\tshares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\tfunction redeemAVAX(uint256 shares) public returns (uint256 assets) {\n\t\t// Check for rounding error since we round down in previewRedeem.\n\t\tif ((assets = previewRedeem(shares)) == 0) {\n\t\t\trevert ZeroAssets();\n\t\t}\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\t/// @notice Max amount of assets owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxWithdraw(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 assets = convertToAssets(balanceOf[_owner]);\n\t\tuint256 avail = totalAssets() - stakingTotalAssets;\n\t\treturn assets > avail ? avail : assets;\n\t}\n\n\t/// @notice Max amount of shares owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxRedeem(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 shares = balanceOf[_owner];\n\t\tuint256 avail = convertToShares(totalAssets() - stakingTotalAssets);\n\t\treturn shares > avail ? avail : shares;\n\t}\n\n\tfunction previewDeposit(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewDeposit(assets);\n\t}\n\n\tfunction previewMint(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewMint(shares);\n\t}\n\n\tfunction previewWithdraw(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewWithdraw(assets);\n\t}\n\n\tfunction previewRedeem(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewRedeem(shares);\n\t}\n\n\tfunction beforeWithdraw(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets -= amount;\n\t}\n\n\tfunction afterDeposit(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets += amount;\n\t}\n\n\tfunction _authorizeUpgrade(address newImplementation) internal override onlyGuardian {}\n}"
    },
    {
      "filename": "contracts/contract/tokens/TokenggAVAX.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// Copied from https://github.com/fei-protocol/ERC4626/blob/main/src/xERC4626.sol\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\npragma solidity 0.8.17;\n\nimport \"../BaseUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"./upgradeable/ERC20Upgradeable.sol\";\nimport {ERC4626Upgradeable} from \"./upgradeable/ERC4626Upgradeable.sol\";\nimport {ProtocolDAO} from \"../ProtocolDAO.sol\";\nimport {Storage} from \"../Storage.sol\";\n\nimport {IWithdrawer} from \"../../interface/IWithdrawer.sol\";\nimport {IWAVAX} from \"../../interface/IWAVAX.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/// @dev Local variables and parent contracts must remain in order between contract upgrades\ncontract TokenggAVAX is Initializable, ERC4626Upgradeable, UUPSUpgradeable, BaseUpgradeable {\n\tusing SafeTransferLib for ERC20;\n\tusing SafeTransferLib for address;\n\tusing SafeCastLib for *;\n\tusing FixedPointMathLib for uint256;\n\n\terror SyncError();\n\terror ZeroShares();\n\terror ZeroAssets();\n\terror InvalidStakingDeposit();\n\terror WithdrawAmountTooLarge();\n\n\tevent NewRewardsCycle(uint256 indexed cycleEnd, uint256 rewardsAmt);\n\tevent WithdrawnForStaking(address indexed caller, uint256 assets);\n\tevent DepositedFromStaking(address indexed caller, uint256 baseAmt, uint256 rewardsAmt);\n\n\t/// @notice the effective start of the current cycle\n\tuint32 public lastSync;\n\n\t/// @notice the maximum length of a rewards cycle\n\tuint32 public rewardsCycleLength;\n\n\t/// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n\tuint32 public rewardsCycleEnd;\n\n\t/// @notice the amount of rewards distributed in a the most recent cycle.\n\tuint192 public lastRewardsAmt;\n\n\t/// @notice the total amount of avax (including avax sent out for staking and all incoming rewards)\n\tuint256 public totalReleasedAssets;\n\n\t/// @notice total amount of avax currently out for staking (not including any rewards)\n\tuint256 public stakingTotalAssets;\n\n\tmodifier whenTokenNotPaused(uint256 amt) {\n\t\tif (amt > 0 && getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\trevert ContractPaused();\n\t\t}\n\t\t_;\n\t}\n\n\t/// @custom:oz-upgrades-unsafe-allow constructor\n\tconstructor() {\n\t\t// The constructor is exectued only when creating implementation contract\n\t\t// so prevent it's reinitialization\n\t\t_disableInitializers();\n\t}\n\n\tfunction initialize(Storage storageAddress, ERC20 asset) public initializer {\n\t\t__ERC4626Upgradeable_init(asset, \"GoGoPool Liquid Staking Token\", \"ggAVAX\");\n\t\t__BaseUpgradeable_init(storageAddress);\n\n\t\trewardsCycleLength = 14 days;\n\t\t// Ensure it will be evenly divisible by `rewardsCycleLength`.\n\t\trewardsCycleEnd = (block.timestamp.safeCastTo32() / rewardsCycleLength) * rewardsCycleLength;\n\t}\n\n\t/// @notice only accept AVAX via fallback from the WAVAX contract\n\treceive() external payable {\n\t\tassert(msg.sender == address(asset));\n\t}\n\n\t/// @notice Distributes rewards to TokenggAVAX holders. Public, anyone can call.\n\t/// \t\t\t\tAll surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n\tfunction syncRewards() public {\n\t\tuint32 timestamp = block.timestamp.safeCastTo32();\n\n\t\tif (timestamp < rewardsCycleEnd) {\n\t\t\trevert SyncError();\n\t\t}\n\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint256 stakingTotalAssets_ = stakingTotalAssets;\n\n\t\tuint256 nextRewardsAmt = (asset.balanceOf(address(this)) + stakingTotalAssets_) - totalReleasedAssets_ - lastRewardsAmt_;\n\n\t\t// Ensure nextRewardsCycleEnd will be evenly divisible by `rewardsCycleLength`.\n\t\tuint32 nextRewardsCycleEnd = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n\t\tlastRewardsAmt = nextRewardsAmt.safeCastTo192();\n\t\tlastSync = timestamp;\n\t\trewardsCycleEnd = nextRewardsCycleEnd;\n\t\ttotalReleasedAssets = totalReleasedAssets_ + lastRewardsAmt_;\n\t\temit NewRewardsCycle(nextRewardsCycleEnd, nextRewardsAmt);\n\t}\n\n\t/// @notice Compute the amount of tokens available to share holders.\n\t///         Increases linearly during a reward distribution period from the sync call, not the cycle start.\n\tfunction totalAssets() public view override returns (uint256) {\n\t\t// cache global vars\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint32 rewardsCycleEnd_ = rewardsCycleEnd;\n\t\tuint32 lastSync_ = lastSync;\n\n\t\tif (block.timestamp >= rewardsCycleEnd_) {\n\t\t\t// no rewards or rewards are fully unlocked\n\t\t\t// entire reward amount is available\n\t\t\treturn totalReleasedAssets_ + lastRewardsAmt_;\n\t\t}\n\n\t\t// rewards are not fully unlocked\n\t\t// return unlocked rewards and stored total\n\t\tuint256 unlockedRewards = (lastRewardsAmt_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);\n\t\treturn totalReleasedAssets_ + unlockedRewards;\n\t}\n\n\tfunction amountAvailableForStaking() public view returns (uint256) {\n\t\tProtocolDAO protocolDAO = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 targetCollateralRate = protocolDAO.getTargetGGAVAXReserveRate();\n\n\t\tuint256 totalAssets_ = totalAssets();\n\n\t\tuint256 reservedAssets = totalAssets_.mulDivDown(targetCollateralRate, 1 ether);\n\t\treturn totalAssets_ - reservedAssets - stakingTotalAssets;\n\t}\n\n\tfunction depositFromStaking(uint256 baseAmt, uint256 rewardAmt) public payable onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tuint256 totalAmt = msg.value;\n\t\tif (totalAmt != (baseAmt + rewardAmt) || baseAmt > stakingTotalAssets) {\n\t\t\trevert InvalidStakingDeposit();\n\t\t}\n\n\t\temit DepositedFromStaking(msg.sender, baseAmt, rewardAmt);\n\t\tstakingTotalAssets -= baseAmt;\n\t\tIWAVAX(address(asset)).deposit{value: totalAmt}();\n\t}\n\n\tfunction withdrawForStaking(uint256 assets) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tif (assets > amountAvailableForStaking()) {\n\t\t\trevert WithdrawAmountTooLarge();\n\t\t}\n\n\t\temit WithdrawnForStaking(msg.sender, assets);\n\n\t\tstakingTotalAssets += assets;\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tIWithdrawer withdrawer = IWithdrawer(msg.sender);\n\t\twithdrawer.receiveWithdrawalAVAX{value: assets}();\n\t}\n\n\tfunction depositAVAX() public payable returns (uint256 shares) {\n\t\tuint256 assets = msg.value;\n\t\t// Check for rounding error since we round down in previewDeposit.\n\t\tif ((shares = previewDeposit(assets)) == 0) {\n\t\t\trevert ZeroShares();\n\t\t}\n\n\t\temit Deposit(msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).deposit{value: assets}();\n\t\t_mint(msg.sender, shares);\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction withdrawAVAX(uint256 assets) public returns (uint256 shares) {\n\t\tshares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\tfunction redeemAVAX(uint256 shares) public returns (uint256 assets) {\n\t\t// Check for rounding error since we round down in previewRedeem.\n\t\tif ((assets = previewRedeem(shares)) == 0) {\n\t\t\trevert ZeroAssets();\n\t\t}\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\t/// @notice Max amount of assets owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxWithdraw(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 assets = convertToAssets(balanceOf[_owner]);\n\t\tuint256 avail = totalAssets() - stakingTotalAssets;\n\t\treturn assets > avail ? avail : assets;\n\t}\n\n\t/// @notice Max amount of shares owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxRedeem(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 shares = balanceOf[_owner];\n\t\tuint256 avail = convertToShares(totalAssets() - stakingTotalAssets);\n\t\treturn shares > avail ? avail : shares;\n\t}\n\n\tfunction previewDeposit(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewDeposit(assets);\n\t}\n\n\tfunction previewMint(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewMint(shares);\n\t}\n\n\tfunction previewWithdraw(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewWithdraw(assets);\n\t}\n\n\tfunction previewRedeem(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewRedeem(shares);\n\t}\n\n\tfunction beforeWithdraw(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets -= amount;\n\t}\n\n\tfunction afterDeposit(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets += amount;\n\t}\n\n\tfunction _authorizeUpgrade(address newImplementation) internal override onlyGuardian {}\n}"
    }
  ]
}