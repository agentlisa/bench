{
  "Title": "[M-26] `VE3DLocker.sol` Wrong implementation of inversely traverse for loops always reverts",
  "Content": "_Submitted by WatchPug, also found by Dravee, gzeon, and TerrierLover_\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L305-L329>\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L349-L373>\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L376-L396>\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L399-L415>\n\n### Vulnerability Details\n\n```\nfunction totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply) {\n    uint256 epochStart = uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n        rewardsDuration\n    );\n    uint256 cutoffEpoch = epochStart.sub(lockDuration);\n\n    //traverse inversely to make more current queries more gas efficient\n    for (uint256 i = _epoch; i + 1 != 0; i--) {\n        Epoch storage e = epochs[i];\n        if (uint256(e.date) <= cutoffEpoch) {\n            break;\n        }\n        supply = supply.add(epochs[i].supply);\n    }\n\n    return supply;\n}\n```\n\nIn `VE3DLocker.sol`, there are multiple instances in which an inversely traverse for loop is used \"to make more current queries more gas efficient\".\n\nFor example:\n\n*   `totalSupplyAtEpoch()`\n*   `balanceAtEpochOf()`\n*   `pendingLockAtEpochOf()`\n*   `totalSupply()`\n\nThe implementation of the inversely traverse for loop is inherited from Convex's original version: <https://github.com/convex-eth/platform/blob/main/contracts/contracts/CvxLockerV2.sol#L333-L334>\n\nHowever, Convex's locker contract is using Solidity 0.6.12, in which the arithmetic operations will overflow/underflow without revert.\n\nAs the solidity version used in the current implementation of `VE3DLocker.sol` is `0.8.7`, and there are some breaking changes in Solidity v0.8.0, including:\n\n> Arithmetic operations revert on underflow and overflow.\n\nRef: <https://docs.soliditylang.org/en/v0.8.7/080-breaking-changes.html#silent-changes-of-the-semantics>\n\nWhich makes the current implementation of inversely traverse for loops always reverts.\n\nMore specifically:\n\n1.  `for (uint i = locks.length - 1; i + 1 != 0; i--) {` will revert when `locks.length == 0` at `locks.length - 1` due to underflow;\n2.  `for (uint256 i = _epoch; i + 1 != 0; i--) {` will loop until `i == 0` and reverts at `i--` due to underflow.\n\nAs a result, all these functions will be malfunctioning and all the internal and external usage of these function will always revert.\n\n### Recommended Mitigation Steps\n\nChange `VE3DLocker.sol#L315` to:\n\n```\nfor (uint256 i = locks.length; i > 0; i--) {\n    uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);\n    //lock epoch must be less or equal to the epoch we're basing from.\n    if (lockEpoch <= epochTime) {\n        if (lockEpoch > cutoffEpoch) {\n            amount = amount.add(locks[i - 1].amount);\n```\n\nChange `VE3DLocker.sol#L360` to:\n\n```\nfor (uint256 i = locks.length; i > 0; i--) {\n    uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);\n\n    //return the next epoch balance\n    if (lockEpoch == nextEpoch) {\n        return locks[i - 1].amount;\n    } else if (lockEpoch < nextEpoch) {\n        //no need to check anymore\n        break;\n    }\n```\n\nChange `VE3DLocker.sol#L387` to:\n\n```\nfor (uint256 i = epochindex; i > 0; i--) {\n    Epoch storage e = epochs[i - 1];\n```\n\nChange `VE3DLocker.sol#L406` to:\n\n```\nfor (uint256 i = _epoch + 1; i > 0; i--) {\n    Epoch storage e = epochs[i - 1];\n    if (uint256(e.date) <= cutoffEpoch) {\n        break;\n    }\n    supply = supply.add(e.supply);\n}\n```\n\n**[solvetony (veToken Finance) confirmed and commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/150#issuecomment-1156684581):**\n > Looks valid.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/150#issuecomment-1196144415):**\n > The warden has shed light into a underflow that will cause a few functions which logic was ported over from 0.6.12, to revert due to new checks introduced in a more recent version of solidity.\n> \n> While the bug is easily fixable, the functions are broken.\n> \n> Normally I would be conflicted between a Low and Medium severity as these functions are mostly `view` and seem to have no particular impact.\n> \n> However, due to my familiarity with other Lockers, and the CVX Voting Strategy used I believe the finding implications are that:\n> - Integrating strategies (tokenizedLocks of the VE3DLocker) would be bricked\n> - Snapshot wouldn't be usable as it would need to know the balance of a user at a specific epoch\n> \n> So am confident in a Medium Severity and have contemplated raising to High, as impact is pretty dramatic.\n> \n> Personally am very confident governance couldn't work without some of the `view` functions impacted, however, considering that the Warden (and other dups) did not bring in any mention of governance, I think Medium Severity is appropriate.\n> \n> I highly recommend the sponsor ensures their governance-related function don't revert as that would be very problematic.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-vetoken-finance-contest",
  "Code": [
    {
      "filename": "contracts/VE3DLocker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"./helper/MathUtil.sol\";\nimport \"./helper/BoringMath.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\n/*\nVE3D Locking contract for https://www.convexfinance.com/\nVE3D locked in this contract will be entitled to voting rights for the Vetoken Finance platform\nBased on EPS Staking contract for http://ellipsis.finance/\nBased on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\n\nV2:\n- change locking mechanism to lock to a future epoch instead of current\n- pending lock getter\n- relocking allocates weight to the current epoch instead of future,\n    thus allows keeping voting weight in the same epoch a lock expires by relocking before a vote begins\n- balanceAtEpoch and supplyAtEpoch return proper values for future epochs\n- do not allow relocking directly to a new address\n*/\ncontract VE3DLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* ========== STATE VARIABLES ========== */\n\n    struct Reward {\n        bool isVeAsset;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n        address ve3Token;\n        address ve3TokenStaking;\n        address veAssetDeposits;\n    }\n    struct Balances {\n        uint112 locked;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply;\n        uint32 date; //epoch start date\n    }\n\n    //token\n    IERC20 public stakingToken; //VE3D\n\n    //rewards\n    address[] public rewardTokens;\n    mapping(address => Reward) public rewardData;\n\n    EnumerableSet.AddressSet internal operators;\n\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 16;\n\n    // reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n\n    // user -> reward token -> amount\n    mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n    mapping(address => mapping(address => uint256)) public rewards;\n\n    //supplies and epochs\n    uint256 public lockedSupply;\n    Epoch[] public epochs;\n\n    //mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    uint256 public constant denominator = 10000;\n\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n\n    //shutdown\n    bool public isShutdown = false;\n\n    //erc20-like interface\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _stakingToken) Ownable() {\n        _name = \"Vote Locked Vetoken Token\";\n        _symbol = \"xVE3D\";\n        _decimals = 18;\n\n        stakingToken = IERC20(_stakingToken);\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function version() public pure returns (uint256) {\n        return 2;\n    }\n\n    /* ========== ADMIN CONFIGURATION ========== */\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _veAssetDeposits,\n        address _ve3Token,\n        address _ve3TokenStaking,\n        address _distributor,\n        bool _isVeAsset\n    ) external {\n        require(_msgSender() == owner() || operators.contains(_msgSender()), \"!Auth\");\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardDistributors[_rewardsToken][_distributor] = true;\n\n        rewardData[_rewardsToken].isVeAsset = _isVeAsset;\n        // if reward is veAsset\n        if (_isVeAsset) {\n            require(_ve3Token != address(0));\n            require(_ve3TokenStaking != address(0));\n            require(_veAssetDeposits != address(0));\n            rewardData[_rewardsToken].ve3Token = _ve3Token;\n            rewardData[_rewardsToken].ve3TokenStaking = _ve3TokenStaking;\n            rewardData[_rewardsToken].veAssetDeposits = _veAssetDeposits;\n        }\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        isShutdown = true;\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    //set approvals for locking veAsset and staking VE3Token\n    function setApprovals() external {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            if (rewardData[_rewardsToken].isVeAsset) {\n                // set approve for staking VE3Token\n                IERC20(rewardData[_rewardsToken].ve3Token).safeApprove(\n                    rewardData[_rewardsToken].ve3TokenStaking,\n                    0\n                );\n                IERC20(rewardData[_rewardsToken].ve3Token).safeApprove(\n                    rewardData[_rewardsToken].ve3TokenStaking,\n                    type(uint256).max\n                );\n\n                // set approve for locking veAsset\n                IERC20(_rewardsToken).safeApprove(rewardData[_rewardsToken].veAssetDeposits, 0);\n                IERC20(_rewardsToken).safeApprove(\n                    rewardData[_rewardsToken].veAssetDeposits,\n                    type(uint256).max\n                );\n            }\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {\n        if (lockedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(lockedSupply)\n            );\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                    _rewardPerToken(_rewardsToken).sub(\n                        userRewardPerTokenPaid[_user][_rewardsToken]\n                    )\n                )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {\n        return Math.min(block.timestamp, _finishTime);\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256) {\n        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken) external view returns (uint256) {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256) {\n        return uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData[](rewardTokens.length);\n        Balances storage userBalance = balances[_account];\n        for (uint256 i = 0; i < userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(_account, token, userBalance.locked);\n        }\n        return userRewards;\n    }\n\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user) external view returns (uint256 amount) {\n        return balances[_user].locked;\n    }\n\n    //balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        return balanceAtEpochOf(findEpochId(block.timestamp), _user);\n    }\n\n    //balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we're basing from.\n            if (lockEpoch <= epochTime) {\n                if (lockEpoch > cutoffEpoch) {\n                    amount = amount.add(locks[i].amount);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    //return currently locked but not active balance\n    function pendingLockOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        uint256 locksLength = locks.length;\n\n        //return amount if latest lock is in the future\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength > 0 &&\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) > currentEpoch\n        ) {\n            return locks[locksLength - 1].amount;\n        }\n\n        return 0;\n    }\n\n    function pendingLockAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get next epoch from the given epoch index\n        uint256 nextEpoch = uint256(epochs[_epoch].date).add(rewardsDuration);\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n\n            //return the next epoch balance\n            if (lockEpoch == nextEpoch) {\n                return locks[i].amount;\n            } else if (lockEpoch < nextEpoch) {\n                //no need to check anymore\n                break;\n            }\n        }\n\n        return 0;\n    }\n\n    //supply of all properly locked balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n\n        //do not include next epoch's supply\n        if (uint256(epochs[epochindex - 1].date) > currentEpoch) {\n            epochindex--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n\n        return supply;\n    }\n\n    //supply of all properly locked balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply) {\n        uint256 epochStart = uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n            rewardsDuration\n        );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n\n        return supply;\n    }\n\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) public view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) break;\n\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock < _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // Information on a user's locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {\n            if (locks[i].unlockTime > block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance[](locks.length - i);\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        //create new epoch in the future where new non-active locks will lock to\n        uint256 nextEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration).add(\n            rewardsDuration\n        );\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n\n        //check to add\n        if (epochs[epochindex - 1].date < nextEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != nextEpoch) {\n                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(\n                    rewardsDuration\n                );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n        }\n    }\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount, false);\n    }\n\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        bool _isRelock\n    ) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //add user balances\n        uint112 lockAmount = _amount.to112();\n        bal.locked = bal.locked.add(lockAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lockAmount);\n\n        //add user lock records or add to current\n        uint256 lockEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        //if a fresh lock, add on an extra duration period\n        if (!_isRelock) {\n            lockEpoch = lockEpoch.add(rewardsDuration);\n        }\n        uint256 unlockTime = lockEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n\n        //if the latest user lock is smaller than this lock, always just add new entry to the end of the list\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {\n            userLocks[_account].push(\n                LockedBalance({amount: lockAmount, unlockTime: uint32(unlockTime)})\n            );\n        } else {\n            //else add to a current lock\n\n            //if latest lock is further in the future, lower index\n            //this can only happen if relocking an expired lock after creating a new lock\n            if (userLocks[_account][idx - 1].unlockTime > unlockTime) {\n                idx--;\n            }\n\n            //if idx points to the epoch when same unlock time, update\n            //(this is always true with a normal lock but maybe not with relock)\n            if (userLocks[_account][idx - 1].unlockTime == unlockTime) {\n                LockedBalance storage userL = userLocks[_account][idx - 1];\n                userL.amount = userL.amount.add(lockAmount);\n            } else {\n                //can only enter here if a relock is made after a lock and there's no lock entry\n                //for the current epoch.\n                //ex a list of locks such as \"[...][older][current*][next]\" but without a \"current\" lock\n                //length - 1 is the next epoch\n                //length - 2 is a past epoch\n                //thus need to insert an entry for current epoch at the 2nd to last entry\n                //we will copy and insert the tail entry(next) and then overwrite length-2 entry\n\n                //reset idx\n                idx = userLocks[_account].length;\n\n                //get current last item\n                LockedBalance storage userL = userLocks[_account][idx - 1];\n\n                //add a copy to end of list\n                userLocks[_account].push(\n                    LockedBalance({amount: userL.amount, unlockTime: userL.unlockTime})\n                );\n\n                //insert current epoch lock entry by overwriting the entry at length-2\n                userL.amount = lockAmount;\n                userL.unlockTime = uint32(unlockTime);\n            }\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        uint256 eIndex = epochs.length - 1;\n        //if relock, epoch should be current and not next, thus need to decrease index to length-2\n        if (_isRelock) {\n            eIndex--;\n        }\n        Epoch storage e = epochs[eIndex];\n        e.supply = e.supply.add(uint224(lockAmount));\n\n        emit Staked(_account, lockEpoch, _amount, lockAmount);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        address _withdrawTo,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n\n        if (isShutdown || locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay > 0) {\n                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(\n                    rewardsDuration\n                );\n                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(\n                    rewardsDuration\n                );\n                uint256 rRate = MathUtil.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i < length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay)) break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay > 0) {\n                    uint256 currentEpoch = block\n                        .timestamp\n                        .sub(_checkDelay)\n                        .div(rewardsDuration)\n                        .mul(rewardsDuration);\n                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(\n                        rewardsDuration\n                    );\n                    uint256 rRate = MathUtil.min(\n                        kickRewardPerEpoch.mul(epochsover + 1),\n                        denominator\n                    );\n                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked > 0, \"no exp locks\");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        lockedSupply = lockedSupply.sub(locked);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward > 0) {\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            stakingToken.safeTransfer(_rewardAddress, reward);\n\n            emit KickReward(_rewardAddress, _account, reward);\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_withdrawTo, locked, true);\n        } else {\n            stakingToken.safeTransfer(_withdrawTo, locked);\n        }\n    }\n\n    // withdraw expired locks to a different address\n    function withdrawExpiredLocksTo(address _withdrawTo) external nonReentrant {\n        _processExpiredLocks(msg.sender, false, _withdrawTo, msg.sender, 0);\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, msg.sender, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of 'kickRewardEpochDelay'\n        _processExpiredLocks(\n            _account,\n            false,\n            _account,\n            msg.sender,\n            rewardsDuration.mul(kickRewardEpochDelay)\n        );\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = rewards[_account][_rewardsToken];\n            if (reward > 0) {\n                rewards[_account][_rewardsToken] = 0;\n                if (rewardData[_rewardsToken].isVeAsset) {\n                    IVeAssetDeposit(rewardData[_rewardsToken].veAssetDeposits).deposit(\n                        reward,\n                        false\n                    );\n                    uint256 _ve3TokenBalance = IERC20(rewardData[_rewardsToken].ve3Token)\n                        .balanceOf(address(this));\n\n                    if (_stake) {\n                        IRewards(rewardData[_rewardsToken].ve3TokenStaking).stakeFor(\n                            _account,\n                            _ve3TokenBalance\n                        );\n                    } else {\n                        IERC20(rewardData[_rewardsToken].ve3Token).safeTransfer(\n                            _account,\n                            _ve3TokenBalance\n                        );\n                    }\n                    reward = _ve3TokenBalance;\n                    _rewardsToken = rewardData[_rewardsToken].ve3Token;\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp >= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to208();\n        } else {\n            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to208();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to40();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();\n    }\n\n    function queueNewRewards(address _rewardsToken, uint256 _reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardDistributors[_rewardsToken][msg.sender], \"Auth!\");\n        require(_reward > 0, \"No reward\");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        emit RewardAdded(_rewardsToken, _reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        require(rewardData[_tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address _account) {\n        {\n            //stack too deep\n            Balances storage userBalance = balances[_account];\n\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = _rewardPerToken(token).to208();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(\n                    rewardData[token].periodFinish\n                ).to40();\n                if (_account != address(0)) {\n                    rewards[_account][token] = _earned(_account, token, userBalance.locked);\n                    userRewardPerTokenPaid[_account][token] = rewardData[token]\n                        .rewardPerTokenStored;\n                }\n            }\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n    event RewardAdded(address indexed _token, uint256 _reward);\n    event Staked(\n        address indexed _user,\n        uint256 indexed _epoch,\n        uint256 _paidAmount,\n        uint256 _lockedAmount\n    );\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);\n    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);\n    event Recovered(address _token, uint256 _amount);\n}"
    },
    {
      "filename": "contracts/VE3DLocker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"./helper/MathUtil.sol\";\nimport \"./helper/BoringMath.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\n/*\nVE3D Locking contract for https://www.convexfinance.com/\nVE3D locked in this contract will be entitled to voting rights for the Vetoken Finance platform\nBased on EPS Staking contract for http://ellipsis.finance/\nBased on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\n\nV2:\n- change locking mechanism to lock to a future epoch instead of current\n- pending lock getter\n- relocking allocates weight to the current epoch instead of future,\n    thus allows keeping voting weight in the same epoch a lock expires by relocking before a vote begins\n- balanceAtEpoch and supplyAtEpoch return proper values for future epochs\n- do not allow relocking directly to a new address\n*/\ncontract VE3DLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* ========== STATE VARIABLES ========== */\n\n    struct Reward {\n        bool isVeAsset;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uin"
    }
  ]
}