{
  "Title": "`Listing::getAmountPodsFromFillListing` underflow can lead to undesired behaviour of `Listing::_fillListing`",
  "Content": "If [`fillBeanAmount * 1_000_000 > type(uint256).max`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Listing.sol#L144), the output of [`Listing::getAmountPodsFromFillListing`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Listing.sol#L144) would be less than expected, which can lead to the loss of user funds through `Listing::_fillListing`. However, the conditions for this issue to arise are highly unlikely given that `MarketplaceFacet::fillPodListing` is the only function that makes use of this function, and which previously performs a [Bean transfer](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/MarketplaceFacet.sol#L70) of `fillBeanAmount`.  The large number of tokens required to produce the undesired behavior notwithstanding, considering the economic impact, use of `SafeMath` when performing the quoted operation should be considered here.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/market/MarketplaceFacet/Listing.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n**/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./PodTransfer.sol\";\nimport \"contracts/libraries/Token/LibTransfer.sol\";\nimport \"contracts/libraries/LibPolynomial.sol\";\n\n/**\n * @author Beanjoyer, Malteasy\n * @title Pod Marketplace v2\n **/\n\ncontract Listing is PodTransfer {\n\n    using SafeMath for uint256;\n\n    struct PodListing {\n        address account;\n        uint256 index;\n        uint256 start;\n        uint256 amount;\n        uint24 pricePerPod;\n        uint256 maxHarvestableIndex;\n        uint256 minFillAmount;\n        LibTransfer.To mode;\n    }\n\n    event PodListingCreated(\n        address indexed account, \n        uint256 index, \n        uint256 start, \n        uint256 amount, \n        uint24 pricePerPod, \n        uint256 maxHarvestableIndex, \n        uint256 minFillAmount,\n        bytes pricingFunction,\n        LibTransfer.To mode,\n        LibPolynomial.PriceType pricingType\n    );\n\n    event PodListingFilled(\n        address indexed from,\n        address indexed to,\n        uint256 index,\n        uint256 start,\n        uint256 amount,\n        uint256 costInBeans\n    );\n\n    event PodListingCancelled(address indexed account, uint256 index);\n\n    /*\n     * Create\n     */\n\n    function _createPodListing(\n        uint256 index,\n        uint256 start,\n        uint256 amount,\n        uint24 pricePerPod,\n        uint256 maxHarvestableIndex,\n        uint256 minFillAmount,\n        LibTransfer.To mode\n    ) internal {\n        uint256 plotSize = s.a[msg.sender].field.plots[index];\n        \n        require(plotSize >= (start.add(amount)) && amount > 0, \"Marketplace: Invalid Plot/Amount.\");\n        require(pricePerPod > 0, \"Marketplace: Pod price must be greater than 0.\");\n        require(s.f.harvestable <= maxHarvestableIndex, \"Marketplace: Expired.\");\n        \n        if (s.podListings[index] != bytes32(0)) _cancelPodListing(msg.sender, index);\n\n        s.podListings[index] = hashListing(start, amount, pricePerPod, maxHarvestableIndex, minFillAmount, mode);\n\n        bytes memory f;\n        \n        emit PodListingCreated(msg.sender, index, start, amount, pricePerPod, maxHarvestableIndex, minFillAmount, f, mode, LibPolynomial.PriceType.Fixed);\n\n    }\n\n    function _createPodListingV2(\n        uint256 index,\n        uint256 start,\n        uint256 amount,\n        uint256 maxHarvestableIndex,\n        uint256 minFillAmount,\n        bytes calldata pricingFunction,\n        LibTransfer.To mode\n    ) internal {\n        uint256 plotSize = s.a[msg.sender].field.plots[index];\n\n        require(plotSize >= (start.add(amount)) && amount > 0, \"Marketplace: Invalid Plot/Amount.\");\n        require(s.f.harvestable <= maxHarvestableIndex, \"Marketplace: Expired.\");\n        \n        if (s.podListings[index] != bytes32(0)) _cancelPodListing(msg.sender, index);\n\n        s.podListings[index] = hashListingV2(\n            start, \n            amount, \n            0, \n            maxHarvestableIndex, \n            minFillAmount,\n            pricingFunction,\n            mode\n        );\n        \n        emit PodListingCreated(\n            msg.sender, \n            index, \n            start, \n            amount, \n            0, \n            maxHarvestableIndex, \n            minFillAmount,\n            pricingFunction,\n            mode,\n            LibPolynomial.PriceType.Dynamic\n        );\n    }\n\n    /*\n     * Fill\n     */\n\n    function _fillListing(PodListing calldata l, uint256 beanAmount) internal {\n        bytes32 lHash = hashListing(\n                l.start,\n                l.amount,\n                l.pricePerPod,\n                l.maxHarvestableIndex,\n                l.minFillAmount,\n                l.mode\n            );\n        \n        require(s.podListings[l.index] == lHash, \"Marketplace: Listing does not exist.\");\n        uint256 plotSize = s.a[l.account].field.plots[l.index];\n        require(plotSize >= (l.start.add(l.amount)) && l.amount > 0, \"Marketplace: Invalid Plot/Amount.\");\n        require(s.f.harvestable <= l.maxHarvestableIndex, \"Marketplace: Listing has expired.\");\n\n        uint256 amount = getAmountPodsFromFillListing(l.pricePerPod, l.amount, beanAmount);\n\n        __fillListing(msg.sender, l, amount, beanAmount);\n        _transferPlot(l.account, msg.sender, l.index, l.start, amount);\n\n    }\n\n    function _fillListingV2(\n        PodListing calldata l, \n        uint256 beanAmount,\n        bytes calldata pricingFunction\n    ) internal {\n        bytes32 lHash = hashListingV2(\n            l.start,\n            l.amount,\n            l.pricePerPod,\n            l.maxHarvestableIndex,\n            l.minFillAmount,\n            pricingFunction,\n            l.mode\n        );\n        \n        require(s.podListings[l.index] == lHash, \"Marketplace: Listing does not exist.\");\n\n        uint256 plotSize = s.a[l.account].field.plots[l.index];\n\n        require(plotSize >= (l.start.add(l.amount)) && l.amount > 0, \"Marketplace: Invalid Plot/Amount.\");\n        require(s.f.harvestable <= l.maxHarvestableIndex, \"Marketplace: Listing has expired.\");\n\n        uint256 amount = getAmountPodsFromFillListingV2(l.index.add(l.start).sub(s.f.harvestable), l.amount, beanAmount, pricingFunction);\n\n        __fillListingV2(msg.sender, l, pricingFunction, amount, beanAmount);\n        _transferPlot(l.account, msg.sender, l.index, l.start, amount);\n\n    }\n\n    function __fillListing(\n        address to,\n        PodListing calldata l,\n        uint256 amount,\n        uint256 beanAmount\n    ) private {\n        require(amount >= l.minFillAmount, \"Marketplace: Fill must be >= minimum amount.\");\n        require(l.amount >= amount, \"Marketplace: Not enough pods in Listing.\");\n\n        delete s.podListings[l.index];\n\n        if (l.amount > amount) {\n            s.podListings[l.index.add(amount).add(l.start)] = hashListing(\n                0,\n                l.amount.sub(amount),\n                l.pricePerPod,\n                l.maxHarvestableIndex,\n                l.minFillAmount,\n                l.mode\n            );\n        }\n\n        emit PodListingFilled(l.account, to, l.index, l.start, amount, beanAmount);\n    }\n\n    function __fillListingV2(\n        address to,\n        PodListing calldata l,\n        bytes calldata pricingFunction,\n        uint256 amount,\n        uint256 beanAmount\n    ) private {\n        require(amount >= l.minFillAmount, \"Marketplace: Fill must be >= minimum amount.\");\n        require(l.amount >= amount, \"Marketplace: Not enough pods in Listing.\");\n\n        delete s.podListings[l.index];\n\n        if (l.amount > amount) {\n            s.podListings[l.index.add(amount).add(l.start)] = hashListingV2(\n                0,\n                l.amount.sub(amount),\n                l.pricePerPod,\n                l.maxHarvestableIndex,\n                l.minFillAmount,\n                pricingFunction,\n                l.mode\n            );\n        }\n\n        emit PodListingFilled(l.account, to, l.index, l.start, amount, beanAmount);\n    }\n\n    /*\n     * Cancel\n     */\n\n    function _cancelPodListing(address account, uint256 index) internal {\n        require(\n            s.a[account].field.plots[index] > 0,\n            \"Marketplace: Listing not owned by sender.\"\n        );\n\n        delete s.podListings[index];\n\n        emit PodListingCancelled(account, index);\n    }\n\n    /*\n     * Helpers\n     */\n\n    function getAmountPodsFromFillListing(uint24 pricePerPod, uint256 podListingAmount, uint256 fillBeanAmount) internal pure returns (uint256 amount) {\n        amount = (fillBeanAmount * 1000000) / pricePerPod;\n        \n        uint256 remainingAmount = podListingAmount.sub(amount, \"Marketplace: Not enough pods in Listing.\");\n        if(remainingAmount <= (1000000 / pricePerPod)) amount = podListingAmount;\n    }\n\n    function getAmountPodsFromFillListingV2(\n        uint256 placeInLine, \n        uint256 podListingAmount,\n        uint256 fillBeanAmount,\n        bytes calldata pricingFunction\n    ) public pure returns (uint256 amount) {\n        uint256 pricePerPod = LibPolynomial.evaluatePolynomialPiecewise(pricingFunction, placeInLine);\n        amount = (fillBeanAmount.mul(1000000)) / pricePerPod;\n        \n        uint256 remainingAmount = podListingAmount.sub(amount, \"Marketplace: Not enough pods in Listing.\");\n        if(remainingAmount <= (1000000 / pricePerPod)) amount = podListingAmount;\n    }\n\n    function hashListing(\n        uint256 start, \n        uint256 amount, \n        uint24 pricePerPod, \n        uint256 maxHarvestableIndex, \n        uint256 minFillAmount,\n        LibTransfer.To mode\n    ) internal pure returns (bytes32 lHash) {\n        if(minFillAmount > 0) lHash = keccak256(abi.encodePacked(start, amount, pricePerPod, maxHarvestableIndex,  minFillAmount, mode == LibTransfer.To.EXTERNAL));\n        else lHash = keccak256(abi.encodePacked(start, amount, pricePerPod, maxHarvestableIndex,  mode == LibTransfer.To.EXTERNAL));\n    }\n\n    function hashListingV2(\n        uint256 start, \n        uint256 amount, \n        uint24 pricePerPod, \n        uint256 maxHarvestableIndex, \n        uint256 minFillAmount,\n        bytes calldata pricingFunction,\n        LibTransfer.To mode\n    ) internal pure returns (bytes32 lHash) {\n        require(pricingFunction.length == LibPolynomial.getNumPieces(pricingFunction).mul(168).add(32), \"Marketplace: Invalid pricing function.\");\n        lHash = keccak256(abi.encodePacked(start, amount, pricePerPod, maxHarvestableIndex, minFillAmount, mode == LibTransfer.To.EXTERNAL, pricingFunction));\n    }\n\n}"
    }
  ]
}