{
  "Title": "[G-01] Pack structs by putting variables that can fit together next to each other",
  "Content": "\nAs the solidity EVM works with 32 bytes, variables less than 32 bytes should be packed inside a struct so that they can be stored in the same slot, this saves gas when writing to storage ~20000 gas.\n\n### StrategyDetailsParam: version and vault can be packed together: `Gas saved: 1 * 2k = 2k`\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/interfaces/IAstariaRouter.sol#L101-L105\n\n```solidity\nFile: /src/interfaces/IAstariaRouter.sol\n101:  struct StrategyDetailsParam {\n102:    uint8 version;\n103:    uint256 deadline;\n104:    address vault;\n105:  }\n```\n\n```diff\ndiff --git a/src/interfaces/IAstariaRouter.sol b/src/interfaces/IAstariaRouter.sol\nindex 2ae1431..679f46a 100644\n--- a/src/interfaces/IAstariaRouter.sol\n+++ b/src/interfaces/IAstariaRouter.sol\n@@ -100,8 +100,8 @@ interface IAstariaRouter is IPausable, IBeacon {\n\n   struct StrategyDetailsParam {\n     uint8 version;\n-    uint256 deadline;\n     address vault;\n+    uint256 deadline;\n   }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/interfaces/IAstariaRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {IPausable} from \"core/utils/Pausable.sol\";\nimport {IBeacon} from \"core/interfaces/IBeacon.sol\";\nimport {IERC4626RouterBase} from \"gpl/interfaces/IERC4626RouterBase.sol\";\nimport {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";\n\ninterface IAstariaRouter is IPausable, IBeacon {\n  enum FileType {\n    FeeTo,\n    LiquidationFee,\n    ProtocolFee,\n    StrategistFee,\n    MinInterestBPS,\n    MinEpochLength,\n    MaxEpochLength,\n    MinInterestRate,\n    MaxInterestRate,\n    BuyoutFee,\n    MinDurationIncrease,\n    AuctionWindow,\n    StrategyValidator,\n    Implementation,\n    CollateralToken,\n    LienToken,\n    TransferProxy\n  }\n\n  struct File {\n    FileType what;\n    bytes data;\n  }\n\n  event FileUpdated(FileType what, bytes data);\n\n  struct RouterStorage {\n    //slot 1\n    uint32 auctionWindow;\n    uint32 auctionWindowBuffer;\n    uint32 liquidationFeeNumerator;\n    uint32 liquidationFeeDenominator;\n    uint32 maxEpochLength;\n    uint32 minEpochLength;\n    uint32 protocolFeeNumerator;\n    uint32 protocolFeeDenominator;\n    //slot 2\n    ERC20 WETH; //20\n    ICollateralToken COLLATERAL_TOKEN; //20\n    ILienToken LIEN_TOKEN; //20\n    ITransferProxy TRANSFER_PROXY; //20\n    address feeTo; //20\n    address BEACON_PROXY_IMPLEMENTATION; //20\n    uint88 maxInterestRate; //6\n    uint32 minInterestBPS; // was uint64\n    //slot 3 +\n    address guardian; //20\n    address newGuardian; //20\n    uint32 buyoutFeeNumerator;\n    uint32 buyoutFeeDenominator;\n    uint32 minDurationIncrease;\n    mapping(uint8 => address) strategyValidators;\n    mapping(uint8 => address) implementations;\n    //A strategist can have many deployed vaults\n    mapping(address => bool) vaults;\n  }\n\n  enum ImplementationType {\n    PrivateVault,\n    PublicVault,\n    WithdrawProxy,\n    ClearingHouse\n  }\n\n  enum LienRequestType {\n    DEACTIVATED,\n    UNIQUE,\n    COLLECTION,\n    UNIV3_LIQUIDITY\n  }\n\n  struct StrategyDetailsParam {\n    uint8 version;\n    uint256 deadline;\n    address vault;\n  }\n\n  struct MerkleData {\n    bytes32 root;\n    bytes32[] proof;\n  }\n\n  struct NewLienRequest {\n    StrategyDetailsParam strategy;\n    ILienToken.Stack[] stack;\n    bytes nlrDetails;\n    MerkleData merkle;\n    uint256 amount;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  struct Commitment {\n    address tokenContract;\n    uint256 tokenId;\n    NewLienRequest lienRequest;\n  }\n\n  /**\n   * @notice Validates the incoming loan commitment.\n   * @param commitment The commitment proofs and requested loan data for each loan.\n   * @return lien the new Lien data.\n   */\n  function validateCommitment(\n    IAstariaRouter.Commitment calldata commitment,\n    uint256 timeToSecondEpochEnd\n  ) external returns (ILienToken.Lien memory lien);\n\n  /**\n   * @notice Deploys a new PublicVault.\n   * @param epochLength The length of each epoch for the new PublicVault.\n   * @param delegate The address of the delegate account.\n   * @param underlying The underlying deposit asset for the vault\n   * @param vaultFee fee for the vault\n   * @param allowListEnabled flag for the allowlist\n   * @param allowList the starting allowList\n   * @param depositCap the deposit cap for the vault if any\n   */\n  function newPublicVault(\n    uint256 epochLength,\n    address delegate,\n    address underlying,\n    uint256 vaultFee,\n    bool allowListEnabled,\n    address[] calldata allowList,\n    uint256 depositCap\n  ) external returns (address);\n\n  /**\n   * @notice Deploys a new PrivateVault.\n   * @param delegate The address of the delegate account.\n   * @param underlying The address of the underlying token.\n   * @return The address of the new PrivateVault.\n   */\n  function newVault(address delegate, address underlying)\n    external\n    returns (address);\n\n  /**\n   * @notice Retrieves the address that collects protocol-level fees.\n   */\n  function feeTo() external returns (address);\n\n  /**\n   * @notice Deposits collateral and requests loans for multiple NFTs at once.\n   * @param commitments The commitment proofs and requested loan data for each loan.\n   * @return lienIds the lienIds for each loan.\n   */\n  function commitToLiens(Commitment[] memory commitments)\n    external\n    returns (uint256[] memory, ILienToken.Stack[] memory);\n\n  /**\n   * @notice Create a new lien against a CollateralToken.\n   * @param params The valid proof and lien details for the new loan.\n   * @return The ID of the created lien.\n   */\n  function requestLienPosition(\n    IAstariaRouter.Commitment calldata params,\n    address recipient\n  )\n    external\n    returns (\n      uint256,\n      ILienToken.Stack[] memory,\n      uint256\n    );\n\n  function LIEN_TOKEN() external view returns (ILienToken);\n\n  function TRANSFER_PROXY() external view returns (ITransferProxy);\n\n  function BEACON_PROXY_IMPLEMENTATION() external view returns (address);\n\n  function COLLATERAL_TOKEN() external view returns (ICollateralToken);\n\n  /**\n   * @notice Returns the current auction duration.\n   * @param includeBuffer Adds the current auctionWindowBuffer if true.\n   */\n  function getAuctionWindow(bool includeBuffer) external view returns (uint256);\n\n  /**\n   * @notice Computes the fee the protocol earns on loan origination from the protocolFee numerator and denominator.\n   */\n  function getProtocolFee(uint256) external view returns (uint256);\n\n  /**\n   * @notice Computes the fee Vaults earn when a Lien is bought out using the buyoutFee numerator and denominator.\n   */\n  function getBuyoutFee(uint256) external view returns (uint256);\n\n  /**\n   * @notice Computes the fee the users earn on liquidating an expired lien from the liquidationFee numerator and denominator.\n   */\n  function getLiquidatorFee(uint256) external view returns (uint256);\n\n  /**\n   * @notice Liquidate a CollateralToken that has defaulted on one of its liens.\n   * @param stack the stack being liquidated\n   * @param position The position of the defaulted lien.\n   * @return reserve The amount owed on all liens for against the collateral being liquidated, including accrued interest.\n   */\n  function liquidate(ILienToken.Stack[] calldata stack, uint8 position)\n    external\n    returns (OrderParameters memory);\n\n  /**\n   * @notice Returns whether a specified lien can be liquidated.\n   */\n  function canLiquidate(ILienToken.Stack calldata) external view returns (bool);\n\n  /**\n   * @notice Returns whether a given address is that of a Vault.\n   * @param vault The Vault address.\n   * @return A boolean representing whether the address exists as a Vault.\n   */\n  function isValidVault(address vault) external view returns (bool);\n\n  /**\n   * @notice Sets universal protocol parameters or changes the addresses for deployed contracts.\n   * @param files Structs to file.\n   */\n  function fileBatch(File[] calldata files) external;\n\n  /**\n   * @notice Sets universal protocol parameters or changes the addresses for deployed contracts.\n   * @param incoming The incoming File.\n   */\n  function file(File calldata incoming) external;\n\n  /**\n   * @notice Updates the guardian address.\n   * @param _guardian The new guardian.\n   */\n  function setNewGuardian(address _guardian) external;\n\n  /**\n   * @notice Specially guarded file().\n   * @param file The incoming data to file.\n   */\n  function fileGuardian(File[] calldata file) external;\n\n  /**\n   * @notice Returns the address for the current implementation of a contract from the ImplementationType enum.\n   * @return impl The address of the clone implementation.\n   */\n  function getImpl(uint8 implType) external view returns (address impl);\n\n  /**\n   * @notice Returns whether a new lien offers more favorable terms over an old lien.\n   * A new lien must have a rate less than or equal to maxNewRate,\n   * or a duration lower by minDurationIncrease, provided the other parameter does not get any worse.\n   * @param newLien The new Lien for the proposed refinance.\n   * @param position The Lien position against the CollateralToken.\n   * @param stack The Stack of existing Liens against the CollateralToken.\n   */\n  function isValidRefinance(\n    ILienToken.Lien calldata newLien,\n    uint8 position,\n    ILienToken.Stack[] calldata stack\n  ) external view returns (bool);\n\n  event Liquidation(uint256 collateralId, uint256 position);\n  event NewVault(\n    address strategist,\n    address delegate,\n    address vault,\n    uint8 vaultType\n  );\n\n  error InvalidFileData();\n  error InvalidEpochLength(uint256);\n  error InvalidRefinanceRate(uint256);\n  error InvalidRefinanceDuration(uint256);\n  error InvalidRefinanceCollateral(uint256);\n  error InvalidVaultState(VaultState);\n  error InvalidSenderForCollateral(address, uint256);\n  error InvalidLienState(LienState);\n  error InvalidCollateralState(CollateralStates);\n  error InvalidCommitmentState(CommitmentState);\n  error InvalidStrategy(uint16);\n  error InvalidVault(address);\n  error UnsupportedFile();\n\n  enum LienState {\n    HEALTHY,\n    AUCTION\n  }\n\n  enum CollateralStates {\n    AUCTION,\n    NO_AUCTION,\n    NO_DEPOSIT,\n    NO_LIENS\n  }\n\n  enum CommitmentState {\n    INVALID,\n    INVALID_RATE,\n    INVALID_AMOUNT,\n    EXPIRED,\n    COLLATERAL_AUCTION,\n    COLLATERAL_NO_DEPOSIT\n  }\n\n  enum VaultState {\n    UNINITIALIZED,\n    CLOSED,\n    LIQUIDATED\n  }\n}"
    }
  ]
}