{
  "Title": "Typo in modifier name",
  "Content": "\nhttps://github.com/defistarter/contracts/blob/9ffe009ee6047ced669711dde14fe38483abdf7e/StakingPool.sol#L68\n\nMissed character in `onlyAferSetup`.\n\nStatus: *Fixed at https://github.com/defistarter/contracts/commit/670678d7d2fd01b4c059ab76535c849f556377b4*\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "StakingPool.sol",
      "content": "//New version\npragma solidity ^0.6.0;\n// SPDX-License-Identifier: MIT\n// Libs\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n// Used contracts\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n//Internal\nimport { LPTokenWrapper } from  \"./LPTokenWrapper.sol\";\n\ncontract StakingPool is Ownable, ReentrancyGuard, LPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n    \n    //interface for Rewards Token\n    IERC20 public rewardsToken;\n    //Conctact status states\n    enum Status {Setup, Running, Ended}\n    \n    //Constants\n    uint256 constant public CALC_PRECISION = 1e18;\n\n    // Address where fees will be sent if fee isn't 0\n    address public fee_beneficiary;\n    // Fee in PPM (Parts Per Million), can be 0\n    uint256 public fee;\n    //Status of contract\n    Status public status;\n    //Rewards for period\n    uint256 public rewardsPerPeriodCap;\n    //Total rewards for all periods\n    uint256 public rewardsTotalCap;\n    //Staking Period in seconds\n    uint256 public periodTime;\n    //Total Periods\n    uint256 public totalPeriods;\n    //Grace Periods Time (time window after contract is Ended when users have to claim their Reward Tokens)\n    //after this period ends, no reward withdrawal is possible and contact owner can withdraw unclamed Reward Tokens\n    uint256 public gracePeriodTime;\n    //Time when contracts starts\n    uint256 public startTime;\n    //Time when contract ends \n    uint256 public endTime;\n    //Time when contract closes (endTime + gracePeriodTime)\n    uint256 public closeTime;\n    \n    \n    //Last Period\n    uint256 public period;\n    \n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event WithdrawnERC20(address indexed user, address token, uint256 amount);\n    \n\n    /** @dev Updates Period before executing function */\n    modifier updatePeriod() {\n        _updatePeriod();\n        _;\n    }\n    \n    /** @dev Make sure setup is finished */\n    modifier onlyAferSetup() {\n        require(status != Status.Setup, \"Setup is not finished\");\n        _;\n    }\n\n    /**\n     * @dev Contract constructor\n     * @param _lpToken Contract address of LP Token\n     * @param _rewardsToken Contract address of Rewards Token\n     * @param _rewardsPerPeriodCap Amount of tokens to be distributed each period (1e18)\n     * @param _periodDays Period time in days\n     * @param _totalPeriods Total periods contract will be running\n     * @param _gracePeriodDays Grace period in days \n     * @param _holdDays Time in days LP Tokens will be on hold for user after each stake\n     */\n    constructor(\n        address _lpToken,\n        address _rewardsToken,\n        uint256 _rewardsPerPeriodCap,\n        uint256 _periodDays, \n        uint256 _totalPeriods,\n        uint256 _gracePeriodDays,\n        uint256 _holdDays,\n        address _fee_beneficiary,\n        uint256 _fee\n    )\n        public\n        LPTokenWrapper(_lpToken, _holdDays)\n    {\n        require(_lpToken.isContract(), \"LP Token address must be a contract\");\n        require(_rewardsToken.isContract(), \"Rewards Token address must be a contract\");\n        rewardsToken = IERC20(_rewardsToken);\n        rewardsPerPeriodCap = _rewardsPerPeriodCap;\n        rewardsTotalCap = _rewardsPerPeriodCap.mul(_totalPeriods);\n        periodTime = _periodDays.mul(1 days);\n        totalPeriods = _totalPeriods;\n        gracePeriodTime = _gracePeriodDays.mul(1 days);\n        fee_beneficiary = _fee_beneficiary;\n        fee = _fee;\n    }\n\n    /***************************************\n                    ADMIN\n    ****************************************/\n\n    /**\n     * @dev Updates contract setup and mark contract status as Running if all requirements are met\n     * @param _now Start contract immediatly if true\n     */    \n    function adminStart(bool _now) \n        external \n        onlyOwner\n    {\n        require(status == Status.Setup, \"Already started\");\n        require(rewardsToken.balanceOf(address(this)) >= rewardsTotalCap, \"Not enough reward tokens to start\");\n        status = Status.Running;\n        if(_now) _startNow();\n    }\n    \n    /**\n     * @dev Option to start contract even there is no deposits yet\n     */\n    function adminStartNow()\n        external\n        onlyOwner\n        onlyAferSetup\n    {\n        require(startTime == 0 && status == Status.Running, \"Already started\");\n        _startNow();\n        \n    }\n    \n    /**\n     * @dev Option to end contract \n     */\n    function adminEnd()\n        external\n        onlyOwner\n        onlyAferSetup\n    {\n        require(block.timestamp >= endTime && endTime != 0, \"Cannot End\");\n        _updatePeriod();\n    }\n    \n    /**\n     * @dev Close contract after End and Grace period and withdraw unclamed rewards tokens\n     * @param _address where to send\n     */\n     function adminClose(address _address)\n        external\n        onlyOwner\n        onlyAferSetup\n    {\n        require(block.timestamp >= closeTime && closeTime != 0, \"Cannot Close\");\n        uint256 _rewardsBalance = rewardsToken.balanceOf(address(this));\n        if(_rewardsBalance > 0) rewardsToken.safeTransfer(_address, _rewardsBalance);\n    }\n    \n    /**\n     * @dev Withdraw other than LP or Rewards tokens \n     * @param _tokenAddress address of the token contract to withdraw\n     */\n     function adminWithdrawERC20(address _tokenAddress)\n        external\n        onlyOwner\n    {\n        require(_tokenAddress != address(rewardsToken) && _tokenAddress != address(lpToken), \"Cannot withdraw Reward or LP Tokens\");\n        IERC20 _token = IERC20(_tokenAddress);\n        uint256 _balance = _token.balanceOf(address(this));\n        require(_balance != 0, \"Not enough balance\");\n        uint256 _fee = _balance.mul(fee).div(1e6);\n        if(_fee != 0){\n            _token.safeTransfer(fee_beneficiary, _fee);\n            emit WithdrawnERC20(fee_beneficiary, _tokenAddress, _fee);\n        }\n        _token.safeTransfer(msg.sender, _balance.sub(_fee));\n        emit WithdrawnERC20(msg.sender, _tokenAddress, _balance.sub(_fee));\n    }\n    \n    /***************************************\n                    PRIVATE\n    ****************************************/\n    \n    /**\n     * @dev Starts the contract\n     */\n    function _startNow()\n        private\n    {\n        startTime = block.timestamp;\n        endTime = startTime.add(periodTime.mul(totalPeriods));  \n        closeTime = endTime.add(gracePeriodTime);\n    }\n\n    /**\n     * @dev Updates last period to current and set status to Ended if needed\n     */\n    function _updatePeriod()\n        private\n    {\n        uint256 _currentPeriod = currentPeriod();\n        if(_currentPeriod != period){\n            period = _currentPeriod;\n            _updateHistoryTotalSupply(period);\n            if(_currentPeriod == totalPeriods){\n                status = Status.Ended;\n                //release hold of LP tokens\n                holdTime = 0;\n            }\n        }\n    }\n    \n \n    /***************************************\n                    ACTIONS\n    ****************************************/\n    \n    /**\n     * @dev Stakes an amount for the sender, assumes sender approved allowace at LP Token contract _amount for this contract address\n     * @param _amount of LP Tokens\n     */\n    function stake(uint256 _amount)\n        external\n        onlyAferSetup\n        updatePeriod\n    {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(status != Status.Ended, \"Contract is Ended\");\n        if(startTime == 0) _startNow();\n        _stake(_amount, period);\n        emit Staked(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Withdraws given LP Token stake amount from the pool\n     * @param _amount LP Tokens to withdraw\n     */\n    function withdraw(uint256 _amount)\n        public\n        onlyAferSetup\n        updatePeriod\n    {\n        require(_amount > 0, \"Cannot withdraw 0\");\n        _withdraw(_amount, period);\n        emit Withdrawn(msg.sender, _amount);\n    }\n    \n    /**\n     * @dev Claims outstanding rewards for the sender.\n     * First updates outstanding reward allocation and then transfers.\n     */\n    function claimReward()\n        public\n        nonReentrant\n        onlyAferSetup\n        updatePeriod\n    {\n        require(block.timestamp <= closeTime, \"Contract is Closed\");\n        uint256 reward = calculateReward(msg.sender);\n        if (reward > 0) {\n            _updateUser(msg.sender, period);\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }    \n    \n    /**\n     * @dev Withdraws LP Tokens stake from pool and claims any rewards\n     */\n    function exit() \n        external\n    {\n        uint256 _amount = balanceOf(msg.sender);\n        if(_amount !=0) withdraw(_amount);\n        claimReward();\n    }\n    \n    /***************************************\n                    GETTERS\n    ****************************************/\n\n    /**\n     * @dev Calculates current period, if contract is ended returns currentPeriod + 1 (totalPeriods)\n     */\n    function currentPeriod() \n        public \n        view \n        returns (uint256)\n    {\n        uint256 _currentPeriod;\n        if(startTime != 0 && endTime != 0)\n        {\n            if(block.timestamp >= endTime){\n                _currentPeriod = totalPeriods;\n            }else{\n                _currentPeriod = block.timestamp.sub(startTime).div(periodTime);\n            }\n        }\n        return _currentPeriod;\n    }\n\n    /**\n     * @dev Calculates pending rewards for the user since last period claimed rewards to current period\n     * @param _address address of the user\n     */\n     function calculateReward(address _address) \n        public\n        view\n        returns (uint256)\n    {\n        UserData storage user = getUserData(_address);\n        if(!user.exists || block.timestamp >= closeTime) return 0;\n        uint256 _period = currentPeriod();\n        uint256 periodTotalSupply;\n        uint256 savedTotalSupply;\n        uint256 periodBalance;\n        uint256 savedBalance;\n        uint256 rewardTotal;\n        savedTotalSupply =  historyTotalSupply(user.period);\n        savedBalance = user.historyBalance[user.period];\n        for(uint256 i = user.period; i < _period; i++){\n            periodTotalSupply = historyTotalSupply(i);\n            periodBalance = user.historyBalance[i];\n            if(i > user.period){\n                periodBalance == 0 ? periodBalance = savedBalance : savedBalance = periodBalance;\n                periodTotalSupply == 0 ? periodTotalSupply = savedTotalSupply : savedTotalSupply = periodTotalSupply;\n            }\n            rewardTotal = rewardTotal.add(\n                rewardsPerPeriodCap.mul(\n                    periodBalance\n                ).mul(\n                    CALC_PRECISION\n                ).div(\n                    periodTotalSupply\n                ).div(\n                    CALC_PRECISION\n                )\n            );\n        }\n        return rewardTotal;\n    }\n\n    /**\n     * @dev Returns estimated current period reward for the user based on current total supply and his balance\n     * @param _address address of the user\n     */\n     function estimateReward(address _address) \n        public\n        view\n        returns (uint256)\n    {\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply == 0 || !isUserExist(_address) || block.timestamp >= closeTime) return 0;\n        return rewardsPerPeriodCap.mul(\n            balanceOf(_address)\n        ).mul(\n            CALC_PRECISION\n        ).div(\n            _totalSupply\n        ).div(\n            CALC_PRECISION\n        );\n    }\n\n}"
    }
  ]
}