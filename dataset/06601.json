{
  "Title": "[06] Variable shadow",
  "Content": "\nConsider renaming the input `accessControlManager` in `PoolRegistry.initialize()`. Currently, it's being shadowed by `AccessControlledV8.accessControlManager()`. This will get a warning on common linters/text editors.\n\nAlso, consider renaming the input \"owner\" in `VToken.allowance()` and `VToken.balanceOf()`, since it's being shadowed by `OwnableUpgradeable.owner()`.\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/Pool/PoolRegistry.sol#L170\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/VToken.sol#L539\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/VToken.sol#L548\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/Pool/PoolRegistry.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@venusprotocol/oracle/contracts/PriceOracle.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../Comptroller.sol\";\nimport \"../Factories/VTokenProxyFactory.sol\";\nimport \"../Factories/JumpRateModelFactory.sol\";\nimport \"../Factories/WhitePaperInterestRateModelFactory.sol\";\nimport \"../WhitePaperInterestRateModel.sol\";\nimport \"../VToken.sol\";\nimport \"../InterestRateModel.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlManager.sol\";\nimport \"../Shortfall/Shortfall.sol\";\nimport \"../VTokenInterfaces.sol\";\nimport \"./PoolRegistryInterface.sol\";\n\n/**\n * @title PoolRegistry\n * @notice PoolRegistry is a registry for Venus interest rate pools.\n */\ncontract PoolRegistry is Ownable2StepUpgradeable, AccessControlledV8, PoolRegistryInterface {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    enum InterestRateModels {\n        WhitePaper,\n        JumpRate\n    }\n\n    struct AddMarketInput {\n        address comptroller;\n        address asset;\n        uint8 decimals;\n        string name;\n        string symbol;\n        InterestRateModels rateModel;\n        uint256 baseRatePerYear;\n        uint256 multiplierPerYear;\n        uint256 jumpMultiplierPerYear;\n        uint256 kink_;\n        uint256 collateralFactor;\n        uint256 liquidationThreshold;\n        uint256 reserveFactor;\n        AccessControlManager accessControlManager;\n        address beaconAddress;\n        uint256 initialSupply;\n        address vTokenReceiver;\n        uint256 supplyCap;\n        uint256 borrowCap;\n    }\n\n    /**\n     * @notice VTokenProxyFactory contract address\n     */\n    VTokenProxyFactory public vTokenFactory;\n\n    /**\n     * @notice JumpRateModelFactory contract address\n     */\n    JumpRateModelFactory public jumpRateFactory;\n\n    /**\n     * @notice WhitePaperInterestRateModelFactory contract address\n     */\n    WhitePaperInterestRateModelFactory public whitePaperFactory;\n\n    /**\n     * @notice Shortfall contract address\n     */\n    Shortfall public shortfall;\n\n    /**\n     * @notice Shortfall contract address\n     */\n    address payable public protocolShareReserve;\n\n    /**\n     * @notice Maps pool's comptroller address to metadata.\n     */\n    mapping(address => VenusPoolMetaData) public metadata;\n\n    /**\n     * @dev Maps pool ID to pool's comptroller address\n     */\n    mapping(uint256 => address) private _poolsByID;\n\n    /**\n     * @dev Total number of pools created.\n     */\n    uint256 private _numberOfPools;\n\n    /**\n     * @dev Maps comptroller address to Venus pool Index.\n     */\n    mapping(address => VenusPool) private _poolByComptroller;\n\n    /**\n     * @dev Maps pool's comptroller address to asset to vToken.\n     */\n    mapping(address => mapping(address => address)) private _vTokens;\n\n    /**\n     * @dev Maps asset to list of supported pools.\n     */\n    mapping(address => address[]) private _supportedPools;\n\n    /**\n     * @dev Emitted when a new Venus pool is added to the directory.\n     */\n    event PoolRegistered(address indexed comptroller, VenusPool pool);\n\n    /**\n     * @dev Emitted when a pool name is set.\n     */\n    event PoolNameSet(address indexed comptroller, string oldName, string newName);\n\n    /**\n     * @dev Emitted when a pool metadata is updated.\n     */\n    event PoolMetadataUpdated(\n        address indexed comptroller,\n        VenusPoolMetaData oldMetadata,\n        VenusPoolMetaData newMetadata\n    );\n\n    /**\n     * @dev Emitted when a Market is added to the pool.\n     */\n    event MarketAdded(address indexed comptroller, address vTokenAddress);\n\n    /**\n     * @notice Event emitted when shortfall contract address is changed\n     */\n    event NewShortfallContract(address indexed oldShortfall, address indexed newShortfall);\n\n    /**\n     * @notice Event emitted when protocol share reserve contract address is changed\n     */\n    event NewProtocolShareReserve(address indexed oldProtocolShareReserve, address indexed newProtocolShareReserve);\n\n    /**\n     * @notice Thrown if trying to set a zero address where it's not allowed\n     */\n    error ZeroAddressNotAllowed();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the deployer to owner.\n     * @param vTokenFactory_ vToken factory address.\n     * @param jumpRateFactory_ jump rate factory address.\n     * @param whitePaperFactory_ white paper factory address.\n     * @param protocolShareReserve_ protocol's shares reserve address.\n     * @param accessControlManager_ AccessControlManager contract address.\n     */\n    function initialize(\n        VTokenProxyFactory vTokenFactory_,\n        JumpRateModelFactory jumpRateFactory_,\n        WhitePaperInterestRateModelFactory whitePaperFactory_,\n        Shortfall shortfall_,\n        address payable protocolShareReserve_,\n        address accessControlManager_\n    ) external initializer {\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager_);\n\n        vTokenFactory = vTokenFactory_;\n        jumpRateFactory = jumpRateFactory_;\n        whitePaperFactory = whitePaperFactory_;\n        _setShortfallContract(shortfall_);\n        _setProtocolShareReserve(protocolShareReserve_);\n    }\n\n    /**\n     * @notice Sets protocol share reserve contract address\n     * @param protocolShareReserve_ The address of the protocol share reserve contract\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\n     * @custom:access Only Governance\n     */\n    function setProtocolShareReserve(address payable protocolShareReserve_) external onlyOwner {\n        _setProtocolShareReserve(protocolShareReserve_);\n    }\n\n    /**\n     * @notice Sets shortfall contract address\n     * @param shortfall_ The address of the shortfall contract\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\n     * @custom:access Only Governance\n     */\n    function setShortfallContract(Shortfall shortfall_) external onlyOwner {\n        _setShortfallContract(shortfall_);\n    }\n\n    /**\n     * @dev Deploys a new Venus pool and adds to the directory.\n     * @param name The name of the pool\n     * @param beaconAddress The upgradeable beacon contract address for Comptroller implementation\n     * @param closeFactor The pool's close factor (scaled by 1e18)\n     * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18)\n     * @param priceOracle The pool's PriceOracle address\n     * @param maxLoopsLimit The maximum limit for the loops can iterate.\n     * @return index The index of the registered Venus pool\n     * @return proxyAddress The the Comptroller proxy address\n     */\n    function createRegistryPool(\n        string calldata name,\n        address beaconAddress,\n        uint256 closeFactor,\n        uint256 liquidationIncentive,\n        uint256 minLiquidatableCollateral,\n        address priceOracle,\n        uint256 maxLoopsLimit,\n        address accessControlManager\n    ) external virtual returns (uint256 index, address proxyAddress) {\n        _checkAccessAllowed(\"createRegistryPool(string,address,uint256,uint256,uint256,address,uint256,address)\");\n        // Input validation\n        require(beaconAddress != address(0), \"PoolRegistry: Invalid Comptroller beacon address.\");\n        require(priceOracle != address(0), \"PoolRegistry: Invalid PriceOracle address.\");\n\n        BeaconProxy proxy = new BeaconProxy(\n            beaconAddress,\n            abi.encodeWithSelector(Comptroller.initialize.selector, maxLoopsLimit, accessControlManager)\n        );\n\n        proxyAddress = address(proxy);\n        Comptroller comptrollerProxy = Comptroller(proxyAddress);\n\n        uint256 poolId = _registerPool(name, proxyAddress);\n\n        // Set Venus pool parameters\n        comptrollerProxy.setCloseFactor(closeFactor);\n        comptrollerProxy.setLiquidationIncentive(liquidationIncentive);\n        comptrollerProxy.setMinLiquidatableCollateral(minLiquidatableCollateral);\n        comptrollerProxy.setPriceOracle(PriceOracle(priceOracle));\n\n        // Start transferring ownership to msg.sender\n        comptrollerProxy.transferOwnership(msg.sender);\n\n        // Register the pool with this PoolRegistry\n        return (poolId, proxyAddress);\n    }\n\n    /**\n     * @notice Add a market to an existing pool and then mint to provide initial supply.\n     * @param input The structure describing the parameters for adding a market to a pool.\n     */\n    function addMarket(AddMarketInput memory input) external {\n        _checkAccessAllowed(\"addMarket(AddMarketInput)\");\n        require(input.comptroller != address(0), \"PoolRegistry: Invalid comptroller address\");\n        require(input.asset != address(0), \"PoolRegistry: Invalid asset address\");\n        require(input.beaconAddress != address(0), \"PoolRegistry: Invalid beacon address\");\n        require(input.vTokenReceiver != address(0), \"PoolRegistry: Invalid vTokenReceiver address\");\n\n        // solhint-disable-next-line reason-string\n        require(\n            _vTokens[input.comptroller][input.asset] == address(0),\n            \"PoolRegistry: Market already added for asset comptroller combination\"\n        );\n\n        InterestRateModel rate;\n        if (input.rateModel == InterestRateModels.JumpRate) {\n            rate = InterestRateModel(\n                jumpRateFactory.deploy(\n                    input.baseRatePerYear,\n                    input.multiplierPerYear,\n                    input.jumpMultiplierPerYear,\n                    input.kink_,\n                    input.accessControlManager\n                )\n            );\n        } else {\n            rate = InterestRateModel(whitePaperFactory.deploy(input.baseRatePerYear, input.multiplierPerYear));\n        }\n\n        Comptroller comptroller = Comptroller(input.comptroller);\n        uint256 underlyingDecimals = IERC20Metadata(input.asset).decimals();\n\n        VTokenProxyFactory.VTokenArgs memory initializeArgs = VTokenProxyFactory.VTokenArgs(\n            input.asset,\n            comptroller,\n            rate,\n            10**(underlyingDecimals + 18 - input.decimals),\n            input.name,\n            input.symbol,\n            input.decimals,\n            msg.sender,\n            input.accessControlManager,\n            VTokenInterface.RiskManagementInit(address(shortfall), protocolShareReserve),\n            input.beaconAddress,\n            input.reserveFactor\n        );\n\n        VToken vToken = vTokenFactory.deployVTokenProxy(initializeArgs);\n\n        comptroller.supportMarket(vToken);\n        comptroller.setCollateralFactor(vToken, input.collateralFactor, input.liquidationThreshold);\n\n        uint256[] memory newSupplyCaps = new uint256[](1);\n        uint256[] memory newBorrowCaps = new uint256[](1);\n        VToken[] memory vTokens = new VToken[](1);\n\n        newSupplyCaps[0] = input.supplyCap;\n        newBorrowCaps[0] = input.borrowCap;\n        vTokens[0] = vToken;\n\n        comptroller.setMarketSupplyCaps(vTokens, newSupplyCaps);\n        comptroller.setMarketBorrowCaps(vTokens, newBorrowCaps);\n\n        _vTokens[input.comptroller][input.asset] = address(vToken);\n        _supportedPools[input.asset].push(input.comptroller);\n\n        IERC20Upgradeable token = IERC20Upgradeable(input.asset);\n        uint256 amountToSupply = _transferIn(token, msg.sender, input.initialSupply);\n        token.safeApprove(address(vToken), 0);\n        token.safeApprove(address(vToken), amountToSupply);\n        vToken.mintBehalf(input.vTokenReceiver, amountToSupply);\n\n        emit MarketAdded(address(comptroller), address(vToken));\n    }\n\n    /**\n     * @notice Modify existing Venus pool name.\n     */\n    function setPoolName(address comptroller, string calldata name) external {\n        _checkAccessAllowed(\"setPoolName(address,string)\");\n        _ensureValidName(name);\n        string memory oldName = _poolByComptroller[comptroller].name;\n        _poolByComptroller[comptroller].name = name;\n        emit PoolNameSet(comptroller, oldName, name);\n    }\n\n    /**\n     * @notice Update metadata of an existing pool.\n     */\n    function updatePoolMetadata(address comptroller, VenusPoolMetaData memory _metadata) external {\n        _checkAccessAllowed(\"updatePoolMetadata(address,VenusPoolMetaData)\");\n        VenusPoolMetaData memory oldMetadata = metadata[comptroller];\n        metadata[comptroller] = _metadata;\n        emit PoolMetadataUpdated(comptroller, oldMetadata, _metadata);\n    }\n\n    /**\n     * @notice Returns arrays of all Venus pools' data.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getAllPools() external view override returns (VenusPool[] memory) {\n        VenusPool[] memory _pools = new VenusPool[](_numberOfPools);\n        for (uint256 i = 1; i <= _numberOfPools; ++i) {\n            address comptroller = _poolsByID[i];\n            _pools[i - 1] = (_poolByComptroller[comptroller]);\n        }\n        return _pools;\n    }\n\n    /**\n     * @param comptroller The comptroller proxy address associated to the pool\n     * @return  Returns Venus pool\n     */\n    function getPoolByComptroller(address comptroller) external view override returns (VenusPool memory) {\n        return _poolByComptroller[comptroller];\n    }\n\n    /**\n     * @param comptroller comptroller of Venus pool\n     * @return Returns Metadata of Venus pool\n     */\n    function getVenusPoolMetadata(address comptroller) external view override returns (VenusPoolMetaData memory) {\n        return metadata[comptroller];\n    }\n\n    function getVTokenForAsset(address comptroller, address asset) external view override returns (address) {\n        return _vTokens[comptroller][asset];\n    }\n\n    function getPoolsSupportedByAsset(address asset) external view override returns (address[] memory) {\n        return _supportedPools[asset];\n    }\n\n    /**\n     * @dev Adds a new Venus pool to the directory (without checking msg.sender).\n     * @param name The name of the pool\n     * @param comptroller The pool's Comptroller proxy contract address\n     * @return The index of the registered Venus pool\n     */\n    function _registerPool(string calldata name, address comptroller) internal returns (uint256) {\n        VenusPool memory venusPool = _poolByComptroller[comptroller];\n\n        require(venusPool.creator == address(0), \"PoolRegistry: Pool already exists in the directory.\");\n        _ensureValidName(name);\n\n        _numberOfPools++;\n\n        VenusPool memory pool = VenusPool(name, msg.sender, comptroller, block.number, block.timestamp);\n\n        _poolsByID[_numberOfPools] = comptroller;\n        _poolByComptroller[comptroller] = pool;\n\n        emit PoolRegistered(comptroller, pool);\n        return _numberOfPools;\n    }\n\n    function _transferIn(\n        IERC20Upgradeable token,\n        address from,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n        uint256 balanceAfter = token.balanceOf(address(this));\n        return balanceAfter - balanceBefore;\n    }\n\n    function _setShortfallContract(Shortfall shortfall_) internal {\n        if (address(shortfall_) == address(0)) {\n            revert ZeroAddressNotAllowed();\n        }\n        address oldShortfall = address(shortfall);\n        shortfall = shortfall_;\n        emit NewShortfallContract(oldShortfall, address(shortfall_));\n    }\n\n    function _setProtocolShareReserve(address payable protocolShareReserve_) internal {\n        if (protocolShareReserve_ == address(0)) {\n            revert ZeroAddressNotAllowed();\n        }\n        address oldProtocolShareReserve = protocolShareReserve;\n        protocolShareReserve = protocolShareReserve_;\n        emit NewProtocolShareReserve(oldProtocolShareReserve, protocolShareReserve_);\n    }\n\n    function _ensureValidName(string calldata name) internal pure {\n        require(bytes(name).length <= 100, \"Pool's name is too large\");\n    }\n}"
    },
    {
      "filename": "contracts/VToken.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./VTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./ExponentialNoError.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport \"./RiskFund/IProtocolShareReserve.sol\";\n\n/**\n * @title Venus VToken Contract\n * @author Venus Dev Team\n */\ncontract VToken is\n    Ownable2StepUpgradeable,\n    AccessControlledV8,\n    VTokenInterface,\n    ExponentialNoError,\n    TokenErrorReporter\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     * @param riskManagement Addresses of risk fund contracts\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address admin_,\n        address accessControlManager_,\n        RiskManagementInit memory riskManagement,\n        uint256 reserveFactorMantissa_\n    ) external initializer {\n        require(admin_ != address(0), \"invalid admin address\");\n\n        // Initialize the market\n        _initialize(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_,\n            accessControlManager_,\n            riskManagement,\n            reserveFactorMantissa_\n        );\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return success True if the transfer suceeded, reverts otherwise\n     * @custom:event Emits Transfer event on success\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\n     * @custom:access Not restricted\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        _transferTokens(msg.sender, msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return success True if the transfer suceeded, reverts otherwise\n     * @custom:event Emits Transfer event on success\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\n     * @custom:access Not restricted\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override nonReentrant returns (bool) {\n        _transferTokens(msg.sender, src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\n     * @return success Whether or not the approval succeeded\n     * @custom:event Emits Approval event\n     * @custom:access Not restricted\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        require(spender != address(0), \"invalid spender address\");\n\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return amount The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint256) {\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return totalBorrows The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override nonReentrant returns (uint256) {\n        accrueInterest();\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return borrowBalance The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        return _borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function mint(uint256 mintAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        _mintFresh(msg.sender, msg.sender, mintAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender calls on-behalf of minter. minter supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function mintBehalf(address minter, uint256 mintAmount) external override nonReentrant returns (uint256) {\n        require(minter != address(0), \"invalid minter address\");\n\n        accrueInterest();\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        _mintFresh(msg.sender, minter, mintAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Redeem and Transfer events; may emit AccrueInterest\n     * @custom:error RedeemTransferOutNotPossible is thrown when the protocol has insufficient cash\n     * @custom:access Not restricted\n     */\n    function redeem(uint256 redeemTokens) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\n        _redeemFresh(msg.sender, redeemTokens, 0);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     */\n    function redeemUnderlying(uint256 redeemAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\n        _redeemFresh(msg.sender, 0, redeemAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Borrow event; may emit AccrueInterest\n     * @custom:error BorrowCashNotAvailable is thrown when the protocol has insufficient cash\n     * @custom:access Not restricted\n     */\n    function borrow(uint256 borrowAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        _borrowFresh(msg.sender, borrowAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function repayBorrow(uint256 repayAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        _repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        _repayBorrowFresh(msg.sender, borrower, repayAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral vToken\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral vToken\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\n     * @custom:access Not restricted\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external override returns (uint256) {\n        _liquidateBorrow(msg.sender, borrower, repayAmount, vTokenCollateral, false);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice sets protocol share accumulated from liquidations\n     * @dev must be less than liquidation incentive - 1\n     * @param newProtocolSeizeShareMantissa_ new protocol share mantissa\n     * @custom:event Emits NewProtocolSeizeShare event on success\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\n     * @custom:error ProtocolSeizeShareTooBig is thrown when the new seize share is too high\n     * @custom:access Controlled by AccessControlManager\n     */\n    function setProtocolSeizeShare(uint256 newProtocolSeizeShareMantissa_) external {\n        _checkAccessAllowed(\"setProtocolSeizeShare(uint256)\");\n        uint256 liquidationIncentive = ComptrollerViewInterface(address(comptroller)).liquidationIncentiveMantissa();\n        if (newProtocolSeizeShareMantissa_ + 1e18 > liquidationIncentive) {\n            revert ProtocolSeizeShareTooBig();\n        }\n\n        uint256 oldProtocolSeizeShareMantissa = protocolSeizeShareMantissa;\n        protocolSeizeShareMantissa = newProtocolSeizeShareMantissa_;\n        emit NewProtocolSeizeShare(oldProtocolSeizeShareMantissa, newProtocolSeizeShareMantissa_);\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @custom:event Emits NewReserveFactor event; may emit AccrueInterest\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\n     * @custom:error SetReserveFactorBoundsCheck is thrown when the new reserve factor is too high\n     * @custom:access Controlled by AccessControlManager\n     */\n    function setReserveFactor(uint256 newReserveFactorMantissa) external override nonReentrant {\n        _checkAccessAllowed(\"setReserveFactor(uint256)\");\n\n        accrueInterest();\n        _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to the protocol reserve contract\n     * @param reduceAmount Amount of reduction to reserves\n     * @custom:event Emits ReservesReduced event; may emit AccrueInterest\n     * @custom:error ReduceReservesCashNotAvailable is thrown when the vToken does not have sufficient cash\n     * @custom:error ReduceReservesCashValidation is thrown when trying to withdraw more cash than the reserves have\n     * @custom:access Not restricted\n     */\n    function reduceReserves(uint256 reduceAmount) external override nonReentrant {\n        accrueInterest();\n        _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @custom:event Emits ReservesAdded event; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function addReserves(uint256 addAmount) external override nonReentrant {\n        accrueInterest();\n        _addReservesFresh(addAmount);\n    }\n\n    /**\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @custom:event Emits NewMarketInterestRateModel event;"
    }
  ]
}