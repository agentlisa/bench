{
  "Title": "[G-02] gov contract :: withdraw\\_voting\\_tokens function",
  "Content": "\nFunction: withdraw\\_voting\\_tokens\n\nContract: <https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/staking.rs#L87>\n\nProblem: Gas is wasted if withdraw\\_share is computed as 0\n\nRecommendation: Add a check for withdraw\\_share>0, otherwise return\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/anchor-token-contracts/contracts/gov/src/staking.rs",
      "content": "use crate::error::ContractError;\nuse crate::state::{\n    bank_read, bank_store, config_read, config_store, poll_read, poll_voter_store, state_read,\n    state_store, Config, Poll, State, TokenManager,\n};\n\nuse anchor_token::gov::{PollStatus, StakerResponse};\nuse astroport::querier::query_token_balance;\nuse cosmwasm_std::{\n    to_binary, Addr, CanonicalAddr, CosmosMsg, Deps, DepsMut, MessageInfo, Response, StdResult,\n    Storage, Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\npub fn stake_voting_tokens(\n    deps: DepsMut,\n    sender: Addr,\n    amount: Uint128,\n) -> Result<Response, ContractError> {\n    if amount.is_zero() {\n        return Err(ContractError::InsufficientFunds {});\n    }\n\n    let sender_address_raw = deps.api.addr_canonicalize(sender.as_str())?;\n    let key = &sender_address_raw.as_slice();\n\n    let mut token_manager = bank_read(deps.storage).may_load(key)?.unwrap_or_default();\n    let config: Config = config_store(deps.storage).load()?;\n    let mut state: State = state_store(deps.storage).load()?;\n\n    // balance already increased, so subtract deposit amount\n    let total_balance = query_token_balance(\n        &deps.querier,\n        deps.api.addr_humanize(&config.anchor_token)?,\n        deps.api.addr_humanize(&state.contract_addr)?,\n    )?\n    .checked_sub(state.total_deposit + amount)?;\n\n    let share = if total_balance.is_zero() || state.total_share.is_zero() {\n        amount\n    } else {\n        amount.multiply_ratio(state.total_share, total_balance)\n    };\n\n    token_manager.share += share;\n    state.total_share += share;\n\n    state_store(deps.storage).save(&state)?;\n    bank_store(deps.storage).save(key, &token_manager)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"staking\"),\n        (\"sender\", sender.as_str()),\n        (\"share\", share.to_string().as_str()),\n        (\"amount\", amount.to_string().as_str()),\n    ]))\n}\n\n// Withdraw amount if not staked. By default all funds will be withdrawn.\npub fn withdraw_voting_tokens(\n    deps: DepsMut,\n    info: MessageInfo,\n    amount: Option<Uint128>,\n) -> Result<Response, ContractError> {\n    let sender_address_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    let key = sender_address_raw.as_slice();\n\n    if let Some(mut token_manager) = bank_read(deps.storage).may_load(key)? {\n        let config: Config = config_store(deps.storage).load()?;\n        let mut state: State = state_store(deps.storage).load()?;\n\n        // Load total share & total balance except proposal deposit amount\n        let total_share = state.total_share.u128();\n        let total_balance = query_token_balance(\n            &deps.querier,\n            deps.api.addr_humanize(&config.anchor_token)?,\n            deps.api.addr_humanize(&state.contract_addr)?,\n        )?\n        .checked_sub(state.total_deposit)?\n        .u128();\n\n        let locked_balance =\n            compute_locked_balance(deps.storage, &mut token_manager, &sender_address_raw);\n        let locked_share = locked_balance * total_share / total_balance;\n        let user_share = token_manager.share.u128();\n\n        let withdraw_share = amount\n            .map(|v| std::cmp::max(v.multiply_ratio(total_share, total_balance).u128(), 1u128))\n            .unwrap_or_else(|| user_share - locked_share);\n        let withdraw_amount = amount\n            .map(|v| v.u128())\n            .unwrap_or_else(|| withdraw_share * total_balance / total_share);\n\n        if locked_share + withdraw_share > user_share {\n            Err(ContractError::InvalidWithdrawAmount {})\n        } else {\n            let share = user_share - withdraw_share;\n            token_manager.share = Uint128::from(share);\n\n            bank_store(deps.storage).save(key, &token_manager)?;\n\n            state.total_share = Uint128::from(total_share - withdraw_share);\n            state_store(deps.storage).save(&state)?;\n\n            send_tokens(\n                deps,\n                &config.anchor_token,\n                &sender_address_raw,\n                withdraw_amount,\n                \"withdraw\",\n            )\n        }\n    } else {\n        Err(ContractError::NothingStaked {})\n    }\n}\n\n// removes not in-progress poll voter info & unlock tokens\n// and returns the largest locked amount in participated polls.\nfn compute_locked_balance(\n    storage: &mut dyn Storage,\n    token_manager: &mut TokenManager,\n    voter: &CanonicalAddr,\n) -> u128 {\n    token_manager.locked_balance.retain(|(poll_id, _)| {\n        let poll: Poll = poll_read(storage).load(&poll_id.to_be_bytes()).unwrap();\n\n        if poll.status != PollStatus::InProgress {\n            // remove voter info from the poll\n            poll_voter_store(storage, *poll_id).remove(voter.as_slice());\n        }\n\n        poll.status == PollStatus::InProgress\n    });\n\n    token_manager\n        .locked_balance\n        .iter()\n        .map(|(_, v)| v.balance.u128())\n        .max()\n        .unwrap_or_default()\n}\n\nfn send_tokens(\n    deps: DepsMut,\n    asset_token: &CanonicalAddr,\n    recipient: &CanonicalAddr,\n    amount: u128,\n    action: &str,\n) -> Result<Response, ContractError> {\n    let contract_human = deps.api.addr_humanize(asset_token)?.to_string();\n    let recipient_human = deps.api.addr_humanize(recipient)?.to_string();\n\n    Ok(Response::new()\n        .add_messages(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: contract_human,\n            msg: to_binary(&Cw20ExecuteMsg::Transfer {\n                recipient: recipient_human.clone(),\n                amount: Uint128::from(amount),\n            })?,\n            funds: vec![],\n        })])\n        .add_attributes(vec![\n            (\"action\", action),\n            (\"recipient\", recipient_human.as_str()),\n            (\"amount\", amount.to_string().as_str()),\n        ]))\n}\n\npub fn query_staker(deps: Deps, address: String) -> StdResult<StakerResponse> {\n    let addr_raw = deps.api.addr_canonicalize(&address).unwrap();\n    let config: Config = config_read(deps.storage).load()?;\n    let state: State = state_read(deps.storage).load()?;\n    let mut token_manager = bank_read(deps.storage)\n        .may_load(addr_raw.as_slice())?\n        .unwrap_or_default();\n\n    // filter out not in-progress polls\n    token_manager.locked_balance.retain(|(poll_id, _)| {\n        let poll: Poll = poll_read(deps.storage)\n            .load(&poll_id.to_be_bytes())\n            .unwrap();\n\n        poll.status == PollStatus::InProgress\n    });\n\n    let total_balance = query_token_balance(\n        &deps.querier,\n        deps.api.addr_humanize(&config.anchor_token)?,\n        deps.api.addr_humanize(&state.contract_addr)?,\n    )?\n    .checked_sub(state.total_deposit)?;\n\n    Ok(StakerResponse {\n        balance: if !state.total_share.is_zero() {\n            token_manager\n                .share\n                .multiply_ratio(total_balance, state.total_share)\n        } else {\n            Uint128::zero()\n        },\n        share: token_manager.share,\n        locked_balance: token_manager.locked_balance,\n    })\n}"
    }
  ]
}