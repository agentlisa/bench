{
  "Title": "M-3: resolveQueuedTrades is intended to be non atomic but invalid signature can still cause entire transaction to revert",
  "Content": "# Issue M-3: resolveQueuedTrades is intended to be non atomic but invalid signature can still cause entire transaction to revert \n\nSource: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/84 \n\n## Found by \n0x52\n\n## Summary\n\nBufferRouter#resolveQueuedTrades and unlockOptions attempt to be non atomic (i.e. doesn't revert the transaction if one fails) but an invalid signature can still cause the entire transaction to revert, because the ECDSA.recover sub call in _validateSigner can still revert.\n\n## Vulnerability Detail\n\n    function _validateSigner(\n        uint256 timestamp,\n        address asset,\n        uint256 price,\n        bytes memory signature\n    ) internal view returns (bool) {\n        bytes32 digest = ECDSA.toEthSignedMessageHash(\n            keccak256(abi.encodePacked(timestamp, asset, price))\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        return recoveredSigner == publisher;\n    }\n\n_validateSigner can revert at the ECDSA.recover sub call breaking the intended non atomic nature of BufferRouter#resolveQueuedTrades and unlockOptions.\n\n## Impact\n\nBufferRouter#resolveQueuedTrades and unlockOptions don't function as intended if signature is malformed\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L260-L271\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a try statement inside _validateSigner to avoid any reverts:\n\n        function _validateSigner(\n            uint256 timestamp,\n            address asset,\n            uint256 price,\n            bytes memory signature\n        ) internal view returns (bool) {\n            bytes32 digest = ECDSA.toEthSignedMessageHash(\n                keccak256(abi.encodePacked(timestamp, asset, price))\n            );\n    -       address recoveredSigner = ECDSA.recover(digest, signature);\n\n    +       try ECDSA.recover(digest, signature) returns (address recoveredSigner) {\n    +           return recoveredSigner == publisher;\n    +       } else {\n    +           return false;\n    +       }\n        }\n\n## Discussion\n\n**bufferfinance**\n\nThe protocol has been tested against wrong signatures.\n[https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/tests/test_router.py#L815](url)\n\n**0x00052**\n\nEscalate for 10 USDC.\n\nMy submission is valid and sponsor's comment here is inaccurate. ECDSA.recover will revert in the _throwError subcall under quite a few conditions not covered by their tests, including signature of invalid length and signature that resolve to address(0).\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/24d1bb668a1152528a6e6d71c2e285d227ed19d9/contracts/utils/cryptography/ECDSA.sol#L88-L92 \n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> My submission is valid and sponsor's comment here is inaccurate. ECDSA.recover will revert in the _throwError subcall under quite a few conditions not covered by their tests, including signature of invalid length and signature that resolve to address(0).\n> \n> https://github.com/OpenZeppelin/openzeppelin-contracts/blob/24d1bb668a1152528a6e6d71c2e285d227ed19d9/contracts/utils/cryptography/ECDSA.sol#L88-L92 \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted \n\nInvalid signatures resolving to address(0) reverts _validateSigner \n\n**sherlock-admin**\n\n> Escalation accepted \n> \n> Invalid signatures resolving to address(0) reverts _validateSigner \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**bufferfinance**\n\nWill fix this\n\n\n**0x00052**\n\nFixed in [PR#28](https://github.com/bufferfinance/Buffer-Protocol-v2/pull/28)\n\nChanges look good.  ECDSA.recover changed to ECDSA.tryRecover to prevent any revert when recovering signatures\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/24",
  "Code": [
    {
      "filename": "contracts/contracts/core/BufferRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/Interfaces.sol\";\n\n/**\n * @author Heisenberg\n * @notice Buffer Options Router Contract\n */\ncontract BufferRouter is AccessControl, IBufferRouter {\n    uint16 MAX_WAIT_TIME = 1 minutes;\n    uint256 public nextQueueId = 0;\n    address public publisher;\n    uint256 public nextQueueIdToProcess = 0;\n    bool public isInPrivateKeeperMode = true;\n\n    mapping(address => uint256[]) public userQueuedIds;\n    mapping(address => uint256[]) public userCancelledQueuedIds;\n    mapping(address => uint256) public userNextQueueIndexToProcess;\n    mapping(uint256 => QueuedTrade) public queuedTrades;\n    mapping(address => bool) public contractRegistry;\n    mapping(address => bool) public isKeeper;\n\n    constructor(address _publisher) {\n        publisher = _publisher;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /************************************************\n     *  ADMIN ONLY FUNCTIONS\n     ***********************************************/\n\n    function setContractRegistry(address targetContract, bool register)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        contractRegistry[targetContract] = register;\n    }\n\n    function setKeeper(address _keeper, bool _isActive)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        isKeeper[_keeper] = _isActive;\n    }\n\n    function setInPrivateKeeperMode() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        isInPrivateKeeperMode = !isInPrivateKeeperMode;\n    }\n\n    /************************************************\n     *  USER WRITE FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Adds an option creation request in the queue\n     */\n    function initiateTrade(\n        uint256 totalFee,\n        uint256 period,\n        bool isAbove,\n        address targetContract,\n        uint256 expectedStrike,\n        uint256 slippage,\n        bool allowPartialFill,\n        string memory referralCode,\n        uint256 traderNFTId\n    ) external returns (uint256 queueId) {\n        // Checks if the target contract has been registered\n        require(\n            contractRegistry[targetContract],\n            \"Router: Unauthorized contract\"\n        );\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            targetContract\n        );\n\n        optionsContract.runInitialChecks(slippage, period, totalFee);\n\n        // Transfer the fee specified from the user to this contract.\n        // User has to approve first inorder to execute this function\n        IERC20(optionsContract.tokenX()).transferFrom(\n            msg.sender,\n            address(this),\n            totalFee\n        );\n        queueId = nextQueueId;\n        nextQueueId++;\n\n        QueuedTrade memory queuedTrade = QueuedTrade(\n            queueId,\n            userQueueCount(msg.sender),\n            msg.sender,\n            totalFee,\n            period,\n            isAbove,\n            targetContract,\n            expectedStrike,\n            slippage,\n            allowPartialFill,\n            block.timestamp,\n            true,\n            referralCode,\n            traderNFTId\n        );\n\n        queuedTrades[queueId] = queuedTrade;\n\n        userQueuedIds[msg.sender].push(queueId);\n\n        emit InitiateTrade(msg.sender, queueId, block.timestamp);\n    }\n\n    /**\n     * @notice Cancels a queued traded. Can only be called by the trade owner\n     */\n    function cancelQueuedTrade(uint256 queueId) external {\n        QueuedTrade memory queuedTrade = queuedTrades[queueId];\n        require(msg.sender == queuedTrade.user, \"Router: Forbidden\");\n        require(queuedTrade.isQueued, \"Router: Trade has already been opened\");\n        _cancelQueuedTrade(queueId);\n        emit CancelTrade(queuedTrade.user, queueId, \"User Cancelled\");\n    }\n\n    /************************************************\n     *  KEEPER ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Verifies the trade parameter via the signature and resolves all the valid queued trades\n     */\n    function resolveQueuedTrades(OpenTradeParams[] calldata params) external {\n        _validateKeeper();\n        for (uint32 index = 0; index < params.length; index++) {\n            OpenTradeParams memory currentParams = params[index];\n            QueuedTrade memory queuedTrade = queuedTrades[\n                currentParams.queueId\n            ];\n            bool isSignerVerifed = _validateSigner(\n                currentParams.timestamp,\n                currentParams.asset,\n                currentParams.price,\n                currentParams.signature\n            );\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailResolve(\n                    currentParams.queueId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n            if (\n                !queuedTrade.isQueued ||\n                currentParams.timestamp != queuedTrade.queuedTime\n            ) {\n                // Trade has already been opened or cancelled or the timestamp is wrong.\n                // So ignore this trade.\n                continue;\n            }\n\n            // If the opening time is much greater than the queue time then cancel the trade\n            if (block.timestamp - queuedTrade.queuedTime <= MAX_WAIT_TIME) {\n                _openQueuedTrade(currentParams.queueId, currentParams.price);\n            } else {\n                _cancelQueuedTrade(currentParams.queueId);\n                emit CancelTrade(\n                    queuedTrade.user,\n                    currentParams.queueId,\n                    \"Wait time too high\"\n                );\n            }\n\n            // Track the next queueIndex to be processed for user\n            userNextQueueIndexToProcess[queuedTrade.user] =\n                queuedTrade.userQueueIndex +\n                1;\n        }\n        // Track the next queueIndex to be processed overall\n        nextQueueIdToProcess = params[params.length - 1].queueId + 1;\n    }\n\n    /**\n     * @notice Verifies the option parameter via the signature and unlocks an array of options\n     */\n    function unlockOptions(CloseTradeParams[] calldata optionData) external {\n        _validateKeeper();\n\n        uint32 arrayLength = uint32(optionData.length);\n        for (uint32 i = 0; i < arrayLength; i++) {\n            CloseTradeParams memory params = optionData[i];\n            IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n                params.asset\n            );\n            (, , , , , uint256 expiration, , , ) = optionsContract.options(\n                params.optionId\n            );\n\n            bool isSignerVerifed = _validateSigner(\n                params.expiryTimestamp,\n                params.asset,\n                params.priceAtExpiry,\n                params.signature\n            );\n\n            // Silently fail if the timestamp of the signature is wrong\n            if (expiration != params.expiryTimestamp) {\n                emit FailUnlock(params.optionId, \"Router: Wrong price\");\n                continue;\n            }\n\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailUnlock(\n                    params.optionId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n\n            try\n                optionsContract.unlock(params.optionId, params.priceAtExpiry)\n            {} catch Error(string memory reason) {\n                emit FailUnlock(params.optionId, reason);\n                continue;\n            }\n        }\n    }\n\n    /************************************************\n     *  READ ONLY FUNCTIONS\n     ***********************************************/\n\n    function userQueueCount(address user) public view returns (uint256) {\n        return userQueuedIds[user].length;\n    }\n\n    function userCancelledQueueCount(address user)\n        external\n        view\n        returns (uint256)\n    {\n        return userCancelledQueuedIds[user].length;\n    }\n\n    /************************************************\n     *  INTERNAL FUNCTIONS\n     ***********************************************/\n    function _validateKeeper() private view {\n        require(\n            !isInPrivateKeeperMode || isKeeper[msg.sender],\n            \"Keeper: forbidden\"\n        );\n    }\n\n    function _validateSigner(\n        uint256 timestamp,\n        address asset,\n        uint256 price,\n        bytes memory signature\n    ) internal view returns (bool) {\n        bytes32 digest = ECDSA.toEthSignedMessageHash(\n            keccak256(abi.encodePacked(timestamp, asset, price))\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        return recoveredSigner == publisher;\n    }\n\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n\n        // Check if slippage lies within the bounds\n        bool isSlippageWithinRange = optionsContract.isStrikeValid(\n            queuedTrade.slippage,\n            price,\n            queuedTrade.expectedStrike\n        );\n\n        if (!isSlippageWithinRange) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(\n                queuedTrade.user,\n                queueId,\n                \"Slippage limit exceeds\"\n            );\n\n            return;\n        }\n\n        // Check all the parameters and compute the amount and revised fee\n        uint256 amount;\n        uint256 revisedFee;\n        bool isReferralValid;\n        IBufferBinaryOptions.OptionParams\n            memory optionParams = IBufferBinaryOptions.OptionParams(\n                queuedTrade.expectedStrike,\n                0,\n                queuedTrade.period,\n                queuedTrade.isAbove,\n                queuedTrade.allowPartialFill,\n                queuedTrade.totalFee,\n                queuedTrade.user,\n                queuedTrade.referralCode,\n                queuedTrade.traderNFTId\n            );\n        try optionsContract.checkParams(optionParams) returns (\n            uint256 _amount,\n            uint256 _revisedFee,\n            bool _isReferralValid\n        ) {\n            (amount, revisedFee, isReferralValid) = (\n                _amount,\n                _revisedFee,\n                _isReferralValid\n            );\n        } catch Error(string memory reason) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(queuedTrade.user, queueId, reason);\n            return;\n        }\n\n        // Transfer the fee to the target options contract\n        IERC20 tokenX = IERC20(optionsContract.tokenX());\n        tokenX.transfer(queuedTrade.targetContract, revisedFee);\n\n        // Refund the user in case the trade amount was lesser\n        if (revisedFee < queuedTrade.totalFee) {\n            tokenX.transfer(\n                queuedTrade.user,\n                queuedTrade.totalFee - revisedFee\n            );\n        }\n\n        optionParams.totalFee = revisedFee;\n        optionParams.strike = price;\n        optionParams.amount = amount;\n\n        uint256 optionId = optionsContract.createFromRouter(\n            optionParams,\n            isReferralValid\n        );\n\n        queuedTrade.isQueued = false;\n\n        emit OpenTrade(queuedTrade.user, queueId, optionId);\n    }\n\n    function _cancelQueuedTrade(uint256 queueId) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n        queuedTrade.isQueued = false;\n        IERC20(optionsContract.tokenX()).transfer(\n            queuedTrade.user,\n            queuedTrade.totalFee\n        );\n\n        userCancelledQueuedIds[queuedTrade.user].push(queueId);\n    }\n}"
    },
    {
      "filename": "contracts/tests/test_router.py",
      "content": "import time\nfrom enum import IntEnum\n\nimport brownie\nfrom eth_account import Account\nfrom eth_account.messages import encode_defunct\n\n\nclass OptionType(IntEnum):\n    ALL = 0\n    PUT = 1\n    CALL = 2\n    NONE = 3\n\n\nONE_DAY = 86400\nADDRESS_0 = \"0x0000000000000000000000000000000000000000\"\n\n\nclass Router(object):\n    def __init__(\n        self,\n        accounts,\n        options,\n        generic_pool,\n        total_fee,\n        chain,\n        tokenX,\n        liquidity,\n        options_config,\n        period,\n        is_yes,\n        is_above,\n        router,\n        ibfr_contract,\n        bfr_pool_atm,\n        bfr_binary_options_config_atm,\n        bfr_binary_european_options_atm,\n        publisher,\n    ):\n        self.tokenX_options = options\n        self.publisher = publisher\n        self.options_config = options_config\n        self.generic_pool = generic_pool\n        self.bfr_options = bfr_binary_european_options_atm\n        self.bfr_options_config = bfr_binary_options_config_atm\n        self.bfr_pool = bfr_pool_atm\n        self.total_fee = total_fee\n        self.option_holder = accounts[1]\n        self.accounts = accounts\n        self.owner = accounts[0]\n        self.user_1 = accounts[1]\n        self.user_2 = accounts[2]\n        self.referrer = accounts[3]\n        self.bot = accounts[4]\n        self.option_id = 0\n        self.liquidity = liquidity\n        self.tokenX = tokenX\n        self.bfr = ibfr_contract\n        self.chain = chain\n        self.period = period\n        self.is_yes = is_yes\n        self.is_above = is_above\n        self.router = router\n        self.expected_strike = int(400e8)\n        self.slippage = 100\n        self.allow_partial_fill = False\n        self.index = 11\n        # self.is_trader_nft = False\n        self.referral_code = \"code123\"\n        self.trader_id = 0\n        self.strike = int(400e8)\n        self.option_params = [\n            self.total_fee,\n            120,\n            self.is_above,\n            self.tokenX_options.address,\n            self.expected_strike,\n            self.slippage,\n            self.allow_partial_fill,\n            self.referral_code,\n            0,\n        ]\n\n    def init(self):\n        self.tokenX.approve(\n            self.generic_pool.address, self.liquidity, {\"from\": self.owner}\n        )\n        self.generic_pool.provide(self.liquidity, 0, {\"from\": self.owner})\n        self.bfr.approve(self.bfr_pool.address, 100e18, {\"from\": self.owner})\n        self.bfr_pool.provide(100e18, 0, {\"from\": self.owner})\n\n    def verify_owner(self):\n        assert self.tokenX_options.hasRole(\n            self.tokenX_options.DEFAULT_ADMIN_ROLE(), self.accounts[0]\n        ), \"The admin of the contract should be the account the contract was deployed by\"\n\n    def verify_target_contract_registration(self):\n        with brownie.reverts(\"Router: Unauthorized contract\"):\n            self.router.initiateTrade(\n                *self.option_params,\n                {\"from\": self.owner},\n            )\n\n        with brownie.reverts():  # Wrong role\n            self.router.setContractRegistry(\n                self.tokenX_options.address, True, {\"from\": self.user_2}\n            )\n\n        self.router.setContractRegistry(self.tokenX_options.address, True)\n        assert self.router.contractRegistry(\n            self.tokenX_options.address\n        ), \"Contract not registered\"\n\n    def get_signature(self, timestamp, token, price, publisher=None):\n        # timestamp = 1667208839\n        # token = \"0x32A49a15F8eE598C1EeDc21138DEb23b391f425b\"\n        # price = int(83e8)\n        web3 = brownie.network.web3\n        key = self.publisher.private_key if not publisher else publisher.private_key\n        msg_hash = web3.solidityKeccak(\n            [\"uint256\", \"address\", \"uint256\"], [timestamp, token, int(price)]\n        )\n        signed_message = Account.sign_message(encode_defunct(msg_hash), key)\n\n        def to_32byte_hex(val):\n            return web3.toHex(web3.toBytes(val).rjust(32, b\"\\0\"))\n\n        return to_32byte_hex(signed_message.signature)\n\n    def verify_multitoken_router(self):\n        self.chain.snapshot()\n        self.tokenX.approve(self.router.address, self.total_fee, {\"from\": self.owner})\n        self.tokenX.transfer(self.user_1, self.total_fee, {\"from\": self.owner})\n        self.tokenX.approve(self.router.address, self.total_fee, {\"from\": self.user_1})\n\n        initial_user_tokenX_balance = self.tokenX.balanceOf(self.user_1)\n        initial_user_bfr_balance = self.bfr.balanceOf(self.user_1)\n\n        params = (\n            self.total_fee,\n            self.period,\n            self.is_above,\n            self.tokenX_options.address,\n            self.expected_strike,\n            self.slippage,\n            True,\n            self.referral_code,\n            0,\n        )\n        txn = self.router.initiateTrade(\n            *params,\n            {\"from\": self.user_1},\n        )\n\n        final_user_tokenX_balance = self.tokenX.balanceOf(self.user_1)\n        final_user_bfr_balance = self.bfr.balanceOf(self.user_1)\n\n        assert (\n            initial_user_tokenX_balance - final_user_tokenX_balance == self.total_fee\n            and initial_user_bfr_balance - final_user_bfr_balance == 0\n        )\n\n        fee = 1e18\n        self.bfr.approve(self.router.address, fee, {\"from\": self.owner})\n        self.bfr.transfer(self.user_1, fee, {\"from\": self.owner})\n        self.bfr.approve(self.router.address, fee, {\"from\": self.user_1})\n\n        initial_user_tokenX_balance = self.tokenX.balanceOf(self.user_1)\n        initial_user_bfr_balance = self.bfr.balanceOf(self.user_1)\n\n        params = (\n            fee,\n            self.period,\n            self.is_above,\n            self.bfr_options.address,\n            self.expected_strike,\n            self.slippage,\n            self.allow_partial_fill,\n            self.referral_code,\n            0,\n        )\n        txn = self.router.initiateTrade(\n            *params,\n            {\"from\": self.user_1},\n        )\n\n        final_user_tokenX_balance = self.tokenX.balanceOf(self.user_1)\n        final_user_bfr_balance = self.bfr.balanceOf(self.user_1)\n\n        assert (\n            initial_user_bfr_balance - final_user_bfr_balance == fee\n            and initial_user_tokenX_balance - final_user_tokenX_balance == 0\n        )\n        queued_trade = self.router.queuedTrades(8)\n        open_params_1 = [\n            queued_trade[10],\n            self.tokenX_options.address,\n            self.expected_strike,\n        ]\n        queued_trade = self.router.queuedTrades(9)\n        open_params_2 = [\n            queued_trade[10],\n            self.bfr_options.address,\n            self.expected_strike,\n        ]\n\n        txn = self.router.resolveQueuedTrades(\n            [\n                (\n                    8,\n                    *open_params_1,\n                    self.get_signature(\n                        *open_params_1,\n                    ),\n                ),\n                (\n                    9,\n                    *open_params_2,\n                    self.get_signature(\n                        *open_params_2,\n                    ),\n                ),\n            ],\n            {\"from\": self.bot},\n        )\n        assert txn.events[\"OpenTrade\"][0][\"queueId\"] == 8, \"Wrong trade opened\"\n        assert txn.events[\"OpenTrade\"][1][\"queueId\"] == 9, \"Wrong trade opened\"\n        assert (\n            self.tokenX_options.nextTokenId() == 3\n            and self.bfr_options.nextTokenId() == 1\n        ), \"Wrong options\"\n        self.chain.revert()\n\n    def verify_trade_initiation(self):\n        # Reverts if period less than 5 mins\n        with brownie.reverts():\n            self.router.initiateTrade(\n                self.total_fee,\n                120,\n                self.is_above,\n                self.tokenX_options.address,\n                self.expected_strike,\n                self.slippage,\n                self.allow_partial_fill,\n                self.referral_code,\n                0,\n                {\"from\": self.owner},\n            )\n\n        # Reverts if period greater than 24 hours\n        with brownie.reverts():\n            self.router.initiateTrade(\n                self.total_fee,\n                87400,\n                self.is_above,\n                self.tokenX_options.address,\n                self.expected_strike,\n                self.slippage,\n                self.allow_partial_fill,\n                self.referral_code,\n                0,\n                {\"from\": self.owner},\n            )\n\n        # Reverts if slippage is greater than 5e2\n        with brownie.reverts(\"O34\"):\n            self.router.initiateTrade(\n                self.total_fee,\n                self.period,\n                self.is_above,\n                self.tokenX_options.address,\n                self.expected_strike,\n                int(6e2),  # Slippage higher than max value\n                self.allow_partial_fill,\n                self.referral_code,\n                0,\n                {\"from\": self.owner},\n            )\n\n        with brownie.reverts(\"O35\"):\n            self.router.initiateTrade(\n                1e5,\n                self.period,\n                self.is_above,\n                self.tokenX_options.address,\n                self.expected_strike,\n                int(1e2),  # Slippage higher than max value\n                self.allow_partial_fill,\n                self.referral_code,\n                0,\n                {\"from\": self.owner},\n            )\n\n        self.tokenX.approve(self.router.address, self.total_fee, {\"from\": self.owner})\n        self.tokenX.transfer(self.user_1, self.total_fee, {\"from\": self.owner})\n        self.tokenX.approve(self.router.address, self.total_fee, {\"from\": self.user_1})\n\n        initial_user_tokenX_balance = self.tokenX.balanceOf(self.user_1)\n        initial_router_tokenX_balance = self.tokenX.balanceOf(self.router.address)\n\n        params = (\n            self.total_fee,\n            self.period,\n            self.is_above,\n            self.tokenX_options.address,\n            self.expected_strike,\n            self.slippage,\n            self.allow_partial_fill,\n            self.referral_code,\n            0,\n        )\n        txn = self.router.initiateTrade(\n            *params,\n            {\"from\": self.user_1},\n        )\n\n        final_user_tokenX_balance = self.tokenX.balanceOf(self.user_1)\n        final_router_tokenX_balance = self.tokenX.balanceOf(self.router.address)\n\n        trade = list(self.router.queuedTrades(0))\n\n        trade.pop(10)\n        trade.pop(10)\n        assert trade == [0, 0, self.user_1, *params], \"Wrong data\"\n        assert (\n            initial_user_tokenX_balance - final_user_tokenX_balance == self.total_fee\n        ) and (\n            final_router_tokenX_balance - initial_router_tokenX_balance\n            == self.total_fee\n        ), \"Wrong token transferred\"\n        assert self.router.nextQueueId() == 1, \"Wrong QueueId\"\n        assert (\n            txn.events[\"InitiateTrade\"] and txn.events[\"InitiateTrade\"][\"queueId\"] == 0\n        ), \"Wrong event\"\n\n        txn = self.router.initiateTrade(\n            *params,\n            {\"from\": self.owner},\n        )\n        trade = list(self.router.queuedTrades(1))\n        trade.pop(10)\n        trade.pop(10)\n        assert trade == [1, 0, self.owner, *params], \"Wrong data\"\n        assert self.router.nextQueueId() == 2, \"Wrong QueueId\"\n        assert self.router.userQueueCount(self.owner) == 1, \"Wrong data\"\n        assert self.router.userQueueCount(self.user_1) == 1, \"Wrong data\"\n        assert self.router.userQueuedIds(self.owner, 0) == 1, \"Wrong data\"\n\n    def verify_trade_cancellation(self):\n        with brownie.reverts(\"Router: Forbidden\"):\n            self.router.cancelQueuedTrade(0, {\"from\": self.user_2})\n        with brownie.reverts(\"Router: Forbidden\"):\n            self.router.cancelQueuedTrade(0, {\"from\": self.owner})\n        with brownie.reverts(\"Router: Forbidden\"):\n            self.router.cancelQueuedTrade(0, {\"from\": self.bot})\n\n        initial_user_tokenX_balance = self.tokenX.balanceOf(self.user_1)\n        initial_router_tokenX_balance = self.tokenX.balanceOf(self.router.address)\n\n        txn = self.router.cancelQueuedTrade(0, {\"from\": self.user_1})\n\n        final_user_tokenX_balance = self.tokenX.balanceOf(self.user_1)\n        final_router_tokenX_balance = self.tokenX.balanceOf(self.router.address)\n\n        with brownie.reverts(\"Router: Trade has already been opened\"):\n            self.router.cancelQueuedTrade(0, {\"from\": self.user_1})\n\n        assert (\n            txn.events[\"CancelTrade\"]\n            and txn.events[\"CancelTrade\"][\"reason\"] == \"User Cancelled\"\n        ), \"Trade should have been cancelled\"\n\n        assert not self.router.queuedTrades(0)[self.index], \"Wrong value\"\n        assert (\n            final_user_tokenX_balance - initial_user_tokenX_balance == self.total_fee\n        ) and (\n            initial_router_tokenX_balance - final_router_tokenX_balance\n            == self.total_fee\n        ), \"Wrong token transferred\"\n\n    def verify_trade_execution(self):\n        open_params = [\n            self.chain.time(),\n            self.tokenX_options.address,\n            self.expected_strike * 2,\n        ]\n\n        txn = self.router.resolveQueuedTrades(\n            [\n                (\n                    0,\n                    *open_params,\n                    self.get_signature(\n                        *open_params,\n                    ),\n                )\n            ],\n            {\"from\": self.bot},\n        )\n        try:\n            assert (\n                txn.events[\"CancelTrade\"]\n                and txn.events[\"CancelTrade\"][\"reason\"] == \"Slippage limit exceeds\"\n            ), \"Trade should have been cancelled\"\n            assert txn.events[\"OpenTrade\"], \"Trade should have been cancelled\"\n            should_fail = True\n        except:\n            should_fail = False\n\n        assert not should_fail\n        # Permissible strike bound is [396, 404]\n\n        # Executing at the price just above the highest permissible  should cancel\n        self.chain.snapshot()\n        assert self.router.queuedTrades(1)[self.index], \"Wrong value\"\n        queued_trade = self.router.queuedTrades(1)\n        open_params = [\n            queued_trade[10],\n            self.tokenX_options.address,\n            404e8 + 1,\n        ]\n        txn = self.router.resolveQueuedTrades(\n            [\n                (\n                    1,\n                    *open_params,\n                    self.get_signature(\n                        *open_params,\n                    ),\n                )\n            ],\n            {\"from\": self.bot},\n        )\n        assert (\n            txn.events[\"CancelTrade\"]\n            and txn.events[\"CancelTrade\"][\"reason\"] == \"Slippage limit exceeds\"\n        ), \"Trade should have been cancelled\"\n\n        assert not self.router.queuedTrades(1)[self.index], \"Wrong value\"\n        self.chain.revert()\n\n        # Executing at the price just below the lowest permissible  should cancel\n        self.chain.snapshot()\n        assert self.router.queuedTrades(1)[self.index], \"Wrong value\"\n        queued_trade = self.router.queuedTrades(1)\n        open_params = [\n            queued_trade[10],\n            self.tokenX_options.address,\n            396e8 - 1,\n        ]\n        txn = self.router.resolveQueuedTrades(\n            [\n                (\n                    1,\n                    *open_params,\n                    self.get_signature(\n                        *open_params,\n                    ),\n                )\n            ],\n            {\"from\": self.bot},\n        )\n        final_router_tokenX_balance = self.tokenX.balanceOf(self.router.address)\n        assert final_router_tokenX_balance == 0, \"Wrong router balance\"\n        assert (\n            txn.events[\"CancelTrade\"]\n            and txn.events[\"CancelTrade\"][\"reason\"] == \"Slippage limit exceeds\"\n        ), \"Trade should have been cancelled\"\n        assert not self.router.queuedTrades(1)[self.index], \"Wrong value\"\n        self.chain.revert()\n\n        # Executing at the lowest permissible price should create option\n        self.chain.snapshot()\n        queued_trade = self.router.queuedTrades(1)\n        open_params = [\n            queued_trade[10],\n            self.tokenX_options.address,\n            396e8,\n        ]\n        txn = self.router.resolveQueuedTrades(\n            [\n                (\n                    1,\n                    *open_params,\n                    self.get_signature(\n                        *open_params,\n                    ),\n                )\n            ],\n            {\"from\": self.bot},\n        )\n        assert txn.events[\"OpenTrade\"], \"Trade should have been cancelled\"\n\n        self.chain.revert()\n\n        # Executing at the highest permissible price should create option\n        initial_user_tokenX_balance = self.tokenX.balanceOf(self.user_1)\n        queued_trade = self.router.queuedTrades(1)\n        open_params = [\n            queued_trade[10],\n            self.tokenX_options.address,\n            404e8,\n        ]\n        txn = self.router.resolveQueuedTrades(\n            [\n                (\n                    1,\n                    *open_params,\n                    self.get_signature(\n                        *open_params,\n                    ),\n                )\n            ],\n            {\"from\": self.bot},\n        )\n\n        final_user_tokenX_balance = self.tokenX.balanceOf(self.user_1)\n        final_router_tokenX_balance = self.tokenX.balanceOf(self.router.address)\n\n        assert final_router_tokenX_balance == 0, \"Wrong router balance\"\n        assert (\n            final_user_tokenX_balance == initial_user_tokenX_balance\n        ), \"Wrong user balance\"\n        assert txn.events[\"OpenTrade\"], \"Trade should have been cancelled\"\n        assert not self.router.queuedTrades(1)[self.index], \"Wrong value\"\n\n        # Initiating a trade with amount greater than 5% of available liquidity\n        self.tokenX.transfer(self.user_2, self.total_fee, {\"from\": self.owner})\n        self.tokenX.approve(self.router.address, self.total_fee, {\"from\": self.user_2})\n        params = (\n            self.total_fee,\n            self.period,\n            self.is_above,\n            self.tokenX_options.address,\n            self.expected_strike,\n            self.slippage,\n            self.allow_partial_fill,\n            self.referral_code,\n            0,\n        )\n        txn = self.router.initiateTrade(\n            *params,\n            {\"from\": self.user_2},\n        )\n\n        # Executing the above trade should refund the user\n        self.chain.snapshot()\n        queued_trade = self.router.queuedTrades(2)\n        open_params = [\n            queued_trade[10],\n            self.tokenX_options.address,\n            404e8,\n        ]\n        initial_user_tokenX_balance = self.tokenX.balanceOf(self.user_2)\n        txn = self.router.resolveQueuedTrades(\n            [\n                (\n                    2,\n                    *open_params,\n                    self.get_signature(\n                        *open_params,\n                    ),\n                )\n            ],\n            {\"from\": self.bot},\n        )\n\n        final_user_tokenX_balance = self.tokenX.balanceOf(self.user_2)\n        final_router_tokenX_balance = self.tokenX.balanceOf(self.router.address)\n\n        assert final_router_tokenX_balance == 0, \"Wrong router balance\"\n        assert (\n            final_user_tokenX_balance - initial_user_tokenX_balance\n        ) == self.total_fee - self.tokenX_options.options(1)[7], \"Wrong user balance\"\n        assert txn.events[\"OpenTrade\"], \"Trade should have been cancelled\"\n\n        self.chain.revert()\n\n        # Executing after the max wait time should cancel\n        self.chain.sleep(61)\n\n        txn = self.router.resolveQueuedTrades(\n            [\n                (\n                    2,\n                    *open_params,\n                    self.get_signature(\n                        *open_params,\n                    ),\n                )\n            ],\n            {\"from\": self.bot},\n        )\n        assert (\n            txn.events[\"CancelTrade\"]\n            and txn.events[\"CancelTrade\"][\"reason\"] == \"Wait time too high\"\n        ), \"Trade should have been cancelled\"\n\n        # Executing multiple trades at once\n        self.tokenX.transfer(self.user_2, self.total_fee, {\"from\": self.owner})\n        self.tokenX.approve(self.router.address, self.total_fee, {\"from\": self.user_2})\n        self.tokenX.transfer(self"
    }
  ]
}