{
  "Title": "[L-01] Consider using ERC1155Holder instead of ERC1155Receiver due to OpenZeppelin's latest `v5.0` release candidate changes",
  "Content": "\nView OpenZeppelin's v5.0 release candidate changes [here](https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v5.0.0-rc.0).\n\n*There is 1 instance of this issue:*\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L9C1-L9C97\n\n```solidity\nFile: src/VirtualAccount.sol\n9: import {ERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/VirtualAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\nimport {ERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IVirtualAccount, Call, PayableCall} from \"./interfaces/IVirtualAccount.sol\";\nimport {IRootPort} from \"./interfaces/IRootPort.sol\";\n\n/// @title VirtualAccount - Contract for managing a virtual user account on the Root Chain\ncontract VirtualAccount is IVirtualAccount, ERC1155Receiver {\n    using SafeTransferLib for address;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override userAddress;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override localPortAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Virtual Account.\n     * @param _userAddress Address of the user account.\n     * @param _localPortAddress Address of the root port contract.\n     */\n    constructor(address _userAddress, address _localPortAddress) {\n        userAddress = _userAddress;\n        localPortAddress = _localPortAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawNative(uint256 _amount) external override requiresApprovedCaller {\n        msg.sender.safeTransferETH(_amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC20(address _token, uint256 _amount) external override requiresApprovedCaller {\n        _token.safeTransfer(msg.sender, _amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC721(address _token, uint256 _tokenId) external override requiresApprovedCaller {\n        ERC721(_token).transferFrom(address(this), msg.sender, _tokenId);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function call(Call[] calldata calls) external override requiresApprovedCaller returns (bytes[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n\n        for (uint256 i = 0; i < length;) {\n            bool success;\n            Call calldata _call = calls[i];\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function payableCall(PayableCall[] calldata calls) public payable returns (bytes[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        PayableCall calldata _call;\n        for (uint256 i = 0; i < length;) {\n            _call = calls[i];\n            uint256 val = _call.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n\n            bool success;\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call{value: val}(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        if (msg.value != valAccumulator) revert CallFailed();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the approved to use the virtual account. Either the owner or an approved router.\n    modifier requiresApprovedCaller() {\n        if (!IRootPort(localPortAddress).isRouterApproved(this, msg.sender)) {\n            if (msg.sender != userAddress) {\n                revert UnauthorizedCaller();\n            }\n        }\n        _;\n    }\n}"
    }
  ]
}