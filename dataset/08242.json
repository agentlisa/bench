{
  "Title": "[M-07] NFT of NFT collection or NFT drop collection can be locked when calling _mint or mintCountTo function to mint it to a contract that does not support ERC721 protocol",
  "Content": "_Submitted by rbserver, also found by 0xc0ffEE, 0xsolstars, berndartmueller, Bnke0x0, brgltd, cccz, CodingNameKiki, Deivitto, Diraco, Dravee, durianSausage, erictee, ignacio, IllIllI, joestakey, KIntern&#95;NA, Lambda, LeoS, Noah3o6, oyc&#95;109, ReyAdmirado, Rohan16, Rolezn, Sm4rty, Treasure-Seeker, zeesaw, and zkhorse_\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274>\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187>\n\n### Impact\n\nWhen calling the following `_mint` or `mintCountTo` function for minting an NFT of a NFT collection or NFT drop collection, the OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is used to mint the NFT to a receiver. If such receiver is a contract that does not support the ERC721 protocol, the NFT will be locked and cannot be retrieved.\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274>\n\n      function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n        require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n        require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n        unchecked {\n          // Number of tokens cannot overflow 256 bits.\n          tokenId = ++latestTokenId;\n          require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n          cidToMinted[tokenCID] = true;\n          _tokenCIDs[tokenId] = tokenCID;\n          _mint(msg.sender, tokenId);\n          emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n        }\n      }\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187>\n\n      function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n        require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n\n        unchecked {\n          // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n          firstTokenId = latestTokenId + 1;\n        }\n        latestTokenId = latestTokenId + count;\n        require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n        for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n          _mint(to, i);\n          unchecked {\n            ++i;\n          }\n        }\n      }\n\nFor reference, [OpenZeppelin's documentation for `_mint`](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721-\\_mint-address-uint256-) states: \"Usage of this method is discouraged, use \\_safeMint whenever possible\".\n\n### Proof of Concept\n\nThe following steps can occur when minting an NFT of a NFT collection or NFT drop collection.\n\n1.  The [`_mint`](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274) or [`mintCountTo`](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187) function is called with `msg.sender` or the `to` input corresponding to a contract.\n2.  The OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is called with `msg.sender` or `to` used in Step 1 as the receiver address.\n3.  Since calling the OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function does not execute the same contract's [`_checkOnERC721Received`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L400-L422) function, it is unknown if the receiving contract inherits from the `IERC721ReceiverUpgradeable` interface and implements the `onERC721Received` function or not. It is possible that the receiving contract does not support the ERC721 protocol, which causes the minted NFT to be locked.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L271> can be changed to the following code.\n\n    _safeMint(msg.sender, tokenId);\n\nAlso, <https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L182> can be changed to the following code.\n\n    _safeMint(to, i);\n\n**[HardlyDifficult (Foundation) confirmed and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/183#issuecomment-1219513491):**\n > Agree will fix.\n> \n> Generally we are inclined to skip \"safe\" by default - it can introduce reentrancy & reverting risk and increase gas costs. When a user is making an action to buy or mint an NFT for themselves, it's very clear that they are trying to acquire an NFT - so using safe to ensure that they support NFTs seems like a Low risk concern and we are inclined to avoid potential reentrancy/reverts and save costs for the common user paths.\n> \n> However in this scenario the part that stood out as different is instead of minting for yourself (the msg.sender) we support minting to an arbitrary `to` address, e.g. for an airdrop type use case. Here specifically it does seem that sending to a list of addresses could be error prone, where a contract address without 721 support was incorrectly captured. To guard against that scenario specifically we are moving forward with this change.\n> \n> Then for consistency we have decided to use safeMint for both collection types because the difference is nuanced.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-foundation-drop-contest",
  "Code": [
    {
      "filename": "contracts/NFTCollection.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}"
    },
    {
      "filename": "contracts/NFTDropCollection.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTDropCollectionMint.sol\";\n\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/roles/AdminRole.sol\";\nimport \"./mixins/roles/MinterRole.sol\";\nimport \"./mixins/shared/Constants.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A contract to batch mint a collection of NFTs.\n * @notice A 10% royalty to the creator is included which may be split with collaborators.\n * @dev A collection can have up to 4,294,967,295 (2^32-1) tokens\n */\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ContextUpgradeable,\n  ERC165Upgradeable,\n  AccessControlUpgradeable,\n  AdminRole,\n  MinterRole,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using Strings for uint256;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address to pay the proceeds/royalties for the collection.\n   * @dev If this is set to address(0) then the proceeds go to the creator.\n   */\n  address payable private paymentAddress;\n  // 96 bits free space\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `<tokenId>.json` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for `tokenId`: \"1\" with `baseURI`: \"ipfs://foo/\" is \"ipfs://foo/1.json\".\n   * @return The base URI used by this collection.\n   */\n  string public baseURI;\n\n  /****** Slot 2 ******/\n  /**\n   * @notice The hash of the revealed baseURI for the collection.\n   * @dev This can be used to verify that the content was not changed after NFTs were minted.\n   * @return bytes32(0) if the content has been revealed.\n   * In pre-reveal state this is set to bytes32(1) when the final content is unknown\n   * otherwise set to keccak256(finalContentBaseURI).\n   */\n  bytes32 public postRevealBaseURIHash;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice Emitted when the collection is revealed.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  event URIUpdated(string baseURI, bytes32 postRevealBaseURIHash);\n\n  modifier validBaseURI(string calldata _baseURI) {\n    require(bytes(_baseURI).length > 0, \"NFTDropCollection: `_baseURI` must be set\");\n    _;\n  }\n\n  modifier onlyWhileUnrevealed() {\n    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\n    _;\n  }\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * This account is the default admin for this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   * @param _baseURI The base URI for the collection.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param _maxTokenId The max token id for this collection.\n   * @param _approvedMinter An optional address to grant the MINTER_ROLE.\n   * Set to address(0) if only admins should be granted permission to mint.\n   * @param _paymentAddress The address that will receive royalties and mint payments.\n   */\n  function initialize(\n    address payable _creator,\n    string calldata _name,\n    string calldata _symbol,\n    string calldata _baseURI,\n    bytes32 _postRevealBaseURIHash,\n    uint32 _maxTokenId,\n    address _approvedMinter,\n    address payable _paymentAddress\n  ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n    require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\n    require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\n\n    // Initialize the NFT\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, _maxTokenId);\n\n    // Initialize royalties\n    if (_paymentAddress != address(0)) {\n      // If no payment address was defined, use the creator's address.\n      paymentAddress = _paymentAddress;\n    }\n\n    // Initialize URI\n    baseURI = _baseURI;\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n\n    // Initialize access control\n    AdminRole._initializeAdminRole(_creator);\n    if (_approvedMinter != address(0)) {\n      MinterRole._initializeMinterRole(_approvedMinter);\n    }\n  }\n\n  /**\n   * @notice Allows the collection admin to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyAdmin` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyAdmin {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint `count` number of NFTs for the `to` address.\n   * @dev This is only callable by an address with either the MINTER_ROLE or the DEFAULT_ADMIN_ROLE.\n   * @param count The number of NFTs to mint.\n   * @param to The address to mint the NFTs for.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   */\n  function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n    require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n\n    unchecked {\n      // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n      firstTokenId = latestTokenId + 1;\n    }\n    latestTokenId = latestTokenId + count;\n    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n    for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n      _mint(to, i);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Allows a collection admin to reveal the collection's final content.\n   * @dev Once revealed, the collection's content is immutable.\n   * Use `updatePreRevealContent` to update content while unrevealed.\n   * @param _baseURI The base URI of the final content for this collection.\n   */\n  function reveal(string calldata _baseURI) external onlyAdmin validBaseURI(_baseURI) onlyWhileUnrevealed {\n    // `postRevealBaseURIHash` == 0 indicates that the collection has been revealed.\n    delete postRevealBaseURIHash;\n\n    // Set the new base URI.\n    baseURI = _baseURI;\n    emit URIUpdated(_baseURI, \"\");\n  }\n\n  /**\n   * @notice Allows a collection admin to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyAdmin {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyAdmin {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  /**\n   * @notice Allows a collection admin to update the pre-reveal content.\n   * @dev Use `reveal` to reveal the final content for this collection.\n   * @param _baseURI The base URI of the pre-reveal content.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n    external\n    validBaseURI(_baseURI)\n    onlyWhileUnrevealed\n    onlyAdmin\n  {\n    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n    baseURI = _baseURI;\n    emit URIUpdated(baseURI, postRevealBaseURIHash);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    super._burn(tokenId);\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(\n    uint256 /* tokenId */\n  ) public view override returns (address payable creatorPaymentAddress) {\n    creatorPaymentAddress = paymentAddress;\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @notice Returns whether the collection has been revealed.\n   * @dev Once revealed, the collection's content is immutable.\n   * @return revealed True if the collection has been revealed.\n   */\n  function isRevealed() external view returns (bool revealed) {\n    revealed = postRevealBaseURIHash == bytes32(0);\n  }\n\n  /**\n   * @notice Get the number of tokens which can still be minted.\n   * @return count The max number of additional NFTs that can be minted by this collection.\n   */\n  function numberOfTokensAvailableToMint() external view returns (uint256 count) {\n    // Mint ensures that latestTokenId is always <= maxTokenId\n    unchecked {\n      count = maxTokenId - latestTokenId;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    if (interfaceId == type(INFTDropCollectionMint).interfaceId) {\n      interfaceSupported = true;\n    } else {\n      interfaceSupported = super.supportsInterface(interfaceId);\n    }\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    _requireMinted(tokenId);\n\n    return string.concat(baseURI, tokenId.toString(), \".json\");\n  }\n}"
    },
    {
      "filename": "contracts/token/ERC721/ERC721Upgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {ERC721Utils} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Utils.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC721Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC-721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC721\n    struct ERC721Storage {\n        // Token name\n        string _name;\n\n        // Token symbol\n        string _symbol;\n\n        mapping(uint256 tokenId => address) _owners;\n\n        mapping(address owner => uint256) _balances;\n\n        mapping(uint256 tokenId => address) _tokenApprovals;\n\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tok"
    }
  ]
}