{
  "Title": "M-5: Lender can take borrower's collateral before first payment due",
  "Content": "# Issue M-5: Lender can take borrower's collateral before first payment due \n\nSource: https://github.com/sherlock-audit/2023-03-teller-judging/issues/92 \n\n## Found by \ncducrest-brainbot, dacian\n## Summary\nFor PaymentCycleType.Seconds if PaymentDefault < PaymentCycle, Lender can take Borrower's collateral before first payment is due. If PaymentDefault > 0 but very small, Lender can do this almost immediately after accepting borrower's bid. This is especially bad as the Market Operator who controls these parameters can also be the Lender.\n\n## Vulnerability Detail\nLender calls CollateralManager.withdraw() [L254](https://github.com/teller-protocol/teller-protocol-v2/blob/cb66c9e348cdf1fd6d9b0416a49d663f5b6a693c/packages/contracts/contracts/CollateralManager.sol#L254), which calls TellerV2.isLoanDefaulted() [L930](https://github.com/teller-protocol/teller-protocol-v2/blob/cb66c9e348cdf1fd6d9b0416a49d663f5b6a693c/packages/contracts/contracts/TellerV2.sol#L930), which bypasses the 1 day grace period & doesn't take into account when first payment is due.\n\n## Impact\nBorrower loses their collateral before they can even make their first repayment, almost instantly if PaymentDefault > 0 but very small.\n\n## Code Snippet\nPut this test in TellerV2_Test.sol:\n```solidity\nfunction test_LenderQuicklyTakesCollateral() public {\n\tMarketRegistry mReg = (MarketRegistry)(payable(address(tellerV2.marketRegistry())));\n\n\t// payment cycle 3600 seconds, payment default 1 second\n\t// payment will be in default almost immediately upon being\n\t// accepted, even though the first payment is not due for much longer\n\t// than the default time\n\tuint32 PAYMENT_CYCLE_SEC   = 3600;\n\tuint32 PAYMENT_DEFAULT_SEC = 1;\n\n\tvm.startPrank(address(marketOwner));\n\tmReg.setPaymentCycle(marketId1, PaymentCycleType.Seconds, PAYMENT_CYCLE_SEC);\n\tmReg.setPaymentDefaultDuration(marketId1, PAYMENT_DEFAULT_SEC);\n\tvm.stopPrank();\n\n\t//Submit bid as borrower\n\tuint256 bidId = submitCollateralBid();\n\t// Accept bid as lender\n\tacceptBid(bidId);\n\n\t// almost immediately take the collateral as the lender, even though\n\t// the first payment wasn't due for much later\n\tICollateralManager cMgr = tellerV2.collateralManager();\n\tskip(PAYMENT_DEFAULT_SEC+1);\n\tcMgr.withdraw(bidId);\n\t// try again to verify the collateral has been taken\n\tvm.expectRevert(\"No collateral balance for asset\");\n\tcMgr.withdraw(bidId);\n}\n``` \n\n## Tool used\nManual Review\n\n## Recommendation\nChange the calculations done as a consequence of calling TellerV2.isLoanDefaulted() to take into account when first payment is due; see similar code which does this TellerV2.calculateNextDueDate() [L886-L899](https://github.com/teller-protocol/teller-protocol-v2/blob/cb66c9e348cdf1fd6d9b0416a49d663f5b6a693c/packages/contracts/contracts/TellerV2.sol#L886-L899). Lender should only be able to take Borrower's collateral after the Borrower has missed their first payment deadline by PaymentDefault seconds.\n\nConsider enforcing sensible minimums for PaymentDefault. If PaymentDefault = 0 no liquidations will ever be possible as TellerV2._canLiquidateLoan() [L963](https://github.com/teller-protocol/teller-protocol-v2/blob/cb66c9e348cdf1fd6d9b0416a49d663f5b6a693c/packages/contracts/contracts/TellerV2.sol#L963) will always return false, so perhaps it shouldn't be possible to set PaymentDefault = 0.\n\n\n \n\n\n\n\n\n\n## Discussion\n\n**devdacian**\n\nEscalate for 10 USDC\n\nIn previous audit contests, the issue of the Borrower being prematurely liquidated/having their collateral seized has been judged as a High finding:\n\n1) High - Loan can be written off by anybody before overdue delay expires - [Union Finance, Sherlock](https://github.com/sherlock-audit/2022-10-union-finance-judging/issues/115)\n2) High - Users can be liquidated prematurely because calculation understates value of underlying position [Blueberry, Sherlock](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/126)\n3) High - Lender is able to seize the collateral by changing the loan parameters [Abra, C4](https://code4rena.com/reports/2022-04-abranft/#h-04-lender-is-able-to-seize-the-collateral-by-changing-the-loan-parameters)\n4) High - Users may be liquidated right after taking maximal debt [Papr, C4](https://code4rena.com/reports/2022-12-backed/#h-04-users-may-be-liquidated-right-after-taking-maximal-debt)\n\nPlease explain the objective standard of truth that when applied to these previous submissions where Borrowers are prematurely liquidated/have their collateral seized judges them all as High, but when applied to my submission where Borrowers are prematurely liquidated/have their collateral seized judges it only medium.\n\nAlternatively, please judge my submission as a High finding in line with the historical judging in both Sherlock & C4.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> In previous audit contests, the issue of the Borrower being prematurely liquidated/having their collateral seized has been judged as a High finding:\n> \n> 1) High - Loan can be written off by anybody before overdue delay expires - [Union Finance, Sherlock](https://github.com/sherlock-audit/2022-10-union-finance-judging/issues/115)\n> 2) High - Users can be liquidated prematurely because calculation understates value of underlying position [Blueberry, Sherlock](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/126)\n> 3) High - Lender is able to seize the collateral by changing the loan parameters [Abra, C4](https://code4rena.com/reports/2022-04-abranft/#h-04-lender-is-able-to-seize-the-collateral-by-changing-the-loan-parameters)\n> 4) High - Users may be liquidated right after taking maximal debt [Papr, C4](https://code4rena.com/reports/2022-12-backed/#h-04-users-may-be-liquidated-right-after-taking-maximal-debt)\n> \n> Please explain the objective standard of truth that when applied to these previous submissions where Borrowers are prematurely liquidated/have their collateral seized judges them all as High, but when applied to my submission where Borrowers are prematurely liquidated/have their collateral seized judges it only medium.\n> \n> Alternatively, please judge my submission as a High finding in line with the historical judging in both Sherlock & C4.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Trumpero**\n\nThis scenario only occurs when the PaymentDefaultDuration variable has been set too low by the admin/owner (1 in the POC), so I believe it is an unlikely occurrence, and should be a medium issue. It is not similar to the other cases mentioned by Watson in the past contests, as they do not require any manipulations/mistakes from the admin.\n\n**hrishibhat**\n\nEscalation rejected\n\nValid medium\nThis requires an admin error/malice to set a low default duration to cause loss of funds. \nAs opposed to the other past issues mentioned in the escalation have a logical flaw in the code to cause loss of funds. \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid medium\n> This requires an admin error/malice to set a low default duration to cause loss of funds. \n> As opposed to the other past issues mentioned in the escalation have a logical flaw in the code to cause loss of funds. \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n**ethereumdegen**\n\nThis is a non-issue because borrowers will be able to validate the default duration of a loan before agreeing to it.  If they agree to a very short default duration, that is their choice.    It does make sense to enforce a default duration longer than 1 payment cycle for ux purposes but i see that as an optional 'nice to have.'  it will just be important to clearly communicate the default duration to borrowers.  \n\n**IAm0x52**\n\nSponsor has acknowledged this risk\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/62",
  "Code": [
    {
      "filename": "packages/contracts/contracts/CollateralManager.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\n// Interfaces\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"./interfaces/ICollateralManager.sol\";\nimport { Collateral, CollateralType, ICollateralEscrowV1 } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\nimport \"./interfaces/ITellerV2.sol\";\n\ncontract CollateralManager is OwnableUpgradeable, ICollateralManager {\n    /* Storage */\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    ITellerV2 public tellerV2;\n    address private collateralEscrowBeacon; // The address of the escrow contract beacon\n    mapping(uint256 => address) public _escrows; // bidIds -> collateralEscrow\n    // bidIds -> validated collateral info\n    mapping(uint256 => CollateralInfo) internal _bidCollaterals;\n\n    /**\n     * Since collateralInfo is mapped (address assetAddress => Collateral) that means\n     * that only a single tokenId per nft per loan can be collateralized.\n     * Ex. Two bored apes cannot be used as collateral for a single loan.\n     */\n    struct CollateralInfo {\n        EnumerableSetUpgradeable.AddressSet collateralAddresses;\n        mapping(address => Collateral) collateralInfo;\n    }\n\n    /* Events */\n    event CollateralEscrowDeployed(uint256 _bidId, address _collateralEscrow);\n    event CollateralCommitted(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n    event CollateralClaimed(uint256 _bidId);\n    event CollateralDeposited(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n    event CollateralWithdrawn(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId,\n        address _recipient\n    );\n\n    /* Modifiers */\n    modifier onlyTellerV2() {\n        require(_msgSender() == address(tellerV2), \"Sender not authorized\");\n        _;\n    }\n\n    /* External Functions */\n\n    /**\n     * @notice Initializes the collateral manager.\n     * @param _collateralEscrowBeacon The address of the escrow implementation.\n     * @param _tellerV2 The address of the protocol.\n     */\n    function initialize(address _collateralEscrowBeacon, address _tellerV2)\n        external\n        initializer\n    {\n        collateralEscrowBeacon = _collateralEscrowBeacon;\n        tellerV2 = ITellerV2(_tellerV2);\n        __Ownable_init_unchained();\n    }\n\n    /**\n     * @notice Sets the address of the Beacon contract used for the collateral escrow contracts.\n     * @param _collateralEscrowBeacon The address of the Beacon contract.\n     */\n    function setCollateralEscrowBeacon(address _collateralEscrowBeacon)\n        external\n        reinitializer(2)\n    {\n        collateralEscrowBeacon = _collateralEscrowBeacon;\n    }\n\n    /**\n     * @notice Checks to see if a bid is backed by collateral.\n     * @param _bidId The id of the bid to check.\n     */\n\n    function isBidCollateralBacked(uint256 _bidId)\n        public\n        virtual\n        returns (bool)\n    {\n        return _bidCollaterals[_bidId].collateralAddresses.length() > 0;\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral assets.\n     * @return validation_ Boolean indicating if the collateral balances were validated.\n     */\n    function commitCollateral(\n        uint256 _bidId,\n        Collateral[] calldata _collateralInfo\n    ) public returns (bool validation_) {\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        (validation_, ) = checkBalances(borrower, _collateralInfo);\n\n        if (validation_) {\n            for (uint256 i; i < _collateralInfo.length; i++) {\n                Collateral memory info = _collateralInfo[i];\n                _commitCollateral(_bidId, info);\n            }\n        }\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's collateral balance and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral asset.\n     * @return validation_ Boolean indicating if the collateral balance was validated.\n     */\n    function commitCollateral(\n        uint256 _bidId,\n        Collateral calldata _collateralInfo\n    ) public returns (bool validation_) {\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        validation_ = _checkBalance(borrower, _collateralInfo);\n        if (validation_) {\n            _commitCollateral(_bidId, _collateralInfo);\n        }\n    }\n\n    /**\n     * @notice Re-checks the validity of a borrower's collateral balance committed to a bid.\n     * @param _bidId The id of the associated bid.\n     * @return validation_ Boolean indicating if the collateral balance was validated.\n     */\n    function revalidateCollateral(uint256 _bidId)\n        external\n        returns (bool validation_)\n    {\n        Collateral[] memory collateralInfos = getCollateralInfo(_bidId);\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        (validation_, ) = _checkBalances(borrower, collateralInfos, true);\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances.\n     * @param _borrowerAddress The address of the borrower holding the collateral.\n     * @param _collateralInfo Additional information about the collateral assets.\n     */\n    function checkBalances(\n        address _borrowerAddress,\n        Collateral[] calldata _collateralInfo\n    ) public returns (bool validated_, bool[] memory checks_) {\n        return _checkBalances(_borrowerAddress, _collateralInfo, false);\n    }\n\n    /**\n     * @notice Deploys a new collateral escrow and deposits collateral.\n     * @param _bidId The associated bidId of the collateral escrow.\n     */\n    function deployAndDeposit(uint256 _bidId) external onlyTellerV2 {\n        if (isBidCollateralBacked(_bidId)) {\n            (address proxyAddress, ) = _deployEscrow(_bidId);\n            _escrows[_bidId] = proxyAddress;\n\n            for (\n                uint256 i;\n                i < _bidCollaterals[_bidId].collateralAddresses.length();\n                i++\n            ) {\n                _deposit(\n                    _bidId,\n                    _bidCollaterals[_bidId].collateralInfo[\n                        _bidCollaterals[_bidId].collateralAddresses.at(i)\n                    ]\n                );\n            }\n\n            emit CollateralEscrowDeployed(_bidId, proxyAddress);\n        }\n    }\n\n    /**\n     * @notice Gets the address of a deployed escrow.\n     * @notice _bidId The bidId to return the escrow for.\n     * @return The address of the escrow.\n     */\n    function getEscrow(uint256 _bidId) external view returns (address) {\n        return _escrows[_bidId];\n    }\n\n    /**\n     * @notice Gets the collateral info for a given bid id.\n     * @param _bidId The bidId to return the collateral info for.\n     * @return infos_ The stored collateral info.\n     */\n    function getCollateralInfo(uint256 _bidId)\n        public\n        view\n        returns (Collateral[] memory infos_)\n    {\n        CollateralInfo storage collateral = _bidCollaterals[_bidId];\n        address[] memory collateralAddresses = collateral\n            .collateralAddresses\n            .values();\n        infos_ = new Collateral[](collateralAddresses.length);\n        for (uint256 i; i < collateralAddresses.length; i++) {\n            infos_[i] = collateral.collateralInfo[collateralAddresses[i]];\n        }\n    }\n\n    /**\n     * @notice Gets the collateral asset amount for a given bid id on the TellerV2 contract.\n     * @param _bidId The ID of a bid on TellerV2.\n     * @param _collateralAddress An address used as collateral.\n     * @return amount_ The amount of collateral of type _collateralAddress.\n     */\n    function getCollateralAmount(uint256 _bidId, address _collateralAddress)\n        public\n        view\n        returns (uint256 amount_)\n    {\n        amount_ = _bidCollaterals[_bidId]\n            .collateralInfo[_collateralAddress]\n            ._amount;\n    }\n\n    /**\n     * @notice Withdraws deposited collateral from the created escrow of a bid that has been successfully repaid.\n     * @param _bidId The id of the bid to withdraw collateral for.\n     */\n    function withdraw(uint256 _bidId) external {\n        BidState bidState = tellerV2.getBidState(_bidId);\n        if (bidState == BidState.PAID) {\n            _withdraw(_bidId, tellerV2.getLoanBorrower(_bidId));\n        } else if (tellerV2.isLoanDefaulted(_bidId)) {\n            _withdraw(_bidId, tellerV2.getLoanLender(_bidId));\n            emit CollateralClaimed(_bidId);\n        } else {\n            revert(\"collateral cannot be withdrawn\");\n        }\n    }\n\n    /**\n     * @notice Sends the deposited collateral to a liquidator of a bid.\n     * @notice Can only be called by the protocol.\n     * @param _bidId The id of the liquidated bid.\n     * @param _liquidatorAddress The address of the liquidator to send the collateral to.\n     */\n    function liquidateCollateral(uint256 _bidId, address _liquidatorAddress)\n        external\n        onlyTellerV2\n    {\n        if (isBidCollateralBacked(_bidId)) {\n            BidState bidState = tellerV2.getBidState(_bidId);\n            require(\n                bidState == BidState.LIQUIDATED,\n                \"Loan has not been liquidated\"\n            );\n            _withdraw(_bidId, _liquidatorAddress);\n        }\n    }\n\n    /* Internal Functions */\n\n    /**\n     * @notice Deploys a new collateral escrow.\n     * @param _bidId The associated bidId of the collateral escrow.\n     */\n    function _deployEscrow(uint256 _bidId)\n        internal\n        virtual\n        returns (address proxyAddress_, address borrower_)\n    {\n        proxyAddress_ = _escrows[_bidId];\n        // Get bid info\n        borrower_ = tellerV2.getLoanBorrower(_bidId);\n        if (proxyAddress_ == address(0)) {\n            require(borrower_ != address(0), \"Bid does not exist\");\n\n            BeaconProxy proxy = new BeaconProxy(\n                collateralEscrowBeacon,\n                abi.encodeWithSelector(\n                    ICollateralEscrowV1.initialize.selector,\n                    _bidId\n                )\n            );\n            proxyAddress_ = address(proxy);\n        }\n    }\n\n    /*\n        * @notice Deploys a new collateral escrow contract. Deposits collateral into a collateral escrow.\n        * @param _bidId The associated bidId of the collateral escrow.\n        * @param collateralInfo The collateral info to deposit.\n\n    */\n    function _deposit(uint256 _bidId, Collateral memory collateralInfo)\n        internal\n        virtual\n    {\n        require(collateralInfo._amount > 0, \"Collateral not validated\");\n        (address escrowAddress, address borrower) = _deployEscrow(_bidId);\n        ICollateralEscrowV1 collateralEscrow = ICollateralEscrowV1(\n            escrowAddress\n        );\n        // Pull collateral from borrower & deposit into escrow\n        if (collateralInfo._collateralType == CollateralType.ERC20) {\n            IERC20Upgradeable(collateralInfo._collateralAddress).transferFrom(\n                borrower,\n                address(this),\n                collateralInfo._amount\n            );\n            IERC20Upgradeable(collateralInfo._collateralAddress).approve(\n                escrowAddress,\n                collateralInfo._amount\n            );\n            collateralEscrow.depositAsset(\n                CollateralType.ERC20,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                0\n            );\n        } else if (collateralInfo._collateralType == CollateralType.ERC721) {\n            IERC721Upgradeable(collateralInfo._collateralAddress).transferFrom(\n                borrower,\n                address(this),\n                collateralInfo._tokenId\n            );\n            IERC721Upgradeable(collateralInfo._collateralAddress).approve(\n                escrowAddress,\n                collateralInfo._tokenId\n            );\n            collateralEscrow.depositAsset(\n                CollateralType.ERC721,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                collateralInfo._tokenId\n            );\n        } else if (collateralInfo._collateralType == CollateralType.ERC1155) {\n            bytes memory data;\n            IERC1155Upgradeable(collateralInfo._collateralAddress)\n                .safeTransferFrom(\n                    borrower,\n                    address(this),\n                    collateralInfo._tokenId,\n                    collateralInfo._amount,\n                    data\n                );\n            IERC1155Upgradeable(collateralInfo._collateralAddress)\n                .setApprovalForAll(escrowAddress, true);\n            collateralEscrow.depositAsset(\n                CollateralType.ERC1155,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                collateralInfo._tokenId\n            );\n        } else {\n            revert(\"Unexpected collateral type\");\n        }\n        emit CollateralDeposited(\n            _bidId,\n            collateralInfo._collateralType,\n            collateralInfo._collateralAddress,\n            collateralInfo._amount,\n            collateralInfo._tokenId\n        );\n    }\n\n    /**\n     * @notice Withdraws collateral to a given receiver's address.\n     * @param _bidId The id of the bid to withdraw collateral for.\n     * @param _receiver The address to withdraw the collateral to.\n     */\n    function _withdraw(uint256 _bidId, address _receiver) internal virtual {\n        for (\n            uint256 i;\n            i < _bidCollaterals[_bidId].collateralAddresses.length();\n            i++\n        ) {\n            // Get collateral info\n            Collateral storage collateralInfo = _bidCollaterals[_bidId]\n                .collateralInfo[\n                    _bidCollaterals[_bidId].collateralAddresses.at(i)\n                ];\n            // Withdraw collateral from escrow and send it to bid lender\n            ICollateralEscrowV1(_escrows[_bidId]).withdraw(\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                _receiver\n            );\n            emit CollateralWithdrawn(\n                _bidId,\n                collateralInfo._collateralType,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                collateralInfo._tokenId,\n                _receiver\n            );\n        }\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's collateral balance and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral asset.\n     */\n    function _commitCollateral(\n        uint256 _bidId,\n        Collateral memory _collateralInfo\n    ) internal virtual {\n        CollateralInfo storage collateral = _bidCollaterals[_bidId];\n        collateral.collateralAddresses.add(_collateralInfo._collateralAddress);\n        collateral.collateralInfo[\n            _collateralInfo._collateralAddress\n        ] = _collateralInfo;\n        emit CollateralCommitted(\n            _bidId,\n            _collateralInfo._collateralType,\n            _collateralInfo._collateralAddress,\n            _collateralInfo._amount,\n            _collateralInfo._tokenId\n        );\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances.\n     * @param _borrowerAddress The address of the borrower holding the collateral.\n     * @param _collateralInfo Additional information about the collateral assets.\n     * @param _shortCircut  if true, will return immediately until an invalid balance\n     */\n    function _checkBalances(\n        address _borrowerAddress,\n        Collateral[] memory _collateralInfo,\n        bool _shortCircut\n    ) internal virtual returns (bool validated_, bool[] memory checks_) {\n        checks_ = new bool[](_collateralInfo.length);\n        validated_ = true;\n        for (uint256 i; i < _collateralInfo.length; i++) {\n            bool isValidated = _checkBalance(\n                _borrowerAddress,\n                _collateralInfo[i]\n            );\n            checks_[i] = isValidated;\n            if (!isValidated) {\n                validated_ = false;\n                if (_shortCircut) {\n                    return (validated_, checks_);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's single collateral balance.\n     * @param _borrowerAddress The address of the borrower holding the collateral.\n     * @param _collateralInfo Additional information about the collateral asset.\n     * @return validation_ Boolean indicating if the collateral balances were validated.\n     */\n    function _checkBalance(\n        address _borrowerAddress,\n        Collateral memory _collateralInfo\n    ) internal virtual returns (bool) {\n        CollateralType collateralType = _collateralInfo._collateralType;\n\n        if (collateralType == CollateralType.ERC20) {\n            return\n                _collateralInfo._amount <=\n                IERC20Upgradeable(_collateralInfo._collateralAddress).balanceOf(\n                    _borrowerAddress\n                );\n        } else if (collateralType == CollateralType.ERC721) {\n            return\n                _borrowerAddress ==\n                IERC721Upgradeable(_collateralInfo._collateralAddress).ownerOf(\n                    _collateralInfo._tokenId\n                );\n        } else if (collateralType == CollateralType.ERC1155) {\n            return\n                _collateralInfo._amount <=\n                IERC1155Upgradeable(_collateralInfo._collateralAddress)\n                    .balanceOf(_borrowerAddress, _collateralInfo._tokenId);\n        } else {\n            return false;\n        }\n    }\n\n    // On NFT Received handlers\n\n    function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return\n            bytes4(\n                keccak256(\"onERC721Received(address,address,uint256,bytes)\")\n            );\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256 id,\n        uint256 value,\n        bytes calldata\n    ) external returns (bytes4) {\n        return\n            bytes4(\n                keccak256(\n                    \"onERC1155Received(address,address,uint256,uint256,bytes)\"\n                )\n            );\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata\n    ) external returns (bytes4) {\n        require(\n            _ids.length == 1,\n            \"Only allowed one asset batch transfer per transaction.\"\n        );\n        return\n            bytes4(\n                keccak256(\n                    \"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"\n                )\n            );\n    }\n}"
    },
    {
      "filename": "packages/contracts/contracts/TellerV2.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"./ProtocolFee.sol\";\nimport \"./TellerV2Storage.sol\";\nimport \"./TellerV2Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\n// Interfaces\nimport \"./interfaces/IMarketRegistry.sol\";\nimport \"./interfaces/IReputationManager.sol\";\nimport \"./interfaces/ITellerV2.sol\";\nimport { Collateral } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./libraries/NumbersLib.sol\";\nimport { BokkyPooBahsDateTimeLibrary as BPBDTL } from \"./libraries/DateTimeLib.sol\";\nimport { V2Calculations, PaymentCycleType } from \"./libraries/V2Calculations.sol\";\n\n/* Errors */\n/**\n * @notice This error is reverted when the action isn't allowed\n * @param bidId The id of the bid.\n * @param action The action string (i.e: 'repayLoan', 'cancelBid', 'etc)\n * @param message The message string to return to the user explaining why the tx was reverted\n */\nerror ActionNotAllowed(uint256 bidId, string action, string message);\n\n/**\n * @notice This error is reverted when repayment amount is less than the required minimum\n * @param bidId The id of the bid the borrower is attempting to repay.\n * @param payment The payment made by the borrower\n * @param minimumOwed The minimum owed value\n */\nerror PaymentNotMinimum(uint256 bidId, uint256 payment, uint256 minimumOwed);\n\ncontract TellerV2 is\n    ITellerV2,\n    OwnableUpgradeable,\n    ProtocolFee,\n    PausableUpgradeable,\n    TellerV2Storage,\n    TellerV2Context\n{\n    using Address for address;\n    using SafeERC20 for ERC20;\n    using NumbersLib for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /** Events */\n\n    /**\n     * @notice This event is emitted when a new bid is submitted.\n     * @param bidId The id of the bid submitted.\n     * @param borrower The address of the bid borrower.\n     * @param metadataURI URI for additional bid information as part of loan bid.\n     */\n    event SubmittedBid(\n        uint256 indexed bidId,\n        address indexed borrower,\n        address receiver,\n        bytes32 indexed metadataURI\n    );\n\n    /**\n     * @notice This event is emitted when a bid has been accepted by a lender.\n     * @param bidId The id of the bid accepted.\n     * @param lender The address of the accepted bid lender.\n     */\n    event AcceptedBid(uint256 indexed bidId, address indexed lender);\n\n    /**\n     * @notice This event is emitted when a previously submitted bid has been cancelled.\n     * @param bidId The id of the cancelled bid.\n     */\n    event CancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when market owner has cancelled a pending bid in their market.\n     * @param bidId The id of the bid funded.\n     *\n     * Note: The `CancelledBid` event will also be emitted.\n     */\n    event MarketOwnerCancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a payment is made towards an active loan.\n     * @param bidId The id of the bid/loan to which the payment was made.\n     */\n    event LoanRepayment(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanRepaid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanLiquidated(uint256 indexed bidId, address indexed liquidator);\n\n    /**\n     * @notice This event is emitted when a fee has been paid related to a bid.\n     * @param bidId The id of the bid.\n     * @param feeType The name of the fee being paid.\n     * @param amount The amount of the fee being paid.\n     */\n    event FeePaid(\n        uint256 indexed bidId,\n        string indexed feeType,\n        uint256 indexed amount\n    );\n\n    /** Modifiers */\n\n    /**\n     * @notice This modifier is used to check if the state of a bid is pending, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier pendingBid(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.PENDING) {\n            revert ActionNotAllowed(_bidId, _action, \"Bid must be pending\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to check if the state of a loan has been accepted, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier acceptedLoan(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.ACCEPTED) {\n            revert ActionNotAllowed(_bidId, _action, \"Loan must be accepted\");\n        }\n\n        _;\n    }\n\n    /** Constant Variables **/\n\n    uint8 public constant CURRENT_CODE_VERSION = 9;\n\n    uint32 public constant LIQUIDATION_DELAY = 86400; //ONE DAY IN SECONDS\n\n    /** Constructor **/\n\n    constructor(address trustedForwarder) TellerV2Context(trustedForwarder) {}\n\n    /** External Functions **/\n\n    /**\n     * @notice Initializes the proxy.\n     * @param _protocolFee The fee collected by the protocol for loan processing.\n     * @param _marketRegistry The address of the market registry contract for the protocol.\n     * @param _reputationManager The address of the reputation manager contract.\n     * @param _lenderCommitmentForwarder The address of the lender commitment forwarder contract.\n     * @param _collateralManager The address of the collateral manager contracts.\n     * @param _lenderManager The address of the lender manager contract for loans on the protocol.\n     */\n    function initialize(\n        uint16 _protocolFee,\n        address _marketRegistry,\n        address _reputationManager,\n        address _lenderCommitmentForwarder,\n        address _collateralManager,\n        address _lenderManager\n    ) external initializer {\n        __ProtocolFee_init(_protocolFee);\n\n        __Pausable_init();\n\n        require(\n            _lenderCommitmentForwarder.isContract(),\n            \"LenderCommitmentForwarder must be a contract\"\n        );\n        lenderCommitmentForwarder = _lenderCommitmentForwarder;\n\n        require(\n            _marketRegistry.isContract(),\n            \"MarketRegistry must be a contract\"\n        );\n        marketRegistry = IMarketRegistry(_marketRegistry);\n\n        require(\n            _reputationManager.isContract(),\n            \"ReputationManager must be a contract\"\n        );\n        reputationManager = IReputationManager(_reputationManager);\n\n        require(\n            _collateralManager.isContract(),\n            \"CollateralManager must be a contract\"\n        );\n        collateralManager = ICollateralManager(_collateralManager);\n\n        _setLenderManager(_lenderManager);\n    }\n\n    function setLenderManager(address _lenderManager)\n        external\n        reinitializer(8)\n        onlyOwner\n    {\n        _setLenderManager(_lenderManager);\n    }\n\n    function _setLenderManager(address _lenderManager)\n        internal\n        onlyInitializing\n    {\n        require(\n            _lenderManager.isContract(),\n            \"LenderManager must be a contract\"\n        );\n        lenderManager = ILenderManager(_lenderManager);\n    }\n\n    /**\n     * @notice Gets the metadataURI for a bidId.\n     * @param _bidId The id of the bid to return the metadataURI for\n     * @return metadataURI_ The metadataURI for the bid, as a string.\n     */\n    function getMetadataURI(uint256 _bidId)\n        public\n        view\n        returns (string memory metadataURI_)\n    {\n        // Check uri mapping first\n        metadataURI_ = uris[_bidId];\n        // If the URI is not present in the mapping\n        if (\n            keccak256(abi.encodePacked(metadataURI_)) ==\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 // hardcoded constant of keccak256('')\n        ) {\n            // Return deprecated bytes32 uri as a string\n            uint256 convertedURI = uint256(bids[_bidId]._metadataURI);\n            metadataURI_ = StringsUpgradeable.toHexString(convertedURI, 32);\n        }\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol to set a new reputation manager contract.\n     * @param _reputationManager The new contract address.\n     */\n    function setReputationManager(address _reputationManager) public onlyOwner {\n        reputationManager = IReputationManager(_reputationManager);\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan without Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan with Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     * @param _collateralInfo Additional information about the collateral asset.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver,\n        Collateral[] calldata _collateralInfo\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n\n        bool validation = collateralManager.commitCollateral(\n            bidId_,\n            _collateralInfo\n        );\n\n        require(\n            validation == true,\n            \"Collateral balance could not be validated\"\n        );\n    }\n\n    function _submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) internal virtual returns (uint256 bidId_) {\n        address sender = _msgSenderForMarket(_marketplaceId);\n\n        (bool isVerified, ) = marketRegistry.isVerifiedBorrower(\n            _marketplaceId,\n            sender\n        );\n\n        require(isVerified, \"Not verified borrower\");\n\n        require(\n            !marketRegistry.isMarketClosed(_marketplaceId),\n            \"Market is closed\"\n        );\n\n        // Set response bid ID.\n        bidId_ = bidId;\n\n        // Create and store our bid into the mapping\n        Bid storage bid = bids[bidId];\n        bid.borrower = sender;\n        bid.receiver = _receiver != address(0) ? _receiver : bid.borrower;\n        bid.marketplaceId = _marketplaceId;\n        bid.loanDetails.lendingToken = ERC20(_lendingToken);\n        bid.loanDetails.principal = _principal;\n        bid.loanDetails.loanDuration = _duration;\n        bid.loanDetails.timestamp = uint32(block.timestamp);\n\n        // Set payment cycle type based on market setting (custom or monthly)\n        (bid.ter"
    }
  ]
}