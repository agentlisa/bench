{
  "Title": "M-12: When bad debts are cleared, there will be some untracked funds",
  "Content": "# Issue M-12: When bad debts are cleared, there will be some untracked funds \n\nSource: https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/130 \n\n## Found by \nTrumpero, ether\\_sky\n## Summary\nIn the `market`, all `funds` should be tracked accurately, whether they are currently held, `borrowed` by `borrowers`, or repaid in the future.\nTo ensure this, the `market` has a sophisticated tracking system that functions effectively.\nHowever, when bad debts are cleared, there will be some untracked funds in the market.\n## Vulnerability Detail\nUsers have the option to deposit into the `market` directly or into specific `fixed rate pools`.\nWhen `borrowers` `borrow` funds from the `fixed rate pool`, they are backed by the `fixed deposits` first.\nIf there is a shortfall in funds, the remaining `debt` is supported by `floating assets`.\nThe movement of funds between `fixed borrowers` and `fixed depositors` is straightforward outside of the `tracking system`.\nThe `tracking system` within the `market` primarily monitors funds within the `variable pool` itself.\nTo simplify the scenario, let's assume there are no `fixed depositors` involved.\n\nFirst, there are `extraordinary earnings`, including `variable backup fees`, `late fixed repayment penalties`, etc.\nThe `earnings accumulator` is responsible for collecting these earnings from `extraordinary` sources and subsequently distributing them gradually and smoothly.\nFor this purpose, there is a `earningsAccumulator` variable.\n```solidity\nfunction depositAtMaturity(\n  uint256 maturity,\n  uint256 assets,\n  uint256 minAssetsRequired,\n  address receiver\n) external whenNotPaused whenNotFrozen returns (uint256 positionAssets) {\n    earningsAccumulator += backupFee;\n}\n```\nWhen users deposit funds into the `variable pool`, the `floatingAssets` increase by the deposited amounts as well as any additional earnings from the `earnings accumulator`.\n```solidity\nfunction afterDeposit(uint256 assets, uint256) internal override whenNotPaused whenNotFrozen {\n  updateFloatingAssetsAverage();\n  uint256 treasuryFee = updateFloatingDebt();\n  uint256 earnings = accrueAccumulatedEarnings();  // @audit, here\n  floatingAssets += earnings + assets;  // @audit, here\n  depositToTreasury(treasuryFee);\n  emitMarketUpdate();\n}\n```\nFunds borrowed by `variable rate borrowers` are tracked using the `floatingDebt` variable, while funds borrowed by `fixed rate borrowers` are tracked using the `floatingBackupBorrowed` variable.\nAdditionally, there is an `unassignedEarnings` variable for each `maturity pool`, which represents upcoming `fees` from `borrowers`.\nThese earnings are added to the `floatingAssets` whenever there are changes in the `market`, such as `borrowers` repaying their `debt` , depositors withdrawing their funds etc.\n```solidity\nfunction depositAtMaturity(\n  uint256 maturity,\n  uint256 assets,\n  uint256 minAssetsRequired,\n  address receiver\n) external whenNotPaused whenNotFrozen returns (uint256 positionAssets) {\n  uint256 backupEarnings = pool.accrueEarnings(maturity); // @audit, here\n  floatingAssets += backupEarnings;\n}\n```\nWhile this variable is important, it is not directly involved in the `tracking system`.\n\nLet's describe the vulnerability.\nA user deposits `5 DAI` into the `DAI market`.\nWhen clearing the `bad debt`, the amount is deducted from the `earnings accumulator`.\n```solidity\nfunction clearBadDebt(address borrower) external {\n  if (totalBadDebt != 0) {\n    earningsAccumulator -= totalBadDebt;  // @audit, here\n    emit SpreadBadDebt(borrower, totalBadDebt);\n  }\n}\n```\nFor testing purpose, `ALICE` borrows funds at a `fixed rate` and repays them after maturity, and the `penalty fee` from this is added to the `earnings accumulator`.\n```solidity\nfunction noTransferRepayAtMaturity(\n  uint256 maturity,\n  uint256 positionAssets,\n  uint256 maxAssets,\n  address borrower,\n  bool canDiscount\n) internal returns (uint256 actualRepayAssets) {\n  if (block.timestamp < maturity) {\n    if (canDiscount) {\n      ...\n    } else {\n      actualRepayAssets = debtCovered;\n    }\n  } else {\n    actualRepayAssets = debtCovered + debtCovered.mulWadDown((block.timestamp - maturity) * penaltyRate);\n\n    // all penalties go to the earnings accumulator\n    earningsAccumulator += actualRepayAssets - debtCovered;  // @audit, here\n  }\n}\n```\nConsequently, the `DAI market` has enough `earningsAccumulator` for clearing upcoming `bad debt` in the test. (see below log)\n```solidity\nearningsAccumulator before clear bad debt       ==>   112859178081957033645\n```\nNow this user `borrows` `1 DAI` from the `DAI market` at a specific `maturity`.\nAt this point, there is no `bad debt` in the `market` and the current `tracking values` are as follows:\n```solidity\nfloatingAssets before clear bad debt            ==>   5005767123287671232800\nfloatingDebt before clear bad debt              ==>   0\nfloatingBackupBorrowed before clear bad debt    ==>   1000000000000000000\nearningsAccumulator before clear bad debt       ==>   112859178081957033645\nowed weth balance before clear bad debt         ==>   1000000000000000000 7671232876712328\ncalculated dai balance before clear bad debt    ==>   5117626301369628266445\ndai balance before clear bad debt               ==>   5117626301369628266445\n```\nThe current `DAI balance` is equal to `floatingAssets - floatingDebt - floatingBackupBorrowed + earningsAccumulator`.\nEverything is correct.\n\nNow, consider `1 DAI` equals to `5000 WETH`.\nGiven sufficient `collateral`, this user can `borrow` `5000 WEHT` from the `WETH market`.\nIf the price of `DAI` drops to `1000 WETH`, this user can be `liquidated`.\n\nWhen `borrowers` `borrow` `fixed rate funds`, the `principal` is backed by `floating assets`(assuming no `fixed rate depositors`), and the `fee` is added to the `unassignedEarnings` of that `maturity pool`.\n```solidity\nfunction borrowAtMaturity(\n  uint256 maturity,\n  uint256 assets,\n  uint256 maxAssets,\n  address receiver,\n  address borrower\n) external whenNotPaused whenNotFrozen returns (uint256 assetsOwed) {\n  {\n    uint256 backupDebtAddition = pool.borrow(assets);  // @audit, here\n    if (backupDebtAddition != 0) {\n      uint256 newFloatingBackupBorrowed = floatingBackupBorrowed + backupDebtAddition;\n      depositToTreasury(updateFloatingDebt());\n      if (newFloatingBackupBorrowed + floatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n        revert InsufficientProtocolLiquidity();\n      }\n      floatingBackupBorrowed = newFloatingBackupBorrowed; // @audit, here\n    }\n  }\n\n  {\n    // if account doesn't have a current position, add it to the list\n    FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n    if (position.principal == 0) {\n      Account storage account = accounts[borrower];\n      account.fixedBorrows = account.fixedBorrows.setMaturity(maturity);\n    }\n\n    // calculate what portion of the fees are to be accrued and what portion goes to earnings accumulator\n    (uint256 newUnassignedEarnings, uint256 newBackupEarnings) = pool.distributeEarnings(\n      chargeTreasuryFee(fee),\n      assets\n    );\n    if (newUnassignedEarnings != 0) pool.unassignedEarnings += newUnassignedEarnings;  // @audit, here\n    collectFreeLunch(newBackupEarnings);\n\n    fixedBorrowPositions[maturity][borrower] = FixedLib.Position(position.principal + assets, position.fee + fee);\n  }\n}\n```\nThese `unassignedEarnings` are later added to the `floatingAssets` whenever changes occur in the `pool`.\nHowever, when clearing `bad debt`, the sum of `principal` and `fee` is deducted from the `earningsAccumulator` if it's enough to cover the `bad debt`.\nThe `floatingBackupBorrowed` is reduced as `principal` (means that these funds returns to the `variable pool`), but there is no provision for the `fee`.\n```solidity\nfunction clearBadDebt(address borrower) external {\n  while (packedMaturities != 0) {\n    if (packedMaturities & 1 != 0) {\n      FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n      uint256 badDebt = position.principal + position.fee; // @audit, here\n      ...\n      floatingBackupBorrowed -= fixedPools[maturity].repay(position.principal); // @audit, here\n    }\n    packedMaturities >>= 1;\n    maturity += FixedLib.INTERVAL;\n  }\n  if (totalBadDebt != 0) {\n    earningsAccumulator -= totalBadDebt; // @audit, here\n    emit SpreadBadDebt(borrower, totalBadDebt);\n  }\n  emitMarketUpdate();\n}\n```\nIn reality, the `fee` is reflected in the `unassignedEarnings` of that `maturity pool`, requiring an appropriate mechanism to update these `unassignedEarnings`.\nIf this user is the last user of this `maturity pool`, there is no way to convert these `unassignedEarnings` to the `tracking system`.\nConsequently, funds equal to the `unassignedEarnings` remain untracked and unused.\nOr if this user is not the last user of this `maturity pool`, these untracked `unassignedEarnings` can be allocated to late `fixed depositors`.\nBelow are tracking states in the `DAI market` after `liquidation`:\n```solidity\nfloatingAssets after clear bad debt             ==>   5057139572755893855767\nfloatingDebt after clear bad debt               ==>   0\nfloatingBackupBorrowed after clear bad debt     ==>   0\nearningsAccumulator after clear bad debt        ==>   55421917808101804495\nowed weth balance after clear bad debt          ==>   0 0\ncalculated dai balance after clear bad debt     ==>   5112561490563995660262\ndai balance after clear bad debt                ==>   5112569161796872372590\n***************\ndifference          ==>   7671232876712328\ncleared fee         ==>   7671232876712328\nunassignedEarnings  ==>   7671232876712328\n```\nThe difference between the actual `DAI balance` and `tracked balance` is equal to the `unassignedEarnings`.\n\nPlease add below test to the `Market.t.sol`.\n```solidity\nfunction testClearBadDebtBeforeMaturity() external {\n  market.deposit(5 ether, address(this));\n  market.deposit(5_000 ether, ALICE);\n  marketWETH.deposit(100_000 ether, ALICE);\n\n  uint256 maxVal = type(uint256).max;\n  vm.prank(ALICE);\n  market.borrowAtMaturity(4 weeks, 1_00 ether, maxVal, ALICE, ALICE);\n\n  vm.warp(12 weeks);\n  market.repayAtMaturity(4 weeks, maxVal, maxVal, ALICE);\n\n  uint256 maturity_16 = 16 weeks;\n  market.borrowAtMaturity(maturity_16, 1 ether, maxVal, address(this), address(this));\n  (uint256 principal_before, uint256 fee_before) = market.fixedBorrowPositions(maturity_16, address(this));\n  uint256 calculatedBalanceBefore = market.floatingAssets() - market.floatingDebt() - market.floatingBackupBorrowed() + market.earningsAccumulator();\n\n  console2.log(\"floatingAssets before clear bad debt            ==>  \", market.floatingAssets());\n  console2.log(\"floatingDebt before clear bad debt              ==>  \", market.floatingDebt());\n  console2.log(\"floatingBackupBorrowed before clear bad debt    ==>  \", market.floatingBackupBorrowed());\n  console2.log(\"earningsAccumulator before clear bad debt       ==>  \", market.earningsAccumulator());\n  console2.log(\"owed weth balance before clear bad debt         ==>  \", principal_before, fee_before);\n  console2.log(\"calculated dai balance before clear bad debt    ==>  \", calculatedBalanceBefore);\n  console2.log(\"dai balance before clear bad debt               ==>  \", asset.balanceOf(address(market)));\n\n  \n  daiPriceFeed.setPrice(5_000e18);\n  uint256 borrowAmount = 5000 ether;\n  marketWETH.borrowAtMaturity(maturity_16, borrowAmount, borrowAmount * 2, address(this), address(this));\n\n  daiPriceFeed.setPrice(1_000e18);\n  weth.mint(ALICE, 1_000_000 ether);\n  vm.prank(ALICE);\n  weth.approve(address(marketWETH), maxVal);\n\n  vm.prank(ALICE);\n  marketWETH.liquidate(address(this), maxVal, market);\n\n  (uint256 principal_after, uint256 fee_after) = market.fixedBorrowPositions(maturity_16, address(this));\n  uint256 calculatedBalanceafter = market.floatingAssets() - market.floatingDebt() - market.floatingBackupBorrowed() + market.earningsAccumulator();\n\n  console2.log(\"***************\");\n  console2.log(\"floatingAssets after clear bad debt             ==>  \", market.floatingAssets());\n  console2.log(\"floatingDebt after clear bad debt               ==>  \", market.floatingDebt());\n  console2.log(\"floatingBackupBorrowed after clear bad debt     ==>  \", market.floatingBackupBorrowed());\n  console2.log(\"earningsAccumulator after clear bad debt        ==>  \", market.earningsAccumulator());\n  console2.log(\"owed weth balance after clear bad debt          ==>  \", principal_after, fee_after);\n  console2.log(\"calculated dai balance after clear bad debt     ==>  \", calculatedBalanceafter);\n  console2.log(\"dai balance after clear bad debt                ==>  \", asset.balanceOf(address(market)));\n\n\n  (, , uint256 unassignedEarnings_after, ) = market.fixedPools(maturity_16);\n  console2.log(\"***************\");\n  console2.log(\"difference          ==>  \", asset.balanceOf(address(market)) - calculatedBalanceafter);\n  console2.log(\"cleared fee         ==>  \", fee_before);\n  console2.log(\"unassignedEarnings  ==>  \", unassignedEarnings_after);\n}\n```\n## Impact\nThis vulnerability can happen under normal situation and there should be no untracked funds in the `market`.\nNobody will detect these untracked funds and they won't be used.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/8f6ef1b0868d3ea3a98a5ab7e8b3a164857681d7/protocol/contracts/Market.sol#L253\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/8f6ef1b0868d3ea3a98a5ab7e8b3a164857681d7/protocol/contracts/Market.sol#L714\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/8f6ef1b0868d3ea3a98a5ab7e8b3a164857681d7/protocol/contracts/Market.sol#L244-L245\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/8f6ef1b0868d3ea3a98a5ab7e8b3a164857681d7/protocol/contracts/Market.sol#L652-L655\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/8f6ef1b0868d3ea3a98a5ab7e8b3a164857681d7/protocol/contracts/Market.sol#L514\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/8f6ef1b0868d3ea3a98a5ab7e8b3a164857681d7/protocol/contracts/Market.sol#L299-L306\n## Tool used\n\nManual Review\n\n## Recommendation\n```solidity\nfunction clearBadDebt(address borrower) external {\n  if (msg.sender != address(auditor)) revert NotAuditor();\n\n  floatingAssets += accrueAccumulatedEarnings();\n  Account storage account = accounts[borrower];\n  uint256 accumulator = earningsAccumulator;\n  uint256 totalBadDebt = 0;\n  uint256 packedMaturities = account.fixedBorrows;\n  uint256 maturity = packedMaturities & ((1 << 32) - 1);\n  packedMaturities = packedMaturities >> 32;\n  while (packedMaturities != 0) {\n    if (packedMaturities & 1 != 0) {\n      FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n      uint256 badDebt = position.principal + position.fee;\n      if (accumulator >= badDebt) {\n        RewardsController memRewardsController = rewardsController;\n        if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n        accumulator -= badDebt;\n        totalBadDebt += badDebt;\n        floatingBackupBorrowed -= fixedPools[maturity].repay(position.principal);\n        delete fixedBorrowPositions[maturity][borrower];\n        account.fixedBorrows = account.fixedBorrows.clearMaturity(maturity);\n\n        emit RepayAtMaturity(maturity, msg.sender, borrower, badDebt, badDebt);\n\n+        if (fixedPools[maturity].borrowed == position.principal) {\n+          earningsAccumulator += fixedPools[maturity].unassignedEarnings;\n+          fixedPools[maturity].unassignedEarnings = 0;\n+        }\n      }\n    }\n    packedMaturities >>= 1;\n    maturity += FixedLib.INTERVAL;\n  }\n  if (account.floatingBorrowShares != 0 && (accumulator = previewRepay(accumulator)) != 0) {\n    (uint256 badDebt, ) = noTransferRefund(accumulator, borrower);\n    totalBadDebt += badDebt;\n  }\n  if (totalBadDebt != 0) {\n    earningsAccumulator -= totalBadDebt;\n    emit SpreadBadDebt(borrower, totalBadDebt);\n  }\n  emitMarketUpdate();\n}\n```\nOr we need more sophisticated solution.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/exactly/protocol/pull/724\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/247",
  "Code": [
    {
      "filename": "protocol/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { ERC4626, ERC20, SafeTransferLib } from \"solmate/src/mixins/ERC4626.sol\";\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\nimport { RewardsController } from \"./RewardsController.sol\";\nimport { FixedLib } from \"./utils/FixedLib.sol\";\nimport { Auditor } from \"./Auditor.sol\";\n\ncontract Market is Initializable, AccessControlUpgradeable, PausableUpgradeable, ERC4626 {\n  using FixedPointMathLib for int256;\n  using FixedPointMathLib for uint256;\n  using FixedPointMathLib for uint128;\n  using SafeTransferLib for ERC20;\n  using FixedLib for FixedLib.Pool;\n  using FixedLib for FixedLib.Position;\n  using FixedLib for uint256;\n\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant EMERGENCY_ADMIN_ROLE = keccak256(\"EMERGENCY_ADMIN_ROLE\");\n\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  Auditor public immutable auditor;\n\n  /// @notice Tracks account's fixed deposit positions by maturity, account and position.\n  mapping(uint256 => mapping(address => FixedLib.Position)) public fixedDepositPositions;\n  /// @notice Tracks account's fixed borrow positions by maturity, account and position.\n  mapping(uint256 => mapping(address => FixedLib.Position)) public fixedBorrowPositions;\n  /// @notice Tracks fixed pools state by maturity.\n  mapping(uint256 => FixedLib.Pool) public fixedPools;\n\n  /// @notice Tracks fixed deposit and borrow map and floating borrow shares of an account.\n  mapping(address => Account) public accounts;\n\n  /// @notice Amount of assets lent by the floating pool to the fixed pools.\n  uint256 public floatingBackupBorrowed;\n  /// @notice Amount of assets lent by the floating pool to accounts.\n  uint256 public floatingDebt;\n\n  /// @notice Accumulated earnings from extraordinary sources to be gradually distributed.\n  uint256 public earningsAccumulator;\n  /// @notice Rate per second to be charged to delayed fixed pools borrowers after maturity.\n  uint256 public penaltyRate;\n  /// @notice Rate charged to the fixed pool to be retained by the floating pool for initially providing liquidity.\n  uint256 public backupFeeRate;\n  /// @notice Damp speed factor to update `floatingAssetsAverage` when `floatingAssets` is higher.\n  uint256 public dampSpeedUp;\n  /// @notice Damp speed factor to update `floatingAssetsAverage` when `floatingAssets` is lower.\n  uint256 public dampSpeedDown;\n\n  /// @notice Number of fixed pools to be active at the same time.\n  uint8 public maxFuturePools;\n  /// @notice Last time the accumulator distributed earnings.\n  uint32 public lastAccumulatorAccrual;\n  /// @notice Last time the floating debt was updated.\n  uint32 public lastFloatingDebtUpdate;\n  /// @notice Last time the floating assets average was updated.\n  uint32 public lastAverageUpdate;\n\n  /// @notice Interest rate model contract used to get the borrow rates.\n  InterestRateModel public interestRateModel;\n\n  /// @notice Factor used for gradual accrual of earnings to the floating pool.\n  uint128 public earningsAccumulatorSmoothFactor;\n  /// @notice Percentage factor that represents the liquidity reserves that can't be borrowed.\n  uint128 public reserveFactor;\n\n  /// @notice Amount of floating assets deposited to the pool.\n  uint256 public floatingAssets;\n  /// @notice Average of the floating assets to get fixed borrow rates and prevent rate manipulation.\n  uint256 public floatingAssetsAverage;\n\n  /// @notice Total amount of floating borrow shares assigned to floating borrow accounts.\n  uint256 public totalFloatingBorrowShares;\n\n  /// @dev gap from deprecated state.\n  /// @custom:oz-renamed-from floatingUtilization\n  uint256 private __gap;\n\n  /// @notice Address of the treasury that will receive the allocated earnings.\n  address public treasury;\n  /// @notice Rate to be charged by the treasury to floating and fixed borrows.\n  uint256 public treasuryFeeRate;\n\n  /// @notice Address of the rewards controller that will accrue rewards for accounts operating with the Market.\n  RewardsController public rewardsController;\n\n  /// @notice Flag to prevent new borrows and deposits.\n  bool public isFrozen;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor(ERC20 asset_, Auditor auditor_) ERC4626(asset_, \"\", \"\") {\n    auditor = auditor_;\n\n    _disableInitializers();\n  }\n\n  /// @notice Initializes the contract.\n  /// @dev can only be called once.\n  function initialize(\n    string calldata assetSymbol,\n    uint8 maxFuturePools_,\n    uint128 earningsAccumulatorSmoothFactor_,\n    InterestRateModel interestRateModel_,\n    uint256 penaltyRate_,\n    uint256 backupFeeRate_,\n    uint128 reserveFactor_,\n    uint256 dampSpeedUp_,\n    uint256 dampSpeedDown_\n  ) external initializer {\n    __AccessControl_init();\n    __Pausable_init();\n\n    lastAccumulatorAccrual = uint32(block.timestamp);\n    lastFloatingDebtUpdate = uint32(block.timestamp);\n    lastAverageUpdate = uint32(block.timestamp);\n\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    setAssetSymbol(assetSymbol);\n    setMaxFuturePools(maxFuturePools_);\n    setEarningsAccumulatorSmoothFactor(earningsAccumulatorSmoothFactor_);\n    setInterestRateModel(interestRateModel_);\n    setPenaltyRate(penaltyRate_);\n    setBackupFeeRate(backupFeeRate_);\n    setReserveFactor(reserveFactor_);\n    setDampSpeed(dampSpeedUp_, dampSpeedDown_);\n  }\n\n  /// @notice Borrows a certain amount from the floating pool.\n  /// @param assets amount to be sent to receiver and repaid by borrower.\n  /// @param receiver address that will receive the borrowed assets.\n  /// @param borrower address that will repay the borrowed assets.\n  /// @return borrowShares shares corresponding to the borrowed assets.\n  function borrow(\n    uint256 assets,\n    address receiver,\n    address borrower\n  ) external whenNotPaused whenNotFrozen returns (uint256 borrowShares) {\n    spendAllowance(borrower, assets);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    depositToTreasury(updateFloatingDebt());\n\n    borrowShares = previewBorrow(assets);\n\n    uint256 newFloatingDebt = floatingDebt + assets;\n    floatingDebt = newFloatingDebt;\n    // check if the underlying liquidity that the account wants to withdraw is borrowed, also considering the reserves\n    if (floatingBackupBorrowed + newFloatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n      revert InsufficientProtocolLiquidity();\n    }\n\n    totalFloatingBorrowShares += borrowShares;\n    accounts[borrower].floatingBorrowShares += borrowShares;\n\n    emit Borrow(msg.sender, receiver, borrower, assets, borrowShares);\n    emitMarketUpdate();\n\n    auditor.checkBorrow(this, borrower);\n    asset.safeTransfer(receiver, assets);\n  }\n\n  /// @notice Repays a certain amount of assets to the floating pool.\n  /// @param assets assets to be subtracted from the borrower's accountability.\n  /// @param borrower address of the account that has the debt.\n  /// @return actualRepay the actual amount that should be transferred into the protocol.\n  /// @return borrowShares subtracted shares from the borrower's accountability.\n  function repay(\n    uint256 assets,\n    address borrower\n  ) external whenNotPaused returns (uint256 actualRepay, uint256 borrowShares) {\n    (actualRepay, borrowShares) = noTransferRefund(previewRepay(assets), borrower);\n    emitMarketUpdate();\n    asset.safeTransferFrom(msg.sender, address(this), actualRepay);\n  }\n\n  /// @notice Repays a certain amount of shares to the floating pool.\n  /// @param borrowShares shares to be subtracted from the borrower's accountability.\n  /// @param borrower address of the account that has the debt.\n  /// @return assets subtracted assets from the borrower's accountability.\n  /// @return actualShares actual subtracted shares from the borrower's accountability.\n  function refund(\n    uint256 borrowShares,\n    address borrower\n  ) external whenNotPaused returns (uint256 assets, uint256 actualShares) {\n    (assets, actualShares) = noTransferRefund(borrowShares, borrower);\n    emitMarketUpdate();\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n  }\n\n  /// @notice Allows to (partially) repay a floating borrow. It does not transfer assets.\n  /// @param borrowShares shares to be subtracted from the borrower's accountability.\n  /// @param borrower the address of the account that has the debt.\n  /// @return assets the actual amount that should be transferred into the protocol.\n  /// @return actualShares actual subtracted shares from the borrower's accountability.\n  function noTransferRefund(\n    uint256 borrowShares,\n    address borrower\n  ) internal returns (uint256 assets, uint256 actualShares) {\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    depositToTreasury(updateFloatingDebt());\n    Account storage account = accounts[borrower];\n    uint256 accountBorrowShares = account.floatingBorrowShares;\n    actualShares = Math.min(borrowShares, accountBorrowShares);\n    assets = previewRefund(actualShares);\n\n    if (assets == 0) revert ZeroRepay();\n\n    floatingDebt -= assets;\n    account.floatingBorrowShares = accountBorrowShares - actualShares;\n    totalFloatingBorrowShares -= actualShares;\n\n    emit Repay(msg.sender, borrower, assets, actualShares);\n  }\n\n  /// @notice Deposits a certain amount to a maturity.\n  /// @param maturity maturity date where the assets will be deposited.\n  /// @param assets amount to receive from the msg.sender.\n  /// @param minAssetsRequired minimum amount of assets required by the depositor for the transaction to be accepted.\n  /// @param receiver address that will be able to withdraw the deposited assets.\n  /// @return positionAssets total amount of assets (principal + fee) to be withdrawn at maturity.\n  function depositAtMaturity(\n    uint256 maturity,\n    uint256 assets,\n    uint256 minAssetsRequired,\n    address receiver\n  ) external whenNotPaused whenNotFrozen returns (uint256 positionAssets) {\n    if (assets == 0) revert ZeroDeposit();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.NONE);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n\n    uint256 backupEarnings = pool.accrueEarnings(maturity);\n    floatingAssets += backupEarnings;\n\n    (uint256 fee, uint256 backupFee) = pool.calculateDeposit(assets, backupFeeRate);\n    positionAssets = assets + fee;\n    if (positionAssets < minAssetsRequired) revert Disagreement();\n\n    floatingBackupBorrowed -= pool.deposit(assets);\n    pool.unassignedEarnings -= fee + backupFee;\n    earningsAccumulator += backupFee;\n\n    // update account's position\n    FixedLib.Position storage position = fixedDepositPositions[maturity][receiver];\n\n    // if account doesn't have a current position, add it to the list\n    if (position.principal == 0) {\n      Account storage account = accounts[receiver];\n      account.fixedDeposits = account.fixedDeposits.setMaturity(maturity);\n    }\n\n    position.principal += assets;\n    position.fee += fee;\n\n    emit DepositAtMaturity(maturity, msg.sender, receiver, assets, fee);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n  }\n\n  /// @notice Borrows a certain amount from a maturity.\n  /// @param maturity maturity date for repayment.\n  /// @param assets amount to be sent to receiver and repaid by borrower.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept.\n  /// @param receiver address that will receive the borrowed assets.\n  /// @param borrower address that will repay the borrowed assets.\n  /// @return assetsOwed total amount of assets (principal + fee) to be repaid at maturity.\n  function borrowAtMaturity(\n    uint256 maturity,\n    uint256 assets,\n    uint256 maxAssets,\n    address receiver,\n    address borrower\n  ) external whenNotPaused whenNotFrozen returns (uint256 assetsOwed) {\n    if (assets == 0) revert ZeroBorrow();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.NONE);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n    floatingAssets += pool.accrueEarnings(maturity);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    {\n      uint256 backupDebtAddition = pool.borrow(assets);\n      if (backupDebtAddition != 0) {\n        uint256 newFloatingBackupBorrowed = floatingBackupBorrowed + backupDebtAddition;\n        depositToTreasury(updateFloatingDebt());\n        if (newFloatingBackupBorrowed + floatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n          revert InsufficientProtocolLiquidity();\n        }\n        floatingBackupBorrowed = newFloatingBackupBorrowed;\n      }\n    }\n    uint256 fee;\n    {\n      uint256 memFloatingAssetsAverage = previewFloatingAssetsAverage();\n      uint256 memFloatingDebt = floatingDebt;\n      uint256 fixedRate = interestRateModel.fixedRate(\n        maturity,\n        maxFuturePools,\n        fixedUtilization(pool.supplied, pool.borrowed, memFloatingAssetsAverage),\n        floatingUtilization(memFloatingAssetsAverage, memFloatingDebt),\n        globalUtilization(memFloatingAssetsAverage, memFloatingDebt, floatingBackupBorrowed)\n      );\n      fee = assets.mulWadDown(fixedRate.mulDivDown(maturity - block.timestamp, 365 days));\n    }\n    assetsOwed = assets + fee;\n\n    // validate that the account is not taking arbitrary fees\n    if (assetsOwed > maxAssets) revert Disagreement();\n\n    spendAllowance(borrower, assetsOwed);\n\n    {\n      // if account doesn't have a current position, add it to the list\n      FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n      if (position.principal == 0) {\n        Account storage account = accounts[borrower];\n        account.fixedBorrows = account.fixedBorrows.setMaturity(maturity);\n      }\n\n      // calculate what portion of the fees are to be accrued and what portion goes to earnings accumulator\n      (uint256 newUnassignedEarnings, uint256 newBackupEarnings) = pool.distributeEarnings(\n        chargeTreasuryFee(fee),\n        assets\n      );\n      if (newUnassignedEarnings != 0) pool.unassignedEarnings += newUnassignedEarnings;\n      collectFreeLunch(newBackupEarnings);\n\n      fixedBorrowPositions[maturity][borrower] = FixedLib.Position(position.principal + assets, position.fee + fee);\n    }\n\n    emit BorrowAtMaturity(maturity, msg.sender, receiver, borrower, assets, fee);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    auditor.checkBorrow(this, borrower);\n    asset.safeTransfer(receiver, assets);\n  }\n\n  /// @notice Withdraws a certain amount from a maturity.\n  /// @param maturity maturity date where the assets will be withdrawn.\n  /// @param positionAssets position size to be reduced.\n  /// @param minAssetsRequired minimum amount required by the account (if discount included for early withdrawal).\n  /// @param receiver address that will receive the withdrawn assets.\n  /// @param owner address that previously deposited the assets.\n  /// @return assetsDiscounted amount of assets withdrawn (can include a discount for early withdraw).\n  function withdrawAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 minAssetsRequired,\n    address receiver,\n    address owner\n  ) external whenNotPaused returns (uint256 assetsDiscounted) {\n    if (positionAssets == 0) revert ZeroWithdraw();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.MATURED);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n    floatingAssets += pool.accrueEarnings(maturity);\n\n    FixedLib.Position memory position = fixedDepositPositions[maturity][owner];\n\n    if (positionAssets > position.principal + position.fee) positionAssets = position.principal + position.fee;\n\n    {\n      // remove the supply from the fixed rate pool\n      uint256 newFloatingBackupBorrowed = floatingBackupBorrowed +\n        pool.withdraw(\n          FixedLib.Position(position.principal, position.fee).scaleProportionally(positionAssets).principal\n        );\n      if (newFloatingBackupBorrowed + floatingDebt > floatingAssets) revert InsufficientProtocolLiquidity();\n      floatingBackupBorrowed = newFloatingBackupBorrowed;\n    }\n\n    // verify if there are any penalties/fee for the account because of early withdrawal, if so discount\n    if (block.timestamp < maturity) {\n      uint256 memFloatingAssetsAverage = previewFloatingAssetsAverage();\n      uint256 memFloatingDebt = floatingDebt;\n      uint256 memFloatingBackupBorrowed = floatingBackupBorrowed;\n\n      uint256 fixedRate = interestRateModel.fixedRate(\n        maturity,\n        maxFuturePools,\n        fixedUtilization(pool.supplied, pool.borrowed, memFloatingAssetsAverage),\n        floatingUtilization(memFloatingAssetsAverage, memFloatingDebt),\n        globalUtilization(memFloatingAssetsAverage, memFloatingDebt, memFloatingBackupBorrowed)\n      );\n      assetsDiscounted = positionAssets.divWadDown(1e18 + fixedRate.mulDivDown(maturity - block.timestamp, 365 days));\n    } else {\n      assetsDiscounted = positionAssets;\n    }\n\n    if (assetsDiscounted < minAssetsRequired) revert Disagreement();\n\n    spendAllowance(owner, assetsDiscounted);\n\n    // all the fees go to unassigned or to the floating pool\n    (uint256 unassignedEarnings, uint256 newBackupEarnings) = pool.distributeEarnings(\n      chargeTreasuryFee(positionAssets - assetsDiscounted),\n      assetsDiscounted\n    );\n    pool.unassignedEarnings += unassignedEarnings;\n    collectFreeLunch(newBackupEarnings);\n\n    // the account gets discounted the full amount\n    position.reduceProportionally(positionAssets);\n    if (position.principal | position.fee == 0) {\n      delete fixedDepositPositions[maturity][owner];\n      Account storage account = accounts[owner];\n      account.fixedDeposits = account.fixedDeposits.clearMaturity(maturity);\n    } else {\n      // proportionally reduce the values\n      fixedDepositPositions[maturity][owner] = position;\n    }\n\n    emit WithdrawAtMaturity(maturity, msg.sender, receiver, owner, positionAssets, assetsDiscounted);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    asset.safeTransfer(receiver, assetsDiscounted);\n  }\n\n  /// @notice Repays a certain amount to a maturity.\n  /// @param maturity maturity date where the assets will be repaid.\n  /// @param positionAssets amount to be paid for the borrower's debt.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept to be repaid.\n  /// @param borrower address of the account that has the debt.\n  /// @return actualRepayAssets the actual amount that was transferred into the protocol.\n  function repayAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 maxAssets,\n    address borrower\n  ) external whenNotPaused returns (uint256 actualRepayAssets) {\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.MATURED);\n\n    actualRepayAssets = noTransferRepayAtMaturity(maturity, positionAssets, maxAssets, borrower, true);\n    emitMarketUpdate();\n\n    asset.safeTransferFrom(msg.sender, address(this), actualRepayAssets);\n  }\n\n  /// @notice Allows to (partially) repay a fixed rate position. It does not transfer assets.\n  /// @param maturity the maturity to access the pool.\n  /// @param positionAssets the amount of debt of the pool that should be paid.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept to be repaid.\n  /// @param borrower the address of the account that has the debt.\n  /// @param canDiscount should early repay discounts be applied.\n  /// @return actualRepayAssets the actual amount that should be transferred into the protocol.\n  function noTransferRepayAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 maxAssets,\n    address borrower,\n    bool canDiscount\n  ) internal returns (uint256 actualRepayAssets) {\n    if (positionAssets == 0) revert ZeroRepay();\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n\n    uint256 backupEarnings = pool.accrueEarnings(maturity);\n    floatingAssets += backupEarnings;\n\n    FixedLib.Position memory position = fixedBorrowPositions[maturity][borrower];\n\n    uint256 debtCovered = Math.min(positionAssets, position.principal + position.fee);\n\n    uint256 principalCovered = FixedLib\n      .Position(position.principal, position.fee)\n      .scaleProportionally(debtCovered)\n      .principal;\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    // early repayment allows a discount from the unassigned earnings\n    if (block.timestamp < maturity) {\n      if (canDiscount) {\n        // calculate the deposit fee considering the amount of debt the account'll pay\n        (uint256 discountFee, uint256 backupFee) = pool.calculateDeposit(principalCovered, backupFeeRate);\n\n        // remove the fee from unassigned earnings\n        pool.unassignedEarnings -= discountFee + backupFee;\n\n        // the fee charged to the fixed pool supplier goes to the earnings accumulator\n        earningsAccumulator += backupFee;\n\n        // the fee gets discounted from the account through `actualRepayAssets`\n        actualRepayAssets = debtCovered - discountFee;\n      } else {\n        actualRepayAssets = debtCovered;\n      }\n    } else {\n      actualRepayAssets = debtCovered + debtCovered.mulWadDown((block.timestamp - maturity) * penaltyRate);\n\n      // all penalties go to the earnings accumulator\n      earningsAccumulator += actualRepayAssets - debtCovered;\n    }\n\n    // verify that the account agrees to this discount or penalty\n    if (actualRepayAssets > maxAssets) revert Disagreement();\n\n    // reduce the borrowed from the pool and might decrease the floating backup borrowed\n    floatingBackupBorrowed -= pool.repay(principalCovered);\n\n    // update the account position\n    position.reduceProportionally(debtCovered);\n    if (position.principal | position.fee == 0) {\n      delete fixedBorrowPositions[maturity][borrower];\n      Account storage account = accounts[borrower];\n      account.fixedBorrows = account.fixedBorrows.clearMaturity(maturity);\n    } else {\n      // proportionally reduce the values\n      fixedBorrowPositions[maturity][borrower] = position;\n    }\n\n    emit RepayAtMaturity(maturity, msg.sender, borrower, actualRepayAssets, debtCovered);\n    emitFixedEarningsUpdate(maturity);\n  }\n\n  /// @notice Liquidates undercollateralized fixed/floating (or both) position(s).\n  /// @dev Msg.sender liquidates borrower's position(s) and repays a certain amount of debt for the floating pool,\n  /// or/and for multiple fixed pools, seizing a portion of borrower's collateral.\n  /// @param borrower account that has an outstanding debt across floating or fixed pools.\n  /// @param maxAssets maximum amount of debt that the liquidator is willing to accept. (it can be less)\n  /// @param seizeMarket market from which the collateral will be seized to give to the liquidator.\n  /// @return repaidAssets actual amount repaid.\n  function liquidate(\n    address borrower,\n    uint256 maxAssets,\n    Market seizeMarket\n  ) external whenNotPaused returns (uint256 repaidAssets) {\n    if (msg.sender == borrower) revert SelfLiquidation();\n\n    maxAssets = auditor.checkLiquidation(this, seizeMarket, borrower, maxAssets);\n    if (maxAssets == 0) revert ZeroRepay();\n\n    Account storage account = accounts[borrower];\n\n    {\n      uint256 packedMaturities = account.fixedBorrows;\n      uint256 maturity = packedMaturities & ((1 << 32) - 1);\n      packedMaturities = packedMaturities >> 32;\n      while (packedMaturities != 0 && maxAssets != 0) {\n        if (packedMaturities & 1 != 0) {\n          uint256 actualRepay;\n          if (block.timestamp < maturity) {\n            actualRepay = noTransferRepayAtMaturity(maturity, maxAssets, maxAssets, borrower, false);\n            maxAssets -= actualRepay;\n          } else {\n            uint256 position;\n            {\n              FixedLib.Position storage p = fixedBorrowPositions[maturity][borrower];\n              position = p.principal + p.fee;\n            }\n            uint256 debt = position + position.mulWadDown((block.timestamp - maturity) * penaltyRate);\n            actualRepay = debt > maxAssets ? maxAssets.mulDivDown(position, debt) : maxAssets;\n\n            if (actualRepay == 0) maxAssets = 0;\n            else {\n              actualRepay = noTransferRepayAtMaturity(maturity, actualRepay, maxAssets, borrower, false);\n              maxAssets -= actualRepay;\n            }\n          }\n          repaidAssets += actualRepay;\n        }\n        packedMaturities >>= 1;\n        maturity += FixedLib.INTERVAL;\n      }\n    }\n\n    if (maxAssets != 0 && account.floatingBorrowShares != 0) {\n      uint256 borrowShares = previewRepay(maxAssets);\n      if (borrowShares != 0) {\n        (uint256 actualRepayAssets, ) = noTransferRefund(borrowShares, borrower);\n        repaidAssets += actualRepayAssets;\n      }\n    }\n\n    // reverts on failure\n    (uint256 lendersAssets, uint256 seizeAssets) = auditor.calculateSeize(this, seizeMarket, borrower, repaidAssets);\n    earningsAccumulator += lendersAssets;\n\n    if (address(seizeMarket) == address(this)) {\n      internalSeize(this, msg.sender, borrower, seizeAssets);\n    } else {\n      seizeMarket.seize(msg.sender, borrower, seizeAssets);\n\n      emitMarketUpdate();\n    }\n\n    emit Liquidate(msg.sender, borrower, repaidAssets, lendersAssets, seizeMarket, seizeAssets);\n\n    auditor.handleBadDebt(borrower);\n\n    asset.safeTransferFrom(msg.sender, address(this), repaidAssets + lendersAssets);\n  }\n\n  /// @notice Clears floating and fixed debt for an account spreading the losses to the `earningsAccumulator`.\n  /// @dev Can only be called from the auditor.\n  /// @param borrower account with insufficient collateral to be cleared the debt.\n  function clearBadDebt(address borrower) external {\n    if (msg.sender != address(auditor)) revert NotAuditor();\n\n    floatingAssets += accrueAccumulatedEarnings();\n    Account storage account = accounts[borrower];\n    uint256 accumulator = earningsAccumulator;\n    uint256 totalBadDebt = 0;\n    uint256 packedMaturities = account.fixedBorrows;\n    uint256 maturity = packedMaturities & ((1 << 32) - 1);\n    packedMaturities = packedMaturities >> 32;\n    while (packedMaturities != 0) {\n      if (packedMaturities & 1 != 0) {\n        FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n        uint256 badDebt = position.principal + position.fee;\n        if (accumulator >= badDebt) {\n          RewardsController memRewardsController = rewardsController;\n          if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n          accumulator -= badDebt;\n          totalBadDebt += badDebt;\n          floatingBackupBorrowed -= fixedPools[maturity].repay(position.principal);\n          delete fixedBorrowPositions[maturity][borrower];\n          account.fixedBorrows = account.fixedBorrows.clearMaturity(maturity);\n\n          emit RepayAtMaturity(maturity, msg.sender, borrower, badDebt, badDebt);\n        }\n      }\n      packedMaturities >>= 1;\n      maturity += FixedLib.INTERVAL;\n    }\n    if (account.floatingBorrowShares != 0 && (accumulator = previewRepay(accumulator)) != 0) {\n      (uint256 badDebt, ) = noTransferRefund(accumulator, borrower);\n      totalBadDebt += badDebt;\n    }\n    if (totalBadDebt != 0) {\n      earningsAccumulator -= totalBadDebt;\n      emit SpreadBadDebt(borrower, totalBadDebt);\n    }\n    emitMarketUpdate();\n  }\n\n  /// @notice Public function to seize a certain amount of assets.\n  /// @dev Public function for liquidator to seize borrowers assets in the floating pool.\n  /// This function will only be called from another Market, on `liquidation` calls.\n  /// That's why msg.sender needs to be passed to the internal function (to be validated as a Market).\n  /// @param liquidator address which will receive the seized assets.\n  /// @param borrower address from which the assets will be seized.\n  /// @param assets amount to be removed from borrower's possession.\n  function seize(address liquidator, address borrower, uint256 assets) external whenNotPaused {\n    internalSeize(Market(msg.sender), liquidator, borrower, assets);\n  }\n\n  /// @notice Internal function to seize a certain amount of assets.\n  /// @dev Internal function for liquidator to seize borrowers assets in the floating pool.\n  /// Will only be called from this Market on `liquidation` or through `seize` calls from another Market.\n  /// That's why msg.sender needs to be passed to the internal function (to be validated as a Market).\n  /// @param seizeMarket address which is calling the seize function (see `seize` public function).\n  /// @param liquidator address which will receive the seized assets.\n  /// @param borrower address from which the assets will be seized.\n  /// @param assets amount to be removed from borrower's possession.\n  function internalSeize(Market seizeMarket, address liquidator, address borrower, uint256 assets) internal {\n    if (assets == 0) revert ZeroWithdraw();\n\n    // reverts on failure\n    auditor.checkSeize(seizeMarket, this);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleDeposit(borrower);\n    uint256 shares = previewWithdraw(assets);\n    beforeWithdraw(assets, shares);\n    _burn(borrower, shares);\n    emit Withdraw(msg.sender, liquidator, borrower, assets, shares);\n    emit Seize(liquidator, borrower, assets);\n    emitMarketUpdate();\n\n    asset.safeTransfer(liquidator, assets);\n  }\n\n  /// @notice Hook to update the floating pool average, floating pool balance and distribute earnings from accumulator.\n  /// @param assets amount of assets to be withdrawn from the floating pool.\n  function beforeWithdraw(uint256 assets, uint256) internal override whenNotPaused {\n    updateFloatingAssetsAverage();\n    depositToTreasury(updateFloatingDebt());\n    uint256 earnings = accrueAccumulatedEarnings();\n    uint256 newFloatingAssets = floatingAssets + earnings - assets;\n    // check if the underlying liquidity that the account wants to withdraw is borrowed\n    if (floatingBackupBorrowed + floatingDebt > newFloatingAssets) revert InsufficientProtocolLiquidity();\n    floatingAssets = newFloatingAssets;\n  }\n\n  /// @notice Hook to update the floating pool average, floating pool balance and distribute earnings from accumulator.\n  /// @param assets amount of assets to be deposited to the floating pool.\n  function afterDeposit(uint256 assets, uint256) internal override whenNotPaused whenNotFrozen {\n    updateFloatingAssetsAverage();\n    uint256 treasuryFee = updateFloatingDebt();\n    uint256 earnings = accrueAccumulatedEarnings();\n    floatingAssets += earnings + assets;\n    depositToTreasury(treasuryFee);\n    emitMarketUpdate();\n  }\n\n  /// @notice Withdraws the owner's floating pool assets to the receiver address.\n  /// @dev Makes sure that the owner doesn't have shortfall after withdrawing.\n  /// @param assets amount of underlying to be withdrawn.\n  /// @param receiver address to which the assets will be transferred.\n  /// @param owner address which owns the floating pool assets.\n  /// @return shares amount of shares redeemed for underlying asset.\n  function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {\n    auditor.checkShortfall(this, owner, assets);\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleDeposit(owner);\n    shares = super.withdraw(assets, receiver, owner);\n    emitMarketUpdate();\n  }\n\n  /// @notice Redeems the owner's floating pool assets"
    }
  ]
}