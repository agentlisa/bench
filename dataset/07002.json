{
  "Title": "[H-04] SwingTraderManager.addSwingTrader will push traderId with `active = false` to activeTraders",
  "Content": "\nIn SwingTraderManager.addSwingTrader, if `active = false`, the traderId is also pushed to activeTraders.\n\n```solidity\n  function addSwingTrader(\n    uint256 traderId,\n    address _swingTrader,\n    bool active,\n    string calldata name\n  ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(traderId > 2 && trader.id == 0, \"TraderId already used\");\n    require(_swingTrader != address(0), \"addr(0)\");\n\n    swingTraders[traderId] = SwingTraderData({\n      id: traderId,\n      index: activeTraders.length,\n      traderContract: _swingTrader,\n      name: name,\n      active: active\n    });\n\n    activeTraders.push(traderId);\n\n    emit AddSwingTrader(traderId, name, active, _swingTrader);\n  }\n```\n\nAfterwards, if toggleTraderActive is called on the traderId, the traderId will be pushed to activeTraders again.\n\n```solidity\n  function toggleTraderActive(uint256 traderId)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(trader.id == traderId, \"Unknown trader\");\n\n    bool active = !trader.active;\n    trader.active = active;\n\n    if (active) {\n      // setting it to active so add to activeTraders\n      trader.index = activeTraders.length;\n      activeTraders.push(traderId);\n    } else {\n```\n\nThis means that in `getTokenBalances()/calculateSwingTraderMaltRatio()`, since there are two identical traderIds in activeTraders, the data in this trader will be calculated twice.\n\nWrong `getTokenBalances()` will result in wrong data when `syncGlobalCollateral()`.\n\n```solidity\n  function getTokenBalances()\n    external\n    view\n    returns (uint256 maltBalance, uint256 collateralBalance)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      maltBalance += malt.balanceOf(trader.traderContract);\n      collateralBalance += collateralToken.balanceOf(trader.traderContract);\n    }\n  }\n```\n\nWrong `calculateSwingTraderMaltRatio()` will cause `MaltDataLab.getRealBurnBudget()/getSwingTraderEntryPrice()` to be wrong.\n\n```solidity\n  function calculateSwingTraderMaltRatio()\n    public\n    view\n    returns (uint256 maltRatio)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    uint256 decimals = collateralToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n    uint256 totalMaltBalance;\n    uint256 totalCollateralBalance;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      totalMaltBalance += malt.balanceOf(trader.traderContract);\n      totalCollateralBalance += collateralToken.balanceOf(\n        trader.traderContract\n      );\n    }\n\n    totalMaltBalance = maltDataLab.maltToRewardDecimals(totalMaltBalance);\n\n    uint256 stMaltValue = ((totalMaltBalance * maltDataLab.priceTarget()) /\n      (10**decimals));\n\n    uint256 netBalance = totalCollateralBalance + stMaltValue;\n\n    if (netBalance > 0) {\n      maltRatio = ((stMaltValue * (10**decimals)) / netBalance);\n    } else {\n      maltRatio = 0;\n    }\n  }\n```\n\nWhat's more serious is that even if toggleTraderActive is called again, only one traderId will pop up from activeTraders, and the other traderId cannot be popped up.\n\n```solidity\n    } else {\n      // Becoming inactive so remove from activePools\n      uint256 index = trader.index;\n      uint256 lastTrader = activeTraders[activeTraders.length - 1];\n\n      activeTraders[index] = lastTrader;\n      activeTraders.pop();\n\n      swingTraders[lastTrader].index = index;\n      trader.index = 0;\n    }\n```\n\nThis causes the trade to participate in the calculation of `getTokenBalances()/calculateSwingTraderMaltRatio()` even if the trade is deactive.\n\nConsidering that the active parameter is likely to be false when addSwingTrader is called and cannot be recovered, this vulnerability should be High risk.\n\n### Proof of Concept\n\n```solidity\n  function testAddSwingTrader(address newSwingTrader) public {\n    _setupContract();\n    vm.assume(newSwingTrader != address(0));\n    vm.prank(admin);\n    swingTraderManager.addSwingTrader(3, newSwingTrader, false, \"Test\");\n\n    (\n      uint256 id,\n      uint256 index,\n      address traderContract,\n      string memory name,\n      bool active\n    ) = swingTraderManager.swingTraders(3);\n\n    assertEq(id, 3);\n    assertEq(index, 2);\n    assertEq(traderContract, newSwingTrader);\n    assertEq(name, \"Test\");\n    assertEq(active, false);\n    vm.prank(admin);\n    swingTraderManager.toggleTraderActive(3);\n    assertEq(swingTraderManager.activeTraders(2),3);\n    assertEq(swingTraderManager.activeTraders(3),3); // @audit:activeTraders[2] = activeTraders[3] = 3\n    vm.prank(admin);\n    swingTraderManager.toggleTraderActive(3);\n    assertEq(swingTraderManager.activeTraders(2),3);\n  }\n```\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L397-L447>\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```diff\n  function addSwingTrader(\n    uint256 traderId,\n    address _swingTrader,\n    bool active,\n    string calldata name\n  ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(traderId > 2 && trader.id == 0, \"TraderId already used\");\n    require(_swingTrader != address(0), \"addr(0)\");\n\n    swingTraders[traderId] = SwingTraderData({\n      id: traderId,\n-     index: activeTraders.length,\n+     index: active ? activeTraders.lengthÂ : 0,\n      traderContract: _swingTrader,\n      name: name,\n      active: active\n    });\n+  if(active) activeTraders.push(traderId);\n\n-   activeTraders.push(traderId);\n\n    emit AddSwingTrader(traderId, name, active, _swingTrader);\n  }\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/12)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-02-malt-protocol-versus-contest",
  "Code": [
    {
      "filename": "contracts/StabilityPod/SwingTraderManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/DataLabExtension.sol\";\nimport \"../StabilizedPoolExtensions/StabilizerNodeExtension.sol\";\nimport \"../interfaces/ISwingTrader.sol\";\nimport \"../interfaces/IMaltDataLab.sol\";\n\nstruct SwingTraderData {\n  uint256 id;\n  uint256 index; // index into the activeTraders array\n  address traderContract;\n  string name;\n  bool active;\n}\n\n/// @title Swing Trader Manager\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The contract simply orchestrates SwingTrader instances. Initially there will only be a single\n/// Swing Trader. But over time there may be others with different strategies that can be balanced / orchestrated\n/// by this contract.\ncontract SwingTraderManager is\n  StabilizedPoolUnit,\n  ISwingTrader,\n  DataLabExtension,\n  StabilizerNodeExtension\n{\n  using SafeERC20 for ERC20;\n\n  bytes32 public immutable CAPITAL_DELEGATE_ROLE;\n\n  mapping(uint256 => SwingTraderData) public swingTraders;\n  uint256[] public activeTraders;\n  uint256 public totalProfit;\n  uint256 public dustThreshold = 1e18; // $1\n\n  event ToggleTraderActive(uint256 traderId, bool active);\n  event AddSwingTrader(\n    uint256 traderId,\n    string name,\n    bool active,\n    address swingTrader\n  );\n  event Delegation(uint256 amount, address destination, address delegate);\n  event BuyMalt(uint256 capitalUsed);\n  event SellMalt(uint256 amountSold, uint256 profit);\n  event SetDustThreshold(uint256 threshold);\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {\n    CAPITAL_DELEGATE_ROLE = 0x6b525fb9eaf138d3dc2ac8323126c54cad39e34e800f9605cb60df858920b17b;\n    _roleSetup(\n      0x6b525fb9eaf138d3dc2ac8323126c54cad39e34e800f9605cb60df858920b17b,\n      timelock\n    );\n  }\n\n  function setupContracts(\n    address _collateralToken,\n    address _malt,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _swingTrader,\n    address _rewardOverflow,\n    address pool\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Only pool factory role\") {\n    require(!contractActive, \"SwingTraderManager: Already setup\");\n    require(\n      _collateralToken != address(0),\n      \"SwingTraderManager: ColToken addr(0)\"\n    );\n    require(_malt != address(0), \"SwingTraderManager: Malt addr(0)\");\n    require(\n      _stabilizerNode != address(0),\n      \"SwingTraderManager: StabNode addr(0)\"\n    );\n    require(\n      _maltDataLab != address(0),\n      \"SwingTraderManager: MaltDataLab addr(0)\"\n    );\n    require(\n      _swingTrader != address(0),\n      \"SwingTraderManager: SwingTrader addr(0)\"\n    );\n    require(\n      _rewardOverflow != address(0),\n      \"SwingTraderManager: Overflow addr(0)\"\n    );\n\n    contractActive = true;\n\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    stabilizerNode = IStabilizerNode(_stabilizerNode);\n\n    // Internal SwingTrader\n    swingTraders[1] = SwingTraderData({\n      id: 1,\n      index: 0,\n      traderContract: _swingTrader,\n      name: \"CoreSwingTrader\",\n      active: true\n    });\n    activeTraders.push(1);\n\n    // RewardOverflow is secondary swing trader\n    swingTraders[2] = SwingTraderData({\n      id: 2,\n      index: 1,\n      traderContract: _rewardOverflow,\n      name: \"CoreSwingTrader\",\n      active: true\n    });\n\n    activeTraders.push(2);\n\n    (, address updater, ) = poolFactory.getPool(pool);\n    _setPoolUpdater(updater);\n  }\n\n  function _beforeSetStabilizerNode(address _stabilizerNode) internal override {\n    _transferRole(\n      _stabilizerNode,\n      address(stabilizerNode),\n      STABILIZER_NODE_ROLE\n    );\n  }\n\n  function buyMalt(uint256 maxCapital)\n    external\n    onlyRoleMalt(STABILIZER_NODE_ROLE, \"Must have stabilizer node privs\")\n    onlyActive\n    returns (uint256 capitalUsed)\n  {\n    if (maxCapital == 0) {\n      return 0;\n    }\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    uint256 totalCapital;\n    uint256[] memory traderCapital = new uint256[](length);\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderBalance = collateralToken.balanceOf(trader.traderContract);\n      totalCapital += traderBalance;\n      traderCapital[i] = traderBalance;\n    }\n\n    if (totalCapital == 0) {\n      return 0;\n    }\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      uint256 share = (maxCapital * traderCapital[i]) / totalCapital;\n\n      if (share == 0) {\n        continue;\n      }\n\n      if (capitalUsed + share > maxCapital) {\n        share = maxCapital - capitalUsed;\n      }\n\n      uint256 used = ISwingTrader(trader.traderContract).buyMalt(share);\n      capitalUsed += used;\n\n      if (capitalUsed >= maxCapital) {\n        break;\n      }\n    }\n\n    emit BuyMalt(capitalUsed);\n\n    return capitalUsed;\n  }\n\n  function sellMalt(uint256 maxAmount)\n    external\n    onlyRoleMalt(STABILIZER_NODE_ROLE, \"Must have stabilizer node privs\")\n    onlyActive\n    returns (uint256 amountSold)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    uint256 profit;\n\n    uint256 totalMalt;\n    uint256[] memory traderMalt = new uint256[](length);\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderMaltBalance = malt.balanceOf(trader.traderContract);\n      totalMalt += traderMaltBalance;\n      traderMalt[i] = traderMaltBalance;\n    }\n\n    if (totalMalt == 0) {\n      return 0;\n    }\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      uint256 share = (maxAmount * traderMalt[i]) / totalMalt;\n\n      if (share == 0) {\n        continue;\n      }\n\n      if (amountSold + share > maxAmount) {\n        share = maxAmount - amountSold;\n      }\n\n      uint256 initialProfit = ISwingTrader(trader.traderContract).totalProfit();\n      try ISwingTrader(trader.traderContract).sellMalt(share) returns (\n        uint256 sold\n      ) {\n        uint256 finalProfit = ISwingTrader(trader.traderContract).totalProfit();\n        profit += (finalProfit - initialProfit);\n        amountSold += sold;\n      } catch {\n        // if it fails just continue\n      }\n\n      if (amountSold >= maxAmount) {\n        break;\n      }\n    }\n\n    if (amountSold + dustThreshold >= maxAmount) {\n      return maxAmount;\n    }\n\n    totalProfit += profit;\n\n    emit SellMalt(amountSold, profit);\n  }\n\n  function costBasis() public view returns (uint256 cost, uint256 decimals) {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    decimals = collateralToken.decimals();\n\n    uint256 totalMaltBalance;\n    uint256 totalDeployedCapital;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      totalDeployedCapital += ISwingTrader(trader.traderContract)\n        .deployedCapital();\n      totalMaltBalance += malt.balanceOf(trader.traderContract);\n    }\n\n    if (totalDeployedCapital == 0 || totalMaltBalance == 0) {\n      return (0, decimals);\n    }\n\n    totalMaltBalance = maltDataLab.maltToRewardDecimals(totalMaltBalance);\n\n    return (\n      (totalDeployedCapital * (10**decimals)) / totalMaltBalance,\n      decimals\n    );\n  }\n\n  function calculateSwingTraderMaltRatio()\n    public\n    view\n    returns (uint256 maltRatio)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n    uint256 decimals = collateralToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n    uint256 totalMaltBalance;\n    uint256 totalCollateralBalance;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      totalMaltBalance += malt.balanceOf(trader.traderContract);\n      totalCollateralBalance += collateralToken.balanceOf(\n        trader.traderContract\n      );\n    }\n\n    totalMaltBalance = maltDataLab.maltToRewardDecimals(totalMaltBalance);\n\n    uint256 stMaltValue = ((totalMaltBalance * maltDataLab.priceTarget()) /\n      (10**decimals));\n\n    uint256 netBalance = totalCollateralBalance + stMaltValue;\n\n    if (netBalance > 0) {\n      maltRatio = ((stMaltValue * (10**decimals)) / netBalance);\n    } else {\n      maltRatio = 0;\n    }\n  }\n\n  function getTokenBalances()\n    external\n    view\n    returns (uint256 maltBalance, uint256 collateralBalance)\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      maltBalance += malt.balanceOf(trader.traderContract);\n      collateralBalance += collateralToken.balanceOf(trader.traderContract);\n    }\n  }\n\n  function delegateCapital(uint256 amount, address destination)\n    external\n    onlyRoleMalt(CAPITAL_DELEGATE_ROLE, \"Must have capital delegation privs\")\n    onlyActive\n  {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    uint256 totalCapital;\n    uint256[] memory traderCapital = new uint256[](length);\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n\n      if (!trader.active) {\n        continue;\n      }\n\n      uint256 traderBalance = collateralToken.balanceOf(trader.traderContract);\n      totalCapital += traderBalance;\n      traderCapital[i] = traderBalance;\n    }\n\n    if (totalCapital == 0) {\n      return;\n    }\n\n    uint256 capitalUsed;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      uint256 share = (amount * traderCapital[i]) / totalCapital;\n\n      if (capitalUsed + share > amount) {\n        share = amount - capitalUsed;\n      }\n\n      if (share == 0) {\n        continue;\n      }\n\n      capitalUsed += share;\n      ISwingTrader(trader.traderContract).delegateCapital(share, destination);\n    }\n\n    emit Delegation(amount, destination, msg.sender);\n  }\n\n  function deployedCapital() external view returns (uint256 deployed) {\n    uint256[] memory traderIds = activeTraders;\n    uint256 length = traderIds.length;\n\n    for (uint256 i; i < length; ++i) {\n      SwingTraderData memory trader = swingTraders[activeTraders[i]];\n      deployed += ISwingTrader(trader.traderContract).deployedCapital();\n    }\n\n    return deployed;\n  }\n\n  function addSwingTrader(\n    uint256 traderId,\n    address _swingTrader,\n    bool active,\n    string calldata name\n  ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(traderId > 2 && trader.id == 0, \"TraderId already used\");\n    require(_swingTrader != address(0), \"addr(0)\");\n\n    swingTraders[traderId] = SwingTraderData({\n      id: traderId,\n      index: activeTraders.length,\n      traderContract: _swingTrader,\n      name: name,\n      active: active\n    });\n\n    activeTraders.push(traderId);\n\n    emit AddSwingTrader(traderId, name, active, _swingTrader);\n  }\n\n  function toggleTraderActive(uint256 traderId)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(trader.id == traderId, \"Unknown trader\");\n\n    bool active = !trader.active;\n    trader.active = active;\n\n    if (active) {\n      // setting it to active so add to activeTraders\n      trader.index = activeTraders.length;\n      activeTraders.push(traderId);\n    } else {\n      // Becoming inactive so remove from activePools\n      uint256 index = trader.index;\n      uint256 lastTrader = activeTraders[activeTraders.length - 1];\n\n      activeTraders[index] = lastTrader;\n      activeTraders.pop();\n\n      swingTraders[lastTrader].index = index;\n      trader.index = 0;\n    }\n\n    emit ToggleTraderActive(traderId, active);\n  }\n\n  function setDustThreshold(uint256 _dust)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    dustThreshold = _dust;\n    emit SetDustThreshold(_dust);\n  }\n\n  function _accessControl()\n    internal\n    override(DataLabExtension, StabilizerNodeExtension)\n  {\n    _onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\");\n  }\n}"
    }
  ]
}