{
  "Title": "[N-06] Long lines",
  "Content": "\nSource codes lines should be limited to a certain number of characters. A good practice is to ensure the code does not require a horizontal scroll bar on GitHub. The lines mentioned below have that problem\n\n### Proof of Concept\n\n14 instances:\n\n#### Swivel.sol\n\n[    if (!mPlace.custodialInitiate(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, principalFilled)) { revert Exception(8, 0, 0, address(0), address(0)); }](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Swivel/Swivel.sol#L137)\\\n[    if (!IMarketPlace(marketPlace).p2pZcTokenExchange(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, a)) { revert Exception(11, 0, 0, address(0), address(0)); }](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Swivel/Swivel.sol#L205)\\\n[    if (!mPlace.p2pVaultExchange(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, principalFilled)) { revert Exception(12, 0, 0, address(0), address(0)); }](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Swivel/Swivel.sol#L229)\\\n[    if (!IMarketPlace(marketPlace).p2pZcTokenExchange(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, principalFilled)) { revert Exception(11, 0, 0, address(0), address(0)); }](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Swivel/Swivel.sol#L301)\\\n[    if (!IMarketPlace(marketPlace).p2pVaultExchange(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, a)) { revert Exception(12, 0, 0, address(0), address(0)); }](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Swivel/Swivel.sol#L331)\\\n[    if (!mPlace.custodialExit(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, principalFilled)) { revert Exception(9, 0, 0, address(0), address(0)); }](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Swivel/Swivel.sol#L399)\n\n#### MarketPlace.sol\n\n[  function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets\\[p\\]\\[u\\]\\[m\\].zcToken) returns (uint256 underlyingAmount) {](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Marketplace/MarketPlace.sol#L148)\n\n#### ZcToken.sol\n\n[    constructor(uint8 \\_protocol, address \\_underlying, uint256 \\_maturity, address \\_cToken, address \\_redeemer, string memory \\_name, string memory \\_symbol, uint8 \\_decimals) ](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Creator/ZcToken.sol#L31)\\\n[        return (principalAmount \\* IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Creator/ZcToken.sol#L47)\\\n[        return (underlyingAmount \\* IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Creator/ZcToken.sol#L56)\\\n[        return (principalAmount \\* IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Creator/ZcToken.sol#L74)\\\n[        return (balanceOf\\[owner\\] \\* IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Creator/ZcToken.sol#L83)\\\n[        return (underlyingAmount \\* IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Creator/ZcToken.sol#L92)\\\n[    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Creator/ZcToken.sol#L120)\n\n### Recommended Mitigation Steps\n\nSplit the lines to avoid needing a scroll bar to look through the code.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-swivel",
  "Code": [
    {
      "filename": "Swivel/Swivel.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './Protocols.sol';\nimport './Hash.sol';\nimport './Sig.sol';\nimport './Safe.sol';\n\ncontract Swivel {\n  /// @dev A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n  /// @dev maps the key of an order to a boolean indicating if an order was cancelled\n  mapping (bytes32 => bool) public cancelled;\n  /// @dev maps the key of an order to an amount representing its taken volume\n  mapping (bytes32 => uint256) public filled;\n  /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made\n  mapping (address => uint256) public withdrawals;\n  /// @dev maps a token address to a point in time, a hold, after which an approval can be made\n  mapping (address => uint256) public approvals;\n\n  string constant public NAME = 'Swivel Finance';\n  string constant public VERSION = '3.0.0';\n  uint256 constant public HOLD = 3 days;\n  bytes32 public immutable domain;\n  address public immutable marketPlace;\n  address public admin;\n  \n  /// @dev address of a deployed Aave contract implementing IAave\n  address public aaveAddr; // TODO immutable?\n\n  uint16 constant public MIN_FEENOMINATOR = 33;\n  /// @dev holds the fee demoninators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]\n  uint16[4] public feenominators;\n  /// @dev A point in time, a hold, after which a change to Fees\n  uint256 public feeChange;\n\n  /// @notice Emitted on order cancellation\n  event Cancel (bytes32 indexed key, bytes32 hash);\n  /// @notice Emitted on any initiate*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Initiate(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on any exit*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Exit(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on token withdrawal scheduling\n  event ScheduleWithdrawal(address indexed token, uint256 hold);\n  /// @notice Emitted on token withdrawal blocking\n  event BlockWithdrawal(address indexed token);\n  /// @notice Emitted on a change to the feenominators array\n  event SetFee(uint256 indexed index, uint256 indexed feenominator);\n  /// @notice Emitted on a token approval scheduling\n  event ScheduleApproval(address indexed token, uint256 hold);\n  /// @notice Emitted on a token approval blocking\n  event BlockApproval(address indexed token);\n  /// @notice Emitted on a fee change scheduling\n  event ScheduleFeeChange(uint256 hold);\n  /// @notice Emitted on a fee change blocking\n  event BlockFeeChange();\n\n  /// @param m Deployed MarketPlace contract address\n  /// @param a Address of a deployed Aave contract implementing our interface\n  constructor(address m, address a) {\n    admin = msg.sender;\n    domain = Hash.domain(NAME, VERSION, block.chainid, address(this));\n    marketPlace = m;\n    aaveAddr = a;\n    feenominators = [200, 600, 400, 200];\n  }\n\n  // ********* INITIATING *************\n\n  /// @notice Allows a user to initiate a position\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Array of Components from valid ECDSA signatures\n  function initiate(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i < len;) {\n      Hash.Order memory order = o[i];\n      if (!order.exit) {\n        if (!order.vault) {\n          initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);\n        } else {\n          initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);\n        }\n      } else {\n        if (!order.vault) {\n          initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          initiateVaultFillingVaultExit(o[i], a[i], c[i]);\n        }\n      }\n      unchecked {i++;}\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (premium) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    // checks order signature, order cancellation and order expiry\n    bytes32 hash = validOrderHash(o, c);\n\n    // checks the side, and the amount compared to available\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n    \n    // TODO cheaper to assign amount here or keep the ADD?\n    filled[hash] += a;\n\n    // transfer underlying tokens\n    IErc20 uToken = IErc20(o.underlying);\n    Safe.transferFrom(uToken, msg.sender, o.maker, a);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    Safe.transferFrom(uToken, o.maker, address(this), principalFilled);\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n\n    // perform the actual deposit type transaction, specific to a protocol\n    if (!deposit(o.protocol, o.underlying, cTokenAddr, principalFilled)) { revert Exception(6, 0, 0, address(0), address(0)); }\n\n    // alert marketplace\n    if (!mPlace.custodialInitiate(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, principalFilled)) { revert Exception(8, 0, 0, address(0), address(0)); }\n\n    // transfer fee in vault notional to swivel (from msg.sender)\n    uint256 fee = principalFilled / feenominators[2];\n    if (!mPlace.transferVaultNotionalFee(o.protocol, o.underlying, o.maturity, msg.sender, fee)) { revert Exception(10, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    IErc20 uToken = IErc20(o.underlying);\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    // transfer principal + fee in underlying to swivel (from sender)\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), (a + fee));\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n\n    // perform the actual deposit type transaction, specific to a protocol\n    if(!deposit(o.protocol, o.underlying, cTokenAddr, a)) { revert Exception(6, 0, 0, address(0), address(0)); }\n\n    // alert marketplace \n    if (!mPlace.custodialInitiate(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, a)) { revert Exception(8, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate \n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n\n    IErc20 uToken = IErc20(o.underlying);\n    // transfer underlying tokens, then take fee\n    Safe.transferFrom(uToken, msg.sender, o.maker, a - premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // alert marketplace\n    if (!IMarketPlace(marketPlace).p2pZcTokenExchange(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, a)) { revert Exception(11, 0, 0, address(0), address(0)); }\n            \n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n\n    // TODO assign amount or keep ADD?\n    filled[hash] += a;\n\n    Safe.transferFrom(IErc20(o.underlying), msg.sender, o.maker, a);\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // alert marketplace\n    if (!mPlace.p2pVaultExchange(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, principalFilled)) { revert Exception(12, 0, 0, address(0), address(0)); }\n\n    // transfer fee (in vault notional) to swivel\n    uint256 fee = principalFilled / feenominators[2];\n    if (!mPlace.transferVaultNotionalFee(o.protocol, o.underlying, o.maturity, msg.sender, fee)) { revert Exception(10, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  // ********* EXITING ***************\n\n  /// @notice Allows a user to exit (sell) a currently held position to the marketplace.\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Components of a valid ECDSA signature\n  function exit(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i < len;) {\n      Hash.Order memory order = o[i];\n      // if the order being filled is not an exit\n      if (!order.exit) {\n        // if the order being filled is a vault initiate or a zcToken initiate\n          if (!order.vault) {\n            // if filling a zcToken initiate with an exit, one is exiting zcTokens\n            exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);\n          } else {\n            // if filling a vault initiate with an exit, one is exiting vault notional\n            exitVaultFillingVaultInitiate(o[i], a[i], c[i]);\n          }\n      } else {\n        // if the order being filled is a vault exit or a zcToken exit\n        if (!order.vault) {\n          // if filling a zcToken exit with an exit, one is exiting vault\n          exitVaultFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          // if filling a vault exit with an exit, one is exiting zcTokens\n          exitZcTokenFillingVaultExit(o[i], a[i], c[i]);\n        }   \n      }\n      unchecked {i++;}\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;       \n\n    IErc20 uToken = IErc20(o.underlying);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // transfer underlying from initiating party to exiting party, minus the price the exit party pays for the exit (premium), and the fee.\n    Safe.transferFrom(uToken, o.maker, msg.sender, principalFilled - a);\n\n    // transfer fee in underlying to swivel\n    uint256 fee = principalFilled / feenominators[1];\n\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // alert marketplace\n    if (!IMarketPlace(marketPlace).p2pZcTokenExchange(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, principalFilled)) { revert Exception(11, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n  \n  /// @notice Allows a user to exit their Vault by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n    \n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n        \n    IErc20 uToken = IErc20(o.underlying);\n\n    // transfer premium from maker to sender\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[3];\n    // transfer fee in underlying to swivel from sender\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // transfer <a> notional from sender to maker\n    if (!IMarketPlace(marketPlace).p2pVaultExchange(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, a)) { revert Exception(12, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their Vault filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    // redeem underlying on Compound and burn cTokens\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n\n    if (!withdraw(o.protocol, o.underlying, cTokenAddr, a)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    IErc20 uToken = IErc20(o.underlying);\n    // transfer principal-premium  back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transfer(uToken, o.maker, a - premiumFilled);\n\n    // transfer premium-fee to floating exit party\n    uint256 fee = premiumFilled / feenominators[3];\n    Safe.transfer(uToken, msg.sender, premiumFilled - fee);\n\n    // burn zcTokens + nTokens from o.maker and msg.sender respectively\n    if (!mPlace.custodialExit(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, a)) { revert Exception(9, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n    \n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    // redeem underlying on Compound and burn cTokens\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n\n    if (!withdraw(o.protocol, o.underlying, cTokenAddr, principalFilled)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    IErc20 uToken = IErc20(o.underlying);\n    // transfer principal-premium-fee back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uint256 fee = principalFilled / feenominators[1];\n    Safe.transfer(uToken, msg.sender, principalFilled - a - fee);\n    Safe.transfer(uToken, o.maker, a);\n\n    // burn <principalFilled> zcTokens + nTokens from msg.sender and o.maker respectively\n    if (!mPlace.custodialExit(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, principalFilled)) { revert Exception(9, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to cancel an order, preventing it from being filled in the future\n  /// @param o Order being cancelled\n  /// @param c Components of a valid ECDSA signature\n  function cancel(Hash.Order[] calldata o, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    for (uint256 i; i < len;) {\n      bytes32 hash = validOrderHash(o[i], c[i]);\n      if (msg.sender != o[i].maker) { revert Exception(15, 0, 0, msg.sender, o[i].maker); }\n\n      cancelled[hash] = true;\n\n      emit Cancel(o[i].key, hash);\n\n      unchecked {\n        i++;\n      }\n    }\n\n    return true;\n  }\n\n  // ********* ADMINISTRATIVE ***************\n\n  /// @param a Address of a new admin\n  function setAdmin(address a) external authorized(admin) returns (bool) {\n    admin = a;\n\n    return true;\n  }\n\n  /// @notice Allows the admin to schedule the withdrawal of tokens\n  /// @param e Address of (erc20) token to withdraw\n  function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\n    uint256 when = block.timestamp + HOLD;\n    withdrawals[e] = when;\n\n    emit ScheduleWithdrawal(e, when);\n\n    return true;\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  /// @param e Address of token withdrawal to block\n  function blockWithdrawal(address e) external authorized(admin) returns (bool) {\n      withdrawals[e] = 0;\n\n      emit BlockWithdrawal(e);\n\n      return true;\n  }\n\n  /// @notice Allows the admin to withdraw the given token, provided the holding period has been observed\n  /// @param e Address of token to withdraw\n  function withdraw(address e) external authorized(admin) returns (bool) {\n    uint256 when = withdrawals[e];\n\n    if (when == 0) { revert Exception(16, 0, 0, address(0), address(0)); }\n\n    if (block.timestamp < when) { revert Exception(17, block.timestamp, when, address(0), address(0)); }\n\n    withdrawals[e] = 0;\n\n    IErc20 token = IErc20(e);\n    Safe.transfer(token, admin, token.balanceOf(address(this)));\n\n    return true;\n  }\n\n  /// @notice Allows the admin to schedule the change of fees\n  function scheduleFeeChange() external authorized(admin) returns (bool) {\n    uint256 when = block.timestamp + HOLD;\n    feeChange = when;\n\n    emit ScheduleFeeChange(when);\n\n    return true;\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  function blockFeeChange() external authorized(admin) returns (bool) {\n      feeChange = 0;\n\n      emit BlockFeeChange();\n\n      return true;\n  }\n\n\n  /// @notice Allows the admin to set a new fee denominator\n  /// @param i The index of the new fee denominator\n  /// @param d The new fee denominator\n  function setFee(uint16[] memory i, uint16[] memory d) external authorized(admin) returns (bool) {\n    uint256 len = i.length;\n\n    if (len != d.length) { revert Exception(19, len, d.length, address(0), address(0)); }\n\n    if (feeChange == 0) { revert Exception(16, 0, 0, address(0), address(0)); }\n\n    if (block.timestamp < feeChange) { revert Exception(17, block.timestamp, feeChange, address(0), address(0)); }\n\n    for (uint256 x; x < len;) {\n      if (d[x] < MIN_FEENOMINATOR) { revert Exception(18, uint256(d[x]), 0, address(0), address(0)); }\n\n      feenominators[x] = d[x];\n      emit SetFee(i[x], d[x]);\n\n      unchecked {\n        x++;\n      }\n    }\n\n    feeChange = 0;\n\n    return true;\n  }\n\n  /// @notice Allows the admin to schedule the approval of tokens\n  /// @param e Address of (erc20) token to withdraw\n  function scheduleApproval(address e) external authorized(admin) returns (bool) {\n    uint256 when = block.timestamp + HOLD;\n    approvals[e] = when;\n\n    emit ScheduleApproval(e, when);\n\n    return true;\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  /// @param e Address of token approval to block\n  function blockApproval(address e) external authorized(admin) returns (bool) {\n      approvals[e] = 0;\n\n      emit BlockApproval(e);\n\n      return true;\n  }\n\n  /// @notice Allows the admin to bulk approve given compound addresses at the underlying token, saving marginal approvals\n  /// @param u array of underlying token addresses\n  /// @param c array of compound token addresses\n  function approveUnderlying(address[] calldata u, address[] calldata c) external authorized(admin) returns (bool) {\n    uint256 len = u.length;\n\n    if (len != c.length) { revert Exception(19, len, c.length, address(0), address(0)); }\n\n    uint256 max = 2**256 - 1;\n    uint256 when;\n\n    for (uint256 i; i < len;) {\n      when = approvals[u[i]];\n\n      if (when == 0) { revert Exception(16, 0, 0, address(0), address(0)); }\n\n      if (block.timestamp < when) { revert Exception(17, block.timestamp, when, address(0), address(0));\n      }\n\n      approvals[u[i]] = 0;\n      IErc20 uToken = IErc20(u[i]);\n      Safe.approve(uToken, c[i], max);\n      unchecked {\n        i++;\n      }\n    }\n\n    return true;\n  }\n  // ********* PROTOCOL UTILITY ***************\n\n  /// @notice Allows users to deposit underlying and in the process split it into/mint \n  /// zcTokens and vault notional. Calls mPlace.mintZcTokenAddingNotional\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with this market pair\n  /// @param m Maturity timestamp of this associated market\n  /// @param a Amount of underlying being deposited\n  function splitUnderlying(uint8 p, address u, uint256 m, uint256 a) external returns (bool) {\n    IErc20 uToken = IErc20(u);\n    Safe.transferFrom(uToken, msg.sender, address(this), a);\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    \n    // the underlying deposit is directed to the appropriate abstraction\n    if (!deposit(p, u, mPlace.cTokenAddress(p, u, m), a)) { revert Exception(6, 0, 0, address(0), address(0));\n    }\n\n    if (!mPlace.mintZcTokenAddingNotional(p, u, m, msg.sender, a)) { revert Exception(13, 0, 0, address(0), address(0));\n    }\n\n    return true;\n  }\n\n  /// @notice Allows users deposit/burn 1-1 amounts of both zcTokens and vault notional,\n  /// in the process \"combining\" the two, and redeeming underlying. Calls mPlace.burnZcTokenRemovingNotional.\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function combineTokens(uint8 p, address u, uint256 m, uint256 a) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n\n    if (!mPlace.burnZcTokenRemovingNotional(p, u, m, msg.sender, a)) { revert Exception(14, 0, 0, address(0), address(0));\n    }\n\n    if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), a)) { revert Exception(7, 0, 0, address(0), address(0));\n    }\n\n    Safe.transfer(IErc20(u), msg.sender, a);\n\n    return true;\n  }\n\n  /// @notice Allows users to redeem zcTokens and withdraw underlying, boiling up from the zcToken instead of starting on Swivel\n  /// @notice p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with this market pair\n  /// @param c Compound token address associated with this market pair\n  /// @param t Address of the user receiving the underlying tokens\n  /// @param a Amount of underlying being redeemed\n  function authRedeemZcToken(uint8 p, address u, address c, address t, uint256 a) external authorized(marketPlace) returns(bool) {\n    // redeem underlying from compounding\n    if (!withdraw(p, u, c, a)) { revert Exception(7, 0, 0, address(0), address(0)); }\n    // transfer underlying back to msg.sender\n    Safe.transfer(IErc20(u), t, a);\n\n    return (true);\n  }\n\n  /// @notice Allows zcToken holders to redeem their tokens for underlying tokens after maturity has been reached (via MarketPlace).\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function redeemZcToken(uint8 p, address u, uint256 m, uint256 a) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemZcToken(p, u, m, msg.sender, a);\n    // redeem underlying from compounding\n    if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), redeemed)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    // transfer underlying back to msg.sender\n    Safe.transfer(IErc20(u), msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Allows Vault owners to redeem any currently accrued interest (via MarketPlace)\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function redeemVaultInterest(uint8 p, address u, uint256 m) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemVaultInterest(p, u, m, msg.sender);\n    // redeem underlying from compounding\n    address cTokenAddr = mPlace.cTokenAddress(p, u, m);\n\n    if (!withdraw(p, u, cTokenAddr, redeemed)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    // transfer underlying back to msg.sender\n    Safe.transfer(IErc20(u), msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Allows Swivel to redeem any currently accrued interest (via MarketPlace)\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function redeemSwivelVaultInterest(uint8 p, address u, uint256 m) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemVaultInterest(p, u, m, address(this));\n    // redeem underlying from compounding\n    if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), redeemed)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    // NOTE: for swivel reddem there is no transfer out as there is in redeemVaultInterest\n\n    return true;\n  }\n\n  /// @notice Varifies the validity of an order and it's signature.\n  /// @param o An offline Swivel.Order\n  /// @param c Components of a valid ECDSA signature\n  /// @return the hashed order.\n  function validOrderHash(Hash.Order calldata o, Sig.Components calldata c) internal view returns (bytes32) {\n    bytes32 hash = Hash.order(o);\n\n    if (cancelled[hash]) { revert Exception(2, 0, 0, address(0), address(0)); }\n\n    if (o.expiry < block.timestamp) { revert Exception(3, o.expiry, block.timestamp, address(0), address(0)); }\n\n    address recovered = Sig.recover(Hash.message(domain, hash), c);\n\n    if (o.maker != recovered) { revert Exception(4, 0, 0, o.maker, recovered); }\n\n    return hash;\n  }\n\n  /// @notice Use the Protocol Enum to direct deposit type transactions to their specific library abstraction\n  /// @dev This functionality is an abstraction used by `IVFZI`, `IZFVI` and `splitUnderlying`\n  /// @param p Protocol Enum Value\n  /// @param u Address of an underlying token (used by Aave)\n  /// @param c Compounding token address\n  /// @param a Amount to deposit\n  function deposit(uint8 p, address u, address c, uint256 a) internal returns (bool) {\n    // TODO as stated elsewhere, we may choose to simply return true in all and not attempt to measure against any expected return\n    if (p == uint8(Protocols.Compound)) { // TODO is Rari a drop in here?\n      return ICompound(c).mint(a) == 0;\n    } else if (p == uint8(Protocols.Yearn)) {\n      // yearn vault api states that deposit returns shares as uint256\n      return IYearn(c).deposit(a) >= 0;\n    } else if (p == uint8(Protocols.Aave)) {\n      // Aave deposit is void. NOTE the change in pattern here where our interface is not wrapping a compounding token directly, but\n      // a specified protocol contract whose address we have set\n      // TODO explain the Aave deposit args\n      IAave(aaveAddr).deposit(u, a, address(this), 0);\n      return true;\n    } else if (p == uint8(Protocols.Euler)) {\n      // Euler deposit is void.\n      // TODO explain the 0 (primary account)\n      IEuler(c).deposit(0, a);\n      return true;\n    } else {\n      // we will allow protocol[0] to also function as a catchall for Erc4626\n      // NOTE: deposit, as per the spec, returns 'shares' but it is unknown if 0 would revert, thus we'll check for 0 or greater\n      return IErc4626(c).deposit(a, address(this)) >= 0;\n    }\n  }\n\n  /// @notice Use the Protocol Enum to direct withdraw type transactions to their specific library abstraction\n  /// @dev This functionality is an abstraction used by `EVFZE`, `EZFVE`, `combineTokens`, `redeemZcToken` and `redeemVaultInterest`.\n  /// Note that while there is an external method `withdraw` also on this contract the unique method signatures (and visibility)\n  /// exclude any possible clashing\n  /// @param p Protocol Enum Value\n  /// @param u Address of an underlying token (used by Aave)\n  /// @param c Compounding token address\n  /// @param a Amount to withdraw\n  function withdraw(uint8 p, address u, address c, uint256 a) internal returns (bool) {"
    }
  ]
}