{
  "Title": "Potentially dangerous out-of-bounds memory access in `BytesParsing::sliceUnchecked`",
  "Content": "**Description:** [`BytesParsing::sliceUnchecked`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/libraries/BytesParsing.sol#L16-L57) currently[ bails early](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/libraries/BytesParsing.sol#L21-L24) for the degenerate case when the slice length is zero; however, there is no validation on the length of the encoded bytes parameter `encoded` itself. If the length of `encoded` is less than the slice `length`, then it is possible to access memory out-of-bounds.\n\n```solidity\nfunction sliceUnchecked(bytes memory encoded, uint256 offset, uint256 length)\n    internal\n    pure\n    returns (bytes memory ret, uint256 nextOffset)\n{\n    //bail early for degenerate case\n    if (length == 0) {\n        return (new bytes(0), offset);\n    }\n\n    assembly (\"memory-safe\") {\n        nextOffset := add(offset, length)\n        ret := mload(freeMemoryPtr)\n\n        /* snip: inline dev comments */\n\n        let shift := and(length, 31) //equivalent to `mod(length, 32)` but 2 gas cheaper\n        if iszero(shift) { shift := wordSize }\n\n        let dest := add(ret, shift)\n        let end := add(dest, length)\n        for { let src := add(add(encoded, shift), offset) } lt(dest, end) {\n            src := add(src, wordSize)\n            dest := add(dest, wordSize)\n        } { mstore(dest, mload(src)) }\n\n        mstore(ret, length)\n        //When compiling with --via-ir then normally allocated memory (i.e. via new) will have 32 byte\n        //  memory alignment and so we enforce the same memory alignment here.\n        mstore(freeMemoryPtr, and(add(dest, 31), not(31)))\n    }\n}\n```\n\nSince the `for` loop begins at the offset of `encoded` in memory, accounting for its length and accompanying `shift` calculation depending on the `length` supplied, and execution continues so long as `dest` is less than `end`, it is possible to continue loading additional words out of bounds simply by passing larger `length` values. Therefore, regardless of the length of the original bytes, the output slice will always have a size defined by the `length` parameter.\n\nIt is understood that this is known behavior due to the unchecked nature of this function and the accompanying checked version, which performs validation on the `nextOffset` return value compared with the length of the encoded bytes.\n\n```solidity\nfunction slice(bytes memory encoded, uint256 offset, uint256 length)\n    internal\n    pure\n    returns (bytes memory ret, uint256 nextOffset)\n{\n    (ret, nextOffset) = sliceUnchecked(encoded, offset, length);\n    checkBound(nextOffset, encoded.length);\n}\n```\n\nIt has not been possible within the constraints of this review to identify a valid scenario in which malicious calldata can make use of this behavior to launch a successful exploit; however, this is not a guarantee that the usage of this library function is bug-free since there do [exist](https://solodit.xyz/issues/h-04-incorrect-implementation-of-access-control-in-mimoproxyexecute-code4rena-mimo-defi-mimo-august-2022-contest-git) [certain](https://solodit.xyz/issues/m-2-high-risk-checks-can-be-bypassed-with-extra-calldata-padding-sherlock-olympus-on-chain-governance-git) [quirks](https://solodit.xyz/issues/opcalldataload-opcalldatacopy-reading-position-out-of-calldata-bounds-spearbit-none-polygon-zkevm-pdf) related to the loading of calldata.\n\n**Impact:** The impact is limited in the context of the library function's usage in the scope of this review; however, it is advisable to check any other usage elsewhere and in the future to ensure that this behavior cannot be weaponized. `BytesParsing::sliceUnchecked` is currently only used in [`WormholeCctpMessages::_decodeBytes`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/libraries/WormholeCctpMessages.sol#L227-L235), which itself is called in [`WormholeCctpMessages::decodeDeposit`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/libraries/WormholeCctpMessages.sol#L196-L223). This latter function is utilized in two places:\n1. [`Logic::decodeDepositWithPayload`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/contracts/CircleIntegration/Logic.sol#L126-L148): here, any issues in slicing the encoded bytes would impact users' ability to decode payloads, potentially stopping them from correctly retrieving the necessary information for redemptions.\n2. [`WormholeCctpTokenMessenger::verifyVaaAndMint`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/contracts/WormholeCctpTokenMessenger.sol#L144-L197)/[`WormholeCctpTokenMessenger::verifyVaaAndMintLegacy`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/contracts/WormholeCctpTokenMessenger.sol#L199-L253): these functions verify and reconcile CCTP and Wormhole messages in order to mint tokens for the encoded mint recipient. Fortunately, for a malicious calldata payload, Wormhole itself will revert when [`IWormhole::parseAndVerifyVM`](https://github.com/wormhole-foundation/wormhole/blob/eee4641f55954d2d0db47831688a2e97eb20f7ee/ethereum/contracts/Messages.sol#L15-L20) is called via [`WormholeCctpTokenMessenger::_parseAndVerifyVaa`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/contracts/WormholeCctpTokenMessenger.sol#L295-L311) since it will be unable to [retrieve a valid version number](https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/Messages.sol#L150) when [casting](https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/libraries/external/BytesLib.sol#L309) to `uint8`.\n\n**Proof of Concept:** Apply the following git diff to differential test against a Python implementation:\n```diff\ndiff --git a/evm/.gitignore b/evm/.gitignore\n--- a/evm/.gitignore\n+++ b/evm/.gitignore\n@@ -7,3 +7,4 @@ lib\n node_modules\n out\n ts/src/ethers-contracts\n+venv/\ndiff --git a/evm/forge/tests/differential/BytesParsing.t.sol b/evm/forge/tests/differential/BytesParsing.t.sol\nnew file mode 100644\n--- /dev/null\n+++ b/evm/forge/tests/differential/BytesParsing.t.sol\n@@ -0,0 +1,72 @@\n+// SPDX-License-Identifier: Apache 2\n+pragma solidity ^0.8.19;\n+\n+import \"forge-std/Test.sol\";\n+import \"forge-std/console.sol\";\n+\n+import {BytesParsing} from \"src/libraries/BytesParsing.sol\";\n+\n+contract BytesParsingTest is Test {\n+    using BytesParsing for bytes;\n+\n+    function setUp() public {}\n+\n+    function test_sliceUncheckedFuzz(bytes memory encoded, uint256 offset, uint256 length) public {\n+        bound(offset, 0, type(uint8).max);\n+        bound(length, 0, type(uint8).max);\n+        if (offset > encoded.length || length > encoded.length || offset + length > encoded.length) {\n+            return;\n+        }\n+\n+        sliceUncheckedBase(encoded, offset, length);\n+    }\n+\n+    function test_sliceUncheckedConcreteReadOOB() public {\n+        bytes memory encoded = bytes(\"\");\n+        bytes32 dirty = 0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef;\n+        assembly {\n+            mstore(add(encoded, 0x20), dirty)\n+        }\n+        uint256 offset = 0;\n+        uint256 length = 32;\n+\n+        sliceUncheckedBase(encoded, offset, length);\n+    }\n+\n+    function sliceUncheckedBase(bytes memory encoded, uint256 offset, uint256 length)\n+        internal\n+        returns (\n+            bytes memory soliditySlice,\n+            uint256 solidityNextOffset,\n+            bytes memory pythonSlice,\n+            uint256 pythonNextOffset\n+        )\n+    {\n+        (soliditySlice, solidityNextOffset) = encoded.sliceUnchecked(offset, length);\n+        assertEq(soliditySlice.length, length, \"wrong length\");\n+\n+        string[] memory inputs = new string[](9);\n+        inputs[0] = \"python\";\n+        inputs[1] = \"forge/tests/differential/python/bytes_parsing.py\";\n+        inputs[2] = \"slice_unchecked\";\n+        inputs[3] = \"--encoded\";\n+        inputs[4] = vm.toString(encoded);\n+        inputs[5] = \"--offset\";\n+        inputs[6] = vm.toString(offset);\n+        inputs[7] = \"--length\";\n+        inputs[8] = vm.toString(length);\n+\n+        (pythonSlice, pythonNextOffset) = abi.decode(vm.ffi(inputs), (bytes, uint256));\n+\n+        emit log_named_uint(\"soliditySlice.length\", soliditySlice.length);\n+        emit log_named_uint(\"pythonSlice.length\", pythonSlice.length);\n+\n+        emit log_named_bytes(\"soliditySlice\", soliditySlice);\n+        emit log_named_bytes(\"pythonSlice\", pythonSlice);\n+        emit log_named_uint(\"solidityNextOffset\", solidityNextOffset);\n+        emit log_named_uint(\"pythonNextOffset\", pythonNextOffset);\n+\n+        assertEq(soliditySlice, pythonSlice, \"wrong slice\");\n+        assertEq(solidityNextOffset, pythonNextOffset, \"wrong next offset\");\n+    }\n+}\ndiff --git a/evm/forge/tests/differential/python/bytes_parsing.py b/evm/forge/tests/differential/python/bytes_parsing.py\nnew file mode 100644\n--- /dev/null\n+++ b/evm/forge/tests/differential/python/bytes_parsing.py\n@@ -0,0 +1,42 @@\n+from eth_abi import encode\n+import argparse\n+\n+\n+def main(args):\n+    if args.function == \"slice_unchecked\":\n+        slice, next_offset = slice_unchecked(args)\n+        encode_and_print(slice, next_offset)\n+\n+\n+def slice_unchecked(args):\n+    if args.length == 0:\n+        return (b\"\", args.offset)\n+\n+    next_offset = args.offset + args.length\n+\n+    encoded_bytes = (\n+        bytes.fromhex(args.encoded[2:])\n+        if args.encoded.startswith(\"0x\")\n+        else bytes.fromhex(args.encoded)\n+    )\n+    return (encoded_bytes[args.offset : next_offset], next_offset)\n+\n+\n+def encode_and_print(slice, next_offset):\n+    encoded_output = encode([\"bytes\", \"uint256\"], (slice, next_offset))\n+    ## append 0x for FFI parsing\n+    print(\"0x\" + encoded_output.hex())\n+\n+\n+def parse_args():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\"function\", choices=[\"slice_unchecked\"])\n+    parser.add_argument(\"--encoded\", type=str)\n+    parser.add_argument(\"--offset\", type=int)\n+    parser.add_argument(\"--length\", type=int)\n+    return parser.parse_args()\n+\n+\n+if __name__ == \"__main__\":\n+    args = parse_args()\n+    main(args)\ndiff --git a/evm/forge/tests/differential/python/requirements.txt b/evm/forge/tests/differential/python/requirements.txt\nnew file mode 100644\n--- /dev/null\n+++ b/evm/forge/tests/differential/python/requirements.txt\n@@ -0,0 +1 @@\n+eth_abi==5.0.0\n\\ No newline at end of file\ndiff --git a/evm/foundry.toml b/evm/foundry.toml\n--- a/evm/foundry.toml\n+++ b/evm/foundry.toml\n@@ -31,4 +31,7 @@ gas_reports = [\"*\"]\n\n gas_limit = \"18446744073709551615\"\n\n+[profile.ffi]\n+ffi = true\n+\n```\n\n**Recommended Mitigation:** Consider bailing early if the length of the bytes from which to construct a slice is zero, and always ensure the resultant offset is correctly validated against the length when using the unchecked version of the function.\n\n**Wormhole Foundation:** The [slice method](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/7599cbe984ce17dd9e87c81fb0b6ea12ff1635ba/evm/src/libraries/BytesParsing.sol#L59) does this checking for us. Since we’re controlling the length specified in the wire format, we can safely use the unchecked variant.\n\n**Cyfrin:** Acknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/libraries/BytesParsing.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.19;\n\nlibrary BytesParsing {\n    uint256 private constant freeMemoryPtr = 0x40;\n    uint256 private constant wordSize = 32;\n\n    error OutOfBounds(uint256 offset, uint256 length);\n\n    function checkBound(uint256 offset, uint256 length) internal pure {\n        if (offset > length) {\n            revert OutOfBounds(offset, length);\n        }\n    }\n\n    function sliceUnchecked(bytes memory encoded, uint256 offset, uint256 length)\n        internal\n        pure\n        returns (bytes memory ret, uint256 nextOffset)\n    {\n        //bail early for degenerate case\n        if (length == 0) {\n            return (new bytes(0), offset);\n        }\n\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, length)\n            ret := mload(freeMemoryPtr)\n\n            //Explanation on how we copy data here:\n            //  The bytes type has the following layout in memory:\n            //    [length: 32 bytes, data: length bytes]\n            //  So if we allocate `bytes memory foo = new bytes(1);` then `foo` will be a pointer to 33\n            //    bytes where the first 32 bytes contain the length and the last byte is the actual data.\n            //  Since mload always loads 32 bytes of memory at once, we use our shift variable to align\n            //    our reads so that our last read lines up exactly with the last 32 bytes of `encoded`.\n            //  However this also means that if the length of `encoded` is not a multiple of 32 bytes, our\n            //    first read will necessarily partly contain bytes from `encoded`'s 32 length bytes that\n            //    will be written into the length part of our `ret` slice.\n            //  We remedy this issue by writing the length of our `ret` slice at the end, thus\n            //    overwritting those garbage bytes.\n            let shift := and(length, 31) //equivalent to `mod(length, 32)` but 2 gas cheaper\n            if iszero(shift) { shift := wordSize }\n\n            let dest := add(ret, shift)\n            let end := add(dest, length)\n            for { let src := add(add(encoded, shift), offset) } lt(dest, end) {\n                src := add(src, wordSize)\n                dest := add(dest, wordSize)\n            } { mstore(dest, mload(src)) }\n\n            mstore(ret, length)\n            //When compiling with --via-ir then normally allocated memory (i.e. via new) will have 32 byte\n            //  memory alignment and so we enforce the same memory alignment here.\n            mstore(freeMemoryPtr, and(add(dest, 31), not(31)))\n        }\n    }\n\n    function slice(bytes memory encoded, uint256 offset, uint256 length)\n        internal\n        pure\n        returns (bytes memory ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = sliceUnchecked(encoded, offset, length);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asAddressUnchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (address, uint256)\n    {\n        (uint160 ret, uint256 nextOffset) = asUint160(encoded, offset);\n        return (address(ret), nextOffset);\n    }\n\n    function asAddress(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (address ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asAddressUnchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBoolUnckecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        (uint8 ret, uint256 nextOffset) = asUint8(encoded, offset);\n        return (ret != 0, nextOffset);\n    }\n\n    function asBool(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bool ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asBoolUnckecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    /* -------------------------------------------------------------------------------------------------\n    Remaining library code below was auto-generated by via the following js/node code:\n\n    for (let bytes = 1; bytes <= 32; ++bytes) {\n    const bits = bytes*8;\n    console.log(\n    `function asUint${bits}Unchecked(\n    bytes memory encoded,\n    uint offset\n    ) internal pure returns (uint${bits} ret, uint nextOffset) {\n    assembly (\"memory-safe\") {\n    nextOffset := add(offset, ${bytes})\n    ret := mload(add(encoded, nextOffset))\n    }\n    return (ret, nextOffset);\n    }\n\n    function asUint${bits}(\n    bytes memory encoded,\n    uint offset\n    ) internal pure returns (uint${bits} ret, uint nextOffset) {\n    (ret, nextOffset) = asUint${bits}Unchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes${bytes}Unchecked(\n    bytes memory encoded,\n    uint offset\n    ) internal pure returns (bytes${bytes}, uint) {\n    (uint${bits} ret, uint nextOffset) = asUint${bits}Unchecked(encoded, offset);\n    return (bytes${bytes}(ret), nextOffset);\n    }\n\n    function asBytes${bytes}(\n    bytes memory encoded,\n    uint offset\n    ) internal pure returns (bytes${bytes}, uint) {\n    (uint${bits} ret, uint nextOffset) = asUint${bits}(encoded, offset);\n    return (bytes${bytes}(ret), nextOffset);\n    }\n    `\n    );\n    }\n    ------------------------------------------------------------------------------------------------- */\n\n    function asUint8Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint8 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 1)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint8(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint8 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint8Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes1Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes1, uint256)\n    {\n        (uint8 ret, uint256 nextOffset) = asUint8Unchecked(encoded, offset);\n        return (bytes1(ret), nextOffset);\n    }\n\n    function asBytes1(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes1, uint256)\n    {\n        (uint8 ret, uint256 nextOffset) = asUint8(encoded, offset);\n        return (bytes1(ret), nextOffset);\n    }\n\n    function asUint16Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint16 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 2)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint16(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint16 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint16Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes2Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes2, uint256)\n    {\n        (uint16 ret, uint256 nextOffset) = asUint16Unchecked(encoded, offset);\n        return (bytes2(ret), nextOffset);\n    }\n\n    function asBytes2(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes2, uint256)\n    {\n        (uint16 ret, uint256 nextOffset) = asUint16(encoded, offset);\n        return (bytes2(ret), nextOffset);\n    }\n\n    function asUint24Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint24 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 3)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint24(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint24 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint24Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes3Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes3, uint256)\n    {\n        (uint24 ret, uint256 nextOffset) = asUint24Unchecked(encoded, offset);\n        return (bytes3(ret), nextOffset);\n    }\n\n    function asBytes3(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes3, uint256)\n    {\n        (uint24 ret, uint256 nextOffset) = asUint24(encoded, offset);\n        return (bytes3(ret), nextOffset);\n    }\n\n    function asUint32Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint32 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 4)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint32(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint32 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint32Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes4Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes4, uint256)\n    {\n        (uint32 ret, uint256 nextOffset) = asUint32Unchecked(encoded, offset);\n        return (bytes4(ret), nextOffset);\n    }\n\n    function asBytes4(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes4, uint256)\n    {\n        (uint32 ret, uint256 nextOffset) = asUint32(encoded, offset);\n        return (bytes4(ret), nextOffset);\n    }\n\n    function asUint40Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint40 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 5)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint40(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint40 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint40Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes5Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes5, uint256)\n    {\n        (uint40 ret, uint256 nextOffset) = asUint40Unchecked(encoded, offset);\n        return (bytes5(ret), nextOffset);\n    }\n\n    function asBytes5(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes5, uint256)\n    {\n        (uint40 ret, uint256 nextOffset) = asUint40(encoded, offset);\n        return (bytes5(ret), nextOffset);\n    }\n\n    function asUint48Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint48 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 6)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint48(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint48 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint48Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes6Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes6, uint256)\n    {\n        (uint48 ret, uint256 nextOffset) = asUint48Unchecked(encoded, offset);\n        return (bytes6(ret), nextOffset);\n    }\n\n    function asBytes6(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes6, uint256)\n    {\n        (uint48 ret, uint256 nextOffset) = asUint48(encoded, offset);\n        return (bytes6(ret), nextOffset);\n    }\n\n    function asUint56Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint56 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 7)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint56(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint56 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint56Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes7Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes7, uint256)\n    {\n        (uint56 ret, uint256 nextOffset) = asUint56Unchecked(encoded, offset);\n        return (bytes7(ret), nextOffset);\n    }\n\n    function asBytes7(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes7, uint256)\n    {\n        (uint56 ret, uint256 nextOffset) = asUint56(encoded, offset);\n        return (bytes7(ret), nextOffset);\n    }\n\n    function asUint64Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint64 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 8)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint64(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint64 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint64Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes8Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes8, uint256)\n    {\n        (uint64 ret, uint256 nextOffset) = asUint64Unchecked(encoded, offset);\n        return (bytes8(ret), nextOffset);\n    }\n\n    function asBytes8(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes8, uint256)\n    {\n        (uint64 ret, uint256 nextOffset) = asUint64(encoded, offset);\n        return (bytes8(ret), nextOffset);\n    }\n\n    function asUint72Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint72 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 9)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint72(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint72 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint72Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes9Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes9, uint256)\n    {\n        (uint72 ret, uint256 nextOffset) = asUint72Unchecked(encoded, offset);\n        return (bytes9(ret), nextOffset);\n    }\n\n    function asBytes9(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes9, uint256)\n    {\n        (uint72 ret, uint256 nextOffset) = asUint72(encoded, offset);\n        return (bytes9(ret), nextOffset);\n    }\n\n    function asUint80Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint80 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 10)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint80(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint80 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint80Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes10Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes10, uint256)\n    {\n        (uint80 ret, uint256 nextOffset) = asUint80Unchecked(encoded, offset);\n        return (bytes10(ret), nextOffset);\n    }\n\n    function asBytes10(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes10, uint256)\n    {\n        (uint80 ret, uint256 nextOffset) = asUint80(encoded, offset);\n        return (bytes10(ret), nextOffset);\n    }\n\n    function asUint88Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint88 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 11)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint88(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint88 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint88Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes11Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes11, uint256)\n    {\n        (uint88 ret, uint256 nextOffset) = asUint88Unchecked(encoded, offset);\n        return (bytes11(ret), nextOffset);\n    }\n\n    function asBytes11(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes11, uint256)\n    {\n        (uint88 ret, uint256 nextOffset) = asUint88(encoded, offset);\n        return (bytes11(ret), nextOffset);\n    }\n\n    function asUint96Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint96 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 12)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint96(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint96 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint96Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes12Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes12, uint256)\n    {\n        (uint96 ret, uint256 nextOffset) = asUint96Unchecked(encoded, offset);\n        return (bytes12(ret), nextOffset);\n    }\n\n    function asBytes12(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes12, uint256)\n    {\n        (uint96 ret, uint256 nextOffset) = asUint96(encoded, offset);\n        return (bytes12(ret), nextOffset);\n    }\n\n    function asUint104Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint104 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 13)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint104(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint104 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint104Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes13Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes13, uint256)\n    {\n        (uint104 ret, uint256 nextOffset) = asUint104Unchecked(encoded, offset);\n        return (bytes13(ret), nextOffset);\n    }\n\n    function asBytes13(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes13, uint256)\n    {\n        (uint104 ret, uint256 nextOffset) = asUint104(encoded, offset);\n        return (bytes13(ret), nextOffset);\n    }\n\n    function asUint112Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint112 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 14)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint112(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint112 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint112Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes14Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes14, uint256)\n    {\n        (uint112 ret, uint256 nextOffset) = asUint112Unchecked(encoded, offset);\n        return (bytes14(ret), nextOffset);\n    }\n\n    function asBytes14(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes14, uint256)\n    {\n        (uint112 ret, uint256 nextOffset) = asUint112(encoded, offset);\n        return (bytes14(ret), nextOffset);\n    }\n\n    function asUint120Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint120 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 15)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint120(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint120 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint120Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes15Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes15, uint256)\n    {\n        (uint120 ret, uint256 nextOffset) = asUint120Unchecked(encoded, offset);\n        return (bytes15(ret), nextOffset);\n    }\n\n    function asBytes15(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes15, uint256)\n    {\n        (uint120 ret, uint256 nextOffset) = asUint120(encoded, offset);\n        return (bytes15(ret), nextOffset);\n    }\n\n    function asUint128Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint128 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 16)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint128(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint128 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint128Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes16Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes16, uint256)\n    {\n        (uint128 ret, uint256 nextOffset) = asUint128Unchecked(encoded, offset);\n        return (bytes16(ret), nextOffset);\n    }\n\n    function asBytes16(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes16, uint256)\n    {\n        (uint128 ret, uint256 nextOffset) = asUint128(encoded, offset);\n        return (bytes16(ret), nextOffset);\n    }\n\n    function asUint136Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint136 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 17)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint136(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint136 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint136Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes17Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes17, uint256)\n    {\n        (uint136 ret, uint256 nextOffset) = asUint136Unchecked(encoded, offset);\n        return (bytes17(ret), nextOffset);\n    }\n\n    function asBytes17(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes17, uint256)\n    {\n        (uint136 ret, uint256 nextOffset) = asUint136(encoded, offset);\n        return (bytes17(ret), nextOffset);\n    }\n\n    function asUint144Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint144 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 18)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint144(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint144 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint144Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes18Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes18, uint256)\n    {\n        (uint144 ret, uint256 nextOffset) = asUint144Unchecked(encoded, offset);\n        return (bytes18(ret), nextOffset);\n    }\n\n    function asBytes18(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes18, uint256)\n    {\n        (uint144 ret, uint256 nextOffset) = asUint144(encoded, offset);\n        return (bytes18(ret), nextOffset);\n    }\n\n    function asUint152Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint152 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 19)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint152(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint152 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint152Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes19Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes19, uint256)\n    {\n        (uint152 ret, uint256 nextOffset) = asUint152Unchecked(encoded, offset);\n        return (bytes19(ret), nextOffset);\n    }\n\n    function asBytes19(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes19, uint256)\n    {\n        (uint152 ret, uint256 nextOffset) = asUint152(encoded, offset);\n        return (bytes19(ret), nextOffset);\n    }\n\n    function asUint160Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint160 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 20)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint160(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint160 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint160Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes20Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes20, uint256)\n    {\n        (uint160 ret, uint256 nextOffset) = asUint160Unchecked(encoded, offset);\n        return (bytes20(ret), nextOffset);\n    }\n\n    function asBytes20(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes20, uint256)\n    {\n        (uint160 ret, uint256 nextOffset) = asUint160(encoded, offset);\n        return (bytes20(ret), nextOffset);\n    }\n\n    function asUint168Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint168 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 21)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint168(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint168 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint168Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes21Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes21, uint256)\n    {\n        (uint168 ret, uint256 nextOffset) = asUint168Unchecked(encoded, offset);\n        return (bytes21(ret), nextOffset);\n    }\n\n    function asBytes21(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes21, uint256)\n    {\n        (uint168 ret, uint256 nextOffset) = asUint168(encoded, offset);\n        return (bytes21(ret), nextOffset);\n    }\n\n    function asUint176Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint176 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 22)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint176(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint176 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint176Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes22Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes22, uint256)\n    {\n        (uint176 ret, uint256 nextOffset) = asUint176Unchecked(encoded, offset);\n        return (bytes22(ret), nextOffset);\n    }\n\n    function asBytes22(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes22, uint256)\n    {\n        (uint176 ret, uint256 nextOffset) = asUint176(encoded, offset);\n        return (bytes22(ret), nextOffset);\n    }\n\n    function asUint184Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint184 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 23)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint184(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint184 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint184Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes23Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes23, uint256)\n    {\n        (uint184 ret, uint256 nextOffset) = asUint184Unchecked(encoded, offset);\n        return (bytes23(ret), nextOffset);\n    }\n\n    function asBytes23(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes23, uint256)\n    {\n        (uint184 ret, uint256 nextOffset) = asUint184(encoded, offset);\n        return (bytes23(ret), nextOffset);\n    }\n\n    function asUint192Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint192 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 24)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint192(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint192 ret, uint256 nextOffset)\n    {\n        (ret, nextOffset) = asUint192Unchecked(encoded, offset);\n        checkBound(nextOffset, encoded.length);\n    }\n\n    function asBytes24Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes24, uint256)\n    {\n        (uint192 ret, uint256 nextOffset) = asUint192Unchecked(encoded, offset);\n        return (bytes24(ret), nextOffset);\n    }\n\n    function asBytes24(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (bytes24, uint256)\n    {\n        (uint192 ret, uint256 nextOffset) = asUint192(encoded, offset);\n        return (bytes24(ret), nextOffset);\n    }\n\n    function asUint200Unchecked(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns (uint200 ret, uint256 nextOffset)\n    {\n        assembly (\"memory-safe\") {\n            nextOffset := add(offset, 25)\n            ret := mload(add(encoded, nextOffset))\n        }\n        return (ret, nextOffset);\n    }\n\n    function asUint200(bytes memory encoded, uint256 offset)\n        internal\n        pure\n        returns"
    }
  ]
}