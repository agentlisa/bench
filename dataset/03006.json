{
  "Title": "M-1: MetaStable2TokenAuraVault allows only up to 1bp weight for Balancer TWAP oracle",
  "Content": "# Issue M-1: MetaStable2TokenAuraVault allows only up to 1bp weight for Balancer TWAP oracle \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/135 \n\n## Found by \nhyh\n\n## Summary\n\nMetaStable2TokenAuraVault's Vault settings are initialized and set with Balancer TWAP oracle weight limit hard coded to `BalancerConstants.VAULT_PERCENT_BASIS`, which is only `1bp` of the total weight, which means that Balancer TWAP do not take any meaningful part in Vault's pricing.\n\n## Vulnerability Detail\n\n_getOraclePairPrice() output is the weighted average of Chainlink and Balancer reported values. While such setup is constructed to enhance the stability of the resulting price feed, now it's incorrectly initialized in such a way that Balancer TWAP oracle's share will be at most `1bp`, i.e. it has almost no influence on the price and price feed stability is basically the same as one of Chainlink oracle.\n\n## Impact\n\nMetaStable2TokenAuraVault strategy will be priced off at least `0.9999` of Chanlink's price and at most `0.0001` of Balancer's TWAP. This way any Chanlink malfunctions and volatility spikes will be almost fully translated to the MetaStable2TokenAuraVault pricing, while Balancer's TWAP is being ignored.\n\nNet impact is the user losses in the event of Chainlink price feed erroneous values (typical mispricing surfaces: liquidation of healthy accounts, prohibition of liquidation of the unhealthy ones).\n\nAs this is the condition for the net loss for the users to occur despite clear technical misconfiguration, setting the severity to be **medium**.\n\n## Code Snippet\n\nMetaStable2TokenAuraVault requires that `balancerOracleWeight <= BalancerConstants.VAULT_PERCENT_BASIS`, i.e. `VAULT_PERCENT_BASIS` is set as Balancer TWAP oracle weight limit:\n\ninitialize:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/MetaStable2TokenAuraVault.sol#L44-L52\n\n```solidity\n    function initialize(InitParams calldata params)\n        external\n        initializer\n        onlyNotionalOwner\n    {\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n        BalancerVaultStorage.setStrategyVaultSettings(\n            params.settings, MAX_ORACLE_QUERY_WINDOW, BalancerConstants.VAULT_PERCENT_BASIS\n        );\n```\n\nsetStrategyVaultSettings:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/MetaStable2TokenAuraVault.sol#L168-L177\n\n```solidity\n    /// @notice Updates the vault settings\n    /// @param settings vault settings\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings)\n        external\n        onlyNotionalOwner\n    {\n        BalancerVaultStorage.setStrategyVaultSettings(\n            settings, MAX_ORACLE_QUERY_WINDOW, BalancerConstants.VAULT_PERCENT_BASIS\n        );\n    }\n```\n\nIn the same time the weight is then calculated out of `BALANCER_ORACLE_WEIGHT_PRECISION = 1e8`:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/BalancerConstants.sol#L7-L12\n\n```solidity\n    uint256 internal constant BALANCER_ORACLE_WEIGHT_PRECISION = 1e8;\n    uint32 internal constant SLIPPAGE_LIMIT_PRECISION = 1e8;\n\n    /// @notice Precision for all percentages used by the vault\n    /// 1e4 = 100% (i.e. maxBalancerPoolShare)\n    uint16 internal constant VAULT_PERCENT_BASIS = 1e4;\n```\n\nI.e. _getOraclePairPrice() logic is based on an assumption that `balancerOracleWeight` is a part of the `BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION`:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L66-L114\n\n```solidity\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param oracleContext oracle context variables\n    /// @param tradingModule address of the trading module\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext, \n        ITradingModule tradingModule\n    ) internal view returns (uint256 oraclePairPrice) {\n        // NOTE: this balancer price is denominated in 18 decimal places\n        uint256 balancerWeightedPrice;\n        if (oracleContext.balancerOracleWeight > 0) {\n            uint256 balancerPrice = BalancerUtils._getTimeWeightedOraclePrice(\n                address(poolContext.basePool.pool),\n                IPriceOracle.Variable.PAIR_PRICE,\n                oracleContext.oracleWindowInSeconds\n            );\n\n            if (poolContext.primaryIndex == 1) {\n                // If the primary index is the second token, we need to invert\n                // the balancer price.\n                balancerPrice = BalancerConstants.BALANCER_PRECISION_SQUARED / balancerPrice;\n            }\n\n            balancerWeightedPrice = balancerPrice * oracleContext.balancerOracleWeight;\n        }\n\n        uint256 chainlinkWeightedPrice;\n        if (oracleContext.balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION) {\n            (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n                poolContext.primaryToken, poolContext.secondaryToken\n            );\n            require(rate > 0);\n            require(decimals >= 0);\n\n            if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n                rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n            }\n\n            // No overflow in rate conversion, checked above\n            chainlinkWeightedPrice = uint256(rate) * \n                (BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION - oracleContext.balancerOracleWeight);\n        }\n\n        oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n            BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION;\n    }\n```\n\nThis way requiring that `balancerOracleWeight <= BalancerConstants.VAULT_PERCENT_BASIS` means that no more than 1bp, `VAULT_PERCENT_BASIS / BALANCER_ORACLE_WEIGHT_PRECISION = 1e-4`, of the _getOraclePairPrice's `oraclePairPrice` will consists of Balancer TWAP oracle.\n\nThis doesn't fit any logic, i.e. if Balancer TWAP oracle price shouldn't be used the limit should be zero, as it's done in the Boosted3TokenAuraVault's case:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/Boosted3TokenAuraVault.sol#L176-L188\n\n```solidity\n    /// @notice Updates the vault settings\n    /// @param settings vault settings\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings)\n        external\n        onlyNotionalOwner\n    {\n        // 3 token vaults do not use the Balancer oracle\n        BalancerVaultStorage.setStrategyVaultSettings(\n            settings, \n            0, // Max Balancer oracle window size\n            0  // Balancer oracle weight\n        );\n    }\n```\n\nIf it should be used, the limit need to be set higher to allow some meaningful value.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider updating the limit so a non-trivial weight can be set for Balancer oracle, for example:\n\ninitialize:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/MetaStable2TokenAuraVault.sol#L44-L52\n\n```solidity\n    function initialize(InitParams calldata params)\n        external\n        initializer\n        onlyNotionalOwner\n    {\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n        BalancerVaultStorage.setStrategyVaultSettings(\n-           params.settings, MAX_ORACLE_QUERY_WINDOW, BalancerConstants.VAULT_PERCENT_BASIS\n+           params.settings, MAX_ORACLE_QUERY_WINDOW, BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION\n        );\n```\n\nsetStrategyVaultSettings:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/MetaStable2TokenAuraVault.sol#L168-L177\n\n```solidity\n    /// @notice Updates the vault settings\n    /// @param settings vault settings\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings)\n        external\n        onlyNotionalOwner\n    {\n        BalancerVaultStorage.setStrategyVaultSettings(\n-           settings, MAX_ORACLE_QUERY_WINDOW, BalancerConstants.VAULT_PERCENT_BASIS\n+           settings, MAX_ORACLE_QUERY_WINDOW, BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION\n        );\n    }\n```\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000 \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/MetaStable2TokenAuraVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {BalancerConstants} from \"./balancer/internal/BalancerConstants.sol\";\nimport {Errors} from \"../global/Errors.sol\";\nimport {\n    DepositParams,\n    RedeemParams,\n    AuraVaultDeploymentParams,\n    InitParams,\n    ReinvestRewardParams,\n    StrategyVaultSettings,\n    StrategyVaultState,\n    PoolContext,\n    TwoTokenPoolContext,\n    StableOracleContext,\n    MetaStable2TokenAuraStrategyContext,\n    StrategyContext\n} from \"./balancer/BalancerVaultTypes.sol\";\nimport {BalancerStrategyBase} from \"./balancer/BalancerStrategyBase.sol\";\nimport {MetaStable2TokenVaultMixin} from \"./balancer/mixins/MetaStable2TokenVaultMixin.sol\";\nimport {AuraStakingMixin} from \"./balancer/mixins/AuraStakingMixin.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {BalancerVaultStorage} from \"./balancer/internal/BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"./balancer/internal/strategy/StrategyUtils.sol\";\nimport {SettlementUtils} from \"./balancer/internal/settlement/SettlementUtils.sol\";\nimport {TwoTokenPoolUtils} from \"./balancer/internal/pool/TwoTokenPoolUtils.sol\";\nimport {MetaStable2TokenAuraHelper} from \"./balancer/external/MetaStable2TokenAuraHelper.sol\";\n\ncontract MetaStable2TokenAuraVault is MetaStable2TokenVaultMixin {\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n    using StrategyUtils for StrategyContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    \n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params) \n        MetaStable2TokenVaultMixin(notional_, params)\n    {}\n\n    function strategy() external override view returns (bytes4) {\n        return bytes4(keccak256(\"MetaStable2TokenAura\"));\n    }\n\n    function initialize(InitParams calldata params)\n        external\n        initializer\n        onlyNotionalOwner\n    {\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n        BalancerVaultStorage.setStrategyVaultSettings(\n            params.settings, MAX_ORACLE_QUERY_WINDOW, BalancerConstants.VAULT_PERCENT_BASIS\n        );\n        _twoTokenPoolContext()._approveBalancerTokens(address(_auraStakingContext().auraBooster));\n    }\n\n    function _depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 strategyTokensMinted) {\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n\n        strategyTokensMinted = context.poolContext._deposit({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            deposit: deposit,\n            params: params\n        });\n    }\n\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 finalPrimaryBalance) {    \n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n        MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n\n        finalPrimaryBalance = context.poolContext._redeem({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            account: account,\n            strategyTokens: strategyTokens,\n            maturity: maturity,\n            params: params\n        });\n    }\n\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 strategyTokenAmount,\n        uint256 maturity\n    ) public view virtual override returns (int256 underlyingValue) {\n        MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n        underlyingValue = context.poolContext._convertStrategyToUnderlying({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext.baseOracle,\n            strategyTokenAmount: strategyTokenAmount\n        });\n    }\n\n    function settleVaultNormal(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external {\n        if (maturity <= block.timestamp) {\n            revert Errors.PostMaturitySettlement();\n        }\n        if (block.timestamp < maturity - SETTLEMENT_PERIOD_IN_SECONDS) {\n            revert Errors.NotInSettlementWindow();\n        }\n        MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n        SettlementUtils._validateCoolDown(\n            context.baseStrategy.vaultState.lastSettlementTimestamp,\n            context.baseStrategy.vaultSettings.settlementCoolDownInMinutes\n        );\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.settlementSlippageLimitPercent,\n            data\n        );\n        MetaStable2TokenAuraHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n        context.baseStrategy.vaultState.lastSettlementTimestamp = uint32(block.timestamp);\n        context.baseStrategy.vaultState.setStrategyVaultState();\n    }\n\n    function settleVaultPostMaturity(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external onlyNotionalOwner {\n        if (block.timestamp < maturity) {\n            revert Errors.HasNotMatured();\n        }\n        MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n        SettlementUtils._validateCoolDown(\n            context.baseStrategy.vaultState.lastPostMaturitySettlementTimestamp,\n            context.baseStrategy.vaultSettings.postMaturitySettlementCoolDownInMinutes\n        );\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.postMaturitySettlementSlippageLimitPercent,\n            data\n        );\n        MetaStable2TokenAuraHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n        context.baseStrategy.vaultState.lastPostMaturitySettlementTimestamp = uint32(block.timestamp);    \n        context.baseStrategy.vaultState.setStrategyVaultState();  \n    }\n\n    function settleVaultEmergency(uint256 maturity, bytes calldata data) external {\n        // No need for emergency settlement during the settlement window\n        _revertInSettlementWindow(maturity);\n        MetaStable2TokenAuraHelper.settleVaultEmergency(\n            _strategyContext(), maturity, data\n        );\n    }\n\n    function reinvestReward(ReinvestRewardParams calldata params) external {\n        MetaStable2TokenAuraHelper.reinvestReward(_strategyContext(), params);\n    }\n\n    /// @notice Updates the vault settings\n    /// @param settings vault settings\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings)\n        external\n        onlyNotionalOwner\n    {\n        BalancerVaultStorage.setStrategyVaultSettings(\n            settings, MAX_ORACLE_QUERY_WINDOW, BalancerConstants.VAULT_PERCENT_BASIS\n        );\n    }\n\n    function _strategyContext() private view returns (MetaStable2TokenAuraStrategyContext memory) {\n        return MetaStable2TokenAuraStrategyContext({\n            poolContext: _twoTokenPoolContext(),\n            oracleContext: _stableOracleContext(),\n            stakingContext: _auraStakingContext(),\n            baseStrategy: _baseStrategyContext()\n        });\n    }\n    \n    function getStrategyContext() external view returns (MetaStable2TokenAuraStrategyContext memory) {\n        return _strategyContext();\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/MetaStable2TokenAuraVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {BalancerConstants} from \"./balancer/internal/BalancerConstants.sol\";\nimport {Errors} from \"../global/Errors.sol\";\nimport {\n    DepositParams,\n    RedeemParams,\n    AuraVaultDeploymentParams,\n    InitParams,\n    ReinvestRewardParams,\n    StrategyVaultSettings,\n    StrategyVaultState,\n    PoolContext,\n    TwoTokenPoolContext,\n    StableOracleContext,\n    MetaStable2TokenAuraStrategyContext,\n    StrategyContext\n} from \"./balancer/BalancerVaultTypes.sol\";\nimport {BalancerStrategyBase} from \"./balancer/BalancerStrategyBase.sol\";\nimport {MetaStable2TokenVaultMixin} from \"./balancer/mixins/MetaStable2TokenVaultMixin.sol\";\nimport {AuraStakingMixin} from \"./balancer/mixins/AuraStakingMixin.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {BalancerVaultStorage} from \"./balancer/internal/BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"./balancer/internal/strategy/StrategyUtils.sol\";\nimport {SettlementUtils} from \"./balancer/internal/settlement/SettlementUtils.sol\";\nimport {TwoTokenPoolUtils} from \"./balancer/internal/pool/TwoTokenPoolUtils.sol\";\nimport {MetaStable2TokenAuraHelper} from \"./balancer/external/MetaStable2TokenAuraHelper.sol\";\n\ncontract MetaStable2TokenAuraVault is MetaStable2TokenVaultMixin {\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n    using StrategyUtils for StrategyContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    \n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params) \n        MetaStable2TokenVaultMixin(notional_, params)\n    {}\n\n    function strategy() external override view returns (bytes4) {\n        return bytes4(keccak256(\"MetaStable2TokenAura\"));\n    }\n\n    function initialize(InitParams calldata params)\n        external\n        initializer\n        onlyNotionalOwner\n    {\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n        BalancerVaultStorage.setStrategyVaultSettings(\n            params.settings, MAX_ORACLE_QUERY_WINDOW, BalancerConstants.VAULT_PERCENT_BASIS\n        );\n        _twoTokenPoolContext()._approveBalancerTokens(address(_auraStakingContext().auraBooster));\n    }\n\n    function _depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 strategyTokensMinted) {\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n\n        strategyTokensMinted = context.poolContext._deposit({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            deposit: deposit,\n            params: params\n        });\n    }\n\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 finalPrimaryBalance) {    \n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n        MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n\n        finalPrimaryBalance = context.poolContext._redeem({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            account: account,\n            strategyTokens: strategyTokens,\n            maturity: maturity,\n            params: params\n        });\n    }\n\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 strategyTokenAmount,\n        uint256 maturity\n    ) public view virtual override returns (int256 underlyingValue) {\n        MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n        underlyingValue = context.poolContext._convertStrategyToUnderlying({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext.baseOracle,\n            strategyTokenAmount: strategyTokenAmount\n        });\n    }\n\n    function settleVaultNormal(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external {\n        if (maturity <= block.timestamp) {\n            revert Errors.PostMaturitySettlement();\n        }\n        if (block.timestamp < maturity - SETTLEMENT_PERIOD_IN_SECONDS) {\n            revert Errors.NotInSettlementWindow();\n        }\n        MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n        SettlementUtils._validateCoolDown(\n            context.baseStrategy.vaultState.lastSettlementTimestamp,\n            context.baseStrategy.vaultSettings.settlementCoolDownInMinutes\n        );\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.settlementSlippageLimitPercent,\n            data\n        );\n        MetaStable2TokenAuraHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n        context.baseStrategy.vaultState.lastSettlementTimestamp = uint32(block.timestamp);\n        context.baseStrategy.vaultState.setStrategyVaultState();\n    }\n\n    function settleVaultPostMaturity(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external onlyNotionalOwner {\n        if (block.timestamp < maturity) {\n            revert Errors.HasNotMatured();\n        }\n        MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n        SettlementUtils._validateCoolDown(\n            context.baseStrategy.vaultState.lastPostMaturitySettlementTimestamp,\n            context.baseStrategy.vaultSettings.postMaturitySettlementCoolDownInMinutes\n        );\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.postMaturitySettlementSlippageLimitPercent,\n            data\n        );\n        MetaStable2TokenAuraHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n        context.baseStrategy.vaultState.lastPostMaturitySettlementTimestamp = uint32(block.timestamp);    \n        context.baseStrategy.vaultState.setStrategyVaultState();  \n    }\n\n    function settleVaultEmergency(uint256 maturity, bytes calldata data) external {\n        // No need for emergency settlement during the settlement window\n        _revertInSettlementWindow(maturity);\n        MetaStable2TokenAuraHelper.settleVaultEmergency(\n            _strategyContext(), maturity, data\n        );\n    }\n\n    function reinvestReward(ReinvestRewardParams calldata params) external {\n        MetaStable2TokenAuraHelper.reinvestReward(_strategyContext(), params);\n    }\n\n    /// @notice Updates the vault settings\n    /// @param settings vault settings\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings)\n        external\n        onlyNotionalOwner\n    {\n        BalancerVaultStorage.setStrategyVaultSettings(\n            settings, MAX_ORACLE_QUERY_WINDOW, BalancerConstants.VAULT_PERCENT_BASIS\n        );\n    }\n\n    function _strategyContext() private view returns (MetaStable2TokenAuraStrategyContext memory) {\n        return MetaStable2TokenAuraStrategyContext({\n            poolContext: _twoTokenPoolContext(),\n            oracleContext: _stableOracleContext(),\n            stakingContext: _auraStakingContext(),\n            baseStrategy: _baseStrategyContext()\n        });\n    }\n    \n    function getStrategyContext() external view returns (MetaStable2TokenAuraStrategyContext memory) {\n        return _strategyContext();\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/BalancerConstants.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.8.15;\n\nlibrary BalancerConstants {\n    uint256 internal constant BALANCER_PRECISION = 1e18;\n    uint256 internal constant BALANCER_PRECISION_SQUARED = 1e36;\n    uint256 internal constant BALANCER_ORACLE_WEIGHT_PRECISION = 1e8;\n    uint32 internal constant SLIPPAGE_LIMIT_PRECISION = 1e8;\n\n    /// @notice Precision for all percentages used by the vault\n    /// 1e4 = 100% (i.e. maxBalancerPoolShare)\n    uint16 internal constant VAULT_PERCENT_BASIS = 1e4;\n    /// @notice Buffer percentage between the desired share of the Balancer pool\n    /// and the maximum share of the pool allowed by maxBalancerPoolShare 1e4 = 100%, 8e3 = 80%\n    uint16 internal constant BALANCER_POOL_SHARE_BUFFER = 8e3;\n    /// @notice Max settlement cool down period allowed (1 day)\n    uint16 internal constant MAX_SETTLEMENT_COOLDOWN_IN_MINUTES = 24 * 60;\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {\n    TwoTokenPoolContext, \n    OracleContext, \n    PoolParams,\n    DepositParams,\n    DynamicTradeParams,\n    DepositTradeParams,\n    RedeemParams,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IAsset} from \"../../../../../interfaces/balancer/IBalancerVault.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {TwoTokenPoolUtils} from \"../pool/TwoTokenPoolUtils.sol\";\nimport {ITradingModule, Trade} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TradeHandler for Trade;\n    using TypeConvert for uint256;\n    using StrategyUtils for StrategyContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    /// @notice Returns parameters for joining and exiting Balancer pools\n    function _getPoolParams(\n        TwoTokenPoolContext memory context,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isJoin\n    ) internal pure returns (PoolParams memory) {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[context.primaryIndex] = IAsset(context.primaryToken);\n        assets[context.secondaryIndex] = IAsset(context.secondaryToken);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[context.primaryIndex] = primaryAmount;\n        amounts[context.secondaryIndex] = secondaryAmount;\n\n        uint256 msgValue;\n        if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n            msgValue = amounts[context.primaryIndex];\n        }\n\n        return PoolParams(assets, amounts, msgValue);\n    }\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param oracleContext oracle context variables\n    /// @param tradingModule address of the trading module\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext, \n        ITradingModule tradingModule\n    ) internal view returns (uint256 oraclePairPrice) {\n        // NOTE: this balancer price is denominated in 18 decimal places\n        uint256 balancerWeightedPrice;\n        if (oracleContext.balancerOracleWeight > 0) {\n            uint256 balancerPrice = BalancerUtils._getTimeWeightedOraclePrice(\n                address(poolContext.basePool.pool),\n                IPriceOracle.Variable.PAIR_PRICE,\n                oracleContext.oracleWindowInSeconds\n            );\n\n            if (poolContext.primaryIndex == 1) {\n                // If the primary index is the second token, we need to invert\n                // the balancer price.\n                balancerPrice = BalancerConstants.BALANCER_PRECISION_SQUARED / balancerPrice;\n            }\n\n            balancerWeightedPrice = balancerPrice * oracleContext.balancerOracleWeight;\n        }\n\n        uint256 chainlinkWeightedPrice;\n        if (oracleContext.balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION) {\n            (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n                poolContext.primaryToken, poolContext.secondaryToken\n            );\n            require(rate > 0);\n            require(decimals >= 0);\n\n            if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n                rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n            }\n\n            // No overflow in rate conversion, checked above\n            chainlinkWeightedPrice = uint256(rate) * \n                (BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION - oracleContext.balancerOracleWeight);\n        }\n\n        oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n            BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION;\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Balancer pool needs to be fully initialized with at least 1024 trades\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        // Gets the BPT token price denominated in token index = 0\n        uint256 bptPrice = BalancerUtils._getTimeWeightedOraclePrice(\n            address(poolContext.basePool.pool),\n            IPriceOracle.Variable.BPT_PRICE,\n            oracleContext.oracleWindowInSeconds\n        );\n\n        uint256 pairPrice = _getOraclePairPrice(poolContext, oracleContext, strategyContext.tradingModule);\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n\n        if (poolContext.primaryIndex == 0) {\n            // Since bptPrice is always denominated in the first token, we can just multiply by\n            // the amount in this case. Both bptPrice and bptAmount are in 1e18 but we need to scale\n            // this back to the primary token's native precision.\n            // underlyingValue = (bptPrice * bptAmount * primaryPrecision) / (1e18 * 1e18)\n            primaryAmount = (bptPrice * bptAmount * primaryPrecision) / \n                BalancerConstants.BALANCER_PRECISION_SQUARED;\n        } else {\n            // The second token in the BPT pool is the price that we want to get. In this case, we need to\n            // convert secondaryTokenValue to underlyingValue using the pairPrice.\n            // Both bptPrice and bptAmount are in 1e18\n            uint256 secondaryAmount = (bptPrice * bptAmount) / BalancerConstants.BALANCER_PRECISION;\n\n            // And then normalizing to primary token precision we add:\n            // PrimaryAmount = (SecondaryAmount * primaryPrecision) / PairPrice\n            primaryAmount = (secondaryAmount * primaryPrecision) / pairPrice;\n        }\n    }\n\n    function _approveBalancerTokens(TwoTokenPoolContext memory poolContext, address bptSpender) internal {\n        IERC20(poolContext.primaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        IERC20(poolContext.secondaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        // Allow BPT spender to pull BALANCER_POOL_TOKEN\n        IERC20(address(poolContext.basePool.pool)).checkApprove(bptSpender, type(uint256).max);\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) private returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeDynamicTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount\n        });\n    }\n\n    function _deposit(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX instead of Balancer when joining\n            (uint256 primarySold, uint256 secondaryBought) = _tradePrimaryForSecondary({\n                poolContext: poolContext,\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minBPT: params.minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) private returns (uint256 primaryPurchased) {\n        (DynamicTradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (DynamicTradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeDynamicTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance\n            });\n    }\n\n    function _redeem(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(\n                poolContext, stakingContext, bptClaim, params.minPrimary, params.minSecondary\n            );\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = _sellSecondaryBalance(\n                poolContext, strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n\n        // Update global strategy token balance\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        // prettier-ignore\n        PoolParams memory poolParams = poolContext._getPoolParams( \n            primaryAmount, \n            secondaryAmount,\n            true // isJoin\n        );\n\n        bptMinted = BalancerUtils._joinPoolExactTokensIn({\n            context: poolContext.basePool,\n            params: poolParams,\n            minBPT: minBPT\n        });\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext.basePool.pool.totalSupply()\n        );\n        uint256 bptHeldAfterJoin = strategyContext.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n    }\n\n    function _unstakeAndExitPool(\n        TwoTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary,\n        uint256 minSecondary\n    ) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n\n        uint256[] memory exitBalances = BalancerUtils._exitPoolExactBPTIn({\n            context: poolContext.basePool,\n            params: poolContext._getPoolParams(minPrimary, minSecondary, false), // isJoin = false\n            bptExitAmount: bptClaim\n        });\n        \n        (primaryBalance, secondaryBalance) \n            = (exitBalances[poolContext.primaryIndex], exitBalances[poolContext.secondaryIndex]);\n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        OracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        \n        uint256 bptClaim \n            = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n\n        underlyingValue \n            = poolContext._getTimeWeightedPrimaryBalance(oracleContext, strategyContext, bptClaim).toInt();\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/Boosted3TokenAuraVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {Errors} from \"../global/Errors.sol\";\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {\n    DepositParams,\n    RedeemParams,\n    AuraVaultDeploymentParams,\n    InitParams,\n    ReinvestRewardParams,\n    StrategyVaultSettings,\n    StrategyVaultState,\n    PoolContext,\n    ThreeTokenPoolContext,\n    Boosted3TokenAuraStrategyContext,\n    StrategyContext\n} from \"./balancer/BalancerVaultTypes.sol\";\nimport {BalancerStrategyBase} from \"./balancer/BalancerStrategyBase.sol\";\nimport {Boosted3TokenPoolMixin} from \"./balancer/mixins/Boosted3TokenPoolMixin.sol\";\nimport {AuraStakingMixin} from \"./balancer/mixins/AuraStakingMixin.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {BalancerVaultStorage} from \"./balancer/internal/BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"./balancer/internal/strategy/StrategyUtils.sol\";\nimport {SettlementUtils} from \"./balancer/internal/settlement/SettlementUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"./balancer/internal/pool/Boosted3TokenPoolUtils.sol\";\nimport {Boosted3TokenAuraHelper} from \"./balancer/external/Boosted3TokenAuraHelpe"
    }
  ]
}