{
  "Title": "M-1: LibUbiquityPool::mintDollar/redeemDollar reliance on outdated TWAP oracle may be inefficient for preventing depeg",
  "Content": "# Issue M-1: LibUbiquityPool::mintDollar/redeemDollar reliance on outdated TWAP oracle may be inefficient for preventing depeg \n\nSource: https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/13 \n\n## Found by \n0xadrii, cergyk, osmanozdemir1, rvierdiiev\n## Summary\nThe ubiquity pool used for minting/burning uAD relies on a twap oracle which can be outdated because the underlying metapool is not updated when calling the ubiquity pool. This would mean that minting/burning will be enabled based on an outdated state when it should have been reverted and inversely \n\n## Vulnerability Detail\nWe can see that LibTWAPOracle has an update function to keep its values up to date according to the underlying metapool:\nhttps://github.com/sherlock-audit/2023-12-ubiquity/blob/main/ubiquity-dollar/packages/contracts/src/dollar/libraries/LibTWAPOracle.sol#L61-L102\n\nAnd that this function is called when minting/burning uADs:\nhttps://github.com/sherlock-audit/2023-12-ubiquity/blob/main/ubiquity-dollar/packages/contracts/src/dollar/libraries/LibUbiquityPool.sol#L344\n\nhttps://github.com/sherlock-audit/2023-12-ubiquity/blob/main/ubiquity-dollar/packages/contracts/src/dollar/libraries/LibUbiquityPool.sol#L416\n\n\nBut the function update is not called on the underlying metapool, so current values fetched for it may be stale:\nhttps://github.com/sherlock-audit/2023-12-ubiquity/blob/main/ubiquity-dollar/packages/contracts/src/dollar/libraries/LibTWAPOracle.sol#L134-L136\n\n## Impact\nA malicious user can use this to mint/burn heavily in order to depeg the coin further\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nCall the function:\n```vyper\ndef remove_liquidity(\n    _burn_amount: uint256,\n    _min_amounts: uint256[N_COINS],\n    _receiver: address = msg.sender\n)\n```\n\nOn the underlying metapool the twap is based on, with only zero values, to ensure that the values of the pool are up to date when consulted\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**auditsea** commented:\n> The issue describes about TWAP can be manipulated because `update` function can be called anytime and by anyone, thus TWAP period can be as short as 1 block. It seems like a valid issue but after caeful consideration, it's noticed that the TWAP issue does not come from its period but the logic itself is incorrect, thus marking this as Invalid\n\n\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**auditsea** commented:\n> The issue describes about TWAP can be manipulated because `update` function can be called anytime and by anyone, thus TWAP period can be as short as 1 block. It seems like a valid issue but after caeful consideration, it's noticed that the TWAP issue does not come from its period but the logic itself is incorrect, thus marking this as Invalid\n\n\n\n**gitcoindev**\n\n> 1 comment(s) were left on this issue during the judging contest.\n> \n> **auditsea** commented:\n> \n> > The issue describes about TWAP can be manipulated because `update` function can be called anytime and by anyone, thus TWAP period can be as short as 1 block. It seems like a valid issue but after caeful consideration, it's noticed that the TWAP issue does not come from its period but the logic itself is incorrect, thus marking this as Invalid\n\nShouldn't the issue be marked with 'Sponsor disputed' label then if it is invalid? @rndquu @pavlovcik @molecula451  \n\n**pavlovcik**\n\nIt probably makes more sense to ask @auditsea (not sure if this is the corresponding GitHub handle.)\n\n**rndquu**\n\n> A malicious user can use this to mint/burn heavily in order to depeg the coin further\n\nEconomically it doesn't make sense for a malicious user to do so. User is incentivised to arbitrage Dollar tokens hence even when metapool price is stale and a huge trade happens (i.e. a huge amount of Dollar tokens is minted in the Ubiquity pool) all secondary markets (uniswap, curve, etc...) will be on parity (in terms of Dollar-ANY_STABLECLON pair) after some time hence arbitrager will have to call `_update()` (when adding or removing liquidity) in the curve's metapool to make a profit.\n\nMeanwhile I agree that the metapool's price can be stale but I don't understand how exactly minting \"too many\" Dollar tokens (keeping in mind that we get collateral in return) or burning \"too many\" Dollar tokens (keeping in mind that it reduces the `Dollar/USD` quote) may harm the protocol.\n\nAnyway fresh data is better than stale one and the fix looks like a one liner so perhaps it makes sense to implement it. So [here](https://github.com/sherlock-audit/2023-12-ubiquity/blob/d9c39e8dfd5601e7e8db2e4b3390e7d8dff42a8e/ubiquity-dollar/packages/contracts/src/dollar/libraries/LibTWAPOracle.sol#L69) we could remove liquidity from the curve's metapool with 0 values (as mentioned in the \"recommendation\" section) which updates cumulative balances under the hood.\n\n@gitcoindev @molecula451 What do you think?\n\n**gitcoindev**\n\n> > A malicious user can use this to mint/burn heavily in order to depeg the coin further\n> \n> Economically it doesn't make sense for a malicious user to do so. User is incentivised to arbitrage Dollar tokens hence even when metapool price is stale and a huge trade happens (i.e. a huge amount of Dollar tokens is minted in the Ubiquity pool) all secondary markets (uniswap, curve, etc...) will be on parity (in terms of Dollar-ANY_STABLECLON pair) after some time hence arbitrager will have to call `_update()` (when adding or removing liquidity) in the curve's metapool to make a profit.\n> \n> Meanwhile I agree that the metapool's price can be stale but I don't understand how exactly minting \"too many\" Dollar tokens (keeping in mind that we get collateral in return) or burning \"too many\" Dollar tokens (keeping in mind that it reduces the `Dollar/USD` quote) may harm the protocol.\n> \n> Anyway fresh data is better than stale one and the fix looks like a one liner so perhaps it makes sense to implement it. So [here](https://github.com/sherlock-audit/2023-12-ubiquity/blob/d9c39e8dfd5601e7e8db2e4b3390e7d8dff42a8e/ubiquity-dollar/packages/contracts/src/dollar/libraries/LibTWAPOracle.sol#L69) we could remove liquidity from the curve's metapool with 0 values (as mentioned in the \"recommendation\" section) which updates cumulative balances under the hood.\n> \n> @gitcoindev @molecula451 What do you think?\n\nI have the same impression. Since this is easy to remediate with updating of cumulative balances I agree we could accept \n and implement it there. \n\n\n**osmanozdemir1**\n\nEscalate\n\nSome duplicates of this issue fail to explain the actual root cause of it, which is internal update function being called in the beginning of every action in the underlying metapool.\n\nOnly valid duplicates of this issue are #68, #134, and #181. They all explain the core problem about curve metapool updating mechanism and provide recommendations regarding how to update underlying pool to solve the problem.\n\nIssues #34, #84, #92 and #187 are more related to `consult()` function returning stale value. Some of them mention general things about TWAP _(like how low volume pools affect TWAP etc)_, and provide vague explanations. However, none of them pinpoints the actual cause of this issue. They don't mention underlying metapool's updating mechanism and should not be considered as valid duplicates without finding the root cause. \n\nLast 4 issues might be considered as separate group of valid issues or they might be invalidated depending on the judge's preference, but they should not be duplicates of this one. \n\nKind regards.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Some duplicates of this issue fail to explain the actual root cause of it, which is internal update function being called in the beginning of every action in the underlying metapool.\n> \n> Only valid duplicates of this issue are #68, #134, and #181. They all explain the core problem about curve metapool updating mechanism and provide recommendations regarding how to update underlying pool to solve the problem.\n> \n> Issues #34, #84, #92 and #187 are more related to `consult()` function returning stale value. Some of them mention general things about TWAP _(like how low volume pools affect TWAP etc)_, and provide vague explanations. However, none of them pinpoints the actual cause of this issue. They don't mention underlying metapool's updating mechanism and should not be considered as valid duplicates without finding the root cause. \n> \n> Last 4 issues might be considered as separate group of valid issues or they might be invalidated depending on the judge's preference, but they should not be duplicates of this one. \n> \n> Kind regards.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@osmanozdemir1 I have internally discussed this with LSW and initially did deduplicated them as you mentioned. However, the watsons are technically not wrong per say by indicating an update required by using a stale time interval, so I decided to duplicate them.\n\n**osmanozdemir1**\n\n@nevillehuang Thanks for the response.\n\nI totally agree with you about watsons being technically not wrong. However, this issue is one step deeper than a regular stale price issue. Even **non-stale** prices _(in terms of time interval)_ will be incorrect because of this issue.\n\nFor example let's say staleness threshold is 4 hours:\n\n```solidity\n  /*           T-4 hours         T-3 hours                                         T0 current\n                 |-----------------|---------------------------------------------------|\n                              Latest action                                   The time Ubiquity \n                             in curve metapool                              updates & checks the price\n\n                                   |----------------------------------------------------|\n                                     Latest actions impact until now is not accounted \n*/      \n```\n\nIn an example above, staleness interval check will not revert because it is inside the staleness threshold. However, the latest action's impact on the price is never accounted. If it is a large swap or deposit, 3 hours worth of impact of this action will be huge.\n\nStaleness check is not a solution for this problem. Only solution is somehow invoking the internal update function of the underlying curve metapool. And only issues I mentioned above explains this problem.\n\nTherefore, I strongly believe those other 4 issues regarding staleness check are valid issues but separate ones.\n\nKind regards.\n\n**0xLogos**\n\nEscalate\n\nImho staleness part should be low and another should be invalid because of this\n\n> > A malicious user can use this to mint/burn heavily in order to depeg the coin further\n> \n> Economically it doesn't make sense for a malicious user to do so. User is incentivised to arbitrage Dollar tokens hence even when metapool price is stale and a huge trade happens (i.e. a huge amount of Dollar tokens is minted in the Ubiquity pool) all secondary markets (uniswap, curve, etc...) will be on parity (in terms of Dollar-ANY_STABLECLON pair) after some time hence arbitrager will have to call `_update()` (when adding or removing liquidity) in the curve's metapool to make a profit.\n> \n> Meanwhile I agree that the metapool's price can be stale but I don't understand how exactly minting \"too many\" Dollar tokens (keeping in mind that we get collateral in return) or burning \"too many\" Dollar tokens (keeping in mind that it reduces the `Dollar/USD` quote) may harm the protocol.\n\nI would also like to ask for a specific numerical example. From my understanding check against TWAP not for prevent depeg but for...\n\n> prevent unnecessary redemptions that could adversely affect the Dollar price\n\ni.e. for cases like redeeming uD when it's price above peg 1$ which is simply unprofitable because within the protocol it's still 1$.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Imho staleness part should be low and another should be invalid because of this\n> \n> > > A malicious user can use this to mint/burn heavily in order to depeg the coin further\n> > \n> > Economically it doesn't make sense for a malicious user to do so. User is incentivised to arbitrage Dollar tokens hence even when metapool price is stale and a huge trade happens (i.e. a huge amount of Dollar tokens is minted in the Ubiquity pool) all secondary markets (uniswap, curve, etc...) will be on parity (in terms of Dollar-ANY_STABLECLON pair) after some time hence arbitrager will have to call `_update()` (when adding or removing liquidity) in the curve's metapool to make a profit.\n> > \n> > Meanwhile I agree that the metapool's price can be stale but I don't understand how exactly minting \"too many\" Dollar tokens (keeping in mind that we get collateral in return) or burning \"too many\" Dollar tokens (keeping in mind that it reduces the `Dollar/USD` quote) may harm the protocol.\n> \n> I would also like to ask for a specific numerical example. From my understanding check against TWAP not for prevent depeg but for...\n> \n> > prevent unnecessary redemptions that could adversely affect the Dollar price\n> \n> i.e. for cases like redeeming uD when it's price above peg 1$ which is simply unprofitable because within the protocol it's still 1$.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nI agree with @osmanozdemir1 analysis. I think this issues can possibly be separated. However, what does a staleness check actually do, isn't it to invoke that particular underlying update function in the first place (which is why I validated them)?\n\n**osmanozdemir1**\n\n> I agree with @osmanozdemir1 analysis. I think this issues can possibly be separated. However, what does a staleness check actually do, isn't it to invoke that particular underlying update function in the first place (which is why I validated them)?\n\nStaleness check might revert or update underlying pool depending on how the protocol implements it. However, even if staleness check updates the underlying pool, it would only do that in case of the last action is outside of the staleness threshold. It won't update the price all the time. \n\nStaleness check won't update the price if it **thinks the price is not stale**. The thing I was trying to point out [here](https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/13#issuecomment-1908782359) is that the underlying curve pool update function must be invoked all the time regardless of the staleness.\n\n**0xLogos**\n\n#181 is nice explanation, but i believe it lacks severe impact\n\n> TWAP prices are incorrect.\n\nIt is view function used only to check thresholds in mint/redeem\n\n> Incorrect amounts of tokens will be minted.\n\nMint/redeem amounts are based on chainlink oracle, not TWAP\n\n> DollarToken's may be minted or redeemed outside of the price threshold.\n\nIt can happen, but there's no incentives to do it. Thresholds allow to mint/redeem uAD if it's actually profitable according to TWAP. If allowance is false-posive mint/redeem will not be profitable, if it is false-negative arb can themself update curve pool and thus update TWAP.\n\nSo IMO impact here is that there is possible situation when arb is forced to  update curve pool themself in order to execute arb. But is this alone medium? And how often these situations will occur?\n\n\n\n\n\n**osmanozdemir1**\n\nHi @0xLogos. Thanks for your comment.\n\n > It is view function used only to check thresholds in mint/redeem\n\nIndeed it is used to check thresholds in mint/redeem. This protocol has certain threshold prices and issue #181 explains how tokens can be minted outside of these threshold. It is clearly broken core functionality.\n\n> It can happen, but there's no incentives to do it.\n\nI can interpret this sentence in another way. If there is no incentive to do it and if it is not profitable for arbitragers etc, just a regular user may get harmed. A normal user doesn't have to track all these things and doesn't need to check Curve prices since the user expects protocol to revert outside of these thresholds. \n\nminting/redeeming uAD above 1.01 and below 0.99 is the central feature of this protocol and in my opinion it is quite clear that minting/redeeming outside of the pre-determined thresholds is a broken functionality.\n\n**CergyK**\n\nManipulations of the TWAP oracle have a high impact because they can cause insolvency on the Pool.\n\nIndeed any redeeming/minting is done at the price indicated by chainlink. So what if the TWAP oracle is not aligned with the chainlink value? A malicious user which already has a large amount of uAD can drain the pool of the collateral\n\n**0xLogos**\n\n> just a regular user may get harmed\n\nUser mistake\n\n\nI believe that \"core functionality\" in judging docs refers to something with obvious impact and I don't see it here, but it's for judges to decide.\n\n> A malicious user which already has a large amount of uAD can drain the pool of the collateral\n\nDon't see why it's malicious, uAD exchanged for collateral according to chainlink (fair) price, not outdated TWAP. Burning large amount of uAD will raise demand and incentivises to mint uAD for collateral and replenish pool - intended behavior.\n\n\n**osmanozdemir1**\n\n> User mistake\n\nI disagree with that. User expects the protocol act like it is stated in the docs. User is not doing something wrong or giving incorrect input. For example, with your argument, every sandwich attack would be a user mistake due to not using private mempool or not being cautious enough but we consider it as lack of slippage protection.\n\nWhole mint/redeem can be done outside of the intended thresholds with incorrect price assumptions. I don't understand how more core you want but will leave it to the judge.\n\n**nevillehuang**\n\n@Czar102 See issue #181 for a more complete issue breakdown with more thorough impact analysis (also the report I selected). I believe this is a valid medium severity issue.\n\n**0xLogos**\n\nSandwitch attack is different. There is attacker, profit for attacker and loss for user. Here user themself making suboptimal choice, but again, he not loosing anything. Also this easier for user to prevent than sandwithcing.\n\n**Czar102**\n\nI agree with the deduplication proposed – issues #34, #84, #92 and #187 aren't describing this issue to a sufficient extent.\n\nI was planning to consider this a low (it's a low/medium borderline issue imo) because I thought there is just protocol revenue lost due to suboptimal pricing.\n\n> Indeed any redeeming/minting is done at the price indicated by chainlink. So what if the TWAP oracle is not aligned with the chainlink value? A malicious user which already has a large amount of uAD can drain the pool of the collateral\n\n@CergyK than you for this comment, this seems to be the case. If the protocol had a single oracle (maybe chainlink and TWAP integrated), there would no issues related to this discrepancy. If there was a single oracle, the uAD would be *verifiably solvent* (given that the thresholds are configured correctly), but right now, due to the possibilities of these discrepancies, there is no such a *guarantee*. Tagging @pavlovcik @gitcoindev @molecula451 @rndquu, maybe it will be a valuable modification. Would also like @CergyK to sign off on this reasoning.\n\nIn real market scenarios, if the price has been radically changed, there is some market activity that will update the TWAP, so the probability of this issue having real impact is negligible, and this issue will usually have some impact on the price, nevertheless negligible. Hence, I think Medium severity is perfect for this issue.\n\nPlanning to separate and invalidate #34, #84, #92 and #187 and leave other duplicates and this issue as they are.\n\n**0xLogos**\n\nSorry, i think i've lost the point.\n\n> So what if the TWAP oracle is not aligned with the chainlink value?\n\n@CergyK TWAP is for uAD but chainlink for collateral. What do you mean they are not aligned?\n\n@Czar102 What verifiably solvent means? User with sufficient uAD can redeem and get all collateral when uAD fresh TWAP < 0.99. Why is't bad?\n\n\n\n**Czar102**\n\n> User with sufficient uAD can redeem and get all collateral when uAD fresh TWAP < 0.99. Why is't bad?\n\n@0xLogos If the Chainlink oracle displays price of uAD of $1.02 and the TWAP is $0.99, then one can redeem and they will get more for redeems ($1.02) than pay for some mints ($1.01).\n\nIf one oracle was used for checking thresholds and exchange rates, it would be impossible to mint for a smaller cost than profit from redeeming.\n\n**CergyK**\n\n> Would also like @CergyK to sign off on this reasoning.\n\nAgreed, as an additional remediation to the individual TWAP issues, it would be reasonable to introduce a deviation check between the two oracles\n\n**0xArz**\n\n@Czar102 The chainlink oracle is not used for uAD, its used for the collateral. There is no uAD chainlink feed so the curve pool twap is used by checking the reserves and the price of that the twap returns does not determine the amount of the collateral tokens that the user receives, it just checks the thresholds \n\n**0xLogos**\n\n@Czar102 But chainlink oracle not used for uAD pricing, there's no such feed. uAD price hardcoded to 1$ in the pool, only collateral chainlink feed used for calculating exchange rate assuming uAD worth 1$.\n\n\n\n**CergyK**\n\n@0xArz @0xLogos\n\nBy giving the right to users to mint/redeem collateral at the price given by the feed collateral/USD, the price of uAD is actually defined by this feed, so we can safely consider that the feed is also the real price collateral/uAD. \n\nEven though I agree with your point that the chainlink feed is not technically a uAD feed. \n\n**0xArz**\n\n> @0xArz @0xLogos\n> \n> By giving the right to users to mint/redeem collateral at the price given by the feed collateral/USD, the price of uAD is actually defined by this feed, so we can safely consider that the feed is also the real price collateral/uAD.\n> \n> Even though I agree with your point that the chainlink feed is not technically a uAD feed.\n\nIts an exchange rate that will always be 1 if the collateral is pegged to $1.00 and you will only receive more or less if the collateral price changes not the uAD price. The impact here is that it might be possible to mint/redeem outside of the thresholds, i dont get how you can “drain” the collateral. \n\n**osmanozdemir1**\n\nIn the simplest way:\n\n```\nIf A happens\n      do B\n```\n\nYou are trying to invalidate this issue by saying the price calculation is correct while performing `do B`. \n\nThe bug is in `if A happens`. This function shouldn't be performing `do B` at all. It doesn't matter `do B` is correct or not. The function should not be in that if statement in the first place. That if statement is the most central part of this protocol. It is the decision to mint or not mint this stable token. It is the decision to burn or not burn. \n\nI am genuinely surprised that we are still discussing the validity of a bug that directly impacts the total supply and mint/redeem decision of a stable token. uAD is a stable coin. It has certain rules to mint/burn. That rule is broken.\n\n\n**0xArz**\n\n@osmanozdemir1 Your report describes this issue really well although this comment https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/13#issuecomment-1945710223 about the impact is wrong. \n\n\n\n> uAD is a stable coin. It has certain rules to mint/burn. That rule is broken.\n\nThis is true but this still doesnt affect the price of uAD until its sold right? If the reserves were 99 and 101 then everyone is able to mint, the arbitrage bot would only need ~1 uAD to rebalance to the pool but what if an attacker just mints the max(50k uAD), isnt this the same problem? Although this rule is broken, you are not stealing anything, the protocol doesnt become insolvent or anything.  Would be great if we could confirm with the sponsor what problem could this cause\n\n**osmanozdemir1**\n\nJust an example in terms of what problem could this cause:\n\nLet's assume TWAP price is 1.011 but the real price is 0.99.\n\n- Normally, the protocol should prevent minting and allow redeeming to maintain the peg. This way token supply will decrease and price will move towards to 1.\n- But because of the TWAP price is 1.01, it will allow minting more uAD instead of forbidding mint and allowing redeem. It will do the complete opposite, which will increase the total supply more instead of decreasing it. Which will decrease the real price more.\n\nDecision to mint/burn and increasing/decreasing token supply are most crucial things in a stable coin and these crucial actions are performed based on mint/redeem thresholds in this protocol. Possibility to mint/redeem outside of these thresholds is not an innocent issue.\n\nThese thresholds will use outdated TWAP prices **nearly all the time** due to this issue because curve metapools are not highly active pools. They are not like uniswap pools. I provided both previous ubiquity metapool address and `lusd` metapool address in my issue if you want to check. **There are only few exchange actions in weeks**. That's why it is quite possible for this protocol to mint uAD instead of burn them or vice versa. People will keep minting until there is an external action in the underlying metapool that updates the TWAP, and that update might take too much time. This protocol should not wait an external action but it must update the underlying pool itself.  \n\n\n**0xArz**\n\n> * But because of the TWAP price is 1.01, it will allow minting more uAD instead of forbidding mint and allowing redeem. It will do the complete opposite, which will increase the total supply more instead of decreasing it. Which will decrease the real price more.\n\nMinting the token will not decrease the price, minting and then selling the token in the curve pool is what will decrease the price, because this isnt profitable, no one would do this. \n\nIf the real price was $0.99 then an arbitrage bot will buy uAD at a discounted price and then redeem and the pool will be updated because he just bought. \n\n\n> Let's assume TWAP price is 1.011\n\nBut the lookback window of the twap is 1 block so doesnt it just return the spot price and then use the current reserves? In that case if the price is 1.011 then an arbitrage bot will mint and sell right after the transaction that made the price 1.011.  Described here https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/20\n\n**osmanozdemir1**\n\n> If the real price was $0.99 then an arbitrage bot will buy uAD at a discounted price and then redeem and the pool will be updated because he just bought.\n\nThe real price I meant here is the real TWAP price after `_update` during an exchange, which can not be known without calling an exchange action in the underlying metapool. Arbitrage bot can't know it since there is no feed that actively tracks real price. That's the whole point of the Curve metapool calling the `_update` function as first thing during any kind of exchange and this way all exchanges are done with the most updated TWAP prices.\n\n> But the lookback window of the twap is 1 block so doesnt it just return the spot price and then use the current reserves?\n\nFirstly, no it doesn't have to be 1 block. It is the difference between current timestamp and the last updated timestamp. #20 explains that it will be only 1 block if you update it in consecutive blocks. \n\nSecondly, no it doesn't return the spot price and that's whole point of my submission. It uses `currentCumulativePrices` function, which returns [latest updated prices](https://github.com/sherlock-audit/2023-12-ubiquity/blob/d9c39e8dfd5601e7e8db2e4b3390e7d8dff42a8e/ubiquity-dollar/packages/contracts/src/dollar/libraries/LibTWAPOracle.sol#L135C1-L136C69). If underlying metapool doesn't have any new action, it will return the same cumulative price and the same timestamp even though if you call it now, or 3 hours later, or 1 day later. It directly returns the cumulative price and the timestamp at the point of the latest action in the underlying metapool. You can read the implementation code here: https://etherscan.io/address/0x5f890841f657d90e081babdb532a05996af79fe6#code\n\n**0xArz**\n\n@osmanozdemir1 I see yeah, i somehow thought that the update is done after the tx. Not sure of the impact but ig medium is appropriate for using an incorrect value to check the thresholds. \n\nThe comment by @Czar102 about the oracles is still incorrect tho. The impact of this issue is that most of the time it will use outdated twap price which can block or allow minting/redeeming.  In https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/56 you would need a lot of funds just to allow/block minting and redeeming for a small amount of time which is not a problem unlike here where most of the time the wrong price will be used which will allow/block minting and redeeming\n\n\n\n**0xLogos**\n\n> But because of the TWAP price is 1.01, it will allow minting more uAD instead of forbidding mint and allowing redeem. It will do the complete opposite, which will increase the total supply more instead of decreasing it. Which will decrease the real price more.\n\nAllowing minting won't increase total supply. No one would mint just because it's allowed when it will cause losses. But one can trigger curve `_update` thus update TWAP and then redeem for profit. uAD is algotithmic stable coin and the market is assumed to operate efficiently. If bad actor wants to grief, arb will drain his funds.\n\n> Let's assume TWAP price is 1.011 but the real price is 0.99.\n\nJust bcz TWAP is stale you can't assume whatever you want. What's probability of this state? I think such curve pools indeed can be stale for long time, but only when they balanced.\n\nSorry, I really do not want to argue, just for @Czar102 to understand and answer my points.\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/ubiquity/ubiquity-dollar/pull/893.\n\n**Czar102**\n\nAfter extensive discussions with the LSW and the Lead Judge, planning to resolve the escalation as previously intended (https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/13#issuecomment-1945710223), as the issue doesn't only cause a DoS, but may allow for an easy value extraction strategy from the protocol, similar to the one described in #17 and duplicates.\n\nPlanning to accept the first and reject the second escalation.\n\n**0xLogos**\n\nFrom #17\n\n> Chainlink price may be slightly outdated with regards to actual Dex state, and in that case users holding a depegging asset (let's consider DAI depegging) will use uAD to swap for the still pegged collateral: LUSD\n\nYou can't swap because allowed only either mint or redeem. \n\nAlso if pool works as expected it always lose value on mint/redeem, but it takes fee to mitigate this (btw this was my escalation point for #36 that fee actually used). Assume peg within desired range: 1.009, but mint is still open because twap is stale and returns 1.011, now you can mint 1 uAD = 1.009$ for 1$. But you pay same fee as usual. And usual mint expected to be more profitable and pool takes according fees. And with that fee mint is barely profitable.\n\nThis is just my thoughts about the strategy and honestly I can't think of anything profitable here. \n\n@CergyK @nevillehuang But if there really is profitable strategy I want to learn it! \n\n**0xArz**\n\n@Czar102 @nevillehuang @CergyK \nhttps://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/56 is not a valid issue. You will not be able to extract anything because it DoSes the redeem, not enables. The report also clearly mentions that.  You can only make the price of uAD increase because it is impossible for the attacker to have a large amount of uAD if the only way to get it from is the curve pool, he can only make the price increase by providing a large amount of 3CRV. \n\nI really dont undestand why we are trying to make https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/17 valid again which is a completely seperate issue from this one. As @0xLogos mentioned you are only able to mint or redeem so you cant sandwich the oracle update and it is not profitable. \n\n\n> easy value extraction strategy\n\nCan you also please tell me since when is proposing 2 consecutive blocks considered easy? \n\n**osmanozdemir1**\n\n> @Czar102 @nevillehuang @CergyK #56 is not a valid issue. You will not be able to extract anyt",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/138",
  "Code": [
    {
      "filename": "ubiquity-dollar/packages/contracts/src/dollar/libraries/LibTWAPOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {IMetaPool} from \"../../dollar/interfaces/IMetaPool.sol\";\nimport {LibAppStorage} from \"./LibAppStorage.sol\";\n\n/**\n * @notice Library used for Curve TWAP oracle in the Dollar MetaPool\n */\nlibrary LibTWAPOracle {\n    /// @notice Struct used as a storage for this library\n    struct TWAPOracleStorage {\n        address pool; // curve metapool address : Ubiquity Dollar <=> 3 Pool\n        // address token0; will always be address(this)\n        address token1; // curve 3pool LP token address\n        uint256 price0Average;\n        uint256 price1Average;\n        uint256 pricesBlockTimestampLast;\n        uint256[2] priceCumulativeLast;\n    }\n\n    /// @notice Storage slot used to store data for this library\n    bytes32 constant TWAP_ORACLE_STORAGE_POSITION =\n        bytes32(uint256(keccak256(\"diamond.standard.twap.oracle.storage\")) - 1);\n\n    /**\n     * @notice Sets Curve MetaPool to be used as a TWAP oracle\n     * @param _pool Curve MetaPool address, pool for 2 tokens [Dollar, 3CRV LP]\n     * @param _curve3CRVToken1 Curve 3Pool LP token address\n     */\n    function setPool(address _pool, address _curve3CRVToken1) internal {\n        require(\n            IMetaPool(_pool).coins(0) ==\n                LibAppStorage.appStorage().dollarTokenAddress,\n            \"TWAPOracle: FIRST_COIN_NOT_DOLLAR\"\n        );\n        TWAPOracleStorage storage ts = twapOracleStorage();\n\n        // coin at index 0 is Ubiquity Dollar and index 1 is 3CRV\n        require(\n            IMetaPool(_pool).coins(1) == _curve3CRVToken1,\n            \"TWAPOracle: COIN_ORDER_MISMATCH\"\n        );\n\n        uint256 _reserve0 = uint112(IMetaPool(_pool).balances(0));\n        uint256 _reserve1 = uint112(IMetaPool(_pool).balances(1));\n\n        // ensure that there's liquidity in the pair\n        require(_reserve0 != 0 && _reserve1 != 0, \"TWAPOracle: NO_RESERVES\");\n        // ensure that pair balance is perfect\n        require(_reserve0 == _reserve1, \"TWAPOracle: PAIR_UNBALANCED\");\n        ts.priceCumulativeLast = IMetaPool(_pool).get_price_cumulative_last();\n        ts.pricesBlockTimestampLast = IMetaPool(_pool).block_timestamp_last();\n        ts.pool = _pool;\n        // dollar token is inside the diamond\n        ts.token1 = _curve3CRVToken1;\n        ts.price0Average = 1 ether;\n        ts.price1Average = 1 ether;\n    }\n\n    /**\n     * @notice Updates the following state variables to the latest values from MetaPool:\n     * - Dollar / 3CRV LP quote\n     * - 3CRV LP / Dollar quote\n     * - cumulative prices\n     * - update timestamp\n     */\n    function update() internal {\n        TWAPOracleStorage storage ts = twapOracleStorage();\n        (\n            uint256[2] memory priceCumulative,\n            uint256 blockTimestamp\n        ) = currentCumulativePrices();\n        if (blockTimestamp - ts.pricesBlockTimestampLast > 0) {\n            // get the balances between now and the last price cumulative snapshot\n            uint256[2] memory twapBalances = IMetaPool(ts.pool)\n                .get_twap_balances(\n                    ts.priceCumulativeLast,\n                    priceCumulative,\n                    blockTimestamp - ts.pricesBlockTimestampLast\n                );\n\n            // price to exchange amountIn Ubiquity Dollar to 3CRV based on TWAP\n            ts.price0Average = IMetaPool(ts.pool).get_dy(\n                0,\n                1,\n                1 ether,\n                twapBalances\n            );\n\n            // price to exchange amountIn 3CRV to Ubiquity Dollar based on TWAP\n            ts.price1Average = IMetaPool(ts.pool).get_dy(\n                1,\n                0,\n                1 ether,\n                twapBalances\n            );\n            // we update the priceCumulative\n            ts.priceCumulativeLast = priceCumulative;\n            ts.pricesBlockTimestampLast = blockTimestamp;\n        }\n    }\n\n    /**\n     * @notice Returns the quote for the provided `token` address\n     * @notice If the `token` param is Dollar then returns 3CRV LP / Dollar quote\n     * @notice If the `token` param is 3CRV LP then returns Dollar / 3CRV LP quote\n     * @param token Token address\n     * @return amountOut Token price, Dollar / 3CRV LP or 3CRV LP / Dollar quote\n     */\n    function consult(address token) internal view returns (uint256 amountOut) {\n        TWAPOracleStorage memory ts = twapOracleStorage();\n\n        if (token == LibAppStorage.appStorage().dollarTokenAddress) {\n            // price to exchange 1 Ubiquity Dollar to 3CRV based on TWAP\n            amountOut = ts.price0Average;\n        } else {\n            require(token == ts.token1, \"TWAPOracle: INVALID_TOKEN\");\n            // price to exchange 1 3CRV to Ubiquity Dollar based on TWAP\n            amountOut = ts.price1Average;\n        }\n    }\n\n    /**\n     * @notice Returns current cumulative prices from metapool with updated timestamp\n     * @return priceCumulative Current cumulative prices for pool tokens\n     * @return blockTimestamp Current update timestamp\n     */\n    function currentCumulativePrices()\n        internal\n        view\n        returns (uint256[2] memory priceCumulative, uint256 blockTimestamp)\n    {\n        address metapool = twapOracleStorage().pool;\n        priceCumulative = IMetaPool(metapool).get_price_cumulative_last();\n        blockTimestamp = IMetaPool(metapool).block_timestamp_last();\n    }\n\n    /**\n     * @notice Returns struct used as a storage for this library\n     * @return ds Struct used as a storage\n     */\n    function twapOracleStorage()\n        internal\n        pure\n        returns (TWAPOracleStorage storage ds)\n    {\n        bytes32 position = TWAP_ORACLE_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /**\n     * @notice Returns current Dollar price\n     * @dev Returns 3CRV LP / Dollar quote, i.e. how many 3CRV LP tokens user will get for 1 Dollar\n     * @return Dollar price\n     */\n    function getTwapPrice() internal view returns (uint256) {\n        return\n            LibTWAPOracle.consult(\n                LibAppStorage.appStorage().dollarTokenAddress\n            );\n    }\n}"
    },
    {
      "filename": "ubiquity-dollar/packages/contracts/src/dollar/libraries/LibUbiquityPool.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.19;\n\nimport {AggregatorV3Interface} from \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IDollarAmoMinter} from \"../interfaces/IDollarAmoMinter.sol\";\nimport {IERC20Ubiquity} from \"../interfaces/IERC20Ubiquity.sol\";\nimport {UBIQUITY_POOL_PRICE_PRECISION} from \"./Constants.sol\";\nimport {LibAppStorage} from \"./LibAppStorage.sol\";\nimport {LibTWAPOracle} from \"./LibTWAPOracle.sol\";\n\n/**\n * @notice Ubiquity pool library\n * @notice Allows users to:\n * - deposit collateral in exchange for Ubiquity Dollars\n * - redeem Ubiquity Dollars in exchange for the earlier provided collateral\n */\nlibrary LibUbiquityPool {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /// @notice Storage slot used to store data for this library\n    bytes32 constant UBIQUITY_POOL_STORAGE_POSITION =\n        bytes32(\n            uint256(keccak256(\"ubiquity.contracts.ubiquity.pool.storage\")) - 1\n        );\n\n    /// @notice Struct used as a storage for this library\n    struct UbiquityPoolStorage {\n        //========\n        // Core\n        //========\n        // minter address -> is it enabled\n        mapping(address amoMinter => bool isEnabled) isAmoMinterEnabled;\n        //======================\n        // Collateral related\n        //======================\n        // available collateral tokens\n        address[] collateralAddresses;\n        // collateral address -> collateral index\n        mapping(address collateralAddress => uint256 collateralIndex) collateralIndex;\n        // collateral index -> chainlink price feed addresses\n        address[] collateralPriceFeedAddresses;\n        // collateral index -> threshold in seconds when chainlink answer should be considered stale\n        uint256[] collateralPriceFeedStalenessThresholds;\n        // collateral index -> collateral price\n        uint256[] collateralPrices;\n        // array collateral symbols\n        string[] collateralSymbols;\n        // collateral address -> is it enabled\n        mapping(address collateralAddress => bool isEnabled) isCollateralEnabled;\n        // Number of decimals needed to get to E18. collateral index -> missing decimals\n        uint256[] missingDecimals;\n        // Total across all collaterals. Accounts for missing_decimals\n        uint256[] poolCeilings;\n        //====================\n        // Redeem related\n        //====================\n        // user -> block number (collateral independent)\n        mapping(address => uint256) lastRedeemedBlock;\n        // 1010000 = $1.01\n        uint256 mintPriceThreshold;\n        // 990000 = $0.99\n        uint256 redeemPriceThreshold;\n        // address -> collateral index -> balance\n        mapping(address user => mapping(uint256 collateralIndex => uint256 amount)) redeemCollateralBalances;\n        // number of blocks to wait before being able to collectRedemption()\n        uint256 redemptionDelayBlocks;\n        // collateral index -> balance\n        uint256[] unclaimedPoolCollateral;\n        //================\n        // Fees related\n        //================\n        // minting fee of a particular collateral index, 1_000_000 = 100%\n        uint256[] mintingFee;\n        // redemption fee of a particular collateral index, 1_000_000 = 100%\n        uint256[] redemptionFee;\n        //=================\n        // Pause related\n        //=================\n        // whether borrowing collateral by AMO minters is paused for a particular collateral index\n        bool[] isBorrowPaused;\n        // whether minting is paused for a particular collateral index\n        bool[] isMintPaused;\n        // whether redeeming is paused for a particular collateral index\n        bool[] isRedeemPaused;\n    }\n\n    /// @notice Struct used for detailed collateral information\n    struct CollateralInformation {\n        uint256 index;\n        string symbol;\n        address collateralAddress;\n        address collateralPriceFeedAddress;\n        uint256 collateralPriceFeedStalenessThreshold;\n        bool isEnabled;\n        uint256 missingDecimals;\n        uint256 price;\n        uint256 poolCeiling;\n        bool isMintPaused;\n        bool isRedeemPaused;\n        bool isBorrowPaused;\n        uint256 mintingFee;\n        uint256 redemptionFee;\n    }\n\n    /**\n     * @notice Returns struct used as a storage for this library\n     * @return uPoolStorage Struct used as a storage\n     */\n    function ubiquityPoolStorage()\n        internal\n        pure\n        returns (UbiquityPoolStorage storage uPoolStorage)\n    {\n        bytes32 position = UBIQUITY_POOL_STORAGE_POSITION;\n        assembly {\n            uPoolStorage.slot := position\n        }\n    }\n\n    //===========\n    // Events\n    //===========\n\n    /// @notice Emitted when new AMO minter is added\n    event AmoMinterAdded(address amoMinterAddress);\n    /// @notice Emitted when AMO minter is removed\n    event AmoMinterRemoved(address amoMinterAddress);\n    /// @notice Emitted on setting a chainlink's collateral price feed params\n    event CollateralPriceFeedSet(\n        uint256 collateralIndex,\n        address priceFeedAddress,\n        uint256 stalenessThreshold\n    );\n    /// @notice Emitted on setting a collateral price\n    event CollateralPriceSet(uint256 collateralIndex, uint256 newPrice);\n    /// @notice Emitted on enabling/disabling a particular collateral token\n    event CollateralToggled(uint256 collateralIndex, bool newState);\n    /// @notice Emitted when fees are updated\n    event FeesSet(\n        uint256 collateralIndex,\n        uint256 newMintFee,\n        uint256 newRedeemFee\n    );\n    /// @notice Emitted on toggling pause for mint/redeem/borrow\n    event MintRedeemBorrowToggled(uint256 collateralIndex, uint8 toggleIndex);\n    /// @notice Emitted when new pool ceiling (i.e. max amount of collateral) is set\n    event PoolCeilingSet(uint256 collateralIndex, uint256 newCeiling);\n    /// @notice Emitted when mint and redeem price thresholds are updated (1_000_000 = $1.00)\n    event PriceThresholdsSet(\n        uint256 newMintPriceThreshold,\n        uint256 newRedeemPriceThreshold\n    );\n    /// @notice Emitted when a new redemption delay in blocks is set\n    event RedemptionDelayBlocksSet(uint256 redemptionDelayBlocks);\n\n    //=====================\n    // Modifiers\n    //=====================\n\n    /**\n     * @notice Checks whether collateral token is enabled (i.e. mintable and redeemable)\n     * @param collateralIndex Collateral token index\n     */\n    modifier collateralEnabled(uint256 collateralIndex) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        require(\n            poolStorage.isCollateralEnabled[\n                poolStorage.collateralAddresses[collateralIndex]\n            ],\n            \"Collateral disabled\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Checks whether a caller is the AMO minter address\n     */\n    modifier onlyAmoMinter() {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        require(\n            poolStorage.isAmoMinterEnabled[msg.sender],\n            \"Not an AMO Minter\"\n        );\n        _;\n    }\n\n    //=====================\n    // Views\n    //=====================\n\n    /**\n     * @notice Returns all collateral addresses\n     * @return All collateral addresses\n     */\n    function allCollaterals() internal view returns (address[] memory) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        return poolStorage.collateralAddresses;\n    }\n\n    /**\n     * @notice Returns collateral information\n     * @param collateralAddress Address of the collateral token\n     * @return returnData Collateral info\n     */\n    function collateralInformation(\n        address collateralAddress\n    ) internal view returns (CollateralInformation memory returnData) {\n        // load the storage\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        // validation\n        require(\n            poolStorage.isCollateralEnabled[collateralAddress],\n            \"Invalid collateral\"\n        );\n\n        // get the index\n        uint256 index = poolStorage.collateralIndex[collateralAddress];\n\n        returnData = CollateralInformation(\n            index,\n            poolStorage.collateralSymbols[index],\n            collateralAddress,\n            poolStorage.collateralPriceFeedAddresses[index],\n            poolStorage.collateralPriceFeedStalenessThresholds[index],\n            poolStorage.isCollateralEnabled[collateralAddress],\n            poolStorage.missingDecimals[index],\n            poolStorage.collateralPrices[index],\n            poolStorage.poolCeilings[index],\n            poolStorage.isMintPaused[index],\n            poolStorage.isRedeemPaused[index],\n            poolStorage.isBorrowPaused[index],\n            poolStorage.mintingFee[index],\n            poolStorage.redemptionFee[index]\n        );\n    }\n\n    /**\n     * @notice Returns USD value of all collateral tokens held in the pool, in E18\n     * @return balanceTally USD value of all collateral tokens\n     */\n    function collateralUsdBalance()\n        internal\n        view\n        returns (uint256 balanceTally)\n    {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        uint256 collateralTokensCount = poolStorage.collateralAddresses.length;\n        balanceTally = 0;\n        for (uint256 i = 0; i < collateralTokensCount; i++) {\n            balanceTally += freeCollateralBalance(i)\n                .mul(10 ** poolStorage.missingDecimals[i])\n                .mul(poolStorage.collateralPrices[i])\n                .div(UBIQUITY_POOL_PRICE_PRECISION);\n        }\n    }\n\n    /**\n     * @notice Returns free collateral balance (i.e. that can be borrowed by AMO minters)\n     * @param collateralIndex collateral token index\n     * @return Amount of free collateral\n     */\n    function freeCollateralBalance(\n        uint256 collateralIndex\n    ) internal view returns (uint256) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        return\n            IERC20(poolStorage.collateralAddresses[collateralIndex])\n                .balanceOf(address(this))\n                .sub(poolStorage.unclaimedPoolCollateral[collateralIndex]);\n    }\n\n    /**\n     * @notice Returns Dollar value in collateral tokens\n     * @param collateralIndex collateral token index\n     * @param dollarAmount Amount of Dollars\n     * @return Value in collateral tokens\n     */\n    function getDollarInCollateral(\n        uint256 collateralIndex,\n        uint256 dollarAmount\n    ) internal view returns (uint256) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        return\n            dollarAmount\n                .mul(UBIQUITY_POOL_PRICE_PRECISION)\n                .div(10 ** poolStorage.missingDecimals[collateralIndex])\n                .div(poolStorage.collateralPrices[collateralIndex]);\n    }\n\n    /**\n     * @notice Returns Ubiquity Dollar token USD price (1e6 precision) from Curve Metapool (Ubiquity Dollar, Curve Tri-Pool LP)\n     * @return dollarPriceUsd USD price of Ubiquity Dollar\n     */\n    function getDollarPriceUsd()\n        internal\n        view\n        returns (uint256 dollarPriceUsd)\n    {\n        // get Dollar price from Curve Metapool (18 decimals)\n        uint256 dollarPriceUsdD18 = LibTWAPOracle.getTwapPrice();\n        // convert to 6 decimals\n        dollarPriceUsd = dollarPriceUsdD18\n            .mul(UBIQUITY_POOL_PRICE_PRECISION)\n            .div(1e18);\n    }\n\n    //====================\n    // Public functions\n    //====================\n\n    /**\n     * @notice Mints Dollars in exchange for collateral tokens\n     * @param collateralIndex Collateral token index\n     * @param dollarAmount Amount of dollars to mint\n     * @param dollarOutMin Min amount of dollars to mint (slippage protection)\n     * @param maxCollateralIn Max amount of collateral to send (slippage protection)\n     * @return totalDollarMint Amount of Dollars minted\n     * @return collateralNeeded Amount of collateral sent to the pool\n     */\n    function mintDollar(\n        uint256 collateralIndex,\n        uint256 dollarAmount,\n        uint256 dollarOutMin,\n        uint256 maxCollateralIn\n    )\n        internal\n        collateralEnabled(collateralIndex)\n        returns (uint256 totalDollarMint, uint256 collateralNeeded)\n    {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        require(\n            poolStorage.isMintPaused[collateralIndex] == false,\n            \"Minting is paused\"\n        );\n\n        // update Dollar price from Curve's Dollar Metapool\n        LibTWAPOracle.update();\n        // prevent unnecessary mints\n        require(\n            getDollarPriceUsd() >= poolStorage.mintPriceThreshold,\n            \"Dollar price too low\"\n        );\n\n        // update collateral price\n        updateChainLinkCollateralPrice(collateralIndex);\n\n        // get amount of collateral for minting Dollars\n        collateralNeeded = getDollarInCollateral(collateralIndex, dollarAmount);\n\n        // subtract the minting fee\n        totalDollarMint = dollarAmount\n            .mul(\n                UBIQUITY_POOL_PRICE_PRECISION.sub(\n                    poolStorage.mintingFee[collateralIndex]\n                )\n            )\n            .div(UBIQUITY_POOL_PRICE_PRECISION);\n\n        // check slippages\n        require((totalDollarMint >= dollarOutMin), \"Dollar slippage\");\n        require((collateralNeeded <= maxCollateralIn), \"Collateral slippage\");\n\n        // check the pool ceiling\n        require(\n            freeCollateralBalance(collateralIndex).add(collateralNeeded) <=\n                poolStorage.poolCeilings[collateralIndex],\n            \"Pool ceiling\"\n        );\n\n        // take collateral first\n        IERC20(poolStorage.collateralAddresses[collateralIndex])\n            .safeTransferFrom(msg.sender, address(this), collateralNeeded);\n\n        // mint Dollars\n        IERC20Ubiquity ubiquityDollarToken = IERC20Ubiquity(\n            LibAppStorage.appStorage().dollarTokenAddress\n        );\n        ubiquityDollarToken.mint(msg.sender, totalDollarMint);\n    }\n\n    /**\n     * @notice Burns redeemable Ubiquity Dollars and sends back 1 USD of collateral token for every 1 Ubiquity Dollar burned\n     * @dev Redeem process is split in two steps:\n     * @dev 1. `redeemDollar()`\n     * @dev 2. `collectRedemption()`\n     * @dev This is done in order to prevent someone using a flash loan of a collateral token to mint, redeem, and collect in a single transaction/block\n     * @param collateralIndex Collateral token index being withdrawn\n     * @param dollarAmount Amount of Ubiquity Dollars being burned\n     * @param collateralOutMin Minimum amount of collateral tokens that'll be withdrawn, used to set acceptable slippage\n     * @return collateralOut Amount of collateral tokens ready for redemption\n     */\n    function redeemDollar(\n        uint256 collateralIndex,\n        uint256 dollarAmount,\n        uint256 collateralOutMin\n    )\n        internal\n        collateralEnabled(collateralIndex)\n        returns (uint256 collateralOut)\n    {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        require(\n            poolStorage.isRedeemPaused[collateralIndex] == false,\n            \"Redeeming is paused\"\n        );\n\n        // update Dollar price from Curve's Dollar Metapool\n        LibTWAPOracle.update();\n        // prevent unnecessary redemptions that could adversely affect the Dollar price\n        require(\n            getDollarPriceUsd() <= poolStorage.redeemPriceThreshold,\n            \"Dollar price too high\"\n        );\n\n        uint256 dollarAfterFee = dollarAmount\n            .mul(\n                UBIQUITY_POOL_PRICE_PRECISION.sub(\n                    poolStorage.redemptionFee[collateralIndex]\n                )\n            )\n            .div(UBIQUITY_POOL_PRICE_PRECISION);\n\n        // update collateral price\n        updateChainLinkCollateralPrice(collateralIndex);\n\n        // get collateral output for incoming Dollars\n        collateralOut = getDollarInCollateral(collateralIndex, dollarAfterFee);\n\n        // checks\n        require(\n            collateralOut <=\n                (IERC20(poolStorage.collateralAddresses[collateralIndex]))\n                    .balanceOf(address(this))\n                    .sub(poolStorage.unclaimedPoolCollateral[collateralIndex]),\n            \"Insufficient pool collateral\"\n        );\n        require(collateralOut >= collateralOutMin, \"Collateral slippage\");\n\n        // account for the redeem delay\n        poolStorage.redeemCollateralBalances[msg.sender][\n            collateralIndex\n        ] = poolStorage\n        .redeemCollateralBalances[msg.sender][collateralIndex].add(\n                collateralOut\n            );\n        poolStorage.unclaimedPoolCollateral[collateralIndex] = poolStorage\n            .unclaimedPoolCollateral[collateralIndex]\n            .add(collateralOut);\n\n        poolStorage.lastRedeemedBlock[msg.sender] = block.number;\n\n        // burn Dollars\n        IERC20Ubiquity ubiquityDollarToken = IERC20Ubiquity(\n            LibAppStorage.appStorage().dollarTokenAddress\n        );\n        ubiquityDollarToken.burnFrom(msg.sender, dollarAmount);\n    }\n\n    /**\n     * @notice Used to collect collateral tokens after redeeming/burning Ubiquity Dollars\n     * @dev Redeem process is split in two steps:\n     * @dev 1. `redeemDollar()`\n     * @dev 2. `collectRedemption()`\n     * @dev This is done in order to prevent someone using a flash loan of a collateral token to mint, redeem, and collect in a single transaction/block\n     * @param collateralIndex Collateral token index being collected\n     * @return collateralAmount Amount of collateral tokens redeemed\n     */\n    function collectRedemption(\n        uint256 collateralIndex\n    ) internal returns (uint256 collateralAmount) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        require(\n            poolStorage.isRedeemPaused[collateralIndex] == false,\n            \"Redeeming is paused\"\n        );\n        require(\n            (\n                poolStorage.lastRedeemedBlock[msg.sender].add(\n                    poolStorage.redemptionDelayBlocks\n                )\n            ) <= block.number,\n            \"Too soon to collect redemption\"\n        );\n\n        bool sendCollateral = false;\n\n        if (\n            poolStorage.redeemCollateralBalances[msg.sender][collateralIndex] >\n            0\n        ) {\n            collateralAmount = poolStorage.redeemCollateralBalances[msg.sender][\n                collateralIndex\n            ];\n            poolStorage.redeemCollateralBalances[msg.sender][\n                collateralIndex\n            ] = 0;\n            poolStorage.unclaimedPoolCollateral[collateralIndex] = poolStorage\n                .unclaimedPoolCollateral[collateralIndex]\n                .sub(collateralAmount);\n            sendCollateral = true;\n        }\n\n        // send out the tokens\n        if (sendCollateral) {\n            IERC20(poolStorage.collateralAddresses[collateralIndex])\n                .safeTransfer(msg.sender, collateralAmount);\n        }\n    }\n\n    /**\n     * @notice Updates collateral token price in USD from ChainLink price feed\n     * @param collateralIndex Collateral token index\n     */\n    function updateChainLinkCollateralPrice(uint256 collateralIndex) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            poolStorage.collateralPriceFeedAddresses[collateralIndex]\n        );\n\n        // fetch latest price\n        (\n            ,\n            // roundId\n            int256 answer, // startedAt\n            ,\n            uint256 updatedAt,\n\n        ) = // answeredInRound\n            priceFeed.latestRoundData();\n\n        // fetch number of decimals in chainlink feed\n        uint256 priceFeedDecimals = priceFeed.decimals();\n\n        // validation\n        require(answer > 0, \"Invalid price\");\n        require(\n            block.timestamp - updatedAt <\n                poolStorage.collateralPriceFeedStalenessThresholds[\n                    collateralIndex\n                ],\n            \"Stale data\"\n        );\n\n        // convert chainlink price to 6 decimals\n        uint256 price = uint256(answer).mul(UBIQUITY_POOL_PRICE_PRECISION).div(\n            10 ** priceFeedDecimals\n        );\n\n        poolStorage.collateralPrices[collateralIndex] = price;\n\n        emit CollateralPriceSet(collateralIndex, price);\n    }\n\n    //=========================\n    // AMO minters functions\n    //=========================\n\n    /**\n     * @notice Allows AMO minters to borrow collateral to make yield in external\n     * protocols like Compound, Curve, erc...\n     * @dev Bypasses the gassy mint->redeem cycle for AMOs to borrow collateral\n     * @param collateralAmount Amount of collateral to borrow\n     */\n    function amoMinterBorrow(uint256 collateralAmount) internal onlyAmoMinter {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        // checks the collateral index of the minter as an additional safety check\n        uint256 minterCollateralIndex = IDollarAmoMinter(msg.sender)\n            .collateralIndex();\n\n        // checks to see if borrowing is paused\n        require(\n            poolStorage.isBorrowPaused[minterCollateralIndex] == false,\n            \"Borrowing is paused\"\n        );\n\n        // ensure collateral is enabled\n        require(\n            poolStorage.isCollateralEnabled[\n                poolStorage.collateralAddresses[minterCollateralIndex]\n            ],\n            \"Collateral disabled\"\n        );\n\n        // transfer\n        IERC20(poolStorage.collateralAddresses[minterCollateralIndex])\n            .safeTransfer(msg.sender, collateralAmount);\n    }\n\n    //========================\n    // Restricted functions\n    //========================\n\n    /**\n     * @notice Adds a new AMO minter\n     * @param amoMinterAddress AMO minter address\n     */\n    function addAmoMinter(address amoMinterAddress) internal {\n        require(amoMinterAddress != address(0), \"Zero address detected\");\n\n        // make sure the AMO Minter has collateralDollarBalance()\n        uint256 collatValE18 = IDollarAmoMinter(amoMinterAddress)\n            .collateralDollarBalance();\n        require(collatValE18 >= 0, \"Invalid AMO\");\n\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.isAmoMinterEnabled[amoMinterAddress] = true;\n\n        emit AmoMinterAdded(amoMinterAddress);\n    }\n\n    /**\n     * @notice Adds a new collateral token\n     * @param collateralAddress Collateral token address\n     * @param chainLinkPriceFeedAddress Chainlink's price feed address\n     * @param poolCeiling Max amount of available tokens for collateral\n     */\n    function addCollateralToken(\n        address collateralAddress,\n        address chainLinkPriceFeedAddress,\n        uint256 poolCeiling\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        uint256 collateralIndex = poolStorage.collateralAddresses.length;\n\n        // add collateral address to all collaterals\n        poolStorage.collateralAddresses.push(collateralAddress);\n\n        // for fast collateral address -> collateral idx lookups later\n        poolStorage.collateralIndex[collateralAddress] = collateralIndex;\n\n        // set collateral initially to disabled\n        poolStorage.isCollateralEnabled[collateralAddress] = false;\n\n        // add in the missing decimals\n        poolStorage.missingDecimals.push(\n            uint256(18).sub(ERC20(collateralAddress).decimals())\n        );\n\n        // add in the collateral symbols\n        poolStorage.collateralSymbols.push(ERC20(collateralAddress).symbol());\n\n        // initialize unclaimed pool collateral\n        poolStorage.unclaimedPoolCollateral.push(0);\n\n        // initialize paused prices to $1 as a backup\n        poolStorage.collateralPrices.push(UBIQUITY_POOL_PRICE_PRECISION);\n\n        // set fees to 0 by default\n        poolStorage.mintingFee.push(0);\n        poolStorage.redemptionFee.push(0);\n\n        // handle the pauses\n        poolStorage.isMintPaused.push(false);\n        poolStorage.isRedeemPaused.push(false);\n        poolStorage.isBorrowPaused.push(false);\n\n        // set pool ceiling\n        poolStorage.poolCeilings.push(poolCeiling);\n\n        // set price feed address\n        poolStorage.collateralPriceFeedAddresses.push(\n            chainLinkPriceFeedAddress\n        );\n\n        // set price feed staleness threshold in seconds\n        poolStorage.collateralPriceFeedStalenessThresholds.push(1 days);\n    }\n\n    /**\n     * @notice Removes AMO minter\n     * @param amoMinterAddress AMO minter address to remove\n     */\n    function removeAmoMinter(address amoMinterAddress) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.isAmoMinterEnabled[amoMinterAddress] = false;\n\n        emit AmoMinterRemoved(amoMinterAddress);\n    }\n\n    /**\n     * @notice Sets collateral ChainLink price feed params\n     * @param collateralAddress Collateral token address\n     * @param chainLinkPriceFeedAddress ChainLink price feed address\n     * @param stalenessThreshold Threshold in seconds when chainlink answer should be considered stale\n     */\n    function setCollateralChainLinkPriceFeed(\n        address collateralAddress,\n        address chainLinkPriceFeedAddress,\n        uint256 stalenessThreshold\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        uint256 collateralIndex = poolStorage.collateralIndex[\n            collateralAddress\n        ];\n\n        // set price feed address\n        poolStorage.collateralPriceFeedAddresses[\n            collateralIndex\n        ] = chainLinkPriceFeedAddress;\n\n        // set staleness threshold in seconds when chainlink answer should be considered stale\n        poolStorage.collateralPriceFeedStalenessThresholds[\n            collateralIndex\n        ] = stalenessThreshold;\n\n        emit CollateralPriceFeedSet(\n            collateralIndex,\n            chainLinkPriceFeedAddress,"
    }
  ]
}