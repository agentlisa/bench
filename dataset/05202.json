{
  "Title": "[H-02] Order's creator can update `tokenOut` to arbitrary token",
  "Content": "\nWhen an order is created, it checks whether the `order.tokenOut` is equal to `marginPos.baseAsset` or `_tokenOut` is equal to `marginPos.quoteAsset`. However, when `tokenOut` is updated via `updateOrder`, it can be changed to an arbitrary token. This has the potential to be exploited by changing `tokenOut` to a high-value token right before the executor executes the `fillOrder`.\n\n### Proof of Concept\n\nIt can be observed that order's creator can update `order.tokenOut` to arbitrary token.\n\n<https://github.com/code-423n4/2024-01-init-capital-invitational/blob/main/contracts/hook/MarginTradingHook.sol#L504-L526>\n\n```solidity\n    function updateOrder(\n        uint _posId,\n        uint _orderId,\n        uint _triggerPrice_e36,\n        address _tokenOut,\n        uint _limitPrice_e36,\n        uint _collAmt\n    ) external {\n        _require(_collAmt != 0, Errors.ZERO_VALUE);\n        Order storage order = __orders[_orderId];\n        _require(order.status == OrderStatus.Active, Errors.INVALID_INPUT);\n        uint initPosId = initPosIds[msg.sender][_posId];\n        _require(initPosId != 0, Errors.POSITION_NOT_FOUND);\n        MarginPos memory marginPos = __marginPositions[initPosId];\n        uint collAmt = IPosManager(POS_MANAGER).getCollAmt(initPosId, marginPos.collPool);\n        _require(_collAmt <= collAmt, Errors.INPUT_TOO_HIGH);\n\n        order.triggerPrice_e36 = _triggerPrice_e36;\n        order.limitPrice_e36 = _limitPrice_e36;\n        order.collAmt = _collAmt;\n        order.tokenOut = _tokenOut;\n        emit UpdateOrder(initPosId, _orderId, _tokenOut, _triggerPrice_e36, _limitPrice_e36, _collAmt);\n    }\n```\n\nThis can be exploited by the order's creator. When the executor is about to execute the `fillOrder`, the order creator can front-run the operation by changing the `order.tokenOut` to a token with a high value. Consequently, the executor will transfer the amount that needs to be transferred but using this new high-value token. But this require hook already have approval from the executor to manage the new high value token.\n\n### Recommended Mitigation Steps\n\nValidate the new token when `updateOrder` is called :\n\n```diff\n    function updateOrder(\n        uint _posId,\n        uint _orderId,\n        uint _triggerPrice_e36,\n        address _tokenOut,\n        uint _limitPrice_e36,\n        uint _collAmt\n    ) external {\n        _require(_collAmt != 0, Errors.ZERO_VALUE);\n        Order storage order = __orders[_orderId];\n        _require(order.status == OrderStatus.Active, Errors.INVALID_INPUT);\n        uint initPosId = initPosIds[msg.sender][_posId];\n        _require(initPosId != 0, Errors.POSITION_NOT_FOUND);\n        MarginPos memory marginPos = __marginPositions[initPosId];\n        uint collAmt = IPosManager(POS_MANAGER).getCollAmt(initPosId, marginPos.collPool);\n        _require(_collAmt <= collAmt, Errors.INPUT_TOO_HIGH);\n+       _require(_tokenOut == marginPos.baseAsset || _tokenOut == marginPos.quoteAsset, Errors.INVALID_INPUT);\n\n        order.triggerPrice_e36 = _triggerPrice_e36;\n        order.limitPrice_e36 = _limitPrice_e36;\n        order.collAmt = _collAmt;\n        order.tokenOut = _tokenOut;\n        emit UpdateOrder(initPosId, _orderId, _tokenOut, _triggerPrice_e36, _limitPrice_e36, _collAmt);\n    }\n```\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2024-01-init-capital-invitational-findings/issues/23#issuecomment-1929196620)**\n\n**[Ladboy233 (Warden) commented](https://github.com/code-423n4/2024-01-init-capital-invitational-findings/issues/23#issuecomment-1932316201):**\n > I think the severity should be high because it is very common the executor tries to fill a lot of order that have different token.\n> \n> It is common that executor approves the hook to spend multiple tokens.\n> \n> Order creator frontrun to update order to different token clearly violate order executor's expectation if order creator update a low value token with high value token before the order is filled.\n\n**[hansfriese (Judge) increased severity to High and commented](https://github.com/code-423n4/2024-01-init-capital-invitational-findings/issues/23#issuecomment-1932318773):**\n > I left a comment [here](https://github.com/code-423n4/2024-01-init-capital-invitational-findings/issues/6#issuecomment-1932316024).\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-init-capital-invitational",
  "Code": [
    {
      "filename": "contracts/hook/MarginTradingHook.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\nimport {BaseMappingIdHook} from './BaseMappingIdHook.sol';\n\nimport {\n    OrderType,\n    OrderStatus,\n    SwapType,\n    Order,\n    MarginPos,\n    SwapInfo,\n    IMarginTradingHook\n} from '../interfaces/hook/IMarginTradingHook.sol';\nimport {IWNative} from '../interfaces/common/IWNative.sol';\nimport {IInitCore} from '../interfaces/core/IInitCore.sol';\nimport {ICallbackReceiver} from '../interfaces/receiver/ICallbackReceiver.sol';\nimport {IMulticall} from '../interfaces/common/IMulticall.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {IInitOracle} from '../interfaces/oracle/IInitOracle.sol';\nimport {IBaseSwapHelper} from '../interfaces/helper/swap_helper/IBaseSwapHelper.sol';\n\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Math} from '@openzeppelin-contracts/utils/math/Math.sol';\n\ncontract MarginTradingHook is BaseMappingIdHook, UnderACM, IMarginTradingHook, ICallbackReceiver {\n    using SafeERC20 for IERC20;\n    using Math for uint;\n\n    // constants\n    uint private constant ONE_E18 = 1e18;\n    uint private constant ONE_E36 = 1e36;\n    bytes32 private constant GOVERNOR = keccak256('governor');\n    // immutables\n    address public immutable WNATIVE;\n    // storages\n    address public swapHelper;\n    mapping(address => mapping(address => address)) private __quoteAssets;\n    mapping(uint => Order) private __orders;\n    mapping(uint => MarginPos) private __marginPositions;\n    mapping(uint => uint[]) private __posOrderIds;\n    uint public lastOrderId;\n\n    // modifiers\n    modifier onlyGovernor() {\n        ACM.checkRole(GOVERNOR, msg.sender);\n        _;\n    }\n\n    // constructor\n    constructor(address _core, address _posManager, address _wNative, address _acm)\n        BaseMappingIdHook(_core, _posManager)\n        UnderACM(_acm)\n    {\n        WNATIVE = _wNative;\n    }\n\n    // initializer\n    function initialize(address _swapHelper) external initializer {\n        swapHelper = _swapHelper;\n    }\n\n    modifier depositNative() {\n        if (msg.value != 0) IWNative(WNATIVE).deposit{value: msg.value}();\n        _;\n    }\n\n    modifier refundNative() {\n        _;\n        // refund native token\n        uint wNativeBal = IERC20(WNATIVE).balanceOf(address(this));\n        // NOTE: no need receive function since we will use TransparentUpgradeableProxyReceiveETH\n        if (wNativeBal != 0) IWNative(WNATIVE).withdraw(wNativeBal);\n        uint nativeBal = address(this).balance;\n        if (nativeBal != 0) {\n            (bool success,) = payable(msg.sender).call{value: nativeBal}('');\n            _require(success, Errors.CALL_FAILED);\n        }\n    }\n\n    // functions\n    /// @inheritdoc IMarginTradingHook\n    function openPos(\n        uint16 _mode,\n        address _viewer,\n        address _tokenIn,\n        uint _amtIn,\n        address _borrPool,\n        uint _borrAmt,\n        address _collPool,\n        bytes calldata _data,\n        uint _minHealth_e18\n    ) external payable depositNative refundNative returns (uint posId, uint initPosId, uint health_e18) {\n        initPosId = IInitCore(CORE).createPos(_mode, _viewer);\n        address borrToken = ILendingPool(_borrPool).underlyingToken();\n        {\n            (address baseToken, address quoteToken) = getBaseAssetAndQuoteAsset(\n                ILendingPool(_collPool).underlyingToken(), ILendingPool(_borrPool).underlyingToken()\n            );\n            bool isLongBaseAsset = baseToken != borrToken;\n            __marginPositions[initPosId] = MarginPos(_collPool, _borrPool, baseToken, quoteToken, isLongBaseAsset);\n        }\n        posId = ++lastPosIds[msg.sender];\n        initPosIds[msg.sender][posId] = initPosId;\n        health_e18 = _increasePosInternal(\n            IncreasePosInternalParam({\n                initPosId: initPosId,\n                tokenIn: _tokenIn,\n                amtIn: _amtIn,\n                borrPool: _borrPool,\n                borrAmt: _borrAmt,\n                collPool: _collPool,\n                data: _data,\n                minHealth_e18: _minHealth_e18\n            })\n        );\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function increasePos(\n        uint _posId,\n        address _tokenIn,\n        uint _amtIn,\n        uint _borrAmt,\n        bytes calldata _data,\n        uint _minHealth_e18\n    ) external payable depositNative refundNative returns (uint health_e18) {\n        uint initPosId = initPosIds[msg.sender][_posId];\n        _require(initPosId != 0, Errors.POSITION_NOT_FOUND);\n        MarginPos storage marginPos = __marginPositions[initPosId];\n        health_e18 = _increasePosInternal(\n            IncreasePosInternalParam({\n                initPosId: initPosId,\n                tokenIn: _tokenIn,\n                amtIn: _amtIn,\n                borrPool: marginPos.borrPool,\n                borrAmt: _borrAmt,\n                collPool: marginPos.collPool,\n                data: _data,\n                minHealth_e18: _minHealth_e18\n            })\n        );\n    }\n\n    /// @dev increase margin pos internal logic\n    function _increasePosInternal(IncreasePosInternalParam memory _param) internal returns (uint health_e18) {\n        _transmitTokenIn(_param.tokenIn, _param.amtIn);\n\n        // perform multicall to INIT core:\n        // 1. borrow tokens\n        // 2. callback (perform swap from borr -> coll)\n        // 3. deposit collateral tokens\n        // 4. collateralize tokens\n        bytes[] memory multicallData = new bytes[](4);\n        multicallData[0] = abi.encodeWithSelector(\n            IInitCore(CORE).borrow.selector, _param.borrPool, _param.borrAmt, _param.initPosId, address(this)\n        );\n        address collToken = ILendingPool(_param.collPool).underlyingToken();\n        address borrToken = ILendingPool(_param.borrPool).underlyingToken();\n        _require(_param.tokenIn == collToken || _param.tokenIn == borrToken, Errors.INVALID_INPUT);\n        {\n            SwapInfo memory swapInfo =\n                SwapInfo(_param.initPosId, SwapType.OpenExactIn, borrToken, collToken, 0, _param.data);\n            multicallData[1] =\n                abi.encodeWithSelector(IInitCore(CORE).callback.selector, address(this), 0, abi.encode(swapInfo));\n        }\n        multicallData[2] = abi.encodeWithSelector(IInitCore(CORE).mintTo.selector, _param.collPool, POS_MANAGER);\n        multicallData[3] =\n            abi.encodeWithSelector(IInitCore(CORE).collateralize.selector, _param.initPosId, _param.collPool);\n\n        // do multicall\n        IMulticall(CORE).multicall(multicallData);\n\n        // position health check\n        health_e18 = _validateHealth(_param.initPosId, _param.minHealth_e18);\n        emit IncreasePos(_param.initPosId, _param.tokenIn, borrToken, _param.amtIn, _param.borrAmt);\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function addCollateral(uint _posId, uint _amtIn)\n        external\n        payable\n        depositNative\n        refundNative\n        returns (uint health_e18)\n    {\n        uint initPosId = initPosIds[msg.sender][_posId];\n        _require(initPosId != 0, Errors.POSITION_NOT_FOUND);\n        MarginPos storage marginPos = __marginPositions[initPosId];\n        address collToken = ILendingPool(marginPos.collPool).underlyingToken();\n        // transfer in tokens\n        _transmitTokenIn(collToken, _amtIn);\n        // transfer tokens to collPool\n        IERC20(collToken).safeTransfer(marginPos.collPool, _amtIn);\n        // mint collateral pool tokens\n        IInitCore(CORE).mintTo(marginPos.collPool, POS_MANAGER);\n        // collateralize to INIT position\n        IInitCore(CORE).collateralize(initPosId, marginPos.collPool);\n        // get health\n        health_e18 = IInitCore(CORE).getPosHealthCurrent_e18(initPosId);\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function removeCollateral(uint _posId, uint _shares, bool _returnNative)\n        external\n        refundNative\n        returns (uint health_e18)\n    {\n        uint initPosId = initPosIds[msg.sender][_posId];\n        _require(initPosId != 0, Errors.POSITION_NOT_FOUND);\n        MarginPos storage marginPos = __marginPositions[initPosId];\n        address collToken = ILendingPool(marginPos.collPool).underlyingToken();\n        // decollateralize collTokens to collPool\n        IInitCore(CORE).decollateralize(initPosId, marginPos.collPool, _shares, marginPos.collPool);\n        // redeem underlying\n        IInitCore(CORE).burnTo(marginPos.collPool, address(this));\n        // transfer collateral tokens out\n        uint balance = IERC20(collToken).balanceOf(address(this));\n        _transmitTokenOut(collToken, balance, _returnNative);\n        // get position health\n        health_e18 = IInitCore(CORE).getPosHealthCurrent_e18(initPosId);\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function repayDebt(uint _posId, uint _repayShares)\n        external\n        payable\n        depositNative\n        refundNative\n        returns (uint repayAmt, uint health_e18)\n    {\n        uint initPosId = initPosIds[msg.sender][_posId];\n        _require(initPosId != 0, Errors.POSITION_NOT_FOUND);\n        MarginPos storage marginPos = __marginPositions[initPosId];\n        address borrPool = marginPos.borrPool;\n        // calculate repay shares (if it exceeds position debt share, only repay what's available)\n        uint debtShares = IPosManager(POS_MANAGER).getPosDebtShares(initPosId, borrPool);\n        if (_repayShares > debtShares) _repayShares = debtShares;\n        // get borrow token amount to repay\n        address borrToken = ILendingPool(borrPool).underlyingToken();\n        uint amtToRepay = ILendingPool(borrPool).debtShareToAmtCurrent(_repayShares);\n        // transfer in borrow tokens\n        _transmitTokenIn(borrToken, amtToRepay);\n        // repay debt to INIT core\n        _ensureApprove(borrToken, amtToRepay);\n        repayAmt = IInitCore(CORE).repay(borrPool, _repayShares, initPosId);\n        // get position health\n        health_e18 = IInitCore(CORE).getPosHealthCurrent_e18(initPosId);\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function reducePos(\n        uint _posId,\n        uint _collAmt,\n        uint _repayShares,\n        address _tokenOut,\n        uint _minAmtOut,\n        bool _returnNative,\n        bytes calldata _data,\n        uint _minHealth_e18\n    ) external refundNative returns (uint amtOut, uint health_e18) {\n        uint initPosId = initPosIds[msg.sender][_posId];\n        (amtOut, health_e18) = _reducePosInternal(\n            ReducePosInternalParam({\n                initPosId: initPosId,\n                collAmt: _collAmt,\n                repayShares: _repayShares,\n                tokenOut: _tokenOut,\n                minAmtOut: _minAmtOut,\n                returnNative: _returnNative,\n                data: _data,\n                minHealth_e18: _minHealth_e18\n            })\n        );\n    }\n\n    function _reducePosInternal(ReducePosInternalParam memory _param) internal returns (uint amtOut, uint health_e18) {\n        MarginPos memory marginPos = __marginPositions[_param.initPosId];\n        // check collAmt & repay shares\n        _require(\n            _param.collAmt <= IPosManager(POS_MANAGER).getCollAmt(_param.initPosId, marginPos.collPool),\n            Errors.INPUT_TOO_HIGH\n        );\n        _require(\n            _param.repayShares <= IPosManager(POS_MANAGER).getPosDebtShares(_param.initPosId, marginPos.borrPool),\n            Errors.INPUT_TOO_HIGH\n        );\n\n        address collToken = ILendingPool(marginPos.collPool).underlyingToken();\n        address borrToken = ILendingPool(marginPos.borrPool).underlyingToken();\n        _require(_param.tokenOut == collToken || _param.tokenOut == borrToken, Errors.INVALID_INPUT);\n\n        uint repayAmt = ILendingPool(marginPos.borrPool).debtShareToAmtCurrent(_param.repayShares);\n        _ensureApprove(borrToken, repayAmt);\n\n        // 1. decollateralize collateral tokens\n        // 2. redeem underlying collateral tokens\n        // 3. callback (perform swap from coll -> borr)\n        // 4. repay borrow tokens\n        bytes[] memory multicallData = new bytes[](4);\n        multicallData[0] = abi.encodeWithSelector(\n            IInitCore(CORE).decollateralize.selector,\n            _param.initPosId,\n            marginPos.collPool,\n            _param.collAmt,\n            marginPos.collPool\n        );\n        multicallData[1] = abi.encodeWithSelector(IInitCore(CORE).burnTo.selector, marginPos.collPool, address(this));\n        {\n            // if expect token out = borr token -> swap all (exact-in)\n            // if expect token out = coll token -> swap enough to repay (exact-out)\n            SwapType swapType = _param.tokenOut == borrToken ? SwapType.CloseExactIn : SwapType.CloseExactOut;\n            SwapInfo memory swapInfo = SwapInfo(_param.initPosId, swapType, collToken, borrToken, repayAmt, _param.data);\n            multicallData[2] =\n                abi.encodeWithSelector(IInitCore(CORE).callback.selector, address(this), 0, abi.encode(swapInfo));\n        }\n        multicallData[3] = abi.encodeWithSelector(\n            IInitCore(CORE).repay.selector, marginPos.borrPool, _param.repayShares, _param.initPosId\n        );\n\n        // do multicall\n        IMulticall(CORE).multicall(multicallData);\n        amtOut = IERC20(_param.tokenOut).balanceOf(address(this));\n        // slippage control check\n        _require(amtOut >= _param.minAmtOut, Errors.SLIPPAGE_CONTROL);\n        // transfer tokens out\n        _transmitTokenOut(_param.tokenOut, amtOut, _param.returnNative);\n\n        // check slippage control on position's health\n        health_e18 = _validateHealth(_param.initPosId, _param.minHealth_e18);\n        emit ReducePos(_param.initPosId, _param.tokenOut, amtOut, _param.collAmt, repayAmt);\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function addStopLossOrder(\n        uint _posId,\n        uint _triggerPrice_e36,\n        address _tokenOut,\n        uint _limitPrice_e36,\n        uint _collAmt\n    ) external returns (uint orderId) {\n        orderId = _createOrder(_posId, _triggerPrice_e36, _tokenOut, _limitPrice_e36, _collAmt, OrderType.StopLoss);\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function addTakeProfitOrder(\n        uint _posId,\n        uint _triggerPrice_e36,\n        address _tokenOut,\n        uint _limitPrice_e36,\n        uint _collAmt\n    ) external returns (uint orderId) {\n        orderId = _createOrder(_posId, _triggerPrice_e36, _tokenOut, _limitPrice_e36, _collAmt, OrderType.TakeProfit);\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function cancelOrder(uint _posId, uint _orderId) external {\n        uint initPosId = initPosIds[msg.sender][_posId];\n        _require(initPosId != 0, Errors.POSITION_NOT_FOUND);\n        Order storage order = __orders[_orderId];\n        _require(order.initPosId == initPosId, Errors.INVALID_INPUT);\n        _require(order.status == OrderStatus.Active, Errors.INVALID_INPUT);\n        order.status = OrderStatus.Cancelled;\n        emit CancelOrder(initPosId, _orderId);\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function fillOrder(uint _orderId) external {\n        Order memory order = __orders[_orderId];\n        _require(order.status == OrderStatus.Active, Errors.INVALID_INPUT);\n        MarginPos memory marginPos = __marginPositions[order.initPosId];\n        address collToken = ILendingPool(marginPos.collPool).underlyingToken();\n        address borrToken = ILendingPool(marginPos.borrPool).underlyingToken();\n        // if position is empty, cancel order\n        if (IPosManager(POS_MANAGER).getCollAmt(order.initPosId, marginPos.collPool) == 0) {\n            order.status = OrderStatus.Cancelled;\n            emit CancelOrder(order.initPosId, _orderId);\n            return;\n        }\n        // validate trigger price condition\n        _validateTriggerPrice(order, marginPos);\n        // calculate fill order info\n        (uint amtOut, uint repayShares, uint repayAmt) = _calculateFillOrderInfo(order, marginPos, collToken);\n        // transfer in repay tokens\n        IERC20(borrToken).safeTransferFrom(msg.sender, address(this), repayAmt);\n        // transfer order owner's desired tokens to the specified recipient\n        IERC20(order.tokenOut).safeTransferFrom(msg.sender, order.recipient, amtOut);\n        // repay tokens\n        _ensureApprove(borrToken, repayAmt);\n        IInitCore(CORE).repay(marginPos.borrPool, repayShares, order.initPosId);\n        // decollateralize coll pool tokens to executor\n        IInitCore(CORE).decollateralize(order.initPosId, marginPos.collPool, order.collAmt, msg.sender);\n        // update order status\n        __orders[_orderId].status = OrderStatus.Filled;\n        emit FillOrder(order.initPosId, _orderId, order.tokenOut, amtOut);\n    }\n\n    /// @inheritdoc ICallbackReceiver\n    function coreCallback(address _sender, bytes calldata _data) external payable returns (bytes memory result) {\n        _require(msg.sender == CORE, Errors.NOT_INIT_CORE);\n        _require(_sender == address(this), Errors.NOT_AUTHORIZED);\n        SwapInfo memory swapInfo = abi.decode(_data, (SwapInfo));\n        MarginPos memory marginPos = __marginPositions[swapInfo.initPosId];\n        uint amtIn = IERC20(swapInfo.tokenIn).balanceOf(address(this));\n        IERC20(swapInfo.tokenIn).safeTransfer(swapHelper, amtIn); // transfer all token in to swap helper\n        // swap helper swap token\n        IBaseSwapHelper(swapHelper).swap(swapInfo);\n        uint amtOut = IERC20(swapInfo.tokenOut).balanceOf(address(this));\n        if (swapInfo.swapType == SwapType.OpenExactIn) {\n            // transfer to coll pool to mint\n            IERC20(swapInfo.tokenOut).safeTransfer(marginPos.collPool, amtOut);\n            emit SwapToIncreasePos(swapInfo.initPosId, swapInfo.tokenIn, swapInfo.tokenOut, amtIn, amtOut);\n        } else {\n            // transfer to borr pool to repay\n            uint amtSwapped = amtIn;\n            if (swapInfo.swapType == SwapType.CloseExactOut) {\n                // slippage control to make sure that swap helper swap correctly\n                _require(IERC20(swapInfo.tokenOut).balanceOf(address(this)) == swapInfo.amtOut, Errors.SLIPPAGE_CONTROL);\n                amtSwapped -= IERC20(swapInfo.tokenIn).balanceOf(address(this));\n            }\n            emit SwapToReducePos(swapInfo.initPosId, swapInfo.tokenIn, swapInfo.tokenOut, amtSwapped, amtOut);\n        }\n        result = abi.encode(amtOut);\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function setQuoteAsset(address _tokenA, address _tokenB, address _quoteAsset) external onlyGovernor {\n        _require(_tokenA != address(0) && _tokenB != address(0), Errors.ZERO_VALUE);\n        _require(_quoteAsset == _tokenA || _quoteAsset == _tokenB, Errors.INVALID_INPUT);\n        _require(_tokenA != _tokenB, Errors.NOT_SORTED_OR_DUPLICATED_INPUT);\n        // sort tokenA and tokenB\n        (address token0, address token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\n        __quoteAssets[token0][token1] = _quoteAsset;\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function getBaseAssetAndQuoteAsset(address _tokenA, address _tokenB)\n        public\n        view\n        returns (address baseAsset, address quoteAsset)\n    {\n        // sort tokenA and tokenB\n        (address token0, address token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\n        quoteAsset = __quoteAssets[token0][token1];\n        _require(quoteAsset != address(0), Errors.ZERO_VALUE);\n        baseAsset = quoteAsset == token0 ? token1 : token0;\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function getOrder(uint _orderId) external view returns (Order memory) {\n        return __orders[_orderId];\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function getMarginPos(uint _initPosId) external view returns (MarginPos memory) {\n        return __marginPositions[_initPosId];\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function getPosOrdersLength(uint _initPosId) external view returns (uint) {\n        return __posOrderIds[_initPosId].length;\n    }\n\n    /// @notice _collAmt MUST be > 0\n    /// @dev create order internal logic\n    function _createOrder(\n        uint _posId,\n        uint _triggerPrice_e36,\n        address _tokenOut,\n        uint _limitPrice_e36,\n        uint _collAmt,\n        OrderType _orderType\n    ) internal returns (uint orderId) {\n        orderId = ++lastOrderId;\n        _require(_collAmt != 0, Errors.ZERO_VALUE);\n        uint initPosId = initPosIds[msg.sender][_posId];\n        _require(initPosId != 0, Errors.POSITION_NOT_FOUND);\n        MarginPos memory marginPos = __marginPositions[initPosId];\n        _require(_tokenOut == marginPos.baseAsset || _tokenOut == marginPos.quoteAsset, Errors.INVALID_INPUT);\n        uint collAmt = IPosManager(POS_MANAGER).getCollAmt(initPosId, marginPos.collPool);\n        _require(_collAmt <= collAmt, Errors.INPUT_TOO_HIGH); // check specified coll amt is feasible\n\n        __orders[orderId] = (\n            Order({\n                initPosId: initPosId,\n                triggerPrice_e36: _triggerPrice_e36,\n                limitPrice_e36: _limitPrice_e36,\n                collAmt: _collAmt,\n                tokenOut: _tokenOut,\n                orderType: _orderType,\n                status: OrderStatus.Active,\n                recipient: msg.sender\n            })\n        );\n        __posOrderIds[initPosId].push(orderId);\n        emit CreateOrder(initPosId, orderId, _tokenOut, _triggerPrice_e36, _limitPrice_e36, _collAmt, _orderType);\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function updateOrder(\n        uint _posId,\n        uint _orderId,\n        uint _triggerPrice_e36,\n        address _tokenOut,\n        uint _limitPrice_e36,\n        uint _collAmt\n    ) external {\n        _require(_collAmt != 0, Errors.ZERO_VALUE);\n        Order storage order = __orders[_orderId];\n        _require(order.status == OrderStatus.Active, Errors.INVALID_INPUT);\n        uint initPosId = initPosIds[msg.sender][_posId];\n        _require(initPosId != 0, Errors.POSITION_NOT_FOUND);\n        MarginPos memory marginPos = __marginPositions[initPosId];\n        uint collAmt = IPosManager(POS_MANAGER).getCollAmt(initPosId, marginPos.collPool);\n        _require(_collAmt <= collAmt, Errors.INPUT_TOO_HIGH);\n\n        order.triggerPrice_e36 = _triggerPrice_e36;\n        order.limitPrice_e36 = _limitPrice_e36;\n        order.collAmt = _collAmt;\n        order.tokenOut = _tokenOut;\n        emit UpdateOrder(initPosId, _orderId, _tokenOut, _triggerPrice_e36, _limitPrice_e36, _collAmt);\n    }\n\n    /// @dev calculate fill order info\n    /// @param _order margin order info\n    /// @param _marginPos margin pos info\n    /// @param _collToken margin pos's collateral token\n    function _calculateFillOrderInfo(Order memory _order, MarginPos memory _marginPos, address _collToken)\n        internal\n        returns (uint amtOut, uint repayShares, uint repayAmt)\n    {\n        (repayShares, repayAmt) = _calculateRepaySize(_order, _marginPos);\n        uint collTokenAmt = ILendingPool(_marginPos.collPool).toAmtCurrent(_order.collAmt);\n        // NOTE: all roundings favor the order owner (amtOut)\n        if (_collToken == _order.tokenOut) {\n            if (_marginPos.isLongBaseAsset) {\n                // long eth hold eth\n                // (2 * 1500 - 1500) = 1500 / 1500 = 1 eth\n                // ((c * limit - borrow) / limit\n                amtOut = collTokenAmt - repayAmt * ONE_E36 / _order.limitPrice_e36;\n            } else {\n                // short eth hold usdc\n                // 2000 - 1 * 1500 = 500 usdc\n                // (c - borrow * limit)\n                amtOut = collTokenAmt - (repayAmt * _order.limitPrice_e36 / ONE_E36);\n            }\n        } else {\n            if (_marginPos.isLongBaseAsset) {\n                // long eth hold usdc\n                // (2 * 1500 - 1500) = 1500 usdc\n                // ((c * limit - borrow)\n                amtOut = (collTokenAmt * _order.limitPrice_e36).ceilDiv(ONE_E36) - repayAmt;\n            } else {\n                // short eth hold eth\n                // (3000 - 1 * 1500) / 1500 = 1 eth\n                // (c - borrow * limit) / limit\n                amtOut = (collTokenAmt * ONE_E36).ceilDiv(_order.limitPrice_e36) - repayAmt;\n            }\n        }\n    }\n\n    /// @dev validate price for margin order for the margin position\n    /// @param _order margin order info\n    /// @param _marginPos margin position info\n    function _validateTriggerPrice(Order memory _order, MarginPos memory _marginPos) internal view {\n        address oracle = IInitCore(CORE).oracle();\n        uint markPrice_e36 = IInitOracle(oracle).getPrice_e36(_marginPos.baseAsset).mulDiv(\n            ONE_E36, IInitOracle(oracle).getPrice_e36(_marginPos.quoteAsset)\n        );\n        // validate mark price\n        // if long base asset, and order type is to take profit -> mark price should pass the trigger price (>=)\n        // if long base asset, and order type is to add stop loss -> mark price should be smaller than the trigger price (<=)\n        // if short base asset, and order type is to take profit -> mark price should be smaller than the trigger price (<=)\n        // if short base asset, and order type is to add stop loss -> mark price should be larger than the trigger price (>=)\n        (_order.orderType == OrderType.TakeProfit) == _marginPos.isLongBaseAsset\n            ? _require(markPrice_e36 >= _order.triggerPrice_e36, Errors.INVALID_INPUT)\n            : _require(markPrice_e36 <= _order.triggerPrice_e36, Errors.INVALID_INPUT);\n    }\n\n    /// @notice if the specified order size is larger than the position's collateral, repay size is scaled proportionally.\n    /// @dev calculate repay size of the given margin order\n    /// @param _order order info\n    /// @param _marginPos margin position info\n    /// @return repayAmt repay amount\n    /// @return repayShares repay shares\n    function _calculateRepaySize(Order memory _order, MarginPos memory _marginPos)\n        internal\n        returns (uint repayAmt, uint repayShares)\n    {\n        uint totalCollAmt = IPosManager(POS_MANAGER).getCollAmt(_order.initPosId, _marginPos.collPool);\n        if (_order.collAmt > totalCollAmt) _order.collAmt = totalCollAmt;\n        uint totalDebtShares = IPosManager(POS_MANAGER).getPosDebtShares(_order.initPosId, _marginPos.borrPool);\n        repayShares = totalDebtShares * _order.collAmt / totalCollAmt;\n        repayAmt = ILendingPool(_marginPos.borrPool).debtShareToAmtCurrent(repayShares);\n    }\n\n    /// @notice if msg.value is provided, then _amt to expect for the transfer is the amount needed on top of msg.value\n    /// @dev transfer _tokenIn in with specific amount\n    /// @param _tokenIn token in address\n    /// @param _amt token amount to expect (this amount includes msg.value if _tokenIn is wrapped native)\n    function _transmitTokenIn(address _tokenIn, uint _amt) internal {\n        uint amtToTransfer = _amt;\n        if (msg.value != 0) {\n            _require(_tokenIn == WNATIVE, Errors.NOT_WNATIVE);\n            amtToTransfer = _amt > msg.value ? amtToTransfer - msg.value : 0;\n        }\n        if (amtToTransfer != 0) IERC20(_tokenIn).safeTransferFrom(msg.sender, address(this), amtToTransfer);\n    }\n\n    /// @notice if _returnNative is true, this function does nothing\n    /// @dev transfer _tokenOut out with specific amount\n    /// @param _tokenOut token out address\n    /// @param _amt token amount to transfer\n    /// @param _returnNative whether to return in native token (only applies in case _tokenOut is wrapped native)\n    function _transmitTokenOut(address _tokenOut, uint _amt, bool _returnNative) internal {\n        // note: if token out is wNative and return native is true,\n        // leave token in this contract to be handled by refundNative modifier\n        // else transfer token out to msg.sender\n        if (_tokenOut != WNATIVE || !_returnNative) IERC20(_tokenOut).safeTransfer(msg.sender, _amt);\n    }\n\n    /// @dev validate position health\n    function _validateHealth(uint _initPosId, uint _minHealth_e18) internal returns (uint health_e18) {\n        health_e18 = IInitCore(CORE).getPosHealthCurrent_e18(_initPosId);\n        _require(health_e18 >= _minHealth_e18, Errors.SLIPPAGE_CONTROL);\n    }\n\n    /// @inheritdoc IMarginTradingHook\n    function getPosOrderIds(uint _initPosId) external view returns (uint[] memory) {\n        return __posOrderIds[_initPosId];\n    }\n}"
    }
  ]
}