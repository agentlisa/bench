{
  "Title": "[M-08] Assets in a Safe can be lost",
  "Content": "\nThe `Guard.sol` contract is enabled on Safe's and uses the [`_checkTransaction`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195-L293) function to ensure that transactions that the Safe executes do not transfer the asset out of the Safe.\n\nThe `checkTransaction` function achieves this by isolating the function selector and checking that it is not a disallowed function selector. For instance: `safeTransferFrom`, `transferFrom`, `approve`, `enableModule`, etc.\n\nThe list does not, however, check for calls to `burn` the token, neither does it check if it is a `permit`. The sponsor has noted the following:\n\n> The [Guard](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol) contract can only protect against the transfer of tokens that faithfully\nimplement the ERC721/ERC1155 spec.\n\nBut this does not acknowledge the fact that an ERC721/ERC1155 implementation can still be an honest implementation and have extra functionality. In particular, the `burn` function is a common addition to many ERC721 contracts, usually granted through inheriting `ERC721Burnable`.\n\nFor example, the following projects all have a `burn` function, and Safe's protected by `Guard.sol` that hold these NFTs will be vulnerable to loss of assets via a malicious renter:\n\n*   [Pudgy Penguins](https://etherscan.io/address/0xbd3531da5cf5857e7cfaa92426877b022e612cf8#writeContract)\n*   [Lil Pudgies](https://etherscan.io/address/0x524cab2ec69124574082676e6f654a18df49a048#writeContract)\n*   [Oh Ottie](https://etherscan.io/address/0x7ff5601b0a434b52345c57a01a28d63f3e892ac0#code#F3#L45)\n\nThese are three that are in the top 10 projects on Opensea at the time of writing.\n\n### Proof of Concept\n\nWe can see in the `Guard.sol` file that certain function selectors are imported to be tested against:\n\n    import {\n        shared_set_approval_for_all_selector,\n        e721_approve_selector,\n        e721_safe_transfer_from_1_selector,\n        e721_safe_transfer_from_2_selector,\n        e721_transfer_from_selector,\n        e721_approve_token_id_offset,\n        e721_safe_transfer_from_1_token_id_offset,\n        e721_safe_transfer_from_2_token_id_offset,\n        e721_transfer_from_token_id_offset,\n        e1155_safe_transfer_from_selector,\n        e1155_safe_batch_transfer_from_selector,\n        e1155_safe_transfer_from_token_id_offset,\n        e1155_safe_batch_transfer_from_token_id_offset,\n        gnosis_safe_set_guard_selector,\n        gnosis_safe_enable_module_selector,\n        gnosis_safe_disable_module_selector,\n        gnosis_safe_enable_module_offset,\n        gnosis_safe_disable_module_offset\n    } from \"@src/libraries/RentalConstants.sol\";\n\nFrom the `_checkTransaction` function we see that there is no check for `burn`, `burnFrom` or `permit`.\n\nA malicious renter who is renting the asset can still execute `burn` (common), `burnFrom` (rare) or `permit` (popularized by [Uni v3](https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/base/ERC721Permit.sol#L52C9-L86)), which will lead to loss of the asset.\n\n### Coded PoC\n\nThe below test can be placed in the `CheckTransaction.t.sol` test file. It should be run with `forge test --match-test test_PoC -vvvv`\n\n        function test_PoC() public {\n            bytes4 burn_selector = 0x42966c68;\n            // Create a rentalId array\n            RentalAssetUpdate[] memory rentalAssets = new RentalAssetUpdate[](1);\n            rentalAssets[0] = RentalAssetUpdate(\n                RentalUtils.getItemPointer(address(alice.safe), address(erc721s[0]), 0),\n                1\n            );\n\n            // Mark the rental as actively rented in storage\n            _markRentalsAsActive(rentalAssets);\n\n            // Build up the `transferFrom(address from, address to, uint256 tokenId)` calldata\n            bytes memory burnCalldata = abi.encodeWithSelector(\n                burn_selector,\n                69\n            );\n\n            // Expect revert because of an unauthorized function selector\n            _checkTransactionRevertUnauthorizedSelector(\n                address(alice.safe),\n                address(erc721s[0]),\n                burn_selector,\n                burnCalldata\n            );\n        }\n\nThe console output is:\n\n    Encountered 1 failing test in test/unit/Guard/CheckTransaction.t.sol:Guard_CheckTransaction_Unit_Test\n    [FAIL. Reason: call did not revert as expected] test_PoC() (gas: 96093)\n\nThis shows that the `checkTransaction` would not protect against calls to `burn` the asset.\n\n### Recommended Mitigation Steps\n\nAlthough not a catch-all, adding checks for `burn`, `burnFrom` and `permit` functions (which are common in smart contracts) should prevent this in most cases.\n\nSelectors:\n\n*   `burn`: `0x42966c68`\n*   `burnFrom`: `0x1fe41211`\n*   `permit` : `0xabae8f0d`\n\nIn the `Guard.sol` file:\n\n<Details>\n\n```diff\n        } else if (selector == e1155_safe_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == burn_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, burn_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == burn_From_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, burn_From_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == permit_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, permit_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } \n```\n</details>\n\n*Please note that there may be other flavours of the `permit` function that have different signatures.*\n\n**[141345 (Lookout) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1902725917):**\n > [Issue 587](https://github.com/code-423n4/2024-01-renft-findings/issues/587) has a detailed discussion about `permit()`.\n\n**[Alec1017 (reNFT) acknowledged and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1908940377):**\n > Non-standard ERC implementations were considered out of scope, but regardless we do plan on adding a whitelist for tokens interacting with the protocol\n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1912774849):**\n > Originally commented on https://github.com/code-423n4/2024-01-renft-findings/issues/587#issuecomment-1912630065\n> \n> But same thing applies here, I don't think this can be called out of scope but do think M is more appropiate.\n\n**[Alec1017 (reNFT) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1915456905):**\n > Given the justification for #587, M severity seems fair.\n\n**[lokithe5th (Warden) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1916119263):**\n > @0xean thank you for your judging efforts. \n> \n> As the author of this submission I would like to highlight a mistake in my report: the Safe itself will not be calling the `permit()` function, only signing a transaction that approves a `permit`. Adding a check for the `permit` selector will not be effective. \n> \n> I draw attention to this fact because I do not want the sponsor to believe they have guarded against the `permit` vulnerability by implementing the suggested fix, while they may still in fact be vulnerable to it.\n> \n> However, the PoC and the suggested fix remain valid for `burn` and `burnFrom` functions. \n> \n> Credit to issue #587 and @stalinMacias for pointing this nuance out.\n\n**[0xStalin (Warden) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1916150182):**\n > Thanks @lokithe5th. \n> \n> I believe this issue is completely valid in regards to the `burn` functionality and is providing the right mitigation for it.\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/5) - Added support for burnable ERC721 and ERC1155 tokens.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/53), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/55) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/14).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/policies/Guard.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {BaseGuard} from \"@safe-contracts/base/GuardManager.sol\";\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {\n    shared_set_approval_for_all_selector,\n    e721_approve_selector,\n    e721_safe_transfer_from_1_selector,\n    e721_safe_transfer_from_2_selector,\n    e721_transfer_from_selector,\n    e721_approve_token_id_offset,\n    e721_safe_transfer_from_1_token_id_offset,\n    e721_safe_transfer_from_2_token_id_offset,\n    e721_transfer_from_token_id_offset,\n    e1155_safe_transfer_from_selector,\n    e1155_safe_batch_transfer_from_selector,\n    e1155_safe_transfer_from_token_id_offset,\n    e1155_safe_batch_transfer_from_token_id_offset,\n    gnosis_safe_set_guard_selector,\n    gnosis_safe_enable_module_selector,\n    gnosis_safe_disable_module_selector,\n    gnosis_safe_enable_module_offset,\n    gnosis_safe_disable_module_offset\n} from \"@src/libraries/RentalConstants.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Guard\n * @notice Acts as an interface for all behavior related to guarding transactions\n *         that originate from a rental wallet.\n */\ncontract Guard is Policy, BaseGuard {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](1);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);\n        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Loads a `bytes32` value from calldata.\n     *\n     * @param data   Calldata of the transaction to execute.\n     * @param offset Byte offset where the value starts.\n     *\n     * @return value The value retrieved from the data.\n     */\n    function _loadValueFromCalldata(\n        bytes memory data,\n        uint256 offset\n    ) private pure returns (bytes32 value) {\n        // Load the `uint256` from calldata at the offset.\n        assembly {\n            value := mload(add(data, offset))\n        }\n    }\n\n    /**\n     * @dev Reverts if the token is actively rented.\n     *\n     * @param selector Function selector which cannot be called\n     * @param safe     Address of the safe that originated the call\n     * @param token    Address of the token which is actively rented.\n     * @param tokenId  ID of the token which is actively rented.\n     */\n    function _revertSelectorOnActiveRental(\n        bytes4 selector,\n        address safe,\n        address token,\n        uint256 tokenId\n    ) private view {\n        // Check if the selector is allowed.\n        if (STORE.isRentedOut(safe, token, tokenId)) {\n            revert Errors.GuardPolicy_UnauthorizedSelector(selector);\n        }\n    }\n\n    /**\n     * @dev Reverts if the extension is not whitelisted.\n     *\n     * @param extension Address of the extension.\n     */\n    function _revertNonWhitelistedExtension(address extension) private view {\n        // Check if the extension is whitelisted.\n        if (!STORE.whitelistedExtensions(extension)) {\n            revert Errors.GuardPolicy_UnauthorizedExtension(extension);\n        }\n    }\n\n    /**\n     * @dev Forwards a gnosis safe call to a hook contract for further processing.\n     *\n     * @param hook  Address of the hook contract.\n     * @param safe  Address of the rental wallet that originated the call.\n     * @param to    Address that the call is directed to.\n     * @param value Value of ether sent with the call.\n     * @param data  Calldata to execute.\n     */\n    function _forwardToHook(\n        address hook,\n        address safe,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) private {\n        // Call the `onTransaction` hook function.\n        try IHook(hook).onTransaction(safe, to, value, data) {} catch Error(\n            string memory revertReason\n        ) {\n            // Revert with reason given.\n            revert Errors.Shared_HookFailString(revertReason);\n        } catch Panic(uint256 errorCode) {\n            // Convert solidity panic code to string.\n            string memory stringErrorCode = LibString.toString(errorCode);\n\n            // Revert with panic code.\n            revert Errors.Shared_HookFailString(\n                string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n            );\n        } catch (bytes memory revertData) {\n            // Fallback to an error that returns the byte data.\n            revert Errors.Shared_HookFailBytes(revertData);\n        }\n    }\n\n    /**\n     * @dev Prevent transactions that involve transferring an ERC721 or ERC1155 in any\n     *      way, and prevent transactions that involve changing the modules or the\n     *      guard contract.\n     *\n     * @param from Rental safe address that initiated the transaction.\n     * @param to Address that the data is targetted to.\n     * @param data Calldata of the transaction.\n     */\n    function _checkTransaction(address from, address to, bytes memory data) private view {\n        bytes4 selector;\n\n        // Load in the function selector.\n        assembly {\n            selector := mload(add(data, 0x20))\n        }\n\n        if (selector == e721_safe_transfer_from_1_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_safe_transfer_from_1_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_safe_transfer_from_2_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_safe_transfer_from_2_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_approve_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_approve_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e1155_safe_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == gnosis_safe_enable_module_selector) {\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n                        _loadValueFromCalldata(data, gnosis_safe_enable_module_offset)\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n            _revertNonWhitelistedExtension(extension);\n        } else if (selector == gnosis_safe_disable_module_selector) {\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n                        _loadValueFromCalldata(data, gnosis_safe_disable_module_offset)\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n            _revertNonWhitelistedExtension(extension);\n        } else {\n            // Revert if the `setApprovalForAll` selector is specified. This selector is\n            // shared between ERC721 and ERC1155 tokens.\n            if (selector == shared_set_approval_for_all_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    shared_set_approval_for_all_selector\n                );\n            }\n\n            // Revert if the `safeBatchTransferFrom` selector is specified. There's no\n            // cheap way to check if individual items in the batch are rented out.\n            // Each token ID would require a call to the storage contract to check\n            // its rental status.\n            if (selector == e1155_safe_batch_transfer_from_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    e1155_safe_batch_transfer_from_selector\n                );\n            }\n\n            // Revert if the `setGuard` selector is specified.\n            if (selector == gnosis_safe_set_guard_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    gnosis_safe_set_guard_selector\n                );\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /** @notice Checks a transaction initiated by a rental safe to decide whether\n     *          it can be allowed or not. During this check, execution control flow\n     *          will be passed to an external hook contract if one exists for the\n     *          target contract.\n     *\n     * @param to             Destination address of Safe transaction.\n     * @param value          Ether value of Safe transaction.\n     * @param data           Data payload of Safe transaction.\n     * @param operation      Operation type of Safe transaction.\n     */\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        address payable,\n        bytes memory,\n        address\n    ) external override {\n        // Disallow transactions that use delegate call, unless explicitly\n        // permitted by the protocol.\n        if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n            revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n        }\n\n        // Require that a function selector exists.\n        if (data.length < 4) {\n            revert Errors.GuardPolicy_FunctionSelectorRequired();\n        }\n\n        // Fetch the hook to interact with for this transaction.\n        address hook = STORE.contractToHook(to);\n        bool isActive = STORE.hookOnTransaction(hook);\n\n        // If a hook exists and is enabled, forward the control flow to the hook.\n        if (hook != address(0) && isActive) {\n            _forwardToHook(hook, msg.sender, to, value, data);\n        }\n        // If no hook exists, use basic tx check.\n        else {\n            _checkTransaction(msg.sender, to, data);\n        }\n    }\n\n    /**\n     * @notice Performs any checks after execution. This is left unimplemented.\n     *\n     * @param txHash Hash of the transaction.\n     * @param success Whether the transaction succeeded.\n     */\n    function checkAfterExecution(bytes32 txHash, bool success) external override {}\n\n    /**\n     * @notice Connects a target contract to a hook.\n     *\n     * @param to   The destination contract of a call.\n     * @param hook The hook middleware contract to sit between the call\n     *             and the destination.\n     */\n    function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\") {\n        STORE.updateHookPath(to, hook);\n    }\n\n    /**\n     * @notice Toggle the status of a hook contract, which defines the functionality\n     *         that the hook supports.\n     *\n     * @param hook The hook contract address.\n     * @param bitmap Bitmap of the status.\n     */\n    function updateHookStatus(\n        address hook,\n        uint8 bitmap\n    ) external onlyRole(\"GUARD_ADMIN\") {\n        STORE.updateHookStatus(hook, bitmap);\n    }\n}"
    },
    {
      "filename": "contracts/base/ERC721Permit.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '../libraries/ChainId.sol';\nimport '../interfaces/external/IERC1271.sol';\nimport '../interfaces/IERC721Permit.sol';\nimport './BlockTimestamp.sol';\n\n/// @title ERC721 with permit\n/// @notice Nonfungible tokens that support an approve via signature, i.e. permit\nabstract contract ERC721Permit is BlockTimestamp, ERC721, IERC721Permit {\n    /// @dev Gets the current nonce for a token ID and then increments it, returning the original value\n    function _getAndIncrementNonce(uint256 tokenId) internal virtual returns (uint256);\n\n    /// @dev The hash of the name used in the permit signature verification\n    bytes32 private immutable nameHash;\n\n    /// @dev The hash of the version string used in the permit signature verification\n    bytes32 private immutable versionHash;\n\n    /// @notice Computes the nameHash and versionHash\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        string memory version_\n    ) ERC721(name_, symbol_) {\n        nameHash = keccak256(bytes(name_));\n        versionHash = keccak256(bytes(version_));\n    }\n\n    /// @inheritdoc IERC721Permit\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                    nameHash,\n                    versionHash,\n                    ChainId.get(),\n                    address(this)\n                )\n            );\n    }\n\n    /// @inheritdoc IERC721Permit\n    /// @dev Value is equal to keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH =\n        0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\n\n    /// @inheritdoc IERC721Permit\n    function permit(\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        require(_blockTimestamp() <= deadline, 'Permit expired');\n\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, _getAndIncrementNonce(tokenId), deadline))\n                )\n            );\n        address owner = ownerOf(tokenId);\n        require(spender != owner, 'ERC721Permit: approval to current owner');\n\n        if (Address.isContract(owner)) {\n            require(IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e, 'Unauthorized');\n        } else {\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0), 'Invalid signature');\n            require(recoveredAddress == owner, 'Unauthorized');\n        }\n\n        _approve(spender, tokenId);\n    }\n}"
    }
  ]
}