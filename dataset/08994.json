{
  "Title": "[L-03] Migrations should do some validation",
  "Content": "<h2 id=\"l-03-migrations-should-do-some-validation\" style=\"position:relative;\"><a href=\"#l-03-migrations-should-do-some-validation\" aria-label=\"l 03 migrations should do some validation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-03] Migrations should do some validation</h2>\n<p>At the very least, a new bath token should have the same underlying to make sure funds can be taken out</p>\n<p><em>There is 1 instance of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"69\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">rubiconPools</span><span class=\"mtk1\">/</span><span class=\"mtk12\">BathHouse</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">216</span><span class=\"mtk1\">      </span><span class=\"mtk3\">/// @notice A migration function that allows the admin to write arbitrarily to tokenToBathToken</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">217</span><span class=\"mtk1\">      </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">adminWriteBathToken</span><span class=\"mtk1\">(</span><span class=\"mtk12\">ERC20</span><span class=\"mtk1\"> </span><span class=\"mtk12\">overwriteERC20</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">newBathToken</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">218          </span><span class=\"mtk11\">external</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">219          </span><span class=\"mtk11\">onlyAdmin</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">220      {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">221</span><span class=\"mtk1\">          </span><span class=\"mtk12\">tokenToBathToken</span><span class=\"mtk1\">[</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">overwriteERC20</span><span class=\"mtk1\">)] = </span><span class=\"mtk12\">newBathToken</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">222</span><span class=\"mtk1\">          </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">LogNewBathToken</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">223</span><span class=\"mtk1\">              </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">overwriteERC20</span><span class=\"mtk1\">),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">224</span><span class=\"mtk1\">              </span><span class=\"mtk12\">newBathToken</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">225</span><span class=\"mtk1\">              </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">226</span><span class=\"mtk1\">              </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">227</span><span class=\"mtk1\">              </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">228</span><span class=\"mtk1\">          );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">229</span><span class=\"mtk1\">:     }</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L216-L229\">https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L216-L229</a></p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-05-rubicon-contest",
  "Code": [
    {
      "filename": "contracts/rubiconPools/BathHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @title  The administrator contract of Rubicon Pools\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice The BathHouse initializes proxy-wrapped bathTokens, manages approved strategists, and sets system variables\n\npragma solidity =0.7.6;\n\nimport \"./BathToken.sol\";\nimport \"../interfaces/IBathPair.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract BathHouse {\n    /// *** Storage Variables ***\n\n    /// @notice Rubicon Bath House\n    string public name;\n\n    /// @notice The administrator of the Bath House contract\n    address public admin;\n\n    /// @notice The proxy administrator of Bath Tokens\n    address public proxyManager;\n\n    /// @notice The core Rubicon Market of the Pools system\n    address public RubiconMarketAddress;\n\n    /// @notice A mapping of approved strategists to access Pools liquidity\n    mapping(address => bool) public approvedStrategists;\n\n    /// @notice The initialization status of BathHouse\n    bool public initialized;\n\n    /// @notice If true, strategists are permissioned and must be approved by admin\n    bool public permissionedStrategists;\n\n    /// @notice Key, system-wide risk parameter for all liquity Pools\n    /// @notice This represents the proportion of a pool's underlying assets that must remain in the pool\n    /// @dev This protects a run on the bank scenario and ensures users can withdraw while allowing funds to be utilized for yield in the market\n    uint256 public reserveRatio;\n\n    /// @notice A variable time delay after which a strategist must return funds to the Bath Token\n    uint256 public timeDelay;\n\n    /// @notice The lone Bath Pair contract of the system which acts as the strategist entry point and logic contract\n    address public approvedPairContract;\n\n    /// @notice The basis point fee that is paid to strategists from LPs on capital that is successfully rebalanced to a Bath Token\n    uint8 public bpsToStrategists;\n\n    /// @notice Key mapping for determining the address of a Bath Token based on its underlying asset\n    /// @dev Source of truth mapping that logs all ERC20 Liquidity pools underlying asset => bathToken Address\n    mapping(address => address) public tokenToBathToken;\n\n    /// @notice The BathToken.sol implementation that any new bathTokens inherit\n    /// @dev The implementation of any ~newly spawned~ proxy-wrapped Bath Tokens via _createBathToken\n    address public newBathTokenImplementation;\n\n    /// *** Events ***\n\n    /// @notice An event that signals the creation of a new Bath Token\n    event LogNewBathToken(\n        address underlyingToken,\n        address bathTokenAddress,\n        address bathTokenFeeAdmin,\n        uint256 timestamp,\n        address bathTokenCreator\n    );\n\n    /// @notice An event that signals the permissionless spawning of a new Bath Token\n    event LogOpenCreationSignal(\n        ERC20 newERC20Underlying,\n        address spawnedBathToken,\n        uint256 initialNewBathTokenDeposit,\n        ERC20 pairedExistingAsset,\n        address pairedExistingBathToken,\n        uint256 pairedBathTokenDeposit,\n        address signaler\n    );\n\n    /// *** Modifiers ***\n\n    /// @notice This modifier enforces that only the admin can call these functions\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    /// *** External Functions ***\n\n    /// @notice The constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage that sets key storage variables\n    /// @dev Admin is set to msg.sender\n    function initialize(\n        address market,\n        uint256 _reserveRatio,\n        uint256 _timeDelay,\n        address _newBathTokenImplementation,\n        address _proxyAdmin\n    ) external {\n        require(!initialized);\n        name = \"Rubicon Bath House\";\n        admin = msg.sender;\n        timeDelay = _timeDelay;\n\n        // Set Bath Token reserve ratio globally\n        require(_reserveRatio <= 100);\n        require(_reserveRatio > 0);\n        reserveRatio = _reserveRatio;\n\n        // Set BPS reward fee for successful strategist market-making\n        /// @notice [(10000 - {bpsToStrategists}) / 10000] BPS of MM-ing activity is passed to users\n        bpsToStrategists = 20;\n\n        // Set key storage variables\n        RubiconMarketAddress = market;\n        permissionedStrategists = true;\n        newBathTokenImplementation = _newBathTokenImplementation;\n        proxyManager = _proxyAdmin;\n\n        // Automatically approve admin as an approved strategist\n        approveStrategist(admin);\n\n        // Complete contract instantiation\n        initialized = true;\n    }\n\n    /// @notice Permissionless entry point to spawn a Bath Token while posting liquidity to a ~pair of Bath Tokens~\n    /// @notice Please note, creating a Bath Token in this fashion ~does not~ gaurentee markets will be made for the new pair. This function signals the desire to have a new pair supported on Rubicon for strategists to consider market-making for\n    /// @notice The best desiredPairedAsset to select is a popular quote currency. Many traditional systems quote in USD while the ETH quote is superior - the choice is yours sweet msg.sender\n    /// @dev The user must approve the bathHouse to spend their ERC20s\n    /// @dev The user can only spawn a Bath Token for an ERC20 that is not yet in the Pools system and they must post liquidity on the other side of the pair for an ~extant Bath Token~\n    function openBathTokenSpawnAndSignal(\n        ERC20 newBathTokenUnderlying,\n        uint256 initialLiquidityNew, // Must approve this contract to spend\n        ERC20 desiredPairedAsset, // Must be paired with an existing quote for v1\n        uint256 initialLiquidityExistingBathToken\n    ) external returns (address newBathToken) {\n        // Check that it doesn't already exist\n        require(\n            getBathTokenfromAsset(newBathTokenUnderlying) == address(0),\n            \"bathToken already exists for that ERC20\"\n        );\n        require(\n            getBathTokenfromAsset(desiredPairedAsset) != address(0),\n            \"bathToken does not exist for that desiredPairedAsset\"\n        );\n\n        // Spawn a bathToken for the new asset\n        address newOne = _createBathToken(newBathTokenUnderlying, address(0)); // NOTE: address(0) as feeAdmin means fee is paid to pool holders\n\n        // Deposit initial liquidity posted of newBathTokenUnderlying\n        require(\n            newBathTokenUnderlying.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityNew\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n\n        newBathTokenUnderlying.approve(newOne, initialLiquidityNew);\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(newOne).deposit(initialLiquidityNew, msg.sender);\n\n        // desiredPairedAsset must be pulled and deposited into bathToken\n        require(\n            desiredPairedAsset.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityExistingBathToken\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n        address pairedPool = getBathTokenfromAsset((desiredPairedAsset));\n        desiredPairedAsset.approve(\n            pairedPool,\n            initialLiquidityExistingBathToken\n        );\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(pairedPool).deposit(\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        // emit an event describing the new pair, underlyings and bathTokens\n        emit LogOpenCreationSignal(\n            newBathTokenUnderlying,\n            newOne,\n            initialLiquidityNew,\n            desiredPairedAsset,\n            pairedPool,\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        newBathToken = newOne;\n    }\n\n    /// ** Admin-Only Functions **\n\n    /// @notice An admin-only function to create a new Bath Token for any ERC20\n    function createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        external\n        onlyAdmin\n        returns (address newBathTokenAddress)\n    {\n        newBathTokenAddress = _createBathToken(underlyingERC20, _feeAdmin);\n    }\n\n    /// @notice A migration function that allows the admin to write arbitrarily to tokenToBathToken\n    function adminWriteBathToken(ERC20 overwriteERC20, address newBathToken)\n        external\n        onlyAdmin\n    {\n        tokenToBathToken[address(overwriteERC20)] = newBathToken;\n        emit LogNewBathToken(\n            address(overwriteERC20),\n            newBathToken,\n            address(0),\n            block.timestamp,\n            msg.sender\n        );\n    }\n\n    /// @notice Function to initialize and store the address of the ~lone~ bathPair contract for the Rubicon protocol\n    function initBathPair(\n        address _bathPairAddress,\n        uint256 _maxOrderSizeBPS,\n        int128 _shapeCoefNum\n    ) external onlyAdmin returns (address newPair) {\n        require(\n            approvedPairContract == address(0),\n            \"BathPair already approved\"\n        );\n        require(\n            IBathPair(_bathPairAddress).initialized() != true,\n            \"BathPair already initialized\"\n        );\n        newPair = _bathPairAddress;\n\n        IBathPair(newPair).initialize(_maxOrderSizeBPS, _shapeCoefNum);\n\n        approvedPairContract = newPair;\n    }\n\n    /// @notice Admin-only function to set a new Admin\n    function setBathHouseAdmin(address newAdmin) external onlyAdmin {\n        admin = newAdmin;\n    }\n\n    /// @notice Admin-only function to set a new Bath Token implementation\n    /// @dev Please note that all bathTokens created will use this abi\n    function setNewBathTokenImplementation(address newImplementation) external onlyAdmin {\n        newBathTokenImplementation = newImplementation;\n    }\n\n    /// @notice Admin-only function to approve a new permissioned strategist\n    function approveStrategist(address strategist) public onlyAdmin {\n        approvedStrategists[strategist] = true;\n    }\n\n    /// @notice Admin-only function to set whether or not strategists are permissioned\n    function setPermissionedStrategists(bool _new) external onlyAdmin {\n        permissionedStrategists = _new;\n    }\n\n    /// @notice Admin-only function to set timeDelay\n    function setCancelTimeDelay(uint256 value) external onlyAdmin {\n        timeDelay = value;\n    }\n\n    /// @notice Admin-only function to set reserveRatio\n    function setReserveRatio(uint256 rr) external onlyAdmin {\n        require(rr <= 100);\n        require(rr > 0);\n        reserveRatio = rr;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's timeDelay\n    function setBathTokenMarket(address bathToken, address newMarket)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setMarket(newMarket);\n    }\n\n    /// @notice Admin-only function to add a bonus token to a Bath Token's reward schema\n    function setBonusToken(address bathToken, address newBonusToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBonusToken(newBonusToken);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathTokenBathHouse(address bathToken, address newAdmin)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBathHouse(newAdmin);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n\n    /// @notice Admin-only function to approve the Bath Token's underlying token on the assigned market\n    /// @dev required in case the market address ever changes.. #battleScars\n    function bathTokenApproveSetMarket(address targetBathToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(targetBathToken).approveMarket();\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient (typically the Bath Token itself)\n    function setBathTokenFeeTo(address bathToken, address feeTo)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeTo(feeTo);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's target Rubicon Market\n    function setMarket(address newMarket) external onlyAdmin {\n        RubiconMarketAddress = newMarket;\n    }\n\n    /// *** View Functions ***\n\n    // Getter Functions for parameters\n    function getMarket() external view returns (address) {\n        return RubiconMarketAddress;\n    }\n\n    function getReserveRatio() external view returns (uint256) {\n        return reserveRatio;\n    }\n\n    function getCancelTimeDelay() external view returns (uint256) {\n        return timeDelay;\n    }\n\n    /// @notice Returns the address of any bathToken in the system based on its corresponding underlying asset\n    function getBathTokenfromAsset(ERC20 asset) public view returns (address) {\n        return tokenToBathToken[address(asset)];\n    }\n\n    function getBPSToStrats() public view returns (uint8) {\n        return bpsToStrategists;\n    }\n\n    /// *** System Security Checks ***\n\n    /// @notice A function to check whether or not an address is an approved strategist\n    function isApprovedStrategist(address wouldBeStrategist)\n        external\n        view\n        returns (bool)\n    {\n        if (\n            approvedStrategists[wouldBeStrategist] == true ||\n            !permissionedStrategists\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice A function to check whether or not an address is the approved system instance of BathPair.sol\n    function isApprovedPair(address pair) public view returns (bool outcome) {\n        pair == approvedPairContract ? outcome = true : outcome = false;\n    }\n\n    /// *** Internal Functions ***\n\n    /// @dev Low-level functionality to spawn a Bath Token using the OZ Transparent Upgradeable Proxy standard\n    /// @param underlyingERC20 The underlying ERC-20 asset that underlies the newBathTokenAddress\n    /// @param _feeAdmin Recipient of pool withdrawal fees, typically the pool itself\n    function _createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        internal\n        returns (address newBathTokenAddress)\n    {\n        require(initialized, \"BathHouse not initialized\");\n        address _underlyingERC20 = address(underlyingERC20);\n        require(\n            _underlyingERC20 != address(0),\n            \"Cant create bathToken for zero address\"\n        );\n\n        // Check that it isn't already logged in the registry\n        require(\n            tokenToBathToken[_underlyingERC20] == address(0),\n            \"bathToken already exists\"\n        );\n\n        // Creates a new bathToken that is upgradeable by the proxyManager\n        require(\n            newBathTokenImplementation != address(0),\n            \"no implementation set for bathTokens\"\n        );\n\n        // Note, the option of a fee recipient for pool withdrawls exists. For all pools this is set to the pool itself in production and is visible via ~feeTo~ on any respective contract\n        // Note, fee admin presently ignored in the Bath Token initialization() call via defaulting to itself; though, this is still upgradeable by the Bath House admin via\n        bytes memory _initData = abi.encodeWithSignature(\n            \"initialize(address,address,address)\",\n            _underlyingERC20,\n            (RubiconMarketAddress),\n            (_feeAdmin)\n        );\n\n\n            TransparentUpgradeableProxy newBathToken\n         = new TransparentUpgradeableProxy(\n            newBathTokenImplementation,\n            proxyManager,\n            _initData\n        );\n\n        // New Bath Token Address\n        newBathTokenAddress = address(newBathToken);\n\n        // Write to source-of-truth router mapping for this ERC-20 => Bath Token\n        tokenToBathToken[_underlyingERC20] = newBathTokenAddress;\n\n        // Log Data\n        emit LogNewBathToken(\n            _underlyingERC20,\n            newBathTokenAddress,\n            _feeAdmin,\n            block.timestamp,\n            msg.sender\n        );\n    }\n}"
    }
  ]
}