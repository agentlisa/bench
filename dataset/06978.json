{
  "Title": "[G-04] Avoid calling the same internal function multiple times",
  "Content": "Calling an internal function will cost at least ~16-20 gas (JUMP to internal function instructions and JUMP back to original instructions). If you call the same internal function multiple times you can save gas by caching the return value of the internal function.\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/plugins/governance/majority-voting/token/TokenVoting.sol#L91-L102\n\n### Cache value from `_msgSender()`\n```solidity\nFile: src/plugins/governance/majority-voting/token/TokenVoting.sol\n91:        if (votingToken.getPastVotes(_msgSender(), snapshotBlock) < minProposerVotingPower()) {\n92:            revert ProposalCreationForbidden(_msgSender());\n93:        }\n94:\n95:        proposalId = _createProposal({\n96:            _creator: _msgSender(),\n97:            _metadata: _metadata,\n98:            _startDate: _startDate,\n99:            _endDate: _endDate,\n100:            _actions: _actions,\n101:            _allowFailureMap: _allowFailureMap\n102:        });\n```\n```diff\ndiff --git a/src/plugins/governance/majority-voting/token/TokenVoting.sol b/src/plugins/governance/majority-voting/token/TokenVoting.sol\nindex a3e26c3..820d3bc 100644\n--- a/src/plugins/governance/majority-voting/token/TokenVoting.sol\n+++ b/src/plugins/governance/majority-voting/token/TokenVoting.sol\n@@ -88,12 +88,13 @@ contract TokenVoting is IMembership, MajorityVotingBase {\n             revert NoVotingPower();\n         }\n\n-        if (votingToken.getPastVotes(_msgSender(), snapshotBlock) < minProposerVotingPower()) {\n-            revert ProposalCreationForbidden(_msgSender());\n+        address sender = _msgSender();\n+        if (votingToken.getPastVotes(sender, snapshotBlock) < minProposerVotingPower()) {\n+            revert ProposalCreationForbidden(sender);\n         }\n\n         proposalId = _createProposal({\n-            _creator: _msgSender(),\n+            _creator: sender,\n             _metadata: _metadata,\n             _startDate: _startDate,\n             _endDate: _endDate,\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/plugins/governance/majority-voting/addresslist/AddresslistVoting.sol#L97-L108\n```solidity\nFile: src/plugins/governance/majority-voting/addresslist/AddresslistVoting.sol\n97:        if (minProposerVotingPower() != 0 && !isListedAtBlock(_msgSender(), snapshotBlock)) {\n98:            revert ProposalCreationForbidden(_msgSender());\n99:        }\n100:\n101:        proposalId = _createProposal({\n102:            _creator: _msgSender(),\n103:            _metadata: _metadata,\n104:            _startDate: _startDate,\n105:            _endDate: _endDate,\n106:            _actions: _actions,\n107:            _allowFailureMap: _allowFailureMap\n108:        });\n```\n```diff\ndiff --git a/src/plugins/governance/majority-voting/addresslist/AddresslistVoting.sol b/src/plugins/governance/majority-voting/addresslist/AddressListVoting.sol\nindex 0ccd8a3..df9912d 100644\n--- a/src/plugins/governance/majority-voting/addresslist/AddresslistVoting.sol\n+++ b/src/plugins/governance/majority-voting/addresslist/AddressListVoting.sol\n@@ -93,13 +93,14 @@ contract AddresslistVoting is IMembership, Addresslist, MajorityVotingBase {\n         unchecked {\n             snapshotBlock = block.number.toUint64() - 1;\n         }\n-\n-        if (minProposerVotingPower() != 0 && !isListedAtBlock(_msgSender(), snapshotBlock)) {\n-            revert ProposalCreationForbidden(_msgSender());\n+\n+        address sender = _msgSender();\n+        if (minProposerVotingPower() != 0 && !isListedAtBlock(sender, snapshotBlock)) {\n+            revert ProposalCreationForbidden(sender);\n         }\n\n         proposalId = _createProposal({\n-            _creator: _msgSender(),\n+            _creator: sender,\n             _metadata: _metadata,\n             _startDate: _startDate,\n             _endDate: _endDate,\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/plugins/governance/multisig/Multisig.sol#L216-L237\n```solidity\nFile: src/plugins/governance/multisig/Multisig.sol\n216:        if (multisigSettings.onlyListed && !isListedAtBlock(_msgSender(), snapshotBlock)) {\n217:            revert ProposalCreationForbidden(_msgSender());\n218:        }\n219:\n220:        if (_startDate == 0) {\n221:            _startDate = block.timestamp.toUint64();\n222:        } else if (_startDate < block.timestamp.toUint64()) {\n223:            revert DateOutOfBounds({limit: block.timestamp.toUint64(), actual: _startDate});\n224:        }\n225:\n226:        if (_endDate < _startDate) {\n227:            revert DateOutOfBounds({limit: _startDate, actual: _endDate});\n228:        }\n229:\n230:        proposalId = _createProposal({\n231:            _creator: _msgSender(),\n232:            _metadata: _metadata,\n233:            _startDate: _startDate,\n234:            _endDate: _endDate,\n235:            _actions: _actions,\n236:            _allowFailureMap: _allowFailureMap\n237:        });\n```\n```diff\ndiff --git a/src/plugins/governance/multisig/Multisig.sol b/src/plugins/governance/multisig/Multisig.sol\nindex d2dd072..f64e8ec 100644\n--- a/src/plugins/governance/multisig/Multisig.sol\n+++ b/src/plugins/governance/multisig/Multisig.sol\n@@ -212,9 +212,10 @@ contract Multisig is\n         uint64 _endDate\n     ) external returns (uint256 proposalId) {\n         uint64 snapshotBlock = block.number.toUint64() - 1;\n-\n-        if (multisigSettings.onlyListed && !isListedAtBlock(_msgSender(), snapshotBlock)) {\n-            revert ProposalCreationForbidden(_msgSender());\n+\n+        address sender = _msgSender();\n+        if (multisigSettings.onlyListed && !isListedAtBlock(sender, snapshotBlock)) {\n+            revert ProposalCreationForbidden(sender);\n         }\n\n         if (_startDate == 0) {\n@@ -228,7 +229,7 @@ contract Multisig is\n         }\n\n         proposalId = _createProposal({\n-            _creator: _msgSender(),\n+            _creator: sender,\n             _metadata: _metadata,\n             _startDate: _startDate,\n             _endDate: _endDate,\n```\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-03-aragon-findings/issues/105#issuecomment-1465262109):**\n > While some of these have been identified in the [known issues](https://gist.github.com/Picodes/16984274f6ad7b83b7a59f8b33cee6a6) - the warden does a good job of going well beyond the known issues and showing the actual saving. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-03-aragon-findings/issues/105#issuecomment-1465270513):**\n > This report may have less findings than some other Grade-A reports, but they are validated in code, which I think makes them significantly more valuable. Awarding as Best.\n\n**[novaknole20 (Aragon) acknowledged](https://github.com/code-423n4/2023-03-aragon-findings/issues/105#issuecomment-1479302894)**\n\n\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-03-aragon",
  "Code": [
    {
      "filename": "packages/contracts/src/plugins/governance/majority-voting/token/TokenVoting.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {IVotesUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {IMembership} from \"../../../../core/plugin/membership/IMembership.sol\";\nimport {IDAO} from \"../../../../core/dao/IDAO.sol\";\nimport {RATIO_BASE, _applyRatioCeiled} from \"../../../utils/Ratio.sol\";\nimport {MajorityVotingBase} from \"../MajorityVotingBase.sol\";\nimport {IMajorityVoting} from \"../IMajorityVoting.sol\";\n\n/// @title TokenVoting\n/// @author Aragon Association - 2021-2023\n/// @notice The majority voting implementation using an [OpenZepplin `Votes`](https://docs.openzeppelin.com/contracts/4.x/api/governance#Votes) compatible governance token.\n/// @dev This contract inherits from `MajorityVotingBase` and implements the `IMajorityVoting` interface.\ncontract TokenVoting is IMembership, MajorityVotingBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant TOKEN_VOTING_INTERFACE_ID =\n        this.initialize.selector ^ this.getVotingToken.selector;\n\n    /// @notice An [OpenZepplin `Votes`](https://docs.openzeppelin.com/contracts/4.x/api/governance#Votes) compatible contract referencing the token being used for voting.\n    IVotesUpgradeable private votingToken;\n\n    /// @notice Thrown if the voting power is zero\n    error NoVotingPower();\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _token The [ERC-20](https://eips.ethereum.org/EIPS/eip-20) token used for voting.\n    function initialize(\n        IDAO _dao,\n        VotingSettings calldata _votingSettings,\n        IVotesUpgradeable _token\n    ) external initializer {\n        __MajorityVotingBase_init(_dao, _votingSettings);\n\n        votingToken = _token;\n\n        emit MembershipContractAnnounced({definingContract: address(_token)});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == TOKEN_VOTING_INTERFACE_ID ||\n            _interfaceId == type(IMembership).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice getter function for the voting token.\n    /// @dev public function also useful for registering interfaceId and for distinguishing from majority voting interface.\n    /// @return The token used for voting.\n    function getVotingToken() public view returns (IVotesUpgradeable) {\n        return votingToken;\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function totalVotingPower(uint256 _blockNumber) public view override returns (uint256) {\n        return votingToken.getPastTotalSupply(_blockNumber);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function createProposal(\n        bytes calldata _metadata,\n        IDAO.Action[] calldata _actions,\n        uint256 _allowFailureMap,\n        uint64 _startDate,\n        uint64 _endDate,\n        VoteOption _voteOption,\n        bool _tryEarlyExecution\n    ) external override returns (uint256 proposalId) {\n        uint256 snapshotBlock;\n        unchecked {\n            snapshotBlock = block.number - 1;\n        }\n\n        uint256 totalVotingPower_ = totalVotingPower(snapshotBlock);\n\n        if (totalVotingPower_ == 0) {\n            revert NoVotingPower();\n        }\n\n        if (votingToken.getPastVotes(_msgSender(), snapshotBlock) < minProposerVotingPower()) {\n            revert ProposalCreationForbidden(_msgSender());\n        }\n\n        proposalId = _createProposal({\n            _creator: _msgSender(),\n            _metadata: _metadata,\n            _startDate: _startDate,\n            _endDate: _endDate,\n            _actions: _actions,\n            _allowFailureMap: _allowFailureMap\n        });\n\n        // Store proposal related information\n        Proposal storage proposal_ = proposals[proposalId];\n\n        (proposal_.parameters.startDate, proposal_.parameters.endDate) = _validateProposalDates(\n            _startDate,\n            _endDate\n        );\n        proposal_.parameters.snapshotBlock = snapshotBlock.toUint64();\n        proposal_.parameters.votingMode = votingMode();\n        proposal_.parameters.supportThreshold = supportThreshold();\n        proposal_.parameters.minVotingPower = _applyRatioCeiled(\n            totalVotingPower_,\n            minParticipation()\n        );\n\n        // Reduce costs\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length; ) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (_voteOption != VoteOption.None) {\n            vote(proposalId, _voteOption, _tryEarlyExecution);\n        }\n    }\n\n    /// @inheritdoc IMembership\n    function isMember(address _account) external view returns (bool) {\n        /// whatever condition\n        return votingToken.getVotes(_account) > 0;\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _vote(\n        uint256 _proposalId,\n        VoteOption _voteOption,\n        address _voter,\n        bool _tryEarlyExecution\n    ) internal override {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // This could re-enter, though we can assume the governance token is not malicious\n        uint256 votingPower = votingToken.getPastVotes(_voter, proposal_.parameters.snapshotBlock);\n        VoteOption state = proposal_.voters[_voter];\n\n        // If voter had previously voted, decrease count\n        if (state == VoteOption.Yes) {\n            proposal_.tally.yes = proposal_.tally.yes - votingPower;\n        } else if (state == VoteOption.No) {\n            proposal_.tally.no = proposal_.tally.no - votingPower;\n        } else if (state == VoteOption.Abstain) {\n            proposal_.tally.abstain = proposal_.tally.abstain - votingPower;\n        }\n\n        // write the updated/new vote for the voter.\n        if (_voteOption == VoteOption.Yes) {\n            proposal_.tally.yes = proposal_.tally.yes + votingPower;\n        } else if (_voteOption == VoteOption.No) {\n            proposal_.tally.no = proposal_.tally.no + votingPower;\n        } else if (_voteOption == VoteOption.Abstain) {\n            proposal_.tally.abstain = proposal_.tally.abstain + votingPower;\n        }\n\n        proposal_.voters[_voter] = _voteOption;\n\n        emit VoteCast({\n            proposalId: _proposalId,\n            voter: _voter,\n            voteOption: _voteOption,\n            votingPower: votingPower\n        });\n\n        if (_tryEarlyExecution && _canExecute(_proposalId)) {\n            _execute(_proposalId);\n        }\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _canVote(\n        uint256 _proposalId,\n        address _account,\n        VoteOption _voteOption\n    ) internal view override returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_isProposalOpen(proposal_)) {\n            return false;\n        }\n\n        // The voter votes `None` which is not allowed.\n        if (_voteOption == VoteOption.None) {\n            return false;\n        }\n\n        // The voter has no voting power.\n        if (votingToken.getPastVotes(_account, proposal_.parameters.snapshotBlock) == 0) {\n            return false;\n        }\n\n        // The voter has already voted but vote replacment is not allowed.\n        if (\n            proposal_.voters[_account] != VoteOption.None &&\n            proposal_.parameters.votingMode != VotingMode.VoteReplacement\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[49] private __gap;\n}"
    },
    {
      "filename": "packages/contracts/src/plugins/governance/majority-voting/addresslist/AddresslistVoting.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {IDAO} from \"../../../../core/dao/IDAO.sol\";\nimport {RATIO_BASE, _applyRatioCeiled} from \"../../../utils/Ratio.sol\";\n\nimport {IMembership} from \"../../../../core/plugin/membership/IMembership.sol\";\nimport {Addresslist} from \"../../../utils/Addresslist.sol\";\nimport {IMajorityVoting} from \"../IMajorityVoting.sol\";\nimport {MajorityVotingBase} from \"../MajorityVotingBase.sol\";\n\n/// @title AddresslistVoting\n/// @author Aragon Association - 2021-2023.\n/// @notice The majority voting implementation using an list of member addresses.\n/// @dev This contract inherits from `MajorityVotingBase` and implements the `IMajorityVoting` interface.\ncontract AddresslistVoting is IMembership, Addresslist, MajorityVotingBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant ADDRESSLIST_VOTING_INTERFACE_ID =\n        this.initialize.selector ^ this.addAddresses.selector ^ this.removeAddresses.selector;\n\n    /// @notice The ID of the permission required to call the `addAddresses` and `removeAddresses` functions.\n    bytes32 public constant UPDATE_ADDRESSES_PERMISSION_ID =\n        keccak256(\"UPDATE_ADDRESSES_PERMISSION\");\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    function initialize(\n        IDAO _dao,\n        VotingSettings calldata _votingSettings,\n        address[] calldata _members\n    ) external initializer {\n        __MajorityVotingBase_init(_dao, _votingSettings);\n\n        _addAddresses(_members);\n        emit MembersAdded({members: _members});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == ADDRESSLIST_VOTING_INTERFACE_ID ||\n            _interfaceId == type(Addresslist).interfaceId ||\n            _interfaceId == type(IMembership).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Adds new members to the address list.\n    /// @param _members The addresses of members to be added.\n    /// @dev This function is used during the plugin initialization.\n    function addAddresses(\n        address[] calldata _members\n    ) external auth(UPDATE_ADDRESSES_PERMISSION_ID) {\n        _addAddresses(_members);\n\n        emit MembersAdded({members: _members});\n    }\n\n    /// @notice Removes existing members from the address list.\n    /// @param _members The addresses of the members to be removed.\n    function removeAddresses(\n        address[] calldata _members\n    ) external auth(UPDATE_ADDRESSES_PERMISSION_ID) {\n        _removeAddresses(_members);\n\n        emit MembersRemoved({members: _members});\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function totalVotingPower(uint256 _blockNumber) public view override returns (uint256) {\n        return addresslistLengthAtBlock(_blockNumber);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function createProposal(\n        bytes calldata _metadata,\n        IDAO.Action[] calldata _actions,\n        uint256 _allowFailureMap,\n        uint64 _startDate,\n        uint64 _endDate,\n        VoteOption _voteOption,\n        bool _tryEarlyExecution\n    ) external override returns (uint256 proposalId) {\n        uint64 snapshotBlock;\n        unchecked {\n            snapshotBlock = block.number.toUint64() - 1;\n        }\n\n        if (minProposerVotingPower() != 0 && !isListedAtBlock(_msgSender(), snapshotBlock)) {\n            revert ProposalCreationForbidden(_msgSender());\n        }\n\n        proposalId = _createProposal({\n            _creator: _msgSender(),\n            _metadata: _metadata,\n            _startDate: _startDate,\n            _endDate: _endDate,\n            _actions: _actions,\n            _allowFailureMap: _allowFailureMap\n        });\n\n        // Store proposal related information\n        Proposal storage proposal_ = proposals[proposalId];\n\n        (proposal_.parameters.startDate, proposal_.parameters.endDate) = _validateProposalDates({\n            _start: _startDate,\n            _end: _endDate\n        });\n        proposal_.parameters.snapshotBlock = snapshotBlock;\n        proposal_.parameters.votingMode = votingMode();\n        proposal_.parameters.supportThreshold = supportThreshold();\n        proposal_.parameters.minVotingPower = _applyRatioCeiled(\n            totalVotingPower(snapshotBlock),\n            minParticipation()\n        );\n\n        // Reduce costs\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length; ) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (_voteOption != VoteOption.None) {\n            vote(proposalId, _voteOption, _tryEarlyExecution);\n        }\n    }\n\n    /// @inheritdoc IMembership\n    function isMember(address _account) external view returns (bool) {\n        return isListed(_account);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _vote(\n        uint256 _proposalId,\n        VoteOption _voteOption,\n        address _voter,\n        bool _tryEarlyExecution\n    ) internal override {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        VoteOption state = proposal_.voters[_voter];\n\n        // Remove the previous vote.\n        if (state == VoteOption.Yes) {\n            proposal_.tally.yes = proposal_.tally.yes - 1;\n        } else if (state == VoteOption.No) {\n            proposal_.tally.no = proposal_.tally.no - 1;\n        } else if (state == VoteOption.Abstain) {\n            proposal_.tally.abstain = proposal_.tally.abstain - 1;\n        }\n\n        // Store the updated/new vote for the voter.\n        if (_voteOption == VoteOption.Yes) {\n            proposal_.tally.yes = proposal_.tally.yes + 1;\n        } else if (_voteOption == VoteOption.No) {\n            proposal_.tally.no = proposal_.tally.no + 1;\n        } else if (_voteOption == VoteOption.Abstain) {\n            proposal_.tally.abstain = proposal_.tally.abstain + 1;\n        }\n\n        proposal_.voters[_voter] = _voteOption;\n\n        emit VoteCast({\n            proposalId: _proposalId,\n            voter: _voter,\n            voteOption: _voteOption,\n            votingPower: 1\n        });\n\n        if (_tryEarlyExecution && _canExecute(_proposalId)) {\n            _execute(_proposalId);\n        }\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _canVote(\n        uint256 _proposalId,\n        address _account,\n        VoteOption _voteOption\n    ) internal view override returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_isProposalOpen(proposal_)) {\n            return false;\n        }\n\n        // The voter votes `None` which is not allowed.\n        if (_voteOption == VoteOption.None) {\n            return false;\n        }\n\n        // The voter has no voting power.\n        if (!isListedAtBlock(_account, proposal_.parameters.snapshotBlock)) {\n            return false;\n        }\n\n        // The voter has already voted but vote replacement is not allowed.\n        if (\n            proposal_.voters[_account] != VoteOption.None &&\n            proposal_.parameters.votingMode != VotingMode.VoteReplacement\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[50] private __gap;\n}"
    },
    {
      "filename": "packages/contracts/src/plugins/governance/multisig/Multisig.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {IDAO} from \"../../../core/dao/IDAO.sol\";\nimport {IMembership} from \"../../../core/plugin/membership/IMembership.sol\";\nimport {PluginUUPSUpgradeable} from \"../../../core/plugin/PluginUUPSUpgradeable.sol\";\n\nimport {ProposalUpgradeable} from \"../../../core/plugin/proposal/ProposalUpgradeable.sol\";\nimport {Addresslist} from \"../../utils/Addresslist.sol\";\nimport {IMultisig} from \"./IMultisig.sol\";\n\n/// @title Multisig\n/// @author Aragon Association - 2022-2023\n/// @notice The on-chain multisig governance plugin in which a proposal passes if X out of Y approvals are met.\ncontract Multisig is\n    IMultisig,\n    IMembership,\n    PluginUUPSUpgradeable,\n    ProposalUpgradeable,\n    Addresslist\n{\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice A container for proposal-related information.\n    /// @param executed Whether the proposal is executed or not.\n    /// @param approvals The number of approvals casted.\n    /// @param parameters The proposal-specific approve settings at the time of the proposal creation.\n    /// @param approvers The approves casted by the approvers.\n    /// @param actions The actions to be executed when the proposal passes.\n    /// @param _allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    struct Proposal {\n        bool executed;\n        uint16 approvals;\n        ProposalParameters parameters;\n        mapping(address => bool) approvers;\n        IDAO.Action[] actions;\n        uint256 allowFailureMap;\n    }\n\n    /// @notice A container for the proposal parameters.\n    /// @param minApprovals The number of approvals required.\n    /// @param snapshotBlock The number of the block prior to the proposal creation.\n    /// @param startDate The timestamp when the proposal starts.\n    /// @param endDate The timestamp when the proposal expires.\n    struct ProposalParameters {\n        uint16 minApprovals;\n        uint64 snapshotBlock;\n        uint64 startDate;\n        uint64 endDate;\n    }\n\n    /// @notice A container for the plugin settings.\n    /// @param onlyListed Whether only listed addresses can create a proposal.\n    /// @param minApprovals The minimum approvals parameter.\n    struct MultisigSettings {\n        bool onlyListed;\n        uint16 minApprovals;\n    }\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant MULTISIG_INTERFACE_ID =\n        this.initialize.selector ^\n            this.updateMultisigSettings.selector ^\n            this.createProposal.selector ^\n            this.getProposal.selector;\n\n    /// @notice The ID of the permission required to call the `addAddresses` and `removeAddresses` functions.\n    bytes32 public constant UPDATE_MULTISIG_SETTINGS_PERMISSION_ID =\n        keccak256(\"UPDATE_MULTISIG_SETTINGS_PERMISSION\");\n\n    /// @notice A mapping between proposal IDs and proposal information.\n    mapping(uint256 => Proposal) internal proposals;\n\n    /// @notice The current plugin settings.\n    MultisigSettings public multisigSettings;\n\n    /// @notice Thrown when a sender is not allowed to create a proposal.\n    /// @param sender The sender address.\n    error ProposalCreationForbidden(address sender);\n\n    /// @notice Thrown if a approver is not allowed to cast an approve. This can be because the proposal\n    /// - is not open,\n    /// - was executed, or\n    /// - the approver is not on the address list\n    /// @param proposalId The ID of the proposal.\n    /// @param sender The address of the sender.\n    error ApprovalCastForbidden(uint256 proposalId, address sender);\n\n    /// @notice Thrown if the proposal execution is forbidden.\n    /// @param proposalId The ID of the proposal.\n    error ProposalExecutionForbidden(uint256 proposalId);\n\n    /// @notice Thrown if the minimal approvals value is out of bounds (less than 1 or greater than the number of members in the address list).\n    /// @param limit The maximal value.\n    /// @param actual The actual value.\n    error MinApprovalsOutOfBounds(uint16 limit, uint16 actual);\n\n    /// @notice Thrown if the addresslist length is out of bounds.\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error AddresslistLengthOutOfBounds(uint16 limit, uint256 actual);\n\n    /// @notice Thrown if a date is out of bounds.\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error DateOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Emitted when an proposal is approve by an approver.\n    /// @param proposalId The ID of the proposal.\n    /// @param approver The approver casting the approve.\n    event Approved(uint256 indexed proposalId, address indexed approver);\n\n    /// @notice Emitted when the plugin settings are set.\n    /// @param onlyListed Whether only listed addresses can create a proposal.\n    /// @param minApprovals The minimum amount of approvals needed to pass a proposal.\n    event MultisigSettingsUpdated(bool onlyListed, uint16 indexed minApprovals);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _multisigSettings The multisig settings.\n    function initialize(\n        IDAO _dao,\n        address[] calldata _members,\n        MultisigSettings calldata _multisigSettings\n    ) external initializer {\n        __PluginUUPSUpgradeable_init(_dao);\n\n        _addAddresses(_members);\n        emit MembersAdded({members: _members});\n\n        _updateMultisigSettings(_multisigSettings);\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) public view virtual override(PluginUUPSUpgradeable, ProposalUpgradeable) returns (bool) {\n        return\n            _interfaceId == MULTISIG_INTERFACE_ID ||\n            _interfaceId == type(IMultisig).interfaceId ||\n            _interfaceId == type(Addresslist).interfaceId ||\n            _interfaceId == type(IMembership).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IMultisig\n    function addAddresses(\n        address[] calldata _members\n    ) external auth(UPDATE_MULTISIG_SETTINGS_PERMISSION_ID) {\n        uint256 newAddresslistLength = addresslistLength() + _members.length;\n\n        // Check if the new address list length would be greater than `type(uint16).max`, the maximal number of approvals.\n        if (newAddresslistLength > type(uint16).max) {\n            revert AddresslistLengthOutOfBounds({\n                limit: type(uint16).max,\n                actual: newAddresslistLength\n            });\n        }\n\n        _addAddresses(_members);\n\n        emit MembersAdded({members: _members});\n    }\n\n    /// @inheritdoc IMultisig\n    function removeAddresses(\n        address[] calldata _members\n    ) external auth(UPDATE_MULTISIG_SETTINGS_PERMISSION_ID) {\n        uint16 newAddresslistLength = uint16(addresslistLength() - _members.length);\n\n        // Check if the new address list length would become less than the current minimum number of approvals required.\n        if (newAddresslistLength < multisigSettings.minApprovals) {\n            revert MinApprovalsOutOfBounds({\n                limit: newAddresslistLength,\n                actual: multisigSettings.minApprovals\n            });\n        }\n\n        _removeAddresses(_members);\n\n        emit MembersRemoved({members: _members});\n    }\n\n    /// @notice Updates the plugin settings.\n    /// @param _multisigSettings The new settings.\n    function updateMultisigSettings(\n        MultisigSettings calldata _multisigSettings\n    ) external auth(UPDATE_MULTISIG_SETTINGS_PERMISSION_ID) {\n        _updateMultisigSettings(_multisigSettings);\n    }\n\n    /// @notice Creates a new majority voting proposal.\n    /// @param _metadata The metadata of the proposal.\n    /// @param _actions The actions that will be executed after the proposal passes.\n    /// @param _allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @param _approveProposal If `true`, the sender will approve the proposal.\n    /// @param _tryExecution If `true`, execution is tried after the vote cast. The call does not revert if early execution is not possible.\n    /// @return proposalId The ID of the proposal.\n    function createProposal(\n        bytes calldata _metadata,\n        IDAO.Action[] calldata _actions,\n        uint256 _allowFailureMap,\n        bool _approveProposal,\n        bool _tryExecution,\n        uint64 _startDate,\n        uint64 _endDate\n    ) external returns (uint256 proposalId) {\n        uint64 snapshotBlock = block.number.toUint64() - 1;\n\n        if (multisigSettings.onlyListed && !isListedAtBlock(_msgSender(), snapshotBlock)) {\n            revert ProposalCreationForbidden(_msgSender());\n        }\n\n        if (_startDate == 0) {\n            _startDate = block.timestamp.toUint64();\n        } else if (_startDate < block.timestamp.toUint64()) {\n            revert DateOutOfBounds({limit: block.timestamp.toUint64(), actual: _startDate});\n        }\n\n        if (_endDate < _startDate) {\n            revert DateOutOfBounds({limit: _startDate, actual: _endDate});\n        }\n\n        proposalId = _createProposal({\n            _creator: _msgSender(),\n            _metadata: _metadata,\n            _startDate: _startDate,\n            _endDate: _endDate,\n            _actions: _actions,\n            _allowFailureMap: _allowFailureMap\n        });\n\n        // Create the proposal\n        Proposal storage proposal_ = proposals[proposalId];\n\n        proposal_.parameters.snapshotBlock = snapshotBlock;\n        proposal_.parameters.startDate = _startDate;\n        proposal_.parameters.endDate = _endDate;\n        proposal_.parameters.minApprovals = multisigSettings.minApprovals;\n\n        // Reduce costs\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length; ) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (_approveProposal) {\n            approve(proposalId, _tryExecution);\n        }\n    }\n\n    /// @inheritdoc IMultisig\n    function approve(uint256 _proposalId, bool _tryExecution) public {\n        address approver = _msgSender();\n        if (!_canApprove(_proposalId, approver)) {\n            revert ApprovalCastForbidden(_proposalId, approver);\n        }\n\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // As the list can never become more than type(uint16).max(due to addAddresses check)\n        // It's safe to use unchecked as it would never overflow.\n        unchecked {\n            proposal_.approvals += 1;\n        }\n\n        proposal_.approvers[approver] = true;\n\n        emit Approved({proposalId: _proposalId, approver: approver});\n\n        if (_tryExecution && _canExecute(_proposalId)) {\n            _execute(_proposalId);\n        }\n    }\n\n    /// @inheritdoc IMultisig\n    function canApprove(uint256 _proposalId, address _account) external view returns (bool) {\n        return _canApprove(_proposalId, _account);\n    }\n\n    /// @inheritdoc IMultisig\n    function canExecute(uint256 _proposalId) external view returns (bool) {\n        return _canExecute(_proposalId);\n    }\n\n    /// @notice Returns all information for a proposal vote by its ID.\n    /// @param _proposalId The ID of the proposal.\n    /// @return executed Whether the proposal is executed or not.\n    /// @return approvals The number of approvals casted.\n    /// @return parameters The parameters of the proposal vote.\n    /// @return actions The actions to be executed in the associated DAO after the proposal has passed.\n    /// @param allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    function getProposal(\n        uint256 _proposalId\n    )\n        public\n        view\n        returns (\n            bool executed,\n            uint16 approvals,\n            ProposalParameters memory parameters,\n            IDAO.Action[] memory actions,\n            uint256 allowFailureMap\n        )\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        executed = proposal_.executed;\n        approvals = proposal_.approvals;\n        parameters = proposal_.parameters;\n        actions = proposal_.actions;\n        allowFailureMap = proposal_.allowFailureMap;\n    }\n\n    /// @inheritdoc IMultisig\n    function hasApproved(uint256 _proposalId, address _account) public view returns (bool) {\n        return proposals[_proposalId].approvers[_account];\n    }\n\n    /// @inheritdoc IMultisig\n    function execute(uint256 _proposalId) public {\n        if (!_canExecute(_proposalId)) {\n            revert ProposalExecutionForbidden(_proposalId);\n        }\n\n        _execute(_proposalId);\n    }\n\n    /// @inheritdoc IMembership\n    function isMember(address _account) external view returns (bool) {\n        return isListed(_account);\n    }\n\n    /// @notice Internal function to execute a vote. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    function _execute(uint256 _proposalId) internal {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        proposal_.executed = true;\n\n        _executeProposal(\n            dao(),\n            _proposalId,\n            proposals[_proposalId].actions,\n            proposals[_proposalId].allowFailureMap\n        );\n    }\n\n    /// @notice Internal function to check if an account can approve. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    /// @param _account The account to check.\n    /// @return Returns `true` if the given account can approve on a certain proposal and `false` otherwise.\n    function _canApprove(uint256 _proposalId, address _account) internal view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        if (!_isProposalOpen(proposal_)) {\n            // The proposal was executed already\n            return false;\n        }\n\n        if (!isListedAtBlock(_account, proposal_.parameters.snapshotBlock)) {\n            // The approver has no voting power.\n            return false;\n        }\n\n        if (proposal_.approvers[_account]) {\n            // The approver has already approved\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Internal function to check if a proposal can be executed. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if the proposal can be executed and `false` otherwise.\n    function _canExecute(uint256 _proposalId) internal view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // Verify that the proposal has not been executed or expired.\n        if ("
    }
  ]
}