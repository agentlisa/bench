{
  "Title": "[M-18] Discrepancy in Default Account Behavior",
  "Content": "\nReverts in default account fallback function (when custom accounts delegate calls to a default account) may introduce security risks as protocols might not anticipate these reverts, resulting in vulnerabilities.\n\n### Proof of Concept\n\nAs stated in the documentation regarding the `DefaultAccount`:\n\n> The main purpose of this contract is to provide EOA-like experience for both wallet users and contracts that call it, i.e. it should not be distinguishable (apart of spent gas) from EOA accounts on Ethereum.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/System%20contracts%20bootloader%20description.md#defaultaccount>\n\nTo achieve this EOA-like behavior, the fallback and receive functions of the `DefaultAccount` contract are designed in such a way that, when called or delegate-called, they mimic the actions of an EOA:\n\n```solidity\nfallback() external payable {\n    // The fallback function of the default account should never be called by the bootloader\n    assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS);\n\n    // If the contract is called directly, it should behave like an EOA.\n}\n\nreceive() external payable {\n    // If the contract is called directly, it should behave like an EOA.\n}\n```\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/DefaultAccount.sol#L222-L231>\n\nHowever, there's an exception to this EOA-like behavior when **a custom account delegate-calls a default account**. Suppose the custom account execution function is implemented as follows:\n\n```solidity\nfunction _execute(Transaction calldata _transaction) internal {\n    address to = address(uint160(_transaction.to));\n    (bool success,) = address(to).delegatecall(\"0x1234\");\n    require(success, \"call was not successful\");\n}\n```\n\nIn this scenario, if the `to` address is a default account, the fallback function of the default account will be invoked. Since the `msg.sender` is the bootloader address, it will trigger a revert due to `assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS)` and `success` will be `false`. This is not the expected behavior, as `to` should act like an EOA and `success` should be true.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/DefaultAccount.sol#L224>\n\nThis situation can potentially pose a significant issue for several reasons:\n\n1. Due to the unpredictability of custom account implementations, any assertion claiming that custom accounts will not delegate calls to a default account lacks a solid foundation.\n2. ZkSync Era has explicitly stated that default accounts should not be distinguishable (apart of spent gas) from EOA accounts on Ethereum. Protocols and custom accounts deployed on ZkSync Era are likely to rely on this statement, believing that they will observe consistent behavior. In practice, they might encounter different behavior, which could lead to unexpected consequences.\n\n### Recommended Mitigation Steps\n\nOne potential solution is to add modifier `ignoreInDelegateCall` to the fallback function as well:\n\n```solidity\n    fallback() external payable ignoreInDelegateCall {\n        assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS);\n    }\n```\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/168#issuecomment-1794964537):**\n > It is showing that default account is not purely simulating EOA. So, medium is fair.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/168#issuecomment-1829775920):**\n > The Warden has shown an edge case for Default Accounts, due to this being a discrepancy in intended behaviour, Medium Severity seems most appropriate.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "docs/Smart%20contract%20Section/System%20contracts%20bootloader%20description.md",
      "content": "# System contracts/bootloader description (VM v1.4.0)\n\n## Bootloader\n\nOn standard Ethereum clients, the workflow for executing blocks is the following:\n\n1. Pick a transaction, validate the transactions & charge the fee, execute it\n2. Gather the state changes (if the transaction has not reverted), apply them to the state.\n3. Go back to step (1) if the block gas limit has not been yet exceeded.\n\nHowever, having such flow on zkSync (i.e. processing transaction one-by-one) would be too inefficient, since we have to run the entire proving workflow for each individual transaction. That’s what we need the *bootloader* for: instead of running N transactions separately, we run the entire batch (set of blocks, more can be found [here](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Batches%20%26%20L2%20blocks%20on%20zkSync.md)) as a single program that accepts the array of transactions as well as some other batch metadata and processes them inside a single big “transaction”. The easiest way to think about bootloader is to think in terms of EntryPoint from EIP4337: it also accepts the array of transactions and facilitates the Account Abstraction protocol.\n\nThe hash of the code of the bootloader is stored on L1 and can only be changed as a part of a system upgrade. Note, that unlike system contracts, the bootloader’s code is not stored anywhere on L2. That’s why we may sometimes refer to the bootloader’s address as formal. It only exists for the sake of providing some value to `this` / `msg.sender`/etc. When someone calls the bootloader address (e.g. to pay fees) the EmptyContract’s code is actually invoked.\n\n## System contracts\n\nWhile most of the primitive EVM opcodes can be supported out of the box (i.e. zero-value calls, addition/multiplication/memory/storage management, etc), some of the opcodes are not supported by the VM by default and they are implemented via “system contracts” — these contracts are located in a special *kernel space,* i.e. in the address space in range `[0..2^16-1]`, and they have some special privileges, which users’ contracts don’t have. These contracts are pre-deployed at the genesis and updating their code can be done only via system upgrade, managed from L1.\n\nThe use of each system contract will be explained down below.\n\n# zkEVM internals\n\nFull specification of the zkEVM is beyond the scope of this document. However, this section will give you most of the details needed for understanding the L2 system smart contracts & basic differences between EVM and zkEVM.\n\n## Registers and memory management\n\nOn EVM, during transaction execution, the following memory areas are available:\n\n- `memory` itself.\n- `calldata` the immutable slice of parent memory.\n- `returndata` the immutable slice returned by the latest call to another contract.\n- `stack` where the local variables are stored.\n\nUnlike EVM, which is stack machine, zkEVM has 16 registers. Instead of receiving input from `calldata`, zkEVM starts by receiving a *pointer* in its first register *(*basically a packed struct with 4 elements: the memory page id, start and length of the slice to which it points to*)* to the calldata page of the parent. Similarly, a transaction can receive some other additional data within its registers at the start of the program: whether the transaction should invoke the constructor ([more about deployments here](#contractdeployer--immutablesimulator)), whether the transaction has `isSystem` flag, etc. The meaning of each of these flags will be expanded further in this section.\n\n*Pointers* are separate type in the VM. It is only possible to:\n\n- Read some value within a pointer.\n- Shrink the pointer by reducing the slice to which pointer points to.\n- Receive the pointer to the returndata/as a calldata.\n- Pointers can be stored only on stack/registers to make sure that the other contracts can not read memory/returndata of contracts they are not supposed to.\n- A pointer can be converted to the u256 integer representing it, but an integer can not be converted to a pointer to prevent unallowed memory access.\n- It is not possible to return a pointer that points to a memory page with id smaller than the one for the current page. What this means is that it is only possible to `return` only pointer to the memory of the current frame or one of the pointers returned by the subcalls of the current frame.\n\n### Memory areas in zkEVM\n\nFor each frame, the following memory areas are allocated:\n\n- *Heap* (plays the same role as `memory` on Ethereum).\n- *AuxHeap* (auxiliary heap). It has the same properties as Heap, but it is used for the compiler to encode calldata/copy the returndata from the calls to system contracts to not interfere with the standard Solidity memory alignment.\n- *Stack*. Unlike Ethereum, stack is not the primary place to get arguments for opcodes. The biggest difference between stack on zkEVM and EVM is that on zkSync stack can be accessed at any location (just like memory). While users do not pay for the growth of stack, the stack can be fully cleared at the end of the frame, so the overhead is minimal.\n- *Code*. The memory area from which the VM executes the code of the contract. The contract itself can not read the code page, it is only done implicitly by the VM.\n\nAlso, as mentioned in the previous section, the contract receives the pointer to the calldata.\n\n### Managing returndata & calldata\n\nWhenever a contract finishes its execution, the parent’s frame receives a *pointer* as `returndata`. This pointer may point to the child frame’s Heap/AuxHeap or it can even be the same `returndata` pointer that the child frame received from some of its child frames.\n\nThe same goes with the `calldata`. Whenever a contract starts its execution, it receives the pointer to the calldata. The parent frame can provide any valid pointer as the calldata, which means it can either be a pointer to the slice of parent’s frame memory (heap or auxHeap) or it can be some valid pointer that the parent frame has received before as calldata/returndata.\n\nContracts simply remember the calldata pointer at the start of the execution frame (it is by design of the compiler) and remembers the latest received returndata pointer.\n\nSome important implications of this is that it is now possible to do the following calls without any memory copying:\n\nA → B → C\n\nwhere C receives a slice of the calldata received by B.\n\nThe same goes for returning data:\n\nA ← B ← C\n\nThere is no need to copy returned data if the B returns a slice of the returndata returned by C.\n\nNote, that you can *not* use the pointer that you received via calldata as returndata (i.e. return it at the end of the execution frame). Otherwise, it would be possible that returndata points to the memory slice of the active frame and allow editing the `returndata`. It means that in the examples above, C could not return a slice of its calldata without memory copying.\n\nSome of these memory optimizations can be seen utilized in the [EfficientCall](https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/libraries/EfficientCall.sol) library that allows to perform a call while reusing the slice of calldata that the frame already has, without memory copying.\n\n### Returndata & precompiles\n\nSome of the operations which are opcodes on Ethereum, have become calls to some of the system contracts. The most notable examples are `Keccak256`, `SystemContext`, etc. Note, that, if done naively, the following lines of code would work differently on zkSync and Ethereum:\n\n```solidity\npop(call(...))\nkeccak(...)\nreturndatacopy(...)\n```\n\nSince the call to keccak precompile would modify the `returndata`. To avoid this, our compiler does not override the latest `returndata` pointer after calls to such opcode-like precompiles.\n\n## zkSync specific opcodes\n\nWhile some Ethereum opcodes are not supported out of the box, some of the new opcodes were added to facilitate the development of the system contracts.\n\nNote, that this lists does not aim to be specific about the internals, but rather explain methods in the [SystemContractHelper.sol](https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/libraries/SystemContractHelper.sol)\n\n### **Only for kernel space**\n\nThese opcodes are allowed only for contracts in kernel space (i.e. system contracts). If executed in other places they result in `revert(0,0)`.\n\n- `mimic_call`. The same as a normal `call`, but it can alter the `msg.sender` field of the transaction.\n- `to_l1`. Sends a system L2→L1 log to Ethereum. The structure of this log can be seen [here](https://github.com/code-423n4/2023-10-zksync/blob/ef99273a8fdb19f5912ca38ba46d6bd02071363d/code/contracts/ethereum/contracts/zksync/Storage.sol#L47).\n- `event`. Emits an L2 log to zkSync. Note, that L2 logs are not equivalent to Ethereum events. Each L2 log can emit 64 bytes of data (the actual size is 88 bytes, because it includes the emitter address, etc). A single Ethereum event is represented with multiple `event` logs constitute. This opcode is only used by `EventWriter` system contract.\n- `precompile_call`. This is an opcode that accepts two parameters: the uint256 representing the packed parameters for it as well as the ergs to burn. Besides the price for the precompile call itself, it burns the provided ergs and executes the precompile. The action that it does depend on `this` during execution:\n    - If it is the address of the `ecrecover` system contract, it performs the ecrecover operation\n    - If it is the address of the `sha256`/`keccak256` system contracts, it performs the corresponding hashing operation.\n    - It does nothing (i.e. just burns ergs) otherwise. It can be used to burn ergs needed for L2→L1 communication or publication of bytecodes onchain.\n- `setValueForNextFarCall` sets `msg.value` for the next `call`/`mimic_call`. Note, that it does not mean that the value will be really transferred. It just sets the corresponding `msg.value` context variable. The transferring of ETH should be done via other means by the system contract that uses this parameter. Note, that this method has no effect on `delegatecall` , since `delegatecall` inherits the `msg.value` of the previous frame.\n- `increment_tx_counter` increments the counter of the transactions within the VM. The transaction counter used mostly for the VM’s internal tracking of events. Used only in bootloader after the end of each transaction.\n\nNote, that currently we do not have access to the `tx_counter` within VM (i.e. for now it is possible to increment it and it will be automatically used for logs such as `event`s as well as system logs produced by `to_l1`, but we can not read it). We need to read it to publish the *user* L2→L1 logs, so `increment_tx_counter` is always accompanied by the corresponding call to the [SystemContext](#systemcontext) contract.\n\nMore on the difference between system and user logs can be read [here](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Handling%20pubdata%20in%20Boojum.md). - `set_pubdata_price` sets the price (in gas) for publishing a single byte of pubdata.\n\n### **Generally accessible**\n\nHere are opcodes that can be generally accessed by any contract. Note that while the VM allows to access these methods, it does not mean that this is easy: the compiler might not have convenient support for some use-cases yet.\n\n- `near_call`. It is basically a “framed” jump to some location of the code of your contract. The difference between the `near_call` and ordinary jump are:\n    1. It is possible to provide an ergsLimit for it. Note, that unlike “`far_call`”s (i.e. calls between contracts) the 63/64 rule does not apply to them.\n    2. If the near call frame panics, all state changes made by it are reversed. Please note, that the memory changes will **not** be reverted.\n- `getMeta`. Returns an u256 packed value of [ZkSyncMeta](https://github.com/code-423n4/2023-10-zksync/blob/ef99273a8fdb19f5912ca38ba46d6bd02071363d/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L42) struct. Note that this is not tight packing. The struct is formed by the [following rust code](https://github.com/matter-labs/era-zkevm_opcode_defs/blob/c7ab62f4c60b27dfc690c3ab3efb5fff1ded1a25/src/definitions/abi/meta.rs#L4).\n- `getCodeAddress` — receives the address of the executed code. This is different from `this` , since in case of delegatecalls `this` is preserved, but `codeAddress` is not.\n\n### Flags for calls\n\nBesides the calldata, it is also possible to provide additional information to the callee when doing `call` , `mimic_call`, `delegate_call`. The called contract will receive the following information in its first 12 registers at the start of execution:\n\n- *r1* — the pointer to the calldata.\n- *r2* — the pointer with flags of the call. This is a mask, where each bit is set only if certain flags have been set to the call. Currently, two flags are supported: 0-th bit: `isConstructor` flag. This flag can only be set by system contracts and denotes whether the account should execute its constructor logic. Note, unlike Ethereum, there is no separation on constructor & deployment bytecode. More on that can be read [here](#contractdeployer--immutablesimulator). 1-st bit: `isSystem` flag. Whether the call intends a system contracts’ function. While most of the system contracts’ functions are relatively harmless, accessing some with calldata only may break the invariants of Ethereum, e.g. if the system contract uses `mimic_call`: no one expects that by calling a contract some operations may be done out of the name of the caller. This flag can be only set if the callee is in kernel space.\n- The rest r3..r12 registers are non-empty only if the `isSystem` flag is set. There may be arbitrary values passed, which we call `extraAbiParams`.\n\nThe compiler implementation is that these flags are remembered by the contract and can be accessed later during execution via special [simulations](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/VM%20Section/How%20compiler%20works/instructions/extensions/overview.md).\n\nIf the caller provides inappropriate flags (i.e. tries to set `isSystem` flag when callee is not in the kernel space), the flags are ignored.\n\n### `onlySystemCall` modifier\n\nSome of the system contracts can act on behalf of the user or have a very important impact on the behavior of the account. That’s why we wanted to make it clear that users can not invoke potentially dangerous operations by doing a simple EVM-like `call`. Whenever a user wants to invoke some of the operations which we considered dangerous, they must provide “`isSystem`” flag with them.\n\nThe `onlySystemCall` flag checks that the call was either done with the “isSystemCall” flag provided or the call is done by another system contract (since Matter Labs is fully aware of system contracts).\n\n### Simulations via our compiler\n\nIn the future, we plan to introduce our “extended” version of Solidity with more supported opcodes than the original one. However, right now it was beyond the capacity of the team to do, so in order to represent accessing zkSync-specific opcodes, we use `call` opcode with certain constant parameters that will be automatically replaced by the compiler with zkEVM native opcode.\n\nExample:\n\n```solidity\nfunction getCodeAddress() internal view returns (address addr) {\n    address callAddr = CODE_ADDRESS_CALL_ADDRESS;\n    assembly {\n        addr := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n    }\n}\n```\n\nIn the example above, the compiler will detect that the static call is done to the constant `CODE_ADDRESS_CALL_ADDRESS` and so it will replace it with the opcode for getting the code address of the current execution.\n\nFull list of opcode simulations can be found [here](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/VM%20Section/How%20compiler%20works/instructions/extensions/call.md).\n\nWe also use [verbatim-like](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/VM%20Section/How%20compiler%20works/instructions/extensions/verbatim.md) statements to access zkSync-specific opcodes in the bootloader.\n\nAll the usages of the simulations in our Solidity code are implemented in the [SystemContractHelper](https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/libraries/SystemContractHelper.sol) library and the [SystemContractsCaller](https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/libraries/SystemContractsCaller.sol) library.\n\n**Simulating** `near_call` **(in Yul only)**\n\nIn order to use `near_call` i.e. to call a local function, while providing a limit of ergs (gas) that this function can use, the following syntax is used:\n\nThe function should contain `ZKSYNC_NEAR_CALL` string in its name and accept at least 1 input parameter. The first input parameter is the packed ABI of the `near_call`. Currently, it is equal to the number of ergs to be passed with the `near_call`.\n\nWhenever a `near_call` panics, the `ZKSYNC_CATCH_NEAR_CALL` function is called.\n\n*Important note:* the compiler behaves in a way that if there is a `revert` in the bootloader, the `ZKSYNC_CATCH_NEAR_CALL` is not called and the parent frame is reverted as well. The only way to revert only the `near_call` frame is to trigger VM’s *panic* (it can be triggered with either invalid opcode or out of gas error).\n\n*Important note 2:* The 63/64 rule does not apply to `near_call`. Also, if 0 gas is provided to the near call, then actually all of the available gas will go to it.\n\n**Notes on security**\n\nTo prevent unintended substitution, the compiler requires `--system-mode` flag to be passed during compilation for the above substitutions to work.\n\n## Bytecode hashes\n\nOn zkSync the bytecode hashes are stored in the following format:\n\n- The 0th byte denotes the version of the format. Currently the only version that is used is “1”.\n- The 1st byte is `0` for deployed contracts’ code and `1` for the contract code [that is being constructed](#constructing-vs-non-constructing-code-hash).\n- The 2nd and 3rd bytes denote the length of the contract in 32-byte words as big-endian 2-byte number.\n- The next 28 bytes are the last 28 bytes of the sha256 hash of the contract’s bytecode.\n\nThe bytes are ordered in little-endian order (i.e. the same way as for `bytes32` ).\n\n### Bytecode validity\n\nA bytecode is valid if it:\n\n- Has its length in bytes divisible by 32 (i.e. consists of an integer number of 32-byte words).\n- Has a length of less than 2^16 words (i.e. its length in words fits into 2 bytes).\n- Has an odd length in words (i.e. the 3rd byte is an odd number).\n\nNote, that it does not have to consist of only correct opcodes. In case the VM encounters an invalid opcode, it will simply revert (similar to how EVM would treat them).\n\nA call to a contract with invalid bytecode can not be proven. That is why it is **essential** that no contract with invalid bytecode is ever deployed on zkSync. It is the job of the [KnownCodesStorage](#knowncodestorage) to ensure that all allowed bytecodes in the system are valid.\n\n# Account abstraction\n\nOne of the other important features of zkSync is the support of account abstraction. It is highly recommended to read the documentation on our AA protocol here: [https://era.zksync.io/docs/reference/concepts/account-abstraction.html#introduction](https://era.zksync.io/docs/reference/concepts/account-abstraction.html#introduction)\n\n### Account versioning\n\nEach account can also specify which version of the account abstraction protocol do they support. This is needed to allow breaking changes of the protocol in the future.\n\nCurrently, two versions are supported: `None` (i.e. it is a simple contract and it should never be used as `from` field of a transaction), and `Version1`.\n\n### Nonce ordering\n\nAccounts can also signal to the operator which nonce ordering it should expect from these accounts: `Sequential` or `Arbitrary`.\n\n`Sequential` means that the nonces should be ordered in the same way as in EOAs. This means, that, for instance, the operator will always wait for a transaction with nonce `X` before processing a transaction with nonce `X+1`.\n\n`Arbitrary` means that the nonces can be ordered in arbitrary order. It is supported by the server right now, i.e. if there is a contract with arbitrary nonce ordering, its transactions will likely either be rejected or get stuck in the mempool due to nonce mismatch.\n\nNote, that this is not enforced by system contracts in any way. Some sanity checks may be present, but the accounts are allowed to do however they like. It is more of a suggestion to the operator on how to manage the mempool.\n\n### Returned magic value\n\nNow, both accounts and paymasters are required to return a certain magic value upon validation. This magic value will be enforced to be correct on the mainnet, but will be ignored during fee estimation. Unlike Ethereum, the signature verification + fee charging/nonce increment are not included as part of the intrinsic costs of the transaction. These are paid as part of the execution and so they need to be estimated as part of the estimation for the transaction’s costs.\n\nGenerally, the accounts are recommended to perform as many operations as during normal validation, but only return the invalid magic in the end of the validation. This will allow to correctly (or at least as correctly as possible) estimate the price for the validation of the account.\n\n# Bootloader\n\nBootloader is the program that accepts an array of transactions and executes the entire zkSync batch. This section will expand on its invariants and methods.\n\n## Playground bootloader vs proved bootloader\n\nFor convenience, we use the same implementation of the bootloader both in the mainnet batches and for emulating ethCalls or other testing activities. *Only* *proved* bootloader is ever used for batch-building and thus this document describes only it.\n\n## Start of the batch\n\nIt is enforced by the ZKPs, that the state of the bootloader is equivalent to the state of a contract transaction with empty calldata. The only difference is that it starts with all the possible memory pre-allocated (to avoid costs for memory expansion).\n\nFor additional efficiency (and our convenience), the bootloader receives its parameters inside its memory. This is the only point of non-determinism: the bootloader *starts with its memory pre-filled with any data the operator wants*. That’s why it is responsible for validating the correctness of it and it should never rely on the initial contents of the memory to be correct & valid.\n\nFor instance, for each transaction, we check that it is [properly ABI-encoded](https://github.com/code-423n4/2023-10-zksync/blob/ef99273a8fdb19f5912ca38ba46d6bd02071363d/code/system-contracts/bootloader/bootloader.yul#L3058) and that the transactions [go exactly one after another](https://github.com/code-423n4/2023-10-zksync/blob/ef99273a8fdb19f5912ca38ba46d6bd02071363d/code/system-contracts/bootloader/bootloader.yul#L3736). We also ensure that transactions do not exceed the limits of the memory space allowed for transactions.\n\n## Transaction types & their validation\n\nWhile the main transaction format is the internal `Transaction` [format](https://github.com/code-423n4/2023-10-zksync/blob/ef99273a8fdb19f5912ca38ba46d6bd02071363d/code/system-contracts/contracts/libraries/TransactionHelper.sol#L25), it is a struct that is used to represent various kinds of transactions types. It contains a lot of `reserved` fields that could be used depending in the future types of transactions without need for AA to change the interfaces of their contracts.\n\nThe exact type of the transaction is marked by the `txType` field of the transaction type. There are 6 types currently supported:\n\n- `txType`: 0. It means that this transaction is of legacy transaction type. The following restrictions are enforced:\n- `maxFeePerErgs=getMaxPriorityFeePerErg` since it is pre-EIP1559 tx type.\n- `reserved1..reserved4` as well as `paymaster` are 0. `paymasterInput` is zero.\n- Note, that unlike type 1 and type 2 transactions, `reserved0` field can be set to a non-zero value, denoting that this legacy transaction is EIP-155-compatible and its RLP encoding (as well as signature) should contain the `chainId` of the system.\n- `txType`: 1. It means that the transaction is of type 1, i.e. transactions access list. zkSync does not support access lists in any way, so no benefits of fulfilling this list will be provided. The access list is assumed to be empty. The same restrictions as for type 0 are enforced, but also `reserved0` must be 0.\n- `txType`: 2. It is EIP1559 transactions. The same restrictions as for type 1 apply, but now `maxFeePerErgs` may not be equal to `getMaxPriorityFeePerErg`.\n- `txType`: 113. It is zkSync transaction type. This transaction type is intended for AA support. The only restriction that applies to this transaction type: fields `reserved0..reserved4` must be equal to 0.\n- `txType`: 254. It is a transaction type that is used for upgrading the L2 system. This is the only type of transaction is allowed to start a transaction out of the name of the contracts in kernel space.\n- `txType`: 255. It is a transaction that comes from L1. There are almost no restrictions explicitly imposed upon this type of transaction, since the bootloader at the end of its execution sends the rolling hash of the executed priority transactions. The L1 contract ensures that the hash did indeed match the [hashes of the priority transactions on L1](https://github.com/code-423n4/2023-10-zksync/blob/ef99273a8fdb19f5912ca38ba46d6bd02071363d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L282).\n\nYou can also read more on L1->L2 transactions and upgrade transacitons [here](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Handling%20L1%E2%86%92L2%20ops%20on%20zkSync.md).\n\nHowever, as already stated, the bootloader’s memory is not deterministic and the operator is free to put anything it wants there. For all of the transaction types above the restrictions are imposed in the following ([method](https://github.com/code-423n4/2023-10-zksync/blob/ef99273a8fdb19f5912ca38ba46d6bd02071363d/code/system-contracts/bootloader/bootloader.yul#L2828)), which is called before starting processing the transaction.\n\n## Structure of the bootloader’s memory\n\nThe bootloader expects the following structure of the memory (here by word we denote 32-bytes, the same machine word as on EVM):\n\n### **Batch information**\n\nThe first 8 words are reserved for the batch information provided by the operator.\n\n- `0` word — the address of the operator (the beneficiary of the transactions).\n- `1` word — the hash of the previous batch. Its validation will be explained later on.\n- `2` word — the timestamp of the current batch. Its validation will be explained later on.\n- `3` word — the number of the new batch.\n- `4` word — the L1 gas price provided by the operator.\n- `5` word — the “fair” price for L2 gas, i.e. the price below which the `baseFee` of the batch should not fall. For now, it is provided by the operator, but it in the future it may become hardcoded.\n- `6` word — the base fee for the batch that is expected by the operator. While the base fee is deterministic, it is still provided to the bootloader just to make sure that the data that the operator has coincides with the data provided by the bootloader.\n- `7` word — reserved word. Unused on proved batch.\n\nThe batch information slots [are used at the beginning of the batch](https://github.com/code-423n4/2023-10-zksync/blob/ef99273a8fdb19f5912ca38ba46d6bd02071363d/code/system-contracts/bootloader/bootloader.yul#L3629). Once read, these slots can be used for temporary data.\n\n### **Temporary data for debug & transaction processing purposes**\n\n- `[8..39]` – reserved slots for debugging purposes\n- `[40..72]` – slots for holding the paymaster context data for the current transaction. The role of the paymaster context is similar to the [EIP4337](https://eips.ethereum.org/EIPS/eip-4337)’s one. You can read more about it in the account abstraction documentation.\n- `[73..74]` – slots for signed and explorer transaction hash of the currently processed L2 transaction.\n- `[75..110]` – 36 slots for the calldata for the KnownCodesContract call.\n- `[111..1134]` – 1024 slots for the refunds for the transactions.\n- `[1135..2158]` – 1024 slots for the overhead for batch for the transactions. This overhead is suggested by the operator, i.e. the bootloader will still double-check that the operator does not overcharge the user.\n- `[2159..3182]` – slots for the “trusted” gas limits by the operator. The user’s transaction will have at its disposal `min(MAX_TX_GAS(), trustedGasLimit)`, where `MAX_TX_GAS` is a constant guaranteed by the system. Currently, it is equal to 80 million gas. In the future, this feature will be removed. \n- `[3183..7282]` – slots for storing L2 block info for each transaction. You can read more on the difference L2 blocks and batches [here](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Batches%20&%20L2%20blocks%20on%20zkSync.md).\n- `[7283..40050]` – slots used for compressed bytecodes each in the following format:\n    - 32 bytecode hash\n    - 32 zeroes (but then it will be modified by the bootloader to contain 28 zeroes and then the 4-byte selector of the `publishCompressedBytecode` function of the `BytecodeCompresor`)\n    - The calldata to the bytecode compressor (without the selector). \n- `[40051..40052]` – slots where the hash and the number of current priority ops is stored. More on it in the priority operations [section](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Handling%20L1%E2%86%92L2%20ops%20on%20zkSync.md).\n\n### L1Messenger Pubdata\n\n- `[40053..248052]` – slots where the final batch pubdata is supplied to be verified by the L1Messenger. More on how the L1Messenger system contracts handles the pubdata can be read [here](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Handling%20pubdata%20in%20Boojum.md).\n\nBut briefly, this space is used for the calldata to the L1Messenger’s `publishPubdataAndClearState` function, which accepts the list of the user L2→L1 logs, published L2→L1 messages as well as bytecodes. It also takes the list of full state diff entries, which describe how each storage slot has changed as well as compressed state diffs. This method will then check the correctness of the provided data and publish the hash of the correct pubdata to L1.\n\nNote, that while the realistic number of pubdata that can be published in a batch is 120kb, the size of the calldata to L1Messenger may be a lot larger due to the fact that this method also accepts the original uncompressed state diff entries. These will not be published to L1, but will be used to verify the correctness of the compression. The worst-case number of bytes that may be needed for this scratch space is if all the pubdata consists of repeated writes (i.e. we’ll need only 4 bytes to include key) that turn into 0 (i.e. they’ll need only 1 byte to describe it). However, each of these writes in the uncompressed form will be represented as 272 byte state diff entry and so we get the number of diffs is `120k / 5 = 24k`. This means that they will have\naccoomdate `24k * 272 = 6528000` bytes of calldata for the uncompressed state diffs. Adding 120k on top leaves us with roughly `6650000` bytes needed for calldata. `207813` slots are needed to accomodate this amount of data.\nWe round up to `208000` slots to give space for constant-size factors for ABI-encoding, like offsets, lengths, etc.\n\nIn theory though much more calldata could be used (if for instance 1 byte is used for enum index). It is the responsibility of the operator to ensure that it can form the correct calldata for the L1Messenger.\n\n### **Transaction’s meta descriptions**\n\n- `[248053..250100]` words — 2048 slots for 1024 transaction’s meta descriptions (their structure is explained below).\n\nFor internal reasons related to possible future integrations of zero-knowledge proofs about some of the contents of the bootloader’s memory, the array of the transactions is not passed as the ABI-encoding of the array of transactions, but:\n\n- We have a constant maximum number of transactions. At the time of this writing, this number is 1024.\n- Then, we have 1024 transaction descriptions, each ABI encoded as the following struct:\n\n```solidity\nstruct Boot"
    }
  ]
}