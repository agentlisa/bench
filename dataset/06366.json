{
  "Title": "[M-10] Incorrect Reward Distribution Calculation in `ProtocolRewardsPool`",
  "Content": "\nThis report highlights a vulnerability in the `ProtocolRewardsPool` contract. The `getReward()` function, designed to distribute rewards to users, uses an incorrect calculation method that can result in incorrect reward distribution.\n\nIn the `ProtocolRewardsPool` contract, a user can call the `getReward()` function to receive the rewards. The function first tries to pay the reward using `eUSD` token, and if a sufficient amount of tokens are not available, it will use `peUSD`, and `stableToken` in the next steps. However, the protocol compares the number of shares with the amount of reward to send the reward.  If one share corresponds to a value greater than 1 `eUSD`, which is typically the case, users can be overpaid when claiming rewards. This can result in a significant discrepancy between the actual reward amount and the amount distributed.\n\n### Proof of Concept\n\nWhen a user invokes the `ProtocolRewardsPool.getReward()` function, the contract attempts to distribute the rewards using the `EUSD` token:\n\n[ProtocolRewardsPool.sol#L190-L218](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L190-L218)\n\n```solidity\nfunction getReward() external updateReward(msg.sender) {\n    uint reward = rewards[msg.sender];\n    if (reward > 0) {\n        rewards[msg.sender] = 0;\n        IEUSD EUSD = IEUSD(configurator.getEUSDAddress());\n        uint256 balance = EUSD.sharesOf(address(this));\n        uint256 eUSDShare = balance >= reward ? reward : reward - balance;\n        EUSD.transferShares(msg.sender, eUSDShare);\n        if (reward > eUSDShare) {\n            ERC20 peUSD = ERC20(configurator.peUSD());\n            uint256 peUSDBalance = peUSD.balanceOf(address(this));\n            if (peUSDBalance >= reward - eUSDShare) {\n                peUSD.transfer(msg.sender, reward - eUSDShare);\n                emit ClaimReward(\n                    msg.sender,\n                    EUSD.getMintedEUSDByShares(eUSDShare),\n                    address(peUSD),\n                    reward - eUSDShare,\n                    block.timestamp\n                );\n            } else {\n                if (peUSDBalance > 0) {\n                    peUSD.transfer(msg.sender, peUSDBalance);\n                }\n                ERC20 token = ERC20(configurator.stableToken());\n                uint256 tokenAmount = ((reward - eUSDShare - peUSDBalance) *\n                    token.decimals()) / 1e18;\n                token.transfer(msg.sender, tokenAmount);\n                emit ClaimReward(\n                    msg.sender,\n                    EUSD.getMintedEUSDByShares(eUSDShare),\n                    address(token),\n                    reward - eUSDShare,\n                    block.timestamp\n                );\n            }\n        } else {\n            emit ClaimReward(\n                msg.sender,\n                EUSD.getMintedEUSDByShares(eUSDShare),\n                address(0),\n                0,\n                block.timestamp\n            );\n        }\n    }\n}\n```\n\nTo determine the available shares for rewarding users, the function calculates the shares of the eUSD token held by the contract and compares it with the total reward to be distributed.\n\nHere is the code snippet illustrating this calculation:\n\n```solidity\nuint256 balance = EUSD.sharesOf(address(this));\nuint256 eUSDShare = balance >= reward ? reward : reward - balance;\n```\n\nHowever, the comparison of shares with the reward in this manner is incorrect.\n\nLet's consider an example to understand the problem. Suppose `rewards[msg.sender]` is equal to `$`10 worth of eUSD, and the shares held by the contract are 9 shares. If each share corresponds to `$`10 worth eUSD, the contract mistakenly assumes it does not have enough balance to cover the entire reward, because it has 9 shares; however, having 9 shares is equivalent to having `$`90 worth of eUSD. Consequently, it first sends 9 shares, equivalent to `$`90 worth of eUSD, and then sends `$`1 worth peUSD. However, the sum of these sent values is `$`91 worth of eUSD, while the user's actual reward is only `$`10 worth eUSD.\n\nThis issue can lead to incorrect reward distribution, causing users to receive significantly more or less rewards than they should.\n\n### Tools Used\n\nManual Review\n\n### Recommended Mitigation Steps\n\nTo address this issue, it is recommended to replace the usage of `eUSDShare` with `EUSD.getMintedEUSDByShares(eUSDShare)` in the following lines:\n\n*   [ProtocolRewardsPool.sol#L198](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L198)\n*   [ProtocolRewardsPool.sol#L201-L202](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L201-L202)\n*   [ProtocolRewardsPool.sol#L209](https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L209)\n\nThis ensures that the correct amount of eUSD is transferred to the user while maintaining the accuracy of reward calculations.\n\n### Assessed type\n\nMath\n\n**[LybraFinance confirmed](https://github.com/code-423n4/2023-06-lybra-findings/issues/604#issuecomment-1635563567)**\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/604#issuecomment-1650698823):**\n > I will leave open for more comment, but this is probably more a \"leak\" of value type scenario than assets being lost or stolen directly. Therefore M is probably appropriate. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/miner/ProtocolRewardsPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title ProtocolRewardsPool is a derivative version of Synthetix StakingRewards.sol, distributing Protocol revenue to esLBR stakers.\n * Converting esLBR to LBR.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract esLBR.\n * - Get `stakedOf(user)` from balanceOf(user) in contract esLBR.\n * - When an address esLBR balance changes, call the refreshReward method to update rewards to be claimed.\n */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"../interfaces/IesLBR.sol\";\n\ninterface IesLBRBoost {\n    function getUnlockTime(\n        address user\n    ) external view returns (uint256 unlockTime);\n}\n\ncontract ProtocolRewardsPool is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBR public esLBR;\n    IesLBR public LBR;\n    IesLBRBoost public esLBRBoost;\n\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint) public rewards;\n    mapping(address => uint) public time2fullRedemption;\n    mapping(address => uint) public unstakeRatio;\n    mapping(address => uint) public lastWithdrawTime;\n    uint256 immutable exitCycle = 90 days;\n    uint256 public grabableAmount;\n    uint256 public grabFeeRatio = 3000;\n    event Restake(address indexed user, uint256 amount, uint256 time);\n    event StakeLBR(address indexed user, uint256 amount, uint256 time);\n    event UnstakeLBR(address indexed user, uint256 amount, uint256 time);\n    event WithdrawLBR(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 eUSDAmount, address token, uint256 tokenAmount, uint256 time);\n\n    constructor(address _config) {\n        configurator = Iconfigurator(_config);\n    }\n\n    function setTokenAddress(address _eslbr, address _lbr, address _boost) external onlyOwner {\n        esLBR = IesLBR(_eslbr);\n        LBR = IesLBR(_lbr);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setGrabCost(uint256 _ratio) external onlyOwner {\n        require(_ratio <= 8000, \"BCE\");\n        grabFeeRatio = _ratio;\n    }\n\n    // Total staked\n    function totalStaked() internal view returns (uint256) {\n        return esLBR.totalSupply();\n    }\n\n    // User address => esLBR balance\n    function stakedOf(address staker) internal view returns (uint256) {\n        return esLBR.balanceOf(staker);\n    }\n\n    function stake(uint256 amount) external {\n        LBR.burn(msg.sender, amount);\n        esLBR.mint(msg.sender, amount);\n        emit StakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Unlocks esLBR and converts it to LBR.\n     * @param amount The amount to convert.\n     * Requirements:\n     * The current time must be greater than the unlock time retrieved from the boost contract for the user.\n     * Effects:\n     * Resets the user's vesting data, entering a new vesting period, when converting to LBR.\n     */\n    function unstake(uint256 amount) external {\n        require(block.timestamp >= esLBRBoost.getUnlockTime(msg.sender), \"Your lock-in period has not ended. You can't convert your esLBR now.\");\n        esLBR.burn(msg.sender, amount);\n        withdraw(msg.sender);\n        uint256 total = amount;\n        if (time2fullRedemption[msg.sender] > block.timestamp) {\n            total += unstakeRatio[msg.sender] * (time2fullRedemption[msg.sender] - block.timestamp);\n        }\n        unstakeRatio[msg.sender] = total / exitCycle;\n        time2fullRedemption[msg.sender] = block.timestamp + exitCycle;\n        emit UnstakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    function withdraw(address user) public {\n        uint256 amount = getClaimAbleLBR(user);\n        if (amount > 0) {\n            LBR.mint(user, amount);\n        }\n        lastWithdrawTime[user] = block.timestamp;\n        emit WithdrawLBR(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeems and converts the ESLBR being claimed in advance,\n     * with the lost portion being recorded in the contract and available for others to purchase in LBR at a certain ratio.\n     */\n    function unlockPrematurely() external {\n        require(block.timestamp + exitCycle - 3 days > time2fullRedemption[msg.sender], \"ENW\");\n        uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender);\n        uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender);\n        if (amount > 0) {\n            LBR.mint(msg.sender, amount);\n        }\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        grabableAmount += burnAmount;\n    }\n\n    /**\n     * @dev Purchase the accumulated amount of pre-claimed lost ESLBR in the contract using LBR.\n     * @param amount The amount of ESLBR to be purchased.\n     * Requirements:\n     * The amount must be greater than 0.\n     */\n    function grabEsLBR(uint256 amount) external {\n        require(amount > 0, \"QMG\");\n        grabableAmount -= amount;\n        LBR.burn(msg.sender, (amount * grabFeeRatio) / 10000);\n        esLBR.mint(msg.sender, amount);\n    }\n\n    /**\n     * @dev Convert unredeemed and converting ESLBR tokens back to LBR.\n     */\n    function reStake() external {\n        uint256 amount = getReservedLBRForVesting(msg.sender) + getClaimAbleLBR(msg.sender);\n        esLBR.mint(msg.sender, amount);\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        emit Restake(msg.sender, amount, block.timestamp);\n    }\n\n    function getPreUnlockableAmount(address user) public view returns (uint256 amount) {\n        uint256 a = getReservedLBRForVesting(user);\n        if (a == 0) return 0;\n        amount = (a * (75e18 - ((time2fullRedemption[user] - block.timestamp) * 70e18) / (exitCycle / 1 days - 3) / 1 days)) / 100e18;\n    }\n\n    function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n        }\n    }\n\n    function getReservedLBRForVesting(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > block.timestamp) {\n            amount = unstakeRatio[user] * (time2fullRedemption[user] - block.timestamp);\n        }\n    }\n\n    function earned(address _account) public view returns (uint) {\n        return ((stakedOf(_account) * (rewardPerTokenStored - userRewardPerTokenPaid[_account])) / 1e18) + rewards[_account];\n    }\n\n    function getClaimAbleUSD(address user) external view returns (uint256 amount) {\n        amount = IEUSD(configurator.getEUSDAddress()).getMintedEUSDByShares(earned(user));\n    }\n\n    /**\n     * @dev Call this function when deposit or withdraw ETH on Lybra and update the status of corresponding user.\n     */\n    modifier updateReward(address account) {\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        _;\n    }\n\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    /**\n     * @notice When claiming protocol rewards earnings, if there is a sufficient amount of eUSD in the ProtocolRewards Pool,\n     * the eUSD will be prioritized for distribution. Distributes earnings in the order of peUSD and other stablecoins if the eUSD balance is insufficient..\n     */\n    function getReward() external updateReward(msg.sender) {\n        uint reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IEUSD EUSD = IEUSD(configurator.getEUSDAddress());\n            uint256 balance = EUSD.sharesOf(address(this));\n            uint256 eUSDShare = balance >= reward ? reward : reward - balance;\n            EUSD.transferShares(msg.sender, eUSDShare);\n            if(reward > eUSDShare) {\n                ERC20 peUSD = ERC20(configurator.peUSD());\n                uint256 peUSDBalance = peUSD.balanceOf(address(this));\n                if(peUSDBalance >= reward - eUSDShare) {\n                    peUSD.transfer(msg.sender, reward - eUSDShare);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(peUSD), reward - eUSDShare, block.timestamp);\n                } else {\n                    if(peUSDBalance > 0) {\n                        peUSD.transfer(msg.sender, peUSDBalance);\n                    }\n                    ERC20 token = ERC20(configurator.stableToken());\n                    uint256 tokenAmount = (reward - eUSDShare - peUSDBalance) * token.decimals() / 1e18;\n                    token.transfer(msg.sender, tokenAmount);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(token), reward - eUSDShare, block.timestamp);\n                }\n            } else {\n                emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(0), 0, block.timestamp);\n            }\n           \n        }\n    }\n\n    /**\n     * @dev Receives stablecoin tokens sent by the configurator contract and records the protocol rewards accumulation per esLBR held.\n     * @param amount The amount of rewards to be distributed.\n     * @param tokenType The type of token (0 for eUSD, 1 for other stablecoins, 2 for peUSD).\n     * @dev This function is called by the configurator contract to distribute rewards.\n     * @dev When receiving stablecoin tokens other than eUSD, the decimals of the token are converted to 18 for consistent calculations.\n     */\n    function notifyRewardAmount(uint amount, uint tokenType) external {\n        require(msg.sender == address(configurator));\n        if (totalStaked() == 0) return;\n        require(amount > 0, \"amount = 0\");\n        if(tokenType == 0) {\n            uint256 share = IEUSD(configurator.getEUSDAddress()).getSharesByMintedEUSD(amount);\n            rewardPerTokenStored = rewardPerTokenStored + (share * 1e18) / totalStaked();\n        } else if(tokenType == 1) {\n            ERC20 token = ERC20(configurator.stableToken());\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e36 / token.decimals()) / totalStaked();\n        } else {\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e18) / totalStaked();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/ProtocolRewardsPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title ProtocolRewardsPool is a derivative version of Synthetix StakingRewards.sol, distributing Protocol revenue to esLBR stakers.\n * Converting esLBR to LBR.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract esLBR.\n * - Get `stakedOf(user)` from balanceOf(user) in contract esLBR.\n * - When an address esLBR balance changes, call the refreshReward method to update rewards to be claimed.\n */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"../interfaces/IesLBR.sol\";\n\ninterface IesLBRBoost {\n    function getUnlockTime(\n        address user\n    ) external view returns (uint256 unlockTime);\n}\n\ncontract ProtocolRewardsPool is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBR public esLBR;\n    IesLBR public LBR;\n    IesLBRBoost public esLBRBoost;\n\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint) public rewards;\n    mapping(address => uint) public time2fullRedemption;\n    mapping(address => uint) public unstakeRatio;\n    mapping(address => uint) public lastWithdrawTime;\n    uint256 immutable exitCycle = 90 days;\n    uint256 public grabableAmount;\n    uint256 public grabFeeRatio = 3000;\n    event Restake(address indexed user, uint256 amount, uint256 time);\n    event StakeLBR(address indexed user, uint256 amount, uint256 time);\n    event UnstakeLBR(address indexed user, uint256 amount, uint256 time);\n    event WithdrawLBR(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 eUSDAmount, address token, uint256 tokenAmount, uint256 time);\n\n    constructor(address _config) {\n        configurator = Iconfigurator(_config);\n    }\n\n    function setTokenAddress(address _eslbr, address _lbr, address _boost) external onlyOwner {\n        esLBR = IesLBR(_eslbr);\n        LBR = IesLBR(_lbr);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setGrabCost(uint256 _ratio) external onlyOwner {\n        require(_ratio <= 8000, \"BCE\");\n        grabFeeRatio = _ratio;\n    }\n\n    // Total staked\n    function totalStaked() internal view returns (uint256) {\n        return esLBR.totalSupply();\n    }\n\n    // User address => esLBR balance\n    function stakedOf(address staker) internal view returns (uint256) {\n        return esLBR.balanceOf(staker);\n    }\n\n    function stake(uint256 amount) external {\n        LBR.burn(msg.sender, amount);\n        esLBR.mint(msg.sender, amount);\n        emit StakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Unlocks esLBR and converts it to LBR.\n     * @param amount The amount to convert.\n     * Requirements:\n     * The current time must be greater than the unlock time retrieved from the boost contract for the user.\n     * Effects:\n     * Resets the user's vesting data, entering a new vesting period, when converting to LBR.\n     */\n    function unstake(uint256 amount) external {\n        require(block.timestamp >= esLBRBoost.getUnlockTime(msg.sender), \"Your lock-in period has not ended. You can't convert your esLBR now.\");\n        esLBR.burn(msg.sender, amount);\n        withdraw(msg.sender);\n        uint256 total = amount;\n        if (time2fullRedemption[msg.sender] > block.timestamp) {\n            total += unstakeRatio[msg.sender] * (time2fullRedemption[msg.sender] - block.timestamp);\n        }\n        unstakeRatio[msg.sender] = total / exitCycle;\n        time2fullRedemption[msg.sender] = block.timestamp + exitCycle;\n        emit UnstakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    function withdraw(address user) public {\n        uint256 amount = getClaimAbleLBR(user);\n        if (amount > 0) {\n            LBR.mint(user, amount);\n        }\n        lastWithdrawTime[user] = block.timestamp;\n        emit WithdrawLBR(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeems and converts the ESLBR being claimed in advance,\n     * with the lost portion being recorded in the contract and available for others to purchase in LBR at a certain ratio.\n     */\n    function unlockPrematurely() external {\n        require(block.timestamp + exitCycle - 3 days > time2fullRedemption[msg.sender], \"ENW\");\n        uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender);\n        uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender);\n        if (amount > 0) {\n            LBR.mint(msg.sender, amount);\n        }\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        grabableAmount += burnAmount;\n    }\n\n    /**\n     * @dev Purchase the accumulated amount of pre-claimed lost ESLBR in the contract using LBR.\n     * @param amount The amount of ESLBR to be purchased.\n     * Requirements:\n     * The amount must be greater than 0.\n     */\n    function grabEsLBR(uint256 amount) external {\n        require(amount > 0, \"QMG\");\n        grabableAmount -= amount;\n        LBR.burn(msg.sender, (amount * grabFeeRatio) / 10000);\n        esLBR.mint(msg.sender, amount);\n    }\n\n    /**\n     * @dev Convert unredeemed and converting ESLBR tokens back to LBR.\n     */\n    function reStake() external {\n        uint256 amount = getReservedLBRForVesting(msg.sender) + getClaimAbleLBR(msg.sender);\n        esLBR.mint(msg.sender, amount);\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        emit Restake(msg.sender, amount, block.timestamp);\n    }\n\n    function getPreUnlockableAmount(address user) public view returns (uint256 amount) {\n        uint256 a = getReservedLBRForVesting(user);\n        if (a == 0) return 0;\n        amount = (a * (75e18 - ((time2fullRedemption[user] - block.timestamp) * 70e18) / (exitCycle / 1 days - 3) / 1 days)) / 100e18;\n    }\n\n    function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n        }\n    }\n\n    function getReservedLBRForVesting(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > block.timestamp) {\n            amount = unstakeRatio[user] * (time2fullRedemption[user] - block.timestamp);\n        }\n    }\n\n    function earned(address _account) public view returns (uint) {\n        return ((stakedOf(_account) * (rewardPerTokenStored - userRewardPerTokenPaid[_account])) / 1e18) + rewards[_account];\n    }\n\n    function getClaimAbleUSD(address user) external view returns (uint256 amount) {\n        amount = IEUSD(configurator.getEUSDAddress()).getMintedEUSDByShares(earned(user));\n    }\n\n    /**\n     * @dev Call this function when deposit or withdraw ETH on Lybra and update the status of corresponding user.\n     */\n    modifier updateReward(address account) {\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        _;\n    }\n\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    /**\n     * @notice When claiming protocol rewards earnings, if there is a sufficient amount of eUSD in the ProtocolRewards Pool,\n     * the eUSD will be prioritized for distribution. Distributes earnings in the order of peUSD and other stablecoins if the eUSD balance is insufficient..\n     */\n    function getReward() external updateReward(msg.sender) {\n        uint reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IEUSD EUSD = IEUSD(configurator.getEUSDAddress());\n            uint256 balance = EUSD.sharesOf(address(this));\n            uint256 eUSDShare = balance >= reward ? reward : reward - balance;\n            EUSD.transferShares(msg.sender, eUSDShare);\n            if(reward > eUSDShare) {\n                ERC20 peUSD = ERC20(configurator.peUSD());\n                uint256 peUSDBalance = peUSD.balanceOf(address(this));\n                if(peUSDBalance >= reward - eUSDShare) {\n                    peUSD.transfer(msg.sender, reward - eUSDShare);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(peUSD), reward - eUSDShare, block.timestamp);\n                } else {\n                    if(peUSDBalance > 0) {\n                        peUSD.transfer(msg.sender, peUSDBalance);\n                    }\n                    ERC20 token = ERC20(configurator.stableToken());\n                    uint256 tokenAmount = (reward - eUSDShare - peUSDBalance) * token.decimals() / 1e18;\n                    token.transfer(msg.sender, tokenAmount);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(token), reward - eUSDShare, block.timestamp);\n                }\n            } else {\n                emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(0), 0, block.timestamp);\n            }\n           \n        }\n    }\n\n    /**\n     * @dev Receives stablecoin tokens sent by the configurator contract and records the protocol rewards accumulation per esLBR held.\n     * @param amount The amount of rewards to be distributed.\n     * @param tokenType The type of token (0 for eUSD, 1 for other stablecoins, 2 for peUSD).\n     * @dev This function is called by the configurator contract to distribute rewards.\n     * @dev When receiving stablecoin tokens other than eUSD, the decimals of the token are converted to 18 for consistent calculations.\n     */\n    function notifyRewardAmount(uint amount, uint tokenType) external {\n        require(msg.sender == address(configurator));\n        if (totalStaked() == 0) return;\n        require(amount > 0, \"amount = 0\");\n        if(tokenType == 0) {\n            uint256 share = IEUSD(configurator.getEUSDAddress()).getSharesByMintedEUSD(amount);\n            rewardPerTokenStored = rewardPerTokenStored + (share * 1e18) / totalStaked();\n        } else if(tokenType == 1) {\n            ERC20 token = ERC20(configurator.stableToken());\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e36 / token.decimals()) / totalStaked();\n        } else {\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e18) / totalStaked();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/ProtocolRewardsPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title ProtocolRewardsPool is a derivative version of Synthetix StakingRewards.sol, distributing Protocol revenue to esLBR stakers.\n * Converting esLBR to LBR.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract esLBR.\n * - Get `stakedOf(user)` from balanceOf(user) in contract esLBR.\n * - When an address esLBR balance changes, call the refreshReward method to update rewards to be claimed.\n */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"../interfaces/IesLBR.sol\";\n\ninterface IesLBRBoost {\n    function getUnlockTime(\n        address user\n    ) external view returns (uint256 unlockTime);\n}\n\ncontract ProtocolRewardsPool is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBR public esLBR;\n    IesLBR public LBR;\n    IesLBRBoost public esLBRBoost;\n\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint) public rewards;\n    mapping(address => uint) public time2fullRedemption;\n    mapping(address => uint) public unstakeRatio;\n    mapping(address => uint) public lastWithdrawTime;\n    uint256 immutable exitCycle = 90 days;\n    uint256 public grabableAmount;\n    uint256 public grabFeeRatio = 3000;\n    event Restake(address indexed user, uint256 amount, uint256 time);\n    event StakeLBR(address indexed user, uint256 amount, uint256 time);\n    event UnstakeLBR(address indexed user, uint256 amount, uint256 time);\n    event WithdrawLBR(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 eUSDAmount, address token, uint256 tokenAmount, uint256 time);\n\n    constructor(address _config) {\n        configurator = Iconfigurator(_config);\n    }\n\n    function setTokenAddress(address _eslbr, address _lbr, address _boost) external onlyOwner {\n        esLBR = IesLBR(_eslbr);\n        LBR = IesLBR(_lbr);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setGrabCost(uint256 _ratio) external onlyOwner {\n        require(_ratio <= 8000, \"BCE\");\n        grabFeeRatio = _ratio;\n    }\n\n    // Total staked\n    function totalStaked() internal view returns (uint256) {\n        return esLBR.totalSupply();\n    }\n\n    // User address => esLBR balance\n    function stakedOf(address staker) internal view returns (uint256) {\n        return esLBR.balanceOf(staker);\n    }\n\n    function stake(uint256 amount) external {\n        LBR.burn(msg.sender, amount);\n        esLBR.mint(msg.sender, amount);\n        emit StakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Unlocks esLBR and converts it to LBR.\n     * @param amount The amount to convert.\n     * Requirements:\n     * The current time must be greater than the unlock time retrieved from the boost contract for the user.\n     * Effects:\n     * Resets the user's vesting data, entering a new vesting period, when converting to LBR.\n     */\n    function unstake(uint256 amount) external {\n        require(block.timestamp >= esLBRBoost.getUnlockTime(msg.sender), \"Your lock-in period has not ended. You can't convert your esLBR now.\");\n        esLBR.burn(msg.sender, amount);\n        withdraw(msg.sender);\n        uint256 total = amount;\n        if (time2fullRedemption[msg.sender] > block.timestamp) {\n            total += unstakeRatio[msg.sender] * (time2fullRedemption[msg.sender] - block.timestamp);\n        }\n        unstakeRatio[msg.sender] = total / exitCycle;\n        time2fullRedemption[msg.sender] = block.timestamp + exitCycle;\n        emit UnstakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    function withdraw(address user) public {\n        uint256 amount = getClaimAbleLBR(user);\n        if (amount > 0) {\n            LBR.mint(user, amount);\n        }\n        lastWithdrawTime[user] = block.timestamp;\n        emit WithdrawLBR(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeems and converts the ESLBR being claimed in advance,\n     * with the lost portion being recorded in the contract and available for others to purchase in LBR at a certain ratio.\n     */\n    function unlockPrematurely() external {\n        require(block.timestamp + exitCycle - 3 days > time2fullRedemption[msg.sender], \"ENW\");\n        uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender);\n        uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender);\n        if (amount > 0) {\n            LBR.mint(msg.sender, amount);\n        }\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        grabableAmount += burnAmount;\n    }\n\n    /**\n     * @dev Purchase the accumulated amount of pre-claimed lost ESLBR in the contract using LBR.\n     * @param amount The amount of ESLBR to be purchased.\n     * Requirements:\n     * The amount must be greater than 0.\n     */\n    function grabEsLBR(uint256 amount) external {\n        require(amount > 0, \"QMG\");\n        grabableAmount -= amount;\n        LBR.burn(msg.sender, (amount * grabFeeRatio) / 10000);\n        esLBR.mint(msg.sender, amount);\n    }\n\n    /**\n     * @dev Convert unredeemed and converting ESLBR tokens back to LBR.\n     */\n    function reStake() external {\n        uint256 amount = getReservedLBRForVesting(msg.sender) + getClaimAbleLBR(msg.sender);\n        esLBR.mint(msg.sender, amount);\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        emit Restake(msg.sender, amount, block.timestamp);\n    }\n\n    function getPreUnlockableAmount(address user) public view returns (uint256 amount) {\n        uint256 a = getReservedLBRForVesting(user);\n        if (a == 0) return 0;\n        amount = (a * (75e18 - ((time2fullRedemption[user] - block.timestamp) * 70e18) / (exitCycle / 1 days - 3) / 1 days)) / 100e18;\n    }\n\n    function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n        }\n    }\n\n    function getReservedLBRForVesting(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > block.timestamp) {\n            amount = unstakeRatio[user] * (time2fullRedemption[user] - block.timestamp);\n        }\n    }\n\n    function earned(address _account) public view returns (uint) {\n        return ((stakedOf(_account) * (rewardPerTokenStored - userRewardPerTokenPaid[_account])) / 1e18) + rewards[_account];\n    }\n\n    function getClaimAbleUSD(address user) external view returns (uint256 amount) {\n        amount = IEUSD(configurator.getEUSDAddress()).getMintedEUSDByShares(earned(user));\n    }\n\n    /**\n     * @dev Call this function when deposit or withdraw ETH on Lybra and update the status of corresponding user.\n     */\n    modifier updateReward(address account) {\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        _;\n    }\n\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    /**\n     * @notice When claiming protocol rewards earnings, if there is a sufficient amount of eUSD in the ProtocolRewards Pool,\n     * the eUSD will be prioritized for distribution. Distributes earnings in the order of peUSD and other stablecoins if the eUSD balance is insufficient..\n     */\n    function getReward() external updateReward(msg.sender) {\n        uint reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IEUSD EUSD = IEUSD(configurator.getEUSDAddress());\n            uint256 balance = EUSD.sharesOf(address(this));\n            uint256 eUSDShare = balance >= reward ? reward : reward - balance;\n            EUSD.transferShares(msg.sender, eUSDShare);\n            if(reward > eUSDShare) {\n                ERC20 peUSD = ERC20(configurator.peUSD());\n                uint256 peUSDBalance = peUSD.balanceOf(address(this));\n                if(peUSDBalance >= reward - eUSDShare) {\n                    peUSD.transfer(msg.sender, reward - eUSDShare);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(peUSD), reward - eUSDShare, block.timestamp);\n                } else {\n                    if(peUSDBalance > 0) {\n                        peUSD.transfer(msg.sender, peUSDBalance);\n                    }\n                    ERC20 token = ERC20(configurator.stableToken());\n                    uint256 tokenAmount = (reward - eUSDShare - peUSDBalance) * token.decimals() / 1e18;\n                    token.transfer(msg.sender, tokenAmount);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(token), reward - eUSDShare, block.timestamp);\n                }\n            } else {\n                emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(0), 0, block.timestamp);\n            }\n           \n        }\n    }\n\n    /**\n     * @dev Receives stablecoin tokens sent by the configurator contract and records the protocol rewards accumulation per esLBR held.\n     * @param amount The amount of rewards to be distributed.\n     * @param tokenType The type of token (0 for eUSD, 1 for other stablecoins, 2 for peUSD).\n     * @dev This function is called by the configurator contract to distribute rewards.\n     * @dev When receiving stablecoin tokens other than eUSD, the decimals of the token are converted to 18 for consistent calculations.\n     */\n    function notifyRewardAmount(uint amount, uint tokenType) external {\n        require(msg.sender == address(configurator));\n        if (totalStaked() == 0) return;\n        require(amount > 0, \"amount = 0\");\n        if(tokenType == 0) {\n            uint256 share = IEUSD(configurator.getEUSDAddress()).getSharesByMintedEUSD(amount);\n            rewardPerTokenStored = rewardPerTokenStored + (share * 1e18) / totalStaked();\n        } else if(tokenType == 1) {\n            ERC20 token = ERC20(configurator.stableToken());\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e36 / token.decimals()) / totalStaked();\n        } else {\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e18) / totalStaked();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/ProtocolRewardsPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title ProtocolRewardsPool is a derivative version of Synthetix StakingRewards.sol, distributing Protocol revenue to esLBR stakers.\n * Converting esLBR to LBR.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract esLBR.\n * - Get `stakedOf(user)` from balanceOf(user) in contract esLBR.\n * - When an address es"
    }
  ]
}