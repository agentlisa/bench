{
  "Title": "[L-01] Disable the `stakeFor` function when the `system` is `paused`",
  "Content": "\nIn the `LockingMultiRewards` contract, users cannot `stake` when the system is `paused`.\nhttps://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/staking/LockingMultiRewards.sol#L150\n```\nfunction stake(uint256 amount, bool lock_) public whenNotPaused {\n    _stakeFor(msg.sender, amount, lock_);\n}\n```\nAdditionally, users cannot lock already deposited tokens when the `system` is `paused`.\nhttps://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/staking/LockingMultiRewards.sol#L155\n```\nfunction lock(uint256 amount) public whenNotPaused {\n}\n```\nAll operations should be disabled when the `system` is `paused`.\nHowever, `operators` can still `stake` for other users when the `system` is `paused`.\nhttps://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/staking/LockingMultiRewards.sol#L349-L351\n```\nfunction stakeFor(address account, uint256 amount, bool lock_) external onlyOperators {\n    _stakeFor(account, amount, lock_);\n}\n```\n\nShould include the `whenNotPaused` `modifier`.\n```\n- function stakeFor(address account, uint256 amount, bool lock_) external onlyOperators {\n+ function stakeFor(address account, uint256 amount, bool lock_) external onlyOperators whenNotPaused  {\n    _stakeFor(account, amount, lock_);\n}\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "src/staking/LockingMultiRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {OperatableV2} from \"mixins/OperatableV2.sol\";\nimport {Pausable} from \"openzeppelin-contracts/security/Pausable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {MathLib} from \"libraries/MathLib.sol\";\n\n/// @notice A staking contract that distributes multiple rewards to stakers.\n/// Stakers can lock their tokens for a period of time to get a boost on their rewards.\n/// @author Based from Curve Finance's MultiRewards contract https://github.com/curvefi/multi-rewards/blob/master/contracts/MultiRewards.sol\n/// @author Based from Ellipsis Finance's EpsStaker https://github.com/ellipsis-finance/ellipsis/blob/master/contracts/EpsStaker.sol\n/// @author Based from Convex Finance's CvxLockerV2 https://github.com/convex-eth/platform/blob/main/contracts/contracts/CvxLockerV2.sol\ncontract LockingMultiRewards is OperatableV2, Pausable {\n    using SafeTransferLib for address;\n\n    event LogRewardAdded(uint256 reward);\n    event LogStaked(address indexed user, uint256 amount);\n    event LogLocked(address indexed user, uint256 amount, uint256 unlockTime, uint256 lockCount);\n    event LogUnlocked(address indexed user, uint256 amount, uint256 index);\n    event LogLockIndexChanged(address indexed user, uint256 fromIndex, uint256 toIndex);\n    event LogWithdrawn(address indexed user, uint256 amount);\n    event LogRewardLockCreated(address indexed user, uint256 unlockTime);\n    event LogRewardLocked(address indexed user, address indexed rewardsToken, uint256 reward);\n    event LogRewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);\n    event LogRewardsDurationUpdated(address token, uint256 newDuration);\n    event LogRecovered(address token, uint256 amount);\n    event LogSetMinLockAmount(uint256 previous, uint256 current);\n\n    error ErrZeroAmount();\n    error ErrRewardAlreadyExists();\n    error ErrInvalidTokenAddress();\n    error ErrMaxUserLocksExceeded();\n    error ErrNotExpired();\n    error ErrInvalidUser();\n    error ErrLockAmountTooSmall();\n    error ErrLengthMismatch();\n    error ErrNoLocks();\n    error ErrLockNotExpired();\n    error ErrMaxRewardsExceeded();\n    error ErrSkimmingTooMuch();\n    error ErrInvalidLockIndex();\n    error ErrNotEnoughReward();\n    error ErrInvalidDurationRatio();\n    error ErrInvalidBoostMultiplier();\n    error ErrInvalidLockDuration();\n    error ErrInvalidRewardDuration();\n    error ErrInsufficientRemainingTime();\n\n    struct Reward {\n        uint256 periodFinish;\n        uint256 rewardRate;\n        uint256 rewardPerTokenStored;\n        bool exists;\n        uint248 lastUpdateTime;\n    }\n\n    struct Balances {\n        uint256 unlocked;\n        uint256 locked;\n    }\n\n    struct LockedBalance {\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    struct RewardLockItem {\n        address token;\n        uint256 amount;\n    }\n\n    struct RewardLock {\n        RewardLockItem[] items;\n        uint256 unlockTime;\n    }\n\n    uint256 private constant BIPS = 10_000;\n    uint256 private constant MAX_NUM_REWARDS = 5;\n    uint256 private constant MIN_LOCK_DURATION = 1 weeks;\n    uint256 private constant MIN_REWARDS_DURATION = 1 days;\n\n    uint256 public immutable maxLocks;\n    uint256 public immutable lockingBoostMultiplerInBips;\n    uint256 public immutable rewardsDuration;\n    uint256 public immutable lockDuration;\n    address public immutable stakingToken;\n\n    mapping(address token => Reward info) private _rewardData;\n    mapping(address user => Balances balances) private _balances;\n    mapping(address user => LockedBalance[] locks) private _userLocks;\n    mapping(address user => RewardLock rewardLock) private _userRewardLock;\n\n    mapping(address user => mapping(address token => uint256 amount)) public userRewardPerTokenPaid;\n    mapping(address user => mapping(address token => uint256 amount)) public rewards;\n    mapping(address user => uint256 index) public lastLockIndex;\n\n    address[] public rewardTokens;\n\n    uint256 public lockedSupply; // all locked boosted deposits\n    uint256 public unlockedSupply; // all unlocked unboosted deposits\n    uint256 public minLockAmount; // minimum amount allowed to lock\n    uint256 public stakingTokenBalance; // total staking token balance\n\n    ///\n    /// @dev Constructor\n    /// @param _stakingToken The token that is being staked\n    /// @param _owner The owner of the contract\n    /// @param _lockingBoostMultiplerInBips The multiplier for the locking boost. 30000 means if you stake 100, you get 300 locked\n    /// @param _rewardsDuration The duration of the rewards period in seconds, should be 7 days by default.\n    /// @param _lockDuration The duration of the lock period in seconds, should be 13 weeks by default.\n    constructor(\n        address _stakingToken,\n        uint256 _lockingBoostMultiplerInBips,\n        uint256 _rewardsDuration,\n        uint256 _lockDuration,\n        address _owner\n    ) OperatableV2(_owner) {\n        if (_lockingBoostMultiplerInBips <= BIPS) {\n            revert ErrInvalidBoostMultiplier();\n        }\n\n        if (_lockDuration < MIN_LOCK_DURATION) {\n            revert ErrInvalidLockDuration();\n        }\n\n        if (_rewardsDuration < MIN_REWARDS_DURATION) {\n            revert ErrInvalidRewardDuration();\n        }\n\n        if (_lockDuration % _rewardsDuration != 0) {\n            revert ErrInvalidDurationRatio();\n        }\n\n        stakingToken = _stakingToken;\n        lockingBoostMultiplerInBips = _lockingBoostMultiplerInBips;\n        rewardsDuration = _rewardsDuration;\n        lockDuration = _lockDuration;\n\n        // kocks are combined into the same `rewardsDuration` epoch. So, if\n        // a user stake with locking every `rewardsDuration` this should reach the\n        // maximum number of possible simultaneous because the first lock gets expired,\n        // freeing up a slot.\n        maxLocks = _lockDuration / _rewardsDuration;\n    }\n\n    /// @notice Stakes the given amount of tokens for the given user.\n    /// @param amount The amount of tokens to stake\n    /// @param lock_ If true, the tokens will be locked for the lock duration for a reward boost\n    function stake(uint256 amount, bool lock_) public whenNotPaused {\n        _stakeFor(msg.sender, amount, lock_);\n    }\n\n    /// @notice Locks an existing unlocked balance.\n    function lock(uint256 amount) public whenNotPaused {\n        if (amount == 0) {\n            revert ErrZeroAmount();\n        }\n\n        _updateRewardsForUser(msg.sender);\n\n        _balances[msg.sender].unlocked -= amount;\n        unlockedSupply -= amount;\n\n        _createLock(msg.sender, amount);\n    }\n\n    /// @notice Withdraws the given amount of unlocked tokens for the given user.\n    /// @param amount The amount of unlocked tokens to withdraw\n    function withdraw(uint256 amount) public virtual {\n        if (amount == 0) {\n            revert ErrZeroAmount();\n        }\n\n        _updateRewardsForUser(msg.sender);\n\n        _balances[msg.sender].unlocked -= amount;\n        unlockedSupply -= amount;\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        stakingTokenBalance -= amount;\n\n        emit LogWithdrawn(msg.sender, amount);\n    }\n\n    function withdrawWithRewards(uint256 amount) public virtual {\n        withdraw(amount);\n        _getRewards(msg.sender);\n    }\n\n    function getRewards() public virtual {\n        _updateRewardsForUser(msg.sender);\n        _getRewards(msg.sender);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    function rewardData(address token) external view returns (Reward memory) {\n        return _rewardData[token];\n    }\n\n    function rewardsForDuration(address rewardToken) external view returns (uint256) {\n        return _rewardData[rewardToken].rewardRate * rewardsDuration;\n    }\n\n    function rewardTokensLength() external view returns (uint256) {\n        return rewardTokens.length;\n    }\n\n    function balances(address user) external view returns (Balances memory) {\n        return _balances[user];\n    }\n\n    function userRewardLock(address user) external view returns (RewardLock memory) {\n        return _userRewardLock[user];\n    }\n\n    function userLocks(address user) external view returns (LockedBalance[] memory) {\n        return _userLocks[user];\n    }\n\n    function userLocksLength(address user) external view returns (uint256) {\n        return _userLocks[user].length;\n    }\n\n    function locked(address user) external view returns (uint256) {\n        return _balances[user].locked;\n    }\n\n    function unlocked(address user) external view returns (uint256) {\n        return _balances[user].unlocked;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return unlockedSupply + ((lockedSupply * lockingBoostMultiplerInBips) / BIPS);\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        Balances storage bal = _balances[user];\n        return bal.unlocked + ((bal.locked * lockingBoostMultiplerInBips) / BIPS);\n    }\n\n    /// @dev Calculates when the next unlock event will occur given the current epoch.\n    /// It ensures that the unlock timing coincides with the intervals at which rewards are distributed.\n    /// If the current time is within an ongoing reward interval, the function establishes the\n    /// unlock period to begin at the next epoch.\n    /// So, if you stake at week 1 + 4 days, you will be able to unlock at the end of week 14.\n    // |    week -1   |    week 1    |    week 2    |      ...     |    week 13   |    week 14   |\n    // |--------------|--------------|--------------|--------------|--------------|--------------|\n    // |                   ^ block.timestamp                                      |\n    // |                             ^ lock starts (adjusted)                                    ^ unlock ends (nextUnlockTime)\n    function nextUnlockTime() public view returns (uint256) {\n        return nextEpoch() + lockDuration;\n    }\n\n    function epoch() public view returns (uint256) {\n        return (block.timestamp / rewardsDuration) * rewardsDuration;\n    }\n\n    function nextEpoch() public view returns (uint256) {\n        return epoch() + rewardsDuration;\n    }\n\n    function remainingEpochTime() public view returns (uint256) {\n        return nextEpoch() - block.timestamp;\n    }\n\n    function lastTimeRewardApplicable(address rewardToken) public view returns (uint256) {\n        return MathLib.min(block.timestamp, _rewardData[rewardToken].periodFinish);\n    }\n\n    function rewardPerToken(address rewardToken) public view returns (uint256) {\n        return _rewardPerToken(rewardToken, lastTimeRewardApplicable(rewardToken), totalSupply());\n    }\n\n    function _rewardPerToken(address rewardToken, uint256 lastTimeRewardApplicable_, uint256 totalSupply_) public view returns (uint256) {\n        if (totalSupply_ == 0) {\n            return _rewardData[rewardToken].rewardPerTokenStored;\n        }\n\n        uint256 timeElapsed = lastTimeRewardApplicable_ - _rewardData[rewardToken].lastUpdateTime;\n        uint256 pendingRewardsPerToken = (timeElapsed * _rewardData[rewardToken].rewardRate * 1e18) / totalSupply_;\n\n        return _rewardData[rewardToken].rewardPerTokenStored + pendingRewardsPerToken;\n    }\n\n    function earned(address user, address rewardToken) public view returns (uint256) {\n        return _earned(user, balanceOf(user), rewardToken, rewardPerToken(rewardToken));\n    }\n\n    function _earned(address user, uint256 balance_, address rewardToken, uint256 rewardPerToken_) internal view returns (uint256) {\n        uint256 pendingUserRewardsPerToken = rewardPerToken_ - userRewardPerTokenPaid[user][rewardToken];\n        return ((balance_ * pendingUserRewardsPerToken) / 1e18) + rewards[user][rewardToken];\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    function addReward(address rewardToken) public onlyOwner {\n        if (rewardToken == address(0)) {\n            revert ErrInvalidTokenAddress();\n        }\n\n        if (_rewardData[rewardToken].exists) {\n            revert ErrRewardAlreadyExists();\n        }\n\n        if (rewardTokens.length == MAX_NUM_REWARDS) {\n            revert ErrMaxRewardsExceeded();\n        }\n\n        rewardTokens.push(rewardToken);\n        _rewardData[rewardToken].exists = true;\n    }\n\n    function setMinLockAmount(uint256 _minLockAmount) external onlyOwner {\n        emit LogSetMinLockAmount(minLockAmount, _minLockAmount);\n        minLockAmount = _minLockAmount;\n    }\n\n    /// @notice This function can recover any token except for the staking token beyond the balance necessary for rewards.\n    /// WARNING: Use this function with caution to ensure it does not affect the reward mechanism.\n    function recover(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        // In case it's the staking token, allow to skim the excess\n        if (tokenAddress == stakingToken && tokenAmount > stakingToken.balanceOf(address(this)) - stakingTokenBalance) {\n            revert ErrSkimmingTooMuch();\n        }\n\n        tokenAddress.safeTransfer(owner, tokenAmount);\n        emit LogRecovered(tokenAddress, tokenAmount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /// EMERGENCY FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /// OPERATORS\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    \n    function stakeFor(address account, uint256 amount, bool lock_) external onlyOperators {\n        _stakeFor(account, amount, lock_);\n    }\n    \n    /// @notice Distribute new rewards to the stakers\n    /// @param rewardToken The address of the reward token\n    /// @param amount The amount of reward tokens to distribute\n    /// @param minRemainingTime The minimum remaining time for the current reward period\n    /// Used to avoid distributing rewards on a lower period than the expected one.\n    /// Example: If the reward period is 7 days, and there are 2 days left, `minRemainingTime` higher than\n    /// 2 days will revert the transaction.\n    /// To ignore this check, set `minRemainingTime` to 0.\n    function notifyRewardAmount(address rewardToken, uint256 amount, uint minRemainingTime) public onlyOperators {\n        if (!_rewardData[rewardToken].exists) {\n            revert ErrInvalidTokenAddress();\n        }\n\n        _updateRewards();\n        rewardToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        Reward storage reward = _rewardData[rewardToken];\n\n        uint256 _nextEpoch = nextEpoch();\n        uint256 _remainingRewardTime = _nextEpoch - block.timestamp;\n\n        if (_remainingRewardTime < minRemainingTime) {\n            revert ErrInsufficientRemainingTime();\n        }\n\n        // Take the remainder of the current rewards and add it to the amount for the next period\n        if (block.timestamp < reward.periodFinish) {\n            amount += _remainingRewardTime * reward.rewardRate;\n        }\n\n        // avoid `rewardRate` being 0\n        if (amount < _remainingRewardTime) {\n            revert ErrNotEnoughReward();\n        }\n\n        reward.rewardRate = amount / _remainingRewardTime;\n        reward.lastUpdateTime = uint248(block.timestamp);\n        reward.periodFinish = _nextEpoch;\n\n        emit LogRewardAdded(amount);\n    }\n\n    /// @notice Updates the balances of the given user and lock indexes\n    // Should be called once a `rewardDuration` (for example, every week)\n    function processExpiredLocks(address[] memory users, uint256[] calldata lockIndexes) external onlyOperators {\n        if (users.length != lockIndexes.length) {\n            revert ErrLengthMismatch();\n        }\n\n        _updateRewardsForUsers(users);\n\n        // Release all expired users' locks\n        for (uint256 i; i < users.length; ) {\n            address user = users[i];\n            Balances storage bal = _balances[user];\n            LockedBalance[] storage locks = _userLocks[user];\n\n            if (locks.length == 0) {\n                revert ErrNoLocks();\n            }\n\n            uint256 index = lockIndexes[i];\n\n            // Prevents processing `lastLockIndex` out of order\n            if (index == lastLockIndex[user] && locks.length > 1) {\n                revert ErrInvalidLockIndex();\n            }\n\n            // prohibit releasing non-expired locks\n            if (locks[index].unlockTime > block.timestamp) {\n                revert ErrLockNotExpired();\n            }\n\n            uint256 amount = locks[index].amount;\n            uint256 lastIndex = locks.length - 1;\n\n            /// Last lock index changed place with the one we just swapped.\n            if (lastLockIndex[user] == lastIndex) {\n                lastLockIndex[user] = index;\n            }\n\n            if (index != lastIndex) {\n                locks[index] = locks[lastIndex];\n                emit LogLockIndexChanged(user, lastIndex, index);\n            }\n\n            locks.pop();\n\n            unlockedSupply += amount;\n            lockedSupply -= amount;\n\n            bal.unlocked += amount;\n            bal.locked -= amount;\n\n            emit LogUnlocked(user, amount, index);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    function _stakeFor(address account, uint256 amount, bool lock_) internal {\n        if (amount == 0) {\n            revert ErrZeroAmount();\n        }\n\n        // This staking contract isn't using balanceOf, so it's safe to transfer immediately\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        stakingTokenBalance += amount;\n\n        _updateRewardsForUser(account);\n\n        if (lock_) {\n            _createLock(account, amount);\n        } else {\n            _balances[account].unlocked += amount;\n            unlockedSupply += amount;\n\n            emit LogStaked(account, amount);\n        }\n    }\n\n    function _createLock(address user, uint256 amount) internal {\n        Balances storage bal = _balances[user];\n        uint256 _nextUnlockTime = nextUnlockTime();\n        uint256 _lastLockIndex = lastLockIndex[user];\n        uint256 lockCount = _userLocks[user].length;\n\n        bal.locked += amount;\n        lockedSupply += amount;\n\n        // Add to current lock if it's the same unlock time or the first one\n        // userLocks is sorted by unlockTime, so the last lock is the most recent one\n        if (lockCount == 0 || _userLocks[user][_lastLockIndex].unlockTime < _nextUnlockTime) {\n            // Limit the number of locks per user to avoid too much gas costs per user\n            // when looping through the locks\n            if (lockCount == maxLocks) {\n                revert ErrMaxUserLocksExceeded();\n            }\n\n            if (amount < minLockAmount) {\n                revert ErrLockAmountTooSmall();\n            }\n\n            _userLocks[user].push(LockedBalance({amount: amount, unlockTime: _nextUnlockTime}));\n            lastLockIndex[user] = lockCount;\n\n            unchecked {\n                ++lockCount;\n            }\n        }\n        /// It's the same reward period, so we just add the amount to the current lock\n        else {\n            _userLocks[user][_lastLockIndex].amount += amount;\n        }\n\n        emit LogLocked(user, amount, _nextUnlockTime, lockCount);\n    }\n\n    /// @dev Update the global accumulated rewards from the last update to this point,\n    /// in relation with the `totalSupply`\n    ///\n    /// The idea is to allow everyone that are currently part of that supply to get their allocated\n    /// reward share.\n    ///\n    /// Each user's reward share is taking in account when `rewards[user][token] = _earned(...)`\n    /// is called. And only updated when a user is interacting with `stake`, `lock`, `withdraw`\n    /// or `getRewards`.\n    ///\n    /// Otherwise, if it's yet-to-be-updated, it's going to get considered as part of the pending\n    /// yet-to-receive rewards in the `earned` function.\n    function _updateRewardsGlobal(address token_, uint256 totalSupply_) internal returns (uint256 rewardPerToken_) {\n        uint256 lastTimeRewardApplicable_ = lastTimeRewardApplicable(token_);\n        rewardPerToken_ = _rewardPerToken(token_, lastTimeRewardApplicable_, totalSupply_);\n\n        _rewardData[token_].rewardPerTokenStored = rewardPerToken_;\n        _rewardData[token_].lastUpdateTime = uint248(lastTimeRewardApplicable_); // safe to cast as this will never overflow\n    }\n\n    function _udpateUserRewards(address user_, uint256 balance_, address token_, uint256 rewardPerToken_) internal {\n        rewards[user_][token_] = _earned(user_, balance_, token_, rewardPerToken_);\n        userRewardPerTokenPaid[user_][token_] = rewardPerToken_;\n    }\n\n    /// @dev Simplest version of updating rewards. Mainly used by `notifyRewardAmount`.\n    /// where we don't need to update any particular user but the global state for\n    /// each reward tokens only.\n    function _updateRewards() internal {\n        uint256 totalSupply_ = totalSupply();\n\n        for (uint256 i; i < rewardTokens.length; ) {\n            _updateRewardsGlobal(rewardTokens[i], totalSupply_);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev More gas efficient version of `_updateRewards` when we\n    /// only need to update the rewards for a single user.\n    function _updateRewardsForUser(address user) internal {\n        uint256 balance = balanceOf(user);\n        uint256 totalSupply_ = totalSupply();\n\n        for (uint256 i; i < rewardTokens.length; ) {\n            address token = rewardTokens[i];\n            _udpateUserRewards(user, balance, token, _updateRewardsGlobal(token, totalSupply_));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev `_updateRewardsForUser` for multiple users.\n    function _updateRewardsForUsers(address[] memory users) internal {\n        uint256 totalSupply_ = totalSupply();\n\n        for (uint256 i; i < rewardTokens.length; ) {\n            address token = rewardTokens[i];\n            uint256 rewardPerToken_ = _updateRewardsGlobal(token, totalSupply_);\n\n            // Record each user's rewards\n            for (uint256 j; j < users.length; ) {\n                address user = users[j];\n                _udpateUserRewards(user, balanceOf(user), token, rewardPerToken_);\n\n                unchecked {\n                    ++j;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Claim unlocked rewards or create a new reward lock that\n    // makes them available the next epoch\n    function _getRewards(address user) internal {\n        RewardLock storage _rewardLock = _userRewardLock[user];\n\n        // first ever lock is always expired because `unlockTime` is 0\n        // unlock time is aligned to epoch\n        bool expired = _rewardLock.unlockTime <= block.timestamp;\n\n        // cache the length here since the loop will be modifying the array\n        uint256 rewardItemLength = _rewardLock.items.length;\n\n        // expired lock\n        // existing lock items will be reused\n        if (expired) {\n            _rewardLock.unlockTime = nextEpoch();\n            emit LogRewardLockCreated(user, _rewardLock.unlockTime);\n        }\n\n        for (uint256 i; i < rewardTokens.length; ) {\n            address rewardToken = rewardTokens[i];\n            uint256 rewardAmount = rewards[user][rewardToken];\n\n            // in all scenario, reset the reward amount immediately\n            rewards[user][rewardToken] = 0;\n\n            // don't assume the rewardTokens array is always the same length as the items array\n            // as new reward tokens can be added by the owner\n            if (i < rewardItemLength) {\n                RewardLockItem storage item = _rewardLock.items[i];\n\n                // expired lock, claim existing unlocked rewards if any\n                if (expired) {\n                    uint256 amount = item.amount;\n\n                    // since this current lock is expired and that item index\n                    // matches the reward index, override the current amount\n                    // with the new locked amount.\n                    item.amount = rewardAmount;\n\n                    // use cached amount\n                    if (amount > 0) {\n                        rewardToken.safeTransfer(user, amount);\n                        emit LogRewardPaid(user, rewardToken, amount);\n                    }\n                } else {\n                    // not expired, just add to the existing lock\n                    item.amount += rewardAmount;\n                }\n            }\n            // new reward token, create a new lock item\n            // could mean it's adding to an existing lock or creating a new one\n            else {\n                _userRewardLock[user].items.push(RewardLockItem({token: rewardToken, amount: rewardAmount}));\n            }\n\n            emit LogRewardLocked(user, rewardToken, rewardAmount);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/staking/LockingMultiRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {OperatableV2} from \"mixins/OperatableV2.sol\";\nimport {Pausable} from \"openzeppelin-contracts/security/Pausable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {MathLib} from \"libraries/MathLib.sol\";\n\n/// @notice A staking contract that distributes multiple rewards to stakers.\n/// Stakers can lock their tokens for a period of time to get a boost on their rewards.\n/// @author Based from Curve Finance's MultiRewards contract https://github.com/curvefi/multi-rewards/blob/master/contracts/MultiRewards.sol\n/// @author Based from Ellipsis Finance's EpsStaker https://github.com/ellipsis-finance/ellipsis/blob/master/contracts/EpsStaker.sol\n/// @author Based from Convex Finance's CvxLockerV2 https://github.com/convex-eth/platform/blob/main/contracts/contracts/CvxLockerV2.sol\ncontract LockingMultiRewards is OperatableV2, Pausable {\n    using SafeTransferLib for address;\n\n    event LogRewardAdded(uint256 reward);\n    event LogStaked(address indexed user, uint256 amount);\n    event LogLocked(address indexed user, uint256 amount, uint256 unlockTime, uint256 lockCount);\n    event LogUnlocked(address indexed user, uint256 amount, uint256 index);\n    event LogLockIndexChanged(address indexed user, uint256 fromIndex, uint256 toIndex);\n    event LogWithdrawn(address indexed user, uint256 amount);\n    event LogRewardLockCreated(address indexed user, uint256 unlockTime);\n    event LogRewardLocked(address indexed user, address indexed rewardsToken, uint256 reward);\n    event LogRewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);\n    event LogRewardsDurationUpdated(address token, uint256 newDuration);\n    event LogRecovered(address token, uint256 amount);\n    event LogSetMinLockAmount(uint256 previous, uint256 current);\n\n    error ErrZeroAmount();\n    error ErrRewardAlreadyExists();\n    error ErrInvalidTokenAddress();\n    error ErrMaxUserLocksExceeded();\n    error ErrNotExpired();\n    error ErrInvalidUser();\n    error ErrLockAmountTooSmall();\n    error ErrLengthMismatch();\n    error ErrNoLocks();\n    error ErrLockNotExpired();\n    error ErrMaxRewardsExceeded();\n    error ErrSkimmingTooMuch();\n    error ErrInvalidLockIndex();\n    error ErrNotEnoughReward();\n    error ErrInvalidDurationRatio();\n    error ErrInvalidBoostMultiplier();\n    error ErrInvalidLockDuration();\n    error ErrInvalidRewardDuration();\n    error ErrInsufficientRemainingTime();\n\n    struct Reward {\n        uint256 periodFinish;\n        uint256 rewardRate;\n        uint256 rewardPerTokenStored;\n        bool exists;\n        uint248 lastUpdateTime;\n    }\n\n    struct Balances {\n        uint256 unlocked;\n        uint256 locked;\n    }\n\n    struct LockedBalance {\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    struct RewardLockItem {\n        address token;\n        uint256 amount;\n    }\n\n    struct RewardLock {\n        RewardLockItem[] items;\n        uint256 unlockTime;\n    }\n\n    uint256 private constant BIPS = 10_000;\n    uint256 private constant MAX_NUM_REWARDS = 5;\n    uint256 private constant MIN_LOCK_DURATION = 1 weeks;\n    uint256 private constant MIN_REWARDS_DURATION = 1 days;\n\n    uint256 public immutable maxLocks;\n    uint256 public immutable lockingBoostMultiplerInBips;\n    uint256 public immutable rewardsDuration;\n    uint256 public immutable lockDuration;\n    address public immutable stakingToken;\n\n    mapping(address token => Reward info) private _rewardData;\n    mapping(address user => Balances balances) private _balances;\n    mapping(address user => LockedBalance[] locks) private _userLocks;\n    mapping(address user => RewardLock rewardLock) private _userRewardLock;\n\n    mapping(address user => mapping(address token => uint256 amount)) public userRewardPerTokenPaid;\n    mapping(address user => mapping(address token => uint256 amount)) public rewards;\n    mapping(address user => uint256 index) public lastLockIndex;\n\n    address[] public rewardTokens;\n\n    uint256 public lockedSupply; // all locked boosted deposits\n    uint256 public unlockedSupply; // all unlocked unboosted deposits\n    uint256 public minLockAmount; // minimum amount allowed to lock\n    uint256 public stakingTokenBalance; // total staking token balance\n\n    ///\n    /// @dev Constructor\n    /// @param _stakingToken The token that is being staked\n    /// @param _owner The owner of the contract\n    /// @param _lockingBoostMultiplerInBips The multiplier for the locking boost. 30000 means if you stake 100, you get 300 locked\n    /// @param _rewardsDuration The duration of the rewards period in seconds, should be 7 days by default.\n    /// @param _lockDuration The duration of the lock period in seconds, should be 13 weeks by default.\n    constructor(\n        address _stakingToken,\n        uint256 _lockingBoostMultiplerInBips,\n        uint256 _rewardsDuration,\n        uint256 _lockDuration,\n        address _owner\n    ) OperatableV2(_owner) {\n        if (_lockingBoostMultiplerInBips <= BIPS) {\n            revert ErrInvalidBoostMultiplier();\n        }\n\n        if (_lockDuration < MIN_LOCK_DURATION) {\n            revert ErrInvalidLockDuration();\n        }\n\n        if (_rewardsDuration < MIN_REWARDS_DURATION) {\n            revert ErrInvalidRewardDuration();\n        }\n\n        if (_lockDuration % _rewardsDuration != 0) {\n            revert ErrInvalidDurationRatio();\n        }\n\n        stakingToken = _stakingToken;\n        lockingBoostMultiplerInBips = _lockingBoostMultiplerInBips;\n        rewardsDuration = _rewardsDuration;\n        lockDuration = _lockDuration;\n\n        // kocks are combined into the same `rewardsDuration` epoch. So, if\n        // a user stake with locking every `rewardsDuration` this should reach the\n        // maximum number of possible simultaneous because the first lock gets expired,\n        // freeing up a slot.\n        maxLocks = _lockDuration / _rewardsDuration;\n    }\n\n    /// @notice Stakes the given amount of tokens for the given user.\n    /// @param amount The amount of tokens to stake\n    /// @param lock_ If true, the tokens will be locked for the lock duration for a reward boost\n    function stake(uint256 amount, bool lock_) public whenNotPaused {\n        _stakeFor(msg.sender, amount, lock_);\n    }\n\n    /// @notice Locks an existing unlocked balance.\n    function lock(uint256 amount) public whenNotPaused {\n        if (amount == 0) {\n            revert ErrZeroAmount();\n        }\n\n        _updateRewardsForUser(msg.sender);\n\n        _balances[msg.sender].unlocked -= amount;\n        unlockedSupply -= amount;\n\n        _createLock(msg.sender, amount);\n    }\n\n    /// @notice Withdraws the given amount of unlocked tokens for the given user.\n    /// @param amount The amount of unlocked tokens to withdraw\n    function withdraw(uint256 amount) public virtual {\n        if (amount =="
    }
  ]
}