{
  "Title": "[ACKNOWLEDGED] Configuration addresses are not updatable in `FathomProxyWalletOwner`",
  "Content": "##### Location\nFile | Location | Line\n--- | --- | ---\n[FathomProxyWalletOwner.sol](https://github.com/Into-the-Fathom/fathom-stablecoin-smart-contracts/tree/3768c87367d286ae0e82f444b2f9d760417b507e/contracts/main/fathom-SDK/FathomProxyWalletOwner.sol#L63 \"/contracts/main/fathom-SDK/FathomProxyWalletOwner.sol\" \"/contracts/main/fathom-SDK/FathomProxyWalletOwner.sol\") | contract `FathomProxyWalletOwner` >  `constructor` | 63\n\n##### Description\nIn the `constructor` of the contract `FathomProxyWalletOwner`, several `address` type variables, such as `bookKeeper`, `positionManager`, `collateralTokenAdapter`, `stablecoinAdapter`, and so on, are initialized. These variables represent the contracts of the core structure of the protocol. If some of the addresses will get updated within the contracts of the core system, the wallet will not be able to interact with the updated contracts, such as in the case of the call to [`setCollateralPoolConfig`](https://github.com/Into-the-Fathom/fathom-stablecoin-smart-contracts/blob/3768c87367d286ae0e82f444b2f9d760417b507e/contracts/main/stablecoin-core/BookKeeper.sol#L164) in the `BookKeeper` contract. The owner of the wallet won't be able to update already initialized addresses, which may result in a lock of the funds in the protocol.\n##### Recommendation\nWe recommend adjusting the architecture for changing main contracts of the protocols by implementing a configuration contract with all recent addresses of the protocol and adding a migration mechanism.\n##### Update\n###### Client's response\nWe would like to exclude `FathomProxyWalletOwner` from the audit scope.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/main/stablecoin-core/BookKeeper.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IBookKeeper.sol\";\nimport \"../interfaces/ICagable.sol\";\nimport \"../interfaces/ICollateralPoolConfig.sol\";\nimport \"../interfaces/IAccessControlConfig.sol\";\nimport \"../interfaces/IPausable.sol\";\nimport \"../utils/CommonMath.sol\";\n\n/**\n * @title BookKeeper\n * @notice A contract which acts as a bookkeeper of the Fathom Stablecoin protocol.\n * It has the ability to move collateral tokens and stablecoins within the accounting state variable.\n */\ncontract BookKeeper is IBookKeeper, ICagable, IPausable, CommonMath, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    using Address for address;\n\n    struct Position {\n        uint256 lockedCollateral; // Locked collateral inside this position (used for minting)                  [wad]\n        uint256 debtShare; // The debt share of this position or the share amount of minted Fathom Stablecoin   [wad]\n    }\n\n    mapping(bytes32 => mapping(address => Position)) public override positions; // mapping of all positions by collateral pool id and position address\n    mapping(bytes32 => mapping(address => uint256)) public override collateralToken; // the accounting of collateral token which is deposited into the protocol [wad]\n    mapping(address => uint256) public override stablecoin; // the accounting of the stablecoin that is deposited or has not been withdrawn from the protocol [rad]\n    mapping(address => uint256) public override systemBadDebt; // the bad debt of the system from late liquidation [rad]\n    mapping(bytes32 => uint256) public override poolStablecoinIssued; // the accounting of the stablecoin issued per collateralPool [rad];\n\n    /// @dev This is the mapping which stores the consent or allowance to adjust positions by the position addresses.\n    /// @dev The position address -> The allowance delegate address -> true (1) means allowed or false (0) means not allowed\n    mapping(address => mapping(address => uint256)) public override positionWhitelist;\n\n    uint256 public override totalStablecoinIssued; // Total stable coin issued or total stablecoin in circulation   [rad]\n    uint256 public totalUnbackedStablecoin; // Total unbacked stable coin  [rad]\n    uint256 public totalDebtCeiling; // Total debt ceiling  [rad]\n    uint256 public live; // Active Flag\n    address public override collateralPoolConfig;\n    address public override accessControlConfig;\n\n    event LogSetTotalDebtCeiling(address indexed _caller, uint256 _totalDebtCeiling);\n    event LogSetAccessControlConfig(address indexed _caller, address _accessControlConfig);\n    event LogSetCollateralPoolConfig(address indexed _caller, address _collateralPoolConfig);\n    event LogAdjustPosition(\n        address indexed _caller,\n        bytes32 indexed _collateralPoolId,\n        address indexed _positionAddress,\n        uint256 _lockedCollateral,\n        uint256 _debtShare,\n        uint256 _positionDebtValue,\n        int256 _addCollateral,\n        int256 _addDebtShare\n    );\n    event LogAddCollateral(address indexed _caller, address indexed _usr, int256 _amount);\n    event LogMoveCollateral(address indexed _caller, bytes32 indexed _collateralPoolId, address _src, address indexed _dst, uint256 _amount);\n    event LogMoveStablecoin(address indexed _caller, address _src, address indexed _dst, uint256 _amount);\n    event LogAddToWhitelist(address indexed _user);\n    event LogRemoveFromWhitelist(address indexed _user);\n    event StablecoinIssuedAmount(uint256 _totalStablecoinIssued, bytes32 indexed _collateralPoolId, uint256 _poolStablecoinIssued);\n\n    modifier onlyOwner() {\n        IAccessControlConfig _accessControlConfig = IAccessControlConfig(accessControlConfig);\n        require(_accessControlConfig.hasRole(_accessControlConfig.OWNER_ROLE(), msg.sender), \"!ownerRole\");\n        _;\n    }\n\n    modifier onlyOwnerOrGov() {\n        IAccessControlConfig _accessControlConfig = IAccessControlConfig(accessControlConfig);\n        require(\n            _accessControlConfig.hasRole(_accessControlConfig.OWNER_ROLE(), msg.sender) ||\n                _accessControlConfig.hasRole(_accessControlConfig.GOV_ROLE(), msg.sender),\n            \"!(ownerRole or govRole)\"\n        );\n        _;\n    }\n\n    modifier onlyOwnerOrShowStopper() {\n        IAccessControlConfig _accessControlConfig = IAccessControlConfig(accessControlConfig);\n        require(\n            _accessControlConfig.hasRole(_accessControlConfig.OWNER_ROLE(), msg.sender) ||\n                _accessControlConfig.hasRole(_accessControlConfig.SHOW_STOPPER_ROLE(), msg.sender),\n            \"!(ownerRole or showStopperRole)\"\n        );\n        _;\n    }\n\n    modifier onlyPositionManager() {\n        IAccessControlConfig _accessControlConfig = IAccessControlConfig(accessControlConfig);\n        require(_accessControlConfig.hasRole(_accessControlConfig.POSITION_MANAGER_ROLE(), msg.sender), \"!positionManagerRole\");\n        _;\n    }\n\n    modifier onlyCollateralManager() {\n        IAccessControlConfig _accessControlConfig = IAccessControlConfig(accessControlConfig);\n        require(_accessControlConfig.hasRole(_accessControlConfig.COLLATERAL_MANAGER_ROLE(), msg.sender), \"!collateralManagerRole\");\n        _;\n    }\n\n    modifier onlyLiquidationEngine() {\n        IAccessControlConfig _accessControlConfig = IAccessControlConfig(accessControlConfig);\n        require(_accessControlConfig.hasRole(_accessControlConfig.LIQUIDATION_ENGINE_ROLE(), msg.sender), \"!liquidationEngineRole\");\n        _;\n    }\n\n    modifier onlyMintable() {\n        IAccessControlConfig _accessControlConfig = IAccessControlConfig(accessControlConfig);\n        require(_accessControlConfig.hasRole(_accessControlConfig.MINTABLE_ROLE(), msg.sender), \"!mintableRole\");\n        _;\n    }\n\n    modifier onlyAdapter() {\n        IAccessControlConfig _accessControlConfig = IAccessControlConfig(accessControlConfig);\n        require(_accessControlConfig.hasRole(_accessControlConfig.ADAPTER_ROLE(), msg.sender), \"!adapterRole\");\n        _;\n    }\n\n    modifier onlyStabilityFeeCollector() {\n        IAccessControlConfig _accessControlConfig = IAccessControlConfig(accessControlConfig);\n        require(_accessControlConfig.hasRole(_accessControlConfig.STABILITY_FEE_COLLECTOR_ROLE(), msg.sender), \"!stabilityFeeCollectorRole\");\n        _;\n    }\n\n    // --- Init ---\n\n    function initialize(address _collateralPoolConfig, address _accessControlConfig) external initializer {\n        require(_collateralPoolConfig.isContract(), \"BookKeeper/collateral-pool-config: NOT_CONTRACT_ADDRESS\");\n        require(_accessControlConfig.isContract(), \"BookKeeper/access-control-config: NOT_CONTRACT_ADDRESS\");\n        require(\n            IAccessControlConfig(_accessControlConfig).hasRole(IAccessControlConfig(_accessControlConfig).OWNER_ROLE(), msg.sender),\n            \"BookKeeper/msgsender-not-owner\"\n        ); // Sanity Check Call\n\n        PausableUpgradeable.__Pausable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\n        collateralPoolConfig = _collateralPoolConfig;\n        accessControlConfig = _accessControlConfig;\n        live = 1;\n    }\n\n    // --- Administration ---\n    /// @dev Sets the total debt ceiling of the entire protocol. The totalDebtCeiling is the maximum amount of debt that can be borrowed from the protocol.\n    /// @param _totalDebtCeiling The new total debt ceiling value to be set.\n    function setTotalDebtCeiling(uint256 _totalDebtCeiling) external onlyOwner {\n        _requireLive();\n        totalDebtCeiling = _totalDebtCeiling;\n        emit LogSetTotalDebtCeiling(msg.sender, _totalDebtCeiling);\n    }\n\n    function setAccessControlConfig(address _accessControlConfig) external onlyOwner {\n        require(_accessControlConfig.isContract(), \"BookKeeper/access-control-config: NOT_CONTRACT_ADDRESS\");\n        require(\n            IAccessControlConfig(_accessControlConfig).hasRole(IAccessControlConfig(_accessControlConfig).OWNER_ROLE(), msg.sender),\n            \"BookKeeper/msgsender-not-owner\"\n        );\n        accessControlConfig = _accessControlConfig;\n        emit LogSetAccessControlConfig(msg.sender, _accessControlConfig);\n    }\n\n    function setCollateralPoolConfig(address _collateralPoolConfig) external onlyOwner {\n        require(_collateralPoolConfig.isContract(), \"BookKeeper/collateral-pool-config: NOT_CONTRACT_ADDRESS\");\n\n        collateralPoolConfig = _collateralPoolConfig;\n        emit LogSetCollateralPoolConfig(msg.sender, _collateralPoolConfig);\n    }\n\n    // --- Cage ---\n    /// @dev Cage function halts bookKeeper contract for good.\n    /// Please be cautious with this function since there is no uncage function\n    function cage() external override onlyOwnerOrShowStopper {\n        if (live == 1) {\n            live = 0;\n            emit LogCage();\n        }\n    }\n\n    // --- Pause ---\n    /// @dev access: OWNER_ROLE, GOV_ROLE\n    function pause() external override onlyOwnerOrGov {\n        _pause();\n    }\n\n    /// @dev access: OWNER_ROLE, GOV_ROLE\n    function unpause() external override onlyOwnerOrGov {\n        _unpause();\n    }\n\n    // --- Whitelist ---\n\n    /// @dev Grants an allowance to the `toBeWhitelistedAddress` to adjust the position address of the caller.\n    /// @notice This function can only be called when the BookKeeper contract is not paused.\n    /// @param _toBeWhitelistedAddress The address that is granted permission to adjust the position address of the caller.\n    /// @dev Emits no events.\n    function addToWhitelist(address _toBeWhitelistedAddress) external override whenNotPaused {\n        positionWhitelist[msg.sender][_toBeWhitelistedAddress] = 1;\n        emit LogAddToWhitelist(_toBeWhitelistedAddress);\n    }\n\n    /// @dev Revokes the allowance from the `toBeRemovedAddress` to adjust the position address of the caller.\n    /// @notice This function can only be called when the BookKeeper contract is not paused.\n    /// @param _toBeRemovedAddress The address that is no longer allowed to adjust the position address of the caller.\n    /// @dev Emits no events.\n    function removeFromWhitelist(address _toBeRemovedAddress) external override whenNotPaused {\n        positionWhitelist[msg.sender][_toBeRemovedAddress] = 0;\n        emit LogRemoveFromWhitelist(_toBeRemovedAddress);\n    }\n\n    // --- Core Logic ---\n\n    /// @dev Updates the accounting of collateral tokens deposited by a position in the specified collateral pool.\n    /// @dev Although the second argument is named as _usr, addCollateral is more often used in the context of CDP manipulation, and the _usr address\n    /// often represents the position's address. Refer to deposit function in CollateralTokenAdapter.\n    /// @notice This function can only be called by the Adapter role when the BookKeeper contract is not paused.\n    /// @param _collateralPoolId The ID of the collateral pool in which the position's collateral is being updated.\n    /// @param _usr The address of the position for which collateral is being adjusted.\n    /// @param _amount The amount of collateral being added (positive value) or removed (negative value) from the user's position.\n    /// @dev Emits a LogAddCollateral event to record the change in the position's collateral amount.\n    function addCollateral(bytes32 _collateralPoolId, address _usr, int256 _amount) external override nonReentrant whenNotPaused onlyAdapter {\n        collateralToken[_collateralPoolId][_usr] = add(collateralToken[_collateralPoolId][_usr], _amount);\n        emit LogAddCollateral(msg.sender, _usr, _amount);\n    }\n\n    /// @notice Moves collateral tokens from one address (often a position address) to another in a specified collateral pool.\n    /// @dev This function can only be called by an entity with the Collateral Manager role when the BookKeeper contract is not paused.\n    /// @dev It also requires that the entity making the call has the authority to adjust the position (or any address that holds collateralToken),\n    ///      as determined by `_requireAllowedPositionAdjustment`.\n    /// @param _collateralPoolId The ID of the collateral pool from which the collateral tokens are being moved.\n    /// @param _src The address from which collateral tokens are being moved.\n    /// @param _dst The address to which collateral tokens are being moved.\n    /// @param _amount The amount of collateral tokens being moved from the source to the destination.\n\n    function moveCollateral(\n        bytes32 _collateralPoolId,\n        address _src,\n        address _dst,\n        uint256 _amount\n    ) external override nonReentrant whenNotPaused onlyCollateralManager {\n        require(_amount > 0, \"bookKeeper/moveCollateral-zero-amount\");\n        require(_src != _dst, \"bookKeeper/moveCollateral-src-dst-same\");\n        _requireAllowedPositionAdjustment(_src, msg.sender);\n        collateralToken[_collateralPoolId][_src] -= _amount;\n        collateralToken[_collateralPoolId][_dst] += _amount;\n        emit LogMoveCollateral(msg.sender, _collateralPoolId, _src, _dst, _amount);\n    }\n\n    /// @notice Moves stablecoin from one address to another.\n    /// @dev This function can only be called when the BookKeeper contract is not paused.\n    /// @dev It also requires that the entity making the call is allowed to adjust the position (or any address that holds stablecoin)\n    /// @dev according to `_requireAllowedPositionAdjustment`.\n    /// @param _src The source address from which the stablecoin is being moved.\n    /// @param _dst The destination address to which the stablecoin is being moved.\n    /// @param _value The amount of stablecoin being moved from the source to the destination.\n\n    function moveStablecoin(address _src, address _dst, uint256 _value) external override nonReentrant whenNotPaused {\n        require(_value > 0, \"bookKeeper/moveStablecoin-zero-amount\");\n        require(_src != _dst, \"bookKeeper/moveStablecoin-src-dst-same\");\n        _requireAllowedPositionAdjustment(_src, msg.sender);\n        stablecoin[_src] -= _value;\n        stablecoin[_dst] += _value;\n        emit LogMoveStablecoin(msg.sender, _src, _dst, _value);\n    }\n\n    /// @notice Adjusts the collateral and debt of a position in a specific collateral pool.\n    /// @dev This function can only be called by an entity with the Position Manager role when the BookKeeper contract is not paused and the collateral pool is active.\n    /// @dev It ensures multiple conditions are met regarding debt and collateral values to maintain system stability and safety.\n    /// @param _collateralPoolId The ID of the collateral pool where the position is located.\n    /// @param _positionAddress The address of the position to be adjusted.\n    /// @param _collateralOwner The address of the owner of the collateral. (positionAddress)\n    /// @param _stablecoinOwner The address of the owner of the stablecoin. (positionAddress)\n    /// @param _collateralValue The change in collateral value. This is added to the position's current locked collateral.\n    /// @param _debtShare The change in debt share. This is added to the position's current debt share.\n    // solhint-disable function-max-lines\n    function adjustPosition(\n        bytes32 _collateralPoolId,\n        address _positionAddress,\n        address _collateralOwner,\n        address _stablecoinOwner,\n        int256 _collateralValue,\n        int256 _debtShare\n    ) external override nonReentrant whenNotPaused onlyPositionManager {\n        _requireLive();\n\n        ICollateralPoolConfig.CollateralPoolInfo memory _vars = ICollateralPoolConfig(collateralPoolConfig).getCollateralPoolInfo(_collateralPoolId);\n        require(_vars.debtAccumulatedRate != 0, \"BookKeeper/collateralPool-not-init\");\n\n        Position memory position = positions[_collateralPoolId][_positionAddress];\n        position.lockedCollateral = add(position.lockedCollateral, _collateralValue);\n        position.debtShare = add(position.debtShare, _debtShare);\n        _vars.totalDebtShare = add(_vars.totalDebtShare, _debtShare);\n        ICollateralPoolConfig(collateralPoolConfig).setTotalDebtShare(_collateralPoolId, _vars.totalDebtShare);\n\n        int256 _debtValue = mul(_vars.debtAccumulatedRate, _debtShare);\n        uint256 _positionDebtValue = _vars.debtAccumulatedRate * position.debtShare;\n        totalStablecoinIssued = add(totalStablecoinIssued, _debtValue);\n        uint256 _poolStablecoinAmount = poolStablecoinIssued[_collateralPoolId];\n        poolStablecoinIssued[_collateralPoolId] = add(_poolStablecoinAmount, _debtValue);\n        _poolStablecoinAmount = poolStablecoinIssued[_collateralPoolId];\n        require(\n            either(\n                _debtShare <= 0,\n                both(_vars.totalDebtShare * _vars.debtAccumulatedRate <= _vars.debtCeiling, totalStablecoinIssued <= totalDebtCeiling)\n            ),\n            \"BookKeeper/ceiling-exceeded\"\n        );\n\n        require(\n            either(both(_debtShare <= 0, _collateralValue >= 0), _positionDebtValue <= position.lockedCollateral * _vars.priceWithSafetyMargin),\n            \"BookKeeper/not-safe\"\n        );\n\n        require(either(both(_debtShare <= 0, _collateralValue >= 0), _wish(_positionAddress, msg.sender)), \"BookKeeper/not-allowed-position-address\");\n        require(either(_collateralValue <= 0, _wish(_collateralOwner, msg.sender)), \"BookKeeper/not-allowed-collateral-owner\");\n        require(either(_debtShare >= 0, _wish(_stablecoinOwner, msg.sender)), \"BookKeeper/not-allowed-stablecoin-owner\");\n\n        require(either(position.debtShare == 0, _positionDebtValue >= _vars.debtFloor), \"BookKeeper/debt-floor\");\n        require(_positionDebtValue <= _vars.positionDebtCeiling, \"BookKeeper/position-debt-ceiling-exceeded\");\n        collateralToken[_collateralPoolId][_collateralOwner] = sub(collateralToken[_collateralPoolId][_collateralOwner], _collateralValue);\n        stablecoin[_stablecoinOwner] = add(stablecoin[_stablecoinOwner], _debtValue);\n\n        positions[_collateralPoolId][_positionAddress] = position;\n\n        emit LogAdjustPosition(\n            msg.sender,\n            _collateralPoolId,\n            _positionAddress,\n            position.lockedCollateral,\n            position.debtShare,\n            _positionDebtValue,\n            _collateralValue,\n            _debtShare\n        );\n        emit StablecoinIssuedAmount(\n            totalStablecoinIssued,\n            _collateralPoolId,\n            _poolStablecoinAmount // [rad]\n        );\n    }\n\n    /// @notice Moves collateral and debt from one position to another in a specific collateral pool.\n    /// @dev This function can only be called by an entity with the Position Manager role when the BookKeeper contract is not paused.\n    /// @dev It ensures that the caller is allowed to manipulate both source and destination positions and the positions remain safe after the move.\n    /// @param _collateralPoolId The ID of the collateral pool where the positions are located.\n    /// @param _src The address of the source position from which collateral and debt are being moved.\n    /// @param _dst The address of the destination position to which collateral and debt are being moved.\n    /// @param _collateralAmount The amount of collateral being moved from the source to the destination position.\n    /// @param _debtShare The amount of debt share being moved from the source to the destination position.\n    // solhint-enable function-max-lines\n    function movePosition(\n        bytes32 _collateralPoolId,\n        address _src,\n        address _dst,\n        int256 _collateralAmount,\n        int256 _debtShare\n    ) external override nonReentrant whenNotPaused onlyPositionManager {\n        Position storage _positionSrc = positions[_collateralPoolId][_src];\n        Position storage _positionDst = positions[_collateralPoolId][_dst];\n\n        ICollateralPoolConfig.CollateralPoolInfo memory _vars = ICollateralPoolConfig(collateralPoolConfig).getCollateralPoolInfo(_collateralPoolId);\n\n        _positionSrc.lockedCollateral = sub(_positionSrc.lockedCollateral, _collateralAmount);\n        _positionSrc.debtShare = sub(_positionSrc.debtShare, _debtShare);\n        _positionDst.lockedCollateral = add(_positionDst.lockedCollateral, _collateralAmount);\n        _positionDst.debtShare = add(_positionDst.debtShare, _debtShare);\n\n        uint256 _utab = _positionSrc.debtShare * _vars.debtAccumulatedRate;\n        uint256 _vtab = _positionDst.debtShare * _vars.debtAccumulatedRate;\n\n        require(both(_wish(_src, msg.sender), _wish(_dst, msg.sender)), \"BookKeeper/movePosition/not-allowed\");\n\n        require(_utab <= _positionSrc.lockedCollateral * _vars.priceWithSafetyMargin, \"BookKeeper/not-safe-src\");\n        require(_vtab <= _positionDst.lockedCollateral * _vars.priceWithSafetyMargin, \"BookKeeper/not-safe-dst\");\n\n        require(either(_utab >= _vars.debtFloor, _positionSrc.debtShare == 0), \"BookKeeper/debt-floor-src\");\n        require(either(_vtab >= _vars.debtFloor, _positionDst.debtShare == 0), \"BookKeeper/debt-floor-dst\");\n\n        require(_vtab <= _vars.positionDebtCeiling, \"BookKeeper/position-debt-ceiling-exceeded-dst\");\n    }\n\n    /// @notice Confiscates a position for liquidation. It seizes collateral and marks a debt.\n    /// @dev This function can only be called by an entity with the Liquidation Engine role when the BookKeeper contract is not paused.\n    /// @dev The seized collateral will be transferred to the Auctioneer contracts and later moved to the corresponding liquidator addresses.\n    /// @dev The stablecoin debt will be initially marked in the SystemDebtEngine contract and will be cleared later on from a successful liquidation.\n    /// @dev If the debt is not fully liquidated, the remaining debt will stay inside SystemDebtEngine as bad debt.\n    /// @param _collateralPoolId The ID of the collateral pool where the positions are located.\n    /// @param _positionAddress The address of the position from which collateral and debt are being confiscated.\n    /// @param _collateralCreditor The address where confiscated collateral will be transferred.\n    /// @param _stablecoinDebtor The address from which the stablecoin debt is being confiscated.\n    /// @param _collateralAmount The amount of collateral being confiscated from the position.\n    /// @param _debtShare The amount of debt share being confiscated from the position.\n    function confiscatePosition(\n        bytes32 _collateralPoolId,\n        address _positionAddress,\n        address _collateralCreditor,\n        address _stablecoinDebtor,\n        int256 _collateralAmount,\n        int256 _debtShare\n    ) external override nonReentrant whenNotPaused onlyLiquidationEngine {\n        Position storage position = positions[_collateralPoolId][_positionAddress];\n        ICollateralPoolConfig.CollateralPoolInfo memory _vars = ICollateralPoolConfig(collateralPoolConfig).getCollateralPoolInfo(_collateralPoolId);\n        // -- col from position\n        position.lockedCollateral = add(position.lockedCollateral, _collateralAmount);\n        // -- debt from position\n        position.debtShare = add(position.debtShare, _debtShare);\n        _vars.totalDebtShare = add(_vars.totalDebtShare, _debtShare);\n        ICollateralPoolConfig(collateralPoolConfig).setTotalDebtShare(_collateralPoolId, _vars.totalDebtShare);\n\n        int256 _debtValue = mul(_vars.debtAccumulatedRate, _debtShare);\n\n        uint256 _poolStablecoinAmount = poolStablecoinIssued[_collateralPoolId];\n        poolStablecoinIssued[_collateralPoolId] = add(_poolStablecoinAmount, _debtValue);\n        // ++ col to _collateralCreditor(showStopper in case of skim/accumulateBadDebt)\n        collateralToken[_collateralPoolId][_collateralCreditor] = sub(collateralToken[_collateralPoolId][_collateralCreditor], _collateralAmount);\n        // ++ debt to systemDebtEngine\n        systemBadDebt[_stablecoinDebtor] = sub(systemBadDebt[_stablecoinDebtor], _debtValue);\n        totalUnbackedStablecoin = sub(totalUnbackedStablecoin, _debtValue);\n    }\n\n    /// @notice Settles the system's bad debt of the caller.\n    /// @dev This function can be called by the SystemDebtEngine, which incurs the system debt. The BookKeeper contract must not be paused.\n    /// @dev Even though the function has no modifier that restricts access exclusively to SystemDebtEngine,\n    ///      the action of the function—reducing the systemBadDebt of msg.sender—effectively limits the function callers to SystemDebtEngine.\n    /// @dev To execute this function, the SystemDebtEngine must have enough stablecoin, which typically comes from the protocol's surplus.\n    /// @dev A successful execution of this function removes the bad debt from the system.\n    /// @param _value The amount of bad debt to be settled.\n    ////\n    function settleSystemBadDebt(uint256 _value) external override nonReentrant whenNotPaused {\n        systemBadDebt[msg.sender] -= _value;\n        stablecoin[msg.sender] -= _value;\n        totalUnbackedStablecoin -= _value;\n        totalStablecoinIssued -= _value;\n    }\n\n    /// @notice Mints unbacked stablecoin.\n    /// @dev This function can only be called by the Mintable role when the BookKeeper contract is not paused.\n    /// @dev It also requires the system to be live.\n    /// @param _from The address from which the unbacked stablecoin is being minted.\n    /// @param _to The address to which the unbacked stablecoin is being minted.\n    /// @param _value The amount of unbacked stablecoin to mint.\n    function mintUnbackedStablecoin(address _from, address _to, uint256 _value) external override nonReentrant whenNotPaused onlyMintable {\n        require(_value > 0, \"bookKeeper/mintUnbackedStablecoin-zero-amount\");\n        _requireLive();\n        require(_from != address(0) && _to != address(0), \"BookKeeper/zero-address\");\n        systemBadDebt[_from] += _value;\n        stablecoin[_to] += _value;\n        totalUnbackedStablecoin += _value;\n        totalStablecoinIssued += _value;\n    }\n\n    /// @notice Accrue stability fee for a specific collateral pool.\n    /// @dev This function can only be called by the StabilityFeeCollector role when the BookKeeper contract is not paused.\n    /// @dev It also requires the system to be live.\n    /// @param _collateralPoolId The ID of the collateral pool where the stability fee is being accrued.\n    /// @param _stabilityFeeRecipient The address that will receive the accrued stability fee.\n    /// @param _debtAccumulatedRate The debt accumulation rate used in the calculation of the stability fee.\n    function accrueStabilityFee(\n        bytes32 _collateralPoolId,\n        address _stabilityFeeRecipient,\n        int256 _debtAccumulatedRate\n    ) external override nonReentrant whenNotPaused onlyStabilityFeeCollector {\n        _requireLive();\n\n        ICollateralPoolConfig.CollateralPoolInfo memory _vars = ICollateralPoolConfig(collateralPoolConfig).getCollateralPoolInfo(_collateralPoolId);\n\n        _vars.debtAccumulatedRate = add(_vars.debtAccumulatedRate, _debtAccumulatedRate);\n        ICollateralPoolConfig(collateralPoolConfig).setDebtAccumulatedRate(_collateralPoolId, _vars.debtAccumulatedRate);\n        int256 _value = mul(_vars.totalDebtShare, _debtAccumulatedRate); // [rad]\n\n        uint256 _poolStablecoinAmount = poolStablecoinIssued[_collateralPoolId];\n        poolStablecoinIssued[_collateralPoolId] = add(_poolStablecoinAmount, _value);\n\n        stablecoin[_stabilityFeeRecipient] = add(stablecoin[_stabilityFeeRecipient], _value);\n        totalStablecoinIssued = add(totalStablecoinIssued, _value);\n    }\n\n    function _requireLive() internal view {\n        require(live == 1, \"BookKeeper/not-live\");\n    }\n\n    function _requireAllowedPositionAdjustment(address _positionAddress, address _usr) internal view {\n        require(_wish(_positionAddress, _usr), \"BookKeeper/not-allowed-position-adjustment\");\n    }\n\n    /// @dev Check if the `usr` address is allowed to adjust the position address (`bit`).\n    /// @param bit The position address\n    /// @param usr The address to be checked for permission\n    function _wish(address bit, address usr) internal view returns (bool) {\n        return either(bit == usr, positionWhitelist[bit][usr] == 1);\n    }\n}"
    }
  ]
}