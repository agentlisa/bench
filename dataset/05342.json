{
  "Title": "[G-15] Move lesser gas costing require checks to the top",
  "Content": "Require() or revert() statements that check input arguments or cost lesser gas should be at the top of the function.\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting alot of gas in a function that may ultimately revert in the unhappy case.\n\n### 31 Instances\n\n<Details>\n\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/OLAS.sol#L44-#L50\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/OLAS.sol#L59-#L65\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/veOLAS.sol#L377-#L394\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/veOLAS.sol#L435-#L454\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/veOLAS.sol#L458-#L479\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/veOLAS.sol#L483-#L507\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/FxGovernorTunnel.sol#L114-#L123\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/HomeMediator.sol#L112-#L122\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/BridgedERC20.sol#30-#L43\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericRegistry.sol#L37-#L50\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericRegistry.sol#L54-#L66\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericRegistry.sol#L78-#L91\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/UnitRegistry.sol#L121-#L147\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericManager.sol#L20-#L33\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L123-#L136\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L143-#L159\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L163-#L173\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L183-#L236\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Dispenser.sol#L46-#L59\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Dispenser.sol#L64-#L80\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Dispenser.sol#L36-#L49\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Dispenser.sol#L56-#L77\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L384-#L400\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L404-#L417\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L423-#L444\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L450-#L469\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L1085-#L1151\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L156-#L177\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L182-#L200\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L313-#L371\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L487-#L503\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "governance/contracts/OLAS.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as a manager.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @title OLAS - Smart contract for the OLAS token.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract OLAS is ERC20 {\n    event MinterUpdated(address indexed minter);\n    event OwnerUpdated(address indexed owner);\n\n    // One year interval\n    uint256 public constant oneYear = 1 days * 365;\n    // Total supply cap for the first ten years (one billion OLAS tokens)\n    uint256 public constant tenYearSupplyCap = 1_000_000_000e18;\n    // Maximum annual inflation after first ten years\n    uint256 public constant maxMintCapFraction = 2;\n    // Initial timestamp of the token deployment\n    uint256 public immutable timeLaunch;\n\n    // Owner address\n    address public owner;\n    // Minter address\n    address public minter;\n\n    constructor() ERC20(\"Autonolas\", \"OLAS\", 18) {\n        owner = msg.sender;\n        minter = msg.sender;\n        timeLaunch = block.timestamp;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes the minter address.\n    /// @param newMinter Address of a new minter.\n    function changeMinter(address newMinter) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newMinter == address(0)) {\n            revert ZeroAddress();\n        }\n\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    /// @dev Mints OLAS tokens.\n    /// @notice If the inflation control does not pass, the revert does not take place, as well as no action is performed.\n    /// @param account Account address.\n    /// @param amount OLAS token amount.\n    function mint(address account, uint256 amount) external {\n        // Access control\n        if (msg.sender != minter) {\n            revert ManagerOnly(msg.sender, minter);\n        }\n\n        // Check the inflation schedule and mint\n        if (inflationControl(amount)) {\n            _mint(account, amount);\n        }\n    }\n\n    /// @dev Provides various checks for the inflation control.\n    /// @notice The `<=` check is left as is for a better code readability.\n    /// @param amount Amount of OLAS to mint.\n    /// @return True if the amount request is within inflation boundaries.\n    function inflationControl(uint256 amount) public view returns (bool) {\n        uint256 remainder = inflationRemainder();\n        return (amount <= remainder);\n    }\n\n    /// @dev Gets the reminder of OLAS possible for the mint.\n    /// @return remainder OLAS token remainder.\n    function inflationRemainder() public view returns (uint256 remainder) {\n        uint256 _totalSupply = totalSupply;\n        // Current year\n        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;\n        // Calculate maximum mint amount to date\n        uint256 supplyCap = tenYearSupplyCap;\n        // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n        if (numYears > 9) {\n            // Number of years after ten years have passed (including ongoing ones)\n            numYears -= 9;\n            for (uint256 i = 0; i < numYears; ++i) {\n                supplyCap += (supplyCap * maxMintCapFraction) / 100;\n            }\n        }\n        // Check for the requested mint overflow\n        remainder = supplyCap - _totalSupply;\n    }\n\n    /// @dev Burns OLAS tokens.\n    /// @param amount OLAS token amount to burn.\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    /// @dev Decreases the allowance of another account over their tokens.\n    /// @notice This implementation does not decrease spender allowance if the maximum allowance was granted.\n    /// @notice The underflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to decrease approval by.\n    /// @return True if the operation succeeded.\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        if (spenderAllowance != type(uint256).max) {\n            spenderAllowance -= amount;\n            allowance[msg.sender][spender] = spenderAllowance;\n            emit Approval(msg.sender, spender, spenderAllowance);\n        }\n\n        return true;\n    }\n\n    /// @dev Increases the allowance of another account over their tokens.\n    /// @notice The overflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to increase approval by.\n    /// @return True if the operation succeeded.\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        spenderAllowance += amount;\n        allowance[msg.sender][spender] = spenderAllowance;\n        emit Approval(msg.sender, spender, spenderAllowance);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "governance/contracts/OLAS.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as a manager.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @title OLAS - Smart contract for the OLAS token.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract OLAS is ERC20 {\n    event MinterUpdated(address indexed minter);\n    event OwnerUpdated(address indexed owner);\n\n    // One year interval\n    uint256 public constant oneYear = 1 days * 365;\n    // Total supply cap for the first ten years (one billion OLAS tokens)\n    uint256 public constant tenYearSupplyCap = 1_000_000_000e18;\n    // Maximum annual inflation after first ten years\n    uint256 public constant maxMintCapFraction = 2;\n    // Initial timestamp of the token deployment\n    uint256 public immutable timeLaunch;\n\n    // Owner address\n    address public owner;\n    // Minter address\n    address public minter;\n\n    constructor() ERC20(\"Autonolas\", \"OLAS\", 18) {\n        owner = msg.sender;\n        minter = msg.sender;\n        timeLaunch = block.timestamp;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes the minter address.\n    /// @param newMinter Address of a new minter.\n    function changeMinter(address newMinter) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newMinter == address(0)) {\n            revert ZeroAddress();\n        }\n\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    /// @dev Mints OLAS tokens.\n    /// @notice If the inflation control does not pass, the revert does not take place, as well as no action is performed.\n    /// @param account Account address.\n    /// @param amount OLAS token amount.\n    function mint(address account, uint256 amount) external {\n        // Access control\n        if (msg.sender != minter) {\n            revert ManagerOnly(msg.sender, minter);\n        }\n\n        // Check the inflation schedule and mint\n        if (inflationControl(amount)) {\n            _mint(account, amount);\n        }\n    }\n\n    /// @dev Provides various checks for the inflation control.\n    /// @notice The `<=` check is left as is for a better code readability.\n    /// @param amount Amount of OLAS to mint.\n    /// @return True if the amount request is within inflation boundaries.\n    function inflationControl(uint256 amount) public view returns (bool) {\n        uint256 remainder = inflationRemainder();\n        return (amount <= remainder);\n    }\n\n    /// @dev Gets the reminder of OLAS possible for the mint.\n    /// @return remainder OLAS token remainder.\n    function inflationRemainder() public view returns (uint256 remainder) {\n        uint256 _totalSupply = totalSupply;\n        // Current year\n        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;\n        // Calculate maximum mint amount to date\n        uint256 supplyCap = tenYearSupplyCap;\n        // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n        if (numYears > 9) {\n            // Number of years after ten years have passed (including ongoing ones)\n            numYears -= 9;\n            for (uint256 i = 0; i < numYears; ++i) {\n                supplyCap += (supplyCap * maxMintCapFraction) / 100;\n            }\n        }\n        // Check for the requested mint overflow\n        remainder = supplyCap - _totalSupply;\n    }\n\n    /// @dev Burns OLAS tokens.\n    /// @param amount OLAS token amount to burn.\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    /// @dev Decreases the allowance of another account over their tokens.\n    /// @notice This implementation does not decrease spender allowance if the maximum allowance was granted.\n    /// @notice The underflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to decrease approval by.\n    /// @return True if the operation succeeded.\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        if (spenderAllowance != type(uint256).max) {\n            spenderAllowance -= amount;\n            allowance[msg.sender][spender] = spenderAllowance;\n            emit Approval(msg.sender, spender, spenderAllowance);\n        }\n\n        return true;\n    }\n\n    /// @dev Increases the allowance of another account over their tokens.\n    /// @notice The overflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to increase approval by.\n    /// @return True if the operation succeeded.\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        spenderAllowance += amount;\n        allowance[msg.sender][spender] = spenderAllowance;\n        emit Approval(msg.sender, spender, spenderAllowance);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "governance/contracts/veOLAS.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"./interfaces/IErrors.sol\";\n\n/**\nVotes have a weight depending on time, so that users are committed to the future of (whatever they are voting for).\nVote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (4 years).\nVoting escrow has time-weighted votes derived from the amount of tokens locked. The maximum voting power can be\nachieved with the longest lock possible. This way the users are incentivized to lock tokens for more time.\n# w ^ = amount * time_locked / MAXTIME\n# 1 +        /\n#   |      /\n#   |    /\n#   |  /\n#   |/\n# 0 +--------+------> time\n#       maxtime (4 years?)\n\nWe cannot really do block numbers per se because slope is per time, not per block, and per block could be fairly bad\nbecause Ethereum changes its block times. What we can do is to extrapolate ***At functions.\n*/\n\n/// @title Voting Escrow OLAS - the workflow is ported from Curve Finance Vyper implementation\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\n/// Code ported from: https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy\n/// and: https://github.com/solidlyexchange/solidly/blob/master/contracts/ve.sol\n\n/* This VotingEscrow is based on the OLAS token that has the following specifications:\n*  - For the first 10 years there will be the cap of 1 billion (1e27) tokens;\n*  - After 10 years, the inflation rate is 2% per year.\n* The maximum number of tokens for each year then can be calculated from the formula: 2^n = 1e27 * (1.02)^x,\n* where n is the specified number of bits that is sufficient to store and not overflow the total supply,\n* and x is the number of years. We limit n by 128, thus it would take 1340+ years to reach that total supply.\n* The amount for each locker is eventually cannot overcome this number as well, and thus uint128 is sufficient.\n*\n* We then limit the time in seconds to last until the value of 2^64 - 1, or for the next 583+ billion years.\n* The number of blocks is essentially cannot be bigger than the number of seconds, and thus it is safe to assume\n* that uint64 for the number of blocks is also sufficient.\n*\n* We also limit the individual deposit amount to be no bigger than 2^96 - 1, or the value of total supply in 220+ years.\n* This limitation is dictated by the fact that there will be at least several accounts with locked tokens, and the\n* sum of all of them cannot be bigger than the total supply. Checking the limit of deposited / increased amount\n* allows us to perform the unchecked operation on adding the amounts.\n*\n* The rest of calculations throughout the contract do not go beyond specified limitations. The contract was checked\n* by echidna and the results can be found in the audit section of the repository.\n*\n* These specified limits allowed us to have storage-added structs to be bound by 2*256 and 1*256 bit sizes\n* respectively, thus limiting the gas amount compared to using bigger variable sizes.\n*\n* Note that after 220 years it is no longer possible to deposit / increase the locked amount to be bigger than 2^96 - 1.\n* It is going to be not safe to use this contract for governance after 1340 years.\n*/\n\n// Struct for storing balance and unlock time\n// The struct size is one storage slot of uint256 (128 + 64 + padding)\nstruct LockedBalance {\n    // Token amount. It will never practically be bigger. Initial OLAS cap is 1 bn tokens, or 1e27.\n    // After 10 years, the inflation rate is 2% per year. It would take 1340+ years to reach 2^128 - 1\n    uint128 amount;\n    // Unlock time. It will never practically be bigger\n    uint64 endTime;\n}\n\n// Structure for voting escrow points\n// The struct size is two storage slots of 2 * uint256 (128 + 128 + 64 + 64 + 128)\nstruct PointVoting {\n    // w(i) = at + b (bias)\n    int128 bias;\n    // dw / dt = a (slope)\n    int128 slope;\n    // Timestamp. It will never practically be bigger than 2^64 - 1\n    uint64 ts;\n    // Block number. It will not be bigger than the timestamp\n    uint64 blockNumber;\n    // Token amount. It will never practically be bigger. Initial OLAS cap is 1 bn tokens, or 1e27.\n    // After 10 years, the inflation rate is 2% per year. It would take 1340+ years to reach 2^128 - 1\n    uint128 balance;\n}\n\n/// @notice This token supports the ERC20 interface specifications except for transfers and approvals.\ncontract veOLAS is IErrors, IVotes, IERC20, IERC165 {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    event Deposit(address indexed account, uint256 amount, uint256 locktime, DepositType depositType, uint256 ts);\n    event Withdraw(address indexed account, uint256 amount, uint256 ts);\n    event Supply(uint256 previousSupply, uint256 currentSupply);\n\n    // 1 week time\n    uint64 internal constant WEEK = 1 weeks;\n    // Maximum lock time (4 years)\n    uint256 internal constant MAXTIME = 4 * 365 * 86400;\n    // Maximum lock time (4 years) in int128\n    int128 internal constant IMAXTIME = 4 * 365 * 86400;\n    // Number of decimals\n    uint8 public constant decimals = 18;\n\n    // Token address\n    address public immutable token;\n    // Total token supply\n    uint256 public supply;\n    // Mapping of account address => LockedBalance\n    mapping(address => LockedBalance) public mapLockedBalances;\n\n    // Total number of economical checkpoints (starting from zero)\n    uint256 public totalNumPoints;\n    // Mapping of point Id => point\n    mapping(uint256 => PointVoting) public mapSupplyPoints;\n    // Mapping of account address => PointVoting[point Id]\n    mapping(address => PointVoting[]) public mapUserPoints;\n    // Mapping of time => signed slope change\n    mapping(uint64 => int128) public mapSlopeChanges;\n\n    // Voting token name\n    string public name;\n    // Voting token symbol\n    string public symbol;\n\n    /// @dev Contract constructor\n    /// @param _token Token address.\n    /// @param _name Token name.\n    /// @param _symbol Token symbol.\n    constructor(address _token, string memory _name, string memory _symbol)\n    {\n        token = _token;\n        name = _name;\n        symbol = _symbol;\n        // Create initial point such that default timestamp and block number are not zero\n        // See cast specification in the PointVoting structure\n        mapSupplyPoints[0] = PointVoting(0, 0, uint64(block.timestamp), uint64(block.number), 0);\n    }\n\n    /// @dev Gets the most recently recorded user point for `account`.\n    /// @param account Account address.\n    /// @return pv Last checkpoint.\n    function getLastUserPoint(address account) external view returns (PointVoting memory pv) {\n        uint256 lastPointNumber = mapUserPoints[account].length;\n        if (lastPointNumber > 0) {\n            pv = mapUserPoints[account][lastPointNumber - 1];\n        }\n    }\n\n    /// @dev Gets the number of user points.\n    /// @param account Account address.\n    /// @return accountNumPoints Number of user points.\n    function getNumUserPoints(address account) external view returns (uint256 accountNumPoints) {\n        accountNumPoints = mapUserPoints[account].length;\n    }\n\n    /// @dev Gets the checkpoint structure at number `idx` for `account`.\n    /// @notice The out of bound condition is treated by the default code generation check.\n    /// @param account User wallet address.\n    /// @param idx User point number.\n    /// @return The requested checkpoint.\n    function getUserPoint(address account, uint256 idx) external view returns (PointVoting memory) {\n        return mapUserPoints[account][idx];\n    }\n\n    /// @dev Record global and per-user data to checkpoint.\n    /// @param account Account address. User checkpoint is skipped if the address is zero.\n    /// @param oldLocked Previous locked amount / end lock time for the user.\n    /// @param newLocked New locked amount / end lock time for the user.\n    /// @param curSupply Current total supply (to avoid using a storage total supply variable)\n    function _checkpoint(\n        address account,\n        LockedBalance memory oldLocked,\n        LockedBalance memory newLocked,\n        uint128 curSupply\n    ) internal {\n        PointVoting memory uOld;\n        PointVoting memory uNew;\n        int128 oldDSlope;\n        int128 newDSlope;\n        uint256 curNumPoint = totalNumPoints;\n\n        if (account != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (oldLocked.endTime > block.timestamp && oldLocked.amount > 0) {\n                uOld.slope = int128(oldLocked.amount) / IMAXTIME;\n                uOld.bias = uOld.slope * int128(uint128(oldLocked.endTime - uint64(block.timestamp)));\n            }\n            if (newLocked.endTime > block.timestamp && newLocked.amount > 0) {\n                uNew.slope = int128(newLocked.amount) / IMAXTIME;\n                uNew.bias = uNew.slope * int128(uint128(newLocked.endTime - uint64(block.timestamp)));\n            }\n\n            // Reads values of scheduled changes in the slope\n            // oldLocked.endTime can be in the past and in the future\n            // newLocked.endTime can ONLY be in the FUTURE unless everything is expired: then zeros\n            oldDSlope = mapSlopeChanges[oldLocked.endTime];\n            if (newLocked.endTime > 0) {\n                if (newLocked.endTime == oldLocked.endTime) {\n                    newDSlope = oldDSlope;\n                } else {\n                    newDSlope = mapSlopeChanges[newLocked.endTime];\n                }\n            }\n        }\n\n        PointVoting memory lastPoint;\n        if (curNumPoint > 0) {\n            lastPoint = mapSupplyPoints[curNumPoint];\n        } else {\n            // If no point is created yet, we take the actual time and block parameters\n            lastPoint = PointVoting(0, 0, uint64(block.timestamp), uint64(block.number), 0);\n        }\n        uint64 lastCheckpoint = lastPoint.ts;\n        // initialPoint is used for extrapolation to calculate the block number and save them\n        // as we cannot figure that out in exact values from inside of the contract\n        PointVoting memory initialPoint = lastPoint;\n        uint256 block_slope; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            // This 1e18 multiplier is needed for the numerator to be bigger than the denominator\n            // We need to calculate this in > uint64 size (1e18 is > 2^59 multiplied by 2^64).\n            block_slope = (1e18 * uint256(block.number - lastPoint.blockNumber)) / uint256(block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope == 0, but we know the block already in this case\n        // Go over weeks to fill in the history and (or) calculate what the current point is\n        {\n            // The timestamp is rounded by a week and < 2^64-1\n            uint64 tStep = (lastCheckpoint / WEEK) * WEEK;\n            for (uint256 i = 0; i < 255; ++i) {\n                // Hopefully it won't happen that this won't get used in 5 years!\n                // If it does, users will be able to withdraw but vote weight will be broken\n                // This is always practically < 2^64-1\n                unchecked {\n                    tStep += WEEK;\n                }\n                int128 dSlope;\n                if (tStep > block.timestamp) {\n                    tStep = uint64(block.timestamp);\n                } else {\n                    dSlope = mapSlopeChanges[tStep];\n                }\n                lastPoint.bias -= lastPoint.slope * int128(int64(tStep - lastCheckpoint));\n                lastPoint.slope += dSlope;\n                if (lastPoint.bias < 0) {\n                    // This could potentially happen, but fuzzer didn't find available \"real\" combinations\n                    lastPoint.bias = 0;\n                }\n                if (lastPoint.slope < 0) {\n                    // This cannot happen - just in case. Again, fuzzer didn't reach this\n                    lastPoint.slope = 0;\n                }\n                lastCheckpoint = tStep;\n                lastPoint.ts = tStep;\n                // After division by 1e18 the uint64 size can be reclaimed\n                lastPoint.blockNumber = initialPoint.blockNumber + uint64((block_slope * uint256(tStep - initialPoint.ts)) / 1e18);\n                lastPoint.balance = initialPoint.balance;\n                // In order for the overflow of total number of economical checkpoints (starting from zero)\n                // The _checkpoint() call must happen n >(2^256 -1)/255 or n > ~1e77/255 > ~1e74 times\n                unchecked {\n                    curNumPoint += 1;    \n                }\n                if (tStep == block.timestamp) {\n                    lastPoint.blockNumber = uint64(block.number);\n                    lastPoint.balance = curSupply;\n                    break;\n                } else {\n                    mapSupplyPoints[curNumPoint] = lastPoint;\n                }\n            }\n        }\n\n        totalNumPoints = curNumPoint;\n\n        // Now mapSupplyPoints is filled until current time\n        if (account != address(0)) {\n            // If last point was in this block, the slope change has been already applied. In such case we have 0 slope(s)\n            lastPoint.slope += (uNew.slope - uOld.slope);\n            lastPoint.bias += (uNew.bias - uOld.bias);\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n        }\n\n        // Record the last updated point\n        mapSupplyPoints[curNumPoint] = lastPoint;\n\n        if (account != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [newLocked.endTime]\n            // and add old_user_slope to [oldLocked.endTime]\n            if (oldLocked.endTime > block.timestamp) {\n                // oldDSlope was <something> - uOld.slope, so we cancel that\n                oldDSlope += uOld.slope;\n                if (newLocked.endTime == oldLocked.endTime) {\n                    oldDSlope -= uNew.slope; // It was a new deposit, not extension\n                }\n                mapSlopeChanges[oldLocked.endTime] = oldDSlope;\n            }\n\n            if (newLocked.endTime > block.timestamp && newLocked.endTime > oldLocked.endTime) {\n                newDSlope -= uNew.slope; // old slope disappeared at this point\n                mapSlopeChanges[newLocked.endTime] = newDSlope;\n                // else: we recorded it already in oldDSlope\n            }\n            // Now handle user history\n            uNew.ts = uint64(block.timestamp);\n            uNew.blockNumber = uint64(block.number);\n            uNew.balance = newLocked.amount;\n            mapUserPoints[account].push(uNew);\n        }\n    }\n\n    /// @dev Record global data to checkpoint.\n    function checkpoint() external {\n        _checkpoint(address(0), LockedBalance(0, 0), LockedBalance(0, 0), uint128(supply));\n    }\n\n    /// @dev Deposits and locks tokens for a specified account.\n    /// @param account Target address for the locked amount.\n    /// @param amount Amount to deposit.\n    /// @param unlockTime New time when to unlock the tokens, or 0 if unchanged.\n    /// @param lockedBalance Previous locked amount / end time.\n    /// @param depositType Deposit type.\n    function _depositFor(\n        address account,\n        uint256 amount,\n        uint256 unlockTime,\n        LockedBalance memory lockedBalance,\n        DepositType depositType\n    ) internal {\n        uint256 supplyBefore = supply;\n        uint256 supplyAfter;\n        // Cannot overflow because the total supply << 2^128-1\n        unchecked {\n            supplyAfter = supplyBefore + amount;\n            supply = supplyAfter;\n        }\n        // Get the old locked data\n        LockedBalance memory oldLocked;\n        (oldLocked.amount, oldLocked.endTime) = (lockedBalance.amount, lockedBalance.endTime);\n        // Adding to the existing lock, or if a lock is expired - creating a new one\n        // This cannot be larger than the total supply\n        unchecked {\n            lockedBalance.amount += uint128(amount);\n        }\n        if (unlockTime > 0) {\n            lockedBalance.endTime = uint64(unlockTime);\n        }\n        mapLockedBalances[account] = lockedBalance;\n\n        // Possibilities:\n        // Both oldLocked.endTime could be current or expired (>/< block.timestamp)\n        // amount == 0 (extend lock) or amount > 0 (add to lock or extend lock)\n        // lockedBalance.endTime > block.timestamp (always)\n        _checkpoint(account, oldLocked, lockedBalance, uint128(supplyAfter));\n        if (amount > 0) {\n            // OLAS is a solmate-based ERC20 token with optimized transferFrom() that either returns true or reverts\n            IERC20(token).transferFrom(msg.sender, address(this), amount);\n        }\n\n        emit Deposit(account, amount, lockedBalance.endTime, depositType, block.timestamp);\n        emit Supply(supplyBefore, supplyAfter);\n    }\n\n    /// @dev Deposits `amount` tokens for `account` and adds to the lock.\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user.\n    /// @param account Account address.\n    /// @param amount Amount to add.\n    function depositFor(address account, uint256 amount) external {\n        LockedBalance memory lockedBalance = mapLockedBalances[account];\n        // Check if the amount is zero\n        if (amount == 0) {\n            revert ZeroValue();\n        }\n        // The locked balance must already exist\n        if (lockedBalance.amount == 0) {\n            revert NoValueLocked(account);\n        }\n        // Check the lock expiry\n        if (lockedBalance.endTime < (block.timestamp + 1)) {\n            revert LockExpired(msg.sender, lockedBalance.endTime, block.timestamp);\n        }\n        // Since in the _depositFor() we have the unchecked sum of amounts, this is needed to prevent unsafe behavior.\n        // After 10 years, the inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1 total supply\n        if (amount > type(uint96).max) {\n            revert Overflow(amount, type(uint96).max);\n        }\n\n        _depositFor(account, amount, 0, lockedBalance, DepositType.DEPOSIT_FOR_TYPE);\n    }\n\n    /// @dev Deposits `amount` tokens for `msg.sender` and locks for `unlockTime`.\n    /// @param amount Amount to deposit.\n    /// @param unlockTime Time when tokens unlock, rounded down to a whole week.\n    function createLock(uint256 amount, uint256 unlockTime) external {\n        _createLockFor(msg.sender, amount, unlockTime);\n    }\n\n    /// @dev Deposits `amount` tokens for `account` and locks for `unlockTime`.\n    /// @notice Tokens are taken from `msg.sender`'s balance.\n    /// @param account Account address.\n    /// @param amount Amount to deposit.\n    /// @param unlockTime Time when tokens unlock, rounded down to a whole week.\n    function createLockFor(address account, uint256 amount, uint256 unlockTime) external {\n        // Check if the account address is zero\n        if (account == address(0)) {\n            revert ZeroAddress();\n        }\n\n        _createLockFor(account, amount, unlockTime);\n    }\n\n    /// @dev Deposits `amount` tokens for `account` and locks for `unlockTime`.\n    /// @notice Tokens are taken from `msg.sender`'s balance.\n    /// @param account Account address.\n    /// @param amount Amount to deposit.\n    /// @param unlockTime Time when tokens unlock, rounded down to a whole week.\n    function _createLockFor(address account, uint256 amount, uint256 unlockTime) private {\n        // Check if the amount is zero\n        if (amount == 0) {\n            revert ZeroValue();\n        }\n        // Lock time is rounded down to weeks\n        // Cannot practically overflow because block.timestamp + unlockTime (max 4 years) << 2^64-1\n        unchecked {\n            unlockTime = ((block.timestamp + unlockTime) / WEEK) * WEEK;\n        }\n        LockedBalance memory lockedBalance = mapLockedBalances[account];\n        // The locked balance must be zero in order to start the lock\n        if (lockedBalance.amount > 0) {\n            revert LockedValueNotZero(account, uint256(lockedBalance.amount));\n        }\n        // Check for the lock time correctness\n        if (unlockTime < (block.timestamp + 1)) {\n            revert UnlockTimeIncorrect(account, block.timestamp, unlockTime);\n        }\n        // Check for the lock time not to exceed the MAXTIME\n        if (unlockTime > block.timestamp + MAXTIME) {\n            revert MaxUnlockTimeReached(account, block.timestamp + MAXTIME, unlockTime);\n        }\n        // After 10 years, the inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1 total supply\n        if (amount > type(uint96).max) {\n            revert Overflow(amount, type(uint96).max);\n        }\n\n        _depositFor(account, amount, unlockTime, lockedBalance, DepositType.CREATE_LOC"
    }
  ]
}