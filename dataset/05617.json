{
  "Title": "[L-02] No controllers can be deployed if certain tokens are chosen as `feeAsset`",
  "Content": "\n[WildcatMarketController Line 345](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketController.sol#L345)\n\n### Issue Description\n\nThe `MarketControllerFactory` allows for setting an `originationFeeAsset`, as well as `originationFeeAmount`, which are used to send a fee to the recipient each time a new market is deployed. When a market is deployed, the `originationFeeAmount` of the `originationFeeAsset` is transferred from the borrower to the `feeRecipient`. There is one additional check in place that verifies if the `originationFeeAsset` address is `0` and only transfers a fee if it is not zero.\n\n```solidity\nif (originationFeeAsset != address(0)) {\n\toriginationFeeAsset.safeTransferFrom(borrower, parameters.feeRecipient, originationFeeAmount);\n}\n```\n\nThe issue with this implementation is that some tokens, like [LEND](https://www.coingecko.com/de/munze/aave-old), may revert in case of a zero transfer. This means that if a token like [LEND](https://www.coingecko.com/de/munze/aave-old) is set as the `originationFeeAsset`, and later on the fee is reduced to zero, this function will always fail to execute, preventing any new markets from being deployed.\n\nAdditionally, not checking for zero transfers could lead to gas waste in the case of a token that does not revert but simply transfers nothing during a zero transfer.\n\n### Recommended Mitigation Steps\n\nTo fix this issue, an additional check needs to be added to the `if` clause, ensuring that `originationFeeAmount` is greater than zero:\n\n```solidity\nif (originationFeeAsset != address(0) && originationFeeAmount > 0) {\n\toriginationFeeAsset.safeTransferFrom(borrower, parameters.feeRecipient, originationFeeAmount);\n}\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/WildcatMarketController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/utils/SafeTransferLib.sol';\nimport './market/WildcatMarket.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './interfaces/IWildcatMarketControllerEventsAndErrors.sol';\nimport './interfaces/IWildcatMarketControllerFactory.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\n\nstruct TemporaryReserveRatio {\n  uint128 reserveRatioBips;\n  uint128 expiry;\n}\n\nstruct TmpMarketParameterStorage {\n  address asset;\n  string namePrefix;\n  string symbolPrefix;\n  address feeRecipient;\n  uint16 protocolFeeBips;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n}\n\ncontract WildcatMarketController is IWildcatMarketControllerEventsAndErrors {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for address;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                 Immutables                                 */\n  /* -------------------------------------------------------------------------- */\n\n  IWildcatArchController public immutable archController;\n\n  IWildcatMarketControllerFactory public immutable controllerFactory;\n\n  address public immutable borrower;\n\n  address public immutable sentinel;\n\n  address public immutable marketInitCodeStorage;\n\n  uint256 public immutable marketInitCodeHash;\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  uint32 internal immutable MinimumDelinquencyGracePeriod;\n  uint32 internal immutable MaximumDelinquencyGracePeriod;\n\n  uint16 internal immutable MinimumReserveRatioBips;\n  uint16 internal immutable MaximumReserveRatioBips;\n\n  uint16 internal immutable MinimumDelinquencyFeeBips;\n  uint16 internal immutable MaximumDelinquencyFeeBips;\n\n  uint32 internal immutable MinimumWithdrawalBatchDuration;\n  uint32 internal immutable MaximumWithdrawalBatchDuration;\n\n  uint16 internal immutable MinimumAnnualInterestBips;\n  uint16 internal immutable MaximumAnnualInterestBips;\n\n  EnumerableSet.AddressSet internal _authorizedLenders;\n  EnumerableSet.AddressSet internal _controlledMarkets;\n\n  /// @dev Temporary storage for market parameters, used during market deployment\n  TmpMarketParameterStorage internal _tmpMarketParameters;\n\n  mapping(address => TemporaryReserveRatio) public temporaryExcessReserveRatio;\n\n  // MarketParameterConstraints internal immutable constraints\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) {\n      revert CallerNotBorrower();\n    }\n    _;\n  }\n\n  modifier onlyControlledMarket(address market) {\n    if (!_controlledMarkets.contains(market)) {\n      revert NotControlledMarket();\n    }\n    _;\n  }\n\n  constructor() {\n    controllerFactory = IWildcatMarketControllerFactory(msg.sender);\n    MarketControllerParameters memory parameters = controllerFactory.getMarketControllerParameters();\n    archController = IWildcatArchController(parameters.archController);\n    borrower = parameters.borrower;\n    sentinel = parameters.sentinel;\n    marketInitCodeStorage = parameters.marketInitCodeStorage;\n    marketInitCodeHash = parameters.marketInitCodeHash;\n    MinimumDelinquencyGracePeriod = parameters.minimumDelinquencyGracePeriod;\n    MaximumDelinquencyGracePeriod = parameters.maximumDelinquencyGracePeriod;\n    MinimumReserveRatioBips = parameters.minimumReserveRatioBips;\n    MaximumReserveRatioBips = parameters.maximumReserveRatioBips;\n    MinimumDelinquencyFeeBips = parameters.minimumDelinquencyFeeBips;\n    MaximumDelinquencyFeeBips = parameters.maximumDelinquencyFeeBips;\n    MinimumWithdrawalBatchDuration = parameters.minimumWithdrawalBatchDuration;\n    MaximumWithdrawalBatchDuration = parameters.maximumWithdrawalBatchDuration;\n    MinimumAnnualInterestBips = parameters.minimumAnnualInterestBips;\n    MaximumAnnualInterestBips = parameters.maximumAnnualInterestBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                               Lender Registry                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the set of authorized lenders.\n   */\n  function getAuthorizedLenders() external view returns (address[] memory) {\n    return _authorizedLenders.values();\n  }\n\n  function getAuthorizedLenders(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _authorizedLenders.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _authorizedLenders.at(start + i);\n    }\n  }\n\n  function getAuthorizedLendersCount() external view returns (uint256) {\n    return _authorizedLenders.length();\n  }\n\n  function isAuthorizedLender(address lender) external view virtual returns (bool) {\n    return _authorizedLenders.contains(lender);\n  }\n\n  /**\n   * @dev Grant authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function authorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.add(lender)) {\n        emit LenderAuthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Revoke authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function deauthorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.remove(lender)) {\n        emit LenderDeauthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Update lender authorization for a set of markets to the current\n   *      status.\n   */\n  function updateLenderAuthorization(address lender, address[] memory markets) external {\n    for (uint256 i; i < markets.length; i++) {\n      address market = markets[i];\n      if (!_controlledMarkets.contains(market)) {\n        revert NotControlledMarket();\n      }\n      WildcatMarket(market).updateAccountAuthorization(lender, _authorizedLenders.contains(lender));\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                Market Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  function isControlledMarket(address market) external view returns (bool) {\n    return _controlledMarkets.contains(market);\n  }\n\n  function getControlledMarkets() external view returns (address[] memory) {\n    return _controlledMarkets.values();\n  }\n\n  function getControlledMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controlledMarkets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controlledMarkets.at(start + i);\n    }\n  }\n\n  function getControlledMarketsCount() external view returns (uint256) {\n    return _controlledMarkets.length();\n  }\n\n  function computeMarketAddress(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) external view returns (address) {\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    return LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                              Market Deployment                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Get the temporarily stored market parameters for a market that is\n   *      currently being deployed.\n   */\n  function getMarketParameters() external view returns (MarketParameters memory parameters) {\n    parameters.asset = _tmpMarketParameters.asset;\n    parameters.namePrefix = _tmpMarketParameters.namePrefix;\n    parameters.symbolPrefix = _tmpMarketParameters.symbolPrefix;\n    parameters.borrower = borrower;\n    parameters.controller = address(this);\n    parameters.feeRecipient = _tmpMarketParameters.feeRecipient;\n    parameters.sentinel = sentinel;\n    parameters.maxTotalSupply = _tmpMarketParameters.maxTotalSupply;\n    parameters.protocolFeeBips = _tmpMarketParameters.protocolFeeBips;\n    parameters.annualInterestBips = _tmpMarketParameters.annualInterestBips;\n    parameters.delinquencyFeeBips = _tmpMarketParameters.delinquencyFeeBips;\n    parameters.withdrawalBatchDuration = _tmpMarketParameters.withdrawalBatchDuration;\n    parameters.reserveRatioBips = _tmpMarketParameters.reserveRatioBips;\n    parameters.delinquencyGracePeriod = _tmpMarketParameters.delinquencyGracePeriod;\n  }\n\n  function _resetTmpMarketParameters() internal {\n    _tmpMarketParameters.asset = address(1);\n    _tmpMarketParameters.namePrefix = '_';\n    _tmpMarketParameters.symbolPrefix = '_';\n    _tmpMarketParameters.feeRecipient = address(1);\n    _tmpMarketParameters.protocolFeeBips = 1;\n    _tmpMarketParameters.maxTotalSupply = 1;\n    _tmpMarketParameters.annualInterestBips = 1;\n    _tmpMarketParameters.delinquencyFeeBips = 1;\n    _tmpMarketParameters.withdrawalBatchDuration = 1;\n    _tmpMarketParameters.reserveRatioBips = 1;\n    _tmpMarketParameters.delinquencyGracePeriod = 1;\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarket` unique to the\n   *      combination of `asset, namePrefix, symbolPrefix` and registers\n   *      it with the arch-controller.\n   *\n   *      If a market has already been deployed with these parameters,\n   *      reverts with `MarketAlreadyDeployed`.\n   *\n   *      If `msg.sender` is not `borrower` or `controllerFactory`,\n   *      reverts with `CallerNotBorrowerOrControllerFactory`.\n   *\n   *\t    If `msg.sender == borrower && !archController.isRegisteredBorrower(msg.sender)`,\n   *\t\t  reverts with `NotRegisteredBorrower`.\n   *\n   *      If called by `controllerFactory`, skips borrower check.\n   *\n   *      If either string is empty, reverts with `EmptyString`.\n   *\n   *      If `originationFeeAmount` returned by controller factory is not zero,\n   *      transfers `originationFeeAmount` of `originationFeeAsset` from\n   *      `msg.sender` to `feeRecipient`.\n   */\n  function deployMarket(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint128 maxTotalSupply,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) external returns (address market) {\n    if (msg.sender == borrower) {\n      if (!archController.isRegisteredBorrower(msg.sender)) {\n        revert NotRegisteredBorrower();\n      }\n    } else if (msg.sender != address(controllerFactory)) {\n      revert CallerNotBorrowerOrControllerFactory();\n    }\n\n    enforceParameterConstraints(\n      namePrefix,\n      symbolPrefix,\n      annualInterestBips,\n      delinquencyFeeBips,\n      withdrawalBatchDuration,\n      reserveRatioBips,\n      delinquencyGracePeriod\n    );\n\n    TmpMarketParameterStorage memory parameters = TmpMarketParameterStorage({\n      asset: asset,\n      namePrefix: namePrefix,\n      symbolPrefix: symbolPrefix,\n      feeRecipient: address(0),\n      maxTotalSupply: maxTotalSupply,\n      protocolFeeBips: 0,\n      annualInterestBips: annualInterestBips,\n      delinquencyFeeBips: delinquencyFeeBips,\n      withdrawalBatchDuration: withdrawalBatchDuration,\n      reserveRatioBips: reserveRatioBips,\n      delinquencyGracePeriod: delinquencyGracePeriod\n    });\n\n    address originationFeeAsset;\n    uint80 originationFeeAmount;\n    (\n      parameters.feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      parameters.protocolFeeBips\n    ) = controllerFactory.getProtocolFeeConfiguration();\n\n    _tmpMarketParameters = parameters;\n\n    if (originationFeeAsset != address(0)) {\n      originationFeeAsset.safeTransferFrom(borrower, parameters.feeRecipient, originationFeeAmount);\n    }\n\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    market = LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n    if (market.codehash != bytes32(0)) {\n      revert MarketAlreadyDeployed();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(marketInitCodeStorage, salt);\n\n    archController.registerMarket(market);\n    _controlledMarkets.add(market);\n\n    _resetTmpMarketParameters();\n  }\n\n  /**\n   * @dev Derive create2 salt for a market given the asset address,\n   *      name prefix and symbol prefix.\n   *\n   *      The salt is unique to each market deployment in the controller,\n   *      so only one market can be deployed for each combination of `asset`,\n   *      `namePrefix` and `symbolPrefix`\n   */\n  function _deriveSalt(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) internal pure returns (bytes32 salt) {\n    assembly {\n      // Cache free memory pointer\n      let freeMemoryPointer := mload(0x40)\n      // `keccak256(abi.encode(asset, keccak256(namePrefix), keccak256(symbolPrefix)))`\n      mstore(0x00, asset)\n      mstore(0x20, keccak256(add(namePrefix, 32), mload(namePrefix)))\n      mstore(0x40, keccak256(add(symbolPrefix, 32), mload(symbolPrefix)))\n      salt := keccak256(0, 0x60)\n      // Restore free memory pointer\n      mstore(0x40, freeMemoryPointer)\n    }\n  }\n\n  /**\n   * @dev Enforce constraints on market parameters, ensuring that\n   *      `annualInterestBips`, `delinquencyFeeBips`, `withdrawalBatchDuration`,\n   *      `reserveRatioBips` and `delinquencyGracePeriod` are within the\n   *      allowed ranges and that `namePrefix` and `symbolPrefix` are not null.\n   */\n  function enforceParameterConstraints(\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) internal view virtual {\n    assembly {\n      if or(iszero(mload(namePrefix)), iszero(mload(symbolPrefix))) {\n        // revert EmptyString();\n        mstore(0x00, 0xecd7b0d1)\n        revert(0x1c, 0x04)\n      }\n    }\n    assertValueInRange(\n      annualInterestBips,\n      MinimumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      AnnualInterestBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyFeeBips,\n      MinimumDelinquencyFeeBips,\n      MaximumDelinquencyFeeBips,\n      DelinquencyFeeBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      withdrawalBatchDuration,\n      MinimumWithdrawalBatchDuration,\n      MaximumWithdrawalBatchDuration,\n      WithdrawalBatchDurationOutOfBounds.selector\n    );\n    assertValueInRange(\n      reserveRatioBips,\n      MinimumReserveRatioBips,\n      MaximumReserveRatioBips,\n      ReserveRatioBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      DelinquencyGracePeriodOutOfBounds.selector\n    );\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    view\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /**\n   * @dev Modify the interest rate for a market.\n   * If the new interest rate is lower than the current interest rate,\n   * the reserve ratio is set to 90% for the next two weeks.\n   */\n  function setAnnualInterestBips(\n    address market,\n    uint16 annualInterestBips\n  ) external virtual onlyBorrower onlyControlledMarket(market) {\n    // If borrower is reducing the interest rate, increase the reserve\n    // ratio for the next two weeks.\n    if (annualInterestBips < WildcatMarket(market).annualInterestBips()) {\n      TemporaryReserveRatio storage tmp = temporaryExcessReserveRatio[market];\n\n      if (tmp.expiry == 0) {\n        tmp.reserveRatioBips = uint128(WildcatMarket(market).reserveRatioBips());\n\n        // Require 90% liquidity coverage for the next 2 weeks\n        WildcatMarket(market).setReserveRatioBips(9000);\n      }\n\n      tmp.expiry = uint128(block.timestamp + 2 weeks);\n    }\n\n    WildcatMarket(market).setAnnualInterestBips(annualInterestBips);\n  }\n\n  function resetReserveRatio(address market) external virtual {\n    TemporaryReserveRatio memory tmp = temporaryExcessReserveRatio[market];\n    if (tmp.expiry == 0) {\n      revertWithSelector(AprChangeNotPending.selector);\n    }\n    if (block.timestamp < tmp.expiry) {\n      revertWithSelector(ExcessReserveRatioStillActive.selector);\n    }\n\n    WildcatMarket(market).setReserveRatioBips(uint256(tmp.reserveRatioBips).toUint16());\n    delete temporaryExcessReserveRatio[market];\n  }\n\n  function assertValueInRange(\n    uint256 value,\n    uint256 min,\n    uint256 max,\n    bytes4 errorSelector\n  ) internal pure {\n    assembly {\n      if or(lt(value, min), gt(value, max)) {\n        mstore(0, errorSelector)\n        revert(0, 4)\n      }\n    }\n  }\n}"
    }
  ]
}