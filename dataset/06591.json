{
  "Title": "[M-10] Exchange Rate can be manipulated",
  "Content": "\n<https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/VToken.sol#L1463> <br><https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/VToken.sol#L1421> <br><https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/VToken.sol#L756>\n\nA malicious user can manipulate the protocol to receive greater rewards from the `RewardsDistributor` than they should. To achieve this, the attacker manipulates the `exchangeRate`.\n\nThe attacker `mint`s into the `VToken` contract legitimately but also `transfer`s an amount of tokens directly to the `VToken` contract. This inflates the `exchangeRate` for all subsequent users who `mint` and has the following impact:\n\n1.  Allows the attacker to push their leverage past the market `collateralFactor`\n2.  Violates the internal accounting when `borrowing` and `repaying`, causing the `totalBorrows` and the sum of the individual account borrows to become out of sync. I.e. the `totalBorrows` can become `0` while there are still some loans outstanding, leading to loss of earned interest.\n3.  The attacker can use the leverage to repeatedly `borrow` + `mint` into the `VToken` in order to inflate their share of the token rewards issued by the rewards distributor.\n\nThis means that all subsequent `minter`s receive less `VTokens` than they should.\n\nThe attack cost is the loss of the `transfer` into the `VToken` contract. But it must be noted that the attacker still receives around 65-75% of the (`attackTokens` + `mintTokens`) back.\n\nThe permanent side-effect of this exploit is that the minting of `VTokens` to any subsequent users remains stunted, as there is no direct mechanism to clear the excess underlying tokens from the contract. This can taint this Pool permanently.\n\nThis exploit becomes more profitable as block count accrues and more `REWARD_TOKENS` are issued, or, for example, if VENUS sets up greater rewards to incentivize supplying into a particular Pool; these increased rewards are a normal practice in DeFi and could be a prime target for this manipulation.\n\n### Proof of Concept\n\nIn this scenario an attacker:\n\n1.  Needs \\~60 underlying tokens (supply 10 underlying, 20 direct transfer, 30 interest).\n2.  Gets \\~5 times more rewards than other users.\n3.  Is still able to withdraw \\~50 underlying tokens from the `VToken`.\n4.  \\~10 tokens are now stuck in the contract, permanently tainting the exchange rate.\n\nA detailed Proof of Concept illustrating the case can be found in this [gist](https://gist.github.com/lokithe5th/cda577cc1b50cb91cfe1d4b1eccecc7e).\n\nThe gist simulates and walks through the attack using the repo's test suite as a base.\nThe exploit is commented on throughout its various steps.\n\n### Tools Used\n\nManual Code Review.\nHardhat + modified tests from repo.\n\n### Recommended Mitigation Steps\n\nWhen contract calculations depend on calls to an `ERC20.balanceOf`, there is always a risk of a malicious user sending tokens directly to the contract to manipulate the calculations to their benefit.\n\nThe simplest solution would be to have a check that the expected amount of underlying is equal to the actual amount of underlying, and if not, have the `mint` function sweep these additional underlying tokens into the next `minter's` calculations, reducing the economic incentive and eliminating the exaggerated effect on the exchange rate.\n\n### Assessed type\n\nToken-Transfer\n\n**[chechu (Venus) disputed and commented via duplicate issue #314](https://github.com/code-423n4/2023-05-venus-findings/issues/314#issuecomment-1560106779):**\n > The attack would indeed be feasible if we didn’t require an initial supply.\n\n**[0xean (judge) commented via duplicate issue #314](https://github.com/code-423n4/2023-05-venus-findings/issues/314#issuecomment-1569220872):**\n >@chechu - can you point me to this in the codebase?\n\n**[chechu (Venus) commented via duplicate issue #314](https://github.com/code-423n4/2023-05-venus-findings/issues/314#issuecomment-1570021693):**\n>Our fault, we **allow** an initial supply, but we don't **require** it. https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Pool/PoolRegistry.sol#L321\n>\n>The origin of the confusion is that we'll provide, for sure, an initial supply on every market that we'll add to the `PoolRegistry`, and the process to add new markets is under the control of the Governance (so, the community will have to vote for it). For that reason, we really assumed that there will be an initial supply, but now we realized we are not requiring it in the code. We'll do it, just to avoid any confusion or potential error.\n>\n>We won't integrate the Oracles, but the initial idea is to provide at least `$`10,000 as an initial supply on each new market. That \"check\" will be done externally, when the VIP is prepared to be proposed to the community.\n\n**[chechu (Venus) commented](https://github.com/code-423n4/2023-05-venus-findings/issues/220#issuecomment-1637858904):**\n>> 1. Allows the attacker to push their leverage past the market collateralFactor\n>\n>This is wrong. If you mint (receiving X `vTokens`) and then you transfer underlying tokens to the market, your X `vTokens` will have a greater value because the exchange rate is greater after the donation. In the PoC:\n>\n>1. The attacker mints 10 WBTC -> `vTokens` received: 10\n>2. The attacker donates 20 WBTC -> this change the exchange rate from 1000000000000000000 to 2000000000000000000, so, basically, the `vTokens` previously minted now can be redeemed receiving the double amount of WBTC (that is the expected effect of this donation).\n>\n>So, the value of the 10 `vTokens` of the attacker after the donation is 20 WBTC, not 10 WBTC. For that reason, the user can borrow 13 WBTC (13 < 20 * 0.7, where 0.7 is the collateral factor).\n>\n>The attacker could get a similar (actually better) effect minting more `vTokens` supplying the 20 WBTC tokens, instead of donating them. Moreover, donating is a benefit for every user with `vTokens` before the donation, while minting only benefits the minter.\n>\n>To demonstrate it, you can replace the following statement in the PoC:\n>\n>```\n>await mockWBTC.connect(attacker).transfer(vWBTC.address, convertToUnit(20, 8))\n>```\n>\n>with this one:\n>\n>```\n>await vWBTC.connect(attacker).mint(convertToUnit(20, 8));\n>```\n>\n>And the output of the PoC will be the same.\n>\n>> 2. Violates the internal accounting when borrowing and repaying causing the `totalBorrows` and the sum of the individual account borrows to become out of sync. I.E. the `totalBorrows` can become 0 while their are still some loans outstanding, leading to loss of earned interest.\n>\n>This is not because of the transfer (donation), but because of the known rounding issues associated with the used math; which can generate small differences among the `totalBorrow` variable and the sum of the individual borrowed amounts.\n>\n>> 3. The attacker can use the leverage to repeatedly borrow + mint into the `VToken` in order to inflate their share of the token rewards issued by the rewards distributor.\n>\n>That is true, but, again, it's independent of the donations. Users can use the leverage to increase their positions and therefore get more rewards. The main downside of leveraging is the cost (every X `WBTC` borrowed that are then supplied implies a cost for the user proportional to the reserve factor of the market). So, taking into account that the total rewards to distribute are fixed, the leverage can make sense depending on the total suppliers and borrowers.\n>\n>> The permanent side-effect of this exploit is that the minting of `VTokens` to any subsequent users remains stunted as there is no direct mechanism to clear the excess underlying tokens from the contract. This can taint this `Pool` permanently.\n>\n>Donations to markets are supported, and there aren't known negative side effects on regular scenarios. If the liquidity of the market is very low, donations can facilitate issues related to rounding (like in the Hundred Finance attack, https://twitter.com/danielvf/status/1647329491788677121), but every market in Venus starts with a minimum liquidity that should reduce these risks.\n>\n>Finally, in the PoC, some redeems operations fail because those users still have some borrowed amount. Printing the error thrown you can see how the error is `InsufficientLiquidity`, thrown in the `Comptroller._checkRedeemAllowed` function. To repay 100% of the debt, the best option is to invoke the `repayBorrow` providing an big amount as parameter. The function will get only the borrowed amount (considering interest accrued until that block).\n\n**[thebrittfactor (C4) commented](https://github.com/code-423n4/2023-05-venus-findings/issues/220#issuecomment-1655683997):**\n>Sponsor requested additional feedback from the warden in regards to this submission after the Post-Judging QA period. C4 staff reached out to the warden directly with that request.\n\n**[LokiThe5th (warden) commented](https://github.com/code-423n4/2023-05-venus-findings/issues/220#issuecomment-1655683997):**\n\n>Thank you for the feedback. I don't have access to my original notes anymore, but will try to provide clarity where I can. To be clear, in retrospect, this submission seems to have conflated a few issues while trying to demonstrate the exchange rate issue.\n>\n>> This is wrong. If you mint (receiving X `vTokens`) and then you transfer underlying tokens to the market, your X `vTokens` will have a greater value because the exchange rate is greater after the donation. \n>\n>Yes, you are correct. The exchange rate is manipulated (which is the issue). To be more specific, the attacker *appears* to be able to push past the collateral factor when *considering the amount of `vToken` held by the attacker*. The intention here is to demonstrate this exchange rate manipulation through borrowing past what the internal accounting would hold the attacker's safe collateral factor would be.\n>\n>> This is not because of the transfer (donation), but because of the known rounding issues associated with the used math; which can generate small differences among the `totalBorrow` variable and the sum of the individual borrowed amounts.  \n>\n>Indeed, rounding in Solidity is a known issue. It may well be that the direct transfer only served to exacerbate this issue when compared with the control scenario.\n>\n>> That is true, but, again, it's independent of the donations. Users can use the leverage to increase their positions and therefore get more rewards. The main downside of leveraging is the cost (every X `WBTC` borrowed that are then supplied implies a cost for the user proportional to the reserve factor of the market). So, taking into account that the total rewards to distribute are fixed, the leverage can make sense depending on the total suppliers and borrowers.  \n>\n>You are correct that this is independent of donations. Users using leverage in this way to increase their rewards is likely a separate issue.  \n>\n>> Donations to markets are supported, and there aren't known negative side effects on regular scenarios. If the liquidity of the market is very low, donations can facilitate issues related to rounding (like in the Hundred Finance attack, https://twitter.com/danielvf/status/1647329491788677121), but every market in Venus starts with a minimum liquidity that should reduce these risks.  \n>\n>In the context of modular markets exchange rate manipulation can be damaging. It is good practice to explicitly handle (or not handle) donations in the accounting logic for the contract. For example, in the standard `UniswapV2Pair` contracts calculations are made using an internal tracking of `reserves` to avoid this issue. \n>\n>> Finally, in the PoC, some redeems operations fail because those users still have some borrowed amount. Printing the error thrown you can see how the error is `InsufficientLiquidity`, thrown in the `Comptroller._checkRedeemAllowed` function. To repay 100% of the debt, the best option is to invoke the `repayBorrow` providing an big amount as parameter. The function will get only the borrowed amount (considering interest accrued until that block).\n>\n>You are correct. Some redeems fail because some users still have borrowed amounts. In the preceeding code these users tried repay their borrows using their exact `borrowBalance` from the call to `VToken.getAccountSnapshot(user)`. It would be acceptable for a user to assume that should they try to `repayBorrow` with this outstanding amount. If memory serves, this failure of repayment using the returned `borrowBalance` happened in exchange manipulation scenarios, but not others. But this may have been a mistaken assumption if that is not the case. If so, it would also be a separate issue.\n\n**[chechu (Venus) commented](https://github.com/code-423n4/2023-05-venus-findings/issues/220#issuecomment-1655688392):**\n>Hey @LokiThe5th - Thanks for your message.\n>\n>> To be more specific, the attacker appears to be able to push past the collateral factor when considering the amount of `vToken` held by the attacker.\n>\n>I think that is not precise. The donation doesn't allow users to break the rule of the collateral factor. The donation is increasing the value of the `vTokens`, so any user with `vTokens` before the donation will be able to borrow more tokens. That is correct, expected, and doesn't generate any issue.\n>\n>You call it manipulation, and I can see your point because with a donation the user is able to change the value of the exchange rate. Personally, I don't think this is a manipulation, because the user doesn't get any benefit by doing it. As I said, if the attacker mints instead of donating the same amount, he would be able to borrow more tokens (in a regular scenario, not being the first and only supplier).\n>\n>Example:\n>* Initial exchange rate: 1 (1 underlying token == 1 `vToken`)\n>* User 1 mints 1,000 tokens, receiving 1,000 `vTokens`. Exchange rate is not affected, so, it's 1\n>* Attacker 1 mints 1,000 tokens, receiving 1,000 `vTokens`. Exchange rate is not affected, so, it's 1\n>* Attacker 1 donates 2,000 tokens, not receiving anything, but changing the exchange rate, that now will be 2 (total cash / total `vTokens` minted)\n>\n>So, now the 1,000 `vTokens` have more value (the attacker would be able to redeem 1,000 `vTokens` and receive 2,000 tokens, instead of the original 1,000 tokens they minted). And therefore, the \"borrowing power\" of the attacker is greater. The attacker can borrow more assets from another market, because now his 1,000 `vTokens` has more value.\n>\n>But, that is a bad strategy by the attacker, because by doing the donation User 1 also received a benefit. Now, User 1 can redeem their 1,000 `vTokens`, receiving 2,000 tokens. Not only their original 1,000 tokens.\n>\n>A better strategy by the attacker would be to mint 2,000 tokens, instead of donating them. This way, the exchange rate doesn't change (so User 1 doesn't receive any benefit) and the \"borrowing power\" of the attacker is even higher (3,000 tokens, instead of 2,000 tokens achieved via the donation).\n>\n>So, yes, with a donation you are able to update the exchange rate, but you won't get any benefit, and you will lose resources.\n>\n>> Indeed, rounding in Solidity is a known issue. It may well be that the direct transfer only served to exacerbate this issue when compared with the control scenario.\n>\n>If you mint instead of donating, the rounding issue appears too. So, I don't think the donation exacerbates the rounding issue.\n>\n>> In the context of modular markets exchange rate manipulation can be damaging. It is good practice to explicitly handle (or not handle) donations in the accounting logic for the contract. For example, in the standard `UniswapV2Pair` contracts calculations are made using an internal tracking of reserves to avoid this issue.\n>\n>In the Venus protocol, I think donations benefit every `vToken` holder and don't affect future holders, because for a user getting `vTokens`, the relevant events happen from the `vTokens` are minted until they are redeemed. It doesn't matter what happened before. Moreover, the exchange rate is never decreasing. So, IMO, we can avoid the internal tracking of cash in the markets.\n>\n>> this failure of repayment using the returned `borrowBalance` happened in exchange manipulation scenarios, but not others.\n>\n>I think the failures of repayments are associated with the rounding issues, not with donations. I modified the provided PoC, transforming the donation into a mint, and this issue is still there. I think the impact is low because users are not able to repay 100% of their debt only in edge cases, with 1 or 2 borrowers in the market and after several blocks. With a regular number of borrowers, users shouldn't have any problem repaying their debt, and therefore redeeming their `vTokens`\n>\n>Thank you again for your time reviewing the code. We really appreciate it. Your comments push us to improve the code (and to understand it better, tbh). We are totally open to trying to clarify any doubts.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/VToken.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./VTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./ExponentialNoError.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport \"./RiskFund/IProtocolShareReserve.sol\";\n\n/**\n * @title Venus VToken Contract\n * @author Venus Dev Team\n */\ncontract VToken is\n    Ownable2StepUpgradeable,\n    AccessControlledV8,\n    VTokenInterface,\n    ExponentialNoError,\n    TokenErrorReporter\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     * @param riskManagement Addresses of risk fund contracts\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address admin_,\n        address accessControlManager_,\n        RiskManagementInit memory riskManagement,\n        uint256 reserveFactorMantissa_\n    ) external initializer {\n        require(admin_ != address(0), \"invalid admin address\");\n\n        // Initialize the market\n        _initialize(\n            underlying_,\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            admin_,\n            accessControlManager_,\n            riskManagement,\n            reserveFactorMantissa_\n        );\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return success True if the transfer suceeded, reverts otherwise\n     * @custom:event Emits Transfer event on success\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\n     * @custom:access Not restricted\n     */\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        _transferTokens(msg.sender, msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return success True if the transfer suceeded, reverts otherwise\n     * @custom:event Emits Transfer event on success\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\n     * @custom:access Not restricted\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override nonReentrant returns (bool) {\n        _transferTokens(msg.sender, src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\n     * @return success Whether or not the approval succeeded\n     * @custom:event Emits Approval event\n     * @custom:access Not restricted\n     */\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        require(spender != address(0), \"invalid spender address\");\n\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return amount The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external override returns (uint256) {\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return totalBorrows The total borrows with interest\n     */\n    function totalBorrowsCurrent() external override nonReentrant returns (uint256) {\n        accrueInterest();\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return borrowBalance The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        return _borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function mint(uint256 mintAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        _mintFresh(msg.sender, msg.sender, mintAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender calls on-behalf of minter. minter supplies assets into the market and receives vTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function mintBehalf(address minter, uint256 mintAmount) external override nonReentrant returns (uint256) {\n        require(minter != address(0), \"invalid minter address\");\n\n        accrueInterest();\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        _mintFresh(msg.sender, minter, mintAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of vTokens to redeem into underlying\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Redeem and Transfer events; may emit AccrueInterest\n     * @custom:error RedeemTransferOutNotPossible is thrown when the protocol has insufficient cash\n     * @custom:access Not restricted\n     */\n    function redeem(uint256 redeemTokens) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\n        _redeemFresh(msg.sender, redeemTokens, 0);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     */\n    function redeemUnderlying(uint256 redeemAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\n        _redeemFresh(msg.sender, 0, redeemAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits Borrow event; may emit AccrueInterest\n     * @custom:error BorrowCashNotAvailable is thrown when the protocol has insufficient cash\n     * @custom:access Not restricted\n     */\n    function borrow(uint256 borrowAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        _borrowFresh(msg.sender, borrowAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function repayBorrow(uint256 repayAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        _repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external override nonReentrant returns (uint256) {\n        accrueInterest();\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        _repayBorrowFresh(msg.sender, borrower, repayAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral vToken\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral vToken\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\n     * @custom:access Not restricted\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral\n    ) external override returns (uint256) {\n        _liquidateBorrow(msg.sender, borrower, repayAmount, vTokenCollateral, false);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice sets protocol share accumulated from liquidations\n     * @dev must be less than liquidation incentive - 1\n     * @param newProtocolSeizeShareMantissa_ new protocol share mantissa\n     * @custom:event Emits NewProtocolSeizeShare event on success\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\n     * @custom:error ProtocolSeizeShareTooBig is thrown when the new seize share is too high\n     * @custom:access Controlled by AccessControlManager\n     */\n    function setProtocolSeizeShare(uint256 newProtocolSeizeShareMantissa_) external {\n        _checkAccessAllowed(\"setProtocolSeizeShare(uint256)\");\n        uint256 liquidationIncentive = ComptrollerViewInterface(address(comptroller)).liquidationIncentiveMantissa();\n        if (newProtocolSeizeShareMantissa_ + 1e18 > liquidationIncentive) {\n            revert ProtocolSeizeShareTooBig();\n        }\n\n        uint256 oldProtocolSeizeShareMantissa = protocolSeizeShareMantissa;\n        protocolSeizeShareMantissa = newProtocolSeizeShareMantissa_;\n        emit NewProtocolSeizeShare(oldProtocolSeizeShareMantissa, newProtocolSeizeShareMantissa_);\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @custom:event Emits NewReserveFactor event; may emit AccrueInterest\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\n     * @custom:error SetReserveFactorBoundsCheck is thrown when the new reserve factor is too high\n     * @custom:access Controlled by AccessControlManager\n     */\n    function setReserveFactor(uint256 newReserveFactorMantissa) external override nonReentrant {\n        _checkAccessAllowed(\"setReserveFactor(uint256)\");\n\n        accrueInterest();\n        _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to the protocol reserve contract\n     * @param reduceAmount Amount of reduction to reserves\n     * @custom:event Emits ReservesReduced event; may emit AccrueInterest\n     * @custom:error ReduceReservesCashNotAvailable is thrown when the vToken does not have sufficient cash\n     * @custom:error ReduceReservesCashValidation is thrown when trying to withdraw more cash than the reserves have\n     * @custom:access Not restricted\n     */\n    function reduceReserves(uint256 reduceAmount) external override nonReentrant {\n        accrueInterest();\n        _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @custom:event Emits ReservesAdded event; may emit AccrueInterest\n     * @custom:access Not restricted\n     */\n    function addReserves(uint256 addAmount) external override nonReentrant {\n        accrueInterest();\n        _addReservesFresh(addAmount);\n    }\n\n    /**\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @custom:event Emits NewMarketInterestRateModel event; may emit AccrueInterest\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\n     * @custom:access Controlled by AccessControlManager\n     */\n    function setInterestRateModel(InterestRateModel newInterestRateModel) external override {\n        _checkAccessAllowed(\"setInterestRateModel(address)\");\n\n        accrueInterest();\n        _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /**\n     * @notice Repays a certain amount of debt, treats the rest of the borrow as bad debt, essentially\n     *   \"forgiving\" the borrower. Healing is a situation that should rarely happen. However, some pools\n     *   may list risky assets or be configured improperly – we want to still handle such cases gracefully.\n     *   We assume that Comptroller does the seizing, so this function is only available to Comptroller.\n     * @dev This function does not call any Comptroller hooks (like \"healAllowed\"), because we assume\n     *   the Comptroller does all the necessary checks before calling this function.\n     * @param payer account who repays the debt\n     * @param borrower account to heal\n     * @param repayAmount amount to repay\n     * @custom:event Emits RepayBorrow, BadDebtIncreased events; may emit AccrueInterest\n     * @custom:error HealBorrowUnauthorized is thrown when the request does not come from Comptroller\n     * @custom:access Only Comptroller\n     */\n    function healBorrow(\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external override nonReentrant {\n        if (msg.sender != address(comptroller)) {\n            revert HealBorrowUnauthorized();\n        }\n\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\n        uint256 totalBorrowsNew = totalBorrows;\n\n        uint256 actualRepayAmount;\n        if (repayAmount != 0) {\n            // _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n            // We violate checks-effects-interactions here to account for tokens that take transfer fees\n            actualRepayAmount = _doTransferIn(payer, repayAmount);\n            totalBorrowsNew = totalBorrowsNew - actualRepayAmount;\n            emit RepayBorrow(payer, borrower, actualRepayAmount, 0, totalBorrowsNew);\n        }\n\n        // The transaction will fail if trying to repay too much\n        uint256 badDebtDelta = accountBorrowsPrev - actualRepayAmount;\n        if (badDebtDelta != 0) {\n            uint256 badDebtOld = badDebt;\n            uint256 badDebtNew = badDebtOld + badDebtDelta;\n            totalBorrowsNew = totalBorrowsNew - badDebtDelta;\n            badDebt = badDebtNew;\n\n            // We treat healing as \"repayment\", where vToken is the payer\n            emit RepayBorrow(address(this), borrower, badDebtDelta, accountBorrowsPrev - badDebtDelta, totalBorrowsNew);\n            emit BadDebtIncreased(borrower, badDebtDelta, badDebtOld, badDebtNew);\n        }\n\n        accountBorrows[borrower].principal = 0;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        emit HealBorrow(payer, borrower, repayAmount);\n    }\n\n    /**\n     * @notice The extended version of liquidations, callable only by Comptroller. May skip\n     *  the close factor check. The collateral seized is transferred to the liquidator.\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param borrower The borrower of this vToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\n     *   regardless of the account liquidity\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\n     * @custom:error ForceLiquidateBorrowUnauthorized is thrown when the request does not come from Comptroller\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral vToken\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral vToken\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\n     * @custom:access Only Comptroller\n     */\n    function forceLiquidateBorrow(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        VTokenInterface vTokenCollateral,\n        bool skipLiquidityCheck\n    ) external override {\n        if (msg.sender != address(comptroller)) {\n            revert ForceLiquidateBorrowUnauthorized();\n        }\n        _liquidateBorrow(liquidator, borrower, repayAmount, vTokenCollateral, skipLiquidityCheck);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another vToken during the process of liquidation.\n     *  It's absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of vTokens to seize\n     * @custom:event Emits Transfer, ReservesAdded events\n     * @custom:error LiquidateSeizeLiquidatorIsBorrower is thrown when trying to liquidate self\n     * @custom:access Not restricted\n     */\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external override nonReentrant {\n        _seize(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    /**\n     * @notice Updates bad debt\n     * @dev Called only when bad debt is recovered from auction\n     * @param recoveredAmount_ The amount of bad debt recovered\n     * @custom:event Emits BadDebtRecovered event\n     * @custom:access Only Shortfall contract\n     */\n    function badDebtRecovered(uint256 recoveredAmount_) external {\n        require(msg.sender == shortfall, \"only shortfall contract can update bad debt\");\n        require(recoveredAmount_ <= badDebt, \"more than bad debt recovered from auction\");\n\n        uint256 badDebtOld = badDebt;\n        uint256 badDebtNew = badDebtOld - recoveredAmount_;\n        badDebt = badDebtNew;\n\n        emit BadDebtRecovered(badDebtOld, badDebtNew);\n    }\n\n    /**\n     * @notice Sets protocol share reserve contract address\n     * @param protocolShareReserve_ The address of the protocol share reserve contract\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\n     * @custom:access Only Governance\n     */\n    function setProtocolShareReserve(address payable protocolShareReserve_) external onlyOwner {\n        _setProtocolShareReserve(protocolShareReserve_);\n    }\n\n    /**\n     * @notice Sets shortfall contract address\n     * @param shortfall_ The address of the shortfall contract\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\n     * @custom:access Only Governance\n     */\n    function setShortfallContract(address shortfall_) external onlyOwner {\n        _setShortfallContract(shortfall_);\n    }\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n     * @param token The address of the ERC-20 token to sweep\n     * @custom:access Only Governance\n     */\n    function sweepToken(IERC20Upgradeable token) external override {\n        require(msg.sender == owner(), \"VToken::sweepToken: only admin can sweep tokens\");\n        require(address(token) != underlying, \"VToken::sweepToken: can not sweep underlying token\");\n        uint256 balance = token.balanceOf(address(this));\n        token.safeTransfer(owner(), balance);\n\n        emit SweepToken(address(token));\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return amount The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return amount The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view override returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @return vTokenBalance User's balance of vTokens\n     * @return borrowBalance Amount owed in terms of underlying\n     * @return exchangeRate Stored exchange rate\n     */\n    function getAccountSnapshot(address account)\n        external\n        view\n        override\n        returns (\n            uint256 error,\n            uint256 vTokenBalance,\n            uint256 borrowBalance,\n            uint256 exchangeRate\n        )\n    {\n        return (NO_ERROR, accountTokens[account], _borrowBalanceStored(account), _exchangeRateStored());\n    }\n\n    /**\n     * @notice Get cash balance of this vToken in the underlying asset\n     * @return cash The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view override returns (uint256) {\n        return _getCashPrior();\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this vToken\n     * @return rate The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view override returns (uint256) {\n        return interestRateModel.getBorrowRate(_getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this v\n     * @return rate The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view override returns (uint256) {\n        return interestRateModel.getSupplyRate(_getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return borrowBalance The calculated balance\n     */\n    function borrowBalanceStored(address account) external view override returns (uint256) {\n        return _borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the VToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() external view override returns (uint256) {\n        return _exchangeRateStored();\n    }\n\n    /**\n     * @notice Increase approval for `spender`\n     * @param spender The address of the account which may transfer tokens\n     * @param addedValue The number of tokens additional tokens spender can transfer\n     * @return success Whether or not the approval succeeded\n     * @custom:event Emits Approval event\n     * @custom:access Not restricted\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0), \"invalid spender address\");\n\n        address src = msg.sender;\n        uint256 newAllowance = transferAllowances[src][spender];\n        newAllowance += addedValue;\n        transferAllowances[src][spender] = newAllowance;\n\n        emit Approval(src, spender, newAllowance);\n        return true;\n    }\n\n    /**\n     * @notice Decreases approval for `spender`\n     * @param spender The address of the account which may transfer tokens\n     * @param subtractedValue The number of tokens tokens to remove from total approval\n     * @return success Whether or not the approval succeeded\n     * @custom:event Emits Approval event\n     * @custom:access Not restricted\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        require(spender != address(0), \"invalid spender address\");\n\n        address src = msg.sender;\n        uint256 currentAllowance = transferAllowances[src][spender];\n        require(currentAllowance >= subtractedValue, \"decreased allowance below zero\");\n        unchecked {\n            currentAllowance -= subtractedValue;\n        }\n\n        transferAllowances[src][spender] = currentAllowance;\n\n        emit Approval(src, spender, currentAllowance);\n        return true;\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public override nonReentrant returns (uint256) {\n        accrueInterest();\n        return _exchangeRateStored();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     * @return Always NO_ERROR\n     * @custom:event Emits AccrueInterest event on success\n     * @custom:access Not restricted\n     */\n    function accrueInterest() public virtual override returns (uint256) {\n        /* Remember the initial block number */\n        uint256 currentBlockNumber = _getBlockNumber();\n        uint256 accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return NO_ERROR;\n        }\n\n        /* Read the previous values out of storage */\n        uint256 cashPrior = _getCashPrior();\n        uint256 borrowsPrior = totalBorrows;\n        uint256 reservesPrior = totalReserves;\n        uint256 borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n        uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n        uint256 totalBorrowsNew = interestAccumulated + borrowsPrior;\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\n            Exp({ mantissa: reserveFactorMantissa }),\n            interestAccumulated,\n            reservesPrior\n        );\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, t"
    }
  ]
}