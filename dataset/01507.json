{
  "Title": "Lack of documentation for complex functionality",
  "Content": "The codebase contains several internal functions that perform complex computations but lack sufficient documentation. Further, some state variables have complex implicit assumptions about the values they store that are not documented. This lack of documentation can hinder the maintainability of these functions and variables, making it more challenging for auditors to thoughtfully understand their implications. In particular:\n\n\n* The `_mintAndTransferQuad`, `_checkAndClearOwner`, `_checkAndClear`, and `_checkBatchReceiverAcceptQuadAndClearOwner` functions in the [`PolygonLandBaseTokenV2`](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandBaseTokenV2.sol) and [`LandBaseTokenV3`](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/LandBaseTokenV3.sol) contracts.\n* The `_owners` state variable defined in the `ERC721BaseTokenV2` contract in both the [Ethereum implementation](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/ERC721BaseTokenV2.sol#L21) and [Polygon implementation](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/BaseWithStorage/ERC721BaseTokenV2.sol#L28), which is used throughout the [`LandBaseTokenV3`](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/LandBaseTokenV3.sol) and [`PolygonLandBaseTokenV2`](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandBaseTokenV2.sol) contracts. This variable uses a complex storage pattern to record ownership of individual LAND tokens as well as \"quads\". Quads are indexed using a bitmask and the code implicitly assumes that ownership of individual LAND tokens takes precedence over quads. Further, the stored addresses include indicator bits above the 160th bit to mark tokens as burned or have an operator enabled.\n\n\nTo ensure ease of maintainability, consider thoroughly documenting these functions and variables, including both function-level documentation as well as in-line documentation where appropriate.\n\n\n***Update:** Resolved in [pull request #916](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/916) at commit [3d5acc1](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/916/commits/3d5acc18b7c6f3738631b5055381d807db0aaf31).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/solc_0.5/Land/erc721/ERC721BaseTokenV2.sol",
      "content": "/* solhint-disable func-order, code-complexity */\npragma solidity 0.5.9;\n\nimport \"../../contracts_common/Libraries/AddressUtils.sol\";\nimport \"../../contracts_common/Interfaces/ERC721TokenReceiver.sol\";\nimport \"../../contracts_common/Interfaces/ERC721Events.sol\";\nimport \"../../contracts_common/BaseWithStorage/SuperOperatorsV2.sol\";\nimport \"../../contracts_common/BaseWithStorage/MetaTransactionReceiverV2.sol\";\nimport \"../../contracts_common/Interfaces/ERC721MandatoryTokenReceiver.sol\";\n\ncontract ERC721BaseTokenV2 is ERC721Events, SuperOperatorsV2, MetaTransactionReceiverV2 {\n    using AddressUtils for address;\n\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\n\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\n\n    mapping (address => uint256) public _numNFTPerAddress;\n    mapping (uint256 => uint256) public _owners;\n    mapping (address => mapping(address => bool)) public _operatorsForAll;\n    mapping (uint256 => address) public _operators;\n\n    bool internal _initialized;\n\n    modifier initializer() {\n        require(!_initialized, \"ERC721BaseToken: Contract already initialized\");\n        _;\n    }\n\n    function initialize (\n        address metaTransactionContract,\n        address admin\n    ) public initializer {\n        _admin = admin;\n        _setMetaTransactionProcessor(metaTransactionContract, true);\n        _initialized = true;\n    }\n\n    function _transferFrom(address from, address to, uint256 id) internal {\n        _numNFTPerAddress[from]--;\n        _numNFTPerAddress[to]++;\n        _owners[id] = uint256(to);\n        emit Transfer(from, to, id);\n    }\n\n    /**\n     * @notice Return the number of Land owned by an address\n     * @param owner The address to look for\n     * @return The number of Land token owned by the address\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"owner is zero address\");\n        return _numNFTPerAddress[owner];\n    }\n\n\n    function _ownerOf(uint256 id) internal view returns (address) {\n        return address(_owners[id]);\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\n        uint256 data = _owners[id];\n        owner = address(data);\n        operatorEnabled = (data / 2**255) == 1;\n    }\n\n    /**\n     * @notice Return the owner of a Land\n     * @param id The id of the Land\n     * @return The address of the owner\n     */\n    function ownerOf(uint256 id) external view returns (address owner) {\n        owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n    }\n\n    function _approveFor(address owner, address operator, uint256 id) internal {\n        if(operator == address(0)) {\n            _owners[id] = uint256(owner); // no need to resset the operator, it will be overriden next time\n        } else {\n            _owners[id] = uint256(owner) + 2**255;\n            _operators[id] = operator;\n        }\n        emit Approval(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external {\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"sender is zero address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _operatorsForAll[sender][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve\"\n        );\n        require(owner == sender, \"owner != sender\");\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) external {\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(\n            owner == msg.sender ||\n            _operatorsForAll[owner][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve\"\n        );\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Get the approved operator for a specific token\n     * @param id The id of the token\n     * @return The address of the operator\n     */\n    function getApproved(uint256 id) external view returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }\n\n    function _checkTransfer(address from, address to, uint256 id) internal view returns (bool isMetaTx) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == from, \"not owner in _checkTransfer\");\n        require(to != address(0), \"can't send to zero address\");\n        isMetaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !isMetaTx) {\n            require(\n                _operatorsForAll[from][msg.sender] ||\n                (operatorEnabled && _operators[id] == msg.sender) ||\n                _superOperators[msg.sender],\n                \"not approved to transfer\"\n            );\n        }\n    }\n\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId)\n        internal\n        view\n        returns (bool)\n    {\n        bool success;\n        bool result;\n        bytes memory call_data = abi.encodeWithSelector(\n            ERC165ID,\n            interfaceId\n        );\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let call_ptr := add(0x20, call_data)\n            let call_size := mload(call_data)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(\n                10000,\n                _contract,\n                call_ptr,\n                call_size,\n                output,\n                0x20\n            ) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n    */\n    function transferFrom(address from, address to, uint256 id) external {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \"\"),\n                \"erc721 transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data) public {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, data),\n                \"ERC721: transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function safeTransferFrom(address from, address to, uint256 id) external {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n    */\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\n        _batchTransferFrom(from, to, ids, data, false);\n    }\n\n    function _batchTransferFrom(address from, address to, uint256[] memory ids, bytes memory data, bool safe) internal {\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        bool authorized = msg.sender == from ||\n            metaTx ||\n            _operatorsForAll[from][msg.sender] ||\n            _superOperators[msg.sender];\n\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n\n        uint256 numTokens = ids.length;\n        for(uint256 i = 0; i < numTokens; i ++) {\n            uint256 id = ids[i];\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n            require(owner == from, \"not owner in batchTransferFrom\");\n            require(authorized || (operatorEnabled && _operators[id] == msg.sender), \"not authorized\");\n            _owners[id] = uint256(to);\n            emit Transfer(from, to, id);\n        }\n        if (from != to) {\n            _numNFTPerAddress[from] -= numTokens;\n            _numNFTPerAddress[to] += numTokens;\n        }\n\n        if (to.isContract()) {\n            if (_checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n                require(\n                    _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\n                    \"erc721 batch transfer rejected by to\"\n                );\n            } else if (safe) {\n                for (uint256 i = 0; i < numTokens; i ++) {\n                    require(\n                        _checkOnERC721Received(metaTx ? from : msg.sender, from, to, ids[i], \"\"),\n                        \"erc721 transfer rejected by to\"\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses ensuring the receiving contract has a receiver method\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n    */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\n        _batchTransferFrom(from, to, ids, data, true);\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) external pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(sender != address(0), \"Invalid sender address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve for all\"\n        );\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(\n            !_superOperators[operator],\n            \"super operator can't have their approvalForAll changed\"\n        );\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Check if the sender approved the operator\n     * @param owner The address of the owner\n     * @param operator The address of the operator\n     * @return The status of the approval\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool isOperator)\n    {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function _burn(address from, address owner, uint256 id) internal {\n        require(from == owner, \"not owner\");\n        _owners[id] = 2**160; // cannot mint it again\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n\n    /// @notice Burns token `id`.\n    /// @param id token which will be burnt.\n    function burn(uint256 id) external {\n        _burn(msg.sender, _ownerOf(id), id);\n    }\n\n    /// @notice Burn token`id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id token which will be burnt.\n    function burnFrom(address from, uint256 id) external {\n        require(from != address(0), \"Invalid sender address\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(\n            msg.sender == from ||\n            _metaTransactionContracts[msg.sender] ||\n            (operatorEnabled && _operators[id] == msg.sender) ||\n            _operatorsForAll[from][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to burn\"\n        );\n        _burn(from, owner, id);\n    }\n\n    function _checkOnERC721Received(address operator, address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        bytes4 retval = ERC721TokenReceiver(to).onERC721Received(operator, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _checkOnERC721BatchReceived(address operator, address from, address to, uint256[] memory ids, bytes memory _data)\n        internal returns (bool)\n    {\n        bytes4 retval = ERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\n        return (retval == _ERC721_BATCH_RECEIVED);\n    }\n\n    // Empty storage space in contracts for future enhancements\n    // ref: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/issues/13)\n    uint256[49] private __gap;\n}"
    }
  ]
}