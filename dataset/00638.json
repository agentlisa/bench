{
  "Title": "M-1: Fees are ignored when checks skew max in Stable Withdrawal /  Leverage Open / Leverage Adjust",
  "Content": "# Issue M-1: Fees are ignored when checks skew max in Stable Withdrawal /  Leverage Open / Leverage Adjust \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/92 \n\n## Found by \nHSP\n## Summary\nFees are ignored when checks skew max in Stable Withdrawal / Leverage Open / Leverage Adjust.\n\n## Vulnerability Detail\nWhen user [withdrawal from the stable LP](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/StableModule.sol#L96-L100), vault **total stable collateral** is updated:\n```solidity\n        vault.updateStableCollateralTotal(-int256(_amountOut));\n```\nThen **_withdrawFee** is calculated and [checkSkewMax(...)](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L296) function is called to ensure that the system will not be too skewed towards longs:\n```solidity\n            // Apply the withdraw fee if it's not the final withdrawal.\n            _withdrawFee = (stableWithdrawFee * _amountOut) / 1e18;\n\n            // additionalSkew = 0 because withdrawal was already processed above.\n            vault.checkSkewMax({additionalSkew: 0});\n```\nAt the end of the execution, vault collateral is settled again with **withdrawFee**, keeper receives **keeperFee** and `(amountOut - totalFee)` amount of collaterals are transferred to the user:\n```solidity\n        // include the fees here to check for slippage\n        amountOut -= totalFee;\n\n        if (amountOut < stableWithdraw.minAmountOut)\n            revert FlatcoinErrors.HighSlippage(amountOut, stableWithdraw.minAmountOut);\n\n        // Settle the collateral\n        vault.updateStableCollateralTotal(int256(withdrawFee)); // pay the withdrawal fee to stable LPs\n        vault.sendCollateral({to: msg.sender, amount: order.keeperFee}); // pay the keeper their fee\n        vault.sendCollateral({to: account, amount: amountOut}); // transfer remaining amount to the trader\n```\nThe `totalFee` is composed of keeper fee and withdrawal fee:\n```solidity\n        uint256 totalFee = order.keeperFee + withdrawFee;\n```\nThis means withdrawal fee is still in the vault, however this fee is ignored when checks skew max and protocol may revert on a safe withdrawal. Consider the following scenario:\n1. **skewFractionMax** is `120%` and **stableWithdrawFee** is `1%`;\n2. Alice deposits `100` collateral and Bob opens a leverage position with size `100`;\n3. At the moment, there is `100` collaterals in the Vault, **skew** is `0` and **skew fraction** is `100%`;\n4. Alice tries to withdraw `16.8` collaterals,  **withdrawFee** is `0.168`, after withdrawal, it is expected that there is `83.368` stable collaterals in the Vault, so **skewFraction** should be `119.5%`, which is less than **skewFractionMax**;\n5. However, the withdrawal will actually fail because when protocol checks skew max, **withdrawFee** is ignored and the **skewFraction** turns out to be `120.19%`, which is higher than **skewFractionMax**.\n\nThe same issue may occur when protocol executes a [leverage open](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LeverageModule.sol#L80-L84) and [leverage adjust](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LeverageModule.sol#L147-L151), in both executions, **tradeFee**  is ignored when checks skew max.\n\nPlease see the test codes:\n```solidity\n    function test_audit_withdraw_fee_ignored_when_checks_skew_max() public {\n        // skewFractionMax is 120%\n        uint256 skewFractionMax = vaultProxy.skewFractionMax();\n        assertEq(skewFractionMax, 120e16);\n\n        // withdraw fee is 1%\n        vm.prank(vaultProxy.owner());\n        stableModProxy.setStableWithdrawFee(1e16);\n\n        uint256 collateralPrice = 1000e8;\n\n        uint256 depositAmount = 100e18;\n        announceAndExecuteDeposit({\n            traderAccount: alice,\n            keeperAccount: keeper,\n            depositAmount: depositAmount,\n            oraclePrice: collateralPrice,\n            keeperFeeAmount: 0\n        });\n\n        uint256 additionalSize = 100e18;\n        announceAndExecuteLeverageOpen({\n            traderAccount: bob,\n            keeperAccount: keeper,\n            margin: 50e18,\n            additionalSize: 100e18,\n            oraclePrice: collateralPrice,\n            keeperFeeAmount: 0\n        });\n\n        // After leverage Open, skew is 0\n        int256 skewAfterLeverageOpen = vaultProxy.getCurrentSkew();\n        assertEq(skewAfterLeverageOpen, 0);\n        // skew fraction is 100%\n        uint256 skewFractionAfterLeverageOpen = getLongSkewFraction();\n        assertEq(skewFractionAfterLeverageOpen, 1e18);\n\n        // Note: comment out `vault.checkSkewMax({additionalSkew: 0})` and below lines to see the actual skew fraction\n        // Alice withdraws 16.8 collateral\n        // uint256 aliceLpBalance = stableModProxy.balanceOf(alice);\n        // announceAndExecuteWithdraw({\n        //     traderAccount: alice, \n        //     keeperAccount: keeper, \n        //     withdrawAmount: 168e17, \n        //     oraclePrice: collateralPrice, \n        //     keeperFeeAmount: 0\n        // });\n\n        // // After withdrawal, the actual skew fraction is 119.9%, less than skewFractionMax\n        // uint256 skewFactionAfterWithdrawal = getLongSkewFraction();\n        // assertEq(skewFactionAfterWithdrawal, 1199501007580846367);\n\n        // console2.log(WETH.balanceOf(address(vaultProxy)));\n    }\n```\n\n## Impact\nProtocol may wrongly prevent a Stable Withdrawal / Leverage Open / Leverage Adjust even if the execution is essentially safe.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/StableModule.sol#L130\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LeverageModule.sol#L101\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LeverageModule.sol#L166\n\n## Tool used\nManual Review\n\n## Recommendation\nInclude withdrawal fee / trade fee when check skew max.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**0xLogos**\n\nEscalate \n\nLow. Exceeding skewFractionMax is possible only by a fraction of a percent \n\n**sherlock-admin2**\n\n> Escalate \n> \n> Low. Exceeding skewFractionMax is possible only by a fraction of a percent \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**santipu03**\n\nAgree with @0xLogos. The withdrawal fee is a tiny amount compared to the total deposited collateral, therefore the impact will be almost imperceptible. The severity should be LOW. \n\n**0xhsp**\n\nThis issue is valid.\n\nThe fee maybe a tiny amount compared to the total deposited collateral, but **the impact is significant to individual users**.\n\nLet's assume **stableCollateralTotal** is 1000 ether, **stableWithdrawFee** is 1%, **skewFractionMax** is 120% and current **skewFraction** is 60%.\n\n> If withdrawal fee is ignored in the calculation of shew fraction, **withdrawAmount** is calculated as:\n\n<img width=\"508\" alt=\"1\" src=\"https://github.com/sherlock-audit/2023-12-flatmoney-judging/assets/155340699/45adbabb-49fc-4a0e-9414-ada424ba0091\">\n\n> If withdrawal fee is considered in the calculation of shew fraction, **withdrawAmount** is calculated as:\n\n<img width=\"702\" alt=\"2\" src=\"https://github.com/sherlock-audit/2023-12-flatmoney-judging/assets/155340699/e557c8b9-6bfa-40df-ac20-69bcc955c43f\">\n\nWe can notice that **5 ether less** collaterals ethers are withdrawable if fee is ignored. Just be realistic, individual user is most likely to deposit a tiny amount of collaterals, this means **many users are unable to withdraw any of their collaterals even if it is safe to do so**.\n\nSimilarly, since **tradeFee** is ignored when protocol checks a leverage open/adjustment, **many traders would be wrongly prevented from opening/adjusting any positions**.\n\n\n**0xLogos**\n\nIn first pic after withdrawing for example 300 eth, fee for that amount will be included in the next withdrawal and so forth so eventually all 505 eth can be withdrawn. Note that it's not work around, just how things work in most cases.\n\n**0xhsp**\n\nIt's not about how much user can withdraw but if user can withdraw whenever it is safe. \n\nGiven after withdrawing for example 300 eth, users expect to be able to withdraw 353.5 ether more but are only allowed 350 ether due to the issue.\n\nIncorrect checking is a high risk to the protocol, it is difficult to predict how users will operate but it would eventually cause huge impact if we ignore the risk.\n\n**santipu03**\n\nThe margin error on the calculation of `checkSkewMax` will be equal to the `tradeFee` on that operation. When the operation is using a huge amount (500 ETH), the margin error of the calculation will be of 5 ETH (assuming a 1% `tradeFee`). But if 10 users withdraw 50 ETH each, the margin error will only be 0.5 ETH on the last withdrawal.\n\nTo trigger this issue with a non-trivial margin error, it requires a user that withdraws collateral (or creates or adjusts a position) with a huge amount compared to the total collateral deposited. \n\nGiven the low probability of this issue happening with a non-trivial margin error and the impact being medium/low, I'd consider the overall severity of this issue to be LOW.\n\n**0xhsp**\n\nThe probability should be medium as you cannot predict the wild market, the impact can be high since usera may suffer a loss due to price fluncation if they cannot withdraw in time. So it's fair to say the servrity is medium.\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dhedge/flatcoin-v1/pull/280.\n\n**Evert0x**\n\nIt seems to me that the issue described can negatively affect users and breaks core contract functionality in specific (but not unrealistic) scenarios https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue\n\nTentatively planning to reject the escalation and keep the issue state as is, but will revisit it later. \n\n**Evert0x**\n\nPlanning to continue with my judgment as stated in the comment above. \n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xLogos](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/92/#issuecomment-1956105454): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/StableModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {ERC20LockableUpgradeable} from \"./misc/ERC20LockableUpgradeable.sol\";\n\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IStableModule} from \"./interfaces/IStableModule.sol\";\nimport {IPointsModule} from \"./interfaces/IPointsModule.sol\";\n\n/// @title StableModule\n/// @author dHEDGE\n/// @notice Contains functions to handle stable LP deposits and withdrawals.\ncontract StableModule is IStableModule, ModuleUpgradeable, ERC20LockableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using PerpMath for int256;\n    using PerpMath for uint256;\n\n    uint256 public constant MIN_LIQUIDITY = 10_000; // minimum totalSupply that is allowable\n\n    /// @notice Fee for stable LP redemptions.\n    /// @dev 1e18 = 100%\n    uint256 public stableWithdrawFee;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(IFlatcoinVault _vault, uint256 _stableWithdrawFee) external initializer {\n        __Module_init(FlatcoinModuleKeys._STABLE_MODULE_KEY, _vault);\n        __ERC20_init(\"Flatmoney\", \"UNIT\");\n\n        setStableWithdrawFee(_stableWithdrawFee);\n    }\n\n    /////////////////////////////////////////////\n    //         External Write Functions        //\n    /////////////////////////////////////////////\n\n    /// @notice User delayed deposit into the stable LP. Mints ERC20 token receipt.\n    /// @dev Needs to be used in conjunction with DelayedOrder module.\n    /// @param _account The usser account which has a pending deposit.\n    /// @param _executableAtTime The time at which the order can be executed.\n    /// @param _announcedDeposit The pending order.\n    /// @return _liquidityMinted The amount of LP tokens minted.\n    function executeDeposit(\n        address _account,\n        uint64 _executableAtTime,\n        FlatcoinStructs.AnnouncedStableDeposit calldata _announcedDeposit\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _liquidityMinted) {\n        uint256 depositAmount = _announcedDeposit.depositAmount;\n\n        uint32 maxAge = _getMaxAge(_executableAtTime);\n\n        _liquidityMinted = (depositAmount * (10 ** decimals())) / stableCollateralPerShare(maxAge);\n\n        if (_liquidityMinted < _announcedDeposit.minAmountOut)\n            revert FlatcoinErrors.HighSlippage(_liquidityMinted, _announcedDeposit.minAmountOut);\n\n        _mint(_account, _liquidityMinted);\n\n        vault.updateStableCollateralTotal(int256(depositAmount));\n\n        if (totalSupply() < MIN_LIQUIDITY)\n            revert FlatcoinErrors.AmountTooSmall({amount: totalSupply(), minAmount: MIN_LIQUIDITY});\n\n        // Mint points\n        IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n        pointsModule.mintDeposit(_account, _announcedDeposit.depositAmount);\n\n        emit FlatcoinEvents.Deposit(_account, depositAmount, _liquidityMinted);\n    }\n\n    /// @notice User delayed withdrawal from the stable LP. Burns ERC20 token receipt.\n    /// @dev Needs to be used in conjunction with DelayedOrder module.\n    /// @param _account The usser account which has a pending withdrawal.\n    /// @param _executableAtTime The time at which the order can be executed.\n    /// @param _announcedWithdraw The pending order.\n    /// @return _amountOut The amount of collateral withdrawn.\n    /// @return _withdrawFee The fee paid to the remaining LPs.\n    function executeWithdraw(\n        address _account,\n        uint64 _executableAtTime,\n        FlatcoinStructs.AnnouncedStableWithdraw calldata _announcedWithdraw\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _amountOut, uint256 _withdrawFee) {\n        uint256 withdrawAmount = _announcedWithdraw.withdrawAmount;\n\n        uint32 maxAge = _getMaxAge(_executableAtTime);\n\n        uint256 stableCollateralPerShareBefore = stableCollateralPerShare(maxAge);\n        _amountOut = (withdrawAmount * stableCollateralPerShareBefore) / (10 ** decimals());\n\n        // Unlock the locked LP tokens before burning.\n        // This is because if the amount to be burned is locked, the burn will fail due to `_beforeTokenTransfer`.\n        _unlock(_account, withdrawAmount);\n\n        _burn(_account, withdrawAmount);\n\n        vault.updateStableCollateralTotal(-int256(_amountOut));\n\n        uint256 stableCollateralPerShareAfter = stableCollateralPerShare(maxAge);\n\n        // Check that there is no significant impact on stable token price.\n        // This should never happen and means that too much value or not enough value was withdrawn.\n        if (totalSupply() > 0) {\n            if (\n                stableCollateralPerShareAfter < stableCollateralPerShareBefore - 1e6 ||\n                stableCollateralPerShareAfter > stableCollateralPerShareBefore + 1e6\n            ) revert FlatcoinErrors.PriceImpactDuringWithdraw();\n\n            // Apply the withdraw fee if it's not the final withdrawal.\n            _withdrawFee = (stableWithdrawFee * _amountOut) / 1e18;\n\n            // additionalSkew = 0 because withdrawal was already processed above.\n            vault.checkSkewMax({additionalSkew: 0});\n        } else {\n            // Need to check there are no longs open before allowing full system withdrawal.\n            uint256 sizeOpenedTotal = vault.getVaultSummary().globalPositions.sizeOpenedTotal;\n\n            if (sizeOpenedTotal != 0) revert FlatcoinErrors.MaxSkewReached(sizeOpenedTotal);\n            if (stableCollateralPerShareAfter != 1e18) revert FlatcoinErrors.PriceImpactDuringFullWithdraw();\n        }\n\n        emit FlatcoinEvents.Withdraw(_account, _amountOut, withdrawAmount);\n    }\n\n    /// @notice Function to lock a certain amount of an account's LP tokens.\n    /// @dev This function is used to lock LP tokens when an account announces a delayed order.\n    /// @param _account The account to lock the LP tokens from.\n    /// @param _amount The amount of LP tokens to lock.\n    function lock(address _account, uint256 _amount) public onlyAuthorizedModule {\n        _lock(_account, _amount);\n    }\n\n    /// @notice Function to unlock a certain amount of an account's LP tokens.\n    /// @dev This function is used to unlock LP tokens when an account cancels a delayed order\n    ///      or when an order is executed.\n    /// @param _account The account to unlock the LP tokens from.\n    /// @param _amount The amount of LP tokens to unlock.\n    function unlock(address _account, uint256 _amount) public onlyAuthorizedModule {\n        _unlock(_account, _amount);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Total collateral available for withdrawal.\n    /// @dev Balance takes into account trader profit and loss and funding rate.\n    /// @return _stableCollateralBalance The total collateral available for withdrawal.\n    function stableCollateralTotalAfterSettlement() public view returns (uint256 _stableCollateralBalance) {\n        return stableCollateralTotalAfterSettlement({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Function to calculate total stable side collateral after accounting for trader profit and loss and funding fees.\n    /// @param _maxAge The oldest price oracle timestamp that can be used. Set to 0 to ignore.\n    /// @return _stableCollateralBalance The total collateral available for withdrawal.\n    function stableCollateralTotalAfterSettlement(\n        uint32 _maxAge\n    ) public view returns (uint256 _stableCollateralBalance) {\n        // Assumption => pnlTotal = pnlLong + fundingAccruedLong\n        // The assumption is based on the fact that stable LPs are the counterparty to leverage traders.\n        // If the `pnlLong` is +ve that means the traders won and the LPs lost between the last funding rate update and now.\n        // Similary if the `fundingAccruedLong` is +ve that means the market was skewed short-side.\n        // When we combine these two terms, we get the total profit/loss of the leverage traders.\n        // NOTE: This function if called after settlement returns only the PnL as funding has already been adjusted\n        //      due to calling `_settleFundingFees()`. Although this still means `netTotal` includes the funding\n        //      adjusted long PnL, it might not be clear to the reader of the code.\n        int256 netTotal = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY))\n            .fundingAdjustedLongPnLTotal({maxAge: _maxAge});\n\n        // The flatcoin LPs are the counterparty to the leverage traders.\n        // So when the traders win, the flatcoin LPs lose and vice versa.\n        // Therefore we subtract the leverage trader profits and add the losses\n        int256 totalAfterSettlement = int256(vault.stableCollateralTotal()) - netTotal;\n\n        if (totalAfterSettlement < 0) {\n            _stableCollateralBalance = 0;\n        } else {\n            _stableCollateralBalance = uint256(totalAfterSettlement);\n        }\n    }\n\n    /// @notice Function to calculate the collateral per share.\n    /// @return _collateralPerShare The collateral per share.\n    function stableCollateralPerShare() public view returns (uint256 _collateralPerShare) {\n        return stableCollateralPerShare({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Function to calculate the collateral per share.\n    /// @param _maxAge The oldest price oracle timestamp that can be used.\n    /// @return _collateralPerShare The collateral per share.\n    function stableCollateralPerShare(uint32 _maxAge) public view returns (uint256 _collateralPerShare) {\n        uint256 totalSupply = totalSupply();\n\n        if (totalSupply > 0) {\n            uint256 stableBalance = stableCollateralTotalAfterSettlement(_maxAge);\n\n            _collateralPerShare = (stableBalance * (10 ** decimals())) / totalSupply;\n        } else {\n            // no shares have been minted yet\n            _collateralPerShare = 1e18;\n        }\n    }\n\n    /// @notice Quoter function for getting the stable deposit amount out.\n    /// @param _depositAmount The amount of collateral to deposit.\n    /// @return _amountOut The amount of LP tokens minted.\n    function stableDepositQuote(uint256 _depositAmount) public view returns (uint256 _amountOut) {\n        return (_depositAmount * (10 ** decimals())) / stableCollateralPerShare();\n    }\n\n    /// @notice Quoter function for getting the stable withdraw amount out.\n    /// @param _withdrawAmount The amount of LP tokens to withdraw.\n    /// @return _amountOut The amount of collateral withdrawn.\n    function stableWithdrawQuote(uint256 _withdrawAmount) public view returns (uint256 _amountOut) {\n        _amountOut = (_withdrawAmount * stableCollateralPerShare()) / (10 ** decimals());\n\n        // Take out the withdrawal fee\n        _amountOut -= (_amountOut * stableWithdrawFee) / 1e18;\n    }\n\n    /// @notice Function to get the locked amount of an account.\n    /// @param _account The account to get the locked amount for.\n    /// @return _amountLocked The amount of LP tokens locked.\n    function getLockedAmount(address _account) public view returns (uint256 _amountLocked) {\n        return _lockedAmount[_account];\n    }\n\n    /////////////////////////////////////////////\n    //            Internal Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the maximum age of the oracle price to be used.\n    /// @param _executableAtTime The time at which the order is executable.\n    /// @return _maxAge The maximum age of the oracle price to be used.\n    function _getMaxAge(uint64 _executableAtTime) internal view returns (uint32 _maxAge) {\n        return (block.timestamp - _executableAtTime).toUint32();\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Setter for the stable withdraw fee.\n    /// @dev Fees can be set to 0 if needed.\n    /// @param _stableWithdrawFee The new stable withdraw fee.\n    function setStableWithdrawFee(uint256 _stableWithdrawFee) public onlyOwner {\n        // Set fee cap to max 1%.\n        // This is to avoid fat fingering but if any change is needed, the owner needs to\n        // upgrade this module.\n        if (_stableWithdrawFee > 0.01e18) revert FlatcoinErrors.InvalidFee(_stableWithdrawFee);\n\n        stableWithdrawFee = _stableWithdrawFee;\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/FlatcoinVault.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\n\n/// @title FlatcoinVault\n/// @author dHEDGE\n/// @notice Contains state to be reused by different modules of the system.\n/// @dev Holds the stable LP deposits and leverage traders' collateral amounts.\n///      Also stores other related contract address pointers.\ncontract FlatcoinVault is IFlatcoinVault, OwnableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice The collateral token address.\n    IERC20Upgradeable public collateral;\n\n    /// @notice The last market skew recomputation timestamp.\n    uint64 public lastRecomputedFundingTimestamp;\n\n    /// @notice The minimum time that needs to expire between trade announcement and execution.\n    uint64 public minExecutabilityAge;\n\n    /// @notice The maximum amount of time that can expire between trade announcement and execution.\n    uint64 public maxExecutabilityAge;\n\n    /// @notice The last recomputed funding rate.\n    int256 public lastRecomputedFundingRate;\n\n    /// @notice Sum of funding rate over the entire lifetime of the market.\n    int256 public cumulativeFundingRate;\n\n    /// @notice Total collateral deposited by users minting the flatcoin.\n    /// @dev This value is adjusted due to funding fee payments.\n    uint256 public stableCollateralTotal;\n\n    /// @notice The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @dev Funding velocity is used for calculating the current funding rate and acts as\n    ///      a limit on how much the funding rate can change between funding re-computations.\n    ///      The units are %/day (1e18 = 100% / day at max or min skew).\n    uint256 public maxFundingVelocity;\n\n    /// @notice The skew percentage at which the funding rate velocity is at its maximum.\n    /// @dev When absolute pSkew > maxVelocitySkew, then funding velocity = maxFundingVelocity.\n    ///      The units are in % (0.1e18 = 10% skew)\n    uint256 public maxVelocitySkew;\n\n    /// @notice Maximum cap on the total stable LP deposits.\n    uint256 public stableCollateralCap;\n\n    /// @notice The maximum limit of total leverage long size vs stable LP.\n    /// @dev This prevents excessive short skew of stable LPs by capping long trader total open interest.\n    ///      Care needs to be taken when increasing this value as it can lead to the stable LPs being excessively short.\n    uint256 public skewFractionMax;\n\n    /// @notice Holds mapping between module keys and module addresses.\n    ///         A module key is a keccak256 hash of the module name.\n    /// @dev Make sure that a module key is created using the following format:\n    ///      moduleKey = bytes32(<MODULE_NAME>)\n    ///      All the module keys should reside in a single file (see FlatcoinModuleKeys.sol).\n    mapping(bytes32 moduleKey => address moduleAddress) public moduleAddress;\n\n    /// @notice Holds mapping between module addresses and their authorization status.\n    mapping(address moduleAddress => bool authorized) public isAuthorizedModule;\n\n    /// @notice Holds mapping between module keys and their pause status.\n    mapping(bytes32 moduleKey => bool paused) public isModulePaused;\n\n    /// @dev Tracks global totals of leverage trade positions to be able to:\n    ///      - price stable LP value.\n    ///      - calculate the funding rate.\n    ///      - calculate the skew.\n    ///      - calculate funding fees payments.\n    FlatcoinStructs.GlobalPositions internal _globalPositions;\n\n    /// @dev Holds mapping between user addresses and their leverage positions.\n    mapping(uint256 tokenId => FlatcoinStructs.Position userPosition) internal _positions;\n\n    modifier onlyAuthorizedModule() {\n        if (isAuthorizedModule[msg.sender] == false) revert FlatcoinErrors.OnlyAuthorizedModule(msg.sender);\n        _;\n    }\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    /// @param _owner The owner of this contract.\n    /// @param _collateral The collateral token address.\n    /// @param _maxFundingVelocity The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @param _maxVelocitySkew The skew percentage at which the funding rate velocity is at its maximum.\n    /// @param _skewFractionMax The maximum limit of total leverage long size vs stable LP.\n    /// @param _stableCollateralCap The maximum cap on the total stable LP deposits.\n    /// @param _minExecutabilityAge The minimum time that needs to expire between trade announcement and execution.\n    /// @param _maxExecutabilityAge The maximum amount of time that can expire between trade announcement and execution.\n    function initialize(\n        address _owner,\n        IERC20Upgradeable _collateral,\n        uint256 _maxFundingVelocity,\n        uint256 _maxVelocitySkew,\n        uint256 _skewFractionMax,\n        uint256 _stableCollateralCap,\n        uint64 _minExecutabilityAge,\n        uint64 _maxExecutabilityAge\n    ) external initializer {\n        if (address(_collateral) == address(0)) revert FlatcoinErrors.ZeroAddress(\"collateral\");\n\n        __Ownable_init();\n        _transferOwnership(_owner);\n\n        collateral = _collateral;\n\n        setMaxFundingVelocity(_maxFundingVelocity);\n        setMaxVelocitySkew(_maxVelocitySkew);\n        setStableCollateralCap(_stableCollateralCap);\n        setSkewFractionMax(_skewFractionMax);\n        setExecutabilityAge(_minExecutabilityAge, _maxExecutabilityAge);\n    }\n\n    /////////////////////////////////////////////\n    //            Module Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Collateral can only be withdrawn by the flatcoin contracts (Delayed Orders, Stable or Leverage module).\n    function sendCollateral(address to, uint256 amount) external onlyAuthorizedModule {\n        collateral.safeTransfer(to, amount);\n    }\n\n    /// @notice Function to set the position of a leverage trader.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _newPosition The new struct encoded position of the leverage trader.\n    /// @param _tokenId The token ID of the leverage trader.\n    function setPosition(\n        FlatcoinStructs.Position calldata _newPosition,\n        uint256 _tokenId\n    ) external onlyAuthorizedModule {\n        _positions[_tokenId] = _newPosition;\n    }\n\n    /// @notice Function to delete the position of a leverage trader.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _tokenId The token ID of the leverage trader.\n    function deletePosition(uint256 _tokenId) external onlyAuthorizedModule {\n        delete _positions[_tokenId];\n    }\n\n    /// @notice Function to update the stable collateral total.\n    /// @dev This function is only callable by the authorized modules.\n    ///      When `_stableCollateralAdjustment` is negative, it means that the stable collateral total is decreasing.\n    /// @param _stableCollateralAdjustment The adjustment to the stable collateral total.\n    function updateStableCollateralTotal(int256 _stableCollateralAdjustment) external onlyAuthorizedModule {\n        _updateStableCollateralTotal(_stableCollateralAdjustment);\n    }\n\n    /// @notice Function to update the global position data.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _price The current price of the underlying asset.\n    /// @param _marginDelta The change in the margin deposited total.\n    /// @param _additionalSizeDelta The change in the size opened total.\n    function updateGlobalPositionData(\n        uint256 _price,\n        int256 _marginDelta,\n        int256 _additionalSizeDelta\n    ) external onlyAuthorizedModule {\n        // Get the total profit loss and update the margin deposited total.\n        int256 profitLossTotal = PerpMath._profitLossTotal({globalPosition: _globalPositions, price: _price});\n\n        // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n        // However, since the funding fees are settled at the same time as the global position data is updated,\n        // we can ignore the funding fees here.\n        int256 newMarginDepositedTotal = int256(_globalPositions.marginDepositedTotal) + _marginDelta + profitLossTotal;\n\n        // Check that the sum of margin of all the leverage traders is not negative.\n        // Rounding errors shouldn't result in a negative margin deposited total given that\n        // we are rounding down the profit loss of the position.\n        // If anything, after closing the last position in the system, the `marginDepositedTotal` should can be positive.\n        // The margin may be negative if liquidations are not happening in a timely manner.\n        if (newMarginDepositedTotal < 0) {\n            revert FlatcoinErrors.InsufficientGlobalMargin();\n        }\n\n        _globalPositions = FlatcoinStructs.GlobalPositions({\n            marginDepositedTotal: uint256(newMarginDepositedTotal),\n            sizeOpenedTotal: (int256(_globalPositions.sizeOpenedTotal) + _additionalSizeDelta).toUint256(),\n            lastPrice: _price\n        });\n\n        // Profit loss of leverage traders has to be accounted for by adjusting the stable collateral total.\n        // Note that technically, even the funding fees should be accounted for when computing the stable collateral total.\n        // However, since the funding fees are settled at the same time as the global position data is updated,\n        // we can ignore the funding fees here\n        _updateStableCollateralTotal(-profitLossTotal);\n    }\n\n    /////////////////////////////////////////////\n    //            Public Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Function to settle the funding fees between longs and LPs.\n    /// @dev Anyone can call this function to settle the funding fees.\n    /// @return _fundingFees The funding fees paid to longs.\n    ///         If it's negative, longs pay shorts and vice versa.\n    function settleFundingFees() public returns (int256 _fundingFees) {\n        (int256 fundingChangeSinceRecomputed, int256 unrecordedFunding) = _getUnrecordedFunding();\n\n        // Record the funding rate change and update the cumulative funding rate.\n        cumulativeFundingRate = PerpMath._nextFundingEntry(unrecordedFunding, cumulativeFundingRate);\n\n        // Update the latest funding rate and the latest funding recomputation timestamp.\n        lastRecomputedFundingRate += fundingChangeSinceRecomputed;\n        lastRecomputedFundingTimestamp = (block.timestamp).toUint64();\n\n        // Calculate the funding fees accrued to the longs.\n        // This will be used to adjust the global margin and collateral amounts.\n        _fundingFees = PerpMath._accruedFundingTotalByLongs(_globalPositions, unrecordedFunding);\n\n        // In the worst case scenario that the last position which remained open is underwater,\n        // we set the margin deposited total to 0. We don't want to have a negative margin deposited total.\n        _globalPositions.marginDepositedTotal = (int256(_globalPositions.marginDepositedTotal) > _fundingFees)\n            ? uint256(int256(_globalPositions.marginDepositedTotal) + _fundingFees)\n            : 0;\n\n        _updateStableCollateralTotal(-_fundingFees);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Function to get a summary of the vault.\n    /// @dev This can be used by modules to get the current state of the vault.\n    /// @return _vaultSummary The vault summary struct.\n    function getVaultSummary() external view returns (FlatcoinStructs.VaultSummary memory _vaultSummary) {\n        return\n            FlatcoinStructs.VaultSummary({\n                marketSkew: int256(_globalPositions.sizeOpenedTotal) - int256(stableCollateralTotal),\n                cumulativeFundingRate: cumulativeFundingRate,\n                lastRecomputedFundingRate: lastRecomputedFundingRate,\n                lastRecomputedFundingTimestamp: lastRecomputedFundingTimestamp,\n                stableCollateralTotal: stableCollateralTotal,\n                globalPositions: _globalPositions\n            });\n    }\n\n    /// @notice Function to get the current funding rate.\n    /// @dev This can be used by modules to get the current funding rate.\n    /// @return currentFundingRate_ The current funding rate.\n    function getCurrentFundingRate() external view returns (int256 currentFundingRate_) {\n        return\n            PerpMath._currentFundingRate({\n                proportionalSkew: PerpMath._proportionalSkew({\n                    skew: int256(_globalPositions.sizeOpenedTotal) - int256(stableCollateralTotal),\n                    stableCollateralTotal: stableCollateralTotal\n                }),\n                lastRecomputedFundingRate: lastRecomputedFundingRate,\n                lastRecomputedFundingTimestamp: lastRecomputedFundingTimestamp,\n                maxFundingVelocity: maxFundingVelocity,\n                maxVelocitySkew: maxVelocitySkew\n            });\n    }\n\n    /// @notice Function to get the position details of associated with a `_tokenId`.\n    /// @dev This can be used by modules to get the position details of a leverage trader.\n    /// @param _tokenId The token ID of the leverage trader.\n    /// @return _positionDetails The position struct with details.\n    function getPosition(uint256 _tokenId) external view returns (FlatcoinStructs.Position memory _positionDetails) {\n        return _positions[_tokenId];\n    }\n\n    /// @notice Function to get the global position details.\n    /// @dev This can be used by modules to get the global position details.\n    /// @return _globalPositionsDetails The global position struct with details.\n    function getGlobalPositions()\n        external\n        view\n        returns (FlatcoinStructs.GlobalPositions memory _globalPositionsDetails)\n    {\n        return _globalPositions;\n    }\n\n    /// @notice Asserts that the system will not be too skewed towards longs after additional skew is added (position change).\n    /// @param _additionalSkew The additional skew added by either opening a long or closing an LP position.\n    function checkSkewMax(uint256 _additionalSkew) public view {\n        // check that skew is not essentially disabled\n        if (skewFractionMax < type(uint256).max) {\n            uint256 sizeOpenedTotal = _globalPositions.sizeOpenedTotal;\n\n            if (stableCollateralTotal == 0) revert FlatcoinErrors.ZeroValue(\"stableCollateralTotal\");\n\n            uint256 longSkewFraction = ((sizeOpenedTotal + _additionalSkew) * 1e18) / stableCollateralTotal;\n\n            if (longSkewFraction > skewFractionMax) revert FlatcoinErrors.MaxSkewReached(longSkewFraction);\n        }\n    }\n\n    /// @notice Reverts if the stable LP deposit cap is reached on deposit.\n    /// @param _depositAmount The amount of stable LP tokens to deposit.\n    function checkCollateralCap(uint256 _depositAmount) public view {\n        uint256 collateralCap = stableCollateralCap;\n\n        if (stableCollateralTotal + _depositAmount > collateralCap)\n            revert FlatcoinErrors.DepositCapReached(collateralCap);\n    }\n\n    /// @notice Returns the current skew of the market taking into account unnacrued funding.\n    /// @return _skew The current skew of the market.\n    function getCurrentSkew() external view returns (int256 _skew) {\n        (, int256 unrecordedFunding) = _getUnrecordedFunding();\n        uint256 sizeOpenedTotal = _globalPositions.sizeOpenedTotal;\n\n        return\n            int256(sizeOpenedTotal) -\n            int256(stableCollateralTotal) -\n            (int256(sizeOpenedTotal) * unrecordedFunding) /\n            1e18;\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Setter for the maximum leverage total skew fraction.\n    /// @dev This ensures that stable LPs are not too short by capping long trader total open interest.\n    ///      Note that `_skewFractionMax` should include 18 decimals.\n    /// @param _skewFractionMax The maximum limit of total leverage long size vs stable LP.\n    function setSkewFractionMax(uint256 _skewFractionMax) public onlyOwner {\n        if (_skewFractionMax < 1e18) revert FlatcoinErrors.InvalidSkewFractionMax(_skewFractionMax);\n\n        skewFractionMax = _skewFractionMax;\n    }\n\n    /// @notice Setter for the maximum funding velocity.\n    /// @param _newMaxFundingVelocity The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @dev NOTE: `_newMaxFundingVelocity` should include 18 decimals.\n    function setMaxFundingVelocity(uint256 _newMaxFundingVelocity) public onlyOwner {\n        settleFundingFees(); // settle funding fees before updating the max funding velocity so that positions are not affected by the change\n        maxFundingVelocity = _newMaxFundingVelocity;\n    }\n\n    /// @notice Setter for the maximum funding velocity skew.\n    /// @param _newMaxVelocitySkew The skew percentage at which the funding rate velocity is at its maximum.\n    /// @dev NOTE: `_newMaxVelocitySkew` should include 18 decimals.\n    function setMaxVelocitySkew(uint256 _newMaxVelocitySkew) public onlyOwner {\n        if (_newMaxVelocitySkew > 1e18 || _newMaxVelocitySkew == 0)\n            revert FlatcoinErrors.InvalidMaxVelocitySkew(_newMaxVelocitySkew);\n\n        settleFundingFees(); // settle funding fees before updating the max velocity skew so that positions are not affected by the change\n        maxVelocitySkew = _newMaxVelocitySkew;\n    }\n\n    /// @notice Function to add multiple authorized modules.\n    /// @dev NOTE: This function can overwrite an existing authorized module.\n    /// @param _modules The array of authorized modules to add.\n    function addAuthorizedModules(FlatcoinStructs.AuthorizedModule[] calldata _modules) external onlyOwner {\n        uint8"
    }
  ]
}