{
  "Title": "[07] Extract constant for custom attributes in `FighterFarm.sol`",
  "Content": "\nAs mentioned by the developers the value 100 is used for custom attributes:\n> guppy — 02/11/2024 3:50 PM\n   100 is a flag we use to determine if it’s a custom attribute or not\n\nTo avoid sprinkling literals in the codebase and improve it's readability it is recommended to extract this literal to a constant, something like this:\n```sol\n/// @notice Special value for custom attributes\nuint256 private constant CUSTOM_ATTRIBUTE = 100\n```\n\nAnd replacing it in the following lines: [here](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L219), [here](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L259) and [here](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L499).\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/FighterFarm.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterOps } from \"./FighterOps.sol\";\nimport { Verification } from \"./Verification.sol\";\nimport { AAMintPass } from \"./AAMintPass.sol\";\nimport { AiArenaHelper } from \"./AiArenaHelper.sol\";\nimport { Neuron } from \"./Neuron.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\n/// @title AI Arena Fighter NFT\n/// @author ArenaX Labs Inc.\n/// @notice This contract manages the creation, ownership, and redemption of AI Arena Fighter NFTs,\n/// including the ability to mint new NFTs from a merging pool or through the redemption of mint passes.\ncontract FighterFarm is ERC721, ERC721Enumerable {\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when a fighter is locked and thus cannot be traded.\n    event Locked(uint256 tokenId);\n\n    /// @notice Event emitted when a fighter is unlocked and can be traded.\n    event Unlocked(uint256 tokenId);\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The maximum amount of fighters owned by an address.\n    uint8 public constant MAX_FIGHTERS_ALLOWED = 10;\n\n    /// @notice The maximum amount of rerolls for each fighter.\n    uint8[2] public maxRerollsAllowed = [3, 3];\n\n    /// @notice The cost ($NRN) to reroll a fighter.\n    uint256 public rerollCost = 1000 * 10**18;    \n\n    /// @notice Stores the current generation for each fighter type.\n    uint8[2] public generation = [0, 0];\n\n    /// @notice Aggregate number of training sessions recorded.\n    uint32 public totalNumTrained;\n\n    /// @notice The address of treasury.\n    address public treasuryAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// The address responsible for setting token URIs and signing fighter claim messages.\n    address _delegatedAddress;\n\n    /// The address of the Merging Pool contract.\n    address _mergingPoolAddress;\n\n    /// @dev Instance of the AI Arena Helper contract.\n    AiArenaHelper _aiArenaHelperInstance;\n\n    /// @dev Instance of the AI Arena Mintpass contract (ERC721).\n    AAMintPass _mintpassInstance;\n\n    /// @dev Instance of the Neuron contract (ERC20).\n    Neuron _neuronInstance;\n\n    /// @notice List of all fighter structs, accessible by using tokenId as index.\n    FighterOps.Fighter[] public fighters;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping to keep track of whether a tokenId has staked or not.\n    mapping(uint256 => bool) public fighterStaked;\n\n    /// @notice Mapping to keep track of how many times an nft has been re-rolled.\n    mapping(uint256 => uint8) public numRerolls;\n\n    /// @notice Mapping to indicate which addresses are able to stake fighters.\n    mapping(address => bool) public hasStakerRole;\n\n    /// @notice Mapping of number elements by generation.\n    mapping(uint8 => uint8) public numElements;\n\n    /// @notice Maps address to fighter type to return the number of NFTs claimed.\n    mapping(address => mapping(uint8 => uint8)) public nftsClaimed;\n\n    /// @notice Mapping of tokenId to number of times trained.\n    mapping(uint256 => uint32) public numTrained;\n\n    /// @notice Mapping to keep track of tokenIds and their URI.\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the owner address, the delegated address.\n    /// @param ownerAddress Address of contract deployer.\n    /// @param delegatedAddress Address of delegated signer for messages.\n    /// @param treasuryAddress_ Community treasury address.\n    constructor(address ownerAddress, address delegatedAddress, address treasuryAddress_)\n        ERC721(\"AI Arena Fighter\", \"FTR\")\n    {\n        _ownerAddress = ownerAddress;\n        _delegatedAddress = delegatedAddress;\n        treasuryAddress = treasuryAddress_;\n        numElements[0] = 3;\n    } \n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Increase the generation of the specified fighter type.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param fighterType Type of fighter either 0 or 1 (champion or dendroid).\n    /// @return Generation count of the fighter type.\n    function incrementGeneration(uint8 fighterType) external returns (uint8) {\n        require(msg.sender == _ownerAddress);\n        generation[fighterType] += 1;\n        maxRerollsAllowed[fighterType] += 1;\n        return generation[fighterType];\n    }\n\n    /// @notice Adds a new address that is allowed to stake fighters on behalf of users.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newStaker The address of the new staker\n    function addStaker(address newStaker) external {\n        require(msg.sender == _ownerAddress);\n        hasStakerRole[newStaker] = true;\n    }\n\n    /// @notice Instantiates the ai arena helper contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param aiArenaHelperAddress Address of new helper contract.\n    function instantiateAIArenaHelperContract(address aiArenaHelperAddress) external {\n        require(msg.sender == _ownerAddress);\n        _aiArenaHelperInstance = AiArenaHelper(aiArenaHelperAddress);\n    }\n\n    /// @notice Instantiates the mint pass contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param mintpassAddress The address of the new AAMintPass contract instance.\n    function instantiateMintpassContract(address mintpassAddress) external {\n        require(msg.sender == _ownerAddress);\n        _mintpassInstance = AAMintPass(mintpassAddress);\n    }\n\n    /// @notice Instantiates the neuron contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param neuronAddress The address of the new Neuron contract instance.\n    function instantiateNeuronContract(address neuronAddress) external {\n        require(msg.sender == _ownerAddress);\n        _neuronInstance = Neuron(neuronAddress);\n    }\n\n    /// @notice Sets the merging pool contract address.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param mergingPoolAddress Address of the new Merging Pool contract.\n    function setMergingPoolAddress(address mergingPoolAddress) external {\n        require(msg.sender == _ownerAddress);\n        _mergingPoolAddress = mergingPoolAddress;\n    }\n\n    /// @notice Sets the tokenURI for the given tokenId.\n    /// @dev Only the delegated address is authorized to call this function.\n    /// @param tokenId The ID of the token to set the URI for.\n    /// @param newTokenURI The new URI to set for the given token.\n    function setTokenURI(uint256 tokenId, string calldata newTokenURI) external {\n        require(msg.sender == _delegatedAddress);\n        _tokenURIs[tokenId] = newTokenURI;\n    }\n\n    /// @notice Enables users to claim a pre-determined number of fighters. \n    /// @dev The function verifies the message signature is from the delegated address.\n    /// @param numToMint Array specifying the number of fighters to be claimed for each fighter type.\n    /// @param signature Signature of the claim message.\n    /// @param modelHashes Array of hashes representing the machine learning models for each fighter.\n    /// @param modelTypes Array of machine learning model types for each fighter.\n    function claimFighters(\n        uint8[2] calldata numToMint,\n        bytes calldata signature,\n        string[] calldata modelHashes,\n        string[] calldata modelTypes\n    ) \n        external \n    {\n        bytes32 msgHash = bytes32(keccak256(abi.encode(\n            msg.sender, \n            numToMint[0], \n            numToMint[1],\n            nftsClaimed[msg.sender][0],\n            nftsClaimed[msg.sender][1]\n        )));\n        require(Verification.verify(msgHash, signature, _delegatedAddress));\n        uint16 totalToMint = uint16(numToMint[0] + numToMint[1]);\n        require(modelHashes.length == totalToMint && modelTypes.length == totalToMint);\n        nftsClaimed[msg.sender][0] += numToMint[0];\n        nftsClaimed[msg.sender][1] += numToMint[1];\n        for (uint16 i = 0; i < totalToMint; i++) {\n            _createNewFighter(\n                msg.sender, \n                uint256(keccak256(abi.encode(msg.sender, fighters.length))),\n                modelHashes[i], \n                modelTypes[i],\n                i < numToMint[0] ? 0 : 1,\n                0,\n                [uint256(100), uint256(100)]\n            );\n        }\n    }\n\n    /// @notice Burns multiple mint passes in exchange for fighter NFTs.\n    /// @dev This function requires the length of all input arrays to be equal.\n    /// @dev Each input array must correspond to the same index, i.e., the first element in each \n    /// array belongs to the same mint pass, and so on.\n    /// @param mintpassIdsToBurn Array of mint pass IDs to be burned for each fighter to be minted.\n    /// @param mintPassDnas Array of DNA strings of the mint passes to be minted as fighters.\n    /// @param fighterTypes Array of fighter types corresponding to the fighters being minted.\n    /// @param modelHashes Array of ML model hashes corresponding to the fighters being minted. \n    /// @param modelTypes Array of ML model types corresponding to the fighters being minted.\n    function redeemMintPass(\n        uint256[] calldata mintpassIdsToBurn,\n        uint8[] calldata fighterTypes,\n        uint8[] calldata iconsTypes,\n        string[] calldata mintPassDnas,\n        string[] calldata modelHashes,\n        string[] calldata modelTypes\n    ) \n        external \n    {\n        require(\n            mintpassIdsToBurn.length == mintPassDnas.length && \n            mintPassDnas.length == fighterTypes.length && \n            fighterTypes.length == modelHashes.length &&\n            modelHashes.length == modelTypes.length\n        );\n        for (uint16 i = 0; i < mintpassIdsToBurn.length; i++) {\n            require(msg.sender == _mintpassInstance.ownerOf(mintpassIdsToBurn[i]));\n            _mintpassInstance.burn(mintpassIdsToBurn[i]);\n            _createNewFighter(\n                msg.sender, \n                uint256(keccak256(abi.encode(mintPassDnas[i]))), \n                modelHashes[i], \n                modelTypes[i],\n                fighterTypes[i],\n                iconsTypes[i],\n                [uint256(100), uint256(100)]\n            );\n        }\n    }\n\n    /// @notice Update the staking status of the fighter associated with the given token ID.\n    /// @dev Only addresses which have the staker role are authorized to call this function.\n    /// @param tokenId The ID of the fighter to update the staking status for.\n    /// @param stakingStatus The new staking status to set for the fighter.\n    function updateFighterStaking(uint256 tokenId, bool stakingStatus) external {\n        require(hasStakerRole[msg.sender]);\n        fighterStaked[tokenId] = stakingStatus;\n        if (stakingStatus) {\n            emit Locked(tokenId);\n        } else {\n            emit Unlocked(tokenId);\n        }\n    }\n\n    /// @notice Update the model for a token ID.\n    /// @dev Only the owner of the fighter can call this function.\n    /// @param tokenId The ID of the fighter to update the model for.\n    /// @param modelHash The hash of the machine learning model.\n    /// @param modelType The type of machine learning model.\n    function updateModel(\n        uint256 tokenId, \n        string calldata modelHash,\n        string calldata modelType\n    ) \n        external\n    {\n        require(msg.sender == ownerOf(tokenId));\n        fighters[tokenId].modelHash = modelHash;\n        fighters[tokenId].modelType = modelType;\n        numTrained[tokenId] += 1;\n        totalNumTrained += 1;\n    }\n\n    /// @notice Checks whether the given token ID exists.\n    /// @param tokenId The ID of the fighter to check for existence.\n    function doesTokenExist(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mints a new fighter from the merging pool.\n    /// @dev Only the merging pool contract address is authorized to call this function.\n    /// @param to The address that the new fighter will be assigned to.\n    /// @param modelHash The hash of the ML model associated with the fighter.\n    /// @param modelType The type of the ML model associated with the fighter.\n    /// @param customAttributes Array with [element, weight] of the newly created fighter.\n    function mintFromMergingPool(\n        address to, \n        string calldata modelHash, \n        string calldata modelType, \n        uint256[2] calldata customAttributes\n    ) \n        public \n    {\n        require(msg.sender == _mergingPoolAddress);\n        _createNewFighter(\n            to, \n            uint256(keccak256(abi.encode(msg.sender, fighters.length))), \n            modelHash, \n            modelType,\n            0,\n            0,\n            customAttributes\n        );\n    }\n\n    /// @notice Transfer NFT ownership from one address to another.\n    /// @dev Add a custom check for an ability to transfer the fighter.\n    /// @param from Address of the current owner.\n    /// @param to Address of the new owner.\n    /// @param tokenId ID of the fighter being transferred.\n    function transferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) \n        public \n        override(ERC721, IERC721)\n    {\n        require(_ableToTransfer(tokenId, to));\n        _transfer(from, to, tokenId);\n    }\n\n    /// @notice Safely transfers an NFT from one address to another.\n    /// @dev Add a custom check for an ability to transfer the fighter.\n    /// @param from Address of the current owner.\n    /// @param to Address of the new owner.\n    /// @param tokenId ID of the fighter being transferred.\n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) \n        public \n        override(ERC721, IERC721)\n    {\n        require(_ableToTransfer(tokenId, to));\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /// @notice Rolls a new fighter with random traits.\n    /// @param tokenId ID of the fighter being re-rolled.\n    /// @param fighterType The fighter type.\n    function reRoll(uint8 tokenId, uint8 fighterType) public {\n        require(msg.sender == ownerOf(tokenId));\n        require(numRerolls[tokenId] < maxRerollsAllowed[fighterType]);\n        require(_neuronInstance.balanceOf(msg.sender) >= rerollCost, \"Not enough NRN for reroll\");\n\n        _neuronInstance.approveSpender(msg.sender, rerollCost);\n        bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, rerollCost);\n        if (success) {\n            numRerolls[tokenId] += 1;\n            uint256 dna = uint256(keccak256(abi.encode(msg.sender, tokenId, numRerolls[tokenId])));\n            (uint256 element, uint256 weight, uint256 newDna) = _createFighterBase(dna, fighterType);\n            fighters[tokenId].element = element;\n            fighters[tokenId].weight = weight;\n            fighters[tokenId].physicalAttributes = _aiArenaHelperInstance.createPhysicalAttributes(\n                newDna,\n                generation[fighterType],\n                fighters[tokenId].iconsType,\n                fighters[tokenId].dendroidBool\n            );\n            _tokenURIs[tokenId] = \"\";\n        }\n    }    \n\n    /// @notice Returns the URI where the contract metadata is stored.\n    /// @return URI where the contract metadata is stored.\n    function contractURI() public pure returns (string memory) {\n        return \"ipfs://bafybeifztjs4yuwhqi7bvzhw2ufksynkoiwxss2gnti6j4v25l7iwz7y44\";\n    }\n\n    /// @notice Returns the URI where the token metadata is stored.\n    /// @param tokenId The ID of the fighter.\n    /// @return URI where the token metadata is stored.\n    function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory) {\n        return _tokenURIs[tokenId];\n    }\n\n    /// @notice Returns whether a given interface is supported by this contract.\n    /// @dev Calls ERC721.supportsInterface.\n    /// @param _interfaceId The interface ID.\n    /// @return Bool whether the interface is supported by this contract.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Returns all information related to the specified fighter token ID.\n    /// @param tokenId The unique identifier for the fighter token.\n    function getAllFighterInfo(\n        uint256 tokenId\n    )\n        public\n        view\n        returns (\n            address,\n            uint256[6] memory,\n            uint256,\n            uint256,\n            string memory,\n            string memory,\n            uint16\n        )\n    {\n        return FighterOps.viewFighterInfo(fighters[tokenId], ownerOf(tokenId));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Hook that is called before a token transfer.\n    /// @param from The address transferring the token.\n    /// @param to The address receiving the token.\n    /// @param tokenId The ID of the NFT being transferred.\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates the base attributes for the fighter.\n    /// @param dna The dna of the fighter.\n    /// @param fighterType The type of the fighter.\n    /// @return Attributes of the new fighter: element, weight, and dna.\n    function _createFighterBase(\n        uint256 dna, \n        uint8 fighterType\n    ) \n        private \n        view \n        returns (uint256, uint256, uint256) \n    {\n        uint256 element = dna % numElements[generation[fighterType]];\n        uint256 weight = dna % 31 + 65;\n        uint256 newDna = fighterType == 0 ? dna : uint256(fighterType);\n        return (element, weight, newDna);\n    }\n\n    /// @notice Creates a new fighter and mints an NFT to the specified address.\n    /// @param to The address to mint the new NFT to.\n    /// @param dna The DNA of the new fighter.\n    /// @param modelHash The hash of the ML model.\n    /// @param modelType The type of the ML model.\n    /// @param fighterType The type of fighter to create.\n    /// @param iconsType Type of icons fighter (0 means it's not an icon).\n    /// @param customAttributes Array with [element, weight] of the newly created fighter.\n    function _createNewFighter(\n        address to, \n        uint256 dna, \n        string memory modelHash,\n        string memory modelType, \n        uint8 fighterType,\n        uint8 iconsType,\n        uint256[2] memory customAttributes\n    ) \n        private \n    {  \n        require(balanceOf(to) < MAX_FIGHTERS_ALLOWED);\n        uint256 element; \n        uint256 weight;\n        uint256 newDna;\n        if (customAttributes[0] == 100) {\n            (element, weight, newDna) = _createFighterBase(dna, fighterType);\n        }\n        else {\n            element = customAttributes[0];\n            weight = customAttributes[1];\n            newDna = dna;\n        }\n        uint256 newId = fighters.length;\n\n        bool dendroidBool = fighterType == 1;\n        FighterOps.FighterPhysicalAttributes memory attrs = _aiArenaHelperInstance.createPhysicalAttributes(\n            newDna,\n            generation[fighterType],\n            iconsType,\n            dendroidBool\n        );\n        fighters.push(\n            FighterOps.Fighter(\n                weight,\n                element,\n                attrs,\n                newId,\n                modelHash,\n                modelType,\n                generation[fighterType],\n                iconsType,\n                dendroidBool\n            )\n        );\n        _safeMint(to, newId);\n        FighterOps.fighterCreatedEmitter(newId, weight, element, generation[fighterType]);\n    }\n\n    /// @notice Check if the transfer of a specific token is allowed.\n    /// @dev Cannot receive another fighter if the user already has the maximum amount.\n    /// @dev Additionally, users cannot trade fighters that are currently staked.\n    /// @param tokenId The token ID of the fighter being transferred.\n    /// @param to The address of the receiver.\n    /// @return Bool whether the transfer is allowed or not.\n    function _ableToTransfer(uint256 tokenId, address to) private view returns(bool) {\n        return (\n          _isApprovedOrOwner(msg.sender, tokenId) &&\n          balanceOf(to) < MAX_FIGHTERS_ALLOWED &&\n          !fighterStaked[tokenId]\n        );\n    }\n}"
    }
  ]
}