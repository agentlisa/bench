{
  "Title": "[G-07] Unneeded ternary logic, booleans, and second condition checks",
  "Content": "In the constructor of PoolTokens.sol, the second condition of the following require statement mandates that at least one feed is associated with each token.\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L106-L109\n\n```solidity\n        require(\n            config.feeds.length == config.nTokens && minFeedsLength(config.feeds) > 0,\n            \"each token needs at least 1 price feed\"\n        );\n```\nAdditionally, the following code lines signify that a minimum of 2 tokens will be associated with the Curve base pool. Otherwise, if `nTokens` is less than 2 or 1, assigning `token0` and/or `token1` will revert due to accessing out-of-bound array elements. \n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L132-L135\n\n```solidity\n        token0 = tokens[0];\n        token1 = tokens[1];\n        token2 = (nTokens > 2) ? tokens[2] : IERC20Metadata(address(0));\n        token3 = (nTokens > 3) ? tokens[3] : IERC20Metadata(address(0));\n```\nUnder this context, the following ternary logic along with the use of boolean `more` is therefore deemed unnecessary.\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L143-L154\n\n```diff\n        // token0\n-        bool more = config.feeds[0].length > 0;\n        // untestable:\n        //     more will always be true based on previous feeds validations\n-        _t0feed0 = more ? config.feeds[0][0] : AggregatorV3Interface(address(0));\n+        _t0feed0 = config.feeds[0][0];\n        _t0timeout0 = more && config.oracleTimeouts[0].length > 0 ? config.oracleTimeouts[0][0] : 0;\n        _t0error0 = more && config.oracleErrors[0].length > 0 ? config.oracleErrors[0][0] : 0;\n-        if (more) {\n            require(address(_t0feed0) != address(0), \"t0feed0 empty\");\n            require(_t0timeout0 > 0, \"t0timeout0 zero\");\n            require(_t0error0 < FIX_ONE, \"t0error0 too large\");\n-        }\n```\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L166-L177\n\n```diff\n        // token1\n        // untestable:\n        //     more will always be true based on previous feeds validations\n-        more = config.feeds[1].length > 0;\n-        _t1feed0 = more ? config.feeds[1][0] : AggregatorV3Interface(address(0));\n+        _t1feed0 = config.feeds[1][0];\n        _t1timeout0 = more && config.oracleTimeouts[1].length > 0 ? config.oracleTimeouts[1][0] : 0;\n        _t1error0 = more && config.oracleErrors[1].length > 0 ? config.oracleErrors[1][0] : 0;\n-        if (more) {\n            require(address(_t1feed0) != address(0), \"t1feed0 empty\");\n            require(_t1timeout0 > 0, \"t1timeout0 zero\");\n            require(_t1error0 < FIX_ONE, \"t1error0 too large\");\n-        }\n```\nSimilarly, the following second conditional checks are also not needed.\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L189-L190\n\n```diff\n        // token2\n-        more = config.feeds.length > 2 && config.feeds[2].length > 0;\n+        more = config.feeds.length > 2;\n```\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L210-L211\n\n```diff\n        // token3\n-        more = config.feeds.length > 3 && config.feeds[3].length > 0;\n+        more = config.feeds.length > 3;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-reserve",
  "Code": [
    {
      "filename": "contracts/plugins/assets/curve/PoolTokens.sol",
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.19;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"contracts/plugins/assets/OracleLib.sol\";\nimport \"contracts/libraries/Fixed.sol\";\n\n// solhint-disable func-name-mixedcase\ninterface ICurvePool {\n    // For Curve Plain Pools and V2 Metapools\n    function coins(uint256) external view returns (address);\n\n    // Only exists in Curve Lending Pools\n    function underlying_coins(uint256) external view returns (address);\n\n    // Only exists in V1 Curve Metapools; not used currently\n    function base_coins(uint256) external view returns (address);\n\n    function balances(uint256) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function exchange(\n        int128,\n        int128,\n        uint256,\n        uint256\n    ) external;\n}\n\n/// Supports Curve base pools for up to 4 tokens\ncontract PoolTokens {\n    using OracleLib for AggregatorV3Interface;\n    using FixLib for uint192;\n\n    error WrongIndex(uint8 maxLength);\n    error NoToken(uint8 tokenNumber);\n\n    enum CurvePoolType {\n        Plain,\n        Lending, // not supported in this version\n        Metapool // not supported via this class. parent class handles metapool math\n    }\n\n    // === State (Immutable) ===\n\n    ICurvePool public immutable curvePool;\n    IERC20Metadata public immutable lpToken;\n    uint8 internal immutable nTokens;\n\n    IERC20Metadata internal immutable token0;\n    IERC20Metadata internal immutable token1;\n    IERC20Metadata internal immutable token2;\n    IERC20Metadata internal immutable token3;\n\n    // For each token, we maintain up to two feeds/timeouts/errors\n    // The data below would normally be a struct, but we want bytecode substitution\n\n    AggregatorV3Interface internal immutable _t0feed0;\n    AggregatorV3Interface internal immutable _t0feed1;\n    uint48 internal immutable _t0timeout0; // {s}\n    uint48 internal immutable _t0timeout1; // {s}\n    uint192 internal immutable _t0error0; // {1}\n    uint192 internal immutable _t0error1; // {1}\n\n    AggregatorV3Interface internal immutable _t1feed0;\n    AggregatorV3Interface internal immutable _t1feed1;\n    uint48 internal immutable _t1timeout0; // {s}\n    uint48 internal immutable _t1timeout1; // {s}\n    uint192 internal immutable _t1error0; // {1}\n    uint192 internal immutable _t1error1; // {1}\n\n    AggregatorV3Interface internal immutable _t2feed0;\n    AggregatorV3Interface internal immutable _t2feed1;\n    uint48 internal immutable _t2timeout0; // {s}\n    uint48 internal immutable _t2timeout1; // {s}\n    uint192 internal immutable _t2error0; // {1}\n    uint192 internal immutable _t2error1; // {1}\n\n    AggregatorV3Interface internal immutable _t3feed0;\n    AggregatorV3Interface internal immutable _t3feed1;\n    uint48 internal immutable _t3timeout0; // {s}\n    uint48 internal immutable _t3timeout1; // {s}\n    uint192 internal immutable _t3error0; // {1}\n    uint192 internal immutable _t3error1; // {1}\n\n    // === Config ===\n\n    struct PTConfiguration {\n        uint8 nTokens;\n        ICurvePool curvePool;\n        IERC20Metadata lpToken;\n        CurvePoolType poolType;\n        AggregatorV3Interface[][] feeds; // row should multiply to give {UoA/ref}; max columns is 2\n        uint48[][] oracleTimeouts; // {s} same order as feeds\n        uint192[][] oracleErrors; // {1} same order as feeds\n    }\n\n    constructor(PTConfiguration memory config) {\n        require(config.nTokens <= 4, \"up to 4 tokens max\");\n        require(maxFeedsLength(config.feeds) <= 2, \"price feeds limited to 2\");\n        require(\n            config.feeds.length == config.nTokens && minFeedsLength(config.feeds) > 0,\n            \"each token needs at least 1 price feed\"\n        );\n        require(address(config.curvePool) != address(0), \"curvePool address is zero\");\n\n        curvePool = config.curvePool;\n        nTokens = config.nTokens;\n        lpToken = config.lpToken;\n\n        // Solidity does not support immutable arrays. This is a hack to get the equivalent of\n        // an immutable array so we do not have store the token feeds in the blockchain. This is\n        // a gas optimization since it is significantly more expensive to read and write on the\n        // blockchain than it is to use embedded values in the bytecode.\n\n        // === Tokens ===\n\n        IERC20Metadata[] memory tokens = new IERC20Metadata[](nTokens);\n        for (uint8 i = 0; i < nTokens; ++i) {\n            if (config.poolType == CurvePoolType.Plain) {\n                tokens[i] = IERC20Metadata(curvePool.coins(i));\n            } else {\n                revert(\"invalid poolType\");\n            }\n        }\n\n        token0 = tokens[0];\n        token1 = tokens[1];\n        token2 = (nTokens > 2) ? tokens[2] : IERC20Metadata(address(0));\n        token3 = (nTokens > 3) ? tokens[3] : IERC20Metadata(address(0));\n\n        // === Feeds + timeouts ===\n        // I know this lots extremely verbose and quite silly, but it actually makes sense:\n        //   - immutable variables cannot be conditionally written to\n        //   - a struct or an array would not be able to be immutable\n        //   - immutable variables means values get in-lined in the bytecode\n\n        // token0\n        bool more = config.feeds[0].length > 0;\n        // untestable:\n        //     more will always be true based on previous feeds validations\n        _t0feed0 = more ? config.feeds[0][0] : AggregatorV3Interface(address(0));\n        _t0timeout0 = more && config.oracleTimeouts[0].length > 0 ? config.oracleTimeouts[0][0] : 0;\n        _t0error0 = more && config.oracleErrors[0].length > 0 ? config.oracleErrors[0][0] : 0;\n        if (more) {\n            require(address(_t0feed0) != address(0), \"t0feed0 empty\");\n            require(_t0timeout0 > 0, \"t0timeout0 zero\");\n            require(_t0error0 < FIX_ONE, \"t0error0 too large\");\n        }\n\n        more = config.feeds[0].length > 1;\n        _t0feed1 = more ? config.feeds[0][1] : AggregatorV3Interface(address(0));\n        _t0timeout1 = more && config.oracleTimeouts[0].length > 1 ? config.oracleTimeouts[0][1] : 0;\n        _t0error1 = more && config.oracleErrors[0].length > 1 ? config.oracleErrors[0][1] : 0;\n        if (more) {\n            require(address(_t0feed1) != address(0), \"t0feed1 empty\");\n            require(_t0timeout1 > 0, \"t0timeout1 zero\");\n            require(_t0error1 < FIX_ONE, \"t0error1 too large\");\n        }\n\n        // token1\n        // untestable:\n        //     more will always be true based on previous feeds validations\n        more = config.feeds[1].length > 0;\n        _t1feed0 = more ? config.feeds[1][0] : AggregatorV3Interface(address(0));\n        _t1timeout0 = more && config.oracleTimeouts[1].length > 0 ? config.oracleTimeouts[1][0] : 0;\n        _t1error0 = more && config.oracleErrors[1].length > 0 ? config.oracleErrors[1][0] : 0;\n        if (more) {\n            require(address(_t1feed0) != address(0), \"t1feed0 empty\");\n            require(_t1timeout0 > 0, \"t1timeout0 zero\");\n            require(_t1error0 < FIX_ONE, \"t1error0 too large\");\n        }\n\n        more = config.feeds[1].length > 1;\n        _t1feed1 = more ? config.feeds[1][1] : AggregatorV3Interface(address(0));\n        _t1timeout1 = more && config.oracleTimeouts[1].length > 1 ? config.oracleTimeouts[1][1] : 0;\n        _t1error1 = more && config.oracleErrors[1].length > 1 ? config.oracleErrors[1][1] : 0;\n        if (more) {\n            require(address(_t1feed1) != address(0), \"t1feed1 empty\");\n            require(_t1timeout1 > 0, \"t1timeout1 zero\");\n            require(_t1error1 < FIX_ONE, \"t1error1 too large\");\n        }\n\n        // token2\n        more = config.feeds.length > 2 && config.feeds[2].length > 0;\n        _t2feed0 = more ? config.feeds[2][0] : AggregatorV3Interface(address(0));\n        _t2timeout0 = more && config.oracleTimeouts[2].length > 0 ? config.oracleTimeouts[2][0] : 0;\n        _t2error0 = more && config.oracleErrors[2].length > 0 ? config.oracleErrors[2][0] : 0;\n        if (more) {\n            require(address(_t2feed0) != address(0), \"t2feed0 empty\");\n            require(_t2timeout0 > 0, \"t2timeout0 zero\");\n            require(_t2error0 < FIX_ONE, \"t2error0 too large\");\n        }\n\n        more = config.feeds.length > 2 && config.feeds[2].length > 1;\n        _t2feed1 = more ? config.feeds[2][1] : AggregatorV3Interface(address(0));\n        _t2timeout1 = more && config.oracleTimeouts[2].length > 1 ? config.oracleTimeouts[2][1] : 0;\n        _t2error1 = more && config.oracleErrors[2].length > 1 ? config.oracleErrors[2][1] : 0;\n        if (more) {\n            require(address(_t2feed1) != address(0), \"t2feed1 empty\");\n            require(_t2timeout1 > 0, \"t2timeout1 zero\");\n            require(_t2error1 < FIX_ONE, \"t2error1 too large\");\n        }\n\n        // token3\n        more = config.feeds.length > 3 && config.feeds[3].length > 0;\n        _t3feed0 = more ? config.feeds[3][0] : AggregatorV3Interface(address(0));\n        _t3timeout0 = more && config.oracleTimeouts[3].length > 0 ? config.oracleTimeouts[3][0] : 0;\n        _t3error0 = more && config.oracleErrors[3].length > 0 ? config.oracleErrors[3][0] : 0;\n        if (more) {\n            require(address(_t3feed0) != address(0), \"t3feed0 empty\");\n            require(_t3timeout0 > 0, \"t3timeout0 zero\");\n            require(_t3error0 < FIX_ONE, \"t3error0 too large\");\n        }\n\n        more = config.feeds.length > 3 && config.feeds[3].length > 1;\n        _t3feed1 = more ? config.feeds[3][1] : AggregatorV3Interface(address(0));\n        _t3timeout1 = more && config.oracleTimeouts[3].length > 1 ? config.oracleTimeouts[3][1] : 0;\n        _t3error1 = more && config.oracleErrors[3].length > 1 ? config.oracleErrors[3][1] : 0;\n        if (more) {\n            require(address(_t3feed1) != address(0), \"t3feed1 empty\");\n            require(_t3timeout1 > 0, \"t3timeout1 zero\");\n            require(_t3error1 < FIX_ONE, \"t3error1 too large\");\n        }\n    }\n\n    /// @param index The index of the token: 0, 1, 2, or 3\n    /// @return low {UoA/ref_index}\n    /// @return high {UoA/ref_index}\n    function tokenPrice(uint8 index) public view returns (uint192 low, uint192 high) {\n        if (index >= nTokens) revert WrongIndex(nTokens - 1);\n\n        // Use only 1 feed if 2nd feed not defined\n        // otherwise: multiply feeds together, e.g; {UoA/ref} = {UoA/target} * {target/ref}\n        uint192 x;\n        uint192 y = FIX_ONE;\n        uint192 xErr; // {1}\n        uint192 yErr; // {1}\n        // if only 1 feed: `y` is FIX_ONE and `yErr` is 0\n\n        if (index == 0) {\n            x = _t0feed0.price(_t0timeout0);\n            xErr = _t0error0;\n            if (address(_t0feed1) != address(0)) {\n                y = _t0feed1.price(_t0timeout1);\n                yErr = _t0error1;\n            }\n        } else if (index == 1) {\n            x = _t1feed0.price(_t1timeout0);\n            xErr = _t1error0;\n            if (address(_t1feed1) != address(0)) {\n                y = _t1feed1.price(_t1timeout1);\n                yErr = _t1error1;\n            }\n        } else if (index == 2) {\n            x = _t2feed0.price(_t2timeout0);\n            xErr = _t2error0;\n            if (address(_t2feed1) != address(0)) {\n                y = _t2feed1.price(_t2timeout1);\n                yErr = _t2error1;\n            }\n        } else {\n            x = _t3feed0.price(_t3timeout0);\n            xErr = _t3error0;\n            if (address(_t3feed1) != address(0)) {\n                y = _t3feed1.price(_t3timeout1);\n                yErr = _t3error1;\n            }\n        }\n\n        return toRange(x, y, xErr, yErr);\n    }\n\n    // === Internal ===\n\n    /// @return low {UoA}\n    /// @return high {UoA}\n    function totalBalancesValue() internal view returns (uint192 low, uint192 high) {\n        for (uint8 i = 0; i < nTokens; ++i) {\n            IERC20Metadata token = getToken(i);\n            uint192 balance = shiftl_toFix(curvePool.balances(i), -int8(token.decimals()));\n            (uint192 lowP, uint192 highP) = tokenPrice(i);\n\n            low += balance.mul(lowP, FLOOR);\n            high += balance.mul(highP, CEIL);\n        }\n    }\n\n    /// @return [{tok}]\n    function getBalances() internal view virtual returns (uint192[] memory) {\n        uint192[] memory balances = new uint192[](nTokens);\n\n        for (uint8 i = 0; i < nTokens; ++i) {\n            IERC20Metadata token = getToken(i);\n            uint192 balance = shiftl_toFix(curvePool.balances(i), -int8(token.decimals()));\n            balances[i] = (balance);\n        }\n\n        return balances;\n    }\n\n    // === Private ===\n\n    function getToken(uint8 index) private view returns (IERC20Metadata) {\n        // untestable:\n        //      getToken is always called with a valid index\n        if (index >= nTokens) revert WrongIndex(nTokens - 1);\n        if (index == 0) return token0;\n        if (index == 1) return token1;\n        if (index == 2) return token2;\n        return token3;\n    }\n\n    function minFeedsLength(AggregatorV3Interface[][] memory feeds) private pure returns (uint8) {\n        uint8 minLength = type(uint8).max;\n        for (uint8 i = 0; i < feeds.length; ++i) {\n            minLength = uint8(Math.min(minLength, feeds[i].length));\n        }\n        return minLength;\n    }\n\n    function maxFeedsLength(AggregatorV3Interface[][] memory feeds) private pure returns (uint8) {\n        uint8 maxLength;\n        for (uint8 i = 0; i < feeds.length; ++i) {\n            maxLength = uint8(Math.max(maxLength, feeds[i].length));\n        }\n        return maxLength;\n    }\n\n    /// x and y can be any two fixes that can be multiplied\n    /// @param xErr {1} error associated with x\n    /// @param yErr {1} error associated with y\n    /// returns low and high extremes of x * y, given errors\n    function toRange(\n        uint192 x,\n        uint192 y,\n        uint192 xErr,\n        uint192 yErr\n    ) private pure returns (uint192 low, uint192 high) {\n        low = x.mul(FIX_ONE - xErr).mul(y.mul(FIX_ONE - yErr), FLOOR);\n        high = x.mul(FIX_ONE + xErr).mul(y.mul(FIX_ONE + yErr), CEIL);\n    }\n}"
    },
    {
      "filename": "contracts/plugins/assets/curve/PoolTokens.sol",
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.19;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"contracts/plugins/assets/OracleLib.sol\";\nimport \"contracts/libraries/Fixed.sol\";\n\n// solhint-disable func-name-mixedcase\ninterface ICurvePool {\n    // For Curve Plain Pools and V2 Metapools\n    function coins(uint256) external view returns (address);\n\n    // Only exists in Curve Lending Pools\n    function underlying_coins(uint256) external view returns (address);\n\n    // Only exists in V1 Curve Metapools; not used currently\n    function base_coins(uint256) external view returns (address);\n\n    function balances(uint256) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function exchange(\n        int128,\n        int128,\n        uint256,\n        uint256\n    ) external;\n}\n\n/// Supports Curve base pools for up to 4 tokens\ncontract PoolTokens {\n    using OracleLib for AggregatorV3Interface;\n    using FixLib for uint192;\n\n    error WrongIndex(uint8 maxLength);\n    error NoToken(uint8 tokenNumber);\n\n    enum CurvePoolType {\n        Plain,\n        Lending, // not supported in this version\n        Metapool // not supported via this class. parent class handles metapool math\n    }\n\n    // === State (Immutable) ===\n\n    ICurvePool public immutable curvePool;\n    IERC20Metadata public immutable lpToken;\n    uint8 internal immutable nTokens;\n\n    IERC20Metadata internal immutable token0;\n    IERC20Metadata internal immutable token1;\n    IERC20Metadata internal immutable token2;\n    IERC20Metadata internal immutable token3;\n\n    // For each token, we maintain up to two feeds/timeouts/errors\n    // The data below would normally be a struct, but we want bytecode substitution\n\n    AggregatorV3Interface internal immutable _t0feed0;\n    AggregatorV3Interface internal immutable _t0feed1;\n    uint48 internal immutable _t0timeout0; // {s}\n    uint48 internal immutable _t0timeout1; // {s}\n    uint192 internal immutable _t0error0; // {1}\n    uint192 internal immutable _t0error1; // {1}\n\n    AggregatorV3Interface internal immutable _t1feed0;\n    AggregatorV3Interface internal immutable _t1feed1;\n    uint48 internal immutable _t1timeout0; // {s}\n    uint48 internal immutable _t1timeout1; // {s}\n    uint192 internal immutable _t1error0; // {1}\n    uint192 internal immutable _t1error1; // {1}\n\n    AggregatorV3Interface internal immutable _t2feed0;\n    AggregatorV3Interface internal immutable _t2feed1;\n    uint48 internal immutable _t2timeout0; // {s}\n    uint48 internal immutable _t2timeout1; // {s}\n    uint192 internal immutable _t2error0; // {1}\n    uint192 internal immutable _t2error1; // {1}\n\n    AggregatorV3Interface internal immutable _t3feed0;\n    AggregatorV3Interface internal immutable _t3feed1;\n    uint48 internal immutable _t3timeout0; // {s}\n    uint48 internal immutable _t3timeout1; // {s}\n    uint192 internal immutable _t3error0; // {1}\n    uint192 internal immutable _t3error1; // {1}\n\n    // === Config ===\n\n    struct PTConfiguration {\n        uint8 nTokens;\n        ICurvePool curvePool;\n        IERC20Metadata lpToken;\n        CurvePoolType poolType;\n        AggregatorV3Interface[][] feeds; // row should multiply to give {UoA/ref}; max columns is 2\n        uint48[][] oracleTimeouts; // {s} same order as feeds\n        uint192[][] oracleErrors; // {1} same order as feeds\n    }\n\n    constructor(PTConfiguration memory config) {\n        require(config.nTokens <= 4, \"up to 4 tokens max\");\n        require(maxFeedsLength(config.feeds) <= 2, \"price feeds limited to 2\");\n        require(\n            config.feeds.length == config.nTokens && minFeedsLength(config.feeds) > 0,\n            \"each token needs at least 1 price feed\"\n        );\n        require(address(config.curvePool) != address(0), \"curvePool address is zero\");\n\n        curvePool = config.curvePool;\n        nTokens = config.nTokens;\n        lpToken = config.lpToken;\n\n        // Solidity does not support immutable arrays. This is a hack to get the equivalent of\n        // an immutable array so we do not have store the token feeds in the blockchain. This is\n        // a gas optimization since it is significantly more expensive to read and write on the\n        // blockchain than it is to use embedded values in the bytecode.\n\n        // === Tokens ===\n\n        IERC20Metadata[] memory tokens = new IERC20Metadata[](nTokens);\n        for (uint8 i = 0; i < nTokens; ++i) {\n            if (config.poolType == CurvePoolType.Plain) {\n                tokens[i] = IERC20Metadata(curvePool.coins(i));\n            } else {\n                revert(\"invalid poolType\");\n            }\n        }\n\n        token0 = tokens[0];\n        token1 = tokens[1];\n        token2 = (nTokens > 2) ? tokens[2] : IERC20Metadata(address(0));\n        token3 = (nTokens > 3) ? tokens[3] : IERC20Metadata(address(0));\n\n        // === Feeds + timeouts ===\n        // I know this lots extremely verbose and quite silly, but it actually makes sense:\n        //   - immutable variables cannot be conditionally written to\n        //   - a struct or an array would not be able to be immutable\n        //   - immutable variables means values get in-lined in the bytecode\n\n        // token0\n        bool more = config.feeds[0].length > 0;\n        // untestable:\n        //     more will always be true based on previous feeds validations\n        _t0feed0 = more ? config.feeds[0][0] : AggregatorV3Interface(address(0));\n        _t0timeout0 = more && config.oracleTimeouts[0].length > 0 ? config.oracleTimeouts[0][0] : 0;\n        _t0error0 = more && config.oracleErrors[0].length > 0 ? config.oracleErrors[0][0] : 0;\n        if (more) {\n            require(address(_t0feed0) != address(0), \"t0feed0 empty\");\n            require(_t0timeout0 > 0, \"t0timeout0 zero\");\n            require(_t0error0 < FIX_ONE, \"t0error0 too large\");\n        }\n\n        more = config.feeds[0].length > 1;\n        _t0feed1 = more ? config.feeds[0][1] : AggregatorV3Interface(address(0));\n        _t0timeout1 = more && config.oracleTimeouts[0].length > 1 ? config.oracleTimeouts[0][1] : 0;\n        _t0error1 = more && config.oracleErrors[0].length > 1 ? config.oracleErrors[0][1] : 0;\n        if (more) {\n            require(address(_t0feed1) != address(0), \"t0feed1 empty\");\n            require(_t0timeout1 > 0, \"t0timeout1 zero\");\n            require(_t0error1 < FIX_ONE, \"t0error1 too large\");\n        }\n\n        // token1\n        // untestable:\n        //     more will always be true based on previous feeds validations\n        more = config.feeds[1].length > 0;\n        _t1feed0 = more ? config.feeds[1][0] : AggregatorV3Interface(address(0));\n        _t1timeout0 = more && config.oracleTimeouts[1].length > 0 ? config.oracleTimeouts[1][0] : 0;\n        _t1error0 = more && config.oracleErrors[1].length > 0 ? config.oracleErrors[1][0] : 0;\n        if (more) {\n            require(address(_t1feed0) != address(0), \"t1feed0 empty\");\n            require(_t1timeout0 > 0, \"t1timeout0 zero\");\n            require(_t1error0 < FIX_ONE, \"t1error0 too large\");\n        }\n\n        more = config.feeds[1].length > 1;\n        _t1feed1 = more ? config.feeds[1][1] : AggregatorV3Interface(address(0));\n        _t1timeout1 = more && config.oracleTimeouts[1].length > 1 ? config.oracleTimeouts[1][1] : 0;\n        _t1error1 = more && config.oracleErrors[1].length > 1 ? config.oracleErrors[1][1] : 0;\n        if (more) {\n            require(address(_t1feed1) != address(0), \"t1feed1 empty\");\n            require(_t1timeout1 > 0, \"t1timeout1 zero\");\n            require(_t1error1 < FIX_ONE, \"t1error1 too large\");\n        }\n\n        // token2\n        more = config.feeds.length > 2 && config.feeds[2].length > 0;\n        _t2feed0 = more ? config.feeds[2][0] : AggregatorV3Interface(address(0));\n        _t2timeout0 = more && config.oracleTimeouts[2].length > 0 ? config.oracleTimeouts[2][0] : 0;\n        _t2error0 = more && config.oracleErrors[2].length > 0 ? config.oracleErrors[2][0] : 0;\n        if (more) {\n            require(address(_t2feed0) != address(0), \"t2feed0 empty\");\n            require(_t2timeout0 > 0, \"t2timeout0 zero\");\n            require(_t2error0 < FIX_ONE, \"t2error0 too large\");\n        }\n\n        more = config.feeds.length > 2 && config.feeds[2].length > 1;\n        _t2feed1 = more ? config.feeds[2][1] : AggregatorV3Interface(address(0));\n        _t2timeout1 = more && config.oracleTimeouts[2].length > 1 ? config.oracleTimeouts[2][1] : 0;\n        _t2error1 = more && config.oracleErrors[2].length > 1 ? config.oracleErrors[2][1] : 0;\n        if (more) {\n            require(address(_t2feed1) != address(0), \"t2feed1 empty\");\n            require(_t2timeout1 > 0, \"t2timeout1 zero\");\n            require(_t2error1 < FIX_ONE, \"t2error1 too large\");\n        }\n\n        // token3\n        more = config.feeds.length > 3 && config.feeds[3].length > 0;\n        _t3feed0 = more ? config.feeds[3][0] : AggregatorV3Interface(address(0));\n        _t3timeout0 = more && config.oracleTimeouts[3].length > 0 ? config.oracleTimeouts[3][0] : 0;\n        _t3error0 = more && config.oracleErrors[3].length > 0 ? config.oracleErrors[3][0] : 0;\n        if (more) {\n            require(address(_t3feed0) != address(0), \"t3feed0 empty\");\n            require(_t3timeout0 > 0, \"t3timeout0 zero\");\n            require(_t3error0 < FIX_ONE, \"t3error0 too large\");\n        }\n\n        more = config.feeds.length > 3 && config.feeds[3].length > 1;\n        _t3feed1 = more ? config.feeds[3][1] : AggregatorV3Interface(address(0));\n        _t3timeout1 = more && config.oracleTimeouts[3].length > 1 ? config.oracleTimeouts[3][1] : 0;\n        _t3error1 = more && config.oracleErrors[3].length > 1 ? config.oracleErrors[3][1] : 0;\n        if (more) {\n            require(address(_t3feed1) != address(0), \"t3feed1 empty\");\n            require(_t3timeout1 > 0, \"t3timeout1 zero\");\n            require(_t3error1 < FIX_ONE, \"t3error1 too large\");\n        }\n    }\n\n    /// @param index The index of the token: 0, 1, 2, or 3\n    /// @return low {UoA/ref_index}\n    /// @return high {UoA/ref_index}\n    function tokenPrice(uint8 index) public view returns (uint192 low, uint192 high) {\n        if (index >= nTokens) revert WrongIndex(nTokens - 1);\n\n        // Use only 1 feed if 2nd feed not defined\n        // otherwise: multiply feeds together, e.g; {UoA/ref} = {UoA/target} * {target/ref}\n        uint192 x;\n        uint192 y = FIX_ONE;\n        uint192 xErr; // {1}\n        uint192 yErr; // {1}\n        // if only 1 feed: `y` is FIX_ONE and `yErr` is 0\n\n        if (index == 0) {\n            x = _t0feed0.price(_t0timeout0);\n            xErr = _t0error0;\n            if (address(_t0feed1) != address(0)) {\n                y = _t0feed1.price(_t0timeout1);\n                yErr = _t0error1;\n            }\n        } else if (index == 1) {\n            x = _t1feed0.price(_t1timeout0);\n            xErr = _t1error0;\n            if (address(_t1feed1) != address(0)) {\n                y = _t1feed1.price(_t1timeout1);\n                yErr = _t1error1;\n            }\n        } else if (index == 2) {\n            x = _t2feed0.price(_t2timeout0);\n            xErr = _t2error0;\n            if (address(_t2feed1) != address(0)) {\n                y = _t2feed1.price(_t2timeout1);\n                yErr = _t2error1;\n            }\n        } else {\n            x = _t3feed0.price(_t3timeout0);\n            xErr = _t3error0;\n            if (address(_t3feed1) != address(0)) {\n                y = _t3feed1.price(_t3timeout1);\n                yErr = _t3error1;\n            }\n        }\n\n        return toRange(x, y, xErr, yErr);\n    }\n\n    // === Internal ===\n\n    /// @return low {UoA}\n    /// @return high {UoA}\n    function totalBalancesValue() internal view returns (uint192 low, uint192 high) {\n        for (uint8 i = 0; i < nTokens; ++i) {\n            IERC20Metadata token = getToken(i);\n            uint192 balance = shiftl_toFix(curvePool.balances(i), -int8(token.decimals()));\n            (uint192 lowP, uint192 highP) = tokenPrice(i);\n\n            low += balance.mul(lowP, FLOOR);\n            high += balance.mul(highP, CEIL);\n        }\n    }\n\n    /// @return [{tok}]\n    function getBalances() internal view virtual returns (uint192[] memory) {\n        uint192[] memory balances = new uint192[](nTokens);\n\n        for (uint8 i = 0; i < nTokens; ++i) {\n            IERC20Metadata token = getToken(i);\n            uint192 balance = shiftl_toFix(curvePool.balances(i), -int8(token.decimals()));\n            balances[i] = (balance);\n        }\n\n        return balances;\n    }\n\n    // === Private ===\n\n    function getToken(uint8 index) private view returns (IERC20Metadata) {\n        // untestable:\n        //      getToken is always called with a valid index\n        if (index >= nTokens) revert WrongIndex(nTokens - 1);\n        if (index == 0) return token0;\n        if (index == 1) return token1;\n        if (index == 2) return token2;\n        return token3;\n    }\n\n    function minFeedsLength(AggregatorV3Interface[][] memory feeds) private pure returns (uint8) {\n        uint8 minLength = type(uint8).max;\n        for (uint8 i = 0; i < feeds.length; ++i) {\n            minLength = uint8(Math.min(minLength, feeds[i].length));\n        }\n        return minLength;\n    }\n\n    function maxFeedsLength(AggregatorV3Interface[][] memory feeds) private pure returns (uint8) {\n        uint8 maxLength;\n        for (uint8 i = 0; i < feeds.length; ++i) {\n            maxLength = uint8(Math.max(maxLength, feeds[i].length));\n        }\n        return maxLength;\n    }\n\n    /// x and y can be any two fixes that can be multiplied\n    /// @param xErr {1} error associated with x\n    /// @param yErr {1} error associated with y\n    /// returns low and high extremes of x * y, given errors\n    function toRange(\n        uint192 x,\n        uint192 y,\n        uint192 xErr,\n        uint192 yErr\n    ) private pure returns (uint192 low, uint192 high) {\n        low = x.mul(FIX_ONE - xErr).mul(y.mul(FIX_ONE - yErr), FLOOR);\n        high = x.mul(FIX_ONE + xErr).mul(y.mul(FIX_ONE + yErr), CEIL);\n    }\n}"
    },
    {
      "filename": "contracts/plugins/assets/curve/PoolTokens.sol",
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.19;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"contracts/plugins/assets/OracleLib.sol\";\nimport \"contracts/libraries/Fixed.sol\";\n\n// solhint-disable func-name-mixedcase\ninterface ICurvePool {\n    // For Curve Plain Pools and V2 Metapools\n    function coins(uint256) external view returns (address);\n\n    // Only exists in Curve Lending Pools\n    function underlying_coins(uint256) external view returns (address);\n\n    // Only exists in V1 Curve Metapools; not used currently\n    function base_coins(uint256) external view returns (address);\n\n    function balances(uint256) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function exchange(\n        int128,\n        int128,\n        uint256,\n        uint256\n    ) external;\n}\n\n/// Supports Curve base pools for up to 4 tokens\ncontract PoolTokens {\n    using OracleLib for AggregatorV3Interface;\n    using FixLib for uint192;\n\n    error WrongIndex(uint8 maxLength);\n    error NoToken(uint8 tokenNumber);\n\n    enum CurvePoolType {\n        Plain,\n        Lending, // not supported in this version\n        Metapool // not supported via this class. parent class handles metapool math\n    }\n\n    // === State (Immutable) ===\n\n    ICurvePool public immutable curvePool;\n    IERC20Metadata public immutable lpToken;\n    uint8 internal immutable nTokens;\n\n    IERC20Metadata internal immutable token0;\n    IERC20Metadata internal immutable token1;\n    IERC20Metadata internal immutable token2;\n    IERC20Metadata internal immutable token3;\n\n    // For each token, we maintain up to two feeds/timeouts/errors\n    // The data below would normally be a struct, but we want bytecode substitution\n\n    AggregatorV3Interface internal immutable _t0feed0;\n    AggregatorV3Interface internal immutable _t0feed1;\n    uint48 internal immutable _t0timeout0; // {s}\n    uint48 internal immutable _t0timeout1; // {s}\n    uint192 internal immutable _t0error0; // {1}\n    uint192 internal immutable _t0error1; // {1}\n\n    AggregatorV3Interface internal immutable _t1feed0;\n    AggregatorV3Interface internal immutable _t1feed1;\n    uint48 internal immutable _t1timeout0; // {s}\n    uint48 internal immutable _t1timeout1; // {s}\n    uint192 internal immutable _t1error0; // {1}\n    uint192 internal immutable _t1error1; // {1}\n\n    AggregatorV3Interface internal immutable _t2feed0;\n    AggregatorV3Interface internal immutable _t2feed1;\n    uint48 internal immutable _t2timeout0; // {s}\n    uint48 internal immutable _t2timeout1; // {s}\n    uint192 internal immutable _t2error0; // {1}\n    uint192 internal immutable _t2error1; // {1}\n\n    AggregatorV3Interface internal immutable _t3feed0;\n    AggregatorV3Interface internal immutable _t3feed1;\n    uint48 internal immutable _t3timeout0; // {s}\n    uint48 internal immutable _t3timeout1; // {s}\n    uint192 internal immutable _t3error0; // {1}\n    uint192 internal immutable _t3error1; // {1}\n\n    // === Config ===\n\n    struct PTConfiguration {\n        uint8 nTokens;\n        ICurvePool curvePool;\n        IERC20Metadata lpToken;\n        CurvePoolType poolType;\n        AggregatorV3Interface[][] feeds; // row should multiply to give {UoA/ref}; max columns is 2\n        uint48[][] oracleTimeouts; // {s} same order as feeds\n        uint192[][] oracleErrors; // {1} same order as feeds\n    }\n\n    constructor(PTConfiguration memory config) {\n        require(config.nTokens <= 4, \"up to 4 tokens max\");\n        require(maxFeedsLength(config.feeds) <= 2, \"price feeds limited to 2\");\n        require(\n            config.feeds.length == config.nTokens && minFeedsLength(config.feeds) > 0,\n            \"each token needs at least 1 price feed\"\n        );\n        require(address(config.curvePool) != address(0), \"curvePool address is zero\");\n\n        cu"
    }
  ]
}