{
  "Title": "M-3: updateCommitmentBorrowers does not delete all existing users",
  "Content": "# Issue M-3: updateCommitmentBorrowers does not delete all existing users \n\nSource: https://github.com/sherlock-audit/2023-03-teller-judging/issues/88 \n\n## Found by \ncducrest-brainbot, monrel, nobody2018\n## Summary\n\n`delete` a complex structure that includes mapping will cause problem. See [[ethereum/solidity#11843](https://github.com/ethereum/solidity/pull/11843)](https://github.com/ethereum/solidity/pull/11843) for more info.\n\n## Vulnerability Detail\n\nThe lender can update the list of borrowers by calling `LenderCommitmentForwarder.updateCommitmentBorrowers`. The list of borrowers is EnumerableSetUpgradeable.AddressSet that is a complex structure containing mapping. Using the `delete` keyword to delete this structure will not erase the mapping inside it. Let's look at the code of this function.\n\n```solidity\nmapping(uint256 => EnumerableSetUpgradeable.AddressSet)\n        internal commitmentBorrowersList;\n        \nfunction updateCommitmentBorrowers(\n        uint256 _commitmentId,\n        address[] calldata _borrowerAddressList\n    ) public commitmentLender(_commitmentId) {\n        delete commitmentBorrowersList[_commitmentId];\n        _addBorrowersToCommitmentAllowlist(_commitmentId, _borrowerAddressList);\n    }\n```\n\nI wrote a similar function to prove the problem.\n\n```solidity\nusing EnumerableSet for EnumerableSet.AddressSet;\n    mapping(uint256 => EnumerableSet.AddressSet) internal users;\n    \n    function test_deleteEnumerableSet() public {\n        uint256 id = 1;\n        address[] memory newUsers = new address[](2);\n        newUsers[0] = address(0x1);\n        newUsers[1] = address(0x2);\n\n        for (uint256 i = 0; i < newUsers.length; i++) {\n            users[id].add(newUsers[i]);\n        }\n        delete users[id];\n        newUsers[0] = address(0x3);\n        newUsers[1] = address(0x4);\n        for (uint256 i = 0; i < newUsers.length; i++) {\n            users[id].add(newUsers[i]);\n        }\n        bool exist = users[id].contains(address(0x1));\n        if(exist) {\n            emit log_string(\"address(0x1) exist\");\n        }\n        exist = users[id].contains(address(0x2));\n        if(exist) {\n            emit log_string(\"address(0x2) exist\");\n        }\n    }\n/*\n[PASS] test_deleteEnumerableSet() (gas: 174783)\nLogs:\n  address(0x1) exist\n  address(0x2) exist\n*/\n```\n\n## Impact\n\nThe deleted Users can still successfully call `LenderCommitmentForwarder.acceptCommitment` to get a loan.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/LenderCommitmentForwarder.sol#L240-L246\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn order to clean an `EnumerableSet`, you can either remove all elements one by one or create a fresh instance using an array of `EnumerableSet`.\n\n\n\n## Discussion\n\n**ethereumdegen**\n\nGithub PR : [Issue 88 - Changing the way borrowers are updated for Lender Commitment](https://github.com/teller-protocol/teller-protocol-v2/pull/90)\n\n**IAm0x52**\n\nFix looks good. updateCommitmentBorrowers has been split into two separate functions:\n\naddCommitmentBorrowers - Explicitly adds borrowers listed\nremoveCommitmentBorrowers - Explicitly removes borrowers listed\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/62",
  "Code": [
    {
      "filename": "teller-protocol-v2/packages/contracts/contracts/LenderCommitmentForwarder.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"./TellerV2MarketForwarder.sol\";\n\n// Interfaces\nimport \"./interfaces/ICollateralManager.sol\";\nimport { Collateral, CollateralType } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\n// Libraries\nimport { MathUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\ncontract LenderCommitmentForwarder is TellerV2MarketForwarder {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    enum CommitmentCollateralType {\n        NONE, // no collateral required\n        ERC20,\n        ERC721,\n        ERC1155,\n        ERC721_ANY_ID,\n        ERC1155_ANY_ID\n    }\n\n    /**\n     * @notice Details about a lender's capital commitment.\n     * @param maxPrincipal Amount of tokens being committed by the lender. Max amount that can be loaned.\n     * @param expiration Expiration time in seconds, when the commitment expires.\n     * @param maxDuration Length of time, in seconds that the lender's capital can be lent out for.\n     * @param minInterestRate Minimum Annual percentage to be applied for loans using the lender's capital.\n     * @param collateralTokenAddress The address for the token contract that must be used to provide collateral for loans for this commitment.\n     * @param maxPrincipalPerCollateralAmount The amount of principal that can be used for a loan per each unit of collateral, expanded additionally by principal decimals.\n     * @param collateralTokenType The type of asset of the collateralTokenAddress (ERC20, ERC721, or ERC1155).\n     * @param lender The address of the lender for this commitment.\n     * @param marketId The market id for this commitment.\n     * @param principalTokenAddress The address for the token contract that will be used to provide principal for loans of this commitment.\n     */\n    struct Commitment {\n        uint256 maxPrincipal;\n        uint32 expiration;\n        uint32 maxDuration;\n        uint16 minInterestRate;\n        address collateralTokenAddress;\n        uint256 collateralTokenId;\n        uint256 maxPrincipalPerCollateralAmount;\n        CommitmentCollateralType collateralTokenType;\n        address lender;\n        uint256 marketId;\n        address principalTokenAddress;\n    }\n\n    // CommitmentId => commitment\n    mapping(uint256 => Commitment) public commitments;\n\n    uint256 commitmentCount;\n\n    mapping(uint256 => EnumerableSetUpgradeable.AddressSet)\n        internal commitmentBorrowersList;\n\n    /**\n     * @notice This event is emitted when a lender's commitment is created.\n     * @param lender The address of the lender.\n     * @param marketId The Id of the market the commitment applies to.\n     * @param lendingToken The address of the asset being committed.\n     * @param tokenAmount The amount of the asset being committed.\n     */\n    event CreatedCommitment(\n        uint256 indexed commitmentId,\n        address lender,\n        uint256 marketId,\n        address lendingToken,\n        uint256 tokenAmount\n    );\n\n    /**\n     * @notice This event is emitted when a lender's commitment is updated.\n     * @param commitmentId The id of the commitment that was updated.\n     * @param lender The address of the lender.\n     * @param marketId The Id of the market the commitment applies to.\n     * @param lendingToken The address of the asset being committed.\n     * @param tokenAmount The amount of the asset being committed.\n     */\n    event UpdatedCommitment(\n        uint256 indexed commitmentId,\n        address lender,\n        uint256 marketId,\n        address lendingToken,\n        uint256 tokenAmount\n    );\n\n    /**\n     * @notice This event is emitted when the allowed borrowers for a commitment is updated.\n     * @param commitmentId The id of the commitment that was updated.\n     */\n    event UpdatedCommitmentBorrowers(uint256 indexed commitmentId);\n\n    /**\n     * @notice This event is emitted when a lender's commitment has been deleted.\n     * @param commitmentId The id of the commitment that was deleted.\n     */\n    event DeletedCommitment(uint256 indexed commitmentId);\n\n    /**\n     * @notice This event is emitted when a lender's commitment is exercised for a loan.\n     * @param commitmentId The id of the commitment that was exercised.\n     * @param borrower The address of the borrower.\n     * @param tokenAmount The amount of the asset being committed.\n     * @param bidId The bid id for the loan from TellerV2.\n     */\n    event ExercisedCommitment(\n        uint256 indexed commitmentId,\n        address borrower,\n        uint256 tokenAmount,\n        uint256 bidId\n    );\n\n    error InsufficientCommitmentAllocation(\n        uint256 allocated,\n        uint256 requested\n    );\n    error InsufficientBorrowerCollateral(uint256 required, uint256 actual);\n\n    /** Modifiers **/\n\n    modifier commitmentLender(uint256 _commitmentId) {\n        require(\n            commitments[_commitmentId].lender == _msgSender(),\n            \"unauthorized commitment lender\"\n        );\n        _;\n    }\n\n    function validateCommitment(Commitment storage _commitment) internal {\n        require(\n            _commitment.expiration > uint32(block.timestamp),\n            \"expired commitment\"\n        );\n        require(\n            _commitment.maxPrincipal > 0,\n            \"commitment principal allocation 0\"\n        );\n\n        if (_commitment.collateralTokenType != CommitmentCollateralType.NONE) {\n            require(\n                _commitment.maxPrincipalPerCollateralAmount > 0,\n                \"commitment collateral ratio 0\"\n            );\n\n            if (\n                _commitment.collateralTokenType ==\n                CommitmentCollateralType.ERC20\n            ) {\n                require(\n                    _commitment.collateralTokenId == 0,\n                    \"commitment collateral token id must be 0 for ERC20\"\n                );\n            }\n        }\n    }\n\n    /** External Functions **/\n\n    constructor(address _protocolAddress, address _marketRegistry)\n        TellerV2MarketForwarder(_protocolAddress, _marketRegistry)\n    {}\n\n    /**\n     * @notice Creates a loan commitment from a lender for a market.\n     * @param _commitment The new commitment data expressed as a struct\n     * @param _borrowerAddressList The array of borrowers that are allowed to accept loans using this commitment\n     * @return commitmentId_ returns the commitmentId for the created commitment\n     */\n    function createCommitment(\n        Commitment calldata _commitment,\n        address[] calldata _borrowerAddressList\n    ) public returns (uint256 commitmentId_) {\n        commitmentId_ = commitmentCount++;\n\n        require(\n            _commitment.lender == _msgSender(),\n            \"unauthorized commitment creator\"\n        );\n\n        commitments[commitmentId_] = _commitment;\n\n        validateCommitment(commitments[commitmentId_]);\n\n        _addBorrowersToCommitmentAllowlist(commitmentId_, _borrowerAddressList);\n\n        emit CreatedCommitment(\n            commitmentId_,\n            _commitment.lender,\n            _commitment.marketId,\n            _commitment.principalTokenAddress,\n            _commitment.maxPrincipal\n        );\n    }\n\n    /**\n     * @notice Updates the commitment of a lender to a market.\n     * @param _commitmentId The Id of the commitment to update.\n     * @param _commitment The new commitment data expressed as a struct\n     */\n    function updateCommitment(\n        uint256 _commitmentId,\n        Commitment calldata _commitment\n    ) public commitmentLender(_commitmentId) {\n        require(\n            _commitment.principalTokenAddress ==\n                commitments[_commitmentId].principalTokenAddress,\n            \"Principal token address cannot be updated.\"\n        );\n        require(\n            _commitment.marketId == commitments[_commitmentId].marketId,\n            \"Market Id cannot be updated.\"\n        );\n\n        commitments[_commitmentId] = _commitment;\n\n        validateCommitment(commitments[_commitmentId]);\n\n        emit UpdatedCommitment(\n            _commitmentId,\n            _commitment.lender,\n            _commitment.marketId,\n            _commitment.principalTokenAddress,\n            _commitment.maxPrincipal\n        );\n    }\n\n    /**\n     * @notice Updates the borrowers allowed to accept a commitment\n     * @param _commitmentId The Id of the commitment to update.\n     * @param _borrowerAddressList The array of borrowers that are allowed to accept loans using this commitment\n     */\n    function updateCommitmentBorrowers(\n        uint256 _commitmentId,\n        address[] calldata _borrowerAddressList\n    ) public commitmentLender(_commitmentId) {\n        delete commitmentBorrowersList[_commitmentId];\n        _addBorrowersToCommitmentAllowlist(_commitmentId, _borrowerAddressList);\n    }\n\n    /**\n     * @notice Adds a borrower to the allowlist for a commmitment.\n     * @param _commitmentId The id of the commitment that will allow the new borrower\n     * @param _borrowerArray the address array of the borrowers that will be allowed to accept loans using the commitment\n     */\n    function _addBorrowersToCommitmentAllowlist(\n        uint256 _commitmentId,\n        address[] calldata _borrowerArray\n    ) internal {\n        for (uint256 i = 0; i < _borrowerArray.length; i++) {\n            commitmentBorrowersList[_commitmentId].add(_borrowerArray[i]);\n        }\n        emit UpdatedCommitmentBorrowers(_commitmentId);\n    }\n\n    /**\n     * @notice Removes the commitment of a lender to a market.\n     * @param _commitmentId The id of the commitment to delete.\n     */\n    function deleteCommitment(uint256 _commitmentId)\n        public\n        commitmentLender(_commitmentId)\n    {\n        delete commitments[_commitmentId];\n        delete commitmentBorrowersList[_commitmentId];\n        emit DeletedCommitment(_commitmentId);\n    }\n\n    /**\n     * @notice Reduces the commitment amount for a lender to a market.\n     * @param _commitmentId The id of the commitment to modify.\n     * @param _tokenAmountDelta The amount of change in the maxPrincipal.\n     */\n    function _decrementCommitment(\n        uint256 _commitmentId,\n        uint256 _tokenAmountDelta\n    ) internal {\n        commitments[_commitmentId].maxPrincipal -= _tokenAmountDelta;\n    }\n\n    /**\n     * @notice Accept the commitment to submitBid and acceptBid using the funds\n     * @dev LoanDuration must be longer than the market payment cycle\n     * @param _commitmentId The id of the commitment being accepted.\n     * @param _principalAmount The amount of currency to borrow for the loan.\n     * @param _collateralAmount The amount of collateral to use for the loan.\n     * @param _collateralTokenId The tokenId of collateral to use for the loan if ERC721 or ERC1155.\n     * @param _collateralTokenAddress The contract address to use for the loan collateral tokens.\n     * @param _interestRate The interest rate APY to use for the loan in basis points.\n     * @param _loanDuration The overall duration for the loan.  Must be longer than market payment cycle duration.\n     * @return bidId The ID of the loan that was created on TellerV2\n     */\n    function acceptCommitment(\n        uint256 _commitmentId,\n        uint256 _principalAmount,\n        uint256 _collateralAmount,\n        uint256 _collateralTokenId,\n        address _collateralTokenAddress,\n        uint16 _interestRate,\n        uint32 _loanDuration\n    ) external returns (uint256 bidId) {\n        address borrower = _msgSender();\n\n        Commitment storage commitment = commitments[_commitmentId];\n\n        validateCommitment(commitment);\n\n        require(\n            _collateralTokenAddress == commitment.collateralTokenAddress,\n            \"Mismatching collateral token\"\n        );\n        require(\n            _interestRate >= commitment.minInterestRate,\n            \"Invalid interest rate\"\n        );\n        require(\n            _loanDuration <= commitment.maxDuration,\n            \"Invalid loan max duration\"\n        );\n\n        require(\n            commitmentBorrowersList[_commitmentId].length() == 0 ||\n                commitmentBorrowersList[_commitmentId].contains(borrower),\n            \"unauthorized commitment borrower\"\n        );\n\n        if (_principalAmount > commitment.maxPrincipal) {\n            revert InsufficientCommitmentAllocation({\n                allocated: commitment.maxPrincipal,\n                requested: _principalAmount\n            });\n        }\n\n        uint256 requiredCollateral = getRequiredCollateral(\n            _principalAmount,\n            commitment.maxPrincipalPerCollateralAmount,\n            commitment.collateralTokenType,\n            commitment.collateralTokenAddress,\n            commitment.principalTokenAddress\n        );\n\n        if (_collateralAmount < requiredCollateral) {\n            revert InsufficientBorrowerCollateral({\n                required: requiredCollateral,\n                actual: _collateralAmount\n            });\n        }\n\n        if (\n            commitment.collateralTokenType == CommitmentCollateralType.ERC721 ||\n            commitment.collateralTokenType ==\n            CommitmentCollateralType.ERC721_ANY_ID\n        ) {\n            require(\n                _collateralAmount == 1,\n                \"invalid commitment collateral amount for ERC721\"\n            );\n        }\n\n        if (\n            commitment.collateralTokenType == CommitmentCollateralType.ERC721 ||\n            commitment.collateralTokenType == CommitmentCollateralType.ERC1155\n        ) {\n            require(\n                commitment.collateralTokenId == _collateralTokenId,\n                \"invalid commitment collateral tokenId\"\n            );\n        }\n\n        bidId = _submitBidFromCommitment(\n            borrower,\n            commitment.marketId,\n            commitment.principalTokenAddress,\n            _principalAmount,\n            commitment.collateralTokenAddress,\n            _collateralAmount,\n            _collateralTokenId,\n            commitment.collateralTokenType,\n            _loanDuration,\n            _interestRate\n        );\n\n        _acceptBid(bidId, commitment.lender);\n\n        _decrementCommitment(_commitmentId, _principalAmount);\n\n        emit ExercisedCommitment(\n            _commitmentId,\n            borrower,\n            _principalAmount,\n            bidId\n        );\n    }\n\n    /**\n     * @notice Calculate the amount of collateral required to borrow a loan with _principalAmount of principal\n     * @param _principalAmount The amount of currency to borrow for the loan.\n     * @param _maxPrincipalPerCollateralAmount The ratio for the amount of principal that can be borrowed for each amount of collateral. This is expanded additionally by the principal decimals.\n     * @param _collateralTokenType The type of collateral for the loan either ERC20, ERC721, ERC1155, or None.\n     * @param _collateralTokenAddress The contract address for the collateral for the loan.\n     * @param _principalTokenAddress The contract address for the principal for the loan.\n     */\n    function getRequiredCollateral(\n        uint256 _principalAmount,\n        uint256 _maxPrincipalPerCollateralAmount,\n        CommitmentCollateralType _collateralTokenType,\n        address _collateralTokenAddress,\n        address _principalTokenAddress\n    ) public view virtual returns (uint256) {\n        if (_collateralTokenType == CommitmentCollateralType.NONE) {\n            return 0;\n        }\n\n        uint8 collateralDecimals;\n        uint8 principalDecimals = IERC20MetadataUpgradeable(\n            _principalTokenAddress\n        ).decimals();\n\n        if (_collateralTokenType == CommitmentCollateralType.ERC20) {\n            collateralDecimals = IERC20MetadataUpgradeable(\n                _collateralTokenAddress\n            ).decimals();\n        }\n\n        /*\n         * The principalAmount is expanded by (collateralDecimals+principalDecimals) to increase precision\n         * and then it is divided by _maxPrincipalPerCollateralAmount which should already been expanded by principalDecimals\n         */\n        return\n            MathUpgradeable.mulDiv(\n                _principalAmount,\n                (10**(collateralDecimals + principalDecimals)),\n                _maxPrincipalPerCollateralAmount,\n                MathUpgradeable.Rounding.Up\n            );\n    }\n\n    /**\n     * @notice Return the array of borrowers that are allowlisted for a commitment\n     * @param _commitmentId The commitment id for the commitment to query.\n     * @return borrowers_ An array of addresses restricted to accept the commitment. Empty array means unrestricted.\n     */\n    function getCommitmentBorrowers(uint256 _commitmentId)\n        external\n        view\n        returns (address[] memory borrowers_)\n    {\n        borrowers_ = commitmentBorrowersList[_commitmentId].values();\n    }\n\n    /**\n     * @notice Internal function to submit a bid to the lending protocol using a commitment\n     * @param _borrower The address of the borrower for the loan.\n     * @param _marketId The id for the market of the loan in the lending protocol.\n     * @param _principalTokenAddress The contract address for the principal token.\n     * @param _principalAmount The amount of principal to borrow for the loan.\n     * @param _collateralTokenAddress The contract address for the collateral token.\n     * @param _collateralAmount The amount of collateral to use for the loan.\n     * @param _collateralTokenId The tokenId for the collateral (if it is ERC721 or ERC1155).\n     * @param _collateralTokenType The type of collateral token (ERC20,ERC721,ERC1177,None).\n     * @param _loanDuration The duration of the loan in seconds delta.  Must be longer than loan payment cycle for the market.\n     * @param _interestRate The amount of interest APY for the loan expressed in basis points.\n     */\n    function _submitBidFromCommitment(\n        address _borrower,\n        uint256 _marketId,\n        address _principalTokenAddress,\n        uint256 _principalAmount,\n        address _collateralTokenAddress,\n        uint256 _collateralAmount,\n        uint256 _collateralTokenId,\n        CommitmentCollateralType _collateralTokenType,\n        uint32 _loanDuration,\n        uint16 _interestRate\n    ) internal returns (uint256 bidId) {\n        CreateLoanArgs memory createLoanArgs;\n        createLoanArgs.marketId = _marketId;\n        createLoanArgs.lendingToken = _principalTokenAddress;\n        createLoanArgs.principal = _principalAmount;\n        createLoanArgs.duration = _loanDuration;\n        createLoanArgs.interestRate = _interestRate;\n\n        Collateral[] memory collateralInfo;\n        if (_collateralTokenType != CommitmentCollateralType.NONE) {\n            collateralInfo = new Collateral[](1);\n            collateralInfo[0] = Collateral({\n                _collateralType: _getEscrowCollateralType(_collateralTokenType),\n                _tokenId: _collateralTokenId,\n                _amount: _collateralAmount,\n                _collateralAddress: _collateralTokenAddress\n            });\n        }\n\n        bidId = _submitBidWithCollateral(\n            createLoanArgs,\n            collateralInfo,\n            _borrower\n        );\n    }\n\n    /**\n     * @notice Return the collateral type based on the commitmentcollateral type.  Collateral type is used in the base lending protocol.\n     * @param _type The type of collateral to be used for the loan.\n     */\n    function _getEscrowCollateralType(CommitmentCollateralType _type)\n        internal\n        pure\n        returns (CollateralType)\n    {\n        if (_type == CommitmentCollateralType.ERC20) {\n            return CollateralType.ERC20;\n        }\n        if (\n            _type == CommitmentCollateralType.ERC721 ||\n            _type == CommitmentCollateralType.ERC721_ANY_ID\n        ) {\n            return CollateralType.ERC721;\n        }\n        if (\n            _type == CommitmentCollateralType.ERC1155 ||\n            _type == CommitmentCollateralType.ERC1155_ANY_ID\n        ) {\n            return CollateralType.ERC1155;\n        }\n\n        revert(\"Unknown Collateral Type\");\n    }\n}"
    }
  ]
}