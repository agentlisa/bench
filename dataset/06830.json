{
  "Title": "[N-06] Remove redundant check in `stake` function",
  "Content": "The following check is redundant:  \n\n[Link](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L206)  \n```solidity\nrequire(IERC20(muteToken).balanceOf(address(this)) > 0, \"MuteAmplifier::stake: no reward balance\");\n```\n\nThis check is redundant because before this check there is [another check](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L205) that `startTime!=0` which means the [`initializeDeposit`](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L160-L172) function has been called which ensures the `MUTE` balance is not zero.  \n\nThere are edge cases where the current check would apply, e.g. when staking occurs after the `endTime`. But the current check is not sufficient in this case because there could just be a little excess `MUTE` balance in the contract and the user would still not get rewards. So I recommend to remove the existing check and the edge cases will be addressed by the other changes I propose in this report.  \n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-mute",
  "Code": [
    {
      "filename": "contracts/amplifier/MuteAmplifier.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../libraries/SafeMath.sol';\nimport '../libraries/TransferHelper.sol';\nimport '../libraries/Ownable.sol';\nimport '../interfaces/IERC20.sol';\nimport '../interfaces/IMuteSwitchPairDynamic.sol';\n\n\n/// @notice Stake Token-Token Mute LP tokens for Token rewards\ncontract MuteAmplifier is Ownable{\n    using SafeMath for uint256;\n    using TransferHelper for address;\n\n    /* ======== EVENTS ======== */\n    event Deposit(uint256 totalRewards, uint256 startTime, uint256 endTime);\n    event Stake(address indexed staker, uint256 lpTokenIn);\n    event Payout(address indexed staker, uint256 reward, uint256 remainder);\n    event FeePayout(address indexed staker, uint256 fee0, uint256 fee1);\n    event Withdraw(address indexed staker, uint256 lpTokenOut, uint256 remainder);\n    event Refresh(uint256 totalRewards, uint256 startTime, uint256 endTime);\n\n\n    /* ======== STATE VARIABLES ======== */\n\n    address public lpToken; // MuteSwitchPairDynamic token\n    address public muteToken; // mute token\n    address public dToken; // dmute contract\n\n    uint256 public totalStakers; // total # of individual stakers\n    uint256 public totalRewards; // total amount of mute emissions\n    uint256 public totalFees0; // total fees accumulated for the lp token0\n    uint256 public totalFees1; // total fees accumulated for the lp token1\n    uint256 public totalReclaimed; // total amount of mute reclaimed to treasury\n    uint256 public totalClaimedRewards; // total amount of mute claimed by stakers\n    uint256 public totalClaimedFees0; // total amount of lp token0 fees claimed by stakers\n    uint256 public totalClaimedFees1; // total amount of lp token1 fees claimed by stakers\n\n    uint256 public startTime; // when to start emissions\n    uint256 public firstStakeTime; // timestamp of first deposit\n    uint256 public endTime; // when to end emissions\n\n    uint256 private _totalStakeLpToken; // total amount of lp tokens staked\n    uint256 private _totalWeight; // total weight of rewards to lp tokens\n    uint256 private _totalWeightFee0; // total weight of lp token0 fees to lp tokens\n    uint256 private _totalWeightFee1; // total weight of lp token1 fees to lp tokens\n\n    uint256 private _mostRecentValueCalcTime; // latest update modifier timestamp\n\n    uint256 public _stakeDivisor; // divisor set in place for modification of reward boost\n\n    uint256 public management_fee; // lp withdrawal fee\n    address public treasury; // address that receives the lp withdrawal fee\n\n    uint private unlocked = 1;\n\n    mapping(address => uint256) public userClaimedRewards; // total mute rewards users have claimed\n\n    mapping(address => uint256) private _userStakedLpToken; // total lp tokens a user has deposited\n    mapping(address => uint256) private _userWeighted; // a users weight of rewards to lp tokens at the moment of a users deposit\n    mapping(address => uint256) private _userWeightedFee0; // a users weight of lp token0 fees to lp tokens at the moment of a users deposit\n    mapping(address => uint256) private _userWeightedFee1; // a users weight of lp token1 fees to lp tokens at the moment of a users deposit\n\n    mapping(address => uint256) private _userAccumulated; // cache of rewards users have not yet pulled out yet\n    mapping(address => uint256) private _userStakedBlock; // the latest block a user deposited - used for dMute multipler\n\n    // contract view info for a specific user\n    struct DripInfo {\n      uint256 perSecondReward;\n      uint256 totalLP;\n      uint256 multiplier_current;\n      uint256 multiplier_last;\n      uint256 currentReward;\n      uint256 fee0;\n      uint256 fee1;\n    }\n\n    /* ======== MODIFIERS ======== */\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'ReentrancyGuard: reentrant call');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    modifier update() {\n        if (_mostRecentValueCalcTime == 0) {\n            _mostRecentValueCalcTime = firstStakeTime;\n        }\n\n        uint256 totalCurrentStake = totalStake();\n\n        if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {\n            uint256 value = 0;\n            uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime);\n            uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime));\n\n            if (block.timestamp < endTime) {\n                value = sinceLastCalc.mul(perSecondReward);\n            } else {\n                uint256 sinceEndTime = block.timestamp.sub(endTime);\n                value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward);\n            }\n\n            _totalWeight = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));\n\n            _mostRecentValueCalcTime = block.timestamp;\n\n            (uint fee0, uint fee1) = IMuteSwitchPairDynamic(lpToken).claimFees();\n\n            _totalWeightFee0 = _totalWeightFee0.add(fee0.mul(10**18).div(totalCurrentStake));\n            _totalWeightFee1 = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));\n\n            totalFees0 = totalFees0.add(fee0);\n            totalFees1 = totalFees1.add(fee1);\n        }\n\n        _;\n    }\n\n    /* ======== CONSTRUCTOR ======== */\n\n    /**\n     *  @notice sets the amplifier pool variables on launch\n     *  @param _lpToken address\n     *  @param _muteToken address\n     *  @param _dToken address\n     *  @param divisor uint\n     *  @param _mgmt_fee uint\n     *  @param _treasury address\n     */\n    constructor (address _lpToken, address _muteToken, address _dToken, uint256 divisor, uint256 _mgmt_fee, address _treasury) {\n        require(divisor >= 10 ** 18, \"MuteAmplifier: invalid _stakeDivisor\");\n        require(_lpToken != address(0), \"MuteAmplifier: invalid lpToken\");\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        require(_dToken != address(0), \"MuteAmplifier: invalid dToken\");\n        require(_mgmt_fee >= 0 && _mgmt_fee <= 1000, \"MuteAmplifier: invalid _mgmt_fee\");\n        require(_treasury != address(0), \"MuteAmplifier: invalid treasury\");\n\n        lpToken = _lpToken;\n        muteToken = _muteToken;\n        dToken = _dToken;\n        _stakeDivisor = divisor;\n        management_fee = _mgmt_fee; //bps 10k\n        treasury = _treasury;\n\n        TransferHelper.safeApprove(muteToken, _dToken, type(uint256).max);\n    }\n\n\n    /* ======== OWNER FUNCTIONS ======== */\n\n    /**\n     *  @notice sets the start and end time of this pool. Rewards must be sent in prior to calling this function. Can only be called once\n     *  @param _startTime address\n     *  @param _endTime address\n     */\n    function initializeDeposit(uint256 _startTime, uint256 _endTime) external virtual onlyOwner {\n        require(startTime == 0, \"MuteAmplifier::deposit: already received deposit\");\n        require(_startTime >= block.timestamp, \"MuteAmplifier::deposit: start time must be in future\");\n        require(_endTime > _startTime, \"MuteAmplifier::deposit: end time must after start time\");\n\n        totalRewards = IERC20(muteToken).balanceOf(address(this));\n        require(totalRewards > 0, \"MuteAmplifier::deposit: no rewards\");\n\n        startTime = _startTime;\n        endTime = _endTime;\n\n        emit Deposit(totalRewards, _startTime, _endTime);\n    }\n\n    /**\n     *  @notice withdraws tokens not meant to be in this contract\n     *  @param tokenToRescue address\n     *  @param to address\n     *  @param amount uint256\n     */\n    function rescueTokens(address tokenToRescue, address to, uint256 amount) external virtual onlyOwner nonReentrant {\n        if (tokenToRescue == lpToken) {\n            require(amount <= IERC20(lpToken).balanceOf(address(this)).sub(_totalStakeLpToken),\n                \"MuteAmplifier::rescueTokens: that Token-Eth belongs to stakers\"\n            );\n        } else if (tokenToRescue == muteToken) {\n            if (totalStakers > 0) {\n                require(amount <= IERC20(muteToken).balanceOf(address(this)).sub(totalRewards.sub(totalClaimedRewards)),\n                    \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"\n                );\n            }\n        }\n\n        IERC20(tokenToRescue).transfer(to, amount);\n    }\n\n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice stakes a certain amount of lp tokens\n     *  @param lpTokenIn uint\n     */\n    function stake(uint256 lpTokenIn) external virtual update nonReentrant {\n        require(lpTokenIn > 0, \"MuteAmplifier::stake: missing stake\");\n        require(block.timestamp >= startTime && startTime !=0, \"MuteAmplifier::stake: not live yet\");\n        require(IERC20(muteToken).balanceOf(address(this)) > 0, \"MuteAmplifier::stake: no reward balance\");\n\n        if (firstStakeTime == 0) {\n            firstStakeTime = block.timestamp;\n        } else {\n            require(block.timestamp < endTime, \"MuteAmplifier::stake: staking is over\");\n        }\n\n        lpToken.safeTransferFrom(msg.sender, address(this), lpTokenIn);\n\n        if (totalUserStake(msg.sender) == 0) {\n            totalStakers = totalStakers.add(1);\n        }\n\n        _stake(lpTokenIn, msg.sender);\n\n        emit Stake(msg.sender, lpTokenIn);\n    }\n\n    /**\n     * @notice  Transfer reward tokens from contract to sender, withdraw lp and apply tax\n     */\n    function withdraw() external virtual update nonReentrant returns (uint256 lpTokenOut, uint256 reward, uint256 remainder, uint256 fee0, uint256 fee1) {\n        totalStakers = totalStakers.sub(1);\n\n        (lpTokenOut, reward, remainder, fee0, fee1) = _applyReward(msg.sender);\n\n        if (lpTokenOut > 0) {\n            uint256 fee = lpTokenOut.mul(management_fee).div(10000);\n            lpToken.safeTransfer(msg.sender, lpTokenOut.sub(fee));\n            lpToken.safeTransfer(treasury, fee);\n        }\n\n        // remaining allocated rewards sent back\n        if(remainder > 0){\n          totalReclaimed = totalReclaimed.add(remainder);\n          IERC20(muteToken).transfer(treasury, remainder);\n        }\n        // payout rewards\n        if (reward > 0) {\n            uint256 week_time = 60 * 60 * 24 * 7;\n            IDMute(dToken).LockTo(reward, week_time ,msg.sender);\n\n            userClaimedRewards[msg.sender] = userClaimedRewards[msg.sender].add(\n                reward\n            );\n            totalClaimedRewards = totalClaimedRewards.add(reward);\n\n            emit Payout(msg.sender, reward, remainder);\n        }\n\n        // payout fee0 fee1\n        if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) {\n            address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(msg.sender, fee0);\n            address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(msg.sender, fee1);\n\n            totalClaimedFees0 = totalClaimedFees0.add(fee0);\n            totalClaimedFees1 = totalClaimedFees1.add(fee1);\n\n            emit FeePayout(msg.sender, fee0, fee1);\n        }\n\n\n        emit Withdraw(msg.sender, lpTokenOut, remainder);\n    }\n\n    /**\n     * @notice  Transfer reward tokens from contract to sender, restake lp\n     */\n    function payout() external virtual update nonReentrant returns (uint256 reward) {\n        require(block.timestamp < endTime, \"MuteAmplifier::payout: withdraw instead\");\n\n        (uint256 lpTokenOut, uint256 _reward, uint256 remainder, uint fee0, uint fee1) = _applyReward(msg.sender);\n\n        reward = _reward;\n        // remaining allocated rewards sent back\n        if(remainder > 0){\n          totalReclaimed = totalReclaimed.add(remainder);\n          IERC20(muteToken).transfer(treasury, remainder);\n        }\n        // payout rewards\n        if (reward > 0) {\n            uint256 week_time = 1 weeks;\n            IDMute(dToken).LockTo(reward, week_time ,msg.sender);\n\n            userClaimedRewards[msg.sender] = userClaimedRewards[msg.sender].add(\n                reward\n            );\n            totalClaimedRewards = totalClaimedRewards.add(reward);\n        }\n\n        // payout fee0 fee1\n        if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) {\n            address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(msg.sender, fee0);\n            address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(msg.sender, fee1);\n\n            totalClaimedFees0 = totalClaimedFees0.add(fee0);\n            totalClaimedFees1 = totalClaimedFees1.add(fee1);\n\n            emit FeePayout(msg.sender, fee0, fee1);\n        }\n\n        _stake(lpTokenOut, msg.sender);\n\n        emit Payout(msg.sender, _reward, remainder);\n    }\n\n    /**\n     *  @notice stakes a certain amount of lp tokens to an account\n     *  @param lpTokenIn uint\n     *  @param account address\n     */\n    function _stake(uint256 lpTokenIn, address account) private {\n        uint256 addBackLpToken;\n\n        if (totalUserStake(account) > 0) {\n            (uint256 lpTokenOut, uint256 reward, uint256 remainder, uint fee0, uint fee1) = _applyReward(account);\n            addBackLpToken = lpTokenOut;\n            _userStakedLpToken[account] = lpTokenOut;\n            _userAccumulated[account] = reward;\n\n            // remaining allocated rewards sent back\n            if(remainder > 0){\n              totalReclaimed = totalReclaimed.add(remainder);\n              IERC20(muteToken).transfer(treasury, remainder);\n            }\n\n            // payout fee0 fee1\n            if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) {\n                address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(account, fee0);\n                address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(account, fee1);\n\n                totalClaimedFees0 = totalClaimedFees0.add(fee0);\n                totalClaimedFees1 = totalClaimedFees1.add(fee1);\n\n                emit FeePayout(account, fee0, fee1);\n            }\n        }\n\n        _userStakedLpToken[account] = _userStakedLpToken[account].add(\n            lpTokenIn\n        );\n\n        _userWeighted[account] = _totalWeight;\n        _userWeightedFee0[account] = _totalWeightFee0;\n        _userWeightedFee1[account] = _totalWeightFee1;\n\n        _userStakedBlock[account] = block.number;\n\n        _totalStakeLpToken = _totalStakeLpToken.add(lpTokenIn);\n\n        if (addBackLpToken > 0) {\n            _totalStakeLpToken = _totalStakeLpToken.add(addBackLpToken);\n        }\n    }\n\n    /**\n     *  @notice applys the current reward for an account and resets its state\n     *  @param account address\n     */\n    function _applyReward(address account) private returns (uint256 lpTokenOut, uint256 reward, uint256 remainder, uint256 fee0, uint256 fee1) {\n        lpTokenOut = totalUserStake(account);\n        require(lpTokenOut > 0, \"MuteAmplifier::_applyReward: no coins staked\");\n\n        // current rewards based on multiplier\n        reward = lpTokenOut.mul(_totalWeight.sub(_userWeighted[account])).div(calculateMultiplier(account, true));\n        // max possible rewards\n        remainder = lpTokenOut.mul(_totalWeight.sub(_userWeighted[account])).div(10**18);\n        // calculate left over rewards\n        remainder = remainder.sub(reward);\n        // add back any accumulated rewards\n        reward = reward.add(_userAccumulated[account]);\n\n        fee0 = lpTokenOut.mul(_totalWeightFee0.sub(_userWeightedFee0[account])).div(10**18);\n\n        fee1 = lpTokenOut.mul(_totalWeightFee1.sub(_userWeightedFee1[account])).div(10**18);\n\n        _totalStakeLpToken = _totalStakeLpToken.sub(lpTokenOut);\n\n        _userStakedLpToken[account] = 0;\n\n        _userAccumulated[account] = 0;\n    }\n\n    /* ======== HELPER FUNCTIONS ======== */\n\n    /**\n     *  @notice returns total lp tokens staked\n     */\n    function totalStake() public view returns (uint256 total) {\n        total = _totalStakeLpToken;\n    }\n\n    /**\n     *  @notice returns total lp tokens staked for a certain user\n     */\n    function totalUserStake(address user) public view returns (uint256 total) {\n        total = _userStakedLpToken[user];\n    }\n\n    /**\n     *  @notice returns the latest block a user staked at\n     */\n    function userStakedBlock(address user) external view returns (uint256 num) {\n        num = _userStakedBlock[user];\n    }\n\n    /**\n     *  @notice returns drip info for certain user\n     *  @param user address\n     */\n    function dripInfo(address user) external view returns (DripInfo memory info) {\n\n        info.perSecondReward = totalRewards.div(endTime.sub(firstStakeTime));\n        info.totalLP = _totalStakeLpToken;\n        info.multiplier_current = calculateMultiplier(user, false);\n        info.multiplier_last = calculateMultiplier(user, true);\n\n\n        uint256 totalCurrentStake = totalStake();\n        if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {\n            uint256 value = 0;\n            uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime);\n\n            if (block.timestamp < endTime) {\n                value = sinceLastCalc.mul(info.perSecondReward);\n            } else {\n                uint256 sinceEndTime = block.timestamp.sub(endTime);\n                value = (sinceLastCalc.sub(sinceEndTime)).mul(info.perSecondReward);\n            }\n\n            uint256 totWeightLocal = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));\n\n            (uint fee0, uint fee1) = IMuteSwitchPairDynamic(lpToken).claimFeesView(user);\n\n            uint256 _totalWeightFee0Local = _totalWeightFee0.add(fee0.mul(10**18).div(totalCurrentStake));\n            uint256 _totalWeightFee1Local = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));\n\n            // current rewards based on multiplier\n            info.currentReward = totalUserStake(user).mul(totWeightLocal.sub(_userWeighted[user])).div(info.multiplier_last);\n            // add back any accumulated rewards\n            info.currentReward = info.currentReward.add(_userAccumulated[user]);\n\n\n            info.fee0 = totalUserStake(user).mul(_totalWeightFee0Local.sub(_userWeightedFee0[user])).div(10**18);\n            info.fee1 = totalUserStake(user).mul(_totalWeightFee1Local.sub(_userWeightedFee1[user])).div(10**18);\n\n        } else {\n          // current rewards based on multiplier\n          info.currentReward = totalUserStake(user).mul(_totalWeight.sub(_userWeighted[user])).div(info.multiplier_last);\n          // add back any accumulated rewards\n          info.currentReward = info.currentReward.add(_userAccumulated[user]);\n        }\n\n    }\n\n\n\n    /**\n     *  @notice returns the multiplier for a certain user based on their dMute holdings to pool ratio.\n     *  toggling enforce shows the account difference betweeen its staked multiplier and current\n     *  e.g stakedivisor of 2e18 = 50% starting point\n     *  1e18 = max reward value\n     *  2e18 - (((2e18- 1e18) * (5000 * 10e18 / 10000) / 10e18)) = 1.5e18\n     *  @param account address\n     *  @param enforce bool\n     */\n    function calculateMultiplier(address account, bool enforce) public view returns (uint256) {\n        require(account != address(0), \"MuteAmplifier::calculateMultiplier: missing account\");\n\n        uint256 accountDTokenValue;\n\n        // zkSync block.number = L1 batch number. This at times is the same for a few minutes. To avoid breaking the call to the dMute contract\n        // we take the previous block into account\n        uint256 staked_block =  _userStakedBlock[account] == block.number ? _userStakedBlock[account] - 1 : _userStakedBlock[account];\n\n        if(staked_block != 0 && enforce)\n          accountDTokenValue = IDMute(dToken).getPriorVotes(account, staked_block);\n        else\n          accountDTokenValue = IDMute(dToken).getPriorVotes(account, block.number - 1);\n\n        if(accountDTokenValue == 0){\n          return _stakeDivisor;\n        }\n\n        uint256 stakeDifference = _stakeDivisor.sub(10 ** 18);\n\n        // ratio of dMute holdings to pool\n        uint256 tokenRatio = accountDTokenValue.mul(10**18).div(totalRewards);\n\n        stakeDifference = stakeDifference.mul(clamp_value(tokenRatio, 10**18)).div(10**18);\n\n        return _stakeDivisor.sub(stakeDifference);\n    }\n\n\n\n\n    /**\n     *  @notice returns the multiplier for a certain user based on their dMute underlying usd value their staked lp usd value.\n     *  toggling enforce shows the account difference betweeen its staked multiplier and current\n     *  e.g stakedivisor of 2e18 = 50% starting point\n     *  1e18 = max reward value\n     *  2e18 - (((2e18- 1e18) * (5000 * 10e18 / 10000) / 10e18)) = 1.5e18\n     *  @param account address\n     *  @param enforce bool\n     */\n\n    /*\n    function calculateMultiplier(address account, bool enforce) public view returns (uint256) {\n        require(account != address(0), \"MuteAmplifier::calculateMultiplier: missing account\");\n\n        uint ratio;\n\n        // zkSync block.number = L1 batch number. This at times is the same for a few minutes. To avoid breaking the call to the dMute contract\n        // we take the previous block into account\n        uint256 staked_block =  _userStakedBlock[account] == block.number ? _userStakedBlock[account] - 1 : _userStakedBlock[account];\n\n        if(staked_block!= 0 && enforce)\n          ratio = IAmplifierOracleHub().holdingsToMuteRatio(account, _lpToken, _userStakedLpToken[account], staked_block);\n        else\n          ratio = IAmplifierOracleHub().holdingsToMuteRatio(account, _lpToken, _userStakedLpToken[account], block.number - 1);\n\n        if(ratio == 0){\n          return _stakeDivisor;\n        }\n\n        uint256 stakeDifference = _stakeDivisor.sub(10 ** 18).mul(clamp_value(ratio.div(10**18), 10**18)).div(10**18);\n\n        return _stakeDivisor.sub(stakeDifference);\n    }\n    */\n\n\n    /**\n     *  @notice returns the clamped value based on the max clamp limit\n     *  @param min uint\n     *  @param max uint\n     */\n    function clamp_value(uint min, uint max) pure public returns (uint) {\n        if (min < max) {\n            return min;\n        } else {\n            return max;\n        }\n    }\n}\n\n\ninterface IDMute {\n    function balanceOf(address account) external view returns(uint256 amount);\n    function getPriorVotes(address account, uint256 block) external view returns(uint256 amount);\n    function LockTo(uint256 _amount, uint256 _lock_time, address to) external;\n}"
    },
    {
      "filename": "contracts/amplifier/MuteAmplifier.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../libraries/SafeMath.sol';\nimport '../libraries/TransferHelper.sol';\nimport '../libraries/Ownable.sol';\nimport '../interfaces/IERC20.sol';\nimport '../interfaces/IMuteSwitchPairDynamic.sol';\n\n\n/// @notice Stake Token-Token Mute LP tokens for Token rewards\ncontract MuteAmplifier is Ownable{\n    using SafeMath for uint256;\n    using TransferHelper for address;\n\n    /* ======== EVENTS ======== */\n    event Deposit(uint256 totalRewards, uint256 startTime, uint256 endTime);\n    event Stake(address indexed staker, uint256 lpTokenIn);\n    event Payout(address indexed staker, uint256 reward, uint256 remainder);\n    event FeePayout(address indexed staker, uint256 fee0, uint256 fee1);\n    event Withdraw(address indexed staker, uint256 lpTokenOut, uint256 remainder);\n    event Refresh(uint256 totalRewards, uint256 startTime, uint256 endTime);\n\n\n    /* ======== STATE VARIABLES ======== */\n\n    address public lpToken; // MuteSwitchPairDynamic token\n    address public muteToken; // mute token\n    address public dToken; // dmute contract\n\n    uint256 public totalStakers; // total # of individual stakers\n    uint256 public totalRewards; // total amount of mute emissions\n    uint256 public totalFees0; // total fees accumulated for the lp token0\n    uint256 public totalFees1; // total fees accumulated for the lp token1\n    uint256 public totalReclaimed; // total amount of mute reclaimed to treasury\n    uint256 public totalClaimedRewards; // total amount of mute claimed by stakers\n    uint256 public totalClaimedFees0; // total amount of lp token0 fees claimed by stakers\n    uint256 public totalClaimedFees1; // total amount of lp token1 fees claimed by stakers\n\n    uint256 public startTime; // when to start emissions\n    uint256 public firstStakeTime; // timestamp of first deposit\n    uint256 public endTime; // when to end emissions\n\n    uint256 private _totalStakeLpToken; // total amount of lp tokens staked\n    uint256 private _totalWeight; // total weight of rewards to lp tokens\n    uint256 private _totalWeightFee0; // total weight of lp token0 fees to lp tokens\n    uint256 private _totalWeightFee1; // total weight of lp token1 fees to lp tokens\n\n    uint256 private _mostRecentValueCalcTime; // latest update modifier timestamp\n\n    uint256 public _stakeDivisor; // divisor set in place for modification of reward boost\n\n    uint256 public management_fee; // lp withdrawal fee\n    address public treasury; // address that receives the lp withdrawal fee\n\n    uint private unlocked = 1;\n\n    mapping(address => uint256) public userClaimedRewards; // total mute rewards users have claimed\n\n    mapping(address => uint256) private _userStakedLpToken; // total lp tokens a user has deposited\n    mapping(address => uint256) private _userWeighted; // a users weight of rewards to lp tokens at the moment of a users deposit\n    mapping(address => uint256) private _userWeightedFee0; // a users weight of lp token0 fees to lp tokens at the moment of a users deposit\n    mapping(address => uint256) private _userWeightedFee1; // a users weight of lp token1 fees to lp tokens at the moment of a users deposit\n\n    mapping(address => uint256) private _userAccumulated; // cache of rewards users have not yet pulled out yet\n    mapping(address => uint256) private _userStakedBlock; // the latest block a user deposited - used for dMute multipler\n\n    // contract view info for a specific user\n    struct DripInfo {\n      uint256 perSecondReward;\n      uint256 totalLP;\n      uint256 multiplier_current;\n      uint256 multiplier_last;\n      uint256 currentReward;\n      uint256 fee0;\n      uint256 fee1;\n    }\n\n    /* ======== MODIFIERS ======== */\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'ReentrancyGuard: reentrant call');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    modifier update() {\n        if (_mostRecentValueCalcTime == 0) {\n            _mostRecentValueCalcTime = firstStakeTime;\n        }\n\n        uint256 totalCurrentStake = totalStake();\n\n        if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {\n            uint256 value = 0;\n            uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime);\n            uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime));\n\n            if (block.timestamp < endTime) {\n                value = sinceLastCalc.mul(perSecondReward);\n            } else {\n                uint256 sinceEndTime = block.timestamp.sub(endTime);\n                value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward);\n            }\n\n            _totalWeight = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));\n\n            _mostRecentValueCalcTime = block.timestamp;\n\n            (uint fee0, uint fee1) = IMuteSwitchPairDynamic(lpToken).claimFees();\n\n            _totalWeightFee0 = _totalWeightFee0.add(fee0.mul(10**18).div(totalCurrentStake));\n            _totalWeightFee1 = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));\n\n            totalFees0 = totalFees0.add(fee0);\n            totalFees1 = totalFees1.add(fee1);\n        }\n\n        _;\n    }\n\n    /* ======== CONSTRUCTOR ======== */\n\n    /**\n     *  @notice sets the amplifier pool variables on launch\n     *  @param _lpToken address\n     *  @param _muteToken address\n     *  @param _dToken address\n     *  @param divisor uint\n     *  @param _mgmt_fee uint\n     *  @param _treasury address\n     */\n    constructor (address _lpToken, address _muteToken, address _dToken, uint256 divisor, uint256 _mgmt_fee, address _treasury) {\n        require(divisor >= 10 ** 18, \"MuteAmplifier: invalid _stakeDivisor\");\n        require(_lpToken != address(0), \"MuteAmplifier: invalid lpToken\");\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        require(_dToken != address(0), \"MuteAmplifier: invalid dToken\");\n        require(_mgmt_fee >= 0 && _mgmt_fee <= 1000, \"MuteAmplifier: invalid _mgmt_fee\");\n        require(_treasury != address(0), \"MuteAmplifier: invalid treasury\");\n\n        lpToken = _lpToken;\n        muteToken = _muteToken;\n        dToken = _dToken;\n        _stakeDivisor = divisor;\n        management_fee = _mgmt_fee; //bps 10k\n        treasury = _treasury;\n\n        TransferHelper.safeApprove(muteToken, _dToken, type(uint256).max);\n    }\n\n\n    /* ======== OWNER FUNCTIONS ======== */\n\n    /**\n     *  @notice sets the start and end time of this pool. Rewards must be sent in prior to calling this function. Can only be called once\n     *  @param _startTime address\n     *  @param _endTime address\n     */\n    function initializeDeposit(uint256 _startTime, uint256 _endTime) external virtual onlyOwner {\n        require(startTime == 0, \"MuteAmplifier::deposit: already received deposit\");\n        require(_startTime >= block.timestamp, \"MuteAmplifier::deposit: start time must be in future\");\n        require(_endTime > _startTime, \"MuteAmplifier::deposit: end time must after start time\");\n\n        totalRewards = IERC20(muteToken).balanceOf(address(this));\n        require(totalRewards > 0, \"MuteAmplifier::deposit: no rewards\");\n\n        startTime = _startTime;\n        endTime = _endTime;\n\n        emit Deposit(totalRewards, _startTime, _endTime);\n    }\n\n    /**\n     *  @notice withdraws tokens not meant to be in this contract\n     *  @param tokenToRescue address\n     *  @param to address\n     *  @param amount uint256\n     */\n    function rescueTokens(address tokenToRescue, address to, uint256 amount) external virtual onlyOwner nonReentrant {\n        if (tokenToRescue == lpToken) {\n            require(amount <= IERC20(lpToken).balanceOf(address(this)).sub(_totalStakeLpToken),\n                \"MuteAmplifier::rescueTokens: that Token-Eth belongs to stakers\"\n            );\n        } else if (tokenToRescue == muteToken) {\n            if (totalStakers > 0) {\n                require(amount <= IERC20(muteToken).balanceOf(address(this)).sub(totalRewards.sub(totalClaimedRewards)),\n                    \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"\n                );\n            }\n        }\n\n        IERC20(tokenToRescue).transfer(to, amount);\n    }\n\n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice stakes a certain amount of lp tokens\n     *  @param lpTokenIn uint\n     */\n    function stake(uint256 lpTokenIn) external virtual update nonReentrant {\n        require(lpTokenIn > 0, \"MuteAmplifier::stake: missing stake\");\n        require(block.timestamp >= startTime && startTime !=0, \"MuteAmplifier::stake: not live yet\");\n        require(IERC20(muteToken).balanceOf(address(this)) > 0, \"MuteAmplifier::stake: no reward balance\");\n\n        if (firstStakeTime == 0) {\n            firstStakeTime = block.timestamp;\n        } else {\n            require(block.timestamp < endTime, \"MuteAmplifier::stake: staking is over\");\n        }\n\n        lpToken.safeTransferFrom(msg.sender, address(this), lpTokenIn);\n\n        if (totalUserStake(msg.sender) == 0) {\n            totalStakers = totalStakers.add(1);\n        }\n\n        _stake(lpTokenIn, msg.sender);\n\n        emit Stake(msg.sender, lpTokenIn);\n    }\n\n    /**\n     * @notice  Transfer reward tokens from contract to sender, withdraw lp and apply tax\n     */\n    function withdraw() external virtual update nonReentrant returns (uint256 lpTokenOut, uint256 reward, uint256 remainder, uint256 fee0, uint256 fee1) {\n        totalStakers = totalStakers.sub(1);\n\n        (lpTokenOut, reward, remainder, fee0, fee1) = _applyReward(msg.sender);\n\n        if (lpTokenOut > 0) {\n            uint256 fee = lpTokenOut.mul(management_fee).div(10000);\n            lpToken.safeTransfer(msg.sender, lpTokenOut.sub(fee));\n            lpToken.safeTransfer(treasury, fee);\n        }\n\n        // remaining allocated rewards sent back\n        if(remainder > 0){\n          totalReclaimed = totalReclaimed.add(remainder);\n          IERC20(muteToken).transfer(treasury, remainder);\n        }\n        // payout rewards\n        if (reward > 0) {\n            uint256 week_time = 60 * 60 * 24 * 7;\n            IDMute(dToken).LockTo(reward, week_time ,msg.sender);\n\n            userClaimedRewards[msg.sender] = userClaimedRewards[msg.sender].add(\n                reward\n            );\n            totalClaimedRewards = totalClaimedRewards.add(reward);\n\n            emit Payout(msg.sender, reward, remainder);\n        }\n\n        // payout fee0 fee1\n        if ((fee0 > 0 || fee1 > 0) && fee0 <= totalF"
    }
  ]
}