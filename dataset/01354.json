{
  "Title": "Legacy withdrawal queue logic in `Weather::handleRain` should be updated",
  "Content": "`Weather::handleRain` contains a [condition](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L239-L241) related to the legacy withdrawal queue that should be modified to reflect the updated logic. It is understood this has since been modified in a more recent commit.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"contracts/libraries/Decimal.sol\";\nimport \"contracts/libraries/Curve/LibBeanMetaCurve.sol\";\nimport \"./Sun.sol\";\n\nlibrary DecimalExtended {\n    uint256 private constant PERCENT_BASE = 1e18;\n\n    function toDecimal(uint256 a) internal pure returns (Decimal.D256 memory) {\n        return Decimal.D256({ value: a });\n    }\n}\n\n/**\n * @title Weather\n * @author Publius\n * @notice Weather controls the Temperature on the Farm.\n */\ncontract Weather is Sun {\n    using SafeMath for uint256;\n    using DecimalExtended for uint256;\n    using LibSafeMath32 for uint32;\n    using Decimal for Decimal.D256;\n\n    /// @dev If all Soil is Sown faster than this, Beanstalk considers demand for Soil to be increasing.\n    uint256 private constant SOW_TIME_DEMAND_INCR = 600; // seconds\n\n    uint32 private constant SOW_TIME_STEADY = 60; // seconds\n\n    uint256 private constant POD_RATE_LOWER_BOUND = 0.05e18; // 5%\n    uint256 private constant POD_RATE_OPTIMAL = 0.15e18; // 15%\n    uint256 private constant POD_RATE_UPPER_BOUND = 0.25e18; // 25%\n\n    uint256 private constant DELTA_POD_DEMAND_LOWER_BOUND = 0.95e18; // 95%\n    uint256 private constant DELTA_POD_DEMAND_UPPER_BOUND = 1.05e18; // 105%\n    \n    /**\n     * @notice Emitted when the Temperature (fka \"Weather\") changes.\n     * @param season The current Season\n     * @param caseId The Weather case, which determines how much the Temperature is adjusted.\n     * @param change The change in Temperature as a delta from the previous value\n     * @dev The name {WeatherChange} is kept for backwards compatibility, \n     * however the state variable included as `change` is now called Temperature.\n     * \n     * `change` is emitted as a delta for gas efficiency.\n     */\n    event WeatherChange(\n        uint256 indexed season,\n        uint256 caseId,\n        int8 change\n    );\n\n    /**\n     * @notice Emitted when Beans are minted during the Season of Plenty.\n     * @param season The Season in which Beans were minted for distribution.\n     * @param amount The amount of 3CRV which was received for swapping Beans.\n     * @param toField The amount of Beans which were distributed to remaining Pods in the Field.\n     */\n    event SeasonOfPlenty(\n        uint256 indexed season,\n        uint256 amount,\n        uint256 toField\n    );\n\n\n    //////////////////// WEATHER GETTERS ////////////////////\n\n    /**\n     * @notice Returns the current Weather struct. See {AppStorage:Storage.Weather}.\n     */\n    function weather() public view returns (Storage.Weather memory) {\n        return s.w;\n    }\n\n    /**\n     * @notice Returns the current Rain struct. See {AppStorage:Storage.Rain}.\n     */\n    function rain() public view returns (Storage.Rain memory) {\n        return s.r;\n    }\n\n    /**\n     * @notice Returns the Plenty per Root for `season`.\n     */\n    function plentyPerRoot(uint32 season) external view returns (uint256) {\n        return s.sops[season];\n    }\n\n    //////////////////// WEATHER INTERNAL ////////////////////\n\n    /**\n     * @param deltaB Pre-calculated deltaB from {Oracle.stepOracle}.\n     * @dev A detailed explanation of the Weather mechanism can be found in the\n     * Beanstalk whitepaper. An explanation of state variables can be found in {AppStorage}.\n     */\n    function stepWeather(int256 deltaB) internal returns (uint256 caseId) {\n        uint256 beanSupply = C.bean().totalSupply();\n\n        // Prevent infinite pod rate\n        if (beanSupply == 0) {\n            s.w.t = 1;\n            return 8; // Reasonably low\n        }\n\n        // Calculate Pod Rate\n        Decimal.D256 memory podRate = Decimal.ratio(\n            s.f.pods.sub(s.f.harvestable), // same as totalUnharvestable()\n            beanSupply\n        );\n\n        // Calculate Delta Soil Demand\n        uint256 dsoil = s.f.beanSown;\n        s.f.beanSown = 0;\n    \n        Decimal.D256 memory deltaPodDemand;\n\n        // `s.w.thisSowTime` is set to the number of seconds in it took for \n        // Soil to sell out during the current Season. If Soil didn't sell out,\n        // it remains `type(uint32).max`.\n        if (s.w.thisSowTime < type(uint32).max) {\n            if (\n                s.w.lastSowTime == type(uint32).max || // Didn't Sow all last Season\n                s.w.thisSowTime < SOW_TIME_DEMAND_INCR || // Sow'd all instantly this Season\n                (s.w.lastSowTime > SOW_TIME_STEADY &&\n                    s.w.thisSowTime < s.w.lastSowTime.sub(SOW_TIME_STEADY)) // Sow'd all faster\n            ) {\n                deltaPodDemand = Decimal.from(1e18);\n            } else if (\n                s.w.thisSowTime <= s.w.lastSowTime.add(SOW_TIME_STEADY)\n            ) {\n                // Sow'd all in same time\n                deltaPodDemand = Decimal.one();\n            } else { \n                deltaPodDemand = Decimal.zero();\n            }\n\n            s.w.lastSowTime = s.w.thisSowTime;  // Overwrite last Season\n            s.w.thisSowTime = type(uint32).max; // Reset for next Season\n        } \n\n        // Soil didn't sell out\n        else {\n            uint256 lastDSoil = s.w.lastDSoil;\n\n            if (dsoil == 0) {\n                deltaPodDemand = Decimal.zero(); // If no one sow'd\n            } else if (lastDSoil == 0) {\n                deltaPodDemand = Decimal.from(1e18); // If no one sow'd last Season\n            } else { \n                deltaPodDemand = Decimal.ratio(dsoil, lastDSoil);\n            }\n\n            if (s.w.lastSowTime != type(uint32).max) {\n                s.w.lastSowTime = type(uint32).max;\n            }\n        }\n        \n        // Calculate Weather Case\n        caseId = 0;\n\n        // Evaluate Pod Rate\n        if (podRate.greaterThanOrEqualTo(POD_RATE_UPPER_BOUND.toDecimal())) {\n            caseId = 24;\n        } else if (podRate.greaterThanOrEqualTo(POD_RATE_OPTIMAL.toDecimal())) {\n            caseId = 16;\n        } else if (podRate.greaterThanOrEqualTo(POD_RATE_LOWER_BOUND.toDecimal())) {\n            caseId = 8;\n        }\n\n        // Evaluate Price\n        if (\n            deltaB > 0 ||\n            (deltaB == 0 && podRate.lessThanOrEqualTo(POD_RATE_OPTIMAL.toDecimal()))\n        ) {\n            caseId += 4;\n        }\n\n        // Evaluate Delta Soil Demand\n        if (deltaPodDemand.greaterThanOrEqualTo(DELTA_POD_DEMAND_UPPER_BOUND.toDecimal())) {\n            caseId += 2;\n        } else if (deltaPodDemand.greaterThanOrEqualTo(DELTA_POD_DEMAND_LOWER_BOUND.toDecimal())) {\n            caseId += 1;\n        }\n\n        s.w.lastDSoil = uint128(dsoil); // SafeCast not necessary as `s.f.beanSown` is uint128.\n        \n        changeWeather(caseId);\n        handleRain(caseId);\n    }\n\n    /**\n     * @dev Changes the current Temperature `s.w.t` based on the Weather Case.\n     */\n    function changeWeather(uint256 caseId) private {\n        int8 change = s.cases[caseId];\n        uint32 t = s.w.t;\n\n        if (change < 0) {\n            if (t <= (uint32(-change))) {\n                // if (change < 0 && t <= uint32(-change)),\n                // then 0 <= t <= type(int8).max because change is an int8.\n                // Thus, downcasting t to an int8 will not cause overflow.\n                change = 1 - int8(t);\n                s.w.t = 1;\n            } else {\n                s.w.t = t - (uint32(-change));\n            }\n        } else {\n            s.w.t = t + (uint32(change));\n        }\n\n        emit WeatherChange(s.season.current, caseId, change);\n    }\n\n    /**\n     * @dev Oversaturated was previously referred to as Raining and thus code\n     * references mentioning Rain really refer to Oversaturation. If P > 1 and the\n     * Pod Rate is less than 5%, the Farm is Oversaturated. If it is Oversaturated\n     * for a Season, each Season in which it continues to be Oversaturated, it Floods.\n     */\n    function handleRain(uint256 caseId) internal {\n        // cases 4-7 represent the case where the pod rate is less than 5% and P > 1.\n        if (caseId < 4 || caseId > 7) {\n            if (s.season.raining) {\n                s.season.raining = false;\n            }\n            return;\n        } else if (!s.season.raining) {\n            s.season.raining = true;\n            // Set the plenty per root equal to previous rain start.\n            s.sops[s.season.current] = s.sops[s.season.rainStart];\n            s.season.rainStart = s.season.current;\n            s.r.pods = s.f.pods;\n            s.r.roots = s.s.roots;\n        } else if (\n            s.season.current >= s.season.rainStart.add(s.season.withdrawSeasons - 1)\n        ) {\n            if (s.r.roots > 0) {\n                sop();\n            }\n        }\n    }\n\n    /**\n     * @dev Flood was previously called a \"Season of Plenty\" (SOP for short).\n     * When Beanstalk has been Oversaturated for a Season, Beanstalk returns the\n     * Bean price to its peg by minting additional Beans and selling them directly\n     * on Curve. Proceeds  from the sale in the form of 3CRV are distributed to\n     * Stalkholders at the beginning of a Season in proportion to their Stalk\n     * ownership when the Farm became Oversaturated. Also, at the beginning of the\n     * Flood, all Pods that were minted before the Farm became Oversaturated Ripen\n     * and become Harvestable.\n     * For more information On Oversaturation see {Weather.handleRain}.\n     */\n    function sop() private {\n        int256 newBeans = LibBeanMetaCurve.getDeltaB();\n        if (newBeans <= 0) return;\n\n        uint256 sopBeans = uint256(newBeans);\n        uint256 newHarvestable;\n\n        // Pay off remaining Pods if any exist.\n        if (s.f.harvestable < s.r.pods) {\n            newHarvestable = s.r.pods - s.f.harvestable;\n            s.f.harvestable = s.f.harvestable.add(newHarvestable);\n            C.bean().mint(address(this), newHarvestable.add(sopBeans));\n        } else {\n            C.bean().mint(address(this), sopBeans);\n        }\n\n        // Swap Beans for 3CRV.\n        uint256 amountOut = C.curveMetapool().exchange(0, 1, sopBeans, 0);\n\n        rewardSop(amountOut);\n        emit SeasonOfPlenty(s.season.current, amountOut, newHarvestable);\n    }\n\n    /**\n     * @dev Allocate 3CRV during a Season of Plenty.\n     */\n    function rewardSop(uint256 amount) private {\n        s.sops[s.season.rainStart] = s.sops[s.season.lastSop].add(\n            amount.mul(C.SOP_PRECISION).div(s.r.roots)\n        );\n        s.season.lastSop = s.season.rainStart;\n        s.season.lastSopSeason = s.season.current;\n    }\n}"
    }
  ]
}