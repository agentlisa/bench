{
  "Title": "M-4: Compound exchange rate can be manipulated to withdraw more underlying tokens from NotionalV3",
  "Content": "# Issue M-4: Compound exchange rate can be manipulated to withdraw more underlying tokens from NotionalV3 \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/122 \n\n## Found by \nmstpr-brainbot\n## Summary\nPrime cash underlying values can be manipulated via donating the underlying to cToken contract to inflate the cToken price and then withdrawing from Notional for more.\n## Vulnerability Detail\nPrime supply underlying value is calculated via few formulas and math operations let's check them:\n\nTo calculate the underlying interest rate:\n(currentUnderlyingValue - lastUnderlyingValue) / lastUnderlyingValue\nwhich we can say that underlying value can be in forms of DAI or cDAI (since the other protocol handlers are not in the audit scope I'll treat it as there is only CompoundV2 available for prime cash external lenders)\nWe can derive this formula for more context:\n(((exchangeRate * totalCDAIHoldings) + totalDAIHolds) - ((previousExchangeRate * totalCDAIHoldings) + totalDAIHolds)) / ((previousExchangeRate * totalCDAIHoldings) + totalDAIHolds) = underlyingInterestRate\n\nTo calculate the underlying scalar:\nlastScalar * (1 + underlyingInterestRate) = underlyingScalar\n\nTo calculate the supply factor:\nsupplyScalar * underlyingScalar = supplyFactor\n\nTo calculate the underlying final:\nprimeCashValue * supplyFactor = underlyingFinal\n\nnow considering these, if someone can manipulate the currentUnderlying (total underlying tokens that Notional holds) up to some level that they can make the prime cash value higher, than there will be a profit. Currently, NotionalV3 deposits the funds to CompoundV2 which the exchange rate is calculated as follows:\n\n(totalCash + totalBorrows - totalReserves) / totalCDAISupply\n\nwhere as totalCash is the balanceOf(token) in the cToken contract. This means that the donations can manipulate the exchange rate and make Notional V3 underlying oracle trick that the tokens worths more. That means the exchange rate can be calculated as this:\n\n(airDropAmount + totalCash + totalBorrows - totalReserves) / totalCDAISupply\n\nif we can find a scenario where underlyingFinal > airDropAmount + initialPrimeCash, someone can do a flash loan attack\n\n\nLet's draw a scenario where this can happen ,\nAssume cDAI has very low liquidity because Compound incentives the v3 usage, Notional is withdrawing its CompoundV2 positions slowly to DAI and getting ready to deploy them to CompoundV3. For this scenario case assume there are total of 100K cDAI which all of them hold by Notional (this can change, just for simplicity I am keeping it), now if attacker donates 50K DAI to cDAI attacker will make the new exchange rate 1.5. Here we go:\n\n1- There are 220K DAI idle and 100K cDAI in Notional (for easiness let's assume 1cDAI == 1DAI)\n2- Alice flashloans 4.83M DAI and deposits to Notional receiving 4.83M pDAI (we assume supplyFactor is 1, which is possible if we are early stages after migration, no interest accrued). Alice will make the total idle DAI balance in Notional as 5M after her deposit\n3- Alice deposits the 50K DAI to cDAI contract to make the exchange rate 1.5 (100KDAI/100KCDAI was the initial state of cDAI, now 150K DAI / 100K CDAI = 1.5) \n4- Alice withdraws the 4.83M pDAI for 5M DAI\n\nLet's prove the math,\nlastUnderlying = (100K cDAI * 1 + 5M) = 5.1M\n\ncurrentUnderlying = (100K cDAI * 1.5 + 5M) = 5.150M\n\nunderlyingInterestRate = (5.15M - 5.1M) / 5.1M = 0.045\n\nunderlyingScalar = 1 * (0.045+ 1) = 1.045\n\nsupplyScalar = 1 * 1.045 = 1.045\n\nResult:\nAlice deposited 4.78M DAI which she got 4.78M pDAI for it, now 4.78M pDAI worths 4.78M * 1.045 =  5M DAI (approx) \n\nAlice flashloaned 4.78M + 50K = 4.83M total flash loaned amount\n\n5M - 4.83M = 170K DAI profit after her attack\n\nIn the end, Alice stole the 220K idle balance.\n\n\n## Impact\nAlthough the above example considers the compound cDAI has very low liquidity, the same scenario could happen with big numbers but that would require Notional to hold lots of liquidity. Since compound is literally incentivizing the compoundv3 over compoundv2 I assumed that scenario is not far away from reality. We also assumed supplyScalar was 1, which is possible since the prime market will start as 1 but also it doesn't really matter since we multiply with lastScalar and supplyScalar on both sides of equation, again it was 1 for simplicity. \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/AccountAction.sol#L173-L210\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/balances/BalanceHandler.sol#L525\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/pCash/PrimeCashExchangeRate.sol#L618-L641\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/pCash/PrimeCashExchangeRate.sol#L535-L596\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/balances/BalanceHandler.sol#L143-L160\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/balances/TokenHandler.sol#L231-L234\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/pCash/PrimeRateLib.sol#L301-L306\n\nCompound stuff\n<img width=\"703\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-03-notional-mstpr/assets/120012681/12d241fb-4ca7-48fa-babb-1fdf6a3bf6ed\">\n\n<img width=\"617\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-03-notional-mstpr/assets/120012681/43641c5d-fc07-4466-b866-09be5abce620\">\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAcknowledge that CompoundV2 exchange rate is exploitable via donating, if the CompoundV2 cTokens has low liquidity, donate attacks will be quite cheap which can cause pDAI manipulations aswell. If the CompoundV2 cToken liquidity goes below some level abort the CompoundV2 strategy and migrate to other money markets where liquidity is decent and exchange rate is not manipulatable. \n\n\n\n## Discussion\n\n**jeffywu**\n\nThis attack vector is known and mitigations have been put in place against it (we've already withdrawn from Compound V2). Furthermore, we've only listed large cap Compound V2 markets so this attack would be very expensive against prime cash.\n\n**mstpr**\n\nEscalate for 10 USDC\n\nAt the moment, the contest only includes the CompoundV2 adapter. From this, we could infer that the primary cash will be deposited into CompoundV2. In the future, CompoundV3 and Aave may also be integrated. However, within the current scope of the code, it only operates with CompoundV2. Consequently, we can safely assert that prime cash will be lent to CompoundV2. This is evident from the scope of the code, which includes all the necessary implementations such as rebalancing, redeeming, and depositing.\n\nWhile I concur that the attack necessitates low liquidity in the CompoundV2 markets and that it's challenging to implement on-chain countermeasures, I believe this risk should be outlined by the protocol team in their documentation. Looking at the Sherlock docs, it's clear that the protocol team should account for possible attack vectors.\n\n<img width=\"786\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-03-notional-judging/assets/120012681/fe73f089-cc86-4b50-91cf-25455e62e2e8\">\n\nWhich is exactly what this issue fits, the attack exists and protocol team did not include the attack in the docs. According to this, this finding should be a medium\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> At the moment, the contest only includes the CompoundV2 adapter. From this, we could infer that the primary cash will be deposited into CompoundV2. In the future, CompoundV3 and Aave may also be integrated. However, within the current scope of the code, it only operates with CompoundV2. Consequently, we can safely assert that prime cash will be lent to CompoundV2. This is evident from the scope of the code, which includes all the necessary implementations such as rebalancing, redeeming, and depositing.\n> \n> While I concur that the attack necessitates low liquidity in the CompoundV2 markets and that it's challenging to implement on-chain countermeasures, I believe this risk should be outlined by the protocol team in their documentation. Looking at the Sherlock docs, it's clear that the protocol team should account for possible attack vectors.\n> \n> <img width=\"786\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-03-notional-judging/assets/120012681/fe73f089-cc86-4b50-91cf-25455e62e2e8\">\n> \n> Which is exactly what this issue fits, the attack exists and protocol team did not include the attack in the docs. According to this, this finding should be a medium\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this issue as a valid medium, based on the conditions required and given that the Compound v2 integration was still in scope for the contest. \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [mstpr](https://github.com/sherlock-audit/2023-03-notional-judging/issues/122/#issuecomment-1568132606): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/external/actions/AccountAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    BalanceState,\n    AccountContext,\n    PortfolioAsset,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\n\nimport {TransferAssets} from \"../../internal/portfolio/TransferAssets.sol\";\nimport {BalanceHandler} from \"../../internal/balances/BalanceHandler.sol\";\nimport {nTokenHandler} from \"../../internal/nToken/nTokenHandler.sol\";\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {AccountContextHandler} from \"../../internal/AccountContextHandler.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {nTokenRedeemAction} from \"./nTokenRedeemAction.sol\";\nimport {SettleAssetsExternal} from \"../SettleAssetsExternal.sol\";\nimport {FreeCollateralExternal} from \"../FreeCollateralExternal.sol\";\nimport {MigrateIncentives} from \"../MigrateIncentives.sol\";\n\ncontract AccountAction is ActionGuards {\n    using BalanceHandler for BalanceState;\n    using AccountContextHandler for AccountContext;\n    using PrimeRateLib for PrimeRate;\n    using SafeInt256 for int256;\n\n    /// @notice A per account setting that allows it to borrow prime cash (i.e. incur negative cash)\n    /// as a result of account initiated actions. Accounts can still incur negative cash as a result of\n    /// fCash settlement regardless of this setting.\n    /// @param allowPrimeBorrow true if the account can borrow prime cash\n    /// @dev emit:AccountSettled emit:AccountContextUpdate\n    /// @dev auth:msg.sender\n    function enablePrimeBorrow(bool allowPrimeBorrow) external {\n        require(msg.sender != address(this)); // dev: no internal call\n        requireValidAccount(msg.sender);\n        (AccountContext memory accountContext, /* didSettle */) = _settleAccountIfRequired(msg.sender);\n        accountContext.allowPrimeBorrow = allowPrimeBorrow;\n        accountContext.setAccountContext(msg.sender);\n    }\n\n    /// @notice Enables a bitmap currency for msg.sender, account cannot have any assets when this call\n    /// occurs. Will revert if the account already has a bitmap currency set.\n    /// @param currencyId the currency to enable the bitmap for.\n    /// @dev emit:AccountSettled emit:AccountContextUpdate\n    /// @dev auth:msg.sender\n    function enableBitmapCurrency(uint16 currencyId) external {\n        require(msg.sender != address(this)); // dev: no internal call to enableBitmapCurrency\n        require(currencyId <= maxCurrencyId); // dev: invalid currency id\n        address account = msg.sender;\n        (AccountContext memory accountContext, /* didSettle */) = _settleAccountIfRequired(account);\n        accountContext.enableBitmapForAccount(currencyId, block.timestamp);\n        accountContext.setAccountContext(account);\n    }\n\n    /// @notice Method for manually settling an account, generally should not be called because other\n    /// methods will check if an account needs to be settled automatically. If a bitmap account has debt\n    /// and is settled via this method, the hasDebt flag will not be cleared until a free collateral check\n    /// is performed on the account.\n    /// @param account the account to settle\n    /// @dev emit:AccountSettled emit:AccountContextUpdate\n    /// @dev auth:none\n    /// @return returns true if account has been settled\n    function settleAccount(address account) external returns (bool) {\n        requireValidAccount(account);\n        (AccountContext memory accountContext, bool didSettle) = _settleAccountIfRequired(account);\n        if (didSettle) accountContext.setAccountContext(account);\n        return didSettle;\n    }\n\n    /// @notice Deposits and wraps the underlying token for a particular cToken. Does not settle assets or check free\n    /// collateral, idea is to be as gas efficient as possible during potential liquidation events.\n    /// @param account the account to deposit into\n    /// @param currencyId currency id of the asset token that wraps this underlying\n    /// @param amountExternalPrecision the amount of underlying tokens in its native decimal precision\n    /// (i.e. 18 decimals for DAI or 6 decimals for USDC). This will be converted to 8 decimals during transfer.\n    /// @return asset tokens minted and deposited to the account in internal decimals (8)\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:none\n    function depositUnderlyingToken(\n        address account,\n        uint16 currencyId,\n        uint256 amountExternalPrecision\n    ) external payable nonReentrant returns (uint256) {\n        require(msg.sender != address(this)); // dev: no internal call to deposit underlying\n        requireValidAccount(account);\n\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(account, currencyId, accountContext);\n\n        // NOTE: using msg.sender here allows for a different sender to deposit tokens into\n        // the specified account. This may be useful for on-demand collateral top ups from a\n        // third party.\n        int256 primeCashReceived = balanceState.depositUnderlyingToken(\n            msg.sender,\n            SafeInt256.toInt(amountExternalPrecision),\n            false // there should never be excess ETH here by definition\n        );\n\n        require(primeCashReceived > 0); // dev: asset tokens negative or zero\n\n        balanceState.finalizeNoWithdraw(account, accountContext);\n        accountContext.setAccountContext(account);\n\n        // Check the supply cap after all balances have been finalized\n        balanceState.primeRate.checkSupplyCap(currencyId);\n\n        // NOTE: no free collateral checks required for depositing\n        return primeCashReceived.toUint();\n    }\n\n    /// @notice DEPRECATED: deposits deprecated cTokens tokens as collateral into an account that\n    /// were listed prior to the migration to prime cash. Future listed tokens will not have asset\n    /// tokens and will revert in this method.\n    /// @param account the account to deposit into\n    /// @param currencyId currency id of the asset token\n    /// @param amountExternalPrecision the amount of asset tokens in its native decimal precision\n    /// (i.e. 8 decimals for cTokens).\n    /// @return asset tokens minted and deposited to the account in internal decimals (8)\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:none\n    function depositAssetToken(\n        address account,\n        uint16 currencyId,\n        uint256 amountExternalPrecision\n    ) external nonReentrant returns (uint256) {\n        require(msg.sender != address(this)); // dev: no internal call to deposit asset\n        requireValidAccount(account);\n\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(account, currencyId, accountContext);\n\n        // Int conversion overflow check done inside this method call. msg.sender\n        // is used as the account in deposit to allow for other accounts to deposit\n        // on behalf of the given account. This always does an immediate transfer\n        // and marks the net prime cash change on the balance state.\n        int256 primeCashReceived = balanceState.depositDeprecatedAssetToken(\n            msg.sender,\n            SafeInt256.toInt(amountExternalPrecision)\n        );\n\n        require(primeCashReceived > 0); // dev: asset tokens negative or zero\n\n        balanceState.finalizeNoWithdraw(account, accountContext);\n        accountContext.setAccountContext(account);\n\n        // Check the supply cap after all balances have been finalized\n        balanceState.primeRate.checkSupplyCap(currencyId);\n\n        // NOTE: no free collateral checks required for depositing\n        return primeCashReceived.toUint();\n    }\n\n    /// @notice Withdraws balances from Notional, may also redeem to underlying tokens on user request. Will settle\n    /// and do free collateral checks if required. Can only be called by msg.sender, operators who want to withdraw for\n    /// an account must do an authenticated call via ERC1155Action `safeTransferFrom` or `safeBatchTransferFrom`\n    /// @param currencyId currency id of the asset token\n    /// @param amountInternalPrecision the amount of cash balance in internal 8 decimal precision to withdraw,\n    /// this is be denominated in prime cash. If set to uint88 max, will withdraw an entire cash balance.\n    /// @param redeemToUnderlying DEPRECATED except for ETH balances. Prior to the prime cash upgrade, accounts could withdraw\n    /// cTokens directly. However, post prime cash migration this is no longer the case. If withdrawing ETH, setting redeemToUnderlying\n    /// to false will redeem ETH as WETH.\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:msg.sender\n    /// @return the amount of tokens received by the account denominated in the destination token precision (if\n    // redeeming to underlying the amount will be the underlying amount received in that token's native precision)\n    function withdraw(\n        uint16 currencyId,\n        uint88 amountInternalPrecision,\n        bool redeemToUnderlying\n    ) external nonReentrant returns (uint256) {\n        if (currencyId != Constants.ETH_CURRENCY_ID) {\n            require(redeemToUnderlying, \"Deprecated: Redeem to cToken\");\n        }\n        // This happens before reading the balance state to get the most up to date cash balance\n        (AccountContext memory accountContext, /* didSettle */) = _settleAccountIfRequired(msg.sender);\n\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(msg.sender, currencyId, accountContext);\n        if (amountInternalPrecision == type(uint88).max) {\n            // if set to uint88 max, withdraw the full stored balance. This feature only\n            // works if there is a positive balance\n            require(balanceState.storedCashBalance > 0);\n            balanceState.primeCashWithdraw = balanceState.storedCashBalance.neg();\n        } else {\n            // Overflow is not possible due to uint88\n            balanceState.primeCashWithdraw = int256(amountInternalPrecision).neg();\n        }\n\n        int256 underlyingWithdrawnExternal = balanceState.finalizeWithWithdraw(\n            msg.sender, accountContext, !redeemToUnderlying\n        );\n\n        accountContext.setAccountContext(msg.sender);\n\n        if (accountContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(msg.sender);\n        }\n\n        require(underlyingWithdrawnExternal <= 0);\n\n        // No need to check supply caps\n        return underlyingWithdrawnExternal.neg().toUint();\n    }\n\n    /// @notice Allows accounts to redeem nTokens into constituent assets and then absorb the assets\n    /// into their portfolio. Due to the complexity here, it is not allowed to be called during a batch trading\n    /// operation and must be done separately.\n    /// @param redeemer the address that holds the nTokens to redeem\n    /// @param currencyId the currency associated the nToken\n    /// @param tokensToRedeem_ the amount of nTokens to convert to cash\n    /// @param sellTokenAssets attempt to sell residual fCash and convert to cash\n    /// @param acceptResidualAssets if true, will place any residual fCash that could not be sold (either due to slippage\n    /// or because it was idiosyncratic) into the account's portfolio\n    /// @dev auth:msg.sender auth:ERC1155\n    /// @return total amount of asset cash redeemed\n    /// @return true or false if there were residuals that were placed into the portfolio\n    function nTokenRedeem(\n        address redeemer,\n        uint16 currencyId,\n        uint96 tokensToRedeem_,\n        bool sellTokenAssets,\n        bool acceptResidualAssets\n    ) external nonReentrant returns (int256, bool) {\n        // ERC1155 can call this method during a post transfer event\n        require(msg.sender == redeemer || msg.sender == address(this), \"Unauthorized caller\");\n        int256 tokensToRedeem = int256(tokensToRedeem_);\n\n        (AccountContext memory context, /* didSettle */) = _settleAccountIfRequired(redeemer);\n\n        BalanceState memory balance;\n        balance.loadBalanceState(redeemer, currencyId, context);\n\n        require(balance.storedNTokenBalance >= tokensToRedeem, \"Insufficient tokens\");\n        balance.netNTokenSupplyChange = tokensToRedeem.neg();\n\n        (int256 totalPrimeCash, PortfolioAsset[] memory assets) = nTokenRedeemAction.redeem(\n            redeemer, currencyId, tokensToRedeem, sellTokenAssets, acceptResidualAssets\n        );\n\n        // Set balances before transferring assets\n        balance.netCashChange = totalPrimeCash;\n        balance.finalizeNoWithdraw(redeemer, context);\n\n        // The hasResidual flag is only set to true if selling residuals has failed, checking\n        // if the length of assets is greater than zero will detect the presence of ifCash\n        // assets that have not been sold.\n        if (assets.length > 0) {\n            // This method will store assets and return the memory location of the new account\n            // context.\n            address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n            context = SettleAssetsExternal.placeAssetsInAccount(redeemer, nTokenAddress, context, assets);\n        }\n\n        context.setAccountContext(redeemer);\n        if (context.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(redeemer);\n        }\n\n        // Do not check supply caps during nToken redemption, no deposits are taken during \n        // redemption so the supply should not change.\n\n        return (totalPrimeCash, assets.length > 0);\n    }\n\n    /// @notice Settle the account if required, returning a reference to the account context. Also\n    /// returns a boolean to indicate if it did settle.\n    function _settleAccountIfRequired(address account)\n        private\n        returns (AccountContext memory, bool)\n    {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        if (accountContext.mustSettleAssets()) {\n            return (SettleAssetsExternal.settleAccount(account, accountContext), true);\n        } else {\n            return (accountContext, false);\n        }\n    }\n\n    /// @notice Get a list of deployed library addresses (sorted by library name)\n    function getLibInfo() external pure returns (address, address, address, address) {\n        return (\n            address(FreeCollateralExternal),\n            address(MigrateIncentives), \n            address(SettleAssetsExternal), \n            address(nTokenRedeemAction)\n        );\n    }\n}"
    },
    {
      "filename": "contracts-v2/contracts/internal/balances/BalanceHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    BalanceState,\n    BalanceStorage,\n    SettleAmount,\n    TokenType,\n    AccountContext,\n    PrimeRate,\n    Token\n} from \"../../global/Types.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {FloatingPoint} from \"../../math/FloatingPoint.sol\";\n\nimport {Emitter} from \"../Emitter.sol\";\nimport {nTokenHandler} from \"../nToken/nTokenHandler.sol\";\nimport {AccountContextHandler} from \"../AccountContextHandler.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\n\nimport {TokenHandler} from \"./TokenHandler.sol\";\nimport {Incentives} from \"./Incentives.sol\";\n\nlibrary BalanceHandler {\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using TokenHandler for Token;\n    using AccountContextHandler for AccountContext;\n    using PrimeRateLib for PrimeRate;\n\n    /// @notice Emitted when a cash balance changes\n    event CashBalanceChange(address indexed account, uint16 indexed currencyId, int256 netCashChange);\n    /// @notice Emitted when nToken supply changes (not the same as transfers)\n    event nTokenSupplyChange(address indexed account, uint16 indexed currencyId, int256 tokenSupplyChange);\n    /// @notice Emitted when reserve fees are accrued\n    event ReserveFeeAccrued(uint16 indexed currencyId, int256 fee);\n    /// @notice Emitted when reserve balance is updated\n    event ReserveBalanceUpdated(uint16 indexed currencyId, int256 newBalance);\n    /// @notice Emitted when reserve balance is harvested\n    event ExcessReserveBalanceHarvested(uint16 indexed currencyId, int256 harvestAmount);\n\n    /// @notice Exists to maintain compatibility for asset token deposits that existed before\n    /// prime cash. After prime cash, Notional will no longer list new asset cash tokens. Asset\n    /// cash listed prior to the prime cash migration will be redeemed immediately to underlying\n    /// and this method will return how much underlying that represents.\n    function depositDeprecatedAssetToken(\n        BalanceState memory balanceState,\n        address account,\n        int256 assetAmountExternal\n    ) internal returns (int256 primeCashDeposited) {\n        if (assetAmountExternal == 0) return 0;\n        require(assetAmountExternal > 0); // dev: deposit asset token amount negative\n        Token memory assetToken = TokenHandler.getDeprecatedAssetToken(balanceState.currencyId);\n        require(assetToken.tokenAddress != address(0));\n\n        // Aave tokens will not be listed prior to the prime cash migration, if NonMintable tokens\n        // are minted then assetTokenTransferred is the underlying.\n        if (\n            assetToken.tokenType == TokenType.cToken ||\n            assetToken.tokenType == TokenType.cETH\n        ) {\n            primeCashDeposited = assetToken.depositDeprecatedAssetToken(\n                balanceState.currencyId,\n                // Overflow checked above\n                uint256(assetAmountExternal),\n                account,\n                balanceState.primeRate\n            );\n            balanceState.netCashChange = balanceState.netCashChange.add(primeCashDeposited);\n        } else if (assetToken.tokenType == TokenType.NonMintable) {\n            // In this case, no redemption is necessary and the non mintable token maps\n            // 1-1 with the underlying token. Deprecated non-mintable tokens will never be ETH so\n            // the returnExcessWrapped flag is set to false.\n            primeCashDeposited = depositUnderlyingToken(balanceState, account, assetAmountExternal, false);\n        } else {\n            revert();\n        }\n    }\n\n    /// @notice Marks some amount of underlying token to be transferred. Transfers will be\n    /// finalized inside _finalizeTransfer unless forceTransfer is set to true\n    function depositUnderlyingToken(\n        BalanceState memory balanceState,\n        address account,\n        int256 underlyingAmountExternal,\n        bool returnExcessWrapped\n    ) internal returns (int256 primeCashDeposited) {\n        if (underlyingAmountExternal == 0) return 0;\n        require(underlyingAmountExternal > 0); // dev: deposit underlying token negative\n\n        // Transfer the tokens and credit the balance state with the\n        // amount of prime cash deposited.\n        (/* actualTransfer */, primeCashDeposited) = TokenHandler.depositUnderlyingExternal(\n            account,\n            balanceState.currencyId,\n            underlyingAmountExternal,\n            balanceState.primeRate,\n            returnExcessWrapped // if true, returns any excess ETH as WETH\n        );\n        balanceState.netCashChange = balanceState.netCashChange.add(primeCashDeposited);\n    }\n\n    /// @notice Finalize collateral liquidation, checkAllowPrimeBorrow is set to false to force\n    /// a negative collateral cash balance if required.\n    function finalizeCollateralLiquidation(\n        BalanceState memory balanceState,\n        address account,\n        AccountContext memory accountContext\n    ) internal {\n        require(balanceState.primeCashWithdraw == 0);\n        _finalize(balanceState, account, accountContext, false, false);\n    }\n\n    /// @notice Calls finalize without any withdraws. Allows the withdrawWrapped flag to be hardcoded to false.\n    function finalizeNoWithdraw(\n        BalanceState memory balanceState,\n        address account,\n        AccountContext memory accountContext\n    ) internal {\n        require(balanceState.primeCashWithdraw == 0);\n        _finalize(balanceState, account, accountContext, false, true);\n    }\n\n    /// @notice Finalizes an account's balances with withdraws, returns the actual amount of underlying tokens transferred\n    /// back to the account\n    function finalizeWithWithdraw(\n        BalanceState memory balanceState,\n        address account,\n        AccountContext memory accountContext,\n        bool withdrawWrapped\n    ) internal returns (int256 transferAmountExternal) {\n        return _finalize(balanceState, account, accountContext, withdrawWrapped, true);\n    }\n\n    /// @notice Finalizes an account's balances, handling any transfer logic required\n    /// @dev This method SHOULD NOT be used for nToken accounts, for that use setBalanceStorageForNToken\n    /// as the nToken is limited in what types of balances it can hold.\n    function  _finalize(\n        BalanceState memory balanceState,\n        address account,\n        AccountContext memory accountContext,\n        bool withdrawWrapped,\n        bool checkAllowPrimeBorrow\n    ) private returns (int256 transferAmountExternal) {\n        bool mustUpdate;\n\n        // Transfer amount is checked inside finalize transfers in case when converting to external we\n        // round down to zero. This returns the actual net transfer in internal precision as well.\n        transferAmountExternal = TokenHandler.withdrawPrimeCash(\n            account,\n            balanceState.currencyId,\n            balanceState.primeCashWithdraw,\n            balanceState.primeRate,\n            withdrawWrapped // if true, withdraws ETH as WETH\n        );\n\n        // No changes to total cash after this point\n        int256 totalCashChange = balanceState.netCashChange.add(balanceState.primeCashWithdraw);\n\n        if (\n            checkAllowPrimeBorrow &&\n            totalCashChange < 0 &&\n            balanceState.storedCashBalance.add(totalCashChange) < 0\n        ) {\n            // If the total cash change is negative and it causes the stored cash balance to become negative,\n            // the account must allow prime debt. This is a safety check to ensure that accounts do not\n            // accidentally borrow variable through a withdraw or a batch transaction.\n            \n            // Accounts can still incur negative cash during fCash settlement, that will bypass this check.\n            \n            // During liquidation, liquidated accounts never have negative total cash change figures except\n            // in the case of negative local fCash liquidation. In that situation, setBalanceStorageForfCashLiquidation\n            // will be called instead.\n\n            // During liquidation, liquidators may have negative net cash change a token has transfer fees, however, in\n            // LiquidationHelpers.finalizeLiquidatorLocal they are not allowed to go into debt.\n            require(accountContext.allowPrimeBorrow, \"No Prime Borrow\");\n        }\n\n\n        if (totalCashChange != 0) {\n            balanceState.storedCashBalance = balanceState.storedCashBalance.add(totalCashChange);\n            mustUpdate = true;\n\n            emit CashBalanceChange(\n                account,\n                uint16(balanceState.currencyId),\n                totalCashChange\n            );\n        }\n\n        if (balanceState.netNTokenTransfer != 0 || balanceState.netNTokenSupplyChange != 0) {\n            // Final nToken balance is used to calculate the account incentive debt\n            int256 finalNTokenBalance = balanceState.storedNTokenBalance\n                .add(balanceState.netNTokenTransfer)\n                .add(balanceState.netNTokenSupplyChange);\n            // Ensure that nToken balances never become negative\n            require(finalNTokenBalance >= 0, \"Neg nToken\");\n\n\n            // overflow checked above\n            Incentives.claimIncentives(balanceState, account, uint256(finalNTokenBalance));\n\n            balanceState.storedNTokenBalance = finalNTokenBalance;\n\n            if (balanceState.netNTokenSupplyChange != 0) {\n                emit nTokenSupplyChange(\n                    account,\n                    uint16(balanceState.currencyId),\n                    balanceState.netNTokenSupplyChange\n                );\n            }\n\n            mustUpdate = true;\n        }\n\n        if (mustUpdate) {\n            _setBalanceStorage(\n                account,\n                balanceState.currencyId,\n                balanceState.storedCashBalance,\n                balanceState.storedNTokenBalance,\n                balanceState.lastClaimTime,\n                balanceState.accountIncentiveDebt,\n                balanceState.primeRate\n            );\n        }\n\n        accountContext.setActiveCurrency(\n            balanceState.currencyId,\n            // Set active currency to true if either balance is non-zero\n            balanceState.storedCashBalance != 0 || balanceState.storedNTokenBalance != 0,\n            Constants.ACTIVE_IN_BALANCES\n        );\n\n        if (balanceState.storedCashBalance < 0) {\n            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check where all balances\n            // are examined\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\n        }\n    }\n\n    /**\n     * @notice A special balance storage method for fCash liquidation to reduce the bytecode size.\n     */\n    function setBalanceStorageForfCashLiquidation(\n        address account,\n        AccountContext memory accountContext,\n        uint16 currencyId,\n        int256 netPrimeCashChange,\n        PrimeRate memory primeRate\n    ) internal {\n        (int256 cashBalance, int256 nTokenBalance, uint256 lastClaimTime, uint256 accountIncentiveDebt) =\n            getBalanceStorage(account, currencyId, primeRate);\n\n        int256 newCashBalance = cashBalance.add(netPrimeCashChange);\n        // If a cash balance is negative already we cannot put an account further into debt. In this case\n        // the netCashChange must be positive so that it is coming out of debt.\n        if (newCashBalance < 0) {\n            require(netPrimeCashChange > 0, \"Neg Cash\");\n            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check\n            // where all balances are examined. In this case the has cash debt flag should\n            // already be set (cash balances cannot get more negative) but we do it again\n            // here just to be safe.\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\n        }\n\n        bool isActive = newCashBalance != 0 || nTokenBalance != 0;\n        accountContext.setActiveCurrency(currencyId, isActive, Constants.ACTIVE_IN_BALANCES);\n\n        // Emit the event here, we do not call finalize\n        emit CashBalanceChange(account, currencyId, netPrimeCashChange);\n\n        _setBalanceStorage(\n            account,\n            currencyId,\n            newCashBalance,\n            nTokenBalance,\n            lastClaimTime,\n            accountIncentiveDebt,\n            primeRate\n        );\n    }\n\n    /// @notice Helper method for settling the output of the SettleAssets method\n    function finalizeSettleAmounts(\n        address account,\n        AccountContext memory accountContext,\n        SettleAmount[] memory settleAmounts\n    ) internal {\n        // Mapping from account to its various currency stores\n        mapping(uint256 => BalanceStorage) storage store = LibStorage.getBalanceStorage()[account];\n\n        for (uint256 i = 0; i < settleAmounts.length; i++) {\n            SettleAmount memory amt = settleAmounts[i];\n            if (amt.positiveSettledCash == 0 && amt.negativeSettledCash == 0) continue;\n\n            PrimeRate memory pr = settleAmounts[i].presentPrimeRate;\n            BalanceStorage storage balanceStorage = store[amt.currencyId];\n\n            int256 previousCashBalance = pr.convertFromStorage(balanceStorage.cashBalance);\n            int256 nTokenBalance = balanceStorage.nTokenBalance;\n\n            int256 newStoredCashBalance = pr.convertToStorageInSettlement(\n                account,\n                amt.currencyId,\n                previousCashBalance,\n                amt.positiveSettledCash,\n                amt.negativeSettledCash\n            );\n            balanceStorage.cashBalance = newStoredCashBalance.toInt88();\n\n            accountContext.setActiveCurrency(\n                amt.currencyId,\n                newStoredCashBalance != 0 || nTokenBalance != 0,\n                Constants.ACTIVE_IN_BALANCES\n            );\n\n            if (newStoredCashBalance < 0) {\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\n            }\n\n            emit CashBalanceChange(\n                account,\n                uint16(amt.currencyId),\n                amt.positiveSettledCash.add(amt.negativeSettledCash)\n            );\n        }\n    }\n\n    /// @notice Special method for setting balance storage for nToken\n    function setBalanceStorageForNToken(\n        address nTokenAddress,\n        uint16 currencyId,\n        int256 cashBalance\n    ) internal {\n        _setPositiveCashBalance(nTokenAddress, currencyId, cashBalance);\n    }\n\n    /// @notice Asses a fee or a refund to the nToken for leveraged vaults\n    function incrementVaultFeeToNToken(uint16 currencyId, int256 fee) internal {\n        require(fee >= 0); // dev: invalid fee\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        int256 cashBalance = getPositiveCashBalance(nTokenAddress, currencyId);\n        cashBalance = cashBalance.add(fee);\n        _setPositiveCashBalance(nTokenAddress, currencyId, cashBalance);\n    }\n\n    /// @notice increments fees to the reserve\n    function incrementFeeToReserve(uint16 currencyId, int256 fee) internal {\n        require(fee >= 0); // dev: invalid fee\n        // prettier-ignore\n        int256 totalReserve = getPositiveCashBalance(Constants.FEE_RESERVE, currencyId);\n        totalReserve = totalReserve.add(fee);\n        _setPositiveCashBalance(Constants.FEE_RESERVE, currencyId, totalReserve);\n        emit ReserveFeeAccrued(uint16(currencyId), fee);\n    }\n\n    /// @notice harvests excess reserve balance\n    function harvestExcessReserveBalance(uint16 currencyId, int256 reserve, int256 assetInternalRedeemAmount) internal {\n        // parameters are validated by the caller\n        reserve = reserve.subNoNeg(assetInternalRedeemAmount);\n        _setPositiveCashBalance(Constants.FEE_RESERVE, currencyId, reserve);\n        emit ExcessReserveBalanceHarvested(currencyId, assetInternalRedeemAmount);\n    }\n\n    /// @notice sets the reserve balance, see TreasuryAction.setReserveCashBalance\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance) internal {\n        require(newBalance >= 0); // dev: invalid balance\n        _setPositiveCashBalance(Constants.FEE_RESERVE, currencyId, newBalance);\n        emit ReserveBalanceUpdated(currencyId, newBalance);\n    }\n\n    function getPositiveCashBalance(\n        address account,\n        uint16 currencyId\n    ) internal view returns (int256 cashBalance) {\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\n        BalanceStorage storage balanceStorage = store[account][currencyId];\n        cashBalance = balanceStorage.cashBalance;\n        // Positive cash balances do not require prime rate conversion\n        require(cashBalance >= 0);\n    }\n\n    /// @notice Sets cash balances for special system accounts that can only ever have positive\n    /// cash balances (and nothing else). Because positive prime cash balances do not require any\n    /// adjustments this does not require a PrimeRate object\n    function _setPositiveCashBalance(address account, uint16 currencyId, int256 newCashBalance) internal {\n        require(newCashBalance >= 0); // dev: invalid balance\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\n        BalanceStorage storage balanceStorage = store[account][currencyId];\n        balanceStorage.cashBalance = newCashBalance.toInt88();"
    }
  ]
}