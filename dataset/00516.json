{
  "Title": "No mechanism for changing the recoverer in KintoWallet",
  "Content": "##### Description\n\n* https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/wallet/KintoWallet.sol#L48\n\nIn the current implementation of KintoWallet, it is impossible to change the address of the recoverer. If the recoverer loses access to their account, or goes rogue, the wallet owners have no way to change it, creating a risk for their funds.\n\n##### Recommendation\n\nWe recommend implementing a mechanism to change the recoverer in KintoWallet.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/wallet/KintoWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\n\nimport '@aa/core/BaseAccount.sol';\nimport '@aa/samples/callback/TokenCallbackHandler.sol';\n\nimport '../interfaces/IKintoID.sol';\nimport '../libraries/ByteSignature.sol';\nimport '../interfaces/IKintoWallet.sol';\nimport '../interfaces/IKintoWalletFactory.sol';\n\n// import 'forge-std/console2.sol';\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\n/**\n  * @title KintoWallet\n  * @dev Kinto Smart Contract Wallet. Supports EIP-4337.\n  *     has execute, eth handling methods and has a single signer \n  *     that can send requests through the entryPoint.\n  */\ncontract KintoWallet is Initializable, BaseAccount, TokenCallbackHandler, UUPSUpgradeable, IKintoWallet {\n    using ECDSA for bytes32;\n    using Address for address;\n\n    /* ============ State Variables ============ */\n    IKintoID public override immutable kintoID;\n    IEntryPoint private immutable _entryPoint;\n\n    uint8 public constant override MAX_SIGNERS = 3;\n    uint8 public constant override SINGLE_SIGNER = 1;\n    uint8 public constant override MINUS_ONE_SIGNER = 2;\n    uint8 public constant override ALL_SIGNERS = 3;\n    uint public constant override RECOVERY_TIME = 7 days;\n\n    IKintoWalletFactory override public factory;\n    uint8 public override signerPolicy = 1; // 1 = single signer, 2 = n-1 required, 3 = all required\n    uint public override inRecovery; // 0 if not in recovery, timestamp when initiated otherwise\n\n    address[] public override owners;\n    address public override recoverer;\n    address[] public override withdrawalWhitelist;\n\n    /* ============ Events ============ */\n    event KintoWalletInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n    event WalletPolicyChanged(uint newPolicy, uint oldPolicy);\n\n    /* ============ Modifiers ============ */\n\n    modifier onlySelf() {\n        _onlySelf();\n        _;\n    }\n\n    modifier onlyFactory() {\n        _onlyFactory();\n        _;\n    }\n\n    modifier onlyRecoverer() {\n        _onlyRecoverer();\n        _;\n    }\n\n    /* ============ Constructor & Initializers ============ */\n\n    constructor(IEntryPoint __entryPoint, IKintoID _kintoID) {\n        _entryPoint = __entryPoint;\n        kintoID = _kintoID;\n        _disableInitializers();\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    /**\n     * @dev The _entryPoint member is immutable, to reduce gas consumption.  To upgrade EntryPoint,\n     * a new implementation of SimpleAccount must be deployed with the new EntryPoint address, then upgrading\n     * the implementation by calling `upgradeTo()`\n     */\n    function initialize(address anOwner, address _recoverer) external virtual initializer {\n        // require(anOwner != _recoverer, 'recoverer and signer cannot be the same');\n        __UUPSUpgradeable_init();\n        owners.push(anOwner);\n        signerPolicy = SINGLE_SIGNER;\n        recoverer = _recoverer;\n        factory = IKintoWalletFactory(msg.sender);\n        emit KintoWalletInitialized(_entryPoint, anOwner);\n    }\n\n\n    /* ============ Execution methods ============ */\n    \n    /**\n     * execute a transaction (called directly from owner, or by entryPoint)\n     */\n    function execute(address dest, uint256 value, bytes calldata func) external override {\n        _requireFromEntryPoint();\n        dest.functionCallWithValue(func, value);\n    }\n\n    /**\n     * execute a sequence of transactions\n     */\n    function executeBatch(address[] calldata dest, uint256[] calldata values, bytes[] calldata func) external override {\n        _requireFromEntryPoint();\n        require(dest.length == func.length, 'wrong array lengths');\n        for (uint256 i = 0; i < dest.length; i++) {\n            dest[i].functionCallWithValue(func[i], values[i]);\n        }\n    }\n\n    /* ============ Signer Management ============ */\n    \n    /**\n     * @dev Change the signer policy\n     * @param policy new policy\n     */\n    function setSignerPolicy(uint8 policy) external override onlySelf {\n        require(policy > 0 && policy < 4  && policy != signerPolicy, 'invalid policy');\n        require(policy == 1 || owners.length > 1, 'invalid policy');\n        emit WalletPolicyChanged(policy, signerPolicy);\n        signerPolicy = policy;\n    }\n\n    /**\n     * @dev Changed the signers\n     * @param newSigners new signers array\n     */\n    function resetSigners(address[] calldata newSigners) external override onlySelf {\n        _resetSigners(newSigners);\n    }\n\n    /* ============ Whitelist Management ============ */\n\n    /**\n     * @dev Changed the valid withdrawal addresses\n     * @param newWhitelist new signers array\n     */\n    function resetWithdrawalWhitelist(address[] calldata newWhitelist) external override onlySelf {\n        withdrawalWhitelist = newWhitelist;\n    }\n\n    /* ============ Recovery Process ============ */\n\n    /**\n     * @dev Start the recovery process\n     * Can only be called by the factory through a privileged signer\n     */\n    function startRecovery() external override onlyRecoverer {\n        inRecovery = block.timestamp;\n    }\n\n    /**\n     * @dev Finish the recovery process and resets the signers\n     * Can only be called by the factory through a privileged signer\\\n     * @param newSigners new signers array\n     */\n    function finishRecovery(address[] calldata newSigners) external override onlyRecoverer {\n        require(inRecovery > 0 && block.timestamp > 0 && block.timestamp > (inRecovery + RECOVERY_TIME), 'too early');\n        require(!kintoID.isKYC(owners[0]), 'Old KYC must be burned');\n        require(kintoID.isKYC(newSigners[0]), 'New KYC must be minted');\n        _resetSigners(newSigners);\n        inRecovery = 0;\n    }\n\n    /**\n     * @dev Cancel the recovery process\n     * Can only be called by the account holder if he regains access to his wallet\n     */\n    function cancelRecovery() external override onlySelf {\n        inRecovery = 0;\n    }\n\n    /* ============ View Functions ============ */\n\n    // @inheritdoc BaseAccount\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    function getNonce() public view virtual override(BaseAccount, IKintoWallet) returns (uint) {\n        return super.getNonce();\n    }\n\n    function getOwnersCount() public view override returns (uint) {\n        return owners.length;\n    }\n\n    /* ============ IAccountOverrides ============ */\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash)\n        internal override virtual returns (uint256 validationData) {\n        // We don't want to do requires here as it would revert the whole transaction\n        // Check first owner of this account is still KYC'ed\n        if (!kintoID.isKYC(owners[0])) {\n            return SIG_VALIDATION_FAILED;\n        }\n        if (userOp.signature.length != 65 * owners.length) {\n            return SIG_VALIDATION_FAILED;\n        }\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        // Single signer\n        if (signerPolicy == 1) {\n            if (owners[0] != hash.recover(userOp.signature))\n                return SIG_VALIDATION_FAILED;\n            return 0;\n        }\n        uint requiredSigners = signerPolicy == 3 ? owners.length : owners.length - 1;\n        bytes[] memory signatures = new bytes[](owners.length);\n        // Split signature from userOp.signature\n        if (owners.length == 2) {\n            (signatures[0], signatures[1]) = ByteSignature.extractTwoSignatures(userOp.signature);\n        } else {\n            (signatures[0], signatures[1], signatures[2]) = ByteSignature.extractThreeSignatures(userOp.signature);\n        }\n        for (uint i = 0; i < owners.length; i++) {\n            if (owners[i] == hash.recover(signatures[i])) {\n                requiredSigners--;\n            }\n        }\n        return requiredSigners;\n    }\n\n    /* ============ Private Functions ============ */\n\n    function _resetSigners(address[] calldata newSigners) internal {\n        require(newSigners.length > 0 && newSigners.length <= MAX_SIGNERS, 'invalid array');\n        require(newSigners[0] != address(0) && kintoID.isKYC(newSigners[0]), 'KYC Required');\n        require(newSigners.length == 1 ||\n            (newSigners.length == 2 && newSigners[0] != newSigners[1]) ||\n            (newSigners.length == 3 && (newSigners[0] != newSigners[1]) &&\n                (newSigners[1] != newSigners[2]) && newSigners[0] != newSigners[2]),\n            'duplicate owners');\n        owners = newSigners;\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by an owner.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the implementation is upgraded\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        (newImplementation);\n        _onlySelf();\n    }\n\n    function _onlySelf() internal view {\n        //directly through the account itself (which gets redirected through execute())\n        require(msg.sender == address(this), 'only self');\n    }\n\n    function _onlyFactory() internal view {\n        //directly through the factory\n        require(msg.sender == address(factory), 'only factory');\n    }\n\n    function _onlyRecoverer() internal view {\n        //directly through the factory\n        require(msg.sender == address(recoverer), 'only recoverer');\n    }\n}"
    }
  ]
}