{
  "Title": "H-7: cannot forward extra rewards from both OCY_Convex to OCT_YDL.",
  "Content": "# Issue H-7: cannot forward extra rewards from both OCY_Convex to OCT_YDL. \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/479 \n\n## Found by \n0xpiken, AllTooWell, BoRonGod, Drynooo, Ironsidesec, den\\_sosnovskyi, ether\\_sky\n## Summary\n\nConvex specifies `rewardContract` to be a `VirtualBalanceRewardPool`, but all three OCY_Convex uses it as a ERC20 token, which make it impossible to claim extra rewards and forward them to the OCT_YDL.\n\n## Vulnerability Detail\n\nAccording to [Convex doc](https://docs.convexfinance.com/convexfinanceintegration/baserewardpool#extra-rewards):\n\n> The BaseRewardPool has an array of child reward contracts called extraRewards.\n> You can query the number of extra rewards via baseRewardPool.extraRewardsLength().\n> This array holds a list of [VirtualBalanceRewardPool ](https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol)contracts which are similar in nature to the base reward contract but without actual control of staked tokens.\n> \n> This means that if a pool has CRV rewards as well as SNX rewards, the pool's main reward contract(BaseRewardPool) will distribute the CRV and the child contract(VirtualBalanceRewardPool) will distribute the SNX.\n\nBut, in current implementation: (take OCY_Convex_A for example)\n\n        // Extra Rewards\n        if (extra) {\n            uint256 extraRewardsLength = IBaseRewardPool_OCY_Convex_A(convexRewards).extraRewardsLength();\n            for (uint256 i = 0; i < extraRewardsLength; i++) {\n                address rewardContract = IBaseRewardPool_OCY_Convex_A(convexRewards).extraRewards(i);\n                uint256 rewardAmount = IBaseRewardPool_OCY_Convex_A(rewardContract).rewardToken().balanceOf(\n                    address(this)\n                );\n                //@Audit rewardContract is a VirtualBalanceRewardPool\n                if (rewardAmount > 0) { IERC20(rewardContract).safeTransfer(OCT_YDL, rewardAmount); }\n            }\n        }\n\nTokens cannot be sent to YDL.\n\n## Impact\n\nCurrent OCY_Convex_A, OCY_Convex_B and OCY_Convex_C cannot forward extraRewards to YDL.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/lockers/OCY/OCY_Convex_A.sol#L263\nhttps://docs.convexfinance.com/convexfinanceintegration/baserewardpool#extra-rewards\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the real token address for token transfer.\n\n\n\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> high, dup of #477, loss of additional reward from convex. Since it accumulates over 30-days period, the loss will be significant. Both `balanceOf` and `safeTransfer` are incorrect - they should be called on `rewardToken().token()`. Different dups of this mention either `balanceOf` or `safeTransfer`, but not both, but I consider them to be the same root cause, so all are dups.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/lockers/OCY/OCY_Convex_A.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IBasePool_OCY_Convex_A {\n    function add_liquidity(uint256[2] memory _amounts, uint256 _min_mint_amount) external returns(uint256);\n    function remove_liquidity(uint256 _burn_amount, uint256[2] memory _min_amounts) external returns(uint256[2] memory);\n}\n\ninterface IBaseRewardPool_OCY_Convex_A {\n    function extraRewards(uint256 index) external view returns(address);\n    function extraRewardsLength() external view returns(uint256);\n    function rewardToken() external view returns(IERC20);\n    function getReward() external returns(bool);\n    function withdrawAndUnwrap(uint256 _amount, bool _claim) external returns(bool);\n}\n\ninterface IBooster_OCY_Convex_A {\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns(bool);\n    function poolInfo(uint256) external view returns(address,address,address,address,address,bool);\n}\n\ninterface IMetaPool_OCY_Convex_A {\n    function add_liquidity(uint256[2] memory _amounts, uint256 _min_mint_amount) external;\n    function remove_liquidity(uint256 _burn_amount, uint256[2] memory _min_amounts) external returns(uint256[2] memory);\n}\n\ninterface IZivoeGlobals_OCY_Convex_A {\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n}\n\n\n\n/// @notice This contract allocates stablecoins to the alUSD/FRAXBP meta-pool and stakes the LP tokens on Convex.\ncontract OCY_Convex_A is ZivoeLocker, ReentrancyGuard {\n    \n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;                   /// @dev The ZivoeGlobals contract.\n\n    address public OCT_YDL;                         /// @dev The OCT_YDL contract.\n\n    /// @dev Tokens.\n    address public constant FRAX = 0x853d955aCEf822Db058eb8505911ED77F175b99e;  /// @dev Index 0, BasePool\n    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;  /// @dev Index 1, BasePool\n    address public constant alUSD = 0xBC6DA0FE9aD5f3b0d58160288917AA56653660E9; /// @dev Index 0, MetaPool\n\n    address public constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52;   /// @dev Native Reward #1\n    address public constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;   /// @dev Native Reward #2\n\n    /// @dev Convex information.\n    address public convexDeposit = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n    address public convexRewards = 0x26598e3E511ADFadefD70ab2C3475Ff741741104;\n    address public convexPoolToken = 0xB30dA2376F63De30b42dC055C93fa474F31330A5;\n\n    uint256 public convexPoolID = 106;\n\n    /// @dev Curve information.\n    address public curveBasePool = 0xDcEF968d416a41Cdac0ED8702fAC8128A64241A2;\n    address public curveBasePoolToken = 0x3175Df0976dFA876431C2E9eE6Bc45b65d3473CC; /// @dev Index 1, MetaPool\n    address public curveMetaPool = 0xB30dA2376F63De30b42dC055C93fa474F31330A5;      /// @dev MetaPool & Token\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCY_OUSD contract.\n    /// @param  DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _OCT_YDL The OCT_YDL (Treasury and ZivoeSwapper) contract.\n    constructor(address DAO, address _GBL, address _OCT_YDL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n        OCT_YDL = _OCT_YDL;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during updateOCTYDL().\n    /// @param  newOCT The new OCT_YDL contract.\n    /// @param  oldOCT The old OCT_YDL contract.\n    event UpdatedOCTYDL(address indexed newOCT, address indexed oldOCT);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLocker().\n    function canPush() public pure override returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public pure override returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pushToLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice Migrates specific amount of ERC20 from owner() to locker.\n    /// @param  asset The asset to migrate.\n    /// @param  amount The amount of \"asset\" to migrate.\n    /// @param  data Accompanying transaction data.\n    function pushToLocker(address asset, uint256 amount, bytes calldata data) external override onlyOwner {\n        require(\n            asset == FRAX || asset == USDC || asset == alUSD, \n            \"OCY_Convex_A::pushToLocker() asset != FRAX && asset != USDC && asset != alUSD\"\n        );\n        IERC20(asset).safeTransferFrom(owner(), address(this), amount);\n\n        (uint _min_mint_amountBP, uint _min_mint_amountMP) = abi.decode(data, (uint, uint));\n\n        if (asset == FRAX) {\n            // Allocate FRAX to Curve BasePool\n            IERC20(FRAX).safeIncreaseAllowance(curveBasePool, amount);\n            uint256[2] memory _amounts;\n            _amounts[0] = amount;\n            IBasePool_OCY_Convex_A(curveBasePool).add_liquidity(_amounts, _min_mint_amountBP);\n            assert(IERC20(FRAX).allowance(address(this), curveBasePool) == 0);\n            \n            // Allocate curveBasePoolToken to Curve MetaPool\n            _amounts[0] = 0;\n            _amounts[1] = IERC20(curveBasePoolToken).balanceOf(address(this));\n            IERC20(curveBasePoolToken).safeIncreaseAllowance(curveMetaPool, _amounts[1]);\n            IMetaPool_OCY_Convex_A(curveMetaPool).add_liquidity(_amounts, _min_mint_amountMP);\n            assert(IERC20(curveBasePoolToken).allowance(address(this), curveMetaPool) == 0);\n        }\n        else if (asset == USDC) {\n            // Allocate USDC to Curve BasePool\n            IERC20(USDC).safeIncreaseAllowance(curveBasePool, amount);\n            uint256[2] memory _amounts;\n            _amounts[1] = amount;\n            IBasePool_OCY_Convex_A(curveBasePool).add_liquidity(_amounts, _min_mint_amountBP);\n            assert(IERC20(USDC).allowance(address(this), curveBasePool) == 0);\n\n            // Allocate curveBasePoolToken to Curve MetaPool\n            _amounts[1] = IERC20(curveBasePoolToken).balanceOf(address(this));\n            IERC20(curveBasePoolToken).safeIncreaseAllowance(curveMetaPool, _amounts[1]);\n            IMetaPool_OCY_Convex_A(curveMetaPool).add_liquidity(_amounts, _min_mint_amountMP);\n            assert(IERC20(curveBasePoolToken).allowance(address(this), curveMetaPool) == 0);\n        }\n        else {\n            // Allocate alUSD to Curve MetaPool\n            uint256[2] memory _amounts;\n            _amounts[0] = amount;\n            IERC20(alUSD).safeIncreaseAllowance(curveMetaPool, _amounts[0]);\n            IMetaPool_OCY_Convex_A(curveMetaPool).add_liquidity(_amounts, _min_mint_amountMP);\n            assert(IERC20(alUSD).allowance(address(this), curveMetaPool) == 0);\n        }\n\n        // Stake CurveLP tokens to Convex\n        uint balCurveMetaPool = IERC20(curveMetaPool).balanceOf(address(this));\n        IERC20(curveMetaPool).safeIncreaseAllowance(convexDeposit, balCurveMetaPool);\n        IBooster_OCY_Convex_A(convexDeposit).deposit(convexPoolID, balCurveMetaPool, true);\n        assert(IERC20(curveMetaPool).allowance(address(this), convexDeposit) == 0);\n    }\n\n    /// @notice Migrates entire ERC20 balance from locker to owner().\n    /// @param  asset The asset to migrate.\n    /// @param  data Accompanying transaction data.\n    function pullFromLocker(address asset, bytes calldata data) external override onlyOwner {\n        require(asset == convexPoolToken, \"OCY_Convex_A::pullFromLocker() asset != convexPoolToken\");\n        \n        claimRewards(false);\n        \n        // Withdraw from ConvexRewards and unstake CurveLP tokens from ConvexBooster\n        IBaseRewardPool_OCY_Convex_A(convexRewards).withdrawAndUnwrap(\n            IERC20(convexRewards).balanceOf(address(this)), false\n        );\n\n        (uint _mp_min0, uint _mp_min1, uint _bp_min0, uint _bp_min1) = abi.decode(data, (uint, uint, uint, uint));\n\n        // Burn MetaPool tokens\n        uint256[2] memory _min_amounts_mp;\n        _min_amounts_mp[0] = _mp_min0;\n        _min_amounts_mp[1] = _mp_min1;\n        IMetaPool_OCY_Convex_A(curveMetaPool).remove_liquidity(\n            IERC20(curveMetaPool).balanceOf(address(this)), _min_amounts_mp\n        );\n\n        // Burn BasePool Tokens\n        uint256[2] memory _min_amounts_bp;\n        _min_amounts_bp[0] = _bp_min0;\n        _min_amounts_bp[1] = _bp_min1;\n        IBasePool_OCY_Convex_A(curveBasePool).remove_liquidity(\n            IERC20(curveBasePoolToken).balanceOf(address(this)), _min_amounts_bp\n        );\n\n        // Return tokens to DAO\n        IERC20(alUSD).safeTransfer(owner(), IERC20(alUSD).balanceOf(address(this)));\n        IERC20(FRAX).safeTransfer(owner(), IERC20(FRAX).balanceOf(address(this)));\n        IERC20(USDC).safeTransfer(owner(), IERC20(USDC).balanceOf(address(this)));\n\n    }\n\n    /// @notice Migrates specific amount of ERC20 from locker to owner().\n    /// @param  asset The asset to migrate.\n    /// @param  amount The amount of \"asset\" to migrate.\n    /// @param  data Accompanying transaction data.\n    function pullFromLockerPartial(address asset, uint256 amount, bytes calldata data) external override onlyOwner {\n        require(asset == convexPoolToken, \"OCY_Convex_A::pullFromLockerPartial() asset != convexPoolToken\");\n        \n        claimRewards(false);\n        \n        IBaseRewardPool_OCY_Convex_A(convexRewards).withdrawAndUnwrap(amount, false);\n\n        (uint _mp_min0, uint _mp_min1, uint _bp_min0, uint _bp_min1) = abi.decode(data, (uint, uint, uint, uint));\n\n        // Burn MetaPool tokens\n        uint256[2] memory _min_amounts_mp;\n        _min_amounts_mp[0] = _mp_min0;\n        _min_amounts_mp[1] = _mp_min1;\n        IMetaPool_OCY_Convex_A(curveMetaPool).remove_liquidity(\n            IERC20(curveMetaPool).balanceOf(address(this)), _min_amounts_mp\n        );\n\n        // Burn BasePool Tokens\n        uint256[2] memory _min_amounts_bp;\n        _min_amounts_bp[0] = _bp_min0;\n        _min_amounts_bp[1] = _bp_min1;\n        IBasePool_OCY_Convex_A(curveBasePool).remove_liquidity(\n            IERC20(curveBasePoolToken).balanceOf(address(this)), _min_amounts_bp\n        );\n\n        // Return tokens to DAO\n        IERC20(alUSD).safeTransfer(owner(), IERC20(alUSD).balanceOf(address(this)));\n        IERC20(FRAX).safeTransfer(owner(), IERC20(FRAX).balanceOf(address(this)));\n        IERC20(USDC).safeTransfer(owner(), IERC20(USDC).balanceOf(address(this)));\n    }\n\n    /// @notice Claims rewards and forward them to the OCT_YDL.\n    /// @param extra Flag for claiming extra rewards.\n    function claimRewards(bool extra) public nonReentrant {\n        IBaseRewardPool_OCY_Convex_A(convexRewards).getReward();\n\n        // Native Reward (CRV)\n        uint256 rewardsCRV = IERC20(CRV).balanceOf(address(this));\n        uint256 rewardsCVX = IERC20(CVX).balanceOf(address(this));\n        if (rewardsCRV > 0) { IERC20(CRV).safeTransfer(OCT_YDL, rewardsCRV); }\n        if (rewardsCVX > 0) { IERC20(CVX).safeTransfer(OCT_YDL, rewardsCVX); }\n\n        // Extra Rewards\n        if (extra) {\n            uint256 extraRewardsLength = IBaseRewardPool_OCY_Convex_A(convexRewards).extraRewardsLength();\n            for (uint256 i = 0; i < extraRewardsLength; i++) {\n                address rewardContract = IBaseRewardPool_OCY_Convex_A(convexRewards).extraRewards(i);\n                uint256 rewardAmount = IBaseRewardPool_OCY_Convex_A(rewardContract).rewardToken().balanceOf(\n                    address(this)\n                );\n                if (rewardAmount > 0) { IERC20(rewardContract).safeTransfer(OCT_YDL, rewardAmount); }\n            }\n        }\n    }\n\n    /// @notice Update the OCT_YDL endpoint.\n    /// @dev    This function MUST only be called by ZVL().\n    /// @param  _OCT_YDL The new address for OCT_YDL.\n    function updateOCTYDL(address _OCT_YDL) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCY_Convex_A(GBL).ZVL(), \n            \"OCY_Convex_A::updateOCTYDL() _msgSender() != IZivoeGlobals_OCY_Convex_A(GBL).ZVL()\"\n        );\n        require(_OCT_YDL != address(0), \"OCY_Convex_A::updateOCTYDL() _OCT_YDL == address(0)\");\n        emit UpdatedOCTYDL(_OCT_YDL, OCT_YDL);\n        OCT_YDL = _OCT_YDL;\n    }\n\n}"
    }
  ]
}