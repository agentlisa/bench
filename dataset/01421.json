{
  "Title": "M-10: Malicious users could use back old values",
  "Content": "# Issue M-10: Malicious users could use back old values \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/612 \n\n## Found by \nctf\\_sec, xiaoming90\n\nMalicious users could use back old values to manipulate the price.\n\n## Vulnerability Detail\n\nPer the [Teller's User Checklist](https://docs.tellor.io/tellor/getting-data/user-checklists#ensure-that-functions-do-not-use-old-tellor-values), it is possible that a potential attacker could go back in time to find a desired value in the event that a Tellor value is disputed. Following is the extract taken from the checklist:\n\n> **Ensure that functions do not use old Tellor values** \n>\n> In the event where a Tellor value is disputed, the disputed value is removed & previous values remain. Prevent potential attackers from going back in time to find a desired value with a check in your contracts. [This repo](https://github.com/tellor-io/tellor-caller-liquity/blob/main/contracts/TellorCaller.sol) is a great reference for integrating Tellor.\n\nThe current implementation lack measure to guard against such attack.\n\n```solidity\nFile: TellorOracle.sol\n101:     function getPriceInEth(address tokenToPrice) external returns (uint256) {\n102:         TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n103:         uint256 timestamp = block.timestamp;\n104:         // Giving time for Tellor network to dispute price\n105:         (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n106:         uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n107:         uint256 tokenPricingTimeout = tellorStoredTimeout == 0 ? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n108: \n109:         // Check that something was returned and freshness of price.\n110:         if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n111:             revert InvalidDataReturned();\n112:         }\n113: \n114:         uint256 price = abi.decode(value, (uint256));\n115:         return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n116:     }\n```\n\nAnyone can submit a dispute to Tellor by paying a fee. The disputed values are immediately removed upon submission, and the previous values will remain. The attacks are profitable as long as the economic gains are higher than the dispute fee. For instance, this can be achieved by holding large amounts of vault shares (e.g., obtained using own funds or flash-loan) to amplify the gain before manipulating the assets within it to increase the values.\n\n## Impact\n\nMalicious users could manipulate the price returned by the oracle to be higher or lower than expected. The protocol relies on the oracle to provide accurate pricing for many critical operations, such as determining the debt values of DV, calculators/stats used during the rebalancing process, NAV/shares of the LMPVault, and determining how much assets the users should receive during withdrawal.\n\nIncorrect pricing would result in many implications that lead to a loss of assets, such as users withdrawing more or fewer assets than expected due to over/undervalued vaults or strategy allowing an unprofitable rebalance to be executed.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol#L101\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the affected function as per the recommendation in [Teller's User Checklist](https://docs.tellor.io/tellor/getting-data/user-checklists#ensure-that-functions-do-not-use-old-tellor-values).\n\n```diff\nfunction getPriceInEth(address tokenToPrice) external returns (uint256) {\n    TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n    uint256 timestamp = block.timestamp;\n    // Giving time for Tellor network to dispute price\n    (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n    uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n    uint256 tokenPricingTimeout = tellorStoredTimeout == 0 ? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n\n    // Check that something was returned and freshness of price.\n    if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n        revert InvalidDataReturned();\n    }\n    \n+    if (timestampRetrieved > lastStoredTimestamps[tellorInfo.queryId]) {\n+        lastStoredTimestamps[tellorInfo.queryId] = timestampRetrieved;\n+        lastStoredPrices[tellorInfo.queryId] = value;\n+    } else {\n+    \tvalue = lastStoredPrices[tellorInfo.queryId]\n+    }\n\n    uint256 price = abi.decode(value, (uint256));\n    return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n}\n```\n\n\n\n## Discussion\n\n**xiaoming9090**\n\nEscalate\n\nThis is wrongly duplicated to Issue 744. In Issue 744, it highlights that the 30-minute delay is too large, which is different from the issue highlighted here. This issue is about a different vulnerability highlighted in Tellor checklist where malicious users can re-use back an old value that has nothing to do with the 30-minute delay being too large.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is wrongly duplicated to Issue 744. In Issue 744, it highlights that the 30-minute delay is too large, which is different from the issue highlighted here. This issue is about a different vulnerability highlighted in Tellor checklist where malicious users can re-use back an old value that has nothing to do with the 30-minute delay being too large.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**JeffCX**\n\nEscalate\n\nAgree with LSW. \n\n#844 is a duplicate of this issue as well, the issue that only highlight the stale price feed should be de-dup together! Thanks!\n\n**sherlock-admin2**\n\n > Escalate\n> \n> Agree with LSW. \n> \n> #844 is a duplicate of this issue as well, the issue that only highlight the stale price feed should be de-dup together! Thanks!\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Trumpero**\n\nAgree with the @xiaoming9090, this issue should not be a duplication of #744 \nPlease check this as well @codenutt \n\n**Evert0x**\n\nPlanning to accept both escalations and make #612 a valid medium with #844 as a duplicate.\n\n**codenutt**\n\n> Agree with the @xiaoming9090, this issue should not be a duplication of #744 Please check this as well @codenutt\n\nYup agree. Thx!\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/612/#issuecomment-1748029481): accepted\n- [JEFFCX](https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/612/#issuecomment-1748625856): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { BaseOracleDenominations, ISystemRegistry } from \"src/oracles/providers/base/BaseOracleDenominations.sol\";\nimport { IEthValueOracle } from \"src/interfaces/pricing/IEthValueOracle.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\nimport { UsingTellor } from \"usingtellor/UsingTellor.sol\";\n\n/**\n * @title Gets the spot price of tokens that Tellor provides a feed for.\n * @dev Will convert all tokens to Eth pricing regardless of original denomination.\n * @dev Returns 18 decimals of precision.\n */\ncontract TellorOracle is BaseOracleDenominations, UsingTellor {\n    /**\n     * @notice Used to store information about Tellor price queries.\n     * @dev No decimals, all returned in e18 precision.\n     * @param queryId bytes32 queryId for pricing query. See here: https://tellor.io/queryidstation/.\n     * @param pricingTimeout Custom timeout for asset.  If 0, contract will use default defined in\n     *    `BaseOracleDenominations.sol`.\n     * @param denomination Enum representing denomination of price returned.\n     */\n    struct TellorInfo {\n        bytes32 queryId;\n        uint32 pricingTimeout;\n        Denomination denomination;\n    }\n\n    /// @dev Token address to TellorInfo structs.\n    mapping(address => TellorInfo) private tellorQueryInfo;\n\n    /// @notice Emitted when information about a Tellor query is registered.\n    event TellorRegistrationAdded(address token, Denomination denomination, bytes32 _queryId);\n\n    /// @notice Emitted when  information about a Tellor query is removed.\n    event TellorRegistrationRemoved(address token, bytes32 queryId);\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _tellorOracleAddress\n    )\n        // Tellor requires payable address\n        UsingTellor(payable(_tellorOracleAddress))\n        BaseOracleDenominations(_systemRegistry)\n    {\n        Errors.verifyNotZero(_tellorOracleAddress, \"tellor\");\n    }\n\n    /**\n     * @notice Allows permissioned address to set _queryId, denomination for token address.\n     * @param token Address of token to set queryId for.\n     * @param _queryId Bytes32 queryId.\n     * @param denomination Denomination of token.\n     * @param pricingTimeout Custom timeout for queryId if needed.  Can be set to zero\n     *      to use default defined in `BaseOracleDenominations.sol`.\n     */\n    function addTellorRegistration(\n        address token,\n        bytes32 _queryId,\n        Denomination denomination,\n        uint32 pricingTimeout\n    ) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenForQueryId\");\n        Errors.verifyNotZero(_queryId, \"queryId\");\n        if (tellorQueryInfo[token].queryId != bytes32(0)) revert Errors.MustBeZero();\n        tellorQueryInfo[token] =\n            TellorInfo({ queryId: _queryId, denomination: denomination, pricingTimeout: pricingTimeout });\n        emit TellorRegistrationAdded(token, denomination, _queryId);\n    }\n\n    /**\n     * @notice Allows permissioned removal registration for token address.\n     * @param token Token to remove TellorInfo struct for.\n     */\n    function removeTellorRegistration(address token) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenToRemoveRegistration\");\n        bytes32 queryIdBeforeDeletion = tellorQueryInfo[token].queryId;\n        Errors.verifyNotZero(queryIdBeforeDeletion, \"queryIdBeforeDeletion\");\n        delete tellorQueryInfo[token];\n        emit TellorRegistrationRemoved(token, queryIdBeforeDeletion);\n    }\n\n    /**\n     * @notice External function to view TellorInfo struct for token address.\n     * @dev Will return empty struct for unregistered token address.\n     * @param token Address of token to view TellorInfo struct for.\n     */\n    function getQueryInfo(address token) external view returns (TellorInfo memory) {\n        return tellorQueryInfo[token];\n    }\n\n    /**\n     * @dev Tellor always returns prices with 18 decimals of precision for spot pricing, so we do not need\n     *      to worry about increasing or decreasing precision here.  See here:\n     *      https://github.com/tellor-io/dataSpecs/blob/main/types/SpotPrice.md\n     */\n    // slither-disable-start timestamp\n    function getPriceInEth(address tokenToPrice) external returns (uint256) {\n        TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n        uint256 timestamp = block.timestamp;\n        // Giving time for Tellor network to dispute price\n        (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n        uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n        uint256 tokenPricingTimeout = tellorStoredTimeout == 0 ? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n\n        // Check that something was returned and freshness of price.\n        if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n            revert InvalidDataReturned();\n        }\n\n        uint256 price = abi.decode(value, (uint256));\n        return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n    }\n    // slither-disable-end timestamp\n\n    /// @dev Used to enforce non-existent queryId checks\n    function _getQueryInfo(address token) private view returns (TellorInfo memory tellorInfo) {\n        tellorInfo = tellorQueryInfo[token];\n        Errors.verifyNotZero(tellorInfo.queryId, \"queryId\");\n    }\n}"
    }
  ]
}