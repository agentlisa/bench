{
  "Title": "[23] Deviations between Solidity compiler's checks and seaport's checks in `validateOrderParameters`",
  "Content": "\n**Context**: [Assertions.sol#L105](https://github.com/ProjectOpenSea/seaport/blob/878121af65be408462f3eae04ab81018b4e199da/contracts/lib/Assertions.sol#L105)\n\nSome comments on comparison between code produced by solidity and this:\n\n1. If there is a parameter `BasicOrderParameters calldata`, the compiler generates the following checks:\n    1. `calldatasize() < 2**64`.\n    2. `calldataload(4) < 2**64`. (Check if the initial offset is too big)\n    3. `calldatasize() - offset >= 0x244`.\n1. The ABI encoder V2 has additional checks on whether `calldata` is properly clean. The compiler only does this checks when a value is read (a high level read; assembly doesn't count). If you want to be complaint, then the values will need to be checked for sanity. For example, an `address` type should not have dirty higher order bits. For example, for `considerationToken`.\n1. This does not check for upper bounds of length of the array `additionalRecipients`. The compiler typically checks if length is `< 2**64`. Similarly, for `bytes signature`. The length checks are surprisingly needed in general, otherwise some offset calculations can overflow and read values that it is not supposed to read. This can be used to fool some checks. Mentioned below.\n1. Both `additionalRecipents` and `signature` are responsible for at least 1 word each in `calldata` (at least length should be present). The compiler checks this. But is likely missing here. \n    1. [`calldataEncodedTailSize`](https://github.com/ethereum/solidity/blob/fdc3c8eedeae7327f772c368582e25fc6a5add5c/libsolidity/ast/Types.cpp#L1725)\n    2. [the check](https://github.com/ethereum/solidity/blob/fdc3c8eedeae7327f772c368582e25fc6a5add5c/libsolidity/codegen/YulUtilFunctions.cpp#L2356) for tail size\n1. The compiler checks that the length of the two dynamic arrays (appropriately scaled) + offsets wouldn't be past `calldatasize()`. (Note: reading past `calldatasize()` would return 0).\n\n### Recommended Mitigation Steps\n\nDocument the differences. Consider adding additional checks, if the differences need to be accounted. See a related issue regarding overflowing length, which ideally needs to be fixed.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/203#issuecomment-1171063542):**\n > This report and its merged issues* highlight several limitations which are informative to the Opensea team. This report is of high quality and is deserving of the best score. I consider all issues raised to be valid.\n>\n> *Merged issues: #[108](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/108), [156](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/156), [176](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/176), [195](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/195), and [205](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/205).\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/Assertions.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { OrderParameters } from \"./ConsiderationStructs.sol\";\n\nimport { GettersAndDerivers } from \"./GettersAndDerivers.sol\";\n\nimport { TokenTransferrerErrors } from \"../interfaces/TokenTransferrerErrors.sol\";\n\nimport { NonceManager } from \"./NonceManager.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title Assertions\n * @author 0age\n * @notice Assertions contains logic for making various assertions that do not\n *         fit neatly within a dedicated semantic scope.\n */\ncontract Assertions is\n    GettersAndDerivers,\n    NonceManager,\n    TokenTransferrerErrors\n{\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController)\n        GettersAndDerivers(conduitController)\n    {}\n\n    /**\n     * @dev Internal view function to to ensure that the supplied consideration\n     *      array length on a given set of order parameters is not less than the\n     *      original consideration array length for that order and to retrieve\n     *      the current nonce for a given order's offerer and zone and use it to\n     *      derive the order hash.\n     *\n     * @param orderParameters The parameters of the order to hash.\n     *\n     * @return The hash.\n     */\n    function _assertConsiderationLengthAndGetNoncedOrderHash(\n        OrderParameters memory orderParameters\n    ) internal view returns (bytes32) {\n        // Ensure supplied consideration array length is not less than original.\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n            orderParameters.consideration.length,\n            orderParameters.totalOriginalConsiderationItems\n        );\n\n        // Derive and return order hash using current nonce for the offerer.\n        return\n            _deriveOrderHash(\n                orderParameters,\n                _getNonce(orderParameters.offerer)\n            );\n    }\n\n    /**\n     * @dev Internal pure function to ensure that the supplied consideration\n     *      array length for an order to be fulfilled is not less than the\n     *      original consideration array length for that order.\n     *\n     * @param suppliedConsiderationItemTotal The number of consideration items\n     *                                       supplied when fulfilling the order.\n     * @param originalConsiderationItemTotal The number of consideration items\n     *                                       supplied on initial order creation.\n     */\n    function _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n        uint256 suppliedConsiderationItemTotal,\n        uint256 originalConsiderationItemTotal\n    ) internal pure {\n        // Ensure supplied consideration array length is not less than original.\n        if (suppliedConsiderationItemTotal < originalConsiderationItemTotal) {\n            revert MissingOriginalConsiderationItems();\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that a given item amount is not\n     *      zero.\n     *\n     * @param amount The amount to check.\n     */\n    function _assertNonZeroAmount(uint256 amount) internal pure {\n        // Revert if the supplied amont is equal to zero.\n        if (amount == 0) {\n            revert MissingItemAmount();\n        }\n    }\n\n    /**\n     * @dev Internal pure function to validate calldata offsets for dynamic\n     *      types in BasicOrderParameters. This ensures that functions using the\n     *      calldata object normally will be using the same data as the assembly\n     *      functions. Note that no parameters are supplied as all basic order\n     *      functions use the same calldata encoding.\n     */\n    function _assertValidBasicOrderParameterOffsets() internal pure {\n        // Declare a boolean designating basic order parameter offset validity.\n        bool validOffsets;\n\n        // Utilize assembly in order to read offset data directly from calldata.\n        assembly {\n            /*\n             * Checks:\n             * 1. Order parameters struct offset == 0x20\n             * 2. Additional recipients arr offset == 0x240\n             * 3. Signature offset == 0x260 + (recipients.length * 0x40)\n             */\n            validOffsets := and(\n                // Order parameters at calldata 0x04 must have offset of 0x20.\n                eq(\n                    calldataload(BasicOrder_parameters_cdPtr),\n                    BasicOrder_parameters_ptr\n                ),\n                // Additional recipients at cd 0x224 must have offset of 0x240.\n                eq(\n                    calldataload(BasicOrder_additionalRecipients_head_cdPtr),\n                    BasicOrder_additionalRecipients_head_ptr\n                )\n            )\n            validOffsets := and(\n                validOffsets,\n                eq(\n                    // Load signature offset from calldata 0x244.\n                    calldataload(BasicOrder_signature_cdPtr),\n                    // Derive expected offset as start of recipients + len * 64.\n                    add(\n                        BasicOrder_signature_ptr,\n                        mul(\n                            // Additional recipients length at calldata 0x264.\n                            calldataload(\n                                BasicOrder_additionalRecipients_length_cdPtr\n                            ),\n                            // Each additional recipient has a length of 0x40.\n                            AdditionalRecipients_size\n                        )\n                    )\n                )\n            )\n        }\n\n        // Revert with an error if basic order parameter offsets are invalid.\n        if (!validOffsets) {\n            revert InvalidBasicOrderParameterEncoding();\n        }\n    }\n}"
    },
    {
      "filename": "libsolidity/ast/Types.cpp",
      "content": "/*\n\tThis file is part of solidity.\n\n\tsolidity is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tsolidity is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with solidity.  If not, see <http://www.gnu.org/licenses/>.\n*/\n// SPDX-License-Identifier: GPL-3.0\n/**\n * @author Christian <c@ethdev.com>\n * @date 2014\n * Solidity data types\n */\n\n#include <libsolidity/ast/Types.h>\n\n#include <libsolidity/ast/AST.h>\n#include <libsolidity/ast/TypeProvider.h>\n\n#include <libsolidity/analysis/ConstantEvaluator.h>\n\n#include <libsolutil/Algorithms.h>\n#include <libsolutil/CommonData.h>\n#include <libsolutil/CommonIO.h>\n#include <libsolutil/FunctionSelector.h>\n#include <libsolutil/Keccak256.h>\n#include <libsolutil/StringUtils.h>\n#include <libsolutil/UTF8.h>\n#include <libsolutil/Visitor.h>\n\n#include <boost/algorithm/string.hpp>\n#include <boost/algorithm/string/classification.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include <boost/algorithm/string/split.hpp>\n\n#include <range/v3/view/enumerate.hpp>\n#include <range/v3/view/reverse.hpp>\n#include <range/v3/view/tail.hpp>\n#include <range/v3/view/transform.hpp>\n\n#include <limits>\n#include <unordered_set>\n#include <utility>\n\nusing namespace std;\nusing namespace solidity;\nusing namespace solidity::langutil;\nusing namespace solidity::frontend;\n\nnamespace\n{\n\n/// Checks whether _mantissa * (10 ** _expBase10) fits into 4096 bits.\nbool fitsPrecisionBase10(bigint const& _mantissa, uint32_t _expBase10)\n{\n\tdouble const log2Of10AwayFromZero = 3.3219280948873624;\n\treturn fitsPrecisionBaseX(_mantissa, log2Of10AwayFromZero, _expBase10);\n}\n\n/// Checks whether _value fits into IntegerType _type.\nBoolResult fitsIntegerType(bigint const& _value, IntegerType const& _type)\n{\n\tif (_value < 0 && !_type.isSigned())\n\t\treturn BoolResult::err(\"Cannot implicitly convert signed literal to unsigned type.\");\n\n\tif (_type.minValue() > _value || _value > _type.maxValue())\n\t\treturn BoolResult::err(\"Literal is too large to fit in \" + _type.toString(false) + \".\");\n\n\treturn true;\n}\n\n/// Checks whether _value fits into _bits bits when having 1 bit as the sign bit\n/// if _signed is true.\nbool fitsIntoBits(bigint const& _value, unsigned _bits, bool _signed)\n{\n\treturn fitsIntegerType(\n\t\t_value,\n\t\t*TypeProvider::integer(\n\t\t\t_bits,\n\t\t\t_signed ? IntegerType::Modifier::Signed : IntegerType::Modifier::Unsigned\n\t\t)\n\t);\n}\n\nutil::Result<TypePointers> transformParametersToExternal(TypePointers const& _parameters, bool _inLibrary)\n{\n\tTypePointers transformed;\n\n\tfor (auto const& type: _parameters)\n\t{\n\t\tif (!type)\n\t\t\treturn util::Result<TypePointers>::err(\"Type information not present.\");\n\t\telse if (Type const* ext = type->interfaceType(_inLibrary).get())\n\t\t\ttransformed.push_back(ext);\n\t\telse\n\t\t\treturn util::Result<TypePointers>::err(\"Parameter should have external type.\");\n\t}\n\n\treturn transformed;\n}\n\n}\n\nMemberList::Member::Member(Declaration const* _declaration, Type const* _type):\n\tMember(_declaration, _type, _declaration->name())\n{}\n\nMemberList::Member::Member(Declaration const* _declaration, Type const* _type, string _name):\n\tname(move(_name)),\n\ttype(_type),\n\tdeclaration(_declaration)\n{\n}\n\nvoid Type::clearCache() const\n{\n\tm_members.clear();\n\tm_stackItems.reset();\n\tm_stackSize.reset();\n}\n\nvoid StorageOffsets::computeOffsets(TypePointers const& _types)\n{\n\tbigint slotOffset = 0;\n\tunsigned byteOffset = 0;\n\tmap<size_t, pair<u256, unsigned>> offsets;\n\tfor (size_t i = 0; i < _types.size(); ++i)\n\t{\n\t\tType const* type = _types[i];\n\t\tif (!type->canBeStored())\n\t\t\tcontinue;\n\t\tif (byteOffset + type->storageBytes() > 32)\n\t\t{\n\t\t\t// would overflow, go to next slot\n\t\t\t++slotOffset;\n\t\t\tbyteOffset = 0;\n\t\t}\n\t\tsolAssert(slotOffset < bigint(1) << 256 ,\"Object too large for storage.\");\n\t\toffsets[i] = make_pair(u256(slotOffset), byteOffset);\n\t\tsolAssert(type->storageSize() >= 1, \"Invalid storage size.\");\n\t\tif (type->storageSize() == 1 && byteOffset + type->storageBytes() <= 32)\n\t\t\tbyteOffset += type->storageBytes();\n\t\telse\n\t\t{\n\t\t\tslotOffset += type->storageSize();\n\t\t\tbyteOffset = 0;\n\t\t}\n\t}\n\tif (byteOffset > 0)\n\t\t++slotOffset;\n\tsolAssert(slotOffset < bigint(1) << 256, \"Object too large for storage.\");\n\tm_storageSize = u256(slotOffset);\n\tswap(m_offsets, offsets);\n}\n\npair<u256, unsigned> const* StorageOffsets::offset(size_t _index) const\n{\n\tif (m_offsets.count(_index))\n\t\treturn &m_offsets.at(_index);\n\telse\n\t\treturn nullptr;\n}\n\nvoid MemberList::combine(MemberList const & _other)\n{\n\tm_memberTypes += _other.m_memberTypes;\n}\n\npair<u256, unsigned> const* MemberList::memberStorageOffset(string const& _name) const\n{\n\tStorageOffsets const& offsets = storageOffsets();\n\n\tfor (auto&& [index, member]: m_memberTypes | ranges::views::enumerate)\n\t\tif (member.name == _name)\n\t\t\treturn offsets.offset(index);\n\treturn nullptr;\n}\n\nu256 const& MemberList::storageSize() const\n{\n\treturn storageOffsets().storageSize();\n}\n\nStorageOffsets const& MemberList::storageOffsets() const {\n\treturn m_storageOffsets.init([&]{\n\t\tTypePointers memberTypes;\n\t\tmemberTypes.reserve(m_memberTypes.size());\n\t\tfor (auto const& member: m_memberTypes)\n\t\t\tmemberTypes.push_back(member.type);\n\n\t\tStorageOffsets storageOffsets;\n\t\tstorageOffsets.computeOffsets(memberTypes);\n\n\t\treturn storageOffsets;\n\t});\n}\n\n/// Helper functions for type identifier\nnamespace\n{\n\nstring parenthesizeIdentifier(string const& _internal)\n{\n\treturn \"(\" + _internal + \")\";\n}\n\ntemplate <class Range>\nstring identifierList(Range const&& _list)\n{\n\treturn parenthesizeIdentifier(boost::algorithm::join(_list, \",\"));\n}\n\nstring richIdentifier(Type const* _type)\n{\n\treturn _type ? _type->richIdentifier() : \"\";\n}\n\nstring identifierList(vector<Type const*> const& _list)\n{\n\treturn identifierList(_list | ranges::views::transform(richIdentifier));\n}\n\nstring identifierList(Type const* _type)\n{\n\treturn parenthesizeIdentifier(richIdentifier(_type));\n}\n\nstring identifierList(Type const* _type1, Type const* _type2)\n{\n\tTypePointers list;\n\tlist.push_back(_type1);\n\tlist.push_back(_type2);\n\treturn identifierList(list);\n}\n\nstring parenthesizeUserIdentifier(string const& _internal)\n{\n\treturn parenthesizeIdentifier(_internal);\n}\n\n}\n\nstring Type::escapeIdentifier(string const& _identifier)\n{\n\tstring ret = _identifier;\n\t// FIXME: should be _$$$_\n\tboost::algorithm::replace_all(ret, \"$\", \"$$$\");\n\tboost::algorithm::replace_all(ret, \",\", \"_$_\");\n\tboost::algorithm::replace_all(ret, \"(\", \"$_\");\n\tboost::algorithm::replace_all(ret, \")\", \"_$\");\n\treturn ret;\n}\n\nstring Type::identifier() const\n{\n\tstring ret = escapeIdentifier(richIdentifier());\n\tsolAssert(ret.find_first_of(\"0123456789\") != 0, \"Identifier cannot start with a number.\");\n\tsolAssert(\n\t\tret.find_first_not_of(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMONPQRSTUVWXYZ_$\") == string::npos,\n\t\t\"Identifier contains invalid characters.\"\n\t);\n\treturn ret;\n}\n\nType const* Type::commonType(Type const* _a, Type const* _b)\n{\n\tif (!_a || !_b)\n\t\treturn nullptr;\n\telse if (_a->mobileType() && _b->isImplicitlyConvertibleTo(*_a->mobileType()))\n\t\treturn _a->mobileType();\n\telse if (_b->mobileType() && _a->isImplicitlyConvertibleTo(*_b->mobileType()))\n\t\treturn _b->mobileType();\n\telse\n\t\treturn nullptr;\n}\n\nMemberList const& Type::members(ASTNode const* _currentScope) const\n{\n\tif (!m_members[_currentScope])\n\t{\n\t\tsolAssert(\n\t\t\t_currentScope == nullptr ||\n\t\t\tdynamic_cast<SourceUnit const*>(_currentScope) ||\n\t\t\tdynamic_cast<ContractDefinition const*>(_currentScope),\n\t\t\"\");\n\t\tMemberList::MemberMap members = nativeMembers(_currentScope);\n\t\tif (_currentScope)\n\t\t\tmembers += boundFunctions(*this, *_currentScope);\n\t\tm_members[_currentScope] = make_unique<MemberList>(move(members));\n\t}\n\treturn *m_members[_currentScope];\n}\n\nType const* Type::fullEncodingType(bool _inLibraryCall, bool _encoderV2, bool) const\n{\n\tType const* encodingType = mobileType();\n\tif (encodingType)\n\t\tencodingType = encodingType->interfaceType(_inLibraryCall);\n\tif (encodingType)\n\t\tencodingType = encodingType->encodingType();\n\t// Structs are fine in the following circumstances:\n\t// - ABIv2 or,\n\t// - storage struct for a library\n\tif (_inLibraryCall && encodingType && encodingType->dataStoredIn(DataLocation::Storage))\n\t\treturn encodingType;\n\tType const* baseType = encodingType;\n\twhile (auto const* arrayType = dynamic_cast<ArrayType const*>(baseType))\n\t{\n\t\tbaseType = arrayType->baseType();\n\n\t\tauto const* baseArrayType = dynamic_cast<ArrayType const*>(baseType);\n\t\tif (!_encoderV2 && baseArrayType && baseArrayType->isDynamicallySized())\n\t\t\treturn nullptr;\n\t}\n\tif (!_encoderV2 && dynamic_cast<StructType const*>(baseType))\n\t\treturn nullptr;\n\n\treturn encodingType;\n}\n\nMemberList::MemberMap Type::boundFunctions(Type const& _type, ASTNode const& _scope)\n{\n\tvector<UsingForDirective const*> usingForDirectives;\n\tSourceUnit const* sourceUnit = dynamic_cast<SourceUnit const*>(&_scope);\n\tif (auto const* contract = dynamic_cast<ContractDefinition const*>(&_scope))\n\t{\n\t\tsourceUnit = &contract->sourceUnit();\n\t\tusingForDirectives += contract->usingForDirectives();\n\t}\n\telse\n\t\tsolAssert(sourceUnit, \"\");\n\tusingForDirectives += ASTNode::filteredNodes<UsingForDirective>(sourceUnit->nodes());\n\n\tif (Declaration const* typeDefinition = _type.typeDefinition())\n\t\tif (auto const* sourceUnit = dynamic_cast<SourceUnit const*>(typeDefinition->scope()))\n\t\t\tfor (auto usingFor: ASTNode::filteredNodes<UsingForDirective>(sourceUnit->nodes()))\n\t\t\t\t// We do not yet compare the type name because of normalization.\n\t\t\t\tif (usingFor->global() && usingFor->typeName())\n\t\t\t\t\tusingForDirectives.emplace_back(usingFor);\n\n\t// Normalise data location of type.\n\tDataLocation typeLocation = DataLocation::Storage;\n\tif (auto refType = dynamic_cast<ReferenceType const*>(&_type))\n\t\ttypeLocation = refType->location();\n\n\tMemberList::MemberMap members;\n\n\tset<pair<string, Declaration const*>> seenFunctions;\n\tauto addFunction = [&](FunctionDefinition const& _function, optional<string> _name = {})\n\t{\n\t\tif (!_name)\n\t\t\t_name = _function.name();\n\t\tType const* functionType =\n\t\t\t_function.libraryFunction() ? _function.typeViaContractName() : _function.type();\n\t\tsolAssert(functionType, \"\");\n\t\tFunctionType const* asBoundFunction =\n\t\t\tdynamic_cast<FunctionType const&>(*functionType).asBoundFunction();\n\t\tsolAssert(asBoundFunction, \"\");\n\n\t\tif (_type.isImplicitlyConvertibleTo(*asBoundFunction->selfType()))\n\t\t\tif (seenFunctions.insert(make_pair(*_name, &_function)).second)\n\t\t\t\tmembers.emplace_back(&_function, asBoundFunction, *_name);\n\t};\n\n\tfor (UsingForDirective const* ufd: usingForDirectives)\n\t{\n\t\t// Convert both types to pointers for comparison to see if the `using for`\n\t\t// directive applies.\n\t\t// Further down, we check more detailed for each function if `_type` is\n\t\t// convertible to the function parameter type.\n\t\tif (\n\t\t\tufd->typeName() &&\n\t\t\t*TypeProvider::withLocationIfReference(typeLocation, &_type, true) !=\n\t\t\t*TypeProvider::withLocationIfReference(\n\t\t\t\ttypeLocation,\n\t\t\t\tufd->typeName()->annotation().type,\n\t\t\t\ttrue\n\t\t\t)\n\t\t)\n\t\t\tcontinue;\n\n\t\tfor (auto const& pathPointer: ufd->functionsOrLibrary())\n\t\t{\n\t\t\tsolAssert(pathPointer);\n\t\t\tDeclaration const* declaration = pathPointer->annotation().referencedDeclaration;\n\t\t\tsolAssert(declaration);\n\n\t\t\tif (ContractDefinition const* library = dynamic_cast<ContractDefinition const*>(declaration))\n\t\t\t{\n\t\t\t\tsolAssert(library->isLibrary());\n\t\t\t\tfor (FunctionDefinition const* function: library->definedFunctions())\n\t\t\t\t{\n\t\t\t\t\tif (!function->isOrdinary() || !function->isVisibleAsLibraryMember() || function->parameters().empty())\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\taddFunction(*function);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\taddFunction(\n\t\t\t\t\tdynamic_cast<FunctionDefinition const&>(*declaration),\n\t\t\t\t\tpathPointer->path().back()\n\t\t\t\t);\n\t\t}\n\t}\n\n\treturn members;\n}\n\nAddressType::AddressType(StateMutability _stateMutability):\n\tm_stateMutability(_stateMutability)\n{\n\tsolAssert(m_stateMutability == StateMutability::Payable || m_stateMutability == StateMutability::NonPayable, \"\");\n}\n\nstring AddressType::richIdentifier() const\n{\n\tif (m_stateMutability == StateMutability::Payable)\n\t\treturn \"t_address_payable\";\n\telse\n\t\treturn \"t_address\";\n}\n\nBoolResult AddressType::isImplicitlyConvertibleTo(Type const& _other) const\n{\n\tif (_other.category() != category())\n\t\treturn false;\n\tAddressType const& other = dynamic_cast<AddressType const&>(_other);\n\n\treturn other.m_stateMutability <= m_stateMutability;\n}\n\nBoolResult AddressType::isExplicitlyConvertibleTo(Type const& _convertTo) const\n{\n\tif ((_convertTo.category() == category()) || isImplicitlyConvertibleTo(_convertTo))\n\t\treturn true;\n\telse if (auto const* contractType = dynamic_cast<ContractType const*>(&_convertTo))\n\t\treturn (m_stateMutability >= StateMutability::Payable) || !contractType->isPayable();\n\telse if (m_stateMutability == StateMutability::NonPayable)\n\t{\n\t\tif (auto integerType = dynamic_cast<IntegerType const*>(&_convertTo))\n\t\t\treturn (!integerType->isSigned() && integerType->numBits() == 160);\n\t\telse if (auto fixedBytesType = dynamic_cast<FixedBytesType const*>(&_convertTo))\n\t\t\treturn (fixedBytesType->numBytes() == 20);\n\t}\n\n\treturn false;\n}\n\nstring AddressType::toString(bool) const\n{\n\tif (m_stateMutability == StateMutability::Payable)\n\t\treturn \"address payable\";\n\telse\n\t\treturn \"address\";\n}\n\nstring AddressType::canonicalName() const\n{\n\treturn \"address\";\n}\n\nu256 AddressType::literalValue(Literal const* _literal) const\n{\n\tsolAssert(_literal, \"\");\n\tsolAssert(_literal->value().substr(0, 2) == \"0x\", \"\");\n\treturn u256(_literal->valueWithoutUnderscores());\n}\n\nTypeResult AddressType::unaryOperatorResult(Token _operator) const\n{\n\treturn _operator == Token::Delete ? TypeProvider::emptyTuple() : nullptr;\n}\n\n\nTypeResult AddressType::binaryOperatorResult(Token _operator, Type const* _other) const\n{\n\tif (!TokenTraits::isCompareOp(_operator))\n\t\treturn TypeResult::err(\"Arithmetic operations on addresses are not supported. Convert to integer first before using them.\");\n\n\treturn Type::commonType(this, _other);\n}\n\nbool AddressType::operator==(Type const& _other) const\n{\n\tif (_other.category() != category())\n\t\treturn false;\n\tAddressType const& other = dynamic_cast<AddressType const&>(_other);\n\treturn other.m_stateMutability == m_stateMutability;\n}\n\nMemberList::MemberMap AddressType::nativeMembers(ASTNode const*) const\n{\n\tMemberList::MemberMap members = {\n\t\t{\"balance\", TypeProvider::uint256()},\n\t\t{\"code\", TypeProvider::array(DataLocation::Memory)},\n\t\t{\"codehash\",  TypeProvider::fixedBytes(32)},\n\t\t{\"call\", TypeProvider::function(strings{\"bytes memory\"}, strings{\"bool\", \"bytes memory\"}, FunctionType::Kind::BareCall, StateMutability::Payable)},\n\t\t{\"callcode\", TypeProvider::function(strings{\"bytes memory\"}, strings{\"bool\", \"bytes memory\"}, FunctionType::Kind::BareCallCode, StateMutability::Payable)},\n\t\t{\"delegatecall\", TypeProvider::function(strings{\"bytes memory\"}, strings{\"bool\", \"bytes memory\"}, FunctionType::Kind::BareDelegateCall, StateMutability::NonPayable)},\n\t\t{\"staticcall\", TypeProvider::function(strings{\"bytes memory\"}, strings{\"bool\", \"bytes memory\"}, FunctionType::Kind::BareStaticCall, StateMutability::View)}\n\t};\n\tif (m_stateMutability == StateMutability::Payable)\n\t{\n\t\tmembers.emplace_back(MemberList::Member{\"send\", TypeProvider::function(strings{\"uint\"}, strings{\"bool\"}, FunctionType::Kind::Send, StateMutability::NonPayable)});\n\t\tmembers.emplace_back(MemberList::Member{\"transfer\", TypeProvider::function(strings{\"uint\"}, strings(), FunctionType::Kind::Transfer, StateMutability::NonPayable)});\n\t}\n\treturn members;\n}\n\nnamespace\n{\n\nbool isValidShiftAndAmountType(Token _operator, Type const& _shiftAmountType)\n{\n\t// Disable >>> here.\n\tif (_operator == Token::SHR)\n\t\treturn false;\n\telse if (IntegerType const* otherInt = dynamic_cast<decltype(otherInt)>(&_shiftAmountType))\n\t\treturn !otherInt->isSigned();\n\telse if (RationalNumberType const* otherRat = dynamic_cast<decltype(otherRat)>(&_shiftAmountType))\n\t\treturn !otherRat->isFractional() && otherRat->integerType() && !otherRat->integerType()->isSigned();\n\telse\n\t\treturn false;\n}\n\n}\n\nIntegerType::IntegerType(unsigned _bits, IntegerType::Modifier _modifier):\n\tm_bits(_bits), m_modifier(_modifier)\n{\n\tsolAssert(\n\t\tm_bits > 0 && m_bits <= 256 && m_bits % 8 == 0,\n\t\t\"Invalid bit number for integer type: \" + util::toString(m_bits)\n\t);\n}\n\nstring IntegerType::richIdentifier() const\n{\n\treturn \"t_\" + string(isSigned() ? \"\" : \"u\") + \"int\" + to_string(numBits());\n}\n\nBoolResult IntegerType::isImplicitlyConvertibleTo(Type const& _convertTo) const\n{\n\tif (_convertTo.category() == category())\n\t{\n\t\tIntegerType const& convertTo = dynamic_cast<IntegerType const&>(_convertTo);\n\t\t// disallowing unsigned to signed conversion of different bits\n\t\tif (isSigned() != convertTo.isSigned())\n\t\t\treturn false;\n\t\telse if (convertTo.m_bits < m_bits)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\telse if (_convertTo.category() == Category::FixedPoint)\n\t{\n\t\tFixedPointType const& convertTo = dynamic_cast<FixedPointType const&>(_convertTo);\n\t\treturn maxValue() <= convertTo.maxIntegerValue() && minValue() >= convertTo.minIntegerValue();\n\t}\n\telse\n\t\treturn false;\n}\n\nBoolResult IntegerType::isExplicitlyConvertibleTo(Type const& _convertTo) const\n{\n\tif (isImplicitlyConvertibleTo(_convertTo))\n\t\treturn true;\n\telse if (auto integerType = dynamic_cast<IntegerType const*>(&_convertTo))\n\t\treturn (numBits() == integerType->numBits()) || (isSigned() == integerType->isSigned());\n\telse if (auto addressType = dynamic_cast<AddressType const*>(&_convertTo))\n\t\treturn\n\t\t\t(addressType->stateMutability() != StateMutability::Payable) &&\n\t\t\t!isSigned() &&\n\t\t\t(numBits() == 160);\n\telse if (auto fixedBytesType = dynamic_cast<FixedBytesType const*>(&_convertTo))\n\t\treturn (!isSigned() && (numBits() == fixedBytesType->numBytes() * 8));\n\telse if (dynamic_cast<EnumType const*>(&_convertTo))\n\t\treturn true;\n\telse if (auto fixedPointType = dynamic_cast<FixedPointType const*>(&_convertTo))\n\t\treturn (isSigned() == fixedPointType->isSigned()) && (numBits() == fixedPointType->numBits());\n\n\treturn false;\n}\n\nTypeResult IntegerType::unaryOperatorResult(Token _operator) const\n{\n\t// \"delete\" is ok for all integer types\n\tif (_operator == Token::Delete)\n\t\treturn TypeResult{TypeProvider::emptyTuple()};\n\t// unary negation only on signed types\n\telse if (_operator == Token::Sub)\n\t\treturn isSigned() ? TypeResult{this} : TypeResult::err(\"Unary negation is only allowed for signed integers.\");\n\telse if (_operator == Token::Inc || _operator == Token::Dec || _operator == Token::BitNot)\n\t\treturn TypeResult{this};\n\telse\n\t\treturn TypeResult::err(\"\");\n}\n\nbool IntegerType::operator==(Type const& _other) const\n{\n\tif (_other.category() != category())\n\t\treturn false;\n\tIntegerType const& other = dynamic_cast<IntegerType const&>(_other);\n\treturn other.m_bits == m_bits && other.m_modifier == m_modifier;\n}\n\nstring IntegerType::toString(bool) const\n{\n\tstring prefix = isSigned() ? \"int\" : \"uint\";\n\treturn prefix + util::toString(m_bits);\n}\n\nu256 IntegerType::min() const\n{\n\tif (isSigned())\n\t\treturn s2u(s256(minValue()));\n\telse\n\t\treturn u256(minValue());\n}\n\nu256 IntegerType::max() const\n{\n\tif (isSigned())\n\t\treturn s2u(s256(maxValue()));\n\telse\n\t\treturn u256(maxValue());\n}\n\nbigint IntegerType::minValue() const\n{\n\tif (isSigned())\n\t\treturn -(bigint(1) << (m_bits - 1));\n\telse\n\t\treturn bigint(0);\n}\n\nbigint IntegerType::maxValue() const\n{\n\tif (isSigned())\n\t\treturn (bigint(1) << (m_bits - 1)) - 1;\n\telse\n\t\treturn (bigint(1) << m_bits) - 1;\n}\n\nTypeResult IntegerType::binaryOperatorResult(Token _operator, Type const* _other) const\n{\n\tif (\n\t\t_other->category() != Category::RationalNumber &&\n\t\t_other->category() != Category::FixedPoint &&\n\t\t_other->category() != category()\n\t)\n\t\treturn nullptr;\n\tif (TokenTraits::isShiftOp(_operator))\n\t{\n\t\t// Shifts are not symmetric with respect to the type\n\t\tif (isValidShiftAndAmountType(_operator, *_other))\n\t\t\treturn this;\n\t\telse\n\t\t\treturn nullptr;\n\t}\n\telse if (Token::Exp == _operator)\n\t{\n\t\tif (auto otherIntType = dynamic_cast<IntegerType const*>(_other))\n\t\t{\n\t\t\tif (otherIntType->isSigned())\n\t\t\t\treturn TypeResult::err(\"Exponentiation power is not allowed to be a signed integer type.\");\n\t\t}\n\t\telse if (dynamic_cast<FixedPointType const*>(_other))\n\t\t\treturn nullptr;\n\t\telse if (auto rationalNumberType = dynamic_cast<RationalNumberType const*>(_other))\n\t\t{\n\t\t\tif (rationalNumberType->isFractional())\n\t\t\t\treturn TypeResult::err(\"Exponent is fractional.\");\n\t\t\tif (!rationalNumberType->integerType())\n\t\t\t\treturn TypeResult::err(\"Exponent too large.\");\n\t\t\tif (rationalNumberType->isNegative())\n\t\t\t\treturn TypeResult::err(\"Exponentiation power is not allowed to be a negative integer literal.\");\n\t\t}\n\t\treturn this;\n\t}\n\n\tauto commonType = Type::commonType(this, _other); //might be an integer or fixed point\n\tif (!commonType)\n\t\treturn nullptr;\n\n\t// All integer types can be compared\n\tif (TokenTraits::isCompareOp(_operator))\n\t\treturn commonType;\n\tif (TokenTraits::isBooleanOp(_operator))\n\t\treturn nullptr;\n\treturn commonType;\n}\n\nFixedPointType::FixedPointType(unsigned _totalBits, unsigned _fractionalDigits, FixedPointType::Modifier _modifier):\n\tm_totalBits(_totalBits), m_fractionalDigits(_fractionalDigits), m_modifier(_modifier)\n{\n\tsolAssert(\n\t\t8 <= m_totalBits && m_totalBits <= 256 && m_totalBits % 8 == 0 && m_fractionalDigits <= 80,\n\t\t\"Invalid bit number(s) for fixed type: \" +\n\t\tutil::toString(_totalBits) + \"x\" + util::toString(_fractionalDigits)\n\t);\n}\n\nstring FixedPointType::richIdentifier() const\n{\n\treturn \"t_\" + string(isSigned() ? \"\" : \"u\") + \"fixed\" + to_string(m_totalBits) + \"x\" + to_string(m_fractionalDigits);\n}\n\nBoolResult FixedPointType::isImplicitlyConvertibleTo(Type const& _convertTo) const\n{\n\tif (_convertTo.category() == category())\n\t{\n\t\tFixedPointType const& convertTo = dynamic_cast<FixedPointType const&>(_convertTo);\n\t\tif (convertTo.fractionalDigits() < m_fractionalDigits)\n\t\t\treturn BoolResult::err(\"Too many fractional digits.\");\n\t\tif (convertTo.numBits() < m_totalBits)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn convertTo.maxIntegerValue() >= maxIntegerValue() && convertTo.minIntegerValue() <= minIntegerValue();\n\t}\n\treturn false;\n}\n\nBoolResult FixedPointType::isExplicitlyConvertibleTo(Type const& _convertTo) const\n{\n\treturn _convertTo.category() == category() || _convertTo.category() == Category::Integer;\n}\n\nTypeResult FixedPointType::unaryOperatorResult(Token _operator) const\n{\n\tswitch (_operator)\n\t{\n\tcase Token::Delete:\n\t\t// \"delete\" is ok for all fixed types\n\t\treturn TypeResult{TypeProvider::emptyTuple()};\n\tcase Token::Add:\n\tcase Token::Sub:\n\tcase Token::Inc:\n\tcase Token::Dec:\n\t\t// for fixed, we allow +, -, ++ and --\n\t\treturn this;\n\tdefault:\n\t\treturn nullptr;\n\t}\n}\n\nbool FixedPointType::operator==(Type const& _other) const\n{\n\tif (_other.category() != category())\n\t\treturn false;\n\tFixedPointType const& other = dynamic_cast<FixedPointType const&>(_other);\n\treturn other.m_totalBits == m_totalBits && other.m_fractionalDigits == m_fractionalDigits && other.m_modifier == m_modifier;\n}\n\nstring FixedPointType::toString(bool) const\n{\n\tstring prefix = isSigned() ? \"fixed\" : \"ufixed\";\n\treturn prefix + util::toString(m_totalBits) + \"x\" + util::toString(m_fractionalDigits);\n}\n\nbigint FixedPointType::maxIntegerValue() const\n{\n\tbigint maxValue = (bigint(1) << (m_totalBits - (isSigned() ? 1 : 0))) - 1;\n\treturn maxValue / boost::multiprecision::pow(bigint(10), m_fractionalDigits);\n}\n\nbigint FixedPointType::minIntegerValue() const\n{\n\tif (isSigned())\n\t{\n\t\tbigint minValue = -(bigint(1) << (m_totalBits - (isSigned() ? 1 : 0)));\n\t\treturn minValue / boost::multiprecision::pow(bigint(10), m_fractionalDigits);\n\t}\n\telse\n\t\treturn bigint(0);\n}\n\nTypeResult FixedPointType::binaryOperatorResult(Token _operator, Type const* _other) const\n{\n\tauto commonType = Type::commonType(this, _other);\n\n\tif (!commonType)\n\t\treturn nullptr;\n\n\t// All fixed types can be compared\n\tif (TokenTraits::isCompareOp(_operator))\n\t\treturn commonType;\n\tif (TokenTraits::isBitOp(_operator) || TokenTraits::isBooleanOp(_operator) || _operator == Token::Exp)\n\t\treturn nullptr;\n\treturn commonType;\n}\n\nIntegerType const* FixedPointType::asIntegerType() const\n{\n\treturn TypeProvider::integer(numBits(), isSigned() ? IntegerType::Modifier::Signed : IntegerType::Modifier::Unsigned);\n}\n\ntuple<bool, rational> RationalNumberType::parseRational(string const& _value)\n{\n\trational value;\n\ttry\n\t{\n\t\tauto radixPoint = find(_value.begin(), _value.end(), '.');\n\n\t\tif (radixPoint != _value.end())\n\t\t{\n\t\t\tif (\n\t\t\t\t!all_of(radixPoint + 1, _value.end(), util::isDigit) ||\n\t\t\t\t!all_of(_value.begin(), radixPoint, util::isDigit)\n\t\t\t)\n\t\t\t\treturn make_tuple(false, rational(0));\n\n\t\t\t// Only decimal notation allowed here, leading zeros would switch to octal.\n\t\t\tauto fractionalBegin = find_if_not(\n\t\t\t\tradixPoint + 1,\n\t\t\t\t_value.end(),\n\t\t\t\t[](char const& a) { return a == '0'; }\n\t\t\t);\n\n\t\t\trational numerator;\n\t\t\trational denominator(1);\n\n\t\t\tdenominator = bigint(string(fractionalBegin, _value.end()));\n\t\t\tdenominator /= boost::multiprecision::pow(\n\t\t\t\tbigint(10),\n\t\t\t\tstatic_cast<unsigned>(distance(radixPoint + 1, _value.end()))\n\t\t\t);\n\t\t\tnumerator = bigint(string(_value.begin(), radixPoint));\n\t\t\tvalue = numerator + denominator;\n\t\t}\n\t\telse\n\t\t\tvalue = bigint(_value);\n\t\treturn make_tuple(true, value);\n\t}\n\tcatch (...)\n\t{\n\t\treturn make_tuple(false, rational(0));\n\t}\n}\n\ntuple<bool, rational> RationalNumberType::isValidLiteral(Literal const& _literal)\n{\n\trational value;\n\ttry\n\t{\n\t\tASTString valueString = _literal.valueWithoutUnderscores();\n\n\t\tauto expPoint = find(valueString.begin(), valueString.end(), 'e');\n\t\tif (expPoint == valueString.end())\n\t\t\texpPoint = find(valueString.begin(), valueString.end(), 'E');\n\n\t\tif (boost::starts_with(valueString, \"0x\"))\n\t\t{\n\t\t\t// process as hex\n\t\t\tvalue = bigint(valueString);\n\t\t}\n\t\telse if (expPoint != valueString.end())\n\t\t{\n\t\t\t// Parse mantissa and exponent. Checks numeric limit.\n\t\t\ttuple<bool, rational> mantissa = parseRational(string(valueString.begin(), expPoint));\n\n\t\t\tif (!get<0>(mantissa))\n\t\t\t\treturn make_tuple(false, rational(0));\n\t\t\tvalue = get<1>(mantissa);\n\n\t\t\t// 0E... is always zero.\n\t\t\tif (value == 0)\n\t\t\t\treturn make_tuple(true, rational(0));\n\n\t\t\tbigint exp = bigint(string(expPoint + 1, valueString.end()));\n\n\t\t\tif (exp > numeric_limits<int32_t>::max() || exp < numeric"
    }
  ]
}