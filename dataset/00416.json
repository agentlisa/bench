{
  "Title": "H-12: TOFTOptionsReceiverModule will have the user lose the whole output TAP when requested to exercise all eligible options",
  "Content": "# Issue H-12: TOFTOptionsReceiverModule will have the user lose the whole output TAP when requested to exercise all eligible options \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/130 \n\n## Found by \nctf\\_sec, hyh\n## Summary\n\nTOFTOptionsReceiverModule's `exerciseOptionsReceiver()` will execute successfully, but lose (freeze permanently) all the output TAP amount of the user if being run with zero TAP amount (`_options.tapAmount`), which is valid use case of TapiocaOptionBroker's `exerciseOption()`, corresponding to the full position exercise.\n\n## Vulnerability Detail\n\nSpecifying zero tap amount is a usual workflow of TapiocaOptionBroker's `exerciseOption()`, meaning that the whole eligible option position should be exercised. It's arguably the most used way to interact with `exerciseOption()` since slicing the exercise doesn't provide any additional benefits, but increases the operational and gas costs.\n\n`exerciseOptionsReceiver()` will not revert when run with `_options.tapAmount = 0`, it will exercise the full position, but send nothing to the user: the whole TAP amount received will be left with the contract, being permanently frozen there as there is no way to rescue it.\n\n## Impact\n\nThe probability of having `exerciseOptionsReceiver()` run with `_options.tapAmount = 0` can be estimated as medium. The impact of user losing the whole position TAP proceedings, being permanently frozen with the contract, has high severity.\n\nLikelihood: Medium + Impact: High = Severity: High.\n\n## Code Snippet\n\n`_options.tapAmount == 0` is an allowed state for `exerciseOptionsReceiver()`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol#L142-L181\n\n```solidity\n    function exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n        // Decode received message.\n        ExerciseOptionsMsg memory msg_ = TOFTMsgCodec.decodeExerciseOptionsMsg(_data);\n\n        _checkWhitelistStatus(msg_.optionsData.target);\n        _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to));\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n>>          _options.tapAmount = _toLD(_options.tapAmount.toUint64());\n            _options.paymentTokenAmount = _toLD(_options.paymentTokenAmount.toUint64());\n\n            // @dev retrieve paymentToken amount\n            _internalTransferWithAllowance(_options.from, srcChainSender, _options.paymentTokenAmount);\n\n            /// Does this: _approve(address(this), _options.target, _options.paymentTokenAmount);\n            pearlmit.approve(\n                address(this), 0, _options.target, uint200(_options.paymentTokenAmount), uint48(block.timestamp + 1)\n            ); // Atomic approval\n            address(this).safeApprove(address(pearlmit), _options.paymentTokenAmount);\n\n            /// @dev call exerciseOption() with address(this) as the payment token\n            uint256 bBefore = balanceOf(address(this));\n            ITapiocaOptionBroker(_options.target).exerciseOption(\n                _options.oTAPTokenID,\n                address(this), //payment token\n>>              _options.tapAmount\n            );\n            address(this).safeApprove(address(pearlmit), 0); // Clear approval\n            uint256 bAfter = balanceOf(address(this));\n\n            // Refund if less was used.\n            if (bBefore > bAfter) {\n                uint256 diff = bBefore - bAfter;\n                if (diff < _options.paymentTokenAmount) {\n                    IERC20(address(this)).safeTransfer(_options.from, _options.paymentTokenAmount - diff);\n                }\n            }\n        }\n```\n\n\nIt corresponds to a situation of exercising for the whole eligible TAP amount in TapiocaOptionBroker's `exerciseOption()`:\n\nhttps://github.com/Tapioca-DAO/tap-token/blob/main/contracts/options/TapiocaOptionBroker.sol#L390-L402\n\n```solidity\n        uint256 eligibleTapAmount = muldiv(tOLPLockPosition.ybShares, gaugeTotalForEpoch, netAmount);\n        eligibleTapAmount -= oTAPCalls[_oTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        if (eligibleTapAmount < _tapAmount) revert TooHigh();\n\n>>      uint256 chosenAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (chosenAmount < 1e18) revert TooLow();\n        oTAPCalls[_oTAPTokenID][cachedEpoch] += chosenAmount; // Adds up exercised amount to current epoch\n\n        // Finalize the deal\n>>      _processOTCDeal(_paymentToken, paymentTokenOracle, chosenAmount, oTAPPosition.discount);\n\n        emit ExerciseOption(cachedEpoch, msg.sender, _paymentToken, _oTAPTokenID, chosenAmount);\n    }\n\n```\n\nBut `exerciseOptionsReceiver()` will send out nothing in this case, the whole TAP amount received will be left with the contract instead of being forwarded to the user:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol#L183-L207\n\n```solidity\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            SendParam memory _send = msg_.lzSendParams.sendParam;\n\n            address tapOft = ITapiocaOptionBroker(_options.target).tapOFT();\n            if (msg_.withdrawOnOtherChain) {\n                /// @dev determine the right amount to send back to source\n>>              uint256 amountToSend = _send.amountLD > _options.tapAmount ? _options.tapAmount : _send.amountLD;\n                if (_send.minAmountLD > amountToSend) {\n                    _send.minAmountLD = amountToSend;\n                }\n\n                // Sends to source and preserve source `msg.sender` (`from` in this case).\n                _sendPacket(msg_.lzSendParams, msg_.composeMsg, _options.from);\n\n                // Refund extra amounts\n                if (_options.tapAmount - amountToSend > 0) {\n                    IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount - amountToSend);\n                }\n            } else {\n                //send on this chain\n>>              IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount);\n            }\n        }\n```\n\nI.e. it will be `amountToSend = _send.minAmountLD = 0` when `msg_.withdrawOnOtherChain == true` and just `_options.tapAmount = 0` otherwise, so all the TAP proceedings will stay with the contract. Since there is no possibility to receive TAP funds out of the contract in excess to the `oTAPTokenID` eligible amount, which becomes zero after exercise, these TAP proceedings will be permanently frozen on the contract balance.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider either forbidding zero `_options.tapAmount` in `exerciseOptionsReceiver()` or adding `nonReentrant` modifier to it, tracking TAP token balance and sending out the realized balance difference from TapiocaOptionBroker's `exerciseOption()` operation to the user instead of relying on `_options.tapAmount`.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/366; https://github.com/Tapioca-DAO/TapiocaZ/pull/183.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    LockAndParticipateData,\n    IMagnetar,\n    MagnetarCall,\n    MagnetarAction,\n    CrossChainMintFromBBAndLendOnSGLData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {\n    ITapiocaOptionBroker, IExerciseOptionsData\n} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {TOFTInitStruct, ExerciseOptionsMsg, LZSendParam} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {MagnetarMintXChainModule} from \"tapioca-periph/Magnetar/modules/MagnetarMintXChainModule.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {SafeApprove} from \"tapioca-periph/libraries/SafeApprove.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTOptionsReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Options module\n */\ncontract TOFTOptionsReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    error TOFTOptionsReceiverModule_NotAuthorized(address invalidAddress);\n\n    event ExerciseOptionsReceived(\n        address indexed user, address indexed target, uint256 indexed oTapTokenId, uint256 paymentTokenAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice cross-chain receiver to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     * @param _data.user the user to perform the operation for\n     * @param _data.bigBang the BB address\n     * @param _data.mintData the data needed to mint on BB\n     * @param _data.lendSendParams LZ send params for lending on another layer\n     */\n    function mintLendXChainSGLXChainLockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode received message.\n        CrossChainMintFromBBAndLendOnSGLData memory msg_ =\n            TOFTMsgCodec.decodeMintLendXChainSGLXChainLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.bigBang);\n        _checkWhitelistStatus(msg_.magnetar);\n\n        if (msg_.mintData.mintAmount > 0) {\n            msg_.mintData.mintAmount = _toLD(msg_.mintData.mintAmount.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.mintBBLendXChainSGL.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: address(this),\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Execute `magnetar.lockAndParticipate`\n     * @dev Lock on tOB and/or participate on tOLP\n     * @param _data The call data containing info about the operation.\n     * @param _data.user the user to perform the operation for\n     * @param _data.singularity the SGL address\n     * @param _data.fraction the amount to lock\n     * @param _data.lockData the data needed to lock on tOB\n     * @param _data.participateData the data needed to participate on tOLP\n     */\n    function lockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode receive message\n        LockAndParticipateData memory msg_ = TOFTMsgCodec.decodeLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.magnetar);\n        _checkWhitelistStatus(msg_.singularity);\n        if (msg_.lockData.lock) {\n            _checkWhitelistStatus(msg_.lockData.target);\n        }\n        if (msg_.participateData.participate) {\n            _checkWhitelistStatus(msg_.participateData.target);\n        }\n\n        if (msg_.fraction > 0) {\n            msg_.fraction = _toLD(msg_.fraction.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.lockAndParticipate.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: msg_.magnetar,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Exercise tOB option\n     * @param _data The call data containing info about the operation.\n     *      - optionsData::address: TapiocaOptionsBroker exercise params.\n     *      - lzSendParams::struct: LZ v2 send to source params.\n     *      - composeMsg::bytes: Further compose data.\n     */\n    function exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n        // Decode received message.\n        ExerciseOptionsMsg memory msg_ = TOFTMsgCodec.decodeExerciseOptionsMsg(_data);\n\n        _checkWhitelistStatus(msg_.optionsData.target);\n        _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to));\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            _options.tapAmount = _toLD(_options.tapAmount.toUint64());\n            _options.paymentTokenAmount = _toLD(_options.paymentTokenAmount.toUint64());\n\n            // @dev retrieve paymentToken amount\n            _internalTransferWithAllowance(_options.from, srcChainSender, _options.paymentTokenAmount);\n\n            /// Does this: _approve(address(this), _options.target, _options.paymentTokenAmount);\n            pearlmit.approve(\n                address(this), 0, _options.target, uint200(_options.paymentTokenAmount), uint48(block.timestamp + 1)\n            ); // Atomic approval\n            address(this).safeApprove(address(pearlmit), _options.paymentTokenAmount);\n\n            /// @dev call exerciseOption() with address(this) as the payment token\n            uint256 bBefore = balanceOf(address(this));\n            ITapiocaOptionBroker(_options.target).exerciseOption(\n                _options.oTAPTokenID,\n                address(this), //payment token\n                _options.tapAmount\n            );\n            address(this).safeApprove(address(pearlmit), 0); // Clear approval\n            uint256 bAfter = balanceOf(address(this));\n\n            // Refund if less was used.\n            if (bBefore > bAfter) {\n                uint256 diff = bBefore - bAfter;\n                if (diff < _options.paymentTokenAmount) {\n                    IERC20(address(this)).safeTransfer(_options.from, _options.paymentTokenAmount - diff);\n                }\n            }\n        }\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            SendParam memory _send = msg_.lzSendParams.sendParam;\n\n            address tapOft = ITapiocaOptionBroker(_options.target).tapOFT();\n            if (msg_.withdrawOnOtherChain) {\n                /// @dev determine the right amount to send back to source\n                uint256 amountToSend = _send.amountLD > _options.tapAmount ? _options.tapAmount : _send.amountLD;\n                if (_send.minAmountLD > amountToSend) {\n                    _send.minAmountLD = amountToSend;\n                }\n\n                // Sends to source and preserve source `msg.sender` (`from` in this case).\n                _sendPacket(msg_.lzSendParams, msg_.composeMsg, _options.from);\n\n                // Refund extra amounts\n                if (_options.tapAmount - amountToSend > 0) {\n                    IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount - amountToSend);\n                }\n            } else {\n                //send on this chain\n                IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount);\n            }\n        }\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTOptionsReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n\n    function _sendPacket(LZSendParam memory _lzSendParam, bytes memory _composeMsg, address _srcChainSender)\n        private\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        /// @dev Applies the token transfers regarding this send() operation.\n        // - amountDebitedLD is the amount in local decimals that was ACTUALLY debited from the sender.\n        // - amountToCreditLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        (uint256 amountDebitedLD, uint256 amountToCreditLD) =\n            _debit(_lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid);\n\n        /// @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildOFTMsgAndOptionsMemory(\n            _lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD, _srcChainSender\n        );\n\n        /// @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        /// @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD, amountToCreditLD);\n\n        emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, msg.sender, amountDebitedLD);\n    }\n    /**\n     * @dev For details about this function, check `BaseTapiocaOmnichainEngine._buildOFTMsgAndOptions()`.\n     * @dev !!!! IMPORTANT !!!! The differences are:\n     *      - memory instead of calldata for parameters.\n     *      - `_msgSender` is used instead of using context `msg.sender`, to preserve context of the OFT call and use `msg.sender` of the source chain.\n     *      - Does NOT combine options, make sure to pass valid options to cover gas costs/value transfers.\n     */\n\n    function _buildOFTMsgAndOptionsMemory(\n        SendParam memory _sendParam,\n        bytes memory _extraOptions,\n        bytes memory _composeMsg,\n        uint256 _amountToCreditLD,\n        address _msgSender\n    ) private view returns (bytes memory message, bytes memory options) {\n        bool hasCompose = _composeMsg.length > 0;\n\n        message = hasCompose\n            ? abi.encodePacked(\n                _sendParam.to, _toSD(_amountToCreditLD), OFTMsgCodec.addressToBytes32(_msgSender), _composeMsg\n            )\n            : abi.encodePacked(_sendParam.to, _toSD(_amountToCreditLD));\n        options = _extraOptions;\n\n        if (msgInspector != address(0)) {\n            IOAppMsgInspector(msgInspector).inspect(message, options);\n        }\n    }\n\n    /**\n     * @dev Performs a transfer with an allowance check and consumption against the xChain msg sender.\n     * @dev Can only transfer to this address.\n     *\n     * @param _owner The account to transfer from.\n     * @param srcChainSender The address of the sender on the source chain.\n     * @param _amount The amount to transfer\n     */\n    function _internalTransferWithAllowance(address _owner, address srcChainSender, uint256 _amount) internal {\n        if (_owner != srcChainSender) {\n            _spendAllowance(_owner, srcChainSender, _amount);\n        }\n\n        _transfer(_owner, address(this), _amount);\n    }\n}"
    },
    {
      "filename": "contracts/options/TapiocaOptionBroker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {TapiocaOptionLiquidityProvision, LockPosition, SingularityPool} from \"./TapiocaOptionLiquidityProvision.sol\";\nimport {IPearlmit, PearlmitHandler} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {TapToken} from \"contracts/tokens/TapToken.sol\";\nimport {OTAP, TapOption} from \"./oTAP.sol\";\nimport {TWAML} from \"./twAML.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nstruct Participation {\n    bool hasVotingPower;\n    bool divergenceForce; // 0 negative, 1 positive\n    uint256 averageMagnitude;\n}\n\nstruct TWAMLPool {\n    uint256 totalParticipants;\n    uint256 averageMagnitude;\n    uint256 totalDeposited;\n    uint256 cumulative;\n}\n\nstruct PaymentTokenOracle {\n    ITapiocaOracle oracle;\n    bytes oracleData;\n}\n\ncontract TapiocaOptionBroker is Pausable, Ownable, PearlmitHandler, IERC721Receiver, TWAML, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    TapiocaOptionLiquidityProvision public immutable tOLP;\n    bytes public tapOracleData;\n    TapToken public immutable tapOFT;\n    OTAP public immutable oTAP;\n    ITapiocaOracle public tapOracle;\n\n    ICluster public cluster;\n\n    uint256 public epochTAPValuation; // TAP price for the current epoch\n    uint256 public epoch; // Represents the number of weeks since the start of the contract\n\n    mapping(uint256 => Participation) public participants; // tOLPTokenID => Participation\n    mapping(uint256 => mapping(uint256 => uint256)) public oTAPCalls; // oTAPTokenID => epoch => amountExercised\n\n    mapping(uint256 => mapping(uint256 => uint256)) public singularityGauges; // epoch => sglAssetId => availableTAP\n\n    mapping(ERC20 => PaymentTokenOracle) public paymentTokens; // Token address => PaymentTokenOracle\n    address public paymentTokenBeneficiary; // Where to collect the payment tokens\n\n    /// ===== TWAML ======\n    mapping(uint256 => TWAMLPool) public twAML; // sglAssetId => twAMLPool\n\n    /// @dev Virtual total amount to add to the total when computing twAML participation right. Default 10_000 * 1e18.\n    uint256 private VIRTUAL_TOTAL_AMOUNT = 10_000 ether;\n\n    uint256 public MIN_WEIGHT_FACTOR = 1000; // In BPS, default 10%\n    uint256 constant dMAX = 500_000; // 50 * 1e4; 0% - 50% discount\n    uint256 constant dMIN = 0;\n    uint256 public immutable EPOCH_DURATION; // 7 days = 604800\n\n    /// @notice starts time for emissions\n    /// @dev initialized in the constructor with block.timestamp\n    uint256 public emissionsStartTime;\n\n    /// @notice Total amount of participation per epoch\n    mapping(uint256 epoch => mapping(uint256 sglAssetID => int256 netAmount)) public netDepositedForEpoch;\n    /// =====-------======\n\n    error NotEqualDurations();\n    error NotAuthorized();\n    error NoActiveSingularities();\n    error NoLiquidity();\n    error OptionExpired();\n    error PaymentTokenNotSupported();\n    error OneEpochCooldown();\n    error TooHigh();\n    error TooLong();\n    error TooLow();\n    error DurationTooShort();\n    error PositionNotValid();\n    error LockNotExpired();\n    error TooSoon();\n    error Failed();\n    error TransferFailed();\n    error SingularityInRescueMode();\n    error PaymentTokenValuationNotValid();\n    error LockExpired();\n    error AdvanceEpochFirst();\n    error DurationNotMultiple();\n    error NotValid();\n\n    constructor(\n        address _tOLP,\n        address _oTAP,\n        address payable _tapOFT,\n        address _paymentTokenBeneficiary,\n        uint256 _epochDuration,\n        IPearlmit _pearlmit,\n        address _owner\n    ) PearlmitHandler(_pearlmit) {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n        tOLP = TapiocaOptionLiquidityProvision(_tOLP);\n\n        if (_epochDuration != TapiocaOptionLiquidityProvision(_tOLP).EPOCH_DURATION()) revert NotEqualDurations();\n\n        tapOFT = TapToken(_tapOFT);\n        oTAP = OTAP(_oTAP);\n        EPOCH_DURATION = _epochDuration;\n\n        _transferOwnership(_owner);\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Participate(\n        uint256 indexed epoch,\n        uint256 indexed sglAssetId,\n        uint256 totalDeposited,\n        uint256 otapTokenId,\n        uint256 tolpTokenId,\n        uint256 discount\n    );\n    event AMLDivergence(uint256 indexed epoch, uint256 cumulative, uint256 averageMagnitude, uint256 totalParticipants);\n    event ExerciseOption(\n        uint256 indexed epoch, address indexed to, ERC20 indexed paymentToken, uint256 otapTokenId, uint256 tapAmount\n    );\n    event NewEpoch(uint256 indexed epoch, uint256 extractedTap, uint256 epochTapValuation);\n    event ExitPosition(uint256 indexed epoch, uint256 indexed otapTokenId, uint256 tolpTokenId);\n    event SetPaymentToken(ERC20 indexed paymentToken, ITapiocaOracle oracle, bytes oracleData);\n    event SetTapOracle(ITapiocaOracle oracle, bytes oracleData);\n\n    // ==========\n    //    READ\n    // ==========\n    /// @notice Returns the current week given a timestamp\n    function timestampToWeek(uint256 timestamp) external view returns (uint256) {\n        if (timestamp == 0) {\n            timestamp = block.timestamp;\n        }\n        if (timestamp < emissionsStartTime) return 0;\n\n        return _timestampToWeek(timestamp);\n    }\n\n    /// @notice Returns the current week\n    function getCurrentWeek() external view returns (uint256) {\n        return _timestampToWeek(block.timestamp);\n    }\n\n    /// @notice Returns the details of an oTAP position including its tOLP lock position\n    /// @param _oTAPTokenID The oTAP token ID\n    /// @param epochId The epoch id of which to get the claimed TAP for - if 0, current epoch will be used\n    /// @return tOLPLockPosition The tOLP lock position of the oTAP position\n    /// @return oTAPPosition The details of the oTAP position\n    /// @return claimedTapInEpoch The amount of TAP claimed in specified epoch\n    function getOptionPosition(uint256 _oTAPTokenID, uint256 epochId)\n        external\n        view\n        returns (LockPosition memory tOLPLockPosition, TapOption memory oTAPPosition, uint256 claimedTapInEpoch)\n    {\n        if (epochId == 0) {\n            epochId = epoch;\n        }\n\n        (, oTAPPosition) = oTAP.attributes(_oTAPTokenID);\n        tOLPLockPosition = tOLP.getLock(oTAPPosition.tOLP);\n        claimedTapInEpoch = oTAPCalls[_oTAPTokenID][epochId];\n    }\n\n    /// @notice Returns the details of TOLP Singularity Pool, twAML pool and gauge for a given sglAssetId\n    /// @param _singularity The singularity address\n    /// @param epochId The epoch id of which to get the tap emitted for the pool - if 0, current epoch will be used\n    /// @return assetId The Singularity asset id = YB asset id\n    /// @return totalDeposited The total deposited amount in the pool\n    /// @return weight The weight of the pool\n    /// @return isInRescue True if the singularity is in rescue mode\n    /// @return tapEmittedInCurrentEpoch The amount of TAP emitted in the current epoch\n    /// @return twAMLPool The twAML Pool details\n    function getSingularityPoolInfo(IERC20 _singularity, uint256 epochId)\n        external\n        view\n        returns (\n            uint256 assetId,\n            uint256 totalDeposited,\n            uint256 weight,\n            bool isInRescue,\n            uint256 tapEmittedInCurrentEpoch,\n            TWAMLPool memory twAMLPool\n        )\n    {\n        if (epochId == 0) {\n            epochId = epoch;\n        }\n\n        (assetId, totalDeposited, weight, isInRescue) = tOLP.activeSingularities(_singularity);\n        twAMLPool = twAML[assetId];\n        tapEmittedInCurrentEpoch = singularityGauges[epochId][assetId];\n    }\n\n    /// @notice Returns the details of an OTC deal for a given oTAP token ID and a payment token.\n    ///         The oracle uses the last peeked value, and not the latest one, so the payment amount may be different.\n    /// @param _oTAPTokenID The oTAP token ID\n    /// @param _paymentToken The payment token\n    /// @param _tapAmount The amount of TAP to be exchanged. If 0 it will use the full amount of TAP eligible for the deal\n    /// @return eligibleTapAmount The amount of TAP eligible for the deal\n    /// @return paymentTokenAmount The amount of payment tokens required for the deal\n    /// @return tapAmount The amount of TAP to be exchanged\n    function getOTCDealDetails(uint256 _oTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        view\n        returns (uint256 eligibleTapAmount, uint256 paymentTokenAmount, uint256 tapAmount)\n    {\n        // Load data\n        (, TapOption memory oTAPPosition) = oTAP.attributes(_oTAPTokenID);\n        LockPosition memory tOLPLockPosition = tOLP.getLock(oTAPPosition.tOLP);\n\n        {\n            if (!_isPositionActive(tOLPLockPosition)) revert OptionExpired();\n        }\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotSupported();\n        }\n        if (block.timestamp < tOLPLockPosition.lockTime + EPOCH_DURATION) {\n            revert OneEpochCooldown();\n        } // Can only exercise after 1 epoch duration\n\n        // Get eligible OTC amount\n        {\n            uint256 gaugeTotalForEpoch = singularityGauges[cachedEpoch][tOLPLockPosition.sglAssetID];\n            uint256 netAmount = uint256(netDepositedForEpoch[cachedEpoch][tOLPLockPosition.sglAssetID]);\n            if (netAmount == 0) revert NoLiquidity();\n\n            eligibleTapAmount = muldiv(tOLPLockPosition.ybShares, gaugeTotalForEpoch, netAmount);\n            eligibleTapAmount -= oTAPCalls[_oTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n            if (eligibleTapAmount < _tapAmount) revert TooHigh();\n        }\n\n        tapAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (tapAmount < 1e18) revert TooLow();\n        // Get TAP valuation\n        uint256 otcAmountInUSD = tapAmount * epochTAPValuation; // Divided by TAP decimals\n        // Get payment token valuation\n        (, uint256 paymentTokenValuation) = paymentTokenOracle.oracle.peek(paymentTokenOracle.oracleData);\n        // Get payment token amount\n        paymentTokenAmount = _getDiscountedPaymentAmount(\n            otcAmountInUSD, paymentTokenValuation, oTAPPosition.discount, _paymentToken.decimals()\n        );\n    }\n\n    // ===========\n    //    WRITE\n    // ===========\n\n    /// @notice Participate in twAMl voting and mint an oTAP position.\n    ///         Exercising the option is not possible on participation week.\n    ///         Lock duration should be a multiple of 1 EPOCH, and have a minimum of 1 EPOCH.\n    /// @param _tOLPTokenID The tokenId of the tOLP position\n    function participate(uint256 _tOLPTokenID) external whenNotPaused nonReentrant returns (uint256 oTAPTokenID) {\n        // Compute option parameters\n        LockPosition memory lock = tOLP.getLock(_tOLPTokenID);\n        uint128 lockExpiry = lock.lockTime + lock.lockDuration;\n\n        if (block.timestamp >= lockExpiry) revert LockExpired();\n        if (_timestampToWeek(block.timestamp) > epoch) revert AdvanceEpochFirst();\n\n        bool isPositionActive = _isPositionActive(lock);\n        if (!isPositionActive) revert OptionExpired();\n\n        if (lock.lockDuration < EPOCH_DURATION) revert DurationTooShort();\n        if (lock.lockDuration % EPOCH_DURATION != 0) revert DurationNotMultiple();\n\n        TWAMLPool memory pool = twAML[lock.sglAssetID];\n\n        if (pool.cumulative == 0) {\n            pool.cumulative = EPOCH_DURATION;\n        }\n\n        // Transfer tOLP position to this contract\n        // tOLP.transferFrom(msg.sender, address(this), _tOLPTokenID);\n        {\n            bool isErr = pearlmit.transferFromERC721(msg.sender, address(this), address(tOLP), _tOLPTokenID);\n            if (isErr) revert TransferFailed();\n        }\n\n        uint256 magnitude = computeMagnitude(uint256(lock.lockDuration), pool.cumulative);\n        uint256 target = computeTarget(dMIN, dMAX, magnitude, pool.cumulative);\n\n        // Revert if the lock 4x the cumulative\n        if (magnitude > pool.cumulative * 4) revert TooLong();\n\n        bool divergenceForce;\n        // Participate in twAMl voting\n        bool hasVotingPower =\n            lock.ybShares >= computeMinWeight(pool.totalDeposited + VIRTUAL_TOTAL_AMOUNT, MIN_WEIGHT_FACTOR);\n        if (hasVotingPower) {\n            pool.totalParticipants++; // Save participation\n            pool.averageMagnitude = (pool.averageMagnitude + magnitude) / pool.totalParticipants; // compute new average magnitude\n\n            // Compute and save new cumulative\n            divergenceForce = lock.lockDuration >= pool.cumulative;\n            if (divergenceForce) {\n                pool.cumulative += pool.averageMagnitude;\n            } else {\n                if (pool.cumulative > pool.averageMagnitude) {\n                    pool.cumulative -= pool.averageMagnitude;\n                } else {\n                    pool.cumulative = EPOCH_DURATION;\n                }\n            }\n\n            // Save new weight\n            pool.totalDeposited += lock.ybShares;\n\n            twAML[lock.sglAssetID] = pool; // Save twAML participation\n            emit AMLDivergence(epoch, pool.cumulative, pool.averageMagnitude, pool.totalParticipants); // Register new voting power event\n        }\n        // Save twAML participation\n        participants[_tOLPTokenID] = Participation(hasVotingPower, divergenceForce, pool.averageMagnitude);\n\n        // Record amount for next epoch exercise\n        netDepositedForEpoch[epoch + 1][lock.sglAssetID] += int256(uint256(lock.ybShares));\n\n        uint256 lastEpoch = _timestampToWeek(lockExpiry);\n        // And remove it from last epoch\n        // Math is safe, check `_emitToGauges()`\n        netDepositedForEpoch[lastEpoch + 1][lock.sglAssetID] -= int256(uint256(lock.ybShares));\n\n        // Mint oTAP position\n        oTAPTokenID = oTAP.mint(msg.sender, lockExpiry, uint128(target), _tOLPTokenID);\n        emit Participate(epoch, lock.sglAssetID, pool.totalDeposited, oTAPTokenID, _tOLPTokenID, target);\n    }\n\n    /// @notice Exit a twAML participation and delete the voting power if existing\n    /// @param _oTAPTokenID The tokenId of the oTAP position\n    function exitPosition(uint256 _oTAPTokenID) external whenNotPaused {\n        if (!oTAP.exists(_oTAPTokenID)) revert PositionNotValid();\n\n        // Load data\n        (, TapOption memory oTAPPosition) = oTAP.attributes(_oTAPTokenID);\n        LockPosition memory lock = tOLP.getLock(oTAPPosition.tOLP);\n\n        bool isSGLInRescueMode = _isSGLInRescueMode(lock);\n\n        // If SGL is in rescue, bypass the lock expiration\n        if (!isSGLInRescueMode) {\n            if (block.timestamp < lock.lockTime + lock.lockDuration) {\n                revert LockNotExpired();\n            }\n        }\n\n        Participation memory participation = participants[oTAPPosition.tOLP];\n\n        // Remove participation\n        // If the SGL is in rescue mode, bypass the voting power removal\n        if (!isSGLInRescueMode && participation.hasVotingPower) {\n            TWAMLPool memory pool = twAML[lock.sglAssetID];\n\n            if (participation.divergenceForce) {\n                if (pool.cumulative > participation.averageMagnitude) {\n                    pool.cumulative -= participation.averageMagnitude;\n                } else {\n                    pool.cumulative = EPOCH_DURATION;\n                }\n            } else {\n                pool.cumulative += participation.averageMagnitude;\n            }\n\n            pool.totalDeposited -= lock.ybShares;\n\n            unchecked {\n                --pool.totalParticipants;\n            }\n\n            twAML[lock.sglAssetID] = pool; // Save twAML exit\n            emit AMLDivergence(epoch, pool.cumulative, pool.averageMagnitude, pool.totalParticipants); // Register new voting power event\n        }\n\n        // Delete participation and burn oTAP position\n        address otapOwner = oTAP.ownerOf(_oTAPTokenID);\n        delete participants[oTAPPosition.tOLP];\n        oTAP.burn(_oTAPTokenID);\n\n        // Transfer position back to oTAP owner\n        tOLP.transferFrom(address(this), otapOwner, oTAPPosition.tOLP);\n\n        emit ExitPosition(epoch, _oTAPTokenID, oTAPPosition.tOLP);\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param _oTAPTokenID tokenId of the oTAP position, position must be active\n    /// @param _paymentToken Address of the payment token to use, must be whitelisted\n    /// @param _tapAmount Amount of TAP to exercise. If 0, the full amount is exercised\n    function exerciseOption(uint256 _oTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount) external whenNotPaused {\n        // Load data\n        (address owner, TapOption memory oTAPPosition) = oTAP.attributes(_oTAPTokenID);\n        LockPosition memory tOLPLockPosition = tOLP.getLock(oTAPPosition.tOLP);\n        {\n            bool isPositionActive = _isPositionActive(tOLPLockPosition);\n            if (!isPositionActive) revert OptionExpired();\n        }\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotSupported();\n        }\n\n        // Check allowance. Make sure to consume it post call\n        {\n            // oTAP.isApprovedOrOwner(msg.sender, _oTAPTokenID)\n            if (owner != msg.sender && !isERC721Approved(owner, msg.sender, address(oTAP), _oTAPTokenID)) {\n                revert NotAuthorized();\n            }\n        }\n\n        if (_timestampToWeek(block.timestamp) > epoch) revert AdvanceEpochFirst();\n\n        if (block.timestamp < oTAPPosition.entry + EPOCH_DURATION) {\n            revert OneEpochCooldown();\n        } // Can only exercise after 1 epoch duration\n\n        // Get eligible OTC amount\n        uint256 gaugeTotalForEpoch = singularityGauges[cachedEpoch][tOLPLockPosition.sglAssetID];\n        uint256 netAmount = uint256(netDepositedForEpoch[cachedEpoch][tOLPLockPosition.sglAssetID]);\n        if (netAmount == 0) revert NoLiquidity();\n        uint256 eligibleTapAmount = muldiv(tOLPLockPosition.ybShares, gaugeTotalForEpoch, netAmount);\n        eligibleTapAmount -= oTAPCalls[_oTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        if (eligibleTapAmount < _tapAmount) revert TooHigh();\n\n        uint256 chosenAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (chosenAmount < 1e18) revert TooLow();\n        oTAPCalls[_oTAPTokenID][cachedEpoch] += chosenAmount; // Adds up exercised amount to current epoch\n\n        // Finalize the deal\n        _processOTCDeal(_paymentToken, paymentTokenOracle, chosenAmount, oTAPPosition.discount);\n\n        emit ExerciseOption(cachedEpoch, msg.sender, _paymentToken, _oTAPTokenID, chosenAmount);\n    }\n\n    // TODO Check at how many SGls this function breaks. Do we need to split calls into 2+ Txs?\n    /// @notice Start a new epoch, extract TAP from the TapOFT co"
    }
  ]
}