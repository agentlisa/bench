{
  "Title": "[25] The `Ecrecover` gas cost been massively increased without significant increases in executional cost",
  "Content": "\n### Proof of Concept\n\nTake a look at the gas cost for ecrecover https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/precompiles/Ecrecover.yul#L22-L25\n\n```yul\n            /// @dev The gas cost of processing ecrecover circuit precompile.\n            function ECRECOVER_GAS_COST() -> ret {\n                ret := 7000\n            }\n```\n\nIt's been massively increased to more than `6x` it's former cost of `1112`, would be key to note that the execution of this contract is still the same without any execessive additional hashing/compiling that justifies this addition.\n\n### Impact\n\nUsers are now charged `>6x` the charges to `ECRECOVER` where as there are no real stand out addition in executional costs.\n\n### Recommended Mitigation Steps\n\nConsider reducing this cost or always attach extensive documentation whenever an update happens to a variable, especially the ones attached to costs.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/precompiles/Ecrecover.yul",
      "content": "/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The contract used to emulate EVM's ecrecover precompile.\n * @dev It uses `precompileCall` to call the zkEVM built-in precompiles.\n */\nobject \"Ecrecover\" {\n    code {\n        return(0, 0)\n    }\n    object \"Ecrecover_deployed\" {\n        code {\n            ////////////////////////////////////////////////////////////////\n            //                      CONSTANTS\n            ////////////////////////////////////////////////////////////////\n\n            // Group order of secp256k1, see https://en.bitcoin.it/wiki/Secp256k1\n            function SECP256K1_GROUP_SIZE() -> ret {\n                ret := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n            }\n\n            /// @dev The gas cost of processing ecrecover circuit precompile.\n            function ECRECOVER_GAS_COST() -> ret {\n                ret := 7000\n            }\n\n            ////////////////////////////////////////////////////////////////\n            //                      HELPER FUNCTIONS\n            ////////////////////////////////////////////////////////////////\n            \n            // @dev Packs precompile parameters into one word.\n            // Note: functions expect to work with 32/64 bits unsigned integers.\n            // Caller should ensure the type matching before!\n            function unsafePackPrecompileParams(\n                uint32_inputOffsetInWords,\n                uint32_inputLengthInWords,\n                uint32_outputOffsetInWords,\n                uint32_outputLengthInWords,\n                uint64_perPrecompileInterpreted\n            ) -> rawParams {\n                rawParams := uint32_inputOffsetInWords\n                rawParams := or(rawParams, shl(32, uint32_inputLengthInWords))\n                rawParams := or(rawParams, shl(64, uint32_outputOffsetInWords))\n                rawParams := or(rawParams, shl(96, uint32_outputLengthInWords))\n                rawParams := or(rawParams, shl(192, uint64_perPrecompileInterpreted))\n            }\n\n            /// @dev Executes the `precompileCall` opcode.\n            function precompileCall(precompileParams, gasToBurn) -> ret {\n                // Compiler simulation for calling `precompileCall` opcode\n                ret := verbatim_2i_1o(\"precompile\", precompileParams, gasToBurn)\n            }\n\n            ////////////////////////////////////////////////////////////////\n            //                      FALLBACK\n            ////////////////////////////////////////////////////////////////\n\n            let digest := calldataload(0)\n            let v := calldataload(32)\n            let r := calldataload(64)\n            let s := calldataload(96)\n\n            // Validate the input by the yellow paper rules (Appendix E. Precompiled contracts)\n            let vIsInvalid := iszero(or(eq(v, 27), eq(v, 28)))\n            let sIsInvalid := or(eq(s, 0), gt(s, sub(SECP256K1_GROUP_SIZE(), 1)))\n            let rIsInvalid := or(eq(r, 0), gt(r, sub(SECP256K1_GROUP_SIZE(), 1)))\n\n            if or(vIsInvalid, or(sIsInvalid, rIsInvalid)) {\n                return(0, 0)\n            }\n\n            // Store the data in memory, so the ecrecover circuit will read it \n            mstore(0, digest)\n            mstore(32, sub(v, 27))\n            mstore(64, r)\n            mstore(96, s)\n\n            let precompileParams := unsafePackPrecompileParams(\n                0, // input offset in words\n                4, // input length in words (the signed digest, v, r, s)\n                0, // output offset in words\n                2, // output length in words (success, signer)\n                0  // No special meaning, ecrecover circuit doesn't check this value\n            )\n            let gasToPay := ECRECOVER_GAS_COST()\n\n            // Check whether the call is successfully handled by the ecrecover circuit\n            let success := precompileCall(precompileParams, gasToPay)\n            let internalSuccess := mload(0)\n\n            switch and(success, internalSuccess)\n            case 0 {\n                return(0, 0)\n            }\n            default {\n                return(32, 32)\n            }\n        }\n    }\n}"
    }
  ]
}