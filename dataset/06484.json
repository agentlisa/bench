{
  "Title": "[M-36] `ERC4626PartnerManager.checkTransfer` does not check `amount` correctly, as it applies `bHermesRate` to `balanceOf[from]`, but not `amount`.",
  "Content": "\n### Proof of Concept\n\n`ERC4626PartnerManager.checkTransfer()` is a modifier that will be called to ensure that the `from` account has sufficient funding to cover  `userClaimedWeight[from]`, `userClaimedBoost[from]`, `userClaimedGovernance[from]`, and `userClaimedPartnerGovernance[from]` before the transfer occurs:\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L325-L335>\n\nHowever, `bHermesRate` is applied to `balanceOf[from]`, but not to `amount`. This is not right, since `amount` is not in the units of `userClaimedWeight[from]`, `userClaimedBoost[from]`, `userClaimedGovernance[from]`, and `userClaimedPartnerGovernance[from]`; but it's in the units of shares of `ERC4626PartnerManager`.\n\nThe correct way to check, would be to ensure  `balanceOf[from]-amount *  bHermesRate` >= `userClaimedWeight[from]`, `userClaimedBoost[from]`, `userClaimedGovernance[from]`, and `userClaimedPartnerGovernance[from]`.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\n```diff\n modifier checkTransfer(address from, uint256 amount) virtual {\n-        uint256 userBalance = balanceOf[from] * bHermesRate;\n+        uint256 userBalance = (balanceOf[from] - amount) * bHermesRate;\n\n-        if (\n-            userBalance - userClaimedWeight[from] < amount || userBalance - userClaimedBoost[from] < amount\n-                || userBalance - userClaimedGovernance[from] < amount\n-                || userBalance - userClaimedPartnerGovernance[from] < amount\n-        ) revert InsufficientUnderlying();\n\n+        if (\n+            userBalance < userClaimedWeight[from] || userBalance < userClaimedBoost[from] \n+                || userBalance < userClaimedGovernance[from]  || userBalance <  userClaimedPartnerGovernance[from] \n+        ) revert InsufficientUnderlying();\n\n\n        _;\n    }\n```\n\n### Assessed type\n\nMath\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/268#issuecomment-1632749238)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/268#issuecomment-1709221420):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/268).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/maia/tokens/ERC4626PartnerManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {bHermes} from \"@hermes/bHermes.sol\";\nimport {bHermesVotes as ERC20MultiVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {PartnerManagerFactory} from \"../factories/PartnerManagerFactory.sol\";\nimport {IBaseVault} from \"../interfaces/IBaseVault.sol\";\nimport {PartnerUtilityManager} from \"../PartnerUtilityManager.sol\";\n\nimport {IERC4626PartnerManager} from \"../interfaces/IERC4626PartnerManager.sol\";\n\n/// @title Yield bearing, boosting, voting, and gauge enabled Partner Token\nabstract contract ERC4626PartnerManager is PartnerUtilityManager, Ownable, ERC4626, IERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         PARTNER MANAGER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    PartnerManagerFactory public immutable override factory;\n\n    /// @inheritdoc IERC4626PartnerManager\n    bHermes public immutable override bHermesToken;\n\n    /// @inheritdoc IERC4626PartnerManager\n    uint256 public override bHermesRate;\n\n    /**\n     * @notice Initializes the ERC4626PartnerManager token.\n     * @param _factory The partner manager factory.\n     * @param _bHermesRate The rate at which bHermes underlying's can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get partner tokens.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of this contract.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    )\n        PartnerUtilityManager(\n            address(bHermes(_bhermes).gaugeWeight()),\n            address(bHermes(_bhermes).gaugeBoost()),\n            address(bHermes(_bhermes).governance()),\n            address(new ERC20MultiVotes(_owner)),\n            partnerVault\n        )\n        ERC4626(\n            _partnerAsset,\n            string.concat(_name, \" - Burned Hermes: Aggregated Gov + Yield + Boost\"),\n            string.concat(_symbol, \"-bHermes\")\n        )\n    {\n        _initializeOwner(_owner);\n        partnerVault = _partnerVault;\n        factory = _factory;\n        bHermesRate = _bHermesRate;\n        bHermesToken = bHermes(_bhermes);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            UTILITY MANAGER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function updateUnderlyingBalance() public virtual {\n        bHermesToken.claimOutstanding();\n    }\n\n    /// @inheritdoc IERC4626PartnerManager\n    function claimOutstanding() public virtual {\n        uint256 balance = balanceOf[msg.sender] * bHermesRate;\n        /// @dev Never overflows since balandeOf >= userClaimed.\n        claimWeight(balance - userClaimedWeight[msg.sender]);\n        claimBoost(balance - userClaimedBoost[msg.sender]);\n        claimGovernance(balance - userClaimedGovernance[msg.sender]);\n        claimPartnerGovernance(balance - userClaimedPartnerGovernance[msg.sender]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Compute the amount of tokens available in contract.\n    /// @dev 1:1 with underlying asset.\n    function totalAssets() public view override returns (uint256) {\n        return totalSupply;\n    }\n\n    /**\n     * @notice Computes and returns the amount of shares from a given amount of assets.\n     * @param assets amount of assets to convert to shares\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Computes and returns the amount of assets from a given amount of shares.\n     * @param shares amount of shares to convert to assets\n     */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Simulates the amount of shares that the assets deposited are worth.\n     * @param assets amount of assets to simulate the deposit.\n     */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Calculates the amount of shares that the assets deposited are worth.\n     */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be withdrawn from a given amount of shares.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be redeemed from a given amount of shares.\n     * @param shares amount of shares to convert to assets.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ER4626 DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxMint(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be withdrawn by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxWithdraw(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /// @notice Returns the maximum amount of assets that can be redeemed by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxRedeem(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function migratePartnerVault(address newPartnerVault) external onlyOwner {\n        if (factory.vaultIds(IBaseVault(newPartnerVault)) == 0) revert UnrecognizedVault();\n\n        address oldPartnerVault = partnerVault;\n        if (oldPartnerVault != address(0)) IBaseVault(oldPartnerVault).clearAll();\n        bHermesToken.claimOutstanding();\n\n        address(gaugeWeight).safeApprove(oldPartnerVault, 0);\n        address(gaugeBoost).safeApprove(oldPartnerVault, 0);\n        address(governance).safeApprove(oldPartnerVault, 0);\n        address(partnerGovernance).safeApprove(oldPartnerVault, 0);\n\n        address(gaugeWeight).safeApprove(newPartnerVault, type(uint256).max);\n        address(gaugeBoost).safeApprove(newPartnerVault, type(uint256).max);\n        address(governance).safeApprove(newPartnerVault, type(uint256).max);\n        address(partnerGovernance).safeApprove(newPartnerVault, type(uint256).max);\n\n        partnerVault = newPartnerVault;\n        if (newPartnerVault != address(0)) IBaseVault(newPartnerVault).applyAll();\n\n        emit MigratePartnerVault(address(this), newPartnerVault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function increaseConversionRate(uint256 newRate) external onlyOwner {\n        if (newRate < bHermesRate) revert InvalidRate();\n\n        if (newRate > (address(bHermesToken).balanceOf(address(this)) / totalSupply)) {\n            revert InsufficientBacking();\n        }\n\n        bHermesRate = newRate;\n\n        partnerGovernance.mint(\n            address(this), totalSupply * newRate - address(partnerGovernance).balanceOf(address(this))\n        );\n        bHermesToken.claimOutstanding();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints new partner bhermes tokens to a specific address.\n     * @param to address to mints tokens to.\n     * @param amount amount of tokens to mint.\n     */\n    function _mint(address to, uint256 amount) internal virtual override {\n        if (amount > maxMint(to)) revert ExceedsMaxDeposit();\n        bHermesToken.claimOutstanding();\n\n        ERC20MultiVotes(partnerGovernance).mint(address(this), amount * bHermesRate);\n        super._mint(to, amount);\n    }\n\n    /**\n     * @notice Burns (or unstakes) the vMaia token in exchange for the underlying\n     *         Partner tokens, performing changes around bHermes tokens.\n     * @param from account to burn the partner manager from\n     * @param amount amounts of vMaia to burn\n     */\n    function _burn(address from, uint256 amount) internal virtual override checkTransfer(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfer partner manager to a specific address.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(msg.sender, amount)\n        returns (bool)\n    {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer tokens from a given address.\n     * @param from address to transfer the tokens from.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available weight allows for call.\n    modifier checkWeight(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedWeight[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available boost allows for call.\n    modifier checkBoost(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedBoost[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available governance allows for call.\n    modifier checkGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available partner governance allows for call.\n    modifier checkPartnerGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedPartnerGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    modifier checkTransfer(address from, uint256 amount) virtual {\n        uint256 userBalance = balanceOf[from] * bHermesRate;\n\n        if (\n            userBalance - userClaimedWeight[from] < amount || userBalance - userClaimedBoost[from] < amount\n                || userBalance - userClaimedGovernance[from] < amount\n                || userBalance - userClaimedPartnerGovernance[from] < amount\n        ) revert InsufficientUnderlying();\n\n        _;\n    }\n}"
    }
  ]
}