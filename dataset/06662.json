{
  "Title": "[G-13] Sort array offchain to check duplicates in O(n) instead of O(n^2)",
  "Content": "Instead of using two for loops to check for duplicates, which runs in O(n^2) time and is expensive, the `proposalIds_` array can be sorted offchain which allows us to to check duplicates by simply ensuring the the current `id` is larger than the previous one (O(n) time).\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L463-L479\n\n```solidity\nFile: ajna-grants/src/base/StandardFunding.sol\n463:    function _hasDuplicates(\n464:        uint256[] calldata proposalIds_\n465:    ) internal pure returns (bool) {\n466:        uint256 numProposals = proposalIds_.length;\n467:\n468:        for (uint i = 0; i < numProposals; ) {\n469:            for (uint j = i + 1; j < numProposals; ) {\n470:                if (proposalIds_[i] == proposalIds_[j]) return true;\n471:\n472:                unchecked { ++j; }\n473:            }\n474:\n475:            unchecked { ++i; }\n476:\n477:        }\n478:        return false;\n479:    }\n```\n\n## `GasReport` output with all optimizations applied\n```js\n| src/grants/GrantFund.sol:GrantFund contract |                 |        |        |        |         |\n|---------------------------------------------|-----------------|--------|--------|--------|---------|\n| Deployment Cost                             | Deployment Size |        |        |        |         |\n| 4584527                                     | 22888           |        |        |        |         |\n| Function Name                               | min             | avg    | median | max    | # calls |\n| claimDelegateReward                         | 1027            | 34814  | 35468  | 42268  | 237     |\n| executeExtraordinary                        | 7234            | 38968  | 39686  | 95707  | 11      |\n| executeStandard                             | 8598            | 29854  | 37920  | 47520  | 8       |\n| findMechanismOfProposal                     | 613             | 2043   | 799    | 4719   | 3       |\n| fundTreasury                                | 7917            | 45019  | 44557  | 65788  | 29      |\n| fundingVote                                 | 1162            | 104626 | 104616 | 396776 | 252     |\n| getDelegateReward                           | 1909            | 1909   | 1909   | 1909   | 5       |\n| getDistributionId                           | 368             | 417    | 368    | 2368   | 601     |\n| getDistributionPeriodInfo                   | 1023            | 1802   | 1023   | 5023   | 77      |\n| getExtraordinaryProposalInfo                | 992             | 992    | 992    | 992    | 4       |\n| getExtraordinaryProposalSucceeded           | 2245            | 2664   | 2740   | 3008   | 3       |\n| getFundedProposalSlate                      | 1155            | 1331   | 1390   | 1390   | 4       |\n| getFundingPowerVotes                        | 15522           | 15710  | 15773  | 15773  | 4       |\n| getFundingVotesCast                         | 1576            | 2316   | 2316   | 3056   | 2       |\n| getMinimumThresholdPercentage               | 471             | 629    | 471    | 2471   | 16      |\n| getProposalInfo                             | 1002            | 1002   | 1002   | 1002   | 110     |\n| getSlateHash                                | 922             | 930    | 934    | 934    | 3       |\n| getSliceOfNonTreasury                       | 1577            | 3743   | 1577   | 8077   | 3       |\n| getSliceOfTreasury                          | 781             | 1781   | 1781   | 2781   | 2       |\n| getTopTenProposals                          | 1209            | 2473   | 2385   | 3326   | 16      |\n| getVoterInfo                                | 1002            | 1002   | 1002   | 1002   | 5       |\n| getVotesExtraordinary                       | 764             | 7180   | 7192   | 8334   | 880     |\n| getVotesFunding                             | 1250            | 4511   | 1250   | 8366   | 15      |\n| getVotesScreening                           | 4892            | 4934   | 4926   | 6068   | 489     |\n| hasVotedExtraordinary                       | 683             | 1683   | 1683   | 2683   | 2       |\n| hashProposal                                | 3685            | 3685   | 3685   | 3685   | 76      |\n| proposeExtraordinary                        | 4725            | 63262  | 82112  | 86451  | 18      |\n| proposeStandard                             | 4418            | 77911  | 82820  | 82820  | 72      |\n| screeningVote                               | 1456            | 44406  | 38748  | 390626 | 271     |\n| screeningVotesCast                          | 695             | 1361   | 695    | 2695   | 3       |\n| startNewDistributionPeriod                  | 576             | 48177  | 52813  | 75139  | 20      |\n| state                                       | 1337            | 4346   | 3685   | 7137   | 20      |\n| treasury                                    | 396             | 396    | 396    | 396    | 12      |\n| updateSlate                                 | 971             | 57418  | 69517  | 310231 | 17      |\n| voteExtraordinary                           | 590             | 28832  | 28927  | 30893  | 877     |\n\n\n| src/PositionManager.sol:PositionManager contract |                 |        |        |         |         |\n|--------------------------------------------------|-----------------|--------|--------|---------|---------|\n| Deployment Cost                                  | Deployment Size |        |        |         |         |\n| 3848238                                          | 19497           |        |        |         |         |\n| Function Name                                    | min             | avg    | median | max     | # calls |\n| DOMAIN_SEPARATOR                                 | 512             | 512    | 512    | 512     | 7       |\n| PERMIT_TYPEHASH                                  | 241             | 241    | 241    | 241     | 7       |\n| approve(address,uint256)                         | 25186           | 25186  | 25186  | 25186   | 10      |\n| approve(address,uint256)(bool)                   | 25186           | 25186  | 25186  | 25186   | 28      |\n| burn                                             | 1408            | 4679   | 5632   | 8524    | 12      |\n| getLP                                            | 5659            | 7969   | 7200   | 35334   | 229     |\n| getPositionIndexes                               | 1323            | 1921   | 1793   | 3439    | 165     |\n| getPositionIndexesFiltered                       | 8165            | 27877  | 23937  | 71401   | 222     |\n| getPositionInfo                                  | 784             | 784    | 784    | 784     | 4       |\n| isIndexInPosition                                | 679             | 1242   | 679    | 2679    | 71      |\n| isPositionBucketBankrupt                         | 5832            | 6624   | 6820   | 7011    | 6       |\n| memorializePositions                             | 17751           | 324318 | 252840 | 1133268 | 58      |\n| mint                                             | 8013            | 87149  | 92653  | 97653   | 63      |\n| moveLiquidity                                    | 5864            | 237889 | 239056 | 675854  | 19      |\n| ownerOf                                          | 580             | 580    | 580    | 599     | 119     |\n| permit                                           | 618             | 12225  | 5865   | 32554   | 7       |\n| poolKey                                          | 523             | 523    | 523    | 523     | 36      |\n| reedemPositions                                  | 2834            | 37754  | 25381  | 139605  | 24      |\n| safeTransferFrom                                 | 21520           | 22920  | 23320  | 23520   | 4       |\n| tokenURI                                         | 2490            | 466347 | 466347 | 930205  | 2       |\n| transferFrom(address,address,uint256)            | 5956            | 18817  | 23476  | 24573   | 12      |\n| transferFrom(address,address,uint256)(bool)      | 5956            | 17097  | 19659  | 24573   | 38      |\n\n\n| src/RewardsManager.sol:RewardsManager contract |                 |         |         |         |         |\n|------------------------------------------------|-----------------|---------|---------|---------|---------|\n| Deployment Cost                                | Deployment Size |         |         |         |         |\n| 1915540                                        | 9863            |         |         |         |         |\n| Function Name                                  | min             | avg     | median  | max     | # calls |\n| calculateRewards                               | 33122           | 47963   | 36928   | 153466  | 106     |\n| claimRewards                                   | 523             | 118708  | 102613  | 381560  | 109     |\n| getBucketStateStakeInfo                        | 677             | 2675    | 2677    | 2677    | 81279   |\n| getStakeInfo                                   | 694             | 694     | 694     | 694     | 137     |\n| moveStakedLiquidity                            | 1856519         | 1968777 | 1968777 | 2081035 | 2       |\n| stake                                          | 118532          | 374112  | 395151  | 890632  | 34      |\n| unstake                                        | 95782           | 177074  | 140013  | 395455  | 13      |\n| updateBucketExchangeRatesAndClaim              | 9593            | 242537  | 174985  | 535123  | 42      |\n```\n\n**[MikeHathaway (Ajna) commented](https://github.com/code-423n4/2023-05-ajna-findings/issues/284#issuecomment-1574481774):**\n > This report was extremely helpful. We've adopted many of the gas optimizations, and have verified that the provided gas savings estimates were generally accurate.\n\n\n\n***\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-grants/src/grants/base/StandardFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }    from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast }  from \"@oz/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@oz/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IStandardFunding } from \"../interfaces/IStandardFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract StandardFunding is Funding, IStandardFunding {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens that can be distributed by the treasury in a quarter.\n     * @dev Stored as a Wad percentage.\n     */\n    uint256 internal constant GLOBAL_BUDGET_CONSTRAINT = 0.03 * 1e18;\n\n    /**\n     * @notice Length of the challengephase of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 7 days.\n     * @dev    The period in which funded proposal slates can be checked in updateSlate.\n     */\n    uint256 internal constant CHALLENGE_PERIOD_LENGTH = 50400;\n\n    /**\n     * @notice Length of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 90 days.\n     */\n    uint48 internal constant DISTRIBUTION_PERIOD_LENGTH = 648000;\n\n    /**\n     * @notice Length of the funding phase of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 10 days.\n     */\n    uint256 internal constant FUNDING_PERIOD_LENGTH = 72000;\n\n    /**\n     * @notice Keccak hash of a prefix string for standard funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_STANDARD = keccak256(bytes(\"Standard Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice ID of the current distribution period.\n     * @dev Used to access information on the status of an ongoing distribution.\n     * @dev Updated at the start of each quarter.\n     * @dev Monotonically increases by one per period.\n     */\n    uint24 internal _currentDistributionId = 0;\n\n    /**\n     * @notice Mapping of quarterly distributions from the grant fund.\n     * @dev distributionId => QuarterlyDistribution\n     */\n    mapping(uint24 => QuarterlyDistribution) internal _distributions;\n\n    /**\n     * @dev Mapping of all proposals that have ever been submitted to the grant fund for screening.\n     * @dev proposalId => Proposal\n     */\n    mapping(uint256 => Proposal) internal _standardFundingProposals;\n\n    /**\n     * @dev Mapping of distributionId to a sorted array of 10 proposalIds with the most votes in the screening period.\n     * @dev distribution.id => proposalId[]\n     * @dev A new array is created for each distribution period\n     */\n    mapping(uint256 => uint256[]) internal _topTenProposals;\n\n    /**\n     * @notice Mapping of a hash of a proposal slate to a list of funded proposals.\n     * @dev slate hash => proposalId[]\n     */\n    mapping(bytes32 => uint256[]) internal _fundedProposalSlates;\n\n    /**\n     * @notice Mapping of quarterly distributions to voters to a Quadratic Voter info struct.\n     * @dev distributionId => voter address => QuadraticVoter \n     */\n    mapping(uint256 => mapping(address => QuadraticVoter)) internal _quadraticVoters;\n\n    /**\n     * @notice Mapping of distributionId to whether surplus funds from distribution updated into treasury\n     * @dev distributionId => bool\n    */\n    mapping(uint256 => bool) internal _isSurplusFundsUpdated;\n\n    /**\n     * @notice Mapping of distributionId to user address to whether user has claimed his delegate reward\n     * @dev distributionId => address => bool\n    */\n    mapping(uint256 => mapping(address => bool)) public hasClaimedReward;\n\n    /**\n     * @notice Mapping of distributionId to user address to total votes cast on screening stage proposals.\n     * @dev distributionId => address => uint256\n    */\n    mapping(uint256 => mapping(address => uint256)) public screeningVotesCast;\n\n    /**************************************************/\n    /*** Distribution Management Functions External ***/\n    /**************************************************/\n\n    /// @inheritdoc IStandardFunding\n    function startNewDistributionPeriod() external override returns (uint24 newDistributionId_) {\n        uint24  currentDistributionId       = _currentDistributionId;\n        uint256 currentDistributionEndBlock = _distributions[currentDistributionId].endBlock;\n\n        // check that there isn't currently an active distribution period\n        if (block.number <= currentDistributionEndBlock) revert DistributionPeriodStillActive();\n\n        // update Treasury with unused funds from last two distributions\n        {\n            // Check if any last distribution exists and its challenge stage is over\n            if (currentDistributionId > 0 && (block.number > _getChallengeStageEndBlock(currentDistributionEndBlock))) {\n                // Add unused funds from last distribution to treasury\n                _updateTreasury(currentDistributionId);\n            }\n\n            // checks if any second last distribution exist and its unused funds are not added into treasury\n            if (currentDistributionId > 1 && !_isSurplusFundsUpdated[currentDistributionId - 1]) {\n                // Add unused funds from second last distribution to treasury\n                _updateTreasury(currentDistributionId - 1);\n            }\n        }\n\n        // set the distribution period to start at the current block\n        uint48 startBlock = SafeCast.toUint48(block.number);\n        uint48 endBlock = startBlock + DISTRIBUTION_PERIOD_LENGTH;\n\n        // set new value for currentDistributionId\n        newDistributionId_ = _setNewDistributionId();\n\n        // create QuarterlyDistribution struct\n        QuarterlyDistribution storage newDistributionPeriod = _distributions[newDistributionId_];\n        newDistributionPeriod.id              = newDistributionId_;\n        newDistributionPeriod.startBlock      = startBlock;\n        newDistributionPeriod.endBlock        = endBlock;\n        uint256 gbc                           = Maths.wmul(treasury, GLOBAL_BUDGET_CONSTRAINT);\n        newDistributionPeriod.fundsAvailable  = SafeCast.toUint128(gbc);\n\n        // decrease the treasury by the amount that is held for allocation in the new distribution period\n        treasury -= gbc;\n\n        emit QuarterlyDistributionStarted(\n            newDistributionId_,\n            startBlock,\n            endBlock\n        );\n    }\n\n    /**************************************************/\n    /*** Distribution Management Functions Internal ***/\n    /**************************************************/\n\n    /**\n     * @notice Get the block number at which this distribution period's challenge stage ends.\n     * @param  endBlock_ The end block of quarterly distribution to get the challenge stage end block for.\n     * @return The block number at which this distribution period's challenge stage ends.\n    */\n    function _getChallengeStageEndBlock(\n        uint256 endBlock_\n    ) internal pure returns (uint256) {\n        return endBlock_ + CHALLENGE_PERIOD_LENGTH;\n    }\n\n    /**\n     * @notice Get the block number at which this distribution period's screening stage ends.\n     * @param  endBlock_ The end block of quarterly distribution to get the screening stage end block for.\n     * @return The block number at which this distribution period's screening stage ends.\n    */\n    function _getScreeningStageEndBlock(\n        uint256 endBlock_\n    ) internal pure returns (uint256) {\n        return endBlock_ - FUNDING_PERIOD_LENGTH;\n    }\n\n    /**\n     * @notice Updates Treasury with surplus funds from distribution.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length of at most 10.\n     * @param distributionId_ distribution Id of updating distribution \n     */\n    function _updateTreasury(\n        uint24 distributionId_\n    ) private {\n        bytes32 fundedSlateHash = _distributions[distributionId_].fundedSlateHash;\n        uint256 fundsAvailable  = _distributions[distributionId_].fundsAvailable;\n\n        uint256[] memory fundingProposalIds = _fundedProposalSlates[fundedSlateHash];\n\n        uint256 totalTokensRequested;\n        uint256 numFundedProposals = fundingProposalIds.length;\n\n        for (uint i = 0; i < numFundedProposals; ) {\n            Proposal memory proposal = _standardFundingProposals[fundingProposalIds[i]];\n\n            totalTokensRequested += proposal.tokensRequested;\n\n            unchecked { ++i; }\n        }\n\n        // readd non distributed tokens to the treasury\n        treasury += (fundsAvailable - totalTokensRequested);\n\n        _isSurplusFundsUpdated[distributionId_] = true;\n    }\n\n    /**\n     * @notice Set a new DistributionPeriod Id.\n     * @dev    Increments the previous Id nonce by 1.\n     * @return newId_ The new distribution period Id.\n     */\n    function _setNewDistributionId() private returns (uint24 newId_) {\n        newId_ = _currentDistributionId += 1;\n    }\n\n    /************************************/\n    /*** Delegation Rewards Functions ***/\n    /************************************/\n\n    /// @inheritdoc IStandardFunding\n    function claimDelegateReward(\n        uint24 distributionId_\n    ) external override returns(uint256 rewardClaimed_) {\n        // Revert if delegatee didn't vote in screening stage\n        if(screeningVotesCast[distributionId_][msg.sender] == 0) revert DelegateRewardInvalid();\n\n        QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];\n\n        // Check if Challenge Period is still active\n        if(block.number < _getChallengeStageEndBlock(currentDistribution.endBlock)) revert ChallengePeriodNotEnded();\n\n        // check rewards haven't already been claimed\n        if(hasClaimedReward[distributionId_][msg.sender]) revert RewardAlreadyClaimed();\n\n        QuadraticVoter memory voter = _quadraticVoters[distributionId_][msg.sender];\n\n        // calculate rewards earned for voting\n        rewardClaimed_ = _getDelegateReward(currentDistribution, voter);\n\n        hasClaimedReward[distributionId_][msg.sender] = true;\n\n        emit DelegateRewardClaimed(\n            msg.sender,\n            distributionId_,\n            rewardClaimed_\n        );\n\n        // transfer rewards to delegatee\n        IERC20(ajnaTokenAddress).safeTransfer(msg.sender, rewardClaimed_);\n    }\n\n    /**\n     * @notice Calculate the delegate rewards that have accrued to a given voter, in a given distribution period.\n     * @dev    Voter must have voted in both the screening and funding stages, and is proportional to their share of votes across the stages.\n     * @param  currentDistribution_ Struct of the distribution period to calculat rewards for.\n     * @param  voter_               Struct of the funding stages voter.\n     * @return rewards_             The delegate rewards accrued to the voter.\n     */\n    function _getDelegateReward(\n        QuarterlyDistribution memory currentDistribution_,\n        QuadraticVoter memory voter_\n    ) internal pure returns (uint256 rewards_) {\n        // calculate the total voting power available to the voter that was allocated in the funding stage\n        uint256 votingPowerAllocatedByDelegatee = voter_.votingPower - voter_.remainingVotingPower;\n\n        // if none of the voter's voting power was allocated, they receive no rewards\n        if (votingPowerAllocatedByDelegatee == 0) return 0;\n\n        // calculate reward\n        // delegateeReward = 10 % of GBC distributed as per delegatee Voting power allocated\n        rewards_ = Maths.wdiv(\n            Maths.wmul(\n                currentDistribution_.fundsAvailable,\n                votingPowerAllocatedByDelegatee\n            ),\n            currentDistribution_.fundingVotePowerCast\n        ) / 10;\n    }\n\n    /***********************************/\n    /*** Proposal Functions External ***/\n    /***********************************/\n\n    /// @inheritdoc IStandardFunding\n    function updateSlate(\n        uint256[] calldata proposalIds_,\n        uint24 distributionId_\n    ) external override returns (bool newTopSlate_) {\n        QuarterlyDistribution storage currentDistribution = _distributions[distributionId_];\n\n        // store number of proposals for reduced gas cost of iterations\n        uint256 numProposalsInSlate = proposalIds_.length;\n\n        // check the each proposal in the slate is valid, and get the sum of the proposals fundingVotesReceived\n        uint256 sum = _validateSlate(distributionId_, currentDistribution.endBlock, currentDistribution.fundsAvailable, proposalIds_, numProposalsInSlate);\n\n        // get pointers for comparing proposal slates\n        bytes32 currentSlateHash = currentDistribution.fundedSlateHash;\n        bytes32 newSlateHash     = keccak256(abi.encode(proposalIds_));\n\n        // check if slate of proposals is better than the existing slate, and is thus the new top slate\n        newTopSlate_ = currentSlateHash == 0 ||\n            (currentSlateHash!= 0 && sum > _sumProposalFundingVotes(_fundedProposalSlates[currentSlateHash]));\n\n        // if slate of proposals is new top slate, update state\n        if (newTopSlate_) {\n            uint256[] storage existingSlate = _fundedProposalSlates[newSlateHash];\n\n            for (uint i = 0; i < numProposalsInSlate; ) {\n\n                // update list of proposals to fund\n                existingSlate.push(proposalIds_[i]);\n\n                unchecked { ++i; }\n            }\n\n            // update hash to point to the new leading slate of proposals\n            currentDistribution.fundedSlateHash = newSlateHash;\n\n            emit FundedSlateUpdated(\n                distributionId_,\n                newSlateHash\n            );\n        }\n    }\n\n    /// @inheritdoc IStandardFunding\n    function executeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_STANDARD, descriptionHash_)));\n        Proposal storage proposal = _standardFundingProposals[proposalId_];\n\n        uint24 distributionId = proposal.distributionId;\n\n        // check that the distribution period has ended, and one week has passed to enable competing slates to be checked\n        if (block.number <= _getChallengeStageEndBlock(_distributions[distributionId].endBlock)) revert ExecuteProposalInvalid();\n\n        // check proposal is succesful and hasn't already been executed\n        if (!_standardFundingVoteSucceeded(proposalId_) || proposal.executed) revert ProposalNotSuccessful();\n\n        proposal.executed = true;\n\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IStandardFunding\n    function proposeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_\n    ) external override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_STANDARD, keccak256(bytes(description_)))));\n\n        Proposal storage newProposal = _standardFundingProposals[proposalId_];\n\n        // check for duplicate proposals\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        QuarterlyDistribution memory currentDistribution = _distributions[_currentDistributionId];\n\n        // cannot add new proposal after end of screening period\n        // screening period ends 72000 blocks before end of distribution period, ~ 80 days.\n        if (block.number > _getScreeningStageEndBlock(currentDistribution.endBlock)) revert ScreeningPeriodEnded();\n\n        // store new proposal information\n        newProposal.proposalId      = proposalId_;\n        newProposal.distributionId  = currentDistribution.id;\n        newProposal.tokensRequested = _validateCallDatas(targets_, values_, calldatas_); // check proposal parameters are valid and update tokensRequested\n\n        // revert if proposal requested more tokens than are available in the distribution period\n        if (newProposal.tokensRequested > (currentDistribution.fundsAvailable * 9 / 10)) revert InvalidProposal();\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            currentDistribution.endBlock,\n            description_\n        );\n    }\n\n    /***********************************/\n    /*** Proposal Functions Internal ***/\n    /***********************************/\n\n    /**\n     * @notice Check the validity of a potential slate of proposals to execute, and sum the slate's fundingVotesReceived.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through both voting stages.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param  distributionId_                   Id of the distribution period to check the slate for.\n     * @param  endBlock                          End block of the distribution period.\n     * @param  distributionPeriodFundsAvailable_ Funds available for distribution in the distribution period.\n     * @param  proposalIds_                      Array of proposal Ids to check.\n     * @param  numProposalsInSlate_              Number of proposals in the slate.\n     * @return sum_                              The total funding votes received by all proposals in the proposed slate.\n     */\n    function _validateSlate(uint24 distributionId_, uint256 endBlock, uint256 distributionPeriodFundsAvailable_, uint256[] calldata proposalIds_, uint256 numProposalsInSlate_) internal view returns (uint256 sum_) {\n        // check that the function is being called within the challenge period\n        if (block.number <= endBlock || block.number > _getChallengeStageEndBlock(endBlock)) {\n            revert InvalidProposalSlate();\n        }\n\n        // check that the slate has no duplicates\n        if (_hasDuplicates(proposalIds_)) revert InvalidProposalSlate();\n\n        uint256 gbc = distributionPeriodFundsAvailable_;\n        uint256 totalTokensRequested = 0;\n\n        // check each proposal in the slate is valid\n        for (uint i = 0; i < numProposalsInSlate_; ) {\n            Proposal memory proposal = _standardFundingProposals[proposalIds_[i]];\n\n            // check if Proposal is in the topTenProposals list\n            if (_findProposalIndex(proposalIds_[i], _topTenProposals[distributionId_]) == -1) revert InvalidProposalSlate();\n\n            // account for fundingVotesReceived possibly being negative\n            if (proposal.fundingVotesReceived < 0) revert InvalidProposalSlate();\n\n            // update counters\n            sum_ += uint128(proposal.fundingVotesReceived); // since we are converting from int128 to uint128, we can safely assume that the value will not overflow\n            totalTokensRequested += proposal.tokensRequested;\n\n            // check if slate of proposals exceeded budget constraint ( 90% of GBC )\n            if (totalTokensRequested > (gbc * 9 / 10)) {\n                revert InvalidProposalSlate();\n            }\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Check an array of proposalIds for duplicate IDs.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through the screening round.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param  proposalIds_ Array of proposal Ids to check.\n     * @return Boolean indicating the presence of a duplicate. True if it has a duplicate; false if not.\n     */\n    function _hasDuplicates(\n        uint256[] calldata proposalIds_\n    ) internal pure returns (bool) {\n        uint256 numProposals = proposalIds_.length;\n\n        for (uint i = 0; i < numProposals; ) {\n            for (uint j = i + 1; j < numProposals; ) {\n                if (proposalIds_[i] == proposalIds_[j]) return true;\n\n                unchecked { ++j; }\n            }\n\n            unchecked { ++i; }\n\n        }\n        return false;\n    }\n\n    /**\n     * @notice Calculates the sum of funding votes allocated to a list of proposals.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through the screening round.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length of at most 10.\n     * @param  proposalIdSubset_ Array of proposal Ids to sum.\n     * @return sum_ The sum of the funding votes across the given proposals.\n     */\n    function _sumProposalFundingVotes(\n        uint256[] memory proposalIdSubset_\n    ) internal view returns (uint128 sum_) {\n        for (uint i = 0; i < proposalIdSubset_.length;) {\n            // since we are converting from int128 to uint128, we can safely assume that the value will not overflow\n            sum_ += uint128(_standardFundingProposals[proposalIdSubset_[i]].fundingVotesReceived);\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _standardProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        Proposal memory proposal = _standardFundingProposals[proposalId_];\n\n        if (proposal.executed)                                                     return ProposalState.Executed;\n        else if (_distributions[proposal.distributionId].endBlock >= block.number) return ProposalState.Active;\n        else if (_standardFundingVoteSucceeded(proposalId_))                      return ProposalState.Succeeded;\n        else                                                                       return ProposalState.Defeated;\n    }\n\n    /*********************************/\n    /*** Voting Functions External ***/\n    /*********************************/\n\n    /// @inheritdoc IStandardFunding\n    function fundingVote(\n        FundingVoteParams[] memory voteParams_\n    ) external override returns (uint256 votesCast_) {\n        uint24 currentDistributionId = _currentDistributionId;\n\n        QuarterlyDistribution storage currentDistribution = _distributions[currentDistributionId];\n        QuadraticVoter        storage voter               = _quadraticVoters[currentDistributionId][msg.sender];\n\n        uint256 endBlock = currentDistribution.endBlock;\n\n        uint256 screeningStageEndBlock = _getScreeningStageEndBlock(endBlock);\n\n        // check that the funding stage is active\n        if (block.number <= screeningStageEndBlock || block.number > endBlock) revert InvalidVote();\n\n        uint128 votingPower = voter.votingPower;\n\n        // if this is the first time a voter has attempted to vote this period,\n        // set initial voting power and remaining voting power\n        if (votingPower == 0) {\n\n            // calculate the voting power available to the voting power in this funding stage\n            uint128 newVotingPower = SafeCast.toUint128(_getVotesFunding(msg.sender, votingPower, voter.remainingVotingPower, screeningStageEndBlock));\n\n            voter.votingPower          = newVotingPower;\n            voter.remainingVotingPower = newVotingPower;\n        }\n\n        uint256 numVotesCast = voteParams_.length;\n\n        for (uint256 i = 0; i < numVotesCast; ) {\n            Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n\n            // check that the proposal is part of the current distribution period\n            if (proposal.distributionId != currentDistributionId) revert InvalidVote();\n\n            // check that the proposal being voted on is in the top ten screened proposals\n            if (_findProposalIndex(voteParams_[i].proposalId, _topTenProposals[currentDistributionId]) == -1) revert InvalidVote();\n\n            // cast each successive vote\n            votesCast_ += _fundingVote(\n                currentDistribution,\n                proposal,\n                msg.sender,\n                voter,\n                voteParams_[i]\n            );\n\n            unchecked { ++i; }\n        }\n    }\n\n    /// @inheritdoc IStandardFunding\n    function screeningVote(\n        ScreeningVoteParams[] memory voteParams_\n    ) external override returns (uint256 votesCast_) {\n        QuarterlyDistribution memory currentDistribution = _distributions[_currentDistributionId];\n\n        // check screening stage is active\n        if (block.number < currentDistribution.startBlock || block.number > _getScreeningStageEndBlock(currentDistribution.endBlock)) revert InvalidVote();\n\n        uint256 numVotesCast = voteParams_.length;\n\n        for (uint256 i = 0; i < numVotesCast; ) {\n            Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n\n            // check that the proposal is part of the current distribution period\n            if (proposal.distributionId != currentDistribution.id) revert InvalidVote();\n\n            uint256 votes = voteParams_[i].votes;\n\n            // cast each successive vote\n            votesCast_ += votes;\n            _screeningVote(msg.sender, proposal, votes);\n\n            unchecked { ++i; }\n        }\n    }\n\n    /*********************************/\n    /*** Voting Functions Internal ***/\n    /*********************************/\n\n    /**\n     * @notice Vote on a proposal in the funding stage of the Distribution Period.\n     * @dev    Votes can be allocated to multiple proposals, quadratically, for or against.\n     * @param  currentDistribution_  The current distribution period.\n     * @param  proposal_             The current proposal being voted upon.\n     * @param  account_              The voting account.\n     * @param  voter_                The voter data struct tracking available votes.\n     * @param  voteParams_           The amount of votes being allocated to the proposal. Not squared. If less than 0, vote is against.\n     * @return incrementalVotesUsed_ The amount of funding stage votes allocated to the proposal.\n     */\n    function _fundingVote(\n        QuarterlyDistribution storage currentDistribution_,\n        Proposal storage proposal_,\n        address account_,\n        QuadraticVoter storage voter_,\n        FundingVoteParams memory voteParams_\n    ) internal returns (uint256 incrementalVotesUsed_) {\n        uint8  support = 1;\n        uint256 proposalId = proposal_.proposalId;\n\n        // determine if voter is voting for or against the proposal\n        voteParams_.votesUsed < 0 ? support = 0 : support = 1;\n\n        uint128 votingPower = voter_.votingPower;\n\n        // the total amount of voting power used by the voter before this vote executes\n        uint128 voterPowerUsedPreVote = votingPower - voter_.remainingVotingPower;\n\n        FundingVoteParams[] storage votesCast = voter_.votesCast;\n\n        // check that the voter hasn't already voted on a proposal by seeing if it's already in the votesCast array \n        int256 voteCastIndex = _findProposalIndexOfVotesCast(proposalId, votesCast);\n\n        // voter had already cast a funding vote on this proposal\n        if (voteCastIndex != -1) {\n            // since we are converting from int256 to uint256, we can safely assume that the value will not overflow\n            FundingVoteParams storage existingVote = votesCast[uint256(voteCastIndex)];\n\n            // can't change the direction of a previous vote\n            if (support == 0 && existingVote.votesUsed > 0 || support == 1 && existingVote.votesUsed < 0) {\n                // if the vote is in the opposite direction of a previous vote,\n                // and the proposal is already in the votesCast array, revert can't change direction\n                revert FundingVoteWrongDirection();\n            }\n            else {\n                // update the votes cast for the proposal\n                existingVote.votesUsed += voteParams_.votesUsed;\n            }\n        }\n        // first time voting on this proposal, add the newly cast vote to the voter's votesCast array\n        else {\n            votesCast.push(voteParams_);\n        }\n\n        // calculate the cumulative cost of all votes made by the voter\n        // and check that attempted votes cast doesn't overflow uint128\n        uint256 sumOfTheSquareOfVotesCast = _sumSquareOfVotesCast(votesCast);\n        if (sumOfTheSquareOfVotesCast > type(uint128).max) revert InsufficientVotingPower();\n        uint128 cumulativeVotePowerUsed = SafeCast.toUint128(sumOfTheSquareOfVotesCast);\n\n        // check that the voter has enough voting power remaining to cast the vote\n        if (cumulativeVotePowerUsed > votingPower) revert InsufficientVotingPower();\n\n        // update voter voting power accumulator\n        voter_.remainingVotingPower = votingPower - cumulativeVotePowerUsed;\n\n        // calculate the change in voting power used by the voter in this vote in order to accurately track the total voting power used in the funding stage\n        // since we are moving from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 incrementalVotingPowerUsed = uint256(cumulativeVotePowerUsed - voterPowerUsedPreVote);\n\n        // update accumulator for total voting power used in the funding stage in order to calculate delegate rewards\n        currentDistribution_.fundingVotePowerCast += incrementalVotingPowerUsed;\n\n        // update proposal vote tracking\n        proposal_.fundingVotesReceived += SafeCast.toInt128(voteParams_.votesUsed);\n\n        // the incremental additional votes cast on the proposal to be used as a return value and emit value\n        incrementalVotesUsed_ = SafeCast.toUint256(Maths.abs(voteParams_.votesUsed));\n\n        // emit VoteCast instead of VoteCastWithParams to maintain compatibility with Tally\n        // emits the amount of incremental votes cast for the proposal, not the voting power cost or total votes on a proposal\n        emit VoteCast(\n            account_,\n            proposalId,\n            support,\n            incrementalVotesUsed_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Vote on a proposal in the screening stage of the Distribution Period.\n     * @param account_  The voting account.\n     * @param proposal_ The current proposal being voted upon.\n     * @param votes_    The amount of votes being cast.\n     */\n    function _screeningVote(\n        address account_,\n        Proposal storage proposal_,\n        uint256 votes_\n    ) internal {\n        uint24 distributionId = proposal_.distributionId;\n\n        // check that the voter has enough voting power to cast the vote\n        if (screeningVotesCast[distributionId][account_] + votes_ > _getVotesScreening(distributionId, account_)) revert InsufficientVotingPower();\n\n        uint256[] storage currentTopTenProposals = _topTenProposals[distributionId];\n        uint256 proposalId = proposal_.proposalId;\n\n        // update proposal votes counter\n        proposal_.votesReceived += SafeCast.toUint128(votes_);\n\n        // check if proposal was already screened\n        int indexInArray = _findProposalIndex(proposalId, currentTopTenProposals);\n        uint256 screenedProposalsLength = currentTopTenProposals.length;\n\n        // check if the proposal should be added to the top ten list for the first time\n        if (screenedProposalsLength < 10 && indexInArray == -1) {\n            currentTopTenProposals.push(proposalId);\n\n            // sort top ten proposals\n            _insertionSortProposalsByVotes(currentTopTenProposals, screenedProposalsLength);\n        }\n        else {\n            // proposal is already in the array\n            if (indexInArray != -1) {\n                // re-sort top ten proposals to account for new vote totals\n                _insertionSortProposalsByVotes(currentTopTenProposals, uint256(indexInArray));\n            }\n            // proposal isn't already in the array\n            else if(_standardFundingProposals[currentTopTenProposals[screenedProposalsLength - 1]].votesReceived < proposal_.votesReceived) {\n                // replace the least supported proposal with the new proposal\n                currentTopTenProposals.pop();\n                currentTopTenProposals.push(proposalId);\n\n                // sort top ten proposals"
    }
  ]
}