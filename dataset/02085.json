{
  "Title": "H-20: Unpaid funding fees from wrong calculation are going to be substracted from the pool",
  "Content": "# Issue H-20: Unpaid funding fees from wrong calculation are going to be substracted from the pool \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/67 \n\n## Found by \nstopthecap\n\n## Summary\n\nThe vulnerability start at the function getNextFundingAmountPerSize:\n\n https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L912\n\nBasically, GMX is handling incorrectly the way on how they calculate the FundingFees to be paid because they calculate the amount using the `getOpenInterest` from both the short and long tokens.\n\n\n## Vulnerability Detail\n\nThe detailed issue here is that GMX is incorrectly handling the calculation with the `getOpenInterest`  (the open Interest) of the two tokens, short and long.  They are dividing the `cache.fundingUsd`  for the interest of the two tokens:\n\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L953-L957\n\nAfter dividing, you get the `cache.fundingUsdForLongCollateral` which is basically the amount that has to be paid or paidTo for any of both collaterals and positions.\n\nThat is a big problem in one case, when users need to pay those feed. When the user does have to pay the fundingFees. Because customers can only pay  those fundingFees for their collateral token, not for both.\n\nAs said, this is not an issue when users do receive the fundingFees because you can claim both tokens, but it is an issue when paying the fees.\n\nThis will result in less fundingFees being paid by users.\n\n## Impact\n2 Impacts:\n\n1:\nA missmatch in the pools accounting will occur over time which might have unexpected results in terms of insolvency's.\n\n2:\nHigh because users are not paying the fees that they should pay, so there is an economic damage. Specifically because the bug just described, does reduce the variable `fundingAmountPerSizePortion` : \n\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L963-L966\n\nwhich is what user pays for the collateral token.   As said before, the amounts are being divided by the entire interest, therefore, just a small part only a portion of the FundingFees will be paid, meanwhile the entire amount can be claimed.\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L912-L1013\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe way on how the funding fees are calculate for users that have to pay them has to change in a way that it is not calculated accounting all the open interest. The calculation of the funding fees for users that have to claim fundingFees, not necessarily has to change.\n\n\n\n## Discussion\n\n**0xffff11**\n\nEscalate for 10 USDC\n\n\nIssue is completely valid as a solo high. I see that my phrasing was not very clear which brought the issue to be excluded. \n\nThe problem here is that when calculating `getNextFundingAmountPerSize`   both  amount per size portion for long and short tokens are accounted https://github.com/sherlock-audit/2023-02-gmx/blob/b8f926738d1e2f4ec1173939caa51698f2c89631/gmx-synthetics/contracts/market/MarketUtils.sol#L953-L954\n\nThose fundingAmounts for long and short tokens are divided by the entire open interest:\n\ncache.fundingUsdForShortCollateral = cache.fundingUsd * cache.oi.shortOpenInterestWithShortCollateral / cache.oi.shortOpenInterest;\n\nThere are 2 scenarios for these:\n\n1\nUser are paid those fees, in which they would be paid entirely, because they are able to clame both, long and short tokens\n\n2\nUser has to pay those funding fees. Users are only able to pay the `fundingAmountPerSizePortion` for their collateral token instead of both tokens, which reduces drastically the amount of `fundingAmountPerSizePortion` that the user will actually pay.\n\nTo sum up. Not all the fees will be paid because you can only pay `fundingAmountPerSizePortion` for your collateral token, but actually all the `fundingAmountPerSizePortion`  can be claimed.\n\n\nTo sum up the  `getNextFundingAmountPerSize` needs to differenciate calculations from those 2 cases to actually work as intended.\n\nAs the issue enables paying less fees for portions because it is being used the entire open interest for calculation, there is an economic damage, therefore is a high\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> \n> Issue is completely valid as a solo high. I see that my phrasing was not very clear which brought the issue to be excluded. \n> \n> The problem here is that when calculating `getNextFundingAmountPerSize`   both  amount per size portion for long and short tokens are accounted https://github.com/sherlock-audit/2023-02-gmx/blob/b8f926738d1e2f4ec1173939caa51698f2c89631/gmx-synthetics/contracts/market/MarketUtils.sol#L953-L954\n> \n> Those fundingAmounts for long and short tokens are divided by the entire open interest:\n> \n> cache.fundingUsdForShortCollateral = cache.fundingUsd * cache.oi.shortOpenInterestWithShortCollateral / cache.oi.shortOpenInterest;\n> \n> There are 2 scenarios for these:\n> \n> 1\n> User are paid those fees, in which they would be paid entirely, because they are able to clame both, long and short tokens\n> \n> 2\n> User has to pay those funding fees. Users are only able to pay the `fundingAmountPerSizePortion` for their collateral token instead of both tokens, which reduces drastically the amount of `fundingAmountPerSizePortion` that the user will actually pay.\n> \n> To sum up. Not all the fees will be paid because you can only pay `fundingAmountPerSizePortion` for your collateral token, but actually all the `fundingAmountPerSizePortion`  can be claimed.\n> \n> \n> To sum up the  `getNextFundingAmountPerSize` needs to differenciate calculations from those 2 cases to actually work as intended.\n> \n> As the issue enables paying less fees for portions because it is being used the entire open interest for calculation, there is an economic damage, therefore is a high\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nI'm having a hard time parsing what is being said, but it sounds like the submitter is worried that there won't be enough tokens to pay out funding fees until fees are deducted from actual positions. If that's what's being claimed, the way this is prevented is by having a [reserved amount](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L1169-L1171) which has to be satisfied by depositors before any position increase is allowed. @xvi10 can you take a look and see if I'm missing something, or if the description of the issue is more clear to you?\n\n**xvi10**\n\nit seems to be a valid issue, i think the issue described is the same as MKTU-2 of https://github.com/GuardianAudits/Audits/blob/main/GMX/GMX_Synthetics_Audit_3.pdf\n\n**IllIllI000**\n\nI agree that this is the same issue described by MKTU-2, but I'm still not seeing what the problem is. `getNextFundingAmountPerSize()` updates the global information about funding for a market's collateral, not the funding fees for a specific position. I don't see any mathematical error in dividing by `cache.oi.longOpenInterest` since it equals `cache.oi.longOpenInterestWithLongCollateral + cache.oi.longOpenInterestWithShortCollateral`. The actual deduction of the funding fees is done separately in [`getFundingFees()`](https://github.com/sherlock-audit/2023-02-gmx/blob/b8f926738d1e2f4ec1173939caa51698f2c89631/gmx-synthetics/contracts/pricing/PositionPricingUtils.sol#L417-L444), where fees are deducted from the collateral held by the position. For example, if user A is long, user B is short with short collat, and user C is short with long collat, and the shorts have to pay longs, A claims collateral that B and C will pay their tokens for. As I mentioned above, user A can't create an OI position until market LPs have added enough tokens to cover any potential gains/losses, and this is enforced by 'reserved amount' checks during increases, decreases, and swaps. @xvi10, am I misunderstanding something here? Do you have access to the POC provided in MKTU-2? Can you provide it, e.g. in a gist so I can see what the exploit is?\n\n**xvi10**\n\nthe PoC:\n\n```\nimport { expect } from \"chai\";\n\nimport { deployFixture } from \"../../../utils/fixture\";\nimport { expandDecimals, decimalToFloat } from \"../../../utils/math\";\nimport { getPoolAmount, getSwapImpactPoolAmount, getMarketTokenPrice } from \"../../../utils/market\";\nimport { handleDeposit, getDepositCount } from \"../../../utils/deposit\";\nimport { OrderType, getOrderCount, getOrderKeys, createOrder, executeOrder, handleOrder } from \"../../../utils/order\";\nimport { getPositionCount, getAccountPositionCount, getPositionKeys } from \"../../../utils/position\";\nimport { mine, time } from \"@nomicfoundation/hardhat-network-helpers\";\nimport * as keys from \"../../../utils/keys\";\n\ndescribe(\"Guardian.MKTU-2\", () => {\n  const { provider } = ethers;\n\n  let fixture;\n  let user0, user1, user2, user3;\n  let reader,\n    dataStore,\n    oracle,\n    depositVault,\n    ethUsdMarket,\n    ethUsdSpotOnlyMarket,\n    wnt,\n    wbtc,\n    usdc,\n    attackContract,\n    exchangeRouter,\n    eventEmitter,\n    ethEthMarket,\n    solEthEthMarket,\n    wbtcEthEthMarket;\n  let executionFee;\n  beforeEach(async () => {\n    fixture = await deployFixture();\n\n    ({ user0, user1, user2, user3 } = fixture.accounts);\n    ({\n      reader,\n      dataStore,\n      oracle,\n      depositVault,\n      ethUsdMarket,\n      ethUsdSpotOnlyMarket,\n      wnt,\n      wbtc,\n      usdc,\n      attackContract,\n      exchangeRouter,\n      eventEmitter,\n      ethEthMarket,\n      solEthEthMarket,\n      wbtcEthEthMarket,\n    } = fixture.contracts);\n    ({ executionFee } = fixture.props);\n\n    await handleDeposit(fixture, {\n      create: {\n        market: ethUsdMarket,\n        longTokenAmount: expandDecimals(1000, 18),\n        shortTokenAmount: expandDecimals(1000 * 5000, 6),\n      },\n    });\n    await handleDeposit(fixture, {\n      create: {\n        market: ethUsdSpotOnlyMarket,\n        longTokenAmount: expandDecimals(10000000, 18),\n        shortTokenAmount: expandDecimals(1000000 * 5000, 6),\n      },\n    });\n  });\n\n  it(\"CRITICAL: More claimable funding fees then paid\", async () => {\n    await dataStore.setUint(keys.fundingFactorKey(ethUsdMarket.marketToken), decimalToFloat(1, 7));\n    await dataStore.setUint(keys.fundingExponentFactorKey(ethUsdMarket.marketToken), decimalToFloat(1));\n\n    // User0 MarketIncrease long position with long collateral for $100K\n    await handleOrder(fixture, {\n      create: {\n        account: user0,\n        market: ethUsdMarket,\n        initialCollateralToken: wnt,\n        initialCollateralDeltaAmount: expandDecimals(10, 18), // $50,000 in 10 ETH\n        swapPath: [],\n        sizeDeltaUsd: decimalToFloat(100 * 1000), // 2x Position\n        acceptablePrice: expandDecimals(5000, 12),\n        executionFee: expandDecimals(1, 15),\n        minOutputAmount: 0,\n        orderType: OrderType.MarketIncrease,\n        isLong: true,\n        shouldUnwrapNativeToken: false,\n      },\n    });\n\n    // User1 MarketIncrease short position with short collateral for $100K\n    await handleOrder(fixture, {\n      create: {\n        account: user1,\n        market: ethUsdMarket,\n        initialCollateralToken: usdc,\n        initialCollateralDeltaAmount: expandDecimals(50 * 1000, 6), // $50,000\n        swapPath: [],\n        sizeDeltaUsd: decimalToFloat(100 * 1000), // 2x Position\n        acceptablePrice: expandDecimals(5000, 12),\n        executionFee: expandDecimals(1, 15),\n        minOutputAmount: 0,\n        orderType: OrderType.MarketIncrease,\n        isLong: false,\n        shouldUnwrapNativeToken: false,\n      },\n    });\n\n    // User2 MarketIncrease short position with long collateral for $100K\n    await handleOrder(fixture, {\n      create: {\n        account: user2,\n        market: ethUsdMarket,\n        initialCollateralToken: wnt,\n        initialCollateralDeltaAmount: expandDecimals(10, 18), // $50,000\n        swapPath: [],\n        sizeDeltaUsd: decimalToFloat(100 * 1000), // 2x Position\n        acceptablePrice: expandDecimals(5000, 12),\n        executionFee: expandDecimals(1, 15),\n        minOutputAmount: 0,\n        orderType: OrderType.MarketIncrease,\n        isLong: false,\n        shouldUnwrapNativeToken: false,\n      },\n    });\n\n    // User3 MarketIncrease long with short collateral for $100K\n    await handleOrder(fixture, {\n      create: {\n        account: user3,\n        market: ethUsdMarket,\n        initialCollateralToken: usdc,\n        initialCollateralDeltaAmount: expandDecimals(100 * 1000, 6), // $100,000\n        swapPath: [],\n        sizeDeltaUsd: decimalToFloat(200 * 1000), // 2x Position\n        acceptablePrice: expandDecimals(5000, 12),\n        executionFee: expandDecimals(1, 15),\n        minOutputAmount: 0,\n        orderType: OrderType.MarketIncrease,\n        isLong: true,\n        shouldUnwrapNativeToken: false,\n      },\n    });\n\n    // Check that everyone has a position open\n    expect(await getAccountPositionCount(dataStore, user0.address)).eq(1);\n    expect(await getAccountPositionCount(dataStore, user1.address)).eq(1);\n    expect(await getAccountPositionCount(dataStore, user2.address)).eq(1);\n    expect(await getAccountPositionCount(dataStore, user3.address)).eq(1);\n    expect(await getPositionCount(dataStore)).eq(4);\n\n    // 300 days later\n    await time.increase(300 * 24 * 60 * 60);\n\n    const prices = {\n      indexTokenPrice: {\n        min: expandDecimals(5000, 12),\n        max: expandDecimals(5000, 12),\n      },\n      longTokenPrice: {\n        min: expandDecimals(5000, 12),\n        max: expandDecimals(5000, 12),\n      },\n      shortTokenPrice: {\n        min: expandDecimals(1, 24),\n        max: expandDecimals(1, 24),\n      },\n    };\n\n    const positionKeys = await getPositionKeys(dataStore, 0, 10);\n    const user0Position = await reader.getPositionInfo(dataStore.address, positionKeys[0], prices);\n    const user3Position = await reader.getPositionInfo(dataStore.address, positionKeys[3], prices);\n\n    // Total WNT FoundingFees paid by User0\n    const totalWNTFeesPaidByUser0 = await user0Position.pendingFundingFees.fundingFeeAmount;\n\n    // Total USDC FoundingFees paid by User3\n    const totalUSDCFeesPaidByUser3 = await user3Position.pendingFundingFees.fundingFeeAmount;\n\n    expect(await getOrderCount(dataStore)).to.eq(0);\n    expect(await wnt.balanceOf(user0.address)).to.eq(0);\n    expect(await wnt.balanceOf(user1.address)).to.eq(0);\n    expect(await wnt.balanceOf(user2.address)).to.eq(0);\n    expect(await wnt.balanceOf(user3.address)).to.eq(0);\n    expect(await usdc.balanceOf(user0.address)).to.eq(0);\n    expect(await usdc.balanceOf(user1.address)).to.eq(0);\n    expect(await usdc.balanceOf(user2.address)).to.eq(0);\n    expect(await usdc.balanceOf(user3.address)).to.eq(0);\n\n    // User0 MarketDecrease for the whole position size\n    await handleOrder(fixture, {\n      create: {\n        account: user0,\n        market: ethUsdMarket,\n        initialCollateralToken: wnt,\n        initialCollateralDeltaAmount: expandDecimals(10, 18), // $50,000\n        swapPath: [],\n        sizeDeltaUsd: decimalToFloat(100 * 1000), // 2x Position\n        acceptablePrice: expandDecimals(5000, 12),\n        executionFee: expandDecimals(1, 15),\n        minOutputAmount: 0,\n        orderType: OrderType.MarketDecrease,\n        isLong: true,\n        shouldUnwrapNativeToken: false,\n      },\n    });\n\n    // User1 MarketDecrease for the whole position size\n    await handleOrder(fixture, {\n      create: {\n        account: user1,\n        market: ethUsdMarket,\n        initialCollateralToken: usdc,\n        initialCollateralDeltaAmount: expandDecimals(50 * 1000, 6), // $50,000\n        swapPath: [],\n        sizeDeltaUsd: decimalToFloat(100 * 1000), // 2x Position\n        acceptablePrice: expandDecimals(5000, 12),\n        executionFee: expandDecimals(1, 15),\n        minOutputAmount: 0,\n        orderType: OrderType.MarketDecrease,\n        isLong: false,\n        shouldUnwrapNativeToken: false,\n      },\n    });\n\n    // User2 MarketDecrease for the whole position size\n    await handleOrder(fixture, {\n      create: {\n        account: user2,\n        market: ethUsdMarket,\n        initialCollateralToken: wnt,\n        initialCollateralDeltaAmount: expandDecimals(10, 18), // $50,000\n        swapPath: [],\n        sizeDeltaUsd: decimalToFloat(100 * 1000), // 2x Position\n        acceptablePrice: expandDecimals(5000, 12),\n        executionFee: expandDecimals(1, 15),\n        minOutputAmount: 0,\n        orderType: OrderType.MarketDecrease,\n        isLong: false,\n        shouldUnwrapNativeToken: false,\n      },\n    });\n\n    // User3 MarketDecrease for the whole position size\n    await handleOrder(fixture, {\n      create: {\n        account: user3,\n        market: ethUsdMarket,\n        initialCollateralToken: usdc,\n        initialCollateralDeltaAmount: expandDecimals(100 * 1000, 6), // $100,000\n        swapPath: [],\n        sizeDeltaUsd: decimalToFloat(200 * 1000), // 2x Position\n        acceptablePrice: expandDecimals(5000, 12),\n        executionFee: expandDecimals(1, 15),\n        minOutputAmount: 0,\n        orderType: OrderType.MarketDecrease,\n        isLong: true,\n        shouldUnwrapNativeToken: false,\n      },\n    });\n\n    // Check total wnt funding fees paid by User0\n    expect(totalWNTFeesPaidByUser0).eq(\"3455997333333400000\");\n\n    // Check total usdc funding fees paid by User3\n    expect(totalUSDCFeesPaidByUser3).eq(\"69120000000\");\n\n    // Check User1's claimable funding fees\n    expect(\n      await dataStore.getUint(keys.claimableFundingAmountKey(ethUsdMarket.marketToken, wnt.address, user1.address))\n    ).to.eq(\"5183999266666700000\");\n    expect(\n      await dataStore.getUint(keys.claimableFundingAmountKey(ethUsdMarket.marketToken, usdc.address, user1.address))\n    ).to.eq(\"51840000000\");\n\n    // Check User2's claimable funding fees\n    expect(\n      await dataStore.getUint(keys.claimableFundingAmountKey(ethUsdMarket.marketToken, wnt.address, user2.address))\n    ).to.eq(\"5183999266666700000\");\n    expect(\n      await dataStore.getUint(keys.claimableFundingAmountKey(ethUsdMarket.marketToken, usdc.address, user2.address))\n    ).to.eq(\"51840000000\");\n\n    // Check User0 has less balance than initially, e.g. User0 paid funding fees in WNT\n    expect(await wnt.balanceOf(user0.address)).to.lt(expandDecimals(10, 18));\n\n    // Check User3 has less balance than initially, e.g. User3 paid funding fees in USDC\n    expect(await usdc.balanceOf(user3.address)).to.lt(expandDecimals(1000 * 1000, 6));\n\n    // First we'll showcase that there is more WNT funding fee to be claimed the being paid, under that test we'll showcase that there is more USDC funding fee to be claimed then being paid\n\n    // TEST more claimable WNT funding fees then paid\n    const totalFeeAmountPaidWNT = BigInt(totalWNTFeesPaidByUser0);\n\n    // Get total of claimable funding fees from User1 and User2\n    const claimableWNTUser1 = await dataStore.getUint(\n      keys.claimableFundingAmountKey(ethUsdMarket.marketToken, wnt.address, user1.address)\n    );\n    const claimableWNTUser2 = await dataStore.getUint(\n      keys.claimableFundingAmountKey(ethUsdMarket.marketToken, wnt.address, user2.address)\n    );\n    const totalClaimableFeesWNT = BigInt(claimableWNTUser1) + BigInt(claimableWNTUser2);\n\n    // When funding fees are paid by the long side, each token per size value is divided amongst the total long open interest, but not every long position is capable of paying out the fees for either collateral tokens\n\n    // Check that the total amount of fees claimable is more the total fees paid\n    expect(totalClaimableFeesWNT).to.gt(totalFeeAmountPaidWNT);\n\n    // TEST more claimable USDC funding fees then paid\n    const totalFeeAmountPaidUSDC = BigInt(totalUSDCFeesPaidByUser3);\n\n    // Get total of claimable funding fees from User1 and User2\n    const claimableUSDCUser1 = await dataStore.getUint(\n      keys.claimableFundingAmountKey(ethUsdMarket.marketToken, usdc.address, user1.address)\n    );\n    const claimableUSDCUser2 = await dataStore.getUint(\n      keys.claimableFundingAmountKey(ethUsdMarket.marketToken, usdc.address, user2.address)\n    );\n    const totalClaimableFeesUSDC = BigInt(claimableUSDCUser1) + BigInt(claimableUSDCUser2);\n\n    // When funding fees are paid by the short side, each token per size value is divided amongst the total short open interest, but not every short position is capable of paying out the fees for either collateral tokens\n\n    // Check that the total amount of fees claimable is more the the total fees paid\n    expect(totalClaimableFeesUSDC).to.gt(totalFeeAmountPaidUSDC);\n\n    // Check there is no open positions\n    expect(await getAccountPositionCount(dataStore, user0.address)).eq(0);\n    expect(await getAccountPositionCount(dataStore, user1.address)).eq(0);\n    expect(await getAccountPositionCount(dataStore, user2.address)).eq(0);\n    expect(await getAccountPositionCount(dataStore, user3.address)).eq(0);\n    expect(await getPositionCount(dataStore)).eq(0);\n  });\n});```\n\n**IllIllI000**\n\nWhile the title of the issue, and the non-code parts of the summary are correct, the vulnerability detail and part of the impact are not correct. As I described above, there is no mathematical issue with the area of the code that the submitter links to, and the actual funding calculation is done elsewhere as I mention. However, there _is_ still an adjustment needed in the per-size values, which is described in MKTU-2, but is not described in this submission. Essentially, while the full open interest division is correct, that amount is later converted to per-share units, which should have taken into account the collateral of the position, so that when it's multiplied later in `getFundingFees()`, we get the right amount. As is seen in the fix applied by the sponsor, the area of the code that the submitter points to [remains unmodified](https://github.com/gmx-io/gmx-synthetics/blob/e6102b306d0488ba3dd71facd53bea4df74987db/contracts/market/MarketUtils.sol#L1047-L1051), and the adjustment that MKTU-2 describes is done [later](https://github.com/gmx-io/gmx-synthetics/blob/e6102b306d0488ba3dd71facd53bea4df74987db/contracts/market/MarketUtils.sol#L1062-L1064). The patch I'm providing below shows that only the MKTU-2 adjustment is needed in order for the `distribute short` amounts to match the `pay short` amount (I commented out the long portion of the test, because including both makes the test run into contract size issues):\n\n```diff\ndiff --git a/gmx-synthetics/contracts/market/MarketUtils.sol b/gmx-synthetics/contracts/market/MarketUtils.sol\nindex 7624b69..70399b2 100644\n--- a/gmx-synthetics/contracts/market/MarketUtils.sol\n+++ b/gmx-synthetics/contracts/market/MarketUtils.sol\n@@ -960,12 +960,15 @@ library MarketUtils {\n         // use Precision.FLOAT_PRECISION here because fundingUsdForLongCollateral or fundingUsdForShortCollateral divided by longTokenPrice\n         // will give an amount in number of tokens which may be quite a small value and could become zero after being divided by longOpenInterest\n         // the result will be the amount in number of tokens multiplied by Precision.FLOAT_PRECISION per 1 USD of size\n-        cache.fps.fundingAmountPerSizePortion_LongCollateral_LongPosition = getPerSizeValue(cache.fundingUsdForLongCollateral / prices.longTokenPrice.max, cache.oi.longOpenInterest);\n+        //cache.fps.fundingAmountPerSizePortion_LongCollateral_LongPosition = getPerSizeValue(cache.fundingUsdForLongCollateral / prices.longTokenPrice.max, cache.oi.longOpenInterest);\n         cache.fps.fundingAmountPerSizePortion_LongCollateral_ShortPosition = getPerSizeValue(cache.fundingUsdForLongCollateral / prices.longTokenPrice.max, cache.oi.shortOpenInterest);\n-        cache.fps.fundingAmountPerSizePortion_ShortCollateral_LongPosition = getPerSizeValue(cache.fundingUsdForShortCollateral / prices.shortTokenPrice.max, cache.oi.longOpenInterest);\n+        //cache.fps.fundingAmountPerSizePortion_ShortCollateral_LongPosition = getPerSizeValue(cache.fundingUsdForShortCollateral / prices.shortTokenPrice.max, cache.oi.longOpenInterest);\n         cache.fps.fundingAmountPerSizePortion_ShortCollateral_ShortPosition = getPerSizeValue(cache.fundingUsdForShortCollateral / prices.shortTokenPrice.max, cache.oi.shortOpenInterest);\n-\n+\t\n         if (result.longsPayShorts) {\n+\t    cache.fps.fundingAmountPerSizePortion_LongCollateral_LongPosition = getPerSizeValue(cache.fundingUsdForLongCollateral / prices.longTokenPrice.max, cache.oi.longOpenInterestWithLongCollateral);\n+\t    cache.fps.fundingAmountPerSizePortion_ShortCollateral_LongPosition = getPerSizeValue(cache.fundingUsdForShortCollateral / prices.shortTokenPrice.max, cache.oi.longOpenInterestWithShortCollateral);\n+\n             // longs pay shorts\n             result.fundingAmountPerSize_LongCollateral_LongPosition = Calc.boundedAdd(\n                 result.fundingAmountPerSize_LongCollateral_LongPosition,\n@@ -987,6 +990,9 @@ library MarketUtils {\n                 cache.fps.fundingAmountPerSizePortion_ShortCollateral_ShortPosition.toInt256()\n             );\n         } else {\n+\t    //cache.fps.fundingAmountPerSizePortion_LongCollateral_ShortPosition = getPerSizeValue(cache.fundingUsdForLongCollateral / prices.longTokenPrice.max, cache.oi.shortOpenInterestWithLongCollateral);\n+\t    //cache.fps.fundingAmountPerSizePortion_ShortCollateral_ShortPosition = getPerSizeValue(cache.fundingUsdForShortCollateral / prices.shortTokenPrice.max, cache.oi.shortOpenInterestWithShortCollateral);\n+\n             // shorts pay longs\n             result.fundingAmountPerSize_LongCollateral_LongPosition = Calc.boundedSub(\n                 result.fundingAmountPerSize_LongCollateral_LongPosition,\ndiff --git a/gmx-synthetics/contracts/pricing/PositionPricingUtils.sol b/gmx-synthetics/contracts/pricing/PositionPricingUtils.sol\nindex c274e48..d807bae 100644\n--- a/gmx-synthetics/contracts/pricing/PositionPricingUtils.sol\n+++ b/gmx-synthetics/contracts/pricing/PositionPricingUtils.sol\n@@ -13,7 +13,7 @@ import \"./PricingUtils.sol\";\n \n import \"../referral/IReferralStorage.sol\";\n import \"../referral/ReferralUtils.sol\";\n-\n+import \"hardhat/console.sol\";\n // @title PositionPricingUtils\n // @dev Library for position pricing functions\n library PositionPricingUtils {\n@@ -405,7 +405,7 @@ library PositionPricingUtils {\n         address shortToken,\n         int256 latestLongTokenFundingAmountPerSize,\n         int256 latestShortTokenFundingAmountPerSize\n-    ) internal pure returns (PositionFundingFees memory) {\n+    ) internal view returns (PositionFundingFees memory) {\n         PositionFundingFees memory fundingFees;\n \n         fundingFees.latestLongTokenFundingAmountPerSize = latestLongTokenFundingAmountPerSize;\n@@ -425,24 +425,36 @@ library PositionPricingUtils {\n             position.shortTokenFundingAmountPerSize(),\n             position.sizeInUsd()\n         );\n-\n+console.log(\"sender: \", tx.origin);\n+//console.log(\"  fundingAPS long\");\n+//console.logInt(latestLongTokenFundingAmountPerSize);\n+console.log(\"  fundingAPS short\");\n+console.logInt(latestShortTokenFundingAmountPerSize);\n+//console.log(\"  long: \");\n+//console.logInt(longTokenFundingFeeAmount);\n+console.log(\"  short:\");\n+console.logInt(shortTokenFundingFeeAmount);\n         // if the position has negative funding fees, distribute it to allow it to be claimable\n         if (longTokenFundingFeeAmount < 0) {\n             fundingFees.claimableLongTokenAmount = (-longTokenFundingFeeAmount).toUint256();\n+//console.log(\"  distribute long\");\n         }\n \n         if (shortTokenFundingFeeAmount < 0) {\n             fundingFees.claimableShortTokenAmount = (-shortTokenFundingFeeAmount).toUint256();\n+console.log(\"  distribute short\");\n         }\n \n         if (position.collateralToken() == longToken && longTokenFundingFeeAmount > 0) {\n             fundingFees.fundingFeeAmount = longTokenFundingFeeAmount.toUint256();\n+//console.log(\"  pay long\");\n         }\n \n         if (position.collateralToken() == shortToken && shortTokenFundingFeeAmount > 0) {\n             fundingFees.fundingFeeAmount = shortTokenFundingFeeAmount.toUint256();\n+console.log(\"  pay short\");\n         }\n-\n+console.log(\"end\\n\");\n         return fundingFees;\n     }\n \n```\n\noutput:\n```text\n...\nsender:  0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\n  fundingAPS short\n10368\n  short:\n1036800000\nend\n\nsender:  0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\n  fundingAPS short\n-10368\n  short:\n-1036800000\n  distribute short\nend\n\nsender:  0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\n  fundingAPS short\n-10368\n  short:\n-1036800000\n  distribute short\nend\n\nsender:  0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\n  fundingAPS short\n10368\n  short:\n2073600000\n  pay short\nend\n...\n```\n\n`-1036800000 + -1036800000 + 2073600000 = 0`\n\nIf there had been another submission in the contest where I could have marked this as a duplicate, I would have done so, so I'm leaning towards this being a valid High. However, because the submission did not actually identify the right problem and didn't provide any test showing that they weren't just guessing that there was _some sort of_ problem in this area, I'm not sure if this qualifies for a solo high, and will leave the decision to the Sherlock team\n\n**IllIllI000**\n\nUpon further inspection, I believe that there is another submission that is describing the MKTU-2 issue correctly, and that's #109. In the section they label with `Calculate nextFundingAmountPerSize:`, they properly include the per-size adjustment, and they properly trace propagation of the incomplete adjustment from `updateFundingAmountPerSize()` to the later call to `getPositionFees()`. They don't explicitly say that the issue is with the per-size adjustment, but the math they provide shows that the amount paid is not the same as the amount withdrawn. Again, this current issue doesn't properly describe the area of the problem, so I would say that it's either a duplicate of #109, or invalid\n\n**xvi10**\n\ni don't think it is the same issue as https://github.com/sherlock-audit/2023-02-gmx-judging/issues/109, the issue in 109 is due to rounding i believe\n\nfor this issue, the description is correct, i think the code referenced in \"https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L963-L966\" is to describe that the incorrect calculation affects these variables\n\nthe Code Snippet covers the code that should be updated\n\n\n\n**IllIllI000**\n\n@xvi10, just so I understand what you're saying about this current issue, do you agree that I've described the shortcomings of this finding correctly, but disagree that it should be invalid, or are you saying something else? With the fix to the area of the code that you changed, are you seeing some other issue not covered by the test?\n\nSeparately, for 109, can you elaborate on how/where it's due to rounding, and point to the change you've made in the code to address it?\n\n**xvi10**\n\ni think that the issue should be valid\n\nthe issue mentioned:\n\n\"High because users are not paying the fees that they should pay, so there is an economic damage. Specifically because the bug just described, does reduce the variable fundingAmountPerSizePortion :\n\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L963-L966\"\n\nthe reporter mentions that the fundingAmountPerSizePortion values will be affected which is correct\n\nfor 109, the fix for the rounding issue: https://github.com/gmx-io/gmx-synthetics/commit/8e5c776546b1eb3da46ae824119f6c797354a640\n\n**IllIllI000**\n\nThey do mention `fundingAmountPerSizePortion`, but the adjustment is in each `fundingAmountPerSizePortion_*Collateral_*Position`, not in the raw `fundingAmountPerSizePortion`. They do mention a problem that ended up being shown to be valid, and I believe that by the Sherlock rules, it doesn't matter that it may not have described every aspect, and it should count as a High\n\nFor 109 can you point to where in the issue they refer to a rounding issue, or what step of the math shows it?\n\n**xvi10**\n\nfor 109, they don't mention it as a rounding issue, but i believe the difference in amount paid vs amount claimed can be fixed by fixing the rounding \n\n**IllIllI000**\n\n@xvi10 Why is it not the same issue as the one described here? Wouldn't their tracing of the various calls made in this issue point to the same issue? What in their description made it seem like a rounding issue instead? Their submission doesn't men",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/market/MarketUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../bank/StrictBank.sol\";\n\nimport \"./Market.sol\";\nimport \"./MarketToken.sol\";\nimport \"./MarketEventUtils.sol\";\nimport \"./MarketStoreUtils.sol\";\n\nimport \"../position/Position.sol\";\nimport \"../order/Order.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../price/Price.sol\";\n\nimport \"../utils/Calc.sol\";\nimport \"../utils/Precision.sol\";\n\n// @title MarketUtils\n// @dev Library for market functions\nlibrary MarketUtils {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    using Market for Market.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev struct to store the prices of tokens of a market\n    // @param indexTokenPrice price of the market's index token\n    // @param longTokenPrice price of the market's long token\n    // @param shortTokenPrice price of the market's short token\n    struct MarketPrices {\n        Price.Props indexTokenPrice;\n        Price.Props longTokenPrice;\n        Price.Props shortTokenPrice;\n    }\n\n    // @dev struct for the result of the getNextFundingAmountPerSize call\n    // @param longsPayShorts whether longs pay shorts or shorts pay longs\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding amount per\n    // size for users with a long position using long collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding amount per\n    // size for users with a short position using long collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding amount per\n    // size for users with a long position using short collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding amount per\n    // size for users with a short position using short collateral\n    struct GetNextFundingAmountPerSizeResult {\n        bool longsPayShorts;\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n    }\n\n    // @dev struct to avoid stack too deep errors for the getPoolValue call\n    // @param value the pool value\n    // @param longTokenAmount the amount of long token in the pool\n    // @param shortTokenAmount the amount of short token in the pool\n    // @param longTokenUsd the USD value of the long tokens in the pool\n    // @param shortTokenUsd the USD value of the short tokens in the pool\n    // @param totalBorrowingFees the total pending borrowing fees for the market\n    // @param borrowingFeeReceiverFactor the fee receiver factor for borrowing fees\n    // @param impactPoolAmount the amount of tokens in the impact pool\n    // @param longPnl the pending pnl of long positions\n    // @param shortPnl the pending pnl of short positions\n    // @param netPnl the net pnl of long and short positions\n    struct GetPoolValueCache {\n        uint256 value;\n\n        uint256 longTokenAmount;\n        uint256 shortTokenAmount;\n        uint256 longTokenUsd;\n        uint256 shortTokenUsd;\n\n        uint256 totalBorrowingFees;\n        uint256 borrowingFeeReceiverFactor;\n\n        uint256 impactPoolAmount;\n        int256 longPnl;\n        int256 shortPnl;\n        int256 netPnl;\n    }\n\n    // @dev GetNextFundingAmountPerSizeCache struct used in getNextFundingAmountPerSize\n    // to avoid stack too deep errors\n    //\n    // @param durationInSeconds duration in seconds since the last funding update\n    //\n    // @param diffUsd the absolute difference in long and short open interest for the market\n    // @param totalOpenInterest the total long and short open interest for the market\n    // @param fundingUsd the funding amount in USD\n    //\n    // @param fundingUsdForLongCollateral the funding amount in USD for positions using the long token as collateral\n    // @param fundingUsdForShortCollateral the funding amount in USD for positions using the short token as collateral\n    struct GetNextFundingAmountPerSizeCache {\n        GetNextFundingAmountPerSizeOpenInterestCache oi;\n        GetNextFundingAmountPerSizeFundingPerSizeCache fps;\n\n        uint256 durationInSeconds;\n\n        uint256 diffUsd;\n        uint256 totalOpenInterest;\n        uint256 sizeOfLargerSide;\n        uint256 fundingFactorPerSecond;\n        uint256 fundingUsd;\n\n        uint256 fundingUsdForLongCollateral;\n        uint256 fundingUsdForShortCollateral;\n    }\n\n    // @param longOpenInterestWithLongCollateral amount of long open interest using the long token as collateral\n    // @param longOpenInterestWithShortCollateral amount of long open interest using the short token as collateral\n    // @param shortOpenInterestWithLongCollateral amount of short open interest using the long token as collateral\n    // @param shortOpenInterestWithShortCollateral amount of short open interest using the short token as collateral\n    //\n    // @param longOpenInterest total long open interest for the market\n    // @param shortOpenInterest total short open interest for the market\n    struct GetNextFundingAmountPerSizeOpenInterestCache {\n        uint256 longOpenInterestWithLongCollateral;\n        uint256 longOpenInterestWithShortCollateral;\n        uint256 shortOpenInterestWithLongCollateral;\n        uint256 shortOpenInterestWithShortCollateral;\n\n        uint256 longOpenInterest;\n        uint256 shortOpenInterest;\n    }\n\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding per size for longs using the long token as collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding per size for shorts using the long token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding per size for longs using the short token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding per size for shorts using the short token as collateral\n    //\n    // @param fundingAmountPerSizePortion_LongCollateral_LongPosition the next funding amount per size for longs using the long token as collateral\n    // @param fundingAmountPerSizePortion_LongCollateral_ShortPosition the next funding amount per size for longs using the short token as collateral\n    // @param fundingAmountPerSizePortion_ShortCollateral_LongPosition the next funding amount per size for shorts using the long token as collateral\n    // @param fundingAmountPerSizePortion_ShortCollateral_ShortPosition the next funding amount per size for shorts using the short token as collateral\n    struct GetNextFundingAmountPerSizeFundingPerSizeCache {\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n\n        uint256 fundingAmountPerSizePortion_LongCollateral_LongPosition;\n        uint256 fundingAmountPerSizePortion_ShortCollateral_LongPosition;\n        uint256 fundingAmountPerSizePortion_LongCollateral_ShortPosition;\n        uint256 fundingAmountPerSizePortion_ShortCollateral_ShortPosition;\n    }\n\n    error EmptyMarket();\n    error DisabledMarket(address market);\n    error InsufficientPoolAmount(uint256 poolAmount, uint256 amount);\n    error InsufficientReserve(uint256 reservedUsd, uint256 maxReservedUsd);\n    error UnexpectedPoolValueForTokenPriceCalculation(int256 poolValue);\n    error UnexpectedSupplyForTokenPriceCalculation();\n    error UnableToGetOppositeToken(address inputToken, address market);\n    error UnableToGetCachedTokenPrice(address token, address market);\n    error CollateralAlreadyClaimed(uint256 adjustedClaimableAmount, uint256 claimedAmount);\n    error OpenInterestCannotBeUpdatedForSwapOnlyMarket(address market);\n    error MaxOpenInterestExceeded(uint256 openInterest, uint256 maxOpenInterest);\n    error MaxPoolAmountExceeded(uint256 poolAmount, uint256 maxPoolAmount);\n    error UnexpectedBorrowingFactor(uint256 positionBorrowingFactor, uint256 cumulativeBorrowingFactor);\n    error UnableToGetBorrowingFactorEmptyPoolUsd();\n    error UnableToGetFundingFactorEmptyOpenInterest();\n    error InvalidPositionMarket(address market);\n    error InvalidCollateralTokenForMarket(address market, address token);\n    error PnlFactorExceededForLongs(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n    error PnlFactorExceededForShorts(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n\n    // @dev get the market token's price\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longTokenPrice the price of the long token\n    // @param shortTokenPrice the price of the short token\n    // @param indexTokenPrice the price of the index token\n    // @param maximize whether to maximize or minimize the market token price\n    // @return returns the market token's price\n    function getMarketTokenPrice(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        Price.Props memory indexTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 poolValue = getPoolValue(\n            dataStore,\n            market,\n            longTokenPrice,\n            shortTokenPrice,\n            indexTokenPrice,\n            pnlFactorType,\n            maximize\n        );\n\n        if (poolValue == 0) { return 0; }\n\n        if (poolValue < 0) {\n            revert UnexpectedPoolValueForTokenPriceCalculation(poolValue);\n        }\n\n        uint256 supply = getMarketTokenSupply(MarketToken(payable(market.marketToken)));\n\n        if (supply == 0) {\n            revert UnexpectedSupplyForTokenPriceCalculation();\n        }\n\n        return poolValue * Precision.WEI_PRECISION.toInt256() / supply.toInt256();\n    }\n\n    // @dev get the total supply of the marketToken\n    // @param marketToken the marketToken\n    // @return the total supply of the marketToken\n    function getMarketTokenSupply(MarketToken marketToken) internal view returns (uint256) {\n        return marketToken.totalSupply();\n    }\n\n    // @dev get the opposite token of the market\n    // if the inputToken is the longToken return the shortToken and vice versa\n    // @param inputToken the input token\n    // @param market the market values\n    // @return the opposite token\n    function getOppositeToken(address inputToken, Market.Props memory market) internal pure returns (address) {\n        if (inputToken == market.longToken) {\n            return market.shortToken;\n        }\n\n        if (inputToken == market.shortToken) {\n            return market.longToken;\n        }\n\n        revert UnableToGetOppositeToken(inputToken, market.marketToken);\n    }\n\n    // @dev get the token price from the stored MarketPrices\n    // @param token the token to get the price for\n    // @param the market values\n    // @param the market token prices\n    // @return the token price from the stored MarketPrices\n    function getCachedTokenPrice(address token, Market.Props memory market, MarketPrices memory prices) internal pure returns (Price.Props memory) {\n        if (token == market.longToken) {\n            return prices.longTokenPrice;\n        }\n        if (token == market.shortToken) {\n            return prices.shortTokenPrice;\n        }\n        if (token == market.indexToken) {\n            return prices.indexTokenPrice;\n        }\n\n        revert UnableToGetCachedTokenPrice(token, market.marketToken);\n    }\n\n    // @dev return the latest prices for the market tokens\n    // the secondary price for market.indexToken is overwritten for certain order\n    // types, use this value instead of the primary price for positions\n    // @param oracle Oracle\n    // @param market the market values\n    function getMarketPricesForPosition(Oracle oracle, Market.Props memory market) internal view returns (MarketPrices memory) {\n        return MarketPrices(\n            oracle.getLatestPrice(market.indexToken),\n            oracle.getLatestPrice(market.longToken),\n            oracle.getLatestPrice(market.shortToken)\n        );\n    }\n\n    // @dev return the primary prices for the market tokens\n    // @param oracle Oracle\n    // @param market the market values\n    function getMarketPrices(Oracle oracle, Market.Props memory market) internal view returns (MarketPrices memory) {\n        return MarketPrices(\n            oracle.getPrimaryPrice(market.indexToken),\n            oracle.getPrimaryPrice(market.longToken),\n            oracle.getPrimaryPrice(market.shortToken)\n        );\n    }\n\n    // @dev get the usd value of either the long or short tokens in the pool\n    // without accounting for the pnl of open positions\n    // @param dataStore DataStore\n    // @param market the market values\n    // @param prices the prices of the market tokens\n    // @param whether to return the value for the long or short token\n    // @return the usd value of either the long or short tokens in the pool\n    function getPoolUsdWithoutPnl(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketPrices memory prices,\n        bool isLong\n    ) internal view returns (uint256) {\n        address token = isLong ? market.longToken : market.shortToken;\n        uint256 poolAmount = getPoolAmount(dataStore, market.marketToken, token);\n        uint256 tokenPrice = isLong ? prices.longTokenPrice.min : prices.shortTokenPrice.min;\n        return poolAmount * tokenPrice;\n    }\n\n    // @dev get the USD value of a pool\n    // the value of a pool is the worth of the liquidity provider tokens in the pool - pending trader pnl\n    // we use the token index prices to calculate this and ignore price impact since if all positions were closed the\n    // net price impact should be zero\n    // @param dataStore DataStore\n    // @param market the market values\n    // @param longTokenPrice price of the long token\n    // @param shortTokenPrice price of the short token\n    // @param indexTokenPrice price of the index token\n    // @param maximize whether to maximize or minimize the pool value\n    // @return the USD value of a pool\n    function getPoolValue(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        Price.Props memory indexTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) internal view returns (int256) {\n        GetPoolValueCache memory cache;\n\n        cache.longTokenAmount = getPoolAmount(dataStore, market.marketToken, market.longToken);\n        cache.shortTokenAmount = getPoolAmount(dataStore, market.marketToken, market.shortToken);\n\n        cache.longTokenUsd = cache.longTokenAmount * longTokenPrice.pickPrice(maximize);\n        cache.shortTokenUsd = cache.shortTokenAmount * shortTokenPrice.pickPrice(maximize);\n\n        cache.value = cache.longTokenUsd + cache.shortTokenUsd;\n\n        cache.totalBorrowingFees = getTotalBorrowingFees(dataStore, market.marketToken, market.longToken, market.shortToken, true);\n        cache.totalBorrowingFees += getTotalBorrowingFees(dataStore, market.marketToken, market.longToken, market.shortToken, false);\n\n        cache.borrowingFeeReceiverFactor = dataStore.getUint(Keys.BORROWING_FEE_RECEIVER_FACTOR);\n        cache.value += Precision.applyFactor(cache.totalBorrowingFees, cache.borrowingFeeReceiverFactor);\n\n        cache.impactPoolAmount = getPositionImpactPoolAmount(dataStore, market.marketToken);\n        cache.value += cache.impactPoolAmount * indexTokenPrice.pickPrice(maximize);\n\n        // !maximize should be used for net pnl as a larger pnl leads to a smaller pool value\n        // and a smaller pnl leads to a larger pool value\n\n        cache.longPnl = getPnl(\n            dataStore,\n            market.marketToken,\n            market.longToken,\n            market.shortToken,\n            indexTokenPrice,\n            true,\n            !maximize\n        );\n\n        cache.longPnl = getCappedPnl(\n            dataStore,\n            market.marketToken,\n            true,\n            cache.longPnl,\n            cache.longTokenUsd,\n            pnlFactorType\n        );\n\n        cache.shortPnl = getPnl(\n            dataStore,\n            market.marketToken,\n            market.longToken,\n            market.shortToken,\n            indexTokenPrice,\n            false,\n            !maximize\n        );\n\n        cache.shortPnl = getCappedPnl(\n            dataStore,\n            market.marketToken,\n            false,\n            cache.shortPnl,\n            cache.shortTokenUsd,\n            pnlFactorType\n        );\n\n        cache.netPnl = cache.longPnl + cache.shortPnl;\n\n        return Calc.sumReturnInt256(cache.value, -cache.netPnl);\n    }\n\n    // @dev get the net pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param maximize whether to maximize or minimize the net pnl\n    // @return the net pending pnl for a market\n    function getNetPnl(\n        DataStore dataStore,\n        address market,\n        address longToken,\n        address shortToken,\n        Price.Props memory indexTokenPrice,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 longPnl = getPnl(dataStore, market, longToken, shortToken, indexTokenPrice, true, maximize);\n        int256 shortPnl = getPnl(dataStore, market, longToken, shortToken, indexTokenPrice, false, maximize);\n\n        return longPnl + shortPnl;\n    }\n\n    // @dev get the capped pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param isLong whether to check for the long or short side\n    // @param pnl the uncapped pnl of the market\n    // @param poolUsd the USD value of the pool\n    // @param pnlFactorType the pnl factor type to use\n    function getCappedPnl(\n        DataStore dataStore,\n        address market,\n        bool isLong,\n        int256 pnl,\n        uint256 poolUsd,\n        bytes32 pnlFactorType\n    ) internal view returns (int256) {\n        if (pnl < 0) { return pnl; }\n\n        uint256 maxPnlFactor = getMaxPnlFactor(dataStore, pnlFactorType, market, isLong);\n        int256 maxPnl = Precision.applyFactor(poolUsd, maxPnlFactor).toInt256();\n\n        return pnl > maxPnl ? maxPnl : pnl;\n    }\n\n    // @dev get the pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param isLong whether to check for the long or short side\n    // @param maximize whether to maximize or minimize the pnl\n    function getPnl(\n        DataStore dataStore,\n        address market,\n        address longToken,\n        address shortToken,\n        uint256 indexTokenPrice,\n        bool isLong,\n        bool maximize\n    ) internal view returns (int256) {\n        Price.Props memory _indexTokenPrice = Price.Props(indexTokenPrice, indexTokenPrice);\n\n        return getPnl(\n            dataStore,\n            market,\n            longToken,\n            shortToken,\n            _indexTokenPrice,\n            isLong,\n            maximize\n        );\n    }\n\n    // @dev get the pending pnl for a market for either longs or shorts\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param isLong whether to get the pnl for longs or shorts\n    // @param maximize whether to maximize or minimize the net pnl\n    // @return the pending pnl for a market for either longs or shorts\n    function getPnl(\n        DataStore dataStore,\n        address market,\n        address longToken,\n        address shortToken,\n        Price.Props memory indexTokenPrice,\n        bool isLong,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 openInterest = getOpenInterest(dataStore, market, longToken, shortToken, isLong).toInt256();\n        uint256 openInterestInTokens = getOpenInterestInTokens(dataStore, market, longToken, shortToken, isLong);\n        if (openInterest == 0 || openInterestInTokens == 0) {\n            return 0;\n        }\n\n        uint256 price = indexTokenPrice.pickPriceForPnl(isLong, maximize);\n\n        // openInterest is the cost of all positions, openInterestValue is the current worth of all positions\n        int256 openInterestValue = (openInterestInTokens * price).toInt256();\n        int256 pnl = isLong ? openInterestValue - openInterest : openInterest - openInterestValue;\n\n        return pnl;\n    }\n\n    // @dev get the amount of tokens in the pool\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param token the token to check\n    // @return the amount of tokens in the pool\n    function getPoolAmount(DataStore dataStore, address market, address token) internal view returns (uint256) {\n        return dataStore.getUint(Keys.poolAmountKey(market, token));\n    }\n\n    // @dev get the max amount of tokens allowed to be in the pool\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param token the token to check\n    // @return the max amount of tokens that are allowed in the pool\n    function getMaxPoolAmount(DataStore dataStore, address market, address token) internal view returns (uint256) {\n        return dataStore.getUint(Keys.maxPoolAmountKey(market, token));\n    }\n\n    // @dev get the max open interest allowed for the market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param isLong whether this is for the long or short side\n    // @return the max open interest allowed for the market\n    function getMaxOpenInterest(DataStore dataStore, address market, bool isLong) internal view returns (uint256) {\n        return dataStore.getUint(Keys.maxOpenInterestKey(market, isLong));\n    }\n\n    // @dev increment the claimable collateral amount\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to increment the claimable collateral for\n    // @param token the claimable token\n    // @param account the account to increment the claimable collateral for\n    // @param delta the amount to increment\n    function incrementClaimableCollateralAmount(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        address account,\n        uint256 delta\n    ) internal {\n        uint256 divisor = dataStore.getUint(Keys.CLAIMABLE_COLLATERAL_TIME_DIVISOR);\n        uint256 timeKey = block.timestamp / divisor;\n\n        uint256 nextValue = dataStore.incrementUint(\n            Keys.claimableCollateralAmountKey(market, token, timeKey, account),\n            delta\n        );\n\n        MarketEventUtils.emitClaimableCollateralUpdated(eventEmitter, market, token, timeKey, account, delta, nextValue);\n    }\n\n    // @dev increment the claimable funding amount\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the trading market\n    // @param token the claimable token\n    // @param account the account to increment for\n    // @param delta the amount to increment\n    function incrementClaimableFundingAmount(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        address account,\n        uint256 delta\n    ) internal {\n        uint256 nextValue = dataStore.incrementUint(\n            Keys.claimableFundingAmountKey(market, token, account),\n            delta\n        );\n\n        MarketEventUtils.emitClaimableFundingUpdated(eventEmitter, market, token, account, delta, nextValue);\n    }\n\n    // @dev claim funding fees\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to claim for\n    // @param token the token to claim\n    // @param account the account to claim for\n    // @param receiver the receiver to send the amount to\n    function claimFundingFees(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        address account,\n        address receiver\n    ) internal {\n        bytes32 key = Keys.claimableFundingAmountKey(market, token, account);\n\n        uint256 claimableAmount = dataStore.getUint(key);\n        dataStore.setUint(key, 0);\n\n        MarketToken(payable(market)).transferOut(\n            token,\n            receiver,\n            claimableAmount\n        );\n\n        MarketEventUtils.emitFundingFeesClaimed(\n            eventEmitter,\n            market,\n            token,\n            account,\n            receiver,\n            claimableAmount\n        );\n    }\n\n    // @dev claim collateral\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to claim for\n    // @param token the token to claim\n    // @param account the account to claim for\n    // @param receiver the receiver to send the amount to\n    function claimCollateral(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        uint256 timeKey,\n        address account,\n        address receiver\n    ) internal {\n        uint256 claimableAmount = dataStore.getUint(Keys.claimableCollateralAmountKey(market, token, timeKey, account));\n        uint256 claimableFactor = dataStore.getUint(Keys.claimableCollateralFactorKey(market, token, timeKey, account));\n        uint256 claimedAmount = dataStore.getUint(Keys.claimedCollateralAmountKey(market, token, timeKey, account));\n\n        uint256 adjustedClaimableAmount = Precision.applyFactor(claimableAmount, claimableFactor);\n        if (adjustedClaimableAmount >= claimedAmount) {\n            revert CollateralAlreadyClaimed(adjustedClaimableAmount, claimedAmount);\n        }\n\n        uint256 remainingClaimableAmount = adjustedClaimableAmount - claimedAmount;\n\n        dataStore.setUint(\n            Keys.claimedCollateralAmountKey(market, token, timeKey, account),\n            adjustedClaimableAmount\n        );\n\n        MarketToken(payable(market)).transferOut(\n            token,\n            receiver,\n            remainingClaimableAmount\n        );\n\n        MarketEventUtils.emitCollateralClaimed(\n            eventEmitter,\n            market,\n            token,\n            timeKey,\n            account,\n            receiver,\n            remainingClaimableAmount\n        );\n    }\n\n    // @dev apply a delta to the pool amount\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to apply to\n    // @param token the token to apply to\n    // @param delta the delta amount\n    function applyDeltaToPoolAmount(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        int256 delta\n    ) internal returns (uint256) {\n        uint256 nextValue = dataStore.applyDeltaToUint(\n            Keys.poolAmountKey(market, token),\n            delta,\n            \"Invalid state, negative poolAmount\"\n        );\n\n        applyDeltaToVirtualInventoryForSwaps(\n            dataStore,\n            market,\n            token,\n            delta\n        );\n\n        MarketEventUtils.emitPoolAmountUpdated(eventEmitter, market, token, delta, nextValue);\n\n        return nextValue;\n    }\n\n    // @dev cap the input priceImpactUsd by the available amount in the position impact pool\n    // @param dataStore DataStore\n    // @param market the trading market\n    // @param tokenPrice the price of the token\n    // @param priceImpactUsd the calculated USD price impact\n    // @return the capped priceImpactUsd\n    function getCappedPositionImpactUsd(\n        DataStore dataStore,\n        address market,\n        Price.Props memory tokenPrice,\n        int256 priceImpactUsd,\n        uint256 sizeDeltaUsd\n    ) internal view returns (int256) {\n        if (priceImpactUsd < 0) {\n            return priceImpactUsd;\n        }\n\n        uint256 impactPoolAmount = getPositionImpactPoolAmount(dataStore, market);\n        int256 maxPriceImpactUsdBasedOnImpactPool = (impactPoolAmount * tokenPrice.min).toInt256();\n\n        if (priceImpactUsd > maxPriceImpactUsdBasedOnImpactPool) {\n            priceImpactUsd = maxPriceImpactUsdBasedOnImpactPool;\n        }\n\n        uint256 maxPriceImpactFactor = getMaxPositionImpactFactor(dataStore, market, true);\n        int256 maxPriceImpactUsdBasedOnMaxPriceImpactFactor = Precision.applyFactor(sizeDeltaUsd, maxPriceImpactFactor).toInt256();\n\n        if (priceImpactUsd > maxPriceImpactUsdBasedOnMaxPriceImpactFactor) {\n            priceImpactUsd = maxPriceImpactUsdBasedOnMaxPriceImpactFactor;\n        }\n\n        return priceImpactUsd;\n    }\n\n    // @dev get the position impact pool amount\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @return the position impact pool amount\n    function getPositionImpactPoolAmount(DataStore dataStore, address market) internal view returns (uint256) {\n        return dataStore.getUint(Keys.positionImpactPoolAmountKey(market));\n    }\n\n    // @dev get the swap impact pool amount\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param token the token to check\n    // @return the swap impact pool amount\n    function getSwapImpactPoolAmount(DataStore dataStore, address market, address token) internal view returns (uint256) {\n        return dataStore.getUint(Keys.swapImpactPoolAmountKey(market, token));\n    }\n\n    // @dev apply a delta to the swap impact pool\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to apply to\n    // @param token the token to apply to\n    // @param delta the delta amount\n    function applyDeltaToSwapImpactPool(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        int256 delta\n    ) internal returns (uint256) {\n        uint256 nextValue = dataStore.applyBoundedDeltaToUint(\n            Keys.swapImpactPoolAmountKey(market, token),\n            delta\n        );\n\n        MarketEventUtils.emitSwapImpactPoolAmountUpdated(eventEmitter, market, token, delta, nextValue);\n\n        return nextValue;\n    }\n\n    // @dev apply a delta to the position impact pool\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to apply to\n    // @param delta the delta amount\n    function applyDeltaToPositionImpactPool(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        int256 delta\n    ) internal returns (uint256) {\n        uint256 nextValue = dataStore.applyBoundedDeltaToUint(\n            Keys.positionImpactPoolAmountKey(market),\n            delta\n        );\n\n        MarketEventUtils.emitPositionImpactPoolAmountUpdated(eventEmitter, market, delta, nextValue);\n\n        return nextValue;\n    }\n\n    // @dev apply a delta to the open interest\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to apply to\n    // @param collateralToken the collateralToken to apply to\n    // @param isLong whether to apply to the long or short side\n    // @param delta the delta amount\n    function applyDeltaToOpenInterest(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address indexToken,\n        address collateralToken,\n        bool isLong,\n        int256 delta\n    ) internal returns (uint256) {\n        if (indexToken == address(0)) {\n            revert OpenInterestCannotBeUpdatedForSwapOnlyMarket(market);\n        }\n\n        uint256 nextValue = dataStore.applyDeltaToUint(\n            Keys.openInterestKey(market, collateralToken, isLong),\n            delta,\n            \"Invalid state: negative open interest\"\n        );\n\n        // if the open interest for longs is increased then tokens were virtually bought from the pool\n        // so the virtual inventory should be decreased\n        // if the open interest for longs is decreased then tokens were virtually sold to the pool\n        // so the virtual inventory should be increased\n        // if the open interest"
    }
  ]
}