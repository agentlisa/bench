{
  "Title": "[M-10] `ERC20TokenEmitter::buyToken` function mints more tokens to users than it should do",
  "Content": "\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L180> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L184> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L200-L215>\n\nUsers can buy governance tokens with the `ERC20TokenEmitter::buyToken()` function. In this protocol, governance token prices are determined by a linear [VRGDA](https://www.paradigm.xyz/2022/08/vrgda) calculation. The token price increases if the token supply is ahead of the schedule and decreases if it is behind the schedule.\n\nThere are also some other parameters I need to mention, which are [`creatorRateBps`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L42) and [`entropyRateBps`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L45).\n\n*   **creatorRateBps:** The portion that goes to the creator anytime a token is bought.\n\n*   **entropyRateBps:** The portion of the creator's cut that is paid directly as ETH. The remaining part of the creator's cut is used to buy governance tokens for the creator.\n\nFor example, if the creator rate is 10%, the entropy rate is 50%, and a user wants to buy 100 ETH worth of tokens:\\\n\\- Creator cut is 10 ETH\\\n\\- 5 ETH will be sent directly to the creator\\\n\\- The other 5 ETH will be used to buy governance tokens for the creator.\\\n\\- The user will get 90 ETH worth of governance tokens.\n\nThis is the main logic in the `ERC20TokenEmitter` contract.\n\nNow, let's examine the `buyToken` function:\\\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L152C3-L230C6>\n\n```solidity\n    function buyToken(\n        address[] calldata addresses,\n        uint[] calldata basisPointSplits,\n        ProtocolRewardAddresses calldata protocolRewardsRecipients\n    ) public payable nonReentrant whenNotPaused returns (uint256 tokensSoldWad) {\n        // ... some code\n\n        // Get value left after protocol rewards\n        uint256 msgValueRemaining = _handleRewardsAndGetValueToSend(\n            msg.value,\n            protocolRewardsRecipients.builder,\n            protocolRewardsRecipients.purchaseReferral,\n            protocolRewardsRecipients.deployer\n        );\n\n        //Share of purchase amount to send to treasury\n173.    uint256 toPayTreasury = (msgValueRemaining * (10_000 - creatorRateBps)) / 10_000;\n\n        //Share of purchase amount to reserve for creators\n        //Ether directly sent to creators\n177.    uint256 creatorDirectPayment = ((msgValueRemaining - toPayTreasury) * entropyRateBps) / 10_000;\n        //Tokens to emit to creators\n179.      int totalTokensForCreators = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment) > 0\n180.-->     ? getTokenQuoteForEther((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n            : int(0);\n\n        // Tokens to emit to buyers\n184.--> int totalTokensForBuyers = toPayTreasury > 0 ? getTokenQuoteForEther(toPayTreasury) : int(0); //@audit-issue tokensForCreators and tokensForBuyers are calculated separately based on their proportional ether payments. This breaks VRGDA logic because these separate calculation are both made according to the current token supply. These two calculations should not be independent of each other\n\n        //Transfer ETH to treasury and update emitted\n        emittedTokenWad += totalTokensForBuyers;\n        if (totalTokensForCreators > 0) emittedTokenWad += totalTokensForCreators;\n\n        //... rest of the code\n        // funds are transferred and these amounts are minted.\n    }\n```\n\nThis function:\n\n1.  Calculates buyers' ETH share in line 173.\n\n2.  Calculates direct ETH payment to creators in line 177.\n\n3.  Calculates token amount to mint for creators with the remaining ETH after direct payment in lines 179-180 using `getTokenQuoteForEther` function.\n\n4.  Calculates token amount to mint for buyers in line 184 using `getTokenQuoteForEther` function\n\n5.  After all of these calculations, it updates `emittedTokenWad` parameter.\n\nNow let's check the [`getTokenQuoteForEther`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L254C2-L264C6) function:\n\n```solidity\n    function getTokenQuoteForEther(uint256 etherAmount) public view returns (int gainedX) {\n        //...\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n-->             sold: emittedTokenWad, //@audit it uses current state variable\n                amount: int(etherAmount)\n            });\n    }\n```\n\nAs we can see in this function, how many governance tokens will be minted is calculated according to the current supply, which is `emittedTokenWad` parameter.\n\n**Alright, what is the issue?**\n\nThe issue is that both of the `totalTokensForCreators` and `totalTokensForBuyers` parameters are **separately** calculated like they are independent of each other, and the `emittedTokenWad` is updated after that. However, this situation breaks the VRGDA logic and more tokens are minted for the same amount of ETH.\n\nThese two calculations should not be independent. Total governance tokens to mint for the total ETH payment should be calculated first, and then the governance token amounts should be proportionally distributed.\n\nCalculating proportional ETH amounts for the buyer and the creator first, and then determining the corresponding governance tokens to mint separately, leads to a higher total number of governance tokens to be minted compared to calculating the total governance tokens required based on the overall ETH amounts to be paid.\n\n### Impact\n\n*   Protocol mints more governance tokens are minted than it should be.\n\n### Proof of Concept\n\n**Coded PoC**\n\nDown below you can find a basic PoC that proves calculating tokens to mint separately results in many more tokens than calculating it only once with total payment.\n\nYou can use the protocol's own setup to run this PoC\\\n\\-Copy and paste the snippet into the `ERC20TokenEmitter.t.sol` test file\\\n\\-Run it with `forge test --match-test testTokenQuoteForEther_is1plus1equal2 -vvv`\n\n```solidity\n    function testTokenQuoteForEther_is1plus1equal2() public {\n        int256 tokenToGetFor100ether = erc20TokenEmitter.getTokenQuoteForEther(100e18);\n        int256 tokenToGetFor500ether = erc20TokenEmitter.getTokenQuoteForEther(500e18);\n        int256 tokenToGetFor600ether = erc20TokenEmitter.getTokenQuoteForEther(600e18);\n\n        // Calculating mint amounts separately will result in minting much more tokens.\n        assertGt(tokenToGetFor100ether + tokenToGetFor500ether, tokenToGetFor600ether);\n        console2.log(\"current total: \", tokenToGetFor100ether + tokenToGetFor500ether);\n        console2.log(\"supposed total: \", tokenToGetFor600ether);\n    }\n```\n\nResults after running:\n\n```solidity\nRunning 1 test for test/token-emitter/ERC20TokenEmitter.t.sol:ERC20TokenEmitterTest\n[PASS] testTokenQuoteForEther_is1plus1equal2() (gas: 41635)\nLogs:\n  current total:  586751802158813828000\n  supposed total:  581798293495083372000\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 41.60ms.\n \nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests).\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nThere are two ways to resolve this issue. An unfair but much easier one, and the fair but not that easy one\n\n**Unfair One:**\\\nThe protocol team should decide which side (creators or buyers) will suffer from the unfairness, and update the `emittedTokenWad` in the middle of two calculations. The latter calculation will buy tokens at a higher price.\n\nIn the example below, the change is in favour of the creators. Buyers get tokens with updated prices to keep the VRGDA logic intact.\n\n```diff\n        //Tokens to emit to creators\n        int totalTokensForCreators = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment) > 0\n            ? getTokenQuoteForEther((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n            : int(0);\n\n+       // Moving this here will keep the VRGDA logic intact, and the calculation for buyers will be made with updated token supply.\n+       if (totalTokensForCreators > 0) emittedTokenWad += totalTokensForCreators;\n        \n        // Tokens to emit to buyers\n        int totalTokensForBuyers = toPayTreasury > 0 ? getTokenQuoteForEther(toPayTreasury) : int(0);\n\n        //Transfer ETH to treasury and update emitted\n        emittedTokenWad += totalTokensForBuyers;\n-       if (totalTokensForCreators > 0) emittedTokenWad += totalTokensForCreators;\n```\n\n**Fair One:**\\\nThis one requires a little more work but it is more fair. The function should:\n\n1.  Calculate the total ETH payment (creators + buyers) for the governance token purchase.\n\n2.  Calculate how many total governance tokens will be minted with this total ETH payment\n\n3.  Then mint proportional amounts to buyers and creators.\n\n**Example**:\n\n```solidity\n// Note: This is not diff. It is just an example\n\n// Creators ETH payment for purchase\nuint256 creatorsPayment = (msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n\n// Total ETH payment for purchase (toPayTreasury is already buyers payment)\nuint256 totalPayment = toPayTreasury + creatorsPayment;\n\n// Get total governance tokens to mint\nint totalGovernanceTokenAmount = getTokenQuoteForEther(totalPayment);\n\n// Calculate proportional governance token amounts.\n// Note: I didn't check this for rounding. Care should be taken if this method will be implemented\nint totalTokensForCreators = (totalGovernanceTokenAmount * creatorsPayment) / totalPayment;\nint totalTokensForBuyers = (totalGovernanceTokenAmount * toPayTreasury) / totalPayment;\n```\n\n**[rocketman-21 (Revolution) confirmed](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/194#issuecomment-1876087797)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/ERC20TokenEmitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { TokenEmitterRewards } from \"@collectivexyz/protocol-rewards/src/abstract/TokenEmitter/TokenEmitterRewards.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport { VRGDAC } from \"./libs/VRGDAC.sol\";\nimport { toDaysWadUnsafe } from \"./libs/SignedWadMath.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { NontransferableERC20Votes } from \"./NontransferableERC20Votes.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\ncontract ERC20TokenEmitter is\n    IERC20TokenEmitter,\n    ReentrancyGuardUpgradeable,\n    TokenEmitterRewards,\n    Ownable2StepUpgradeable,\n    PausableUpgradeable\n{\n    // treasury address to pay funds to\n    address public treasury;\n\n    // The token that is being minted.\n    NontransferableERC20Votes public token;\n\n    // The VRGDA contract\n    VRGDAC public vrgdac;\n\n    // solhint-disable-next-line not-rely-on-time\n    uint256 public startTime;\n\n    /**\n     * @notice A running total of the amount of tokens emitted.\n     */\n    int256 public emittedTokenWad;\n\n    // The split of the purchase that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The split of (purchase proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The account or contract to pay the creator reward to\n    address public creatorsAddress;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _protocolRewards The protocol rewards contract address\n    /// @param _protocolFeeRecipient The protocol fee recipient address\n    constructor(\n        address _manager,\n        address _protocolRewards,\n        address _protocolFeeRecipient\n    ) payable TokenEmitterRewards(_protocolRewards, _protocolFeeRecipient) initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the token emitter\n     * @param _initialOwner The initial owner of the token emitter\n     * @param _erc20Token The ERC-20 token contract address\n     * @param _vrgdac The VRGDA contract address\n     * @param _treasury The treasury address to pay funds to\n     * @param _creatorsAddress The address to pay the creator reward to\n     */\n    function initialize(\n        address _initialOwner,\n        address _erc20Token,\n        address _treasury,\n        address _vrgdac,\n        address _creatorsAddress\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        require(_treasury != address(0), \"Invalid treasury address\");\n\n        // Set up ownable\n        __Ownable_init(_initialOwner);\n\n        treasury = _treasury;\n        creatorsAddress = _creatorsAddress;\n        vrgdac = VRGDAC(_vrgdac);\n        token = NontransferableERC20Votes(_erc20Token);\n        startTime = block.timestamp;\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        token.mint(_to, _amount);\n    }\n\n    function totalSupply() public view returns (uint) {\n        // returns total supply issued so far\n        return token.totalSupply();\n    }\n\n    function decimals() public view returns (uint8) {\n        // returns decimals\n        return token.decimals();\n    }\n\n    function balanceOf(address _owner) public view returns (uint) {\n        // returns balance of address\n        return token.balanceOf(_owner);\n    }\n\n    /**\n     * @notice Pause the contract.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the token emitter.\n     * @dev This function can only be called by the owner when the\n     * contract is paused.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice A payable function that allows a user to buy tokens for a list of addresses and a list of basis points to split the token purchase between.\n     * @param addresses The addresses to send purchased tokens to.\n     * @param basisPointSplits The basis points of the purchase to send to each address.\n     * @param protocolRewardsRecipients The addresses to pay the builder, purchaseRefferal, and deployer rewards to\n     * @return tokensSoldWad The amount of tokens sold in wad units.\n     */\n    function buyToken(\n        address[] calldata addresses,\n        uint[] calldata basisPointSplits,\n        ProtocolRewardAddresses calldata protocolRewardsRecipients\n    ) public payable nonReentrant whenNotPaused returns (uint256 tokensSoldWad) {\n        //prevent treasury from paying itself\n        require(msg.sender != treasury && msg.sender != creatorsAddress, \"Funds recipient cannot buy tokens\");\n\n        require(msg.value > 0, \"Must send ether\");\n        // ensure the same number of addresses and bps\n        require(addresses.length == basisPointSplits.length, \"Parallel arrays required\");\n\n        // Get value left after protocol rewards\n        uint256 msgValueRemaining = _handleRewardsAndGetValueToSend(\n            msg.value,\n            protocolRewardsRecipients.builder,\n            protocolRewardsRecipients.purchaseReferral,\n            protocolRewardsRecipients.deployer\n        );\n\n        //Share of purchase amount to send to treasury\n        uint256 toPayTreasury = (msgValueRemaining * (10_000 - creatorRateBps)) / 10_000;\n\n        //Share of purchase amount to reserve for creators\n        //Ether directly sent to creators\n        uint256 creatorDirectPayment = ((msgValueRemaining - toPayTreasury) * entropyRateBps) / 10_000;\n        //Tokens to emit to creators\n        int totalTokensForCreators = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment) > 0\n            ? getTokenQuoteForEther((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n            : int(0);\n\n        // Tokens to emit to buyers\n        int totalTokensForBuyers = toPayTreasury > 0 ? getTokenQuoteForEther(toPayTreasury) : int(0);\n\n        //Transfer ETH to treasury and update emitted\n        emittedTokenWad += totalTokensForBuyers;\n        if (totalTokensForCreators > 0) emittedTokenWad += totalTokensForCreators;\n\n        //Deposit funds to treasury\n        (bool success, ) = treasury.call{ value: toPayTreasury }(new bytes(0));\n        require(success, \"Transfer failed.\");\n\n        //Transfer ETH to creators\n        if (creatorDirectPayment > 0) {\n            (success, ) = creatorsAddress.call{ value: creatorDirectPayment }(new bytes(0));\n            require(success, \"Transfer failed.\");\n        }\n\n        //Mint tokens for creators\n        if (totalTokensForCreators > 0 && creatorsAddress != address(0)) {\n            _mint(creatorsAddress, uint256(totalTokensForCreators));\n        }\n\n        uint256 bpsSum = 0;\n\n        //Mint tokens to buyers\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (totalTokensForBuyers > 0) {\n                // transfer tokens to address\n                _mint(addresses[i], uint256((totalTokensForBuyers * int(basisPointSplits[i])) / 10_000));\n            }\n            bpsSum += basisPointSplits[i];\n        }\n\n        require(bpsSum == 10_000, \"bps must add up to 10_000\");\n\n        emit PurchaseFinalized(\n            msg.sender,\n            msg.value,\n            toPayTreasury,\n            msg.value - msgValueRemaining,\n            uint256(totalTokensForBuyers),\n            uint256(totalTokensForCreators),\n            creatorDirectPayment\n        );\n\n        return uint256(totalTokensForBuyers);\n    }\n\n    /**\n     * @notice Returns the amount of wei that would be spent to buy an amount of tokens. Does not take into account the protocol rewards.\n     * @param amount the amount of tokens to buy.\n     * @return spentY The cost in wei of the token purchase.\n     */\n    function buyTokenQuote(uint256 amount) public view returns (int spentY) {\n        require(amount > 0, \"Amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.xToY({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(amount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for an amount of wei. Does not take into account the protocol rewards.\n     * @param etherAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForEther(uint256 etherAmount) public view returns (int gainedX) {\n        require(etherAmount > 0, \"Ether amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(etherAmount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for the payment amount, taking into account the protocol rewards.\n     * @param paymentAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForPayment(uint256 paymentAmount) external view returns (int gainedX) {\n        require(paymentAmount > 0, \"Payment amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(((paymentAmount - computeTotalReward(paymentAmount)) * (10_000 - creatorRateBps)) / 10_000)\n            });\n    }\n\n    /**\n     * @notice Set the split of (purchase * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        emit EntropyRateBpsUpdated(entropyRateBps = _entropyRateBps);\n    }\n\n    /**\n     * @notice Set the split of the payment that is reserved for creators in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n\n        emit CreatorRateBpsUpdated(creatorRateBps = _creatorRateBps);\n    }\n\n    /**\n     * @notice Set the creators address to pay the creatorRate to. Can be a contract.\n     * @dev Only callable by the owner.\n     */\n    function setCreatorsAddress(address _creatorsAddress) external override onlyOwner nonReentrant {\n        require(_creatorsAddress != address(0), \"Invalid address\");\n\n        emit CreatorsAddressUpdated(creatorsAddress = _creatorsAddress);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/ERC20TokenEmitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { TokenEmitterRewards } from \"@collectivexyz/protocol-rewards/src/abstract/TokenEmitter/TokenEmitterRewards.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport { VRGDAC } from \"./libs/VRGDAC.sol\";\nimport { toDaysWadUnsafe } from \"./libs/SignedWadMath.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { NontransferableERC20Votes } from \"./NontransferableERC20Votes.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\ncontract ERC20TokenEmitter is\n    IERC20TokenEmitter,\n    ReentrancyGuardUpgradeable,\n    TokenEmitterRewards,\n    Ownable2StepUpgradeable,\n    PausableUpgradeable\n{\n    // treasury address to pay funds to\n    address public treasury;\n\n    // The token that is being minted.\n    NontransferableERC20Votes public token;\n\n    // The VRGDA contract\n    VRGDAC public vrgdac;\n\n    // solhint-disable-next-line not-rely-on-time\n    uint256 public startTime;\n\n    /**\n     * @notice A running total of the amount of tokens emitted.\n     */\n    int256 public emittedTokenWad;\n\n    // The split of the purchase that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The split of (purchase proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The account or contract to pay the creator reward to\n    address public creatorsAddress;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _protocolRewards The protocol rewards contract address\n    /// @param _protocolFeeRecipient The protocol fee recipient address\n    constructor(\n        address _manager,\n        address _protocolRewards,\n        address _protocolFeeRecipient\n    ) payable TokenEmitterRewards(_protocolRewards, _protocolFeeRecipient) initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the token emitter\n     * @param _initialOwner The initial owner of the token emitter\n     * @param _erc20Token The ERC-20 token contract address\n     * @param _vrgdac The VRGDA contract address\n     * @param _treasury The treasury address to pay funds to\n     * @param _creatorsAddress The address to pay the creator reward to\n     */\n    function initialize(\n        address _initialOwner,\n        address _erc20Token,\n        address _treasury,\n        address _vrgdac,\n        address _creatorsAddress\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        require(_treasury != address(0), \"Invalid treasury address\");\n\n        // Set up ownable\n        __Ownable_init(_initialOwner);\n\n        treasury = _treasury;\n        creatorsAddress = _creatorsAddress;\n        vrgdac = VRGDAC(_vrgdac);\n        token = NontransferableERC20Votes(_erc20Token);\n        startTime = block.timestamp;\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        token.mint(_to, _amount);\n    }\n\n    function totalSupply() public view returns (uint) {\n        // returns total supply issued so far\n        return token.totalSupply();\n    }\n\n    function decimals() public view returns (uint8) {\n        // returns decimals\n        return token.decimals();\n    }\n\n    function balanceOf(address _owner) public view returns (uint) {\n        // returns balance of address\n        return token.balanceOf(_owner);\n    }\n\n    /**\n     * @notice Pause the contract.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the token emitter.\n     * @dev This function can only be called by the owner when the\n     * contract is paused.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice A payable function that allows a user to buy tokens for a list of addresses and a list of basis points to split the token purchase between.\n     * @param addresses The addresses to send purchased tokens to.\n     * @param basisPointSplits The basis points of the purchase to send to each address.\n     * @param protocolRewardsRecipients The addresses to pay the builder, purchaseRefferal, and deployer rewards to\n     * @return tokensSoldWad The amount of tokens sold in wad units.\n     */\n    function buyToken(\n        address[] calldata addresses,\n        uint[] calldata basisPointSplits,\n        ProtocolRewardAddresses calldata protocolRewardsRecipients\n    ) public payable nonReentrant whenNotPaused returns (uint256 tokensSoldWad) {\n        //prevent treasury from paying itself\n        require(msg.sender != treasury && msg.sender != creatorsAddress, \"Funds recipient cannot buy tokens\");\n\n        require(msg.value > 0, \"Must send ether\");\n        // ensure the same number of addresses and bps\n        require(addresses.length == basisPointSplits.length, \"Parallel arrays required\");\n\n        // Get value left after protocol rewards\n        uint256 msgValueRemaining = _handleRewardsAndGetValueToSend(\n            msg.value,\n            protocolRewardsRecipients.builder,\n            protocolRewardsRecipients.purchaseReferral,\n            protocolRewardsRecipients.deployer\n        );\n\n        //Share of purchase amount to send to treasury\n        uint256 toPayTreasury = (msgValueRemaining * (10_000 - creatorRateBps)) / 10_000;\n\n        //Share of purchase amount to reserve for creators\n        //Ether directly sent to creators\n        uint256 creatorDirectPayment = ((msgValueRemaining - toPayTreasury) * entropyRateBps) / 10_000;\n        //Tokens to emit to creators\n        int totalTokensForCreators = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment) > 0\n            ? getTokenQuoteForEther((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n            : int(0);\n\n        // Tokens to emit to buyers\n        int totalTokensForBuyers = toPayTreasury > 0 ? getTokenQuoteForEther(toPayTreasury) : int(0);\n\n        //Transfer ETH to treasury and update emitted\n        emittedTokenWad += totalTokensForBuyers;\n        if (totalTokensForCreators > 0) emittedTokenWad += totalTokensForCreators;\n\n        //Deposit funds to treasury\n        (bool success, ) = treasury.call{ value: toPayTreasury }(new bytes(0));\n        require(success, \"Transfer failed.\");\n\n        //Transfer ETH to creators\n        if (creatorDirectPayment > 0) {\n            (success, ) = creatorsAddress.call{ value: creatorDirectPayment }(new bytes(0));\n            require(success, \"Transfer failed.\");\n        }\n\n        //Mint tokens for creators\n        if (totalTokensForCreators > 0 && creatorsAddress != address(0)) {\n            _mint(creatorsAddress, uint256(totalTokensForCreators));\n        }\n\n        uint256 bpsSum = 0;\n\n        //Mint tokens to buyers\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (totalTokensForBuyers > 0) {\n                // transfer tokens to address\n                _mint(addresses[i], uint256((totalTokensForBuyers * int(basisPointSplits[i])) / 10_000));\n            }\n            bpsSum += basisPointSplits[i];\n        }\n\n        require(bpsSum == 10_000, \"bps must add up to 10_000\");\n\n        emit PurchaseFinalized(\n            msg.sender,\n            msg.value,\n            toPayTreasury,\n            msg.value - msgValueRemaining,\n            uint256(totalTokensForBuyers),\n            uint256(totalTokensForCreators),\n            creatorDirectPayment\n        );\n\n        return uint256(totalTokensForBuyers);\n    }\n\n    /**\n     * @notice Returns the amount of wei that would be spent to buy an amount of tokens. Does not take into account the protocol rewards.\n     * @param amount the amount of tokens to buy.\n     * @return spentY The cost in wei of the token purchase.\n     */\n    function buyTokenQuote(uint256 amount) public view returns (int spentY) {\n        require(amount > 0, \"Amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.xToY({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(amount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for an amount of wei. Does not take into account the protocol rewards.\n     * @param etherAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForEther(uint256 etherAmount) public view returns (int gainedX) {\n        require(etherAmount > 0, \"Ether amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(etherAmount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for the payment amount, taking into account the protocol rewards.\n     * @param paymentAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForPayment(uint256 paymentAmount) external view returns (int gainedX) {\n        require(paymentAmount > 0, \"Payment amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(((paymentAmount - computeTotalReward(paymentAmount)) * (10_000 - creatorRateBps)) / 10_000)\n            });\n    }\n\n    /**\n     * @notice Set the split of (purchase * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        emit EntropyRateBpsUpdated(entropyRateBps = _entropyRateBps);\n    }\n\n    /**\n     * @notice Set the split of the payment that is reserved for creators in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n\n        emit CreatorRateBpsUpdated(creatorRateBps = _creatorRateBps);\n    }\n\n    /**\n     * @notice Set the creators address to pay the creatorRate to. Can be a contract.\n     * @dev Only callable by the owner.\n     */\n    function setCreatorsAddress(address _creatorsAddress) external override onlyOwner nonReentrant {\n        require(_creatorsAddress != address(0), \"Invalid address\");\n\n        emit CreatorsAddressUpdated(creatorsAddress = _creatorsAddress);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/ERC20TokenEmitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { TokenEmitterRewards } from \"@collectivexyz/protocol-rewards/src/abstract/TokenEmitter/TokenEmitterRewards.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport { VRGDAC } from \"./libs/VRGDAC.sol\";\nimport { toDaysWadUnsafe } from \"./libs/SignedWadMath.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { NontransferableERC20Votes } from \"./NontransferableERC20Votes.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\ncontract ERC20TokenEmitter is\n    IERC20TokenEmitter,\n    ReentrancyGuardUpgradeable,\n    TokenEmitterRewards,\n    Ownable2StepUpgradeable,\n    PausableUpgradeable\n{\n    // treasury address to pay funds to\n    address public treasury;\n\n    // The token that is being minted.\n    NontransferableERC20Votes public token;\n\n    // The VRGDA contract\n    VRGDAC public vrgdac;\n\n    // solhint-disable-next-line not-rely-on-time\n    uint256 public startTime;\n\n    /**\n     * @notice A running total of the amount of tokens emitted.\n     */\n    int256 public emittedTokenWad;\n\n    // The split of the purchase that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The split of (purchase proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The account or contract to pay the creator reward to\n    address public creatorsAddress;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _protocolRewards The protocol rewards contract address\n    /// @param _protocolFeeRecipient The protocol fee recipient address\n    constructor(\n        address _manager,\n        address _protocolRewards,\n        address _protocolFeeRecipient\n    ) payable TokenEmitterRewards(_protocolRewards, _protocolFeeRecipient) initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the token emitter\n     * @param _initialOwner The initial owner of the token emitter\n     * @param _erc20Token The ERC-20 token contract address\n     * @param _vrgdac The VRGDA contract address\n     * @param _treasury The treasury address to pay funds to\n     * @param _creatorsAddress The address to pay the creator reward to\n     */\n    function initialize(\n        address _initialOwner,\n        address _erc20Token,\n        address _treasury,\n        address _vrgdac,\n        address _creatorsAddress\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        require(_treasury != address(0), \"Invalid treasury address\");\n\n        // Set up ownable\n        __Ownable_init(_initialOwner);\n\n        treasury = _treasury;\n        creatorsAddress = _creatorsAddress;\n        vrgdac = VRGDAC(_vrgdac);\n        token = NontransferableERC20Votes(_erc20Token);\n        startTime = block.timestamp;\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        token.mint(_to, _amount);\n    }\n\n    function totalSupply() public view returns (uint) {\n        // returns total supply issued so far\n        return token.totalSupply();\n    }\n\n    function decimals() public view returns (uint8) {\n        // returns decimals\n        return token.decimals();\n    }\n\n    function balanceOf(address _owner) public view returns (uint) {\n        // returns balance of address\n        return token.balanceOf(_owner);\n    }\n\n    /**\n     * @notice Pause the contract.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the token emitter.\n     * @dev This function can only be called by the owner when the\n     * contract is paused.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice A payable function that allows a user to buy tokens for a list of addresses and a list of basis points to split the token purchase between.\n     * @param addresses The addresses to send purchased tokens to.\n     * @param basisPointSplits The basis points of the purchase to send to each address.\n     * @param protocolRewardsRecipients The addresses to pay the builder, purchaseRefferal, and deployer rewards to\n     * @return tokensSoldWad The amount of tokens sold in wad units.\n     */\n    function buyToken(\n        address[] calldata addresses,\n        uint[] calldata basisPointSplits,\n        ProtocolRewardAddresses calldata protocolRewardsRecipients\n    ) public payable nonReentrant whenNotPaused returns (uint256 tokensSoldWad) {\n        //prevent treasury from paying itself\n        require(msg.sender != treasury && msg.sender != creatorsAddress, \"Funds recipient cannot buy tokens\");\n\n        require(msg.value > 0, \"Must send ether\");\n        // ensure the same number of addresses and bps\n        require(addresses.length == basisPointSplits.length, \"Parallel arrays required\");\n\n        // Get value left after protocol rewards\n        uint256 msgValueRemaining = _handleRewardsAndGetValueToSend(\n            msg.value,\n            protocolRewardsRecipients.builder,\n            protocolRewardsRecipients.purchaseReferral,\n            protocolRewardsRecipients.deployer\n        );\n\n        //Share of purchase amount to send to treasury\n        uint256 toPayTreasury = (msgValueRemaining * (10_000 - creatorRateBps)) / 10_000;\n\n        //Share of purchase amount to reserve for creators\n        //Ether directly sent to creators\n        uint256 creatorDirectPayment = ((msgValueRemaining - toPayTreasury) * entropyRateBps) / 10_000;\n        //Tokens to emit to creators\n        int totalTokensForCreators = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment) > 0\n            ? getTokenQuoteForEther((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n            : int(0);\n\n        // Tokens to emit to"
    }
  ]
}