{
  "Title": "[M-04] Redemptions during undercollateralization can be hot-swapped to steal all funds",
  "Content": "\nDuring recollateralization/a switch basket/when the protocol collateral isn't sound, a user can have almost their entire redemption transaction hot swapped for nothing.\n\nFor example, trying to redeem 1M collateral for 1M rTokens could have the user end up with 0 collateral and 0 rTokens, just by calling the `redeem` function at the wrong time.\n\nExample:\n\n*   User A issues 1M rToken for 1M tokenA\n\n*   Evil user sees tokenA is about to become disabled, and that User A sent a normally innocuous redeem tx for too much underlying collateral in the mempool\n\n*   Evil user orders transactions so they and RSR/Rtoken holders can steal user A's funds\n\n*   They first buy a ton of tokenA and send it to the backing Manager\n\n*   They call `manageTokens` which flash issues a ton of new Rtoken due to the inflated tokenA balance, increasing the totalSupply\n\n*   The increase in total supply allows the normal redemption cap to be drastically lifted\n\n*   They then let the disabling of tokenA process, and calls refreshBasket where a backup token (tokenB) kicks in\n\n*   We are now undercollateralized, and evil user sends tokenB dust to the backingmanager\n\n*   FINALLY: the original redemption TX is ordered, and due to the inflated RToken supply, the battery discharge amount is also inflated, allowing the redemption to go through. Due to the new collateral in place, they redeem ALL their Rtoken (1M) for dust of tokenB!! The protocol has essentially honeypotted them!!\n\n### Proof of Concept\n\nWe provide the proof of code in `proof of code` section.\n\n1.  MEV\n\nThis relies on a validator being malicious with for-profit motives. It would be pretty easy for them to setup a bot looking for this exact scenario though and just staying dormant till the time is right. If they get to order the transactions, they can make a fat profit from the victim.\n\n2.  Backing manager can flash issue RToken\n\nIf the backingManger has too many excess assets, it will flash issue as [many RTokens as](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/BackingManager.sol#L201) possible to even the collateral to RTokens.\n\n    function handoutExcessAssets(IERC20[] calldata erc20s) private {\n    .\n    .\n    if (held.gt(needed)) {\n    .\n    .\n    rToken.mint(address(this), uint256(rTok));\n\n3.  Increasing the supply increases the redemption and issuance block cap\n\nThe RedemptionBattery's currentCharge function is [dependent on the total supply of RTokens](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/libraries/RedemptionBattery.sol#L59). So if the total supply is raised, you can redeem way more than you should be able to.\n\n    uint256 amtPerHour = (supply * battery.scalingRedemptionRate) / FIX_ONE_256;\n\n(This also is true for issuance.)\n\n4.  Anyone can call [refreshBasket when a collateral](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/BasketHandler.sol#L179) is disabled\n\n```\n\n    function refreshBasket() external {\n            assetRegistry.refresh();\n\n            require(\n                main.hasRole(OWNER, _msgSender()) ||\n                    (status() == CollateralStatus.DISABLED && !main.pausedOrFrozen()),\n                \"basket unrefreshable\"\n            );\n            _switchBasket();\n        }\n```\n\nSo if I see a tx where a collateral is about to be disabled, I can chain it with the refreshbasket TX myself.\n\n5.  Redemptions can occur when protocol is undercollateralized\n\nThe `redeem` function has this check:\n\n    require(basketHandler.status() != CollateralStatus.DISABLED, \"collateral default\");\n\nWhich checks if the collateral is good, but NOT if the protocol is fullyCollateralized. Since we chain the disabled asset with the refreshBasket TX, the backup collateral kicks in, and the collateral status becomes `SOUND`. However, normally, we'd have 0 of the new collateral and any redemptions would fail, since there isn't anything to give back.\n\n6.  Sending dust to backing manager\n\nSo, if you send a tiny tiny bit of the new collateral to the protocol, the protocol will process the redemption and give them their `prorata` share of the collateral, which right now is almost 0, but still burn all the rToken being redeemed.\n\n[RToken.sol](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/RToken.sol#L475)\n\n    // amount is never changed, they burn all the rToken\n    // in our example above, all 1M Rtoken are burned!\n    _burn(redeemer, amount);\n\nAnd we calculate how much they get back like so. We see how much `$` we currently have in the basket, and hand back those amounts accordingly. Since we have almost no money, we are going to give them almost nothing for their rTokens.\n\n    (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);\n    uint256 erc20length = erc20s.length;\n    // Bound each withdrawal by the prorata share, in case we're currently under-collateralized\n            for (uint256 i = 0; i < erc20length; ++i) {\n                // {qTok}\n                uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));\n\n                // gas-optimization: only do the full mulDiv256 if prorate is 0\n                uint256 prorata = (prorate > 0)\n                    ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18\n                    : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}\n\n                if (prorata < amounts[i]) amounts[i] = prorata;\n            }\n\nAnd just like that, a seemingly innocuous redemption transaction was a trap the whole time. The next step would be to go through the rest of the process to see how much our evil user profited (from running the auctions), as they need to be a whale to inflate the RToken supply. However, we've seen attacks like this, and one could consider it a [highly profitable trading strategy](https://twitter.com/avi_eisen/status/1581326197241180160?s=20\\&t=8WpEg76bW_Kk8YaJ5orP5Q). If they buy up majority shares in the RToken, or, they coordinate with most of the StRSR token holders they could advertise and honey pot people to do redemptions whenever a switchBasket is coming. Spread FUD like \"you need to redeem otherwise you'll lose money!\" and it's the redeeming that actually steals their money.\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nDisallow issuance/redemptions while the protocol is undercollateralized.\n\n### Proof Of Code\n\nSee warden's [original submission](https://github.com/code-423n4/2023-01-reserve-findings/issues/399) for full details.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/399#issuecomment-1399349370):**\n > Certainly a creative attack vector, will leave open for sponsor review.  I am unclear on a few nuances of the attack here, but ultimately would like the sponsor to comment.\n> \n> Downgrading to Medium for the moment due to a very particular sequence of events being required for this to be executed. \n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/399#issuecomment-1405418612):**\n > The bug is simpler than the description. If the basket is DISABLED, then all that needs to happen is for a redeem tx to be in the mempool. An MEV searcher can order a `refreshBasket()` call earlier in the block, causing the redemption to be partial. This acts as a net transfer between the RToken redeemer and RSR stakers, who will eventually collect the money. \n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR allows an RToken redeemer to specify when they require full redemptions vs accept partial (prorata) redemptions.<br>\n> [reserve-protocol/protocol#615](https://github.com/reserve-protocol/protocol/pull/615)\n\n**Status:** Not fully mitigated. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/54), [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/14), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/69). Also included in Mitigation Review section below.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-reserve-contest",
  "Code": [
    {
      "filename": "contracts/p1/BackingManager.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IAsset.sol\";\nimport \"../interfaces/IBackingManager.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Array.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/Trading.sol\";\nimport \"./mixins/RecollateralizationLib.sol\";\n\n/**\n * @title BackingManager\n * @notice The backing manager holds + manages the backing for an RToken\n */\n\n/// @custom:oz-upgrades-unsafe-allow external-library-linking\ncontract BackingManagerP1 is TradingP1, IBackingManager {\n    using FixLib for uint192;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Cache of peer components\n    IAssetRegistry private assetRegistry;\n    IBasketHandler private basketHandler;\n    IDistributor private distributor;\n    IRToken private rToken;\n    IERC20 private rsr;\n    IStRSR private stRSR;\n    IRevenueTrader private rsrTrader;\n    IRevenueTrader private rTokenTrader;\n    uint48 public constant MAX_TRADING_DELAY = 31536000; // {s} 1 year\n    uint192 public constant MAX_BACKING_BUFFER = 1e18; // {%}\n\n    uint48 public tradingDelay; // {s} how long to wait until resuming trading after switching\n    uint192 public backingBuffer; // {%} how much extra backing collateral to keep\n\n    // ==== Invariants ====\n    // tradingDelay <= MAX_TRADING_DELAY and backingBuffer <= MAX_BACKING_BUFFER\n    //\n    // ... and the *much* more complicated temporal properties for _manageTokens()\n\n    function init(\n        IMain main_,\n        uint48 tradingDelay_,\n        uint192 backingBuffer_,\n        uint192 maxTradeSlippage_,\n        uint192 minTradeVolume_\n    ) external initializer {\n        __Component_init(main_);\n        __Trading_init(main_, maxTradeSlippage_, minTradeVolume_);\n\n        assetRegistry = main_.assetRegistry();\n        basketHandler = main_.basketHandler();\n        distributor = main_.distributor();\n        rsr = main_.rsr();\n        rsrTrader = main_.rsrTrader();\n        rTokenTrader = main_.rTokenTrader();\n        rToken = main_.rToken();\n        stRSR = main_.stRSR();\n\n        setTradingDelay(tradingDelay_);\n        setBackingBuffer(backingBuffer_);\n    }\n\n    /// Give RToken max allowance over the registered token `erc20`\n    /// @custom:interaction CEI\n    // checks: erc20 in assetRegistry\n    // action: set allowance on erc20 for rToken to UINT_MAX\n    // Using two safeApprove calls instead of safeIncreaseAllowance to support USDT\n    function grantRTokenAllowance(IERC20 erc20) external notPausedOrFrozen {\n        require(assetRegistry.isRegistered(erc20), \"erc20 unregistered\");\n        // == Interaction ==\n        IERC20Upgradeable(address(erc20)).safeApprove(address(main.rToken()), 0);\n        IERC20Upgradeable(address(erc20)).safeApprove(address(main.rToken()), type(uint256).max);\n    }\n\n    /// Maintain the overall backing policy; handout assets otherwise\n    /// @custom:interaction\n    // checks: the addresses in `erc20s` are unique\n    // effect: _manageTokens(erc20s)\n    function manageTokens(IERC20[] calldata erc20s) external notPausedOrFrozen {\n        // Token list must not contain duplicates\n        require(ArrayLib.allUnique(erc20s), \"duplicate tokens\");\n        _manageTokens(erc20s);\n    }\n\n    /// Mointain the overall backing policy; handout assets otherwise\n    /// @dev Tokens must be in sorted order!\n    /// @dev Performs a uniqueness check on the erc20s list in O(n)\n    /// @custom:interaction\n    // checks: the addresses in `erc20s` are unique (and sorted)\n    // effect: _manageTokens(erc20s)\n    function manageTokensSortedOrder(IERC20[] calldata erc20s) external notPausedOrFrozen {\n        // Token list must not contain duplicates\n        require(ArrayLib.sortedAndAllUnique(erc20s), \"duplicate/unsorted tokens\");\n        _manageTokens(erc20s);\n    }\n\n    /// Maintain the overall backing policy; handout assets otherwise\n    /// @custom:interaction RCEI\n    // only called internally, from manageTokens*, so erc20s has no duplicates unique\n    // (but not necessarily all registered or valid!)\n    function _manageTokens(IERC20[] calldata erc20s) private {\n        // == Refresh ==\n        assetRegistry.refresh();\n\n        if (tradesOpen > 0) return;\n        // Only trade when all the collateral assets in the basket are SOUND\n        require(basketHandler.status() == CollateralStatus.SOUND, \"basket not sound\");\n\n        uint48 basketTimestamp = basketHandler.timestamp();\n        if (block.timestamp < basketTimestamp + tradingDelay) return;\n\n        if (basketHandler.fullyCollateralized()) {\n            // == Interaction (then return) ==\n            handoutExcessAssets(erc20s);\n        } else {\n            /* Recollateralization\n             *\n             * Strategy: iteratively move the system on a forgiving path towards capitalization\n             * through a narrowing BU price band. The initial large spread reflects the\n             * uncertainty associated with the market price of defaulted/volatile collateral, as\n             * well as potential losses due to trading slippage. In the absence of further\n             * collateral default, the size of the BU price band should decrease with each trade\n             * until it is 0, at which point capitalization is restored.\n             *\n             * If we run out of capital and are still undercapitalized, we compromise\n             * rToken.basketsNeeded to the current basket holdings. Haircut time.\n             */\n\n            (bool doTrade, TradeRequest memory req) = RecollateralizationLibP1\n                .prepareRecollateralizationTrade(this);\n\n            if (doTrade) {\n                // Seize RSR if needed\n                if (req.sell.erc20() == rsr) {\n                    uint256 bal = req.sell.erc20().balanceOf(address(this));\n                    if (req.sellAmount > bal) stRSR.seizeRSR(req.sellAmount - bal);\n                }\n\n                tryTrade(req);\n            } else {\n                // Haircut time\n                compromiseBasketsNeeded();\n            }\n        }\n    }\n\n    /// Send excess assets to the RSR and RToken traders\n    /// @custom:interaction CEI\n    function handoutExcessAssets(IERC20[] calldata erc20s) private {\n        /**\n         * Assumptions:\n         *   - Fully capitalized. All collateral, and therefore assets, meet balance requirements.\n         *   - All backing capital is held at BackingManager's address. No capital is out on-trade\n         *   - Neither RToken nor RSR are in the basket\n         *   - Each address in erc20s is unique\n         *\n         * Steps:\n         *   1. Forward all held RSR to the RSR trader to prevent using it for RToken appreciation\n         *      (action: send rsr().balanceOf(this) to rsrTrader)\n         *   2. Using whatever balances of collateral are there, fast-issue all RToken possible.\n         *      (in detail: mint RToken and set basketsNeeded so that the BU/rtok exchange rate is\n         *       roughly constant, and strictly does not decrease,\n         *   3. Handout all surplus asset balances (including collateral and RToken) to the\n         *      RSR and RToken traders according to the distribution totals.\n         */\n\n        // Forward any RSR held to StRSR pool; RSR should never be sold for RToken yield\n        if (rsr.balanceOf(address(this)) > 0) {\n            // For CEI, this is an interaction \"within our system\" even though RSR is already live\n            IERC20Upgradeable(address(rsr)).safeTransfer(\n                address(rsrTrader),\n                rsr.balanceOf(address(this))\n            );\n        }\n\n        // Mint revenue RToken and update `basketsNeeded`\n        // across this block:\n        //   where rate(R) == R.basketsNeeded / R.totalSupply,\n        //   rate(rToken') >== rate(rToken)\n        //   (>== is \"no less than, and nearly equal to\")\n        //    and rToken'.basketsNeeded <= basketHandler.basketsHeldBy(this)\n        // and rToken'.totalSupply is maximal satisfying this.\n        uint192 needed; // {BU}\n        {\n            needed = rToken.basketsNeeded(); // {BU}\n            uint192 held = basketHandler.basketsHeldBy(address(this)); // {BU}\n            if (held.gt(needed)) {\n                int8 decimals = int8(rToken.decimals());\n                uint192 totalSupply = shiftl_toFix(rToken.totalSupply(), -decimals); // {rTok}\n\n                // {BU} = {BU} - {BU}\n                uint192 extraBUs = held.minus(needed);\n\n                // {qRTok: Fix} = {BU} * {qRTok / BU} (if needed == 0, conv rate is 1 qRTok/BU)\n                uint192 rTok = (needed > 0) ? extraBUs.mulDiv(totalSupply, needed) : extraBUs;\n\n                rToken.mint(address(this), rTok.shiftl_toUint(decimals));\n                rToken.setBasketsNeeded(held);\n                needed = held;\n            }\n        }\n\n        // At this point, even though basketsNeeded may have changed:\n        // - We're fully capitalized\n        // - The BU exchange rate {BU/rTok} did not decrease\n\n        // Keep a small buffer of individual collateral; \"excess\" assets are beyond the buffer.\n        needed = needed.mul(FIX_ONE.plus(backingBuffer));\n\n        // Handout excess assets above what is needed, including any recently minted RToken\n        uint256 length = erc20s.length;\n        RevenueTotals memory totals = distributor.totals();\n        uint256[] memory toRSR = new uint256[](length);\n        uint256[] memory toRToken = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            IAsset asset = assetRegistry.toAsset(erc20s[i]);\n\n            uint192 req = needed.mul(basketHandler.quantity(erc20s[i]), CEIL);\n            if (asset.bal(address(this)).gt(req)) {\n                // delta: {qTok}, the excess quantity of this asset that we hold\n                uint256 delta = asset.bal(address(this)).minus(req).shiftl_toUint(\n                    int8(IERC20Metadata(address(erc20s[i])).decimals())\n                );\n                // no div-by-0: Distributor guarantees (totals.rTokenTotal + totals.rsrTotal) > 0\n                // initial division is intentional here! We'd rather save the dust than be unfair\n                toRSR[i] = (delta / (totals.rTokenTotal + totals.rsrTotal)) * totals.rsrTotal;\n                toRToken[i] = (delta / (totals.rTokenTotal + totals.rsrTotal)) * totals.rTokenTotal;\n            }\n        }\n\n        // == Interactions ==\n        for (uint256 i = 0; i < length; ++i) {\n            IERC20Upgradeable erc20 = IERC20Upgradeable(address(erc20s[i]));\n            if (toRToken[i] > 0) erc20.safeTransfer(address(rTokenTrader), toRToken[i]);\n            if (toRSR[i] > 0) erc20.safeTransfer(address(rsrTrader), toRSR[i]);\n        }\n\n        // It's okay if there is leftover dust for RToken or a surplus asset (not RSR)\n    }\n\n    /// Compromise on how many baskets are needed in order to recollateralize-by-accounting\n    function compromiseBasketsNeeded() private {\n        assert(tradesOpen == 0 && !basketHandler.fullyCollateralized());\n        rToken.setBasketsNeeded(basketHandler.basketsHeldBy(address(this)));\n    }\n\n    // === Governance Setters ===\n\n    /// @custom:governance\n    function setTradingDelay(uint48 val) public governance {\n        require(val <= MAX_TRADING_DELAY, \"invalid tradingDelay\");\n        emit TradingDelaySet(tradingDelay, val);\n        tradingDelay = val;\n    }\n\n    /// @custom:governance\n    function setBackingBuffer(uint192 val) public governance {\n        require(val <= MAX_BACKING_BUFFER, \"invalid backingBuffer\");\n        emit BackingBufferSet(backingBuffer, val);\n        backingBuffer = val;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[41] private __gap;\n}"
    },
    {
      "filename": "contracts/libraries/RedemptionBattery.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"../interfaces/IRToken.sol\";\nimport \"./Fixed.sol\";\n\n// NOTE: This algorithm assumes the contract is running on PoS Ethereum and 100% of the\n// network is online. It is possible for the battery to recharge up to 2/3 as fast\n// depending on validator participation levels. Below 2/3 the chain halts, in which case\n// the battery stops charging completely.\nuint48 constant BLOCKS_PER_HOUR = 300; // {blocks/hour}\n\n/// Throttling mechanism:\n/// Models a \"battery\" which \"recharges\" linearly block by block, over roughly 1 hour.\n/// Calls to discharge() will revert if the battery doesn't have enough \"charge\".\n/// @dev This implementation basically assumes that maxCapacity is always the same value.\n///      It won't misbehave badly if maxCapacity is changed, but it doesn't have sharply-defined\n///      behavior in that case. (But keeping maxCapacity outside storage saves SLOADs)\nlibrary RedemptionBatteryLib {\n    using FixLib for uint192;\n\n    struct Battery {\n        uint256 redemptionRateFloor; // {qRTok/hour} the floor of the battery charging rate\n        uint192 scalingRedemptionRate; // {1/hour} charging rate as a fraction of supply\n        // for either: set to 0 to disable\n        // ===\n        uint48 lastBlock; // {blocks}\n        uint256 lastCharge; // {qRTok}\n    }\n\n    /// @param supply {qRTok} Total RToken supply before redemption\n    /// @param amount {qRTok} Amount of RToken being redeemed\n    function discharge(\n        Battery storage battery,\n        uint256 supply,\n        uint256 amount\n    ) internal {\n        if (battery.redemptionRateFloor == 0 && battery.scalingRedemptionRate == 0) return;\n\n        // {qRTok}\n        uint256 charge = currentCharge(battery, supply);\n\n        // A nice error message so people aren't confused why redemption failed\n        require(amount <= charge, \"redemption battery insufficient\");\n\n        // Update battery\n        battery.lastBlock = uint48(block.number);\n        battery.lastCharge = charge - amount;\n    }\n\n    /// @param supply {qRTok} Total RToken supply before the burn step\n    /// @return charge {qRTok} The current total charge as an amount of RToken\n    function currentCharge(Battery storage battery, uint256 supply)\n        internal\n        view\n        returns (uint256 charge)\n    {\n        // {qRTok/hour} = {qRTok} * D18{1/hour} / D18\n        uint256 amtPerHour = (supply * battery.scalingRedemptionRate) / FIX_ONE_256;\n\n        if (battery.redemptionRateFloor > amtPerHour) amtPerHour = battery.redemptionRateFloor;\n\n        // {blocks}\n        uint48 blocks = uint48(block.number) - battery.lastBlock;\n\n        // {qRTok} = {qRTok} + {qRTok/hour} * {blocks} / {blocks/hour}\n        charge = battery.lastCharge + (amtPerHour * blocks) / BLOCKS_PER_HOUR;\n\n        uint256 maxCharge = amtPerHour > supply ? supply : amtPerHour;\n        if (charge > maxCharge) charge = maxCharge;\n    }\n}"
    },
    {
      "filename": "contracts/p1/BasketHandler.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../interfaces/IAssetRegistry.sol\";\nimport \"../interfaces/IBasketHandler.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Array.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/Component.sol\";\n\n// A \"valid collateral array\" is a an IERC20[] value without rtoken, rsr, or any duplicate values\n\n// A BackupConfig value is valid if erc20s is a valid collateral array\nstruct BackupConfig {\n    uint256 max; // Maximum number of backup collateral erc20s to use in a basket\n    IERC20[] erc20s; // Ordered list of backup collateral ERC20s\n}\n\n// What does a BasketConfig value mean?\n//\n// erc20s, targetAmts, and targetNames should be interpreted together.\n// targetAmts[erc20] is the quantity of target units of erc20 that one BU should hold\n// targetNames[erc20] is the name of erc20's target unit\n// and then backups[tgt] is the BackupConfig to use for the target unit named tgt\n//\n// For any valid BasketConfig value:\n//     erc20s == keys(targetAmts) == keys(targetNames)\n//     if name is in values(targetNames), then backups[name] is a valid BackupConfig\n//     erc20s is a valid collateral array\n//\n// In the meantime, treat erc20s as the canonical set of keys for the target* maps\nstruct BasketConfig {\n    // The collateral erc20s in the prime (explicitly governance-set) basket\n    IERC20[] erc20s;\n    // Amount of target units per basket for each prime collateral token. {target/BU}\n    mapping(IERC20 => uint192) targetAmts;\n    // Cached view of the target unit for each erc20 upon setup\n    mapping(IERC20 => bytes32) targetNames;\n    // Backup configurations, per target name.\n    mapping(bytes32 => BackupConfig) backups;\n}\n\n/// The type of BasketHandler.basket.\n/// Defines a basket unit (BU) in terms of reference amounts of underlying tokens\n// Logically, basket is just a mapping of erc20 addresses to ref-unit amounts.\n// In the analytical comments I'll just refer to it that way.\n//\n// A Basket is valid if erc20s is a valid collateral array and erc20s == keys(refAmts)\nstruct Basket {\n    IERC20[] erc20s; // enumerated keys for refAmts\n    mapping(IERC20 => uint192) refAmts; // {ref/BU}\n}\n\n/*\n * @title BasketLibP1\n */\nlibrary BasketLibP1 {\n    using BasketLibP1 for Basket;\n    using FixLib for uint192;\n\n    /// Set self to a fresh, empty basket\n    // self'.erc20s = [] (empty list)\n    // self'.refAmts = {} (empty map)\n    function empty(Basket storage self) internal {\n        uint256 length = self.erc20s.length;\n        for (uint256 i = 0; i < length; ++i) self.refAmts[self.erc20s[i]] = FIX_ZERO;\n        delete self.erc20s;\n    }\n\n    /// Set `self` equal to `other`\n    function setFrom(Basket storage self, Basket storage other) internal {\n        empty(self);\n        uint256 length = other.erc20s.length;\n        for (uint256 i = 0; i < length; ++i) {\n            self.erc20s.push(other.erc20s[i]);\n            self.refAmts[other.erc20s[i]] = other.refAmts[other.erc20s[i]];\n        }\n    }\n\n    /// Add `weight` to the refAmount of collateral token `tok` in the basket `self`\n    // self'.refAmts[tok] = self.refAmts[tok] + weight\n    // self'.erc20s is keys(self'.refAmts)\n    function add(\n        Basket storage self,\n        IERC20 tok,\n        uint192 weight\n    ) internal {\n        if (weight == FIX_ZERO) return;\n        if (self.refAmts[tok].eq(FIX_ZERO)) {\n            self.erc20s.push(tok);\n            self.refAmts[tok] = weight;\n        } else {\n            self.refAmts[tok] = self.refAmts[tok].plus(weight);\n        }\n    }\n}\n\n/**\n * @title BasketHandler\n * @notice Handles the basket configuration, definition, and evolution over time.\n */\ncontract BasketHandlerP1 is ComponentP1, IBasketHandler {\n    using BasketLibP1 for Basket;\n    using CollateralStatusComparator for CollateralStatus;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using FixLib for uint192;\n\n    uint192 public constant MAX_TARGET_AMT = 1e3 * FIX_ONE; // {target/BU} max basket weight\n\n    // Peer components\n    IAssetRegistry private assetRegistry;\n    IBackingManager private backingManager;\n    IERC20 private rsr;\n    IRToken private rToken;\n    IStRSR private stRSR;\n\n    // config is the basket configuration, from which basket will be computed in a basket-switch\n    // event. config is only modified by governance through setPrimeBakset and setBackupConfig\n    BasketConfig private config;\n\n    // basket, disabled, nonce, and timestamp are only ever set by `_switchBasket()`\n    // basket is the current basket.\n    Basket private basket;\n\n    uint48 public override nonce; // A unique identifier for this basket instance\n    uint48 public override timestamp; // The timestamp when this basket was last set\n\n    // If disabled is true, status() is DISABLED, the basket is invalid, and the whole system should\n    // be paused.\n    bool private disabled;\n\n    // ==== Invariants ====\n    // basket is a valid Basket:\n    //   basket.erc20s is a valid collateral array and basket.erc20s == keys(basket.refAmts)\n    // config is a valid BasketConfig:\n    //   erc20s == keys(targetAmts) == keys(targetNames)\n    //   erc20s is a valid collateral array\n    //   for b in vals(backups), b.erc20s is a valid collateral array.\n    // if basket.erc20s is empty then disabled == true\n\n    // BasketHandler.init() just leaves the BasketHandler state zeroed\n    function init(IMain main_) external initializer {\n        __Component_init(main_);\n\n        assetRegistry = main_.assetRegistry();\n        backingManager = main_.backingManager();\n        rsr = main_.rsr();\n        rToken = main_.rToken();\n        stRSR = main_.stRSR();\n\n        disabled = true;\n    }\n\n    /// Disable the basket in order to schedule a basket refresh\n    /// @custom:protected\n    // checks: caller is assetRegistry\n    // effects: disabled' = true\n    function disableBasket() external {\n        require(_msgSender() == address(assetRegistry), \"asset registry only\");\n        uint192[] memory refAmts = new uint192[](basket.erc20s.length);\n        emit BasketSet(nonce, basket.erc20s, refAmts, true);\n        disabled = true;\n    }\n\n    /// Switch the basket, only callable directly by governance\n    /// @custom:interaction OR @custom:governance\n    // checks: either caller has OWNER,\n    //         or (basket is disabled after refresh and we're unpaused and unfrozen)\n    // actions: calls assetRegistry.refresh(), then _switchBasket()\n    // effects:\n    //   Either: (basket' is a valid nonempty basket, without DISABLED collateral,\n    //            that satisfies basketConfig) and disabled' = false\n    //   Or no such basket exists and disabled' = true\n    function refreshBasket() external {\n        assetRegistry.refresh();\n\n        require(\n            main.hasRole(OWNER, _msgSender()) ||\n                (status() == CollateralStatus.DISABLED && !main.pausedOrFrozen()),\n            \"basket unrefreshable\"\n        );\n        _switchBasket();\n    }\n\n    /// Set the prime basket in the basket configuration, in terms of erc20s and target amounts\n    /// @param erc20s The collateral for the new prime basket\n    /// @param targetAmts The target amounts (in) {target/BU} for the new prime basket\n    /// @custom:governance\n    // checks:\n    //   caller is OWNER\n    //   len(erc20s) == len(targetAmts)\n    //   erc20s is a valid collateral array\n    //   for all i, erc20[i] is in AssetRegistry as collateral\n    //   for all i, 0 < targetAmts[i] <= MAX_TARGET_AMT == 1000\n    //\n    // effects:\n    //   config'.erc20s = erc20s\n    //   config'.targetAmts[erc20s[i]] = targetAmts[i], for i from 0 to erc20s.length-1\n    //   config'.targetNames[e] = assetRegistry.toColl(e).targetName, for e in erc20s\n    function setPrimeBasket(IERC20[] calldata erc20s, uint192[] calldata targetAmts)\n        external\n        governance\n    {\n        require(erc20s.length > 0, \"cannot empty basket\");\n        require(erc20s.length == targetAmts.length, \"must be same length\");\n        requireValidCollArray(erc20s);\n\n        // Clean up previous basket config\n        for (uint256 i = 0; i < config.erc20s.length; ++i) {\n            delete config.targetAmts[config.erc20s[i]];\n            delete config.targetNames[config.erc20s[i]];\n        }\n        delete config.erc20s;\n\n        // Set up new config basket\n        bytes32[] memory names = new bytes32[](erc20s.length);\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            // This is a nice catch to have, but in general it is possible for\n            // an ERC20 in the prime basket to have its asset unregistered.\n            require(assetRegistry.toAsset(erc20s[i]).isCollateral(), \"token is not collateral\");\n            require(0 < targetAmts[i], \"invalid target amount; must be nonzero\");\n            require(targetAmts[i] <= MAX_TARGET_AMT, \"invalid target amount; too large\");\n\n            config.erc20s.push(erc20s[i]);\n            config.targetAmts[erc20s[i]] = targetAmts[i];\n            names[i] = assetRegistry.toColl(erc20s[i]).targetName();\n            config.targetNames[erc20s[i]] = names[i];\n        }\n\n        emit PrimeBasketSet(erc20s, targetAmts, names);\n    }\n\n    /// Set the backup configuration for some target name\n    /// @custom:governance\n    // checks:\n    //   caller is OWNER\n    //   erc20s is a valid collateral array\n    //   for all i, erc20[i] is in AssetRegistry as collateral\n    //\n    // effects:\n    //   config'.backups[targetName] = {max: max, erc20s: erc20s}\n    function setBackupConfig(\n        bytes32 targetName,\n        uint256 max,\n        IERC20[] calldata erc20s\n    ) external governance {\n        requireValidCollArray(erc20s);\n        BackupConfig storage conf = config.backups[targetName];\n        conf.max = max;\n        delete conf.erc20s;\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            // This is a nice catch to have, but in general it is possible for\n            // an ERC20 in the backup config to have its asset altered.\n            require(assetRegistry.toAsset(erc20s[i]).isCollateral(), \"token is not collateral\");\n            conf.erc20s.push(erc20s[i]);\n        }\n        emit BackupConfigSet(targetName, max, erc20s);\n    }\n\n    /// @return Whether this contract owns enough collateral to cover rToken.basketsNeeded() BUs\n    /// ie, whether the protocol is currently fully collateralized\n    function fullyCollateralized() external view returns (bool) {\n        return basketsHeldBy(address(backingManager)) >= rToken.basketsNeeded();\n    }\n\n    /// @return status_ The status of the basket\n    // returns DISABLED if disabled == true, and worst(status(coll)) otherwise\n    function status() public view returns (CollateralStatus status_) {\n        uint256 size = basket.erc20s.length;\n\n        // untestable:\n        //      disabled is only set in _switchBasket, and only if size > 0.\n        if (disabled || size == 0) return CollateralStatus.DISABLED;\n\n        for (uint256 i = 0; i < size; ++i) {\n            CollateralStatus s = assetRegistry.toColl(basket.erc20s[i]).status();\n            if (s.worseThan(status_)) status_ = s;\n        }\n    }\n\n    /// @return {tok/BU} The token-quantity of an ERC20 token in the basket.\n    // Returns 0 if erc20 is not registered, disabled, or not in the basket\n    // Returns FIX_MAX (in lieu of +infinity) if Collateral.refPerTok() is 0.\n    // Otherwise returns (token's basket.refAmts / token's Collateral.refPerTok())\n    function quantity(IERC20 erc20) public view returns (uint192) {\n        try assetRegistry.toColl(erc20) returns (ICollateral coll) {\n            if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n\n            uint192 refPerTok = coll.refPerTok(); // {ref/tok}\n            if (refPerTok > 0) {\n                // {tok/BU} = {ref/BU} / {ref/tok}\n                return basket.refAmts[erc20].div(refPerTok, CEIL);\n            } else {\n                return FIX_MAX;\n            }\n        } catch {\n            return FIX_ZERO;\n        }\n    }\n\n    /// Should not revert\n    /// @return low {UoA/tok} The lower end of the price estimate\n    /// @return high {UoA/tok} The upper end of the price estimate\n    // returns sum(quantity(erc20) * price(erc20) for erc20 in basket.erc20s)\n    function price() external view returns (uint192 low, uint192 high) {\n        return _price(false);\n    }\n\n    /// Should not revert\n    /// lowLow should be nonzero when the asset might be worth selling\n    /// @return lotLow {UoA/tok} The lower end of the lot price estimate\n    /// @return lotHigh {UoA/tok} The upper end of the lot price estimate\n    // returns sum(quantity(erc20) * lotPrice(erc20) for erc20 in basket.erc20s)\n    function lotPrice() external view returns (uint192 lotLow, uint192 lotHigh) {\n        return _price(true);\n    }\n\n    /// Returns the price of a BU, using the lot prices if `useLotPrice` is true\n    /// @return low {UoA/tok} The lower end of the lot price estimate\n    /// @return high {UoA/tok} The upper end of the lot price estimate\n    function _price(bool useLotPrice) internal view returns (uint192 low, uint192 high) {\n        uint256 low256;\n        uint256 high256;\n\n        uint256 len = basket.erc20s.length;\n        for (uint256 i = 0; i < len; ++i) {\n            uint192 qty = quantity(basket.erc20s[i]);\n            if (qty == 0) continue;\n\n            (uint192 lowP, uint192 highP) = useLotPrice\n                ? assetRegistry.toAsset(basket.erc20s[i]).lotPrice()\n                : assetRegistry.toAsset(basket.erc20s[i]).price();\n\n            low256 += quantityMulPrice(qty, lowP);\n            high256 += quantityMulPrice(qty, highP);\n        }\n\n        low = low256 >= FIX_MAX ? FIX_MAX : uint192(low256);\n        high = high256 >= FIX_MAX ? FIX_MAX : uint192(high256);\n    }\n\n    /// Multiply quantity by price, rounding up to FIX_MAX and down to 0\n    /// @param qty {tok/BU}\n    /// @param p {UoA/tok}\n    function quantityMulPrice(uint192 qty, uint192 p) internal pure returns (uint192) {\n        if (qty == 0 || p == 0) return 0;\n        if (qty == FIX_MAX || p == FIX_MAX) return FIX_MAX;\n\n        // return FIX_MAX instead of throwing overflow errors.\n        unchecked {\n            // p and mul *are* Fix values, so have 18 decimals (D18)\n            uint256 rawDelta = uint256(p) * qty; // {D36} = {D18} * {D18}\n            // if we overflowed *, then return FIX_MAX\n            if (rawDelta / p != qty) return FIX_MAX;\n\n            // add in FIX_HALF for rounding\n            uint256 shiftDelta = rawDelta + (FIX_ONE / 2);\n            if (shiftDelta < rawDelta) return FIX_MAX;\n\n            // return _div(rawDelta, FIX_ONE, ROUND)\n            return uint192(shiftDelta / FIX_ONE); // {D18} = {D36} / {D18}\n        }\n    }\n\n    /// Return the current issuance/redemption value of `amount` BUs\n    /// @param amount {BU}\n    /// @return erc20s The backing collateral erc20s\n    /// @return quantities {qTok} ERC20 token quantities equal to `amount` BUs\n    // Returns (erc20s, [quantity(e) * amount {as qTok} for e in erc20s])\n    function quote(uint192 amount, RoundingMode rounding)\n        external\n        view\n        returns (address[] memory erc20s, uint256[] memory quantities)\n    {\n        uint256 length = basket.erc20s.length;\n        erc20s = new address[](length);\n        quantities = new uint256[](length);\n\n        for (uint256 i = 0; i < length; ++i) {\n            erc20s[i] = address(basket.erc20s[i]);\n\n            // {qTok} = {tok/BU} * {BU} * {tok} * {qTok/tok}\n            quantities[i] = quantity(basket.erc20s[i]).mul(amount, rounding).shiftl_toUint(\n                int8(IERC20Metadata(address(basket.erc20s[i])).decimals()),\n                rounding\n            );\n        }\n    }\n\n    /// @return baskets {BU} The balance of basket units held by `account`\n    /// @dev Returns FIX_ZERO for an empty basket\n    // Returns:\n    //    0, if (basket.erc20s is empty) or (disabled is true) or (status() is DISABLED)\n    //    min(e.balanceOf(account) / quantity(e) for e in basket.erc20s if quantity(e) > 0),\n    function basketsHeldBy(address account) public view returns (uint192 baskets) {\n        uint256 length = basket.erc20s.length;\n        if (length == 0 || disabled) return FIX_ZERO;\n        baskets = FIX_MAX;\n\n        for (uint256 i = 0; i < length; ++i) {\n            ICollateral coll = assetRegistry.toColl(basket.erc20s[i]);\n            if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n\n            uint192 refPerTok = coll.refPerTok();\n            // If refPerTok is 0, then we have zero of coll's reference unit.\n            // We know that basket.refAmts[basket.erc20s[i]] > 0, so we have no baskets.\n            if (refPerTok == 0) return FIX_ZERO;\n\n            // {tok}\n            uint192 bal = coll.bal(account);\n\n            // {tok/BU} = {ref/BU} / {ref/tok}.  0-division averted by condition above.\n            uint192 q = basket.refAmts[basket.erc20s[i]].div(refPerTok, CEIL);\n\n            // {BU} = {tok} / {tok/BU}.  q > 0 because q = (n).div(_, CEIL) and n > 0\n            baskets = fixMin(baskets, bal.div(q));\n        }\n    }\n\n    /* _switchBasket computes basket' from three inputs:\n       - the basket configuration (config: BasketConfig)\n       - the function (isGood: erc20 -> bool), implemented here by goodCollateral()\n       - the function (targetPerRef: erc20 -> Fix) implemented by the Collateral plugin\n\n       ==== Definitions ==="
    }
  ]
}