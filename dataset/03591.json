{
  "Title": "[L03] Duplicated code",
  "Content": "There are instances of duplicated code within the codebase. Duplicating code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors. Errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical. Examples of duplicated code include:\n\n\n* The whole [`Vault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/Vault.sol#L4) library is duplicated inside [IRibbonThetaVaultâ€™s file](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/interfaces/IRibbonThetaVault.sol#L5).\n* Some of the functions of the vendored `DSMath` library are duplicated inside [GnosisAuction](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/GnosisAuction.sol#L251) and [VaultLifecycle](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L522), albeit with different names.\n\n\nInstead of duplicating code, consider having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.\n\n\n**Update**: *Fixed in commit [`e1ec5868835ee2ed718668695157bea11f209553` of PR#90](https://github.com/ribbon-finance/ribbon-v2/pull/90/commits/e1ec5868835ee2ed718668695157bea11f209553).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\n\nlibrary Vault {\n    struct VaultParams {\n        // Option type the vault is selling\n        bool isPut;\n        // Token decimals for vault shares\n        uint8 decimals;\n        // Asset used in Theta / Delta Vault\n        address asset;\n        // Underlying asset of the options sold by vault\n        address underlying;\n        // Minimum supply of the vault shares issued, for ETH it's 10**10\n        uint56 minimumSupply;\n        // Vault cap\n        uint104 cap;\n        // If migrating from existing vault, allows for smooth migration\n        uint256 initialSharePrice;\n    }\n\n    struct OptionState {\n        // Option that the vault is shorting / longing in the next cycle\n        address nextOption;\n        // Option that the vault is currently shorting / longing\n        address currentOption;\n        // The timestamp when the `nextOption` can be used by the vault\n        uint32 nextOptionReadyAt;\n    }\n\n    struct VaultState {\n        // 32 byte slot 1\n        //  Current round number. `round` represents the number of `period`s elapsed.\n        uint16 round;\n        // Amount that is currently locked for selling options\n        uint104 lockedAmount;\n        // Amount that was locked for selling options in the previous round\n        // used for calculating performance fee deduction\n        uint104 lastLockedAmount;\n        // 32 byte slot 2\n        // Stores the total tally of how much of collateral there is\n        // to be used to mint rTHETA tokens\n        uint128 totalPending;\n        // Amount locked for scheduled withdrawals;\n        uint128 queuedWithdrawShares;\n    }\n\n    struct DepositReceipt {\n        // Flag to mark if processed or not\n        bool processed;\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\n        uint16 round;\n        // Deposit amount, max 20,282,409,603,651 or 20 trillion ETH deposit\n        uint104 amount;\n        // Unredeemed shares balance\n        uint128 unredeemedShares;\n    }\n\n    struct Withdrawal {\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\n        uint16 round;\n        // Number of shares withdrawn\n        uint128 shares;\n    }\n\n    struct AuctionSellOrder {\n        // Amount of `asset` token offered in auction\n        uint96 sellAmount;\n        // Amount of oToken requested in auction\n        uint96 buyAmount;\n        // User Id of delta vault in latest gnosis auction\n        uint64 userId;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/GnosisAuction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {IGnosisAuction} from \"../interfaces/IGnosisAuction.sol\";\nimport {IOtoken} from \"../interfaces/GammaInterface.sol\";\nimport {IOptionsPremiumPricer} from \"../interfaces/IRibbon.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {IRibbonThetaVault} from \"../interfaces/IRibbonThetaVault.sol\";\n\nlibrary GnosisAuction {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event InitiateGnosisAuction(\n        address auctioningToken,\n        address biddingToken,\n        uint256 auctionCounter,\n        address manager\n    );\n\n    event PlaceAuctionBid(\n        uint256 auctionId,\n        address auctioningToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        address bidder\n    );\n\n    struct AuctionDetails {\n        address oTokenAddress;\n        address gnosisEasyAuction;\n        address asset;\n        uint256 assetDecimals;\n        uint256 oTokenPremium;\n        uint256 duration;\n    }\n\n    struct BidDetails {\n        address oTokenAddress;\n        address gnosisEasyAuction;\n        address asset;\n        uint256 assetDecimals;\n        uint256 auctionId;\n        uint256 lockedBalance;\n        uint256 optionAllocationPct;\n        uint256 optionPremium;\n        address bidder;\n    }\n\n    function startAuction(AuctionDetails calldata auctionDetails)\n        internal\n        returns (uint256 auctionID)\n    {\n        uint256 oTokenSellAmount =\n            getOTokenSellAmount(auctionDetails.oTokenAddress);\n\n        IERC20(auctionDetails.oTokenAddress).safeApprove(\n            auctionDetails.gnosisEasyAuction,\n            IERC20(auctionDetails.oTokenAddress).balanceOf(address(this))\n        );\n\n        // minBidAmount is total oTokens to sell * premium per oToken\n        // shift decimals to correspond to decimals of USDC for puts\n        // and underlying for calls\n        uint256 minBidAmount =\n            dswmul(oTokenSellAmount.mul(10**10), auctionDetails.oTokenPremium)\n                .div(10**(uint256(18).sub(auctionDetails.assetDecimals)));\n\n        require(\n            minBidAmount <= type(uint96).max,\n            \"optionPremium * oTokenSellAmount > type(uint96) max value!\"\n        );\n\n        auctionID = IGnosisAuction(auctionDetails.gnosisEasyAuction)\n            .initiateAuction(\n            // address of oToken we minted and are selling\n            auctionDetails.oTokenAddress,\n            // address of asset we want in exchange for oTokens. Should match vault collateral\n            auctionDetails.asset,\n            // orders can be cancelled before the auction's halfway point\n            block.timestamp.add(auctionDetails.duration.div(2)),\n            // order will last for `duration`\n            block.timestamp.add(auctionDetails.duration),\n            // we are selling all of the otokens minus a fee taken by gnosis\n            uint96(oTokenSellAmount),\n            // the minimum we are willing to sell all the oTokens for. A discount is applied on black-scholes price\n            uint96(minBidAmount),\n            // the minimum bidding amount must be 1 * 10 ** -assetDecimals\n            1,\n            // the min funding threshold\n            0,\n            // no atomic closure\n            false,\n            // access manager contract\n            address(0),\n            // bytes for storing info like a whitelist for who can bid\n            bytes(\"\")\n        );\n\n        emit InitiateGnosisAuction(\n            auctionDetails.oTokenAddress,\n            auctionDetails.asset,\n            auctionID,\n            msg.sender\n        );\n    }\n\n    function placeBid(BidDetails calldata bidDetails)\n        internal\n        returns (\n            uint256 sellAmount,\n            uint256 buyAmount,\n            uint64 userId\n        )\n    {\n        // calculate how much to allocate\n        sellAmount = bidDetails\n            .lockedBalance\n            .mul(bidDetails.optionAllocationPct)\n            .div(10000);\n\n        // divide the `asset` sellAmount by the target premium per oToken to\n        // get the number of oTokens to buy (8 decimals)\n        buyAmount = sellAmount\n            .mul(10**bidDetails.assetDecimals)\n            .div(bidDetails.optionPremium)\n            .mul(10**8)\n            .div(10**bidDetails.assetDecimals);\n\n        require(\n            sellAmount <= type(uint96).max,\n            \"sellAmount > type(uint96) max value!\"\n        );\n        require(\n            buyAmount <= type(uint96).max,\n            \"buyAmount > type(uint96) max value!\"\n        );\n\n        // approve that amount\n        IERC20(bidDetails.asset).safeApprove(\n            bidDetails.gnosisEasyAuction,\n            sellAmount\n        );\n\n        uint96[] memory _minBuyAmounts = new uint96[](1);\n        uint96[] memory _sellAmounts = new uint96[](1);\n        bytes32[] memory _prevSellOrders = new bytes32[](1);\n        _minBuyAmounts[0] = uint96(buyAmount);\n        _sellAmounts[0] = uint96(sellAmount);\n        _prevSellOrders[\n            0\n        ] = 0x0000000000000000000000000000000000000000000000000000000000000001;\n\n        // place sell order with that amount\n        userId = IGnosisAuction(bidDetails.gnosisEasyAuction).placeSellOrders(\n            bidDetails.auctionId,\n            _minBuyAmounts,\n            _sellAmounts,\n            _prevSellOrders,\n            \"0x\"\n        );\n\n        emit PlaceAuctionBid(\n            bidDetails.auctionId,\n            bidDetails.oTokenAddress,\n            sellAmount,\n            buyAmount,\n            bidDetails.bidder\n        );\n    }\n\n    function claimAuctionOtokens(\n        Vault.AuctionSellOrder calldata auctionSellOrder,\n        address gnosisEasyAuction,\n        address counterpartyThetaVault\n    ) internal {\n        bytes32 order =\n            encodeOrder(\n                auctionSellOrder.userId,\n                auctionSellOrder.buyAmount,\n                auctionSellOrder.sellAmount\n            );\n        bytes32[] memory orders = new bytes32[](1);\n        orders[0] = order;\n        IGnosisAuction(gnosisEasyAuction).claimFromParticipantOrder(\n            IRibbonThetaVault(counterpartyThetaVault).optionAuctionID(),\n            orders\n        );\n    }\n\n    function getOTokenSellAmount(address oTokenAddress)\n        internal\n        view\n        returns (uint256 oTokenSellAmount)\n    {\n        // We take our current oToken balance. That will be our sell amount\n        // but gnosis will transfer all the otokens\n        oTokenSellAmount = IERC20(oTokenAddress).balanceOf(address(this));\n\n        require(\n            oTokenSellAmount <= type(uint96).max,\n            \"oTokenSellAmount > type(uint96) max value!\"\n        );\n    }\n\n    function getOTokenPremium(\n        address oTokenAddress,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount\n    ) internal view returns (uint256 optionPremium) {\n        IOtoken newOToken = IOtoken(oTokenAddress);\n        IOptionsPremiumPricer premiumPricer =\n            IOptionsPremiumPricer(optionsPremiumPricer);\n\n        // Apply black-scholes formula (from rvol library) to option given its features\n        // and get price for 100 contracts denominated in the underlying asset for call option\n        // and USDC for put option\n        optionPremium = premiumPricer.getPremium(\n            newOToken.strikePrice(),\n            newOToken.expiryTimestamp(),\n            newOToken.isPut()\n        );\n\n        // Apply a discount to incentivize arbitraguers\n        optionPremium = optionPremium.mul(premiumDiscount).div(1000);\n\n        require(\n            optionPremium <= type(uint96).max,\n            \"optionPremium > type(uint96) max value!\"\n        );\n    }\n\n    function encodeOrder(\n        uint64 userId,\n        uint96 buyAmount,\n        uint96 sellAmount\n    ) internal pure returns (bytes32) {\n        return\n            bytes32(\n                (uint256(userId) << 192) +\n                    (uint256(buyAmount) << 96) +\n                    uint256(sellAmount)\n            );\n    }\n\n    /***\n     * DSMath Copy paste\n     */\n\n    uint256 constant DSWAD = 10**18;\n\n    function dsadd(uint256 x, uint256 y) private pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function dsmul(uint256 x, uint256 y) private pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function dswmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = dsadd(dsmul(x, y), DSWAD / 2) / DSWAD;\n    }\n}"
    }
  ]
}