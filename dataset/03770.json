{
  "Title": "[M01] Governance can be tricked into performing external calls to a malicious contract",
  "Content": "The [`Incentivizer` contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/incentivizer/Incentivizer.sol#L35) allows the protocol to give rewards to users that stake underlying assets.\n\n\nIn case of having unused assets by the `Incentivizer` contract, the governance can call the [`rescue` function](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/incentivizer/Incentivizer.sol#L176) transferring those into the [reserve](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveImpl.sol#L31).\n\n\nHowever, this opens a backdoor which a malicious user could exploit. An user could create a malicious contract that simulates to be a ERC20 compliant token that deposits tokens in the `Incentivizer` contract, and when the governance passes a proposal to rescue those tokens and send them into the reserve, an [external call to the malicious contract will be executed](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/incentivizer/Incentivizer.sol#L179) without checks on the other end.\n\n\nFurthermore, once received into the reserve, the governance could [create an order to swap](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveSwapper.sol#L57) them and when the attacker makes the call to the `swap` function from the `ReserveSwapper` contract, the [malicious external call would now be originated](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveSwapper.sol#L87) from the reserve.\n\n\nAlthough the contract is shielded by the [OpenZeppelinâ€™s `ReentrancyGuard` contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveSwapper.sol#L23) and no funds cannot be moved with this attack, reducing the attack surface on the code, and specially on contracts that handle the assets such as the `ReserveSwapper` and the `Incentivizer` contracts, is always recommendable to prevent that future versions of the protocol could be affected by this attack.\n\n\nMoreover, as discussed in the introduction, the `ReentrancyGuard` shield has been removed from the code while the audit was being performed.\n\n\nConsider restricting the possibility to perform external calls to untrusted contracts to reduce the attack surfaces in the protocol.\n\n\n***Update**: Acknowledged. The EmptySetSquad team statement for this issue:*\n\n\n\n> \n> *Updated docs with a guide on acceptable ERC20 properties for [governance](https://emptysetsquad.gitbook.io/continuous-esd/governance).*\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/incentivizer/Incentivizer.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../lib/Decimal.sol\";\n\n/**\n * @title Incentivizer\n * @notice Generic incentivization contract that allows one ERC20 to be staked while earning\n *         either the same ERC20 or a different ERC20 as a reward\n * @dev Reward program can be adjusted or ended at any time through governance as long as there\n *      is sufficient balance. Architecture based off the Synthetix StakingRewards contract:\n *      https://github.com/Synthetixio/synthetix/blob/master/contracts/StakingRewards.sol\n */\ncontract Incentivizer is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Decimal for Decimal.D256;\n\n    /**\n     * @notice Emitted when the reward program is updated with a rate `rate` completing `complete`\n     */\n    event RewardProgramUpdate(uint256 rate, uint256 complete);\n\n    /**\n     * @notice Emitted when the owner rescues `amount` of `token`\n     */\n    event Rescue(address token, uint256 amount);\n\n    /**\n     * @notice Emitted on reward accrual when `newReward` reward tokens are dispersed at\n     *         timestamp `updated`, updating the rewards per unit to `rewardPerUnit`\n     */\n    event Settle(uint256 rewardPerUnit, uint256 newReward, uint256 updated);\n\n    /**\n     * @notice Emitted on when `account` stakes `amount` of the underlying token\n     */\n    event Stake(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` withdraws `amount` of the underlying token\n     */\n    event Withdrawal(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` claims `amount` of the reward token\n     */\n    event Claim(address account, uint256 amount);\n\n    /**\n     * @notice Address to receive rescued and refunded funds\n     */\n    address public reserve;\n\n    /**\n     * @notice ERC20 token that will be used as underlying for staking\n     */\n    IERC20 public underlyingToken;\n\n    /**\n     * @notice ERC20 token that will be dispersed as rewards\n     */\n    IERC20 public rewardToken;\n\n    /**\n     * @notice Quantity of  rewardToken` dispersed to the entire staking pool per second\n     */\n    uint256 public rewardRate;\n\n    /**\n     * @notice Timestamp the current reward program ends\n     */\n    uint256 public rewardComplete;\n\n    /**\n     * @notice Timestamp that reward accrual was last settled\n     */\n    uint256 public rewardUpdated;\n\n    /**\n     * @notice Mapping of underlying token balance per account\n     */\n    mapping(address => uint256) public balanceOfUnderlying;\n\n    /**\n     * @notice Total underlying token balance staked in this contract\n     */\n    uint256 public totalUnderlying;\n\n    /**\n     * @notice Total outstanding unclaimed rewards that have accrued so far\n     */\n    uint256 public totalReward;\n\n    /**\n     * @notice Mapping of settled reward balance per account\n     */\n    mapping(address => uint256) internal _reward;\n\n    /**\n     * @notice Mapping of rewards already paid out per account\n     */\n    mapping(address => Decimal.D256) internal _paid;\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     */\n    Decimal.D256 internal _rewardPerUnit;\n\n\n    /**\n     * @notice Constructs the Incentivizer\n     * @param underlying_ Underlying ERC20 token for staking\n     * @param reward_ Reward ERC20 token for rewards\n     * @notice reserve_ Address to receive rescued and refunded ERC20 tokens\n     */\n    constructor(IERC20 underlying_, IERC20 reward_, address reserve_) public {\n        reserve = reserve_;\n        underlyingToken = underlying_;\n        rewardToken = reward_;\n    }\n\n    // ADMIN\n\n    /**\n     * @notice Updates the rate and completion time for this contract's reward program\n     * @dev Owner only - governance hook\n     *      Insufficient funds will revert - excess funds will be refunded to {reserve}\n     * @param rate Reward token amount to disperse to enter staking pool per second\n     * @param complete Timestamp the reward program ends\n     */\n    function updateRewardProgram(uint256 rate, uint256 complete) external onlyOwner {\n        require(complete > block.timestamp, \"Incentivizer: already ended\");\n\n        settle();\n\n        // Set new reward rate\n        (rewardRate, rewardComplete, rewardUpdated) = (rate, complete, block.timestamp);\n\n        // Return rewards in excess of the required amount\n        rewardToken.safeTransfer(reserve, verifyRewardBalance());\n\n        emit RewardProgramUpdate(rate, complete);\n    }\n\n    /**\n     * @notice Allows the owner to withdraw stuck ERC20 tokens to {reserve}\n     * @dev Owner only - governance hook\n     *      Non-reentrant\n     *      Cannot withdraw the underlying token\n     *      Cannot withdraw more of the reward token than is needed for the current reward program\n     * @param token ERC20 token to withdraw\n     * @param amount Amount to withdraw\n     */\n    function rescue(address token, uint256 amount) external nonReentrant onlyOwner {\n        require(token != address(underlyingToken), \"Incentivizer: underlying token\");\n\n        IERC20(token).safeTransfer(reserve, amount);\n\n        verifyRewardBalance();\n\n        emit Rescue(token, amount);\n    }\n\n    /**\n     * @notice Verifies that there is sufficient reward tokens for the current reward program\n     * @dev Internal only - helper\n     *      Reverts if there is insufficient reward token funds\n     */\n    function verifyRewardBalance() private view returns (uint256) {\n        return _totalRewardBalance()\n            .sub(totalReward, \"Incentivizer: insufficient rewards\")\n            .sub(totalProvisionedReward(), \"Incentivizer: insufficient rewards\");\n    }\n\n    // FLYWHEEL\n\n    /**\n     * @notice Total rewards that have been provisioned for the current reward program,\n     *         but not yet settled or paid out\n     * @return Total provisioned rewards\n     */\n    function totalProvisionedReward() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 updated = rewardUpdated;\n\n        return complete > updated ? complete.sub(updated).mul(rewardRate) : 0;\n    }\n\n    /**\n     * @notice Returns either the current timestamp or the last applicable timestamp of the reward program\n     * @return Most recent reward-applicable timestamp\n     */\n    function nowOrComplete() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 latest = block.timestamp;\n\n        return latest > complete ? complete : latest;\n    }\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     * @dev Computes the current effective rewardPerUnit value as if there was a settlement now\n     * @return Effective rewards per unit\n     */\n    function rewardPerUnit() public view returns (Decimal.D256 memory) {\n        if (totalUnderlying == 0) {\n            return _rewardPerUnit;\n        } else {\n            return _rewardPerUnit\n                .add(Decimal.from(nowOrComplete().sub(rewardUpdated).mul(rewardRate)).div(totalUnderlying));\n        }\n    }\n\n    /**\n     * @notice Accrues and updates rewards since last settlement\n     * @dev Internal only\n     */\n    function settle() internal {\n        uint256 nowOrComplete = nowOrComplete();\n        Decimal.D256 memory newRewardPerUnit = rewardPerUnit();\n        uint256 newReward = newRewardPerUnit.sub(_rewardPerUnit).mul(totalUnderlying).asUint256();\n        uint256 newTotalReward = totalReward.add(newReward);\n\n        _rewardPerUnit = newRewardPerUnit;\n        totalReward = newTotalReward;\n        rewardUpdated = nowOrComplete;\n\n        emit Settle(newRewardPerUnit.value, newReward, nowOrComplete);\n    }\n\n    /**\n     * @notice Accrues and records rewards for `account` to simplify accounting math\n     * @dev Internal only\n     * @param account Account to settle rewards for\n     */\n    function settleAccount(address account) internal {\n        settle();\n\n        _reward[account] = balanceOfReward(account);\n        _paid[account] = _rewardPerUnit;\n    }\n\n    // EXTERNAL\n\n    /**\n     * @notice Balance of all accrued rewards (including unsettled) for `account`\n     * @param account Account to retrieve balance for\n     */\n    function balanceOfReward(address account) public view returns (uint256) {\n        return _reward[account].add(\n            rewardPerUnit().sub(_paid[account])      // Since last checkpoint\n                .mul(balanceOfUnderlying[account])   // Multiply per unit\n                .asUint256()                         // Convert and truncate\n        );\n    }\n\n    /**\n     * @notice Deposit `amount` underlying tokens to start accruing rewards\n     * @dev Non-reentrant\n     * @param amount Amount of underlying tokens for the caller to deposit\n     */\n    function stake(uint256 amount) external nonReentrant {\n        settleAccount(msg.sender);\n\n        // Increment account balance\n        balanceOfUnderlying[msg.sender] = balanceOfUnderlying[msg.sender].add(amount);\n        totalUnderlying = totalUnderlying.add(amount);\n\n        // Transfer in token amount\n        underlyingToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(msg.sender, amount);\n    }\n\n    /**\n     * @notice Withdraw `amount` underlying tokens\n     * @dev Non-reentrant\n     * @param amount Amount of underlying tokens for the caller to withdraw\n     */\n    function withdraw(uint256 amount) public nonReentrant {\n        settleAccount(msg.sender);\n\n        // Decrement account balance\n        balanceOfUnderlying[msg.sender] = balanceOfUnderlying[msg.sender].sub(amount, \"Incentivizer: insufficient balance\");\n        totalUnderlying = totalUnderlying.sub(amount, \"Incentivizer: insufficient balance\");\n\n        // Transfer out token amount\n        underlyingToken.safeTransfer(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Claim all accrued reward tokens for caller\n     * @dev Non-reentrant\n     */\n    function claim() public nonReentrant {\n        settleAccount(msg.sender);\n\n        uint256 rewardBalance = _reward[msg.sender];\n        rewardToken.safeTransfer(msg.sender, rewardBalance);\n\n        _reward[msg.sender] = 0;\n        totalReward = totalReward.sub(rewardBalance);\n\n        emit Claim(msg.sender, rewardBalance);\n    }\n\n    /**\n     * @notice Claim all accrued reward tokens withdraw all underlying tokens for caller\n     */\n    function exit() external {\n        withdraw(balanceOfUnderlying[msg.sender]);\n        claim();\n    }\n\n    // INTERNAL\n\n    /**\n     * @notice Total reward token holdings of this contract\n     * @dev If reward token == underlying token, this will subtract the total underlying amount from the balance\n     * @dev Internal only - helper\n     */\n    function _totalRewardBalance() private view returns (uint256) {\n        if (underlyingToken == rewardToken) {\n            uint256 totalBalance = rewardToken.balanceOf(address(this));\n            return totalBalance > totalUnderlying ? totalBalance - totalUnderlying : 0;\n        }\n\n        return rewardToken.balanceOf(address(this));\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/incentivizer/Incentivizer.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../lib/Decimal.sol\";\n\n/**\n * @title Incentivizer\n * @notice Generic incentivization contract that allows one ERC20 to be staked while earning\n *         either the same ERC20 or a different ERC20 as a reward\n * @dev Reward program can be adjusted or ended at any time through governance as long as there\n *      is sufficient balance. Architecture based off the Synthetix StakingRewards contract:\n *      https://github.com/Synthetixio/synthetix/blob/master/contracts/StakingRewards.sol\n */\ncontract Incentivizer is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Decimal for Decimal.D256;\n\n    /**\n     * @notice Emitted when the reward program is updated with a rate `rate` completing `complete`\n     */\n    event RewardProgramUpdate(uint256 rate, uint256 complete);\n\n    /**\n     * @notice Emitted when the owner rescues `amount` of `token`\n     */\n    event Rescue(address token, uint256 amount);\n\n    /**\n     * @notice Emitted on reward accrual when `newReward` reward tokens are dispersed at\n     *         timestamp `updated`, updating the rewards per unit to `rewardPerUnit`\n     */\n    event Settle(uint256 rewardPerUnit, uint256 newReward, uint256 updated);\n\n    /**\n     * @notice Emitted on when `account` stakes `amount` of the underlying token\n     */\n    event Stake(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` withdraws `amount` of the underlying token\n     */\n    event Withdrawal(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` claims `amount` of the reward token\n     */\n    event Claim(address account, uint256 amount);\n\n    /**\n     * @notice Address to receive rescued and refunded funds\n     */\n    address public reserve;\n\n    /**\n     * @notice ERC20 token that will be used as underlying for staking\n     */\n    IERC20 public underlyingToken;\n\n    /**\n     * @notice ERC20 token that will be dispersed as rewards\n     */\n    IERC20 public rewardToken;\n\n    /**\n     * @notice Quantity of  rewardToken` dispersed to the entire staking pool per second\n     */\n    uint256 public rewardRate;\n\n    /**\n     * @notice Timestamp the current reward program ends\n     */\n    uint256 public rewardComplete;\n\n    /**\n     * @notice Timestamp that reward accrual was last settled\n     */\n    uint256 public rewardUpdated;\n\n    /**\n     * @notice Mapping of underlying token balance per account\n     */\n    mapping(address => uint256) public balanceOfUnderlying;\n\n    /**\n     * @notice Total underlying token balance staked in this contract\n     */\n    uint256 public totalUnderlying;\n\n    /**\n     * @notice Total outstanding unclaimed rewards that have accrued so far\n     */\n    uint256 public totalReward;\n\n    /**\n     * @notice Mapping of settled reward balance per account\n     */\n    mapping(address => uint256) internal _reward;\n\n    /**\n     * @notice Mapping of rewards already paid out per account\n     */\n    mapping(address => Decimal.D256) internal _paid;\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     */\n    Decimal.D256 internal _rewardPerUnit;\n\n\n    /**\n     * @notice Constructs the Incentivizer\n     * @param underlying_ Underlying ERC20 token for staking\n     * @param reward_ Reward ERC20 token for rewards\n     * @notice reserve_ Address to receive rescued and refunded ERC20 tokens\n     */\n    constructor(IERC20 underlying_, IERC20 reward_, address reserve_) public {\n        reserve = reserve_;\n        underlyingToken = underlying_;\n        rewardToken = reward_;\n    }\n\n    // ADMIN\n\n    /**\n     * @notice Updates the rate and completion time for this contract's reward program\n     * @dev Owner only - governance hook\n     *      Insufficient funds will revert - excess funds will be refunded to {reserve}\n     * @param rate Reward token amount to disperse to enter staking pool per second\n     * @param complete Timestamp the reward program ends\n     */\n    function updateRewardProgram(uint256 rate, uint256 complete) external onlyOwner {\n        require(complete > block.timestamp, \"Incentivizer: already ended\");\n\n        settle();\n\n        // Set new reward rate\n        (rewardRate, rewardComplete, rewardUpdated) = (rate, complete, block.timestamp);\n\n        // Return rewards in excess of the required amount\n        rewardToken.safeTransfer(reserve, verifyRewardBalance());\n\n        emit RewardProgramUpdate(rate, complete);\n    }\n\n    /**\n     * @notice Allows the owner to withdraw stuck ERC20 tokens to {reserve}\n     * @dev Owner only - governance hook\n     *      Non-reentrant\n     *      Cannot withdraw the underlying token\n     *      Cannot withdraw more of the reward token than is needed for the current reward program\n     * @param token ERC20 token to withdraw\n     * @param amount Amount to withdraw\n     */\n    function rescue(address token, uint256 amount) external nonReentrant onlyOwner {\n        require(token != address(underlyingToken), \"Incentivizer: underlying token\");\n\n        IERC20(token).safeTransfer(reserve, amount);\n\n        verifyRewardBalance();\n\n        emit Rescue(token, amount);\n    }\n\n    /**\n     * @notice Verifies that there is sufficient reward tokens for the current reward program\n     * @dev Internal only - helper\n     *      Reverts if there is insufficient reward token funds\n     */\n    function verifyRewardBalance() private view returns (uint256) {\n        return _totalRewardBalance()\n            .sub(totalReward, \"Incentivizer: insufficient rewards\")\n            .sub(totalProvisionedReward(), \"Incentivizer: insufficient rewards\");\n    }\n\n    // FLYWHEEL\n\n    /**\n     * @notice Total rewards that have been provisioned for the current reward program,\n     *         but not yet settled or paid out\n     * @return Total provisioned rewards\n     */\n    function totalProvisionedReward() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 updated = rewardUpdated;\n\n        return complete > updated ? complete.sub(updated).mul(rewardRate) : 0;\n    }\n\n    /**\n     * @notice Returns either the current timestamp or the last applicable timestamp of the reward program\n     * @return Most recent reward-applicable timestamp\n     */\n    function nowOrComplete() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 latest = block.timestamp;\n\n        return latest > complete ? complete : latest;\n    }\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     * @dev Computes the current effective rewardPerUnit value as if there was a settlement now\n     * @return Effective rewards per unit\n     */\n    function rewardPerUnit() public view returns (Decimal.D256 memory) {\n        if (totalUnderlying == 0) {\n            return _rewardPerUnit;\n        } else {\n            return _rewardPerUnit\n                .add(Decimal.from(nowOrComplete().sub(rewardUpdated).mul(rewardRate)).div(totalUnderlying));\n        }\n    }\n\n    /**\n     * @notice Accrues and updates rewards since last settlement\n     * @dev Internal only\n     */\n    function settle() internal {\n        uint256 nowOrComplete = nowOrComplete();\n        Decimal.D256 memory newRewardPerUnit = rewardPerUnit();\n        uint256 newReward = newRewardPerUnit.sub(_rewardPerUnit).mul(totalUnderlying).asUint256();\n        uint256 newTotalReward = totalReward.add(newReward);\n\n        _rewardPerUnit = newRewardPerUnit;\n        totalReward = newTotalReward;\n        rewardUpdated = nowOrComplete;\n\n        emit Settle(newRewardPerUnit.value, newReward, nowOrComplete);\n    }\n\n    /**\n     * @notice Accrues and records rewards for `account` to simplify accounting math\n     * @dev Internal only\n     * @param account Account to settle rewards for\n     */\n    function settleAccount(address account) internal {\n        settle();\n\n        _reward[account] = balanceOfReward(account);\n        _paid[account] = _rewardPerUnit;\n    }\n\n    // EXTERNAL\n\n    /**\n     * @notice Balance of all accrued rewards (including unsettled) for `account`\n     * @param account Account to retrieve balance for\n     */\n    function balanceOfReward(address account) public view returns (uint256) {\n        return _reward[account].add(\n            rewardPerUnit().sub(_paid[account])      // Since last checkpoint\n                .mul(balanceOfUnderlying[account])   // Multiply per unit\n                .asUint256()                         // Convert and truncate\n        );\n    }\n\n    /**\n     * @notice Deposit `amount` underlying tokens to start accruing rewards\n     * @dev Non-reentrant\n     * @param amount Amount of underlying tokens for the caller to deposit\n     */\n    function stake(uint256 amount) external nonReentrant {\n        settleAccount(msg.sender);\n\n        // Increment account balance\n        balanceOfUnderlying[msg.sender] = balanceOfUnderlying[msg.sender].add(amount);\n        totalUnderlying = totalUnderlying.add(amount);\n\n        // Transfer in token amount\n        underlyingToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(msg.sender, amount);\n    }\n\n    /**\n     * @notice Withdraw `amount` underlying tokens\n     * @dev Non-reentrant\n     * @param amount Amount of underlying tokens for the caller to withdraw\n     */\n    function withdraw(uint256 amount) public nonReentrant {\n        settleAccount(msg.sender);\n\n        // Decrement account balance\n        balanceOfUnderlying[msg.sender] = balanceOfUnderlying[msg.sender].sub(amount, \"Incentivizer: insufficient balance\");\n        totalUnderlying = totalUnderlying.sub(amount, \"Incentivizer: insufficient balance\");\n\n        // Transfer out token amount\n        underlyingToken.safeTransfer(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Claim all accrued reward tokens for caller\n     * @dev Non-reentrant\n     */\n    function claim() public nonReentrant {\n        settleAccount(msg.sender);\n\n        uint256 rewardBalance = _reward[msg.sender];\n        rewardToken.safeTransfer(msg.sender, rewardBalance);\n\n        _reward[msg.sender] = 0;\n        totalReward = totalReward.sub(rewardBalance);\n\n        emit Claim(msg.sender, rewardBalance);\n    }\n\n    /**\n     * @notice Claim all accrued reward tokens withdraw all underlying tokens for caller\n     */\n    function exit() external {\n        withdraw(balanceOfUnderlying[msg.sender]);\n        claim();\n    }\n\n    // INTERNAL\n\n    /**\n     * @notice Total reward token holdings of this contract\n     * @dev If reward token == underlying token, this will subtract the total underlying amount from the balance\n     * @dev Internal only - helper\n     */\n    function _totalRewardBalance() private view returns (uint256) {\n        if (underlyingToken == rewardToken) {\n            uint256 totalBalance = rewardToken.balanceOf(address(this));\n            return totalBalance > totalUnderlying ? totalBalance - totalUnderlying : 0;\n        }\n\n        return rewardToken.balanceOf(address(this));\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/incentivizer/Incentivizer.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../lib/Decimal.sol\";\n\n/**\n * @title Incentivizer\n * @notice Generic incentivization contract that allows one ERC20 to be staked while earning\n *         either the same ERC20 or a different ERC20 as a reward\n * @dev Reward program can be adjusted or ended at any time through governance as long as there\n *      is sufficient balance. Architecture based off the Synthetix StakingRewards contract:\n *      https://github.com/Synthetixio/synthetix/blob/master/contracts/StakingRewards.sol\n */\ncontract Incentivizer is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Decimal for Decimal.D256;\n\n    /**\n     * @notice Emitted when the reward program is updated with a rate `rate` completing `complete`\n     */\n    event RewardProgramUpdate(uint256 rate, uint256 complete);\n\n    /**\n     * @notice Emitted when the owner rescues `amount` of `token`\n     */\n    event Rescue(address token, uint256 amount);\n\n    /**\n     * @notice Emitted on reward accrual when `newReward` reward tokens are dispersed at\n     *         timestamp `updated`, updating the rewards per unit to `rewardPerUnit`\n     */\n    event Settle(uint256 rewardPerUnit, uint256 newReward, uint256 updated);\n\n    /**\n     * @notice Emitted on when `account` stakes `amount` of the underlying token\n     */\n    event Stake(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` withdraws `amount` of the underlying token\n     */\n    event Withdrawal(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` claims `amount` of the reward token\n     */\n    event Claim(address account, uint256 amount);\n\n    /**\n     * @notice Address to receive rescued and refunded funds\n     */\n    address public reserve;\n\n    /**\n     * @notice ERC20 token that will be used as underlying for staking\n     */\n    IERC20 public underlyingToken;\n\n    /**\n     * @notice ERC20 token that will be dispersed as rewards\n     */\n    IERC20 public rewardToken;\n\n    /**\n     * @notice Quantity of  rewardToken` dispersed to the entire staking pool per second\n     */\n    uint256 public rewardRate;\n\n    /**\n     * @notice Timestamp the current reward program ends\n     */\n    uint256 public rewardComplete;\n\n    /**\n     * @notice Timestamp that reward accrual was last settled\n     */\n    uint256 public rewardUpdated;\n\n    /**\n     * @notice Mapping of underlying token balance per account\n     */\n    mapping(address => uint256) public balanceOfUnderlying;\n\n    /**\n     * @notice Total underlying token balance staked in this contract\n     */\n    uint256 public totalUnderlying;\n\n    /**\n     * @notice Total outstanding unclaimed rewards that have accrued so far\n     */\n    uint256 public totalReward;\n\n    /**\n     * @notice Mapping of settled reward balance per account\n     */\n    mapping(address => uint256) internal _reward;\n\n    /**\n     * @notice Mapping of rewards already paid out per account\n     */\n    mapping(address => Decimal.D256) internal _paid;\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     */\n    Decimal.D256 internal _rewardPerUnit;\n\n\n    /**\n     * @notice Constructs the Incentivizer\n     * @param underlying_ Underlying ERC20 token for staking\n     * @param reward_ Reward ERC20 token for rewards\n     * @notice reserve_ Address to receive rescued and refunded ERC20 tokens\n     */\n    constructor(IERC20 underlying_, IERC20 reward_, address reserve_) public {\n        reserve = reserve_;\n        underlyingToken = underlying_;\n        rewardToken = reward_;\n    }\n\n    // ADMIN\n\n    /**\n     * @notice Updates the rate and completion time for this contract's reward program\n     * @dev Owner only - governance hook\n     *      Insufficient funds will revert - excess funds will be refunded to {reserve}\n     * @param rate Reward token amount to disperse to enter staking pool per second\n     * @param complete Timestamp the reward program ends\n     */\n    function updateRewardProgram(uint256 rate, uint256 complete) external onlyOwner {\n        require(complete > block.timestamp, \"Incentivizer: already ended\");\n\n        settle();\n\n        // Set new reward rate\n        (rewardRate, rewardComplete, rewardUpdated) = (rate, complete, block.timestamp);\n\n        // Return rewards in excess of the required amount\n        rewardToken.safeTransfer(reserve, verifyRewardBalance());\n\n        emit RewardProgramUpdate(rate, complete);\n    }\n\n    /**\n     * @notice Allows the owner to withdraw stuck ERC20 tokens to {reserve}\n     * @dev Owner only - governance hook\n     *      Non-reentrant\n     *      Cannot withdraw the underlying token\n     *      Cannot withdraw more of the reward token than is needed for the current reward program\n     * @param token ERC20 token to withdraw\n     * @param amount Amount to withdraw\n     */\n    function rescue(address token, uint256 amount) external nonReentrant onlyOwner {\n        require(token != address(underlyingToken), \"Incentivizer: underlying token\");\n\n        IERC20(token).safeTransfer(reserve, amount);\n\n        verifyRewardBalance();\n\n        emit Rescue(token, amount);\n    }\n\n    /**\n     * @notice Verifies that there is sufficient reward tokens for the current reward program\n     * @dev Internal only - helper\n     *      Reverts if there is insufficient reward token funds\n     */\n    function verifyRewardBalance() private view returns (uint256) {\n        return _totalRewardBalance()\n            .sub(totalReward, \"Incentivizer: insufficient rewards\")\n            .sub(totalProvisionedReward(), \"Incentivizer: insufficient rewards\");\n    }\n\n    // FLYWHEEL\n\n    /**\n     * @notice Total rewards that have been provisioned for the current reward program,\n     *         but not yet settled or paid out\n     * @return Total provisioned rewards\n     */\n    function totalProvisionedReward() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 updated = rewardUpdated;\n\n        return complete > updated ? complete.sub(updated).mul(rewardRate) : 0;\n    }\n\n    /**\n     * @notice Returns either the current timestamp or the last applicable timestamp of the reward program\n     * @return Most recent reward-applicable timestamp\n     */\n    function nowOrComplete() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 latest = block.timestamp;\n\n        return latest > complete ? complete : latest;\n    }\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     * @dev Computes the current effective rewardPerUnit value as if there was a settlement now\n     * @return Effective rewards per unit\n     */\n    function rewardPerUnit() public view returns (Decimal.D256 memory) {\n        if (totalUnderlying == 0) {\n            return _rewardPerUnit;\n        } else {\n            return _rewardPerUnit\n                .add(Decimal.from(nowOrComplete().sub(rewardUpdated).mul(rewardRate)).div(totalUnderlying));\n        }\n    }\n\n    /**\n     * @notice Accrues and updates rewards since last settlement\n     * @dev Internal only\n     */\n    function settle() internal {\n        uint256 nowOrComplete = nowOrComplete();\n        Decimal.D256 memory newRewardPerUnit = rewardPerUnit();\n        uint256 newReward = newRewardPerUnit.sub(_rewardPerUnit).mul(totalUnderlying).asUint25"
    }
  ]
}