{
  "Title": "[M01] Multiple iterations of the same transfer can occur",
  "Content": "The [`TransferWhitelist` contract](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/common/TransferWhitelist.sol) implements the functionality to [store “a whitelist of addresses for which transfers should not be frozen so that network initialization can take place”](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/common/TransferWhitelist.sol#L8-L9).\n\n\nNevertheless, the [`whitelistAddress` function](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/common/TransferWhitelist.sol#L30) does not check if the `newAddress` to be pushed into the `directlyWhitelistedAddresses` array was already added to it, making it possible to whitelist multiple times the same address.\n\n\nBecause these addresses can be used to perform transfers, if contracts that use this array do not check if there are multiple intances of the same address, then it could use the array from the [`getWhitelist` outcome](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/common/TransferWhitelist.sol#L104) and re-do multiple same transactions during the execution.\n\n\nAlthough this contract only allows whitelist changes when the owner calls it, a mistake from the owner while adding addresses could end up with severe repercussions.\n\n\nConsider validating the input parameters to check that no-other element in the arrays match with the `newAddress` parameter. Furthermore, consider complementing the array with a mapping to keep track of the whitelisted addresses and restrict the possibility for those that are already flagged up.\n\n\n***Update**: Acknowledged, and will not fix. Affected contract was only used once and it is not going to be used again. The cLabs team’s response was:*\n\n\n\n> \n> The `TransferWhitelist` contract has been deprecated. It was used to bootstrap the network and enable features in phases but will not be used again.\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/TransferWhitelist.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./UsingRegistry.sol\";\n\n/**\n * @title Holds a whitelist of addresses for which transfers should not be\n * frozen so that network initialization can take place.\n */\ncontract TransferWhitelist is Ownable, UsingRegistry {\n  using SafeMath for uint256;\n\n  address[] private directlyWhitelistedAddresses;\n  bytes32[] public whitelistedContractIdentifiers;\n\n  event WhitelistedAddress(address indexed addr);\n  event WhitelistedAddressRemoved(address indexed addr);\n  event WhitelistedContractIdentifier(bytes32 indexed contractIdentifier);\n\n  constructor(address registryAddress) public {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Add an address to the whitelist.\n   * @param newAddress The address to add.\n   */\n  function whitelistAddress(address newAddress) public onlyOwner {\n    directlyWhitelistedAddresses.push(newAddress);\n    emit WhitelistedAddress(newAddress);\n  }\n\n  /**\n   * @notice Remove an address from the whitelist.\n   * @param removedAddress The address to add.\n   * @param index Index of address in the whitelist.\n   */\n  function removeAddress(address removedAddress, uint256 index) external onlyOwner {\n    require(index < directlyWhitelistedAddresses.length, \"Whitelist index out of range\");\n    require(directlyWhitelistedAddresses[index] == removedAddress, \"Bad whitelist index\");\n    uint256 tailIndex = directlyWhitelistedAddresses.length.sub(1);\n    if (index != tailIndex) {\n      directlyWhitelistedAddresses[index] = directlyWhitelistedAddresses[tailIndex];\n    }\n    directlyWhitelistedAddresses.length = tailIndex;\n    emit WhitelistedAddressRemoved(removedAddress);\n  }\n\n  /**\n   * @notice Adds the registry id of a whitelisted contract.\n   * @param contractIdentifier The id of the contract to be added.\n   */\n  function whitelistRegisteredContract(bytes32 contractIdentifier) external onlyOwner {\n    require(\n      registry.getAddressFor(contractIdentifier) != address(0),\n      \"contractIdentifier does not correspond to a registered address\"\n    );\n    whitelistedContractIdentifiers.push(contractIdentifier);\n    emit WhitelistedContractIdentifier(contractIdentifier);\n  }\n\n  /**\n   * @notice Gets the number of registered contracts\n   * @return The length of whitelistedContractIdentifiers\n   */\n  function getNumberOfWhitelistedContractIdentifiers() external view returns (uint256 length) {\n    return whitelistedContractIdentifiers.length;\n  }\n\n  /**\n   * @notice Set the whitelist of addresses.\n   * @param  _whitelist The new whitelist of addresses.\n   */\n  function setDirectlyWhitelistedAddresses(address[] calldata _whitelist) external onlyOwner {\n    for (uint256 i = 0; i < directlyWhitelistedAddresses.length; i = i.add(1)) {\n      emit WhitelistedAddressRemoved(directlyWhitelistedAddresses[i]);\n    }\n    directlyWhitelistedAddresses.length = 0;\n    for (uint256 i = 0; i < _whitelist.length; i = i.add(1)) {\n      whitelistAddress(_whitelist[i]);\n    }\n  }\n\n  /**\n   * @notice Set the whitelist of registered contracts.\n   * @param  _registeredContracts The new whitelist of registered contract ids.\n   */\n  function setWhitelistedContractIdentifiers(bytes32[] calldata _registeredContracts)\n    external\n    onlyOwner\n  {\n    whitelistedContractIdentifiers = _registeredContracts;\n  }\n\n  /**\n   * @notice Appends the addresses of registered contracts to the\n   * whitelist before returning the list.\n   * @dev If a registry id is not yet registered, the null address\n   * will be appended to the list instead.\n   * @return  The full whitelist of addresses.\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    uint256 len = directlyWhitelistedAddresses.length.add(whitelistedContractIdentifiers.length);\n    address[] memory _whitelist = new address[](len);\n    uint256 i = 0;\n    while (i < directlyWhitelistedAddresses.length) {\n      _whitelist[i] = directlyWhitelistedAddresses[i];\n      i = i.add(1);\n    }\n    for (uint256 j = 0; j < whitelistedContractIdentifiers.length; j = j.add(1)) {\n      _whitelist[i] = registry.getAddressFor(whitelistedContractIdentifiers[j]);\n      i = i.add(1);\n    }\n    return _whitelist;\n  }\n\n  /**\n   * @notice Clears all data (storage and bytecode) at this contract's address.\n   * @dev The balance of this contract is returned to the owner.\n   */\n  function selfDestruct() external onlyOwner {\n    selfdestruct(msg.sender);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/TransferWhitelist.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./UsingRegistry.sol\";\n\n/**\n * @title Holds a whitelist of addresses for which transfers should not be\n * frozen so that network initialization can take place.\n */\ncontract TransferWhitelist is Ownable, UsingRegistry {\n  using SafeMath for uint256;\n\n  address[] private directlyWhitelistedAddresses;\n  bytes32[] public whitelistedContractIdentifiers;\n\n  event WhitelistedAddress(address indexed addr);\n  event WhitelistedAddressRemoved(address indexed addr);\n  event WhitelistedContractIdentifier(bytes32 indexed contractIdentifier);\n\n  constructor(address registryAddress) public {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Add an address to the whitelist.\n   * @param newAddress The address to add.\n   */\n  function whitelistAddress(address newAddress) public onlyOwner {\n    directlyWhitelistedAddresses.push(newAddress);\n    emit WhitelistedAddress(newAddress);\n  }\n\n  /**\n   * @notice Remove an address from the whitelist.\n   * @param removedAddress The address to add.\n   * @param index Index of address in the whitelist.\n   */\n  function removeAddress(address removedAddress, uint256 index) external onlyOwner {\n    require(index < directlyWhitelistedAddresses.length, \"Whitelist index out of range\");\n    require(directlyWhitelistedAddresses[index] == removedAddress, \"Bad whitelist index\");\n    uint256 tailIndex = directlyWhitelistedAddresses.length.sub(1);\n    if (index != tailIndex) {\n      directlyWhitelistedAddresses[index] = directlyWhitelistedAddresses[tailIndex];\n    }\n    directlyWhitelistedAddresses.length = tailIndex;\n    emit WhitelistedAddressRemoved(removedAddress);\n  }\n\n  /**\n   * @notice Adds the registry id of a whitelisted contract.\n   * @param contractIdentifier The id of the contract to be added.\n   */\n  function whitelistRegisteredContract(bytes32 contractIdentifier) external onlyOwner {\n    require(\n      registry.getAddressFor(contractIdentifier) != address(0),\n      \"contractIdentifier does not correspond to a registered address\"\n    );\n    whitelistedContractIdentifiers.push(contractIdentifier);\n    emit WhitelistedContractIdentifier(contractIdentifier);\n  }\n\n  /**\n   * @notice Gets the number of registered contracts\n   * @return The length of whitelistedContractIdentifiers\n   */\n  function getNumberOfWhitelistedContractIdentifiers() external view returns (uint256 length) {\n    return whitelistedContractIdentifiers.length;\n  }\n\n  /**\n   * @notice Set the whitelist of addresses.\n   * @param  _whitelist The new whitelist of addresses.\n   */\n  function setDirectlyWhitelistedAddresses(address[] calldata _whitelist) external onlyOwner {\n    for (uint256 i = 0; i < directlyWhitelistedAddresses.length; i = i.add(1)) {\n      emit WhitelistedAddressRemoved(directlyWhitelistedAddresses[i]);\n    }\n    directlyWhitelistedAddresses.length = 0;\n    for (uint256 i = 0; i < _whitelist.length; i = i.add(1)) {\n      whitelistAddress(_whitelist[i]);\n    }\n  }\n\n  /**\n   * @notice Set the whitelist of registered contracts.\n   * @param  _registeredContracts The new whitelist of registered contract ids.\n   */\n  function setWhitelistedContractIdentifiers(bytes32[] calldata _registeredContracts)\n    external\n    onlyOwner\n  {\n    whitelistedContractIdentifiers = _registeredContracts;\n  }\n\n  /**\n   * @notice Appends the addresses of registered contracts to the\n   * whitelist before returning the list.\n   * @dev If a registry id is not yet registered, the null address\n   * will be appended to the list instead.\n   * @return  The full whitelist of addresses.\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    uint256 len = directlyWhitelistedAddresses.length.add(whitelistedContractIdentifiers.length);\n    address[] memory _whitelist = new address[](len);\n    uint256 i = 0;\n    while (i < directlyWhitelistedAddresses.length) {\n      _whitelist[i] = directlyWhitelistedAddresses[i];\n      i = i.add(1);\n    }\n    for (uint256 j = 0; j < whitelistedContractIdentifiers.length; j = j.add(1)) {\n      _whitelist[i] = registry.getAddressFor(whitelistedContractIdentifiers[j]);\n      i = i.add(1);\n    }\n    return _whitelist;\n  }\n\n  /**\n   * @notice Clears all data (storage and bytecode) at this contract's address.\n   * @dev The balance of this contract is returned to the owner.\n   */\n  function selfDestruct() external onlyOwner {\n    selfdestruct(msg.sender);\n  }\n}"
    }
  ]
}