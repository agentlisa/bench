{
  "Title": "[L-4] We should check the `totals[token].total` when rescuing tokens in the `BlastOnboarding`",
  "Content": "\nWhen rescuing tokens, we only check whether this token is supported.\nIf it is not a supported token, the `owner` can claim any amounts.\nhttps://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/blast/BlastOnboarding.sol#L205-L212\n```\nfunction rescue(address token, address to, uint256 amount) external onlyOwner {\n    if (supportedTokens[token]) {\n        revert ErrNotAllowed();\n    }\n    token.safeTransfer(to, amount);\n    emit LogTokenRescue(token, to, amount);\n}\n```\nThere might be a scenario as follows:\n`Token A` is initially set as a `supported` token.\nUsers deposit some amounts.\nAfter some time, this token is set as `unsupported`.\nAs a result, the owner can claim this token, and therefore users who deposited it cannot `claim` their tokens.\n\nPlease add below additional check.\n```\nfunction rescue(address token, address to, uint256 amount) external onlyOwner {\n+    if (amount > IERC20(token).balanceOf(address(this)) - totals[token].total) revert();\n-     if (supportedTokens[token]) {\n-         revert ErrNotAllowed();\n-     }\n    token.safeTransfer(to, amount);\n    emit LogTokenRescue(token, to, amount);\n}\n```\nBy doing this, the `owner` can claim the donated `supported` tokens also.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "src/blast/BlastOnboarding.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {BlastYields} from \"/blast/libraries/BlastYields.sol\";\nimport {BlastTokenRegistry} from \"/blast/BlastTokenRegistry.sol\";\nimport {Proxy} from \"openzeppelin-contracts/proxy/Proxy.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {BlastPoints} from \"/blast/libraries/BlastPoints.sol\";\nimport {Pausable} from \"openzeppelin-contracts/security/Pausable.sol\";\n\ncontract BlastOnboardingData is Owned, Pausable {\n    error ErrZeroAddress();\n    error ErrWrongState();\n    error ErrUnsupportedToken();\n    error ErrNotAllowed();\n\n    enum State {\n        Idle,\n        Opened,\n        Closed\n    }\n\n    struct Balances {\n        uint256 unlocked;\n        uint256 locked;\n        uint256 total;\n    }\n\n    State public state;\n    address public bootstrapper;\n    address public feeTo;\n    BlastTokenRegistry public registry;\n\n    // Global\n    mapping(address token => bool) public supportedTokens;\n    mapping(address token => Balances) public totals;\n    mapping(address token => uint256 cap) public caps;\n\n    // Per-user\n    mapping(address user => mapping(address token => Balances)) public balances;\n\n    modifier onlyState(State _state) {\n        if (state != _state) {\n            revert ErrWrongState();\n        }\n        _;\n    }\n\n    modifier onlySupportedTokens(address token) {\n        if (!supportedTokens[token]) {\n            revert ErrUnsupportedToken();\n        }\n\n        _;\n    }\n\n    constructor() Owned(msg.sender) {\n        BlastYields.configureDefaultClaimables(address(this));\n        BlastPoints.configure();\n    }\n}\n\ncontract BlastOnboarding is BlastOnboardingData, Proxy {\n    using SafeTransferLib for address;\n\n    event LogBootstrapperChanged(address indexed bootstrapper);\n    event LogTokenSupported(address indexed token, bool supported);\n    event LogDeposit(address indexed user, address indexed token, uint256 amount, bool lock);\n    event LogLock(address indexed user, address indexed token, uint256 amount);\n    event LogFeeToChanged(address indexed feeTo);\n    event LogWithdraw(address indexed user, address indexed token, uint256 amount);\n    event LogTokenCapChanged(address indexed token, uint256 cap);\n    event LogStateChange(State state);\n    event LogTokenRescue(address indexed token, address indexed to, uint256 amount);\n\n    error ErrUnsupported();\n    error ErrCapReached();\n\n    receive() external payable override {\n        revert ErrUnsupported();\n    }\n\n    constructor(BlastTokenRegistry registry_, address feeTo_) {\n        if (address(registry_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        if (feeTo_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        registry = registry_;\n        feeTo = feeTo_;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function deposit(address token, uint256 amount, bool lock_) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        if (lock_) {\n            totals[token].locked += amount;\n            balances[msg.sender][token].locked += amount;\n        } else {\n            totals[token].unlocked += amount;\n            balances[msg.sender][token].unlocked += amount;\n        }\n\n        totals[token].total += amount;\n\n        if (caps[token] > 0 && totals[token].total > caps[token]) {\n            revert ErrCapReached();\n        }\n\n        balances[msg.sender][token].total += amount;\n\n        emit LogDeposit(msg.sender, token, amount, lock_);\n    }\n\n    function lock(address token, uint256 amount) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {\n        balances[msg.sender][token].unlocked -= amount;\n        balances[msg.sender][token].locked += amount;\n        totals[token].unlocked -= amount;\n        totals[token].locked += amount;\n\n        emit LogLock(msg.sender, token, amount);\n    }\n\n    function withdraw(address token, uint256 amount) external whenNotPaused onlySupportedTokens(token) {\n        balances[msg.sender][token].unlocked -= amount;\n        balances[msg.sender][token].total -= amount;\n        totals[token].unlocked -= amount;\n        totals[token].total -= amount;\n\n        token.safeTransfer(msg.sender, amount);\n\n        emit LogWithdraw(msg.sender, token, amount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setFeeTo(address feeTo_) external onlyOwner {\n        if (feeTo_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        feeTo = feeTo_;\n        emit LogFeeToChanged(feeTo_);\n    }\n\n    function callBlastPrecompile(bytes calldata data) external onlyOwner {\n        BlastYields.callPrecompile(data);\n    }\n\n    function claimGasYields() external onlyOwner returns (uint256) {\n        return BlastYields.claimMaxGasYields(feeTo);\n    }\n\n    function claimTokenYields(address[] memory tokens) external onlyOwner {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (!supportedTokens[tokens[i]]) {\n                revert ErrUnsupportedToken();\n            }\n            if (registry.nativeYieldTokens(tokens[i])) {\n                BlastYields.claimAllTokenYields(tokens[i], feeTo);\n            }\n        }\n    }\n\n    function setTokenSupported(address token, bool supported) external onlyOwner {\n        supportedTokens[token] = supported;\n\n        if (registry.nativeYieldTokens(token)) {\n            BlastYields.enableTokenClaimable(token);\n        }\n\n        emit LogTokenSupported(token, supported);\n    }\n\n    function setCap(address token, uint256 cap) external onlyOwner onlySupportedTokens(token) {\n        caps[token] = cap;\n        emit LogTokenCapChanged(token, cap);\n    }\n\n    function setBootstrapper(address bootstrapper_) external onlyOwner {\n        bootstrapper = bootstrapper_;\n        emit LogBootstrapperChanged(bootstrapper_);\n    }\n\n    function open() external onlyOwner onlyState(State.Idle) {\n        state = State.Opened;\n        emit LogStateChange(State.Opened);\n    }\n\n    function close() external onlyOwner onlyState(State.Opened) {\n        state = State.Closed;\n        emit LogStateChange(State.Closed);\n    }\n\n    function rescue(address token, address to, uint256 amount) external onlyOwner {\n        if (supportedTokens[token]) {\n            revert ErrNotAllowed();\n        }\n\n        token.safeTransfer(to, amount);\n        emit LogTokenRescue(token, to, amount);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PROXY IMPLEMENTATION\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _implementation() internal view override returns (address) {\n        return address(bootstrapper);\n    }\n}"
    }
  ]
}