{
  "Title": "M-1: BalancerPairOracle#getPrice will revert due to division by zero in some cases",
  "Content": "# Issue M-1: BalancerPairOracle#getPrice will revert due to division by zero in some cases \n\nSource: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/25 \n\n## Found by \n0x52, nobody2018\n## Summary\n\n`BalancerPairOracle#getPrice` internally calls `computeFairReserves`, which returns fair reserve amounts given spot reserves, weights, and fair prices. When the parameter `resA` passed to `computeFairReserves` is smaller than `resB`, division by 0 will occur.\n\n## Vulnerability Detail\n\nIn `BalancerPairOracle#getPrice`, resA and resB passed to `computeFairReserves` are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n\n```solidity\nfunction computeFairReserves(\n        uint256 resA,\n        uint256 resB,\n        uint256 wA,\n        uint256 wB,\n        uint256 pxA,\n        uint256 pxB\n    ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n    \t...\n    \t//@audit r0 = 0 when resA < resB.\n->      uint256 r0 = resA / resB;\n        uint256 r1 = (wA * pxB) / (wB * pxA);\n        // fairResA = resA * (r1 / r0) ^ wB\n        // fairResB = resB * (r0 / r1) ^ wA\n        if (r0 > r1) {\n            uint256 ratio = r1 / r0;\n            fairResA = resA * (ratio ** wB);\n            fairResB = resB / (ratio ** wA);\n        } else {\n->          uint256 ratio = r0 / r1;\t\t// radio = 0 when r0 = 0\n->          fairResA = resA / (ratio ** wB);   \t// revert divided by 0\n            fairResB = resB * (ratio ** wA);\n        }\n    }\n```\n\nAnother case is **when the decimals of tokenA is smaller than the decimals of tokenB**, such as usdc(e6)-weth(e18).\n\n## Impact\n\nAll functions that subcall `BalancerPairOracle#getPrice` will be affected.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L35-L66\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\n--- a/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n+++ b/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n@@ -50,7 +50,7 @@ contract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n         // --> fairResA / r1^wB = constant product\n         // --> fairResA = resA^wA * resB^wB * r1^wB\n         // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n-        uint256 r0 = resA / resB;\n+        uint256 r0 = resA * 10**(decimalsB) / resB;\n         uint256 r1 = (wA * pxB) / (wB * pxA);\n         // fairResA = resA * (r1 / r0) ^ wB\n         // fairResB = resB * (r0 / r1) ^ wA\n```\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 USDC\nThis is a valid M/H. Please review **Vulnerability Detail** of this report, it describes 2 cases:\n1. resA and resB passed to computeFairReserves are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n2. when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18).\n\n**This issue is same root as #28**.\nThe impact described in #28 is only possible if the dp of the two tokens are different. But it is not completely correct, because when the dp of token0 is less than the dp of token1, a division by zero error occurs, such as token0(e6)-token1(e18).\nMerging the two reports is the best description.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is a valid M/H. Please review **Vulnerability Detail** of this report, it describes 2 cases:\n> 1. resA and resB passed to computeFairReserves are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n> 2. when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18).\n> \n> **This issue is same root as #28**.\n> The impact described in #28 is only possible if the dp of the two tokens are different. But it is not completely correct, because when the dp of token0 is less than the dp of token1, a division by zero error occurs, such as token0(e6)-token1(e18).\n> Merging the two reports is the best description.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nAgreed with escalation. This and #28 are dupes and this does a better job of describing the issue so it should be the main issue. Additionally given that the contract would become nonfunctional rather than return an incorrect price, I agree with the watson's original severity of medium.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nMaking this issue the main one and #28 a duplicate of this issue. \n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Making this issue the main one and #28 a duplicate of this issue. \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/77",
  "Code": [
    {
      "filename": "blueberry-core/contracts/oracle/BalancerPairOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/balancer/IBalancerVault.sol\";\n\n/**\n * @author BlueberryProtocol\n * @title Balancer Pair Oracle\n * @notice Oracle contract which privides price feeds of Balancer Pair tokens\n * @dev Implented Fair Lp Pricing\n *      Ref: https://blog.alphaventuredao.io/fair-lp-token-pricing/\n */\ncontract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /// @notice Return fair reserve amounts given spot reserves, weights, and fair prices.\n    /// @param resA Reserve of the first asset\n    /// @param resB Reserve of the second asset\n    /// @param wA Weight of the first asset\n    /// @param wB Weight of the second asset\n    /// @param pxA Fair price of the first asset\n    /// @param pxB Fair price of the second asset\n    function computeFairReserves(\n        uint256 resA,\n        uint256 resB,\n        uint256 wA,\n        uint256 wB,\n        uint256 pxA,\n        uint256 pxB\n    ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n        // NOTE: wA + wB = 1 (normalize weights)\n        // constant product = resA^wA * resB^wB\n        // constraints:\n        // - fairResA^wA * fairResB^wB = constant product\n        // - fairResA * pxA / wA = fairResB * pxB / wB\n        // Solving equations:\n        // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n        // --> fairResA / r1^wB = constant product\n        // --> fairResA = resA^wA * resB^wB * r1^wB\n        // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n        uint256 r0 = resA / resB;\n        uint256 r1 = (wA * pxB) / (wB * pxA);\n        // fairResA = resA * (r1 / r0) ^ wB\n        // fairResB = resB * (r0 / r1) ^ wA\n        if (r0 > r1) {\n            uint256 ratio = r1 / r0;\n            fairResA = resA * (ratio ** wB);\n            fairResB = resB / (ratio ** wA);\n        } else {\n            uint256 ratio = r0 / r1;\n            fairResA = resA / (ratio ** wB);\n            fairResB = resB * (ratio ** wA);\n        }\n    }\n\n    /// @notice Return the USD value of given Curve Lp, with 18 decimals of precision.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external view override returns (uint256) {\n        IBalancerPool pool = IBalancerPool(token);\n        IBalancerVault vault = IBalancerVault(pool.getVault());\n        (address[] memory tokens, uint256[] memory balances, ) = vault\n            .getPoolTokens(pool.getPoolId());\n        uint256[] memory weights = pool.getNormalizedWeights();\n        require(tokens.length == 2, \"num tokens must be 2\");\n        address tokenA = tokens[0];\n        address tokenB = tokens[1];\n        uint256 price0 = base.getPrice(tokenA);\n        uint256 price1 = base.getPrice(tokenB);\n        (uint256 fairResA, uint256 fairResB) = computeFairReserves(\n            balances[0],\n            balances[1],\n            weights[0],\n            weights[1],\n            price0,\n            price1\n        );\n        // use fairReserveA and fairReserveB to compute LP token price\n        // LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n        return (fairResA * price0 + fairResB * price1) / pool.totalSupply();\n    }\n}"
    }
  ]
}