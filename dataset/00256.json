{
  "Title": "Deprecated pool BEAN:WETH on LibBarnRaise used as fallback",
  "Content": "# Deprecated pool BEAN:WETH on LibBarnRaise used as fallback\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/a3d702c2e108cac6ebdf2416906cbca73c83ec99/protocol/contracts/libraries/LibBarnRaise.sol#L26-L29\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/a3d702c2e108cac6ebdf2416906cbca73c83ec99/protocol/contracts/libraries/LibBarnRaise.sol#L26-L29</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/a3d702c2e108cac6ebdf2416906cbca73c83ec99/protocol/contracts/beanstalk/init/InitMigrateUnripeBeanEthToBeanSteth.sol#L67C23-L67C46\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/a3d702c2e108cac6ebdf2416906cbca73c83ec99/protocol/contracts/beanstalk/init/InitMigrateUnripeBeanEthToBeanSteth.sol#L67C23-L67C46</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/a3d702c2e108cac6ebdf2416906cbca73c83ec99/protocol/contracts/libraries/LibFertilizer.sol#L250\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/a3d702c2e108cac6ebdf2416906cbca73c83ec99/protocol/contracts/libraries/LibFertilizer.sol#L250</a>\n\n\n## Summary\nThe protocol will migrate the Bean:WETH Well LP to Bean:wsETH Well LP after initializing the bip migration: \n\nInitMigrateUnripeBeanEthToBeanSteth -> LibFertilizer -> beginBarnRaiseMigration -> switchUnderlyingToken\n```solidity\nLibUnripe.switchUnderlyingToken(C.UNRIPE_LP, well);\n```\n\nThis will change the underlying token of `C.UNRIPE_LP` to the new Bean:wsETH pool. \n\n## Vulnerability Details\nWhenever `getBarnRaiseWell` uses a fallback underlyingToken, the correct pool to be returned should be the new one added `Bean:wsETH` not `Bean:WETH`. But currently, the `Bean:WETH` pool is used.\n\n## Impact\nAs the `getBarnRaiseWell` is used in several areas of the protocol like: \n- Token conversions(`LibConvert`)\n- Calculate BDV\n- Calculate the caseId\n\nWhenever the fallback `underlyingToken` is used it will completely break the protocol logic as Bean:WETH is not the current underlying token after the migration. \n\n## PoC\nAdd the following test inside `BeanEthToBeanWstethMigration.test.js` -> 'Initializes migration'\n\n```javascript\ndescribe('When the fallback unlderyingToken is used', async function () {\n      it('should return valid fallback token', async function () {\n        await this.beanstalk.connect(owner).switchUnderlyingToken(UNRIPE_LP, ethers.constants.AddressZero)\n        expect(await this.beanstalk.getBarnRaiseToken()).to.be.equal(WSTETH)\n      })\n    })\n```\n\nOutput: \n```markdown\n21 passing (19s)\n  1 failing\n\n  1) Bean:Eth to Bean:Wsteth Migration\n       Initializes migration\n         When the fallback unlderyingToken is used\n           should return valid fallback token:\n\n      AssertionError: expected '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C7…' to equal '0x7f39C581F595B53c5cb19bD0b3f8dA6c935…'\n      + expected - actual\n\n      -0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n      +0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0\n```\n\n## Tools Used\nHardhard & Manual Review\n\n## Recommendations\nAdd the `C.BEAN_WSTETH_WELL` as a fallback for the underlying token on `LibBarnRaise`. Also, ensure `C.BEAN_WSTETH_WELL` will have the correct address.\n\n```diff\nreturn\n            s.u[C.UNRIPE_LP].underlyingToken == address(0)\n-                ? C.BEAN_ETH_WELL\n+                ? C.BEAN_WSTETH_WELL\n                : s.u[C.UNRIPE_LP].underlyingToken;\n```\n",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clu7665bs0001fmt5yahc8tyh",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/LibBarnRaise.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IWell} from \"contracts/interfaces/basin/IWell.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {AppStorage, LibAppStorage} from \"contracts/libraries/LibAppStorage.sol\";\n\n\n/**\n * @title LibBarnRaise\n * @author Brendan\n * @notice Library fetching Barn Raise Token\n */\nlibrary LibBarnRaise {\n\n    function getBarnRaiseToken() internal view returns (address) {\n        IERC20[] memory tokens = IWell(getBarnRaiseWell()).tokens();\n        return address(address(tokens[0]) == C.BEAN ? tokens[1] : tokens[0]);\n    }\n\n    function getBarnRaiseWell() internal view returns (address) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return\n            s.u[C.UNRIPE_LP].underlyingToken == address(0)\n                ? C.BEAN_ETH_WELL\n                : s.u[C.UNRIPE_LP].underlyingToken;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/init/InitMigrateUnripeBeanEthToBeanSteth.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {AppStorage} from \"contracts/beanstalk/AppStorage.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {LibFertilizer} from \"contracts/libraries/LibFertilizer.sol\";\nimport {LibWhitelist} from \"contracts/libraries/Silo/LibWhitelist.sol\";\nimport {BDVFacet} from \"contracts/beanstalk/silo/BDVFacet.sol\";\nimport {ILiquidityWeightFacet} from \"contracts/beanstalk/sun/LiquidityWeightFacet.sol\";\nimport {IGaugePointFacet} from \"contracts/beanstalk/sun/GaugePointFacet.sol\";\n\n/**\n * Initializes the Migration of the Unripe LP underlying tokens from Bean:Eth to Bean:Steth.\n * It:\n * - Turns off Bean:Eth Minting while Multi Flow Pump catches up\n * - Whitelists Bean:WstETH\n * - Updates the optimal percent deposited for Bean:Eth\n * - Migrates the Unripe LP underlying tokens from Bean:Eth to Bean:Wsteth\n */\ncontract InitMigrateUnripeBeanEthToBeanSteth {\n\n    // The initial gauge points for Bean:WstETH.\n    uint128 internal constant BEAN_WSTETH_INITIAL_GAUGE_POINTS = 100e18;\n\n    // The amount of Seasons that Bean:Eth Minting will be off.\n    uint32 constant BEAN_ETH_PUMP_CATCH_UP_SEASONS = 24;\n\n    // The initial Stalk issued per BDV for all whitelisted Silo tokens.\n    uint32 constant private STALK_ISSUED_PER_BDV = 10000;\n\n    // The optimal percent deposited for Bean:Wsteth.\n    uint64 constant private OPTIMAL_PERCENT_DEPOSITED_BDV = 5e6;\n\n    // The total percent deposited BDV.\n    uint64 constant private MAX_PERCENT_DEPOSITED_BDV = 100e6;\n\n    AppStorage internal s;\n\n    function init() external {\n\n        // Turn off Bean:Eth Minting while Multi Flow Pump catches up\n        delete s.wellOracleSnapshots[C.BEAN_ETH_WELL];\n        s.season.beanEthStartMintingSeason = s.season.current + BEAN_ETH_PUMP_CATCH_UP_SEASONS;\n\n        LibWhitelist.whitelistToken(\n            C.BEAN_WSTETH_WELL,\n            BDVFacet.wellBdv.selector,\n            STALK_ISSUED_PER_BDV,\n            0, // No need to set Stalk issued per BDV\n            0x01,\n            IGaugePointFacet.defaultGaugePointFunction.selector,\n            ILiquidityWeightFacet.maxWeight.selector,\n            BEAN_WSTETH_INITIAL_GAUGE_POINTS,\n            OPTIMAL_PERCENT_DEPOSITED_BDV\n        );\n\n        LibWhitelist.updateOptimalPercentDepositedBdvForToken(\n            C.BEAN_ETH_WELL,\n            MAX_PERCENT_DEPOSITED_BDV - OPTIMAL_PERCENT_DEPOSITED_BDV\n        );\n\n        LibFertilizer.beginBarnRaiseMigration(C.BEAN_WSTETH_WELL);\n\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/LibFertilizer.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {AppStorage, LibAppStorage} from \"./LibAppStorage.sol\";\nimport {LibSafeMath128} from \"./LibSafeMath128.sol\";\nimport {C} from \"../C.sol\";\nimport {LibUnripe} from \"./LibUnripe.sol\";\nimport {IWell} from \"contracts/interfaces/basin/IWell.sol\";\nimport {LibBarnRaise} from \"./LibBarnRaise.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {LibWell} from \"contracts/libraries/Well/LibWell.sol\";\nimport {LibUsdOracle} from \"contracts/libraries/Oracle/LibUsdOracle.sol\";\n\n/**\n * @author Publius\n * @title Fertilizer\n **/\n\nlibrary LibFertilizer {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n    using LibWell for address;\n\n    event SetFertilizer(uint128 id, uint128 bpf);\n\n    // 6 - 3\n    uint128 private constant PADDING = 1e3;\n    uint128 private constant DECIMALS = 1e6;\n    uint128 private constant REPLANT_SEASON = 6074;\n    uint128 private constant RESTART_HUMIDITY = 2500;\n    uint128 private constant END_DECREASE_SEASON = REPLANT_SEASON + 461;\n\n    function addFertilizer(\n        uint128 season,\n        uint256 tokenAmountIn,\n        uint256 fertilizerAmount,\n        uint256 minLP\n    ) internal returns (uint128 id) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint128 fertilizerAmount128 = fertilizerAmount.toUint128();\n\n        // Calculate Beans Per Fertilizer and add to total owed\n        uint128 bpf = getBpf(season);\n        s.unfertilizedIndex = s.unfertilizedIndex.add(\n            fertilizerAmount.mul(bpf)\n        );\n        // Get id\n        id = s.bpf.add(bpf);\n        // Update Total and Season supply\n        s.fertilizer[id] = s.fertilizer[id].add(fertilizerAmount128);\n        s.activeFertilizer = s.activeFertilizer.add(fertilizerAmount);\n        // Add underlying to Unripe Beans and Unripe LP\n        addUnderlying(tokenAmountIn, fertilizerAmount.mul(DECIMALS), minLP);\n        // If not first time adding Fertilizer with this id, return\n        if (s.fertilizer[id] > fertilizerAmount128) return id;\n        // If first time, log end Beans Per Fertilizer and add to Season queue.\n        push(id);\n        emit SetFertilizer(id, bpf);\n    }\n\n    function getBpf(uint128 id) internal pure returns (uint128 bpf) {\n        bpf = getHumidity(id).add(1000).mul(PADDING);\n    }\n\n    function getHumidity(uint128 id) internal pure returns (uint128 humidity) {\n        if (id == 0) return 5000;\n        if (id >= END_DECREASE_SEASON) return 200;\n        uint128 humidityDecrease = id.sub(REPLANT_SEASON).mul(5);\n        humidity = RESTART_HUMIDITY.sub(humidityDecrease);\n    }\n\n    /**\n     * @dev Any token contributions should already be transferred to the Barn Raise Well to allow for a gas efficient liquidity\n     * addition through the use of `sync`. See {FertilizerFacet.mintFertilizer} for an example.\n     */\n    function addUnderlying(uint256 tokenAmountIn, uint256 usdAmount, uint256 minAmountOut) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // Calculate how many new Deposited Beans will be minted\n        uint256 percentToFill = usdAmount.mul(C.precision()).div(\n            remainingRecapitalization()\n        );\n\n        uint256 newDepositedBeans;\n        if (C.unripeBean().totalSupply() > s.u[C.UNRIPE_BEAN].balanceOfUnderlying) {\n            newDepositedBeans = (C.unripeBean().totalSupply()).sub(\n                s.u[C.UNRIPE_BEAN].balanceOfUnderlying\n            );\n            newDepositedBeans = newDepositedBeans.mul(percentToFill).div(\n                C.precision()\n            );\n        }\n\n        // Calculate how many Beans to add as LP\n        uint256 newDepositedLPBeans = usdAmount.mul(C.exploitAddLPRatio()).div(\n            DECIMALS\n        );\n\n        // Mint the Deposited Beans to Beanstalk.\n        C.bean().mint(\n            address(this),\n            newDepositedBeans\n        );\n\n        // Mint the LP Beans and add liquidity to the well.\n        address barnRaiseWell = LibBarnRaise.getBarnRaiseWell();\n        address barnRaiseToken = LibBarnRaise.getBarnRaiseToken();\n\n        C.bean().mint(\n            address(this),\n            newDepositedLPBeans\n        );\n\n        IERC20(barnRaiseToken).transferFrom(\n            msg.sender,\n            address(this),\n            uint256(tokenAmountIn)\n        );\n\n        IERC20(barnRaiseToken).approve(barnRaiseWell, uint256(tokenAmountIn));\n        C.bean().approve(barnRaiseWell, newDepositedLPBeans);\n\n        uint256[] memory tokenAmountsIn = new uint256[](2);\n        IERC20[] memory tokens = IWell(barnRaiseWell).tokens();\n        (tokenAmountsIn[0], tokenAmountsIn[1]) = tokens[0] == C.bean() ?\n            (newDepositedLPBeans, tokenAmountIn) :\n            (tokenAmountIn, newDepositedLPBeans);\n\n        uint256 newLP = IWell(barnRaiseWell).addLiquidity(\n            tokenAmountsIn,\n            minAmountOut,\n            address(this),\n            type(uint256).max\n        );\n\n        // Increment underlying balances of Unripe Tokens\n        LibUnripe.incrementUnderlying(C.UNRIPE_BEAN, newDepositedBeans);\n        LibUnripe.incrementUnderlying(C.UNRIPE_LP, newLP);\n\n        s.recapitalized = s.recapitalized.add(usdAmount);\n    }\n\n    function push(uint128 id) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (s.fFirst == 0) {\n            // Queue is empty\n            s.season.fertilizing = true;\n            s.fLast = id;\n            s.fFirst = id;\n        } else if (id <= s.fFirst) {\n            // Add to front of queue\n            setNext(id, s.fFirst);\n            s.fFirst = id;\n        } else if (id >= s.fLast) {\n            // Add to back of queue\n            setNext(s.fLast, id);\n            s.fLast = id;\n        } else {\n            // Add to middle of queue\n            uint128 prev = s.fFirst;\n            uint128 next = getNext(prev);\n            // Search for proper place in line\n            while (id > next) {\n                prev = next;\n                next = getNext(next);\n            }\n            setNext(prev, id);\n            setNext(id, next);\n        }\n    }\n\n    function remainingRecapitalization()\n        internal\n        view\n        returns (uint256 remaining)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 totalDollars = C\n            .dollarPerUnripeLP()\n            .mul(C.unripeLP().totalSupply())\n            .div(DECIMALS);\n        totalDollars = totalDollars / 1e6 * 1e6; // round down to nearest USDC\n        if (s.recapitalized >= totalDollars) return 0;\n        return totalDollars.sub(s.recapitalized);\n    }\n\n    function pop() internal returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint128 first = s.fFirst;\n        s.activeFertilizer = s.activeFertilizer.sub(getAmount(first));\n        uint128 next = getNext(first);\n        if (next == 0) {\n            // If all Unfertilized Beans have been fertilized, delete line.\n            require(s.activeFertilizer == 0, \"Still active fertilizer\");\n            s.fFirst = 0;\n            s.fLast = 0;\n            s.season.fertilizing = false;\n            return false;\n        }\n        s.fFirst = getNext(first);\n        return true;\n    }\n\n    function getAmount(uint128 id) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.fertilizer[id];\n    }\n\n    function getNext(uint128 id) internal view returns (uint128) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.nextFid[id];\n    }\n\n    function setNext(uint128 id, uint128 next) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.nextFid[id] = next;\n    }\n\n    function beginBarnRaiseMigration(address well) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(well.isWell(), \"Fertilizer: Not a Whitelisted Well.\");\n\n        // The Barn Raise only supports 2 token Wells where 1 token is Bean and the\n        // other is supported by the Lib Usd Oracle.\n        IERC20[] memory tokens = IWell(well).tokens();\n        require(tokens.length == 2, \"Fertilizer: Well must have 2 tokens.\");\n        require(\n            tokens[0] == C.bean() || tokens[1] == C.bean(),\n            \"Fertilizer: Well must have BEAN.\"\n        );\n        // Check that Lib Usd Oracle supports the non-Bean token in the Well.\n        LibUsdOracle.getTokenPrice(address(tokens[tokens[0] == C.bean() ? 1 : 0]));\n\n        uint256 balanceOfUnderlying = s.u[C.UNRIPE_LP].balanceOfUnderlying;\n        IERC20(s.u[C.UNRIPE_LP].underlyingToken).safeTransfer(\n            LibDiamond.diamondStorage().contractOwner,\n            balanceOfUnderlying\n        );\n        LibUnripe.decrementUnderlying(C.UNRIPE_LP, balanceOfUnderlying);\n        LibUnripe.switchUnderlyingToken(C.UNRIPE_LP, well);\n    }\n}"
    }
  ]
}